/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall sub_11008(__int64 a1, unsigned __int16 a2, __int64 a3);
__int64 __fastcall sub_1102C(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall sub_11068(__int64 a1, __int64 a2, __int64 a3, __int16 a4, __int64 a5);
__int64 __fastcall sub_111BC(__int64 a1, char a2, __int64 *a3, __int64 a4);
NTSTATUS __stdcall DriverEntry(_DRIVER_OBJECT *DriverObject, PUNICODE_STRING RegistryPath);
void __fastcall sub_11658(PDEVICE_OBJECT DeviceObject);
__int64 sub_118FC();
void sub_11B24();
__int64 sub_11BB4();
__int64 sub_11C4C();
__int64 __fastcall sub_1216C(__int64 a1);
char __fastcall sub_12298(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
__int64 __fastcall sub_12490(__int64 a1);
void __fastcall sub_12598(const signed __int32 *a1);
__int64 __fastcall sub_126B4(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 sub_1270C(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 __fastcall sub_127D0(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 sub_12818(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 __fastcall sub_12878(int a1, __int64 a2, __int64 a3, __int64 a4, int *a5);
__int64 __fastcall sub_12B2C(__int64 a1, __int64 a2, int *a3, int a4, __int64 a5, __int64 a6, int a7);
__int64 __fastcall sub_12C30(int a1, unsigned __int64 *a2);
__int64 __fastcall sub_12D54(int a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5);
__int64 __fastcall sub_12EC4(int a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_13068(__int64 a1);
__int64 __fastcall sub_1314C(unsigned __int64 a1);
__int64 __fastcall sub_132A0(int a1, __int64 a2, int a3, _DWORD *a4, void **a5, _DWORD *a6);
__int64 __fastcall sub_13420(int a1, __int64 a2, __int64 a3, _DWORD *a4, _QWORD *a5, _DWORD *a6);
__int64 __fastcall sub_13618(__int64 a1, unsigned __int16 a2, __int64 a3, const char *a4);
void __fastcall sub_13678(__int64 *a1);
__int64 __fastcall sub_13830(__int64 a1);
void __fastcall sub_13A5C(__int64 a1);
void __fastcall sub_13F34(__int64 *a1);
void __fastcall sub_140EC(_QWORD *a1);
__int64 __fastcall sub_142F4(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 sub_1434C(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_143A4(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_143EC(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_14440();
__int64 sub_146C4();
__int64 sub_1486C();
__int64 __fastcall sub_14A2C(const char *a1, int a2, char a3);
void sub_14DA8();
__int64 __fastcall sub_14E80(__int64 a1, PVOID *a2, unsigned int *a3);
__int64 __fastcall sub_15250(__int64 a1);
__int64 __fastcall sub_15538(__int64 a1, __int64 a2, int *a3, __int64 a4);
__int64 __fastcall sub_1589C(__int64 a1);
__int64 __fastcall sub_15FB8(__int64 a1, __int64 a2, unsigned __int8 *a3);
unsigned __int8 __fastcall sub_1609C(__int64 a1, __int64 a2, __int64 a3);
unsigned __int8 __fastcall sub_16220(__int64 a1, __int64 a2);
__int64 __fastcall sub_163F4(unsigned __int64 a1);
bool __fastcall sub_1660C(wchar_t *Str1, __int64 a2, const wchar_t *a3);
unsigned __int8 __fastcall sub_166F8(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_16A88(int a1);
__int64 __fastcall sub_16C40(const signed __int32 *a1);
__int64 __fastcall sub_16DA0(PVOID **a1);
__int64 __fastcall sub_16F38(PVOID **a1);
__int64 __fastcall sub_17050(__int64 a1, __int64 a2);
__int64 __fastcall sub_171A0(PVOID *a1);
__int64 __fastcall sub_173BC(__int64 *a1, PVOID *a2, unsigned int *a3);
__int64 __fastcall sub_17608(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_176E4(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 sub_17814(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 __fastcall sub_17860(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4);
__int64 __fastcall sub_178E0(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 sub_17984(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_179C0(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_17A34(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_17AB4(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 __fastcall sub_17B40(__int64 a1, __int64 a2, __int64 a3, const char *a4, _WORD *a5);
__int64 __fastcall sub_17C08(__int64 a1, unsigned __int16 a2, __int64 a3, const char *a4, const char *a5);
__int64 __fastcall sub_17CB8(__int64 *a1, __int64 a2);
__int64 __fastcall sub_19244(__int64 *a1);
__int64 __fastcall sub_19344(__int64 a1, int a2, __int64 *a3);
__int64 __fastcall sub_196F0(__int64 a1, __int64 a2);
__int64 __fastcall sub_198E8(__int64 a1, __int64 a2, __int64 *a3);
__int64 __fastcall sub_19B54(_QWORD *a1);
__int64 __fastcall sub_19CAC(__int64 a1);
__int64 __fastcall sub_19DB0(PVOID *a1);
__int64 __fastcall sub_1A2F8(PVOID *a1);
__int64 __fastcall sub_1A6D8(__int64 a1);
__int64 __fastcall sub_1A8A4(__int64 a1, __int64 a2);
__int64 __fastcall sub_1ABC4(__int64 a1);
__int64 __fastcall sub_1AD88(__int64 a1, int a2);
__int64 __fastcall sub_1AFDC(__int64 a1, __int64 a2);
__int64 sub_1B2D0();
__int64 __fastcall sub_1B4D4(__int64 a1, __int64 a2);
__int64 __fastcall sub_1B7C4(__int64 a1, __int64 a2);
__int64 __fastcall sub_1BA3C(__int64 a1, __int64 a2);
__int64 __fastcall sub_1BC58(__int64 a1, __int64 a2);
__int64 __fastcall sub_1BEB4(__int64 a1, __int64 a2, _QWORD *a3, int *a4, int *a5);
__int64 __fastcall sub_1C1A0(__int64 a1, __int64 a2, int *a3, __int64 *a4, int *a5, _DWORD *a6);
__int64 __fastcall sub_1C738(__int64 a1, __int64 a2, int *a3, __int64 *a4, int *a5);
__int64 __fastcall sub_1CC44(__int64 a1, __int64 a2, __int64 a3, int *a4, int a5, int a6, int *a7);
__int64 __fastcall sub_1CFDC(__int64 a1, __int64 a2, int a3, int a4);
__int64 __fastcall sub_1D780(int a1, _WORD *a2, int *a3);
__int64 __fastcall sub_1DAFC(__int64 a1, __int64 a2);
__int64 __fastcall sub_1DD60(__int64 a1, unsigned __int64 *a2);
__int64 __fastcall sub_1DEC4(__int64 a1, unsigned __int64 a2, __int64 a3);
__int64 __fastcall sub_1E020(__int64 a1, unsigned __int64 a2, __int64 *a3);
__int64 __fastcall sub_1E228(__int64 a1);
__int64 __fastcall sub_1E350(__int64 a1);
__int64 __fastcall sub_1E434(__int64 a1, const signed __int32 *a2);
const char *__fastcall sub_1E710(int a1);
__int64 sub_1E76C();
void __fastcall sub_1E830(int a1);
__int64 __fastcall sub_1E93C(void *Dst); // idb
__int64 __fastcall sub_1EA0C(__int64 a1, __int64 a2);
__int64 __fastcall sub_1EB00(int a1);
__int64 __fastcall sub_1EB84(int a1);
__int64 sub_1EBD4(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_1ECC0(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 __fastcall sub_1EE78(PVOID *a1);
__int64 __fastcall sub_1F0D4(PVOID *a1);
__int64 __fastcall sub_1F2A0(ULONG_PTR *a1);
__int64 __fastcall sub_1F420(ULONG_PTR *a1, unsigned __int64 a2, int a3, int a4, _WORD *a5, __int64 a6);
__int64 __fastcall sub_1F96C(__int64 *a1, unsigned __int64 a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _QWORD *a6);
__int64 __fastcall sub_1FBB4(_QWORD *a1);
__int64 __fastcall sub_1FD10(__int64 a1);
char __fastcall sub_1FE44(int a1, int a2, __int64 a3, _WORD *a4);
__int64 __fastcall sub_20144(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, const char *a5);
__int64 sub_201C4(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_202B4(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_20340(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_20394(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_2041C(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_204BC(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_20510(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_205C0(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_2064C(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_206FC(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 __fastcall sub_20788(__int64 a1, __int64 a2, __int64 a3, const char *a4);
__int64 __fastcall sub_20830(__int64 a1, __int64 a2, __int64 a3, const char *a4, char a5, const char *a6);
__int64 __fastcall sub_2090C(__int64 a1, __int64 a2, __int64 a3, const char *a4);
__int64 __fastcall sub_209CC(__int64 a1, __int64 a2, __int64 a3, const char *a4, char a5, const char *a6);
__int64 __fastcall sub_20A84(__int64 *a1, __int64 a2, int a3);
__int64 __fastcall sub_20CF8(__int64 *a1);
__int64 __fastcall sub_20EA4(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_21014(PVOID *a1);
__int64 __fastcall sub_21120(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_2128C(PVOID *a1);
__int64 __fastcall sub_21398(__int64 a1, __int64 a2);
__int64 __fastcall sub_214EC(__int64 a1, __int64 a2);
__int64 __fastcall sub_216C0(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_21884(PERESOURCE *a1);
__int64 __fastcall sub_21A90(PERESOURCE *a1);
__int64 __fastcall sub_21C3C(__int64 a1, __int64 a2);
__int64 __fastcall sub_21D80(__int64 a1, __int64 a2);
__int64 __fastcall sub_21ED4(__int64 *a1, __int64 a2, int a3, _DWORD *a4);
__int64 __fastcall sub_222C0(PVOID *a1);
__int64 __fastcall sub_223D0(PERESOURCE Resource, __int64 a2);
__int64 __fastcall sub_22628(__int64 a1, __int64 a2, _QWORD *a3, _BYTE *a4);
__int64 __fastcall sub_22AB4(PERESOURCE Resource, __int64 a2, int *a3, int a4);
__int64 __fastcall sub_23424(PERESOURCE Resource); // idb
const char *__fastcall sub_23730(int a1);
__int64 __fastcall sub_23778(__int64 a1, __int64 a2);
__int64 __fastcall sub_239B0(__int64 a1, __int64 a2);
__int64 __fastcall sub_23C04(__int64 a1);
__int64 __fastcall sub_23F38(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_23FA8(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4);
__int64 __fastcall sub_24040(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4);
__int64 __fastcall sub_24104(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 (__fastcall *a5)(__int64 a1, __int64 a2));
__int64 sub_24174();
__int64 __fastcall sub_242E8(wchar_t *a1, char *a2);
__int64 __fastcall sub_24530(unsigned __int8 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_247BC(wchar_t *a1, char *a2);
__int64 __fastcall sub_24920(__int64 a1, _BYTE *a2);
__int64 sub_24AD0();
__int64 __fastcall sub_24BCC(wchar_t *a1, char *a2, _QWORD *a3, char *a4);
__int64 sub_24EEC(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 __fastcall sub_24F94(__int64 a1, __int64 a2, __int64 a3, int a4, char a5, _WORD *a6);
__int64 __fastcall sub_25058(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 sub_250B4();
__int64 sub_25160();
__int64 __fastcall sub_25248(char a1);
__int64 __fastcall sub_25448(__int64 a1, char a2);
__int64 __fastcall sub_25714(__int64 a1, __int64 a2, _WORD *a3);
__int64 __fastcall sub_25994(void **a1, _DWORD *a2);
__int64 __fastcall sub_25C34(PVOID *a1);
__int64 sub_25D6C();
__int64 sub_25F94();
__int64 sub_261B0();
__int64 __fastcall sub_26384(__int64 a1, unsigned __int16 a2);
PVOID __fastcall sub_26404(int a1, unsigned int a2, ULONG a3);
void __fastcall sub_26488(PVOID P, ULONG Tag);
PVOID __fastcall sub_264FC(__int64 a1, void *a2, unsigned int a3, unsigned int a4);
char *__fastcall sub_26670(__int64 a1, unsigned int a2, ULONG a3);
void __fastcall sub_26828(PVOID P);
_DWORD *__fastcall sub_26948(__int64 a1);
void __fastcall sub_269B0(__int64 a1, __int64 a2);
__int64 __fastcall sub_26ADC(PERESOURCE Resource); // idb
__int64 __fastcall sub_26BB0(PERESOURCE Resource); // idb
BOOLEAN __fastcall sub_26C84(PERESOURCE Resource);
BOOLEAN __fastcall sub_26D5C(PERESOURCE Resource);
void __fastcall sub_26E34(PERESOURCE Resource);
void __fastcall sub_26F00(PKSPIN_LOCK SpinLock, KIRQL *a2);
void __fastcall sub_26F78(PKSPIN_LOCK SpinLock, KIRQL a2);
int __fastcall sub_26FEC(PRKEVENT Event);
int __fastcall sub_27054(PRKEVENT Event);
void __fastcall sub_27120(__int64 a1);
void __fastcall sub_27200(PFAST_MUTEX FastMutex);
void __fastcall sub_272CC(PFAST_MUTEX FastMutex);
_QWORD *sub_27398();
void __fastcall sub_27504(__int64 a1);
__int64 __fastcall sub_27570(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_27600(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_2769C(__int64 a1, __int64 a2, __int64 a3, int a4);
PVOID __fastcall sub_2772C(int a1, unsigned int a2, ULONG a3);
void __fastcall sub_27848(PVOID P, ULONG Tag);
_DWORD *__fastcall sub_27940(__int64 a1);
__int64 __fastcall sub_27A44(_QWORD *a1);
void __fastcall sub_27AC8(PKSPIN_LOCK SpinLock, KIRQL *a2);
void __fastcall sub_27B80(PKSPIN_LOCK SpinLock, KIRQL a2);
bool __fastcall sub_27C24(struct _KEVENT **a1, char a2);
void __fastcall sub_27D0C(PVOID P);
int __fastcall sub_27DA4(PRKEVENT Event);
void __fastcall HandleInformation(PVOID StartContext);
unsigned __int8 __fastcall sub_27ED0(PVOID *Object, __int64 a2, __int64 (__fastcall *a3)(void ***a1));
__int64 __fastcall sub_28038(PVOID Object); // idb
__int64 __fastcall sub_280CC(void ***a1);
__int64 sub_283D8();
__int64 __fastcall sub_285FC(PVOID P); // idb
void __fastcall sub_28958(__int64 a1, char a2);
void __fastcall sub_28A1C(__int64 a1);
__int64 __fastcall sub_28B00(PVOID Object); // idb
__int64 __fastcall sub_28BA8(ULONG Count, PVOID Object[]); // idb
__int64 __fastcall sub_28CB4(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall sub_28D00(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 sub_28D6C(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_28DD0(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_28E34(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_28E98(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_28F10();
__int64 sub_29034();
__int64 __fastcall sub_29144(__int64 *a1);
__int64 __fastcall sub_29264(PVOID P); // idb
__int64 __fastcall sub_29320(_DWORD *a1, int a2, __int64 *a3);
__int64 __fastcall sub_29498(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 *a4);
__int64 __fastcall sub_296E0(PVOID P); // idb
__int64 __fastcall sub_2979C(__int64 a1, __int64 a2, unsigned int a3, __int64 **a4);
__int64 __fastcall sub_29964(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_29A80(__int64 a1, int *a2);
__int64 __fastcall sub_29B50(_DWORD **a1, _DWORD *a2, __int64 *a3);
__int64 __fastcall sub_29D9C(__int64 a1);
__int64 __fastcall sub_29E48(__int64 a1);
__int64 __fastcall sub_29F0C(__int64 a1, void **a2, int *a3);
__int64 __fastcall sub_2A0B4(const void **a1, int *a2, __int64 **a3);
__int64 __fastcall sub_2A274(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_2A2C4(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall sub_2A330(PVOID P); // idb
__int64 __fastcall sub_2A3F8(int a1, const void *a2, unsigned int a3, __int64 **a4);
__int64 __fastcall sub_2A590(__int64 a1, __int64 a2);
__int64 __fastcall sub_2A67C(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 *a4);
__int64 __fastcall sub_2A8A0(__int64 a1);
__int64 __fastcall sub_2A944(__int64 a1, void **a2, int *a3);
__int64 __fastcall sub_2AA24(const void **a1, int *a2, __int64 **a3);
unsigned __int8 __fastcall sub_2AB60(__int64 a1);
bool __fastcall sub_2AC14(__int64 a1);
bool __fastcall sub_2ACB8(__int64 a1);
__int64 sub_2AD5C();
__int64 __fastcall sub_2ADEC(__int64 a1);
__int64 __fastcall sub_2AE94(const void **a1, _DWORD *a2, __int64 **a3);
void __fastcall sub_2AFDC(__int64 a1);
__int64 __fastcall sub_2B07C(__int64 a1);
__int64 __fastcall sub_2B134(__int64 a1, void **a2, int *a3);
__int64 __fastcall sub_2B2B4(_DWORD **a1, _DWORD *a2, __int64 **a3);
__int64 sub_2B54C(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_2B5DC();
void sub_2B6B4();
__int64 __fastcall sub_2B764(__int64 a1);
void __fastcall sub_2B824(__int64 a1);
__int64 __fastcall sub_2B954(__int64 a1, __int64 a2);
__int64 __fastcall sub_2BA80(__int64 a1);
__int64 __fastcall sub_2BB58(__int64 a1, void **a2, int *a3);
__int64 __fastcall sub_2BCB8(__int64 a1, _DWORD **a2, _DWORD *a3, __int64 (__fastcall *a4)(_DWORD **, _DWORD *, __int64 *));
__int64 __fastcall sub_2BE4C(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_2BFE0(_QWORD *a1);
__int64 __fastcall sub_2C17C(_QWORD *a1);
__int64 __fastcall sub_2C2A0(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_2C3CC(unsigned int a1, _QWORD *a2);
void **__fastcall sub_2C4B0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4);
void __fastcall sub_2C584(PVOID P);
__int64 __fastcall sub_2C640(__int64 a1);
__int64 __fastcall sub_2C724(__int64 a1, void **a2, int *a3);
void __fastcall DeferredRoutine(_KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2);
__int64 sub_2C86C();
__int64 __fastcall sub_2C9A0(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall sub_2C9F4(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, __int64 a6, int a7);
__int64 __fastcall sub_2CA64(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall sub_2CAD0(__int64 a1);
__int64 __fastcall sub_2CB44(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall sub_2CBA0(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_2CC10(__int64 a1, __int64 a2, _QWORD *a3);
__int64 sub_2D188();
__int64 (**sub_2D528())(void);
void sub_2D654();
__int64 __fastcall sub_2D7F0(__int64 a1, void *a2);
__int64 __fastcall sub_2DA90(unsigned int a1);
__int64 __fastcall sub_2DCFC(__int64 a1, unsigned int a2, _QWORD *a3, _DWORD *a4);
__int64 __fastcall sub_2DFD4(__int64 a1);
__int64 __fastcall sub_2E210(__int64 a1, unsigned int a2, __int64 a3, int a4);
char *sub_2E4DC();
void sub_2E6AC();
__int64 __fastcall sub_2E790(__int64 a1);
__int64 sub_2ED48();
__int64 __fastcall sub_2F414(unsigned int a1, int a2, unsigned int a3, _DWORD *a4);
__int64 __fastcall sub_2FA0C(__int64 a1, unsigned int a2, __int64 a3);
__int64 __fastcall sub_2FDD0(int a1);
__int64 __fastcall sub_2FF2C(int a1);
__int64 sub_30054(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 __fastcall sub_300A8(__int16 *a1, int a2, unsigned int *a3);
__int64 __fastcall sub_3027C(char a1);
__int64 __fastcall sub_30318(int a1, int a2);
__int64 __fastcall sub_304F8(int a1, __int64 a2);
__int64 sub_306EC();
__int64 __fastcall sub_308AC(int a1, const void *a2, unsigned int a3, int a4, int *a5);
__int64 __fastcall sub_30B00(unsigned int a1, __int64 a2);
__int64 sub_30C50();
__int64 sub_30EC0();
__int64 __fastcall sub_31148(int a1);
__int64 sub_3150C();
__int64 sub_31C70();
__int64 __fastcall sub_31FD0(int a1, const void *a2, unsigned int a3, int a4, int *a5);
__int64 __fastcall sub_322F4(int a1, const void *a2, unsigned int a3, _DWORD *a4);
__int64 __fastcall sub_32548(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_327A0(unsigned int *a1);
__int64 __fastcall sub_328FC(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_329E8(__int64 a1, int a2, unsigned int a3, void *a4);
__int64 __fastcall sub_32BE4(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_32E58(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_33170(__int64 a1, __int64 a2, __int64 a3);
__int64 sub_33350();
__int64 __fastcall sub_33440(int a1, __int64 a2);
__int64 __fastcall sub_33638(int a1, __int64 a2);
__int64 __fastcall sub_33838(__int64 a1, const void *a2, unsigned int a3);
__int64 __fastcall sub_33AE0(__int64 a1, __int64 a2, __int64 a3);
__int64 sub_33C84();
__int64 __fastcall sub_33D7C(__int64 a1, __int64 *a2, __int64 *a3);
__int64 __fastcall sub_33F40(__int64 a1, _QWORD *a2, unsigned int *a3);
__int64 __fastcall sub_34384(PVOID *a1);
const char *__fastcall sub_34494(int a1);
const char *__fastcall sub_34580(int a1);
const char *__fastcall sub_345E4(int a1);
const char *__fastcall sub_34658(unsigned int a1);
const char *__fastcall sub_346D0(int a1);
const char *__fastcall sub_347A8(int a1);
__int64 __fastcall sub_347D0(__int64 a1, const void *a2, size_t a3);
__int64 __fastcall sub_34930(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_349BC(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall sub_34A5C(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall sub_34B0C(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4, _WORD *a5);
__int64 __fastcall sub_34C0C(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4);
__int64 __fastcall sub_34CB0(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4);
__int64 __fastcall sub_34D50(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4);
__int64 __fastcall sub_34DF4(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4, const char *a5);
__int64 __fastcall sub_34EC8(__int64 a1, __int64 a2, __int64 a3, char a4);
__int64 __fastcall sub_34F10(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 sub_34F90(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_34FE8();
void sub_350EC();
_DWORD *__fastcall sub_351D0(__int64 a1, unsigned int a2, const void *a3, unsigned int a4, unsigned int a5, _DWORD *a6, _DWORD *a7);
const wchar_t *__fastcall sub_35224(int a1);
const wchar_t *__fastcall sub_352B8(int a1);
const wchar_t *__fastcall sub_36CB0(int a1);
const wchar_t *__fastcall sub_38664(int a1);
__int64 __fastcall sub_38734(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_38870(__int64 a1, _BYTE *a2);
void **__fastcall sub_389AC(unsigned __int8 *a1);
void **__fastcall sub_38A78(_WORD *a1);
__int64 __fastcall sub_38C6C(__int64 a1, _BYTE *a2);
void **__fastcall sub_38D44(unsigned __int8 *a1);
__int64 __fastcall sub_38E18(__int64 *a1);
__int64 __fastcall sub_38F84(__int64 *a1, char a2);
__int64 __fastcall sub_390A0(__int64 *a1, char a2);
__int64 __fastcall sub_391AC(__int64 *a1, int a2);
__int64 __fastcall sub_392B4(__int64 *a1, __int64 a2);
__int64 __fastcall sub_393C0(__int64 *a1, const char *a2);
__int64 __fastcall sub_395A8(__int64 *a1, const wchar_t *a2);
__int64 __fastcall sub_39758(__int64 *a1, const void *a2, int a3);
__int64 __fastcall sub_398F8(__int64 *a1, int a2);
__int64 __fastcall sub_39A0C(__int64 *a1, const void *a2, const void *a3, int a4);
__int64 __fastcall sub_39CFC(__int64 *a1, __int64 a2, char a3);
__int64 __fastcall sub_3A090(__int64 *a1, unsigned __int16 *a2, unsigned __int8 a3);
__int64 __fastcall sub_3AA24(__int64 *a1, __int64 a2);
__int64 __fastcall sub_3AB8C(__int64 *a1);
__int64 __fastcall sub_3ACEC(__int64 *a1, __int64 a2);
__int64 __fastcall sub_3AF94(__int64 a1);
__int64 __fastcall sub_3B0E0(__int64 *a1);
void __fastcall sub_3B22C(__int64 a1);
__int64 __fastcall sub_3B864(const void **a1, __int64 a2, unsigned int a3, unsigned int a4, unsigned int *a5, _DWORD *a6);
__int64 __fastcall sub_3BB90(__int64 *a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_3C074(_DWORD *a1, __int64 a2);
__int64 __fastcall sub_3C5C4(PVOID *a1, const void *a2, unsigned int a3);
__int64 __fastcall sub_3C894(PVOID *a1);
__int64 __fastcall sub_3C9C8(__int64 a1);
__int64 __fastcall sub_3CC40(__int64 a1, _QWORD *a2, unsigned int *a3);
__int64 __fastcall sub_3CE18(PVOID *a1, const char *a2);
__int64 __fastcall sub_3D04C(PVOID *a1);
__int64 __fastcall sub_3D4C4(PVOID *a1, __int64 a2);
__int64 __fastcall sub_3DA00(PVOID *a1);
__int64 __fastcall sub_3DE0C(__int64 a1);
__int64 __fastcall sub_3E4EC(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, unsigned int *a5, _DWORD *a6);
__int64 __fastcall sub_3E80C(PVOID *a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_3EC78(__int64 a1);
__int64 __fastcall sub_3ED70(__int64 a1, int a2, _QWORD *a3);
__int64 __fastcall sub_3F008(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_3F130(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_3F278(__int64 a1, bool *a2);
__int64 __fastcall sub_3F3B8(__int64 a1, __int64 a2);
__int64 __fastcall sub_3F594(__int64 a1, __int64 a2);
__int64 __fastcall sub_3F7B4(__int64 *a1);
__int64 __fastcall sub_3F8E4(__int64 *a1, __int64 a2);
__int64 __fastcall sub_3FA68(__int64 *a1);
__int64 __fastcall sub_3FB0C(_QWORD *a1, __int64 a2, unsigned int a3, unsigned int a4, _DWORD *a5, _DWORD *a6);
__int64 __fastcall sub_3FC44(__int64 **a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_3FDA8(__int64 a1, int a2, _QWORD *a3);
__int64 __fastcall sub_3FE74(__int64 **a1);
__int64 __fastcall sub_400E8(__int64 **a1, __int64 *a2);
__int64 __fastcall sub_40368(__int64 **a1);
__int64 __fastcall sub_40484(_QWORD **a1);
__int64 __fastcall sub_4064C(_QWORD **a1, __int64 a2, unsigned int a3, unsigned int a4, unsigned int *a5, _DWORD *a6);
__int64 __fastcall sub_40810(__int64 **a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_40A10(__int64 *a1, int a2, _QWORD *a3);
__int64 __fastcall sub_40BA0(__int64 **a1, int a2, int a3, int a4);
__int64 __fastcall sub_40D54(__int64 **a1, __int64 a2);
__int64 __fastcall sub_40F90(__int64 **a1);
void __fastcall sub_41094(__int64 a1);
__int64 __fastcall sub_412B4(const void ***a1, __int64 a2, unsigned int a3, unsigned int a4, unsigned int *a5, _DWORD *a6);
__int64 __fastcall sub_4142C(__int64 **a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_415C0(__int64 a1, int a2, _QWORD *a3);
__int64 __fastcall sub_416F0(__int64 **a1);
__int64 __fastcall sub_418BC(__int64 **a1, __int64 *a2);
__int64 __fastcall sub_41AAC(__int64 **a1);
void __fastcall sub_41BF0(__int64 *a1);
__int64 __fastcall sub_41CFC(const void ***a1, __int64 a2, unsigned int a3, unsigned int a4, unsigned int *a5, _DWORD *a6);
__int64 __fastcall sub_41E74(__int64 **a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_41FFC(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_420EC(__int64 a1, unsigned __int8 (__fastcall *a2)(_QWORD, __int64, __int64), __int64 a3, _BYTE *a4);
__int64 sub_42254();
void sub_42424();
__int64 __fastcall sub_42500(ULONG a1, __int64 *a2, int a3, void (__fastcall *a4)(__int64 *));
__int64 __fastcall sub_426B4(__int64 *a1, __int64 a2, __int64 (__fastcall *a3)(__int64 *, _QWORD), void (__fastcall *a4)(__int64 *));
__int64 __fastcall sub_42938(__int64 *a1, void (__fastcall *a2)(__int64 *));
__int64 __fastcall sub_42A4C(__int64 a1, void (__fastcall *a2)(__int64 *));
__int64 __fastcall sub_42B90(_QWORD *a1, void (__fastcall *a2)(_QWORD));
__int64 __fastcall sub_42D48(int *a1, __int64 a2, __int64 (__fastcall *a3)(_QWORD, _QWORD));
__int64 __fastcall sub_42F90(int *a1, __int64 a2, __int64 (__fastcall *a3)(_QWORD, __int64), void (__fastcall *a4)(_QWORD *), char a5);
__int64 __fastcall sub_431EC(int *a1, __int64 a2, _QWORD *a3, __int64 (__fastcall *a4)(_QWORD, __int64), char a5);
__int64 __fastcall sub_433EC(__int64 a1);
__int64 __fastcall sub_434BC(_QWORD *a1, __int64 a2, unsigned int a3, unsigned int a4, _DWORD *a5, void (__fastcall *a6)(_QWORD, __int64, _QWORD, _QWORD, _DWORD *, _DWORD *), _DWORD *a7);
__int64 __fastcall sub_43718(__int64 *a1, __int64 a2, unsigned int a3, __int64 (__fastcall *a4)(__int64 *, __int64, _QWORD), void (__fastcall *a5)(__int64 *));
__int64 __fastcall sub_439A0(__int64 a1, __int64 a2);
__int64 __fastcall sub_43B64(__int64 *a1);
bool __fastcall sub_43C74(_QWORD *a1);
__int64 __fastcall sub_43D50(__int64 a1);
__int64 __fastcall sub_43E74(__int64 a1);
__int64 sub_43F68(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_43FB8(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 __fastcall sub_4401C(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall sub_44078(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 sub_440E8(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 __fastcall sub_44130(int a1, _QWORD *a2);
__int64 __fastcall sub_44314(int a1, __int64 a2);
__int64 __fastcall sub_44474(int a1, struct _FAST_MUTEX *a2, KIRQL *a3);
__int64 __fastcall sub_44538(int a1, struct _FAST_MUTEX *a2, KIRQL a3);
__int64 __fastcall sub_445CC(__int64 a1, __int64 a2, char a3);
__int64 __fastcall sub_446F8(__int64 a1, __int64 a2, char a3);
_DWORD *__fastcall sub_4481C(unsigned __int8 a1, __int64 a2, __int64 a3, ULONG a4, __int64 a5, int a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, _DWORD *a11);
__int64 __fastcall sub_44B4C(ULONG_PTR BugCheckParameter2); // idb
__int64 __fastcall sub_44FD8(ULONG_PTR BugCheckParameter2); // idb
unsigned __int64 __fastcall sub_452B8(__int64 a1, unsigned __int64 a2, _DWORD *a3);
_DWORD *__fastcall sub_453B4(__int64 a1, __int64 a2, _DWORD *a3);
__int64 __fastcall sub_4553C(__int64 a1, unsigned int a2, __int64 *a3);
__int64 __fastcall sub_45738(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_458B8(__int64 a1, __int64 a2, char a3);
__int64 __fastcall sub_45B04(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_45BFC(ULONG_PTR BugCheckParameter2, unsigned __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_45E1C(ULONG_PTR BugCheckParameter2, unsigned __int64 a2, __int64 a3, _DWORD *a4);
__int64 __fastcall sub_460A0(__int64 a1, unsigned __int64 a2, __int64 a3, _DWORD *a4);
_QWORD *__fastcall sub_4626C(__int64 a1, unsigned int a2, __int64 a3, _DWORD *a4);
ULONG_PTR __fastcall sub_4642C(ULONG_PTR BugCheckParameter2, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_4688C(ULONG_PTR BugCheckParameter2, ULONG_PTR *a2, _DWORD *a3);
__int64 __fastcall sub_46A58(ULONG_PTR BugCheckParameter2, ULONG_PTR *a2, __int64 a3, _DWORD *a4);
__int64 __fastcall sub_46D0C(ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter1, char a3);
__int64 __fastcall sub_46E50(ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter1, char a3);
char __fastcall sub_46FCC(_BYTE *a1, _DWORD *a2);
char __fastcall sub_47118(_BYTE *a1, _DWORD *a2);
char __fastcall sub_47264(_BYTE *a1, _DWORD *a2);
__int64 __fastcall sub_473B0(int a1);
__int64 __fastcall sub_47450(unsigned int a1);
__int64 __fastcall sub_47580(__int64 a1);
char __fastcall sub_47F64(ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter1);
__int64 __fastcall sub_47FBC(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_48100(__int64 a1, __int64 a2, __int64 a3, int a4, const char *a5, const char *a6);
__int64 __fastcall sub_481C8(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, const char *a5);
_BYTE *__fastcall sub_48250(_BYTE *a1, int a2);
__int64 __fastcall sub_4879C(__int64 a1, __int64 a2);
__int64 __fastcall sub_48854(__int64 a1, __int64 a2);
__int64 __fastcall sub_48908(__int64 a1, _WORD *a2);
__int64 __fastcall sub_489CC(_BYTE *a1, _BYTE *a2);
__int64 __fastcall sub_48A7C(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_48B2C(__int64 a1, _WORD *a2);
__int64 __fastcall sub_48BF8(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_48CA8(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_48D58(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_48E1C(__int64 a1, unsigned __int8 *a2, _QWORD *a3);
char __fastcall sub_490E0(__int64 a1);
__int64 __fastcall sub_492B4(__int64 a1, unsigned __int16 *a2);
__int64 __fastcall sub_4937C(__int64 a1, unsigned __int8 *a2);
__int64 __fastcall sub_49430(__int64 a1, __m128i *a2);
__int64 __fastcall sub_494E4(__int64 a1, __m128i *a2);
__int64 __fastcall sub_49640(_BYTE *a1, __m128i *a2);
__int64 __fastcall sub_49AAC(_WORD *a1, _WORD *a2);
__int64 __fastcall sub_49B70(__int64 a1, _WORD *a2);
__int64 __fastcall sub_49C34(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_49CE4(_WORD *a1, _WORD *a2);
__int64 __fastcall sub_49DA8(__int64 a1, _WORD *a2);
char __fastcall sub_49E6C(__int64 a1);
__int64 __fastcall sub_49F2C(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_4A0C0(__int64 a1, unsigned int a2, unsigned __int16 *a3);
__int64 __fastcall sub_4A2D8(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_4A548(__int64 a1, unsigned __int8 a2, unsigned __int64 *a3);
__int64 __fastcall sub_4A8A8(__int64 a1);
char __fastcall sub_4AAA8(_BYTE *a1);
const char *__fastcall sub_4ABEC(unsigned __int8 a1);
__int64 __fastcall sub_4ACDC(WCHAR *a1, __int16 a2, __int64 a3, ULONG *a4);
void __fastcall sub_4AE98(__int64 a1);
char __fastcall sub_4AF10(PFAST_MUTEX FastMutex);
char __fastcall sub_4AFB8(PFAST_MUTEX FastMutex);
char __fastcall sub_4B020(PFAST_MUTEX FastMutex);
__int64 __fastcall sub_4B084(_QWORD *a1, _QWORD *a2);
void __fastcall sub_4B208(PVOID P);
__int64 __fastcall sub_4B278(__int64 a1, __int64 a2);
__int64 __fastcall sub_4B2BC(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, void *Src);
// int __cdecl wcsicmp(const wchar_t *Str1, const wchar_t *Str2);
__int64 __fastcall sub_4B434(char *a1, unsigned __int64 a2, CHAR *a3, __int64 a4);
__int64 sub_4B484(char *a1, unsigned __int64 a2, CHAR *a3, ...);
__int64 __fastcall sub_4B4A8(void *a1, size_t a2, const void *a3, size_t a4);
__int64 __fastcall sub_4B54C(_WORD *a1, __int64 a2, __int16 *a3);
// __int64 __fastcall write_char(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall write_multi_char(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_4B680(_BYTE *a1, int a2, __int64 a3, _DWORD *a4);
__int64 __fastcall sub_4B6F0(__int64 a1, CHAR *a2, __int64 a3);
__int64 __fastcall sub_4BFC0(char *a1, unsigned __int64 a2, CHAR *a3, __int64 a4);
// int __cdecl flsbuf(int Ch, FILE *File);
// NTSTATUS __stdcall RtlStringCopyWorkerW(NTSTRSAFE_PWSTR pszDest, size_t cchDest, size_t *pcchNewDestLength, STRSAFE_PCNZWCH pszSrc, size_t cchToCopy);
// __int64 __fastcall unknown_libname_2(_QWORD, _QWORD, _QWORD); weak
__int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
// void *__cdecl memmove(void *Dst, const void *Src, size_t MaxCount);
// void *__cdecl memset(void *Dst, int Val, size_t Size);
// NTSTATUS __stdcall RtlUnicodeToMultiByteN(PCHAR MultiByteString, ULONG MaxBytesInMultiByteString, PULONG BytesInMultiByteString, PCWCH UnicodeString, ULONG BytesInUnicodeString);
// int __cdecl stricmp(const char *Str1, const char *Str2);
// void __stdcall KeStallExecutionProcessor(ULONG MicroSeconds);
// LARGE_INTEGER __stdcall KeQueryPerformanceCounter(PLARGE_INTEGER PerformanceFrequency);
// NTSTATUS __stdcall IoWMIWriteEvent(PVOID WnodeEventItem);
// void __stdcall RtlInitUnicodeString(PUNICODE_STRING DestinationString, PCWSTR SourceString);
// PVOID __stdcall MmGetSystemRoutineAddress(PUNICODE_STRING SystemRoutineName);
// SIZE_T __stdcall RtlCompareMemory(const void *Source1, const void *Source2, SIZE_T Length);
// NTSTATUS __stdcall IofCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp);
// int __cdecl _wcsicmp(const wchar_t *Str1, const wchar_t *Str2);
// void KeLeaveCriticalRegion(void);
// void KeEnterCriticalRegion(void);
// void __stdcall __noreturn KeBugCheckEx(ULONG BugCheckCode, ULONG_PTR BugCheckParameter1, ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter3, ULONG_PTR BugCheckParameter4);
// BOOLEAN __stdcall ExAcquireResourceExclusiveLite(PERESOURCE Resource, BOOLEAN Wait);
// void __stdcall KeClearEvent(PRKEVENT Event);
// LONG __stdcall KeResetEvent(PRKEVENT Event);
// void __stdcall ExReleaseFastMutex(PFAST_MUTEX FastMutex);
// void __stdcall ExInitializeNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside, PALLOCATE_FUNCTION Allocate, PFREE_FUNCTION Free, ULONG Flags, SIZE_T Size, ULONG Tag, USHORT Depth);
// void __stdcall ExAcquireFastMutex(PFAST_MUTEX FastMutex);
// LONG __stdcall KeSetEvent(PRKEVENT Event, KPRIORITY Increment, BOOLEAN Wait);
// PSLIST_ENTRY __stdcall ExpInterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry);
// void __stdcall KeInitializeEvent(PRKEVENT Event, EVENT_TYPE Type, BOOLEAN State);
// void __stdcall KeReleaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL NewIrql);
// PSLIST_ENTRY __stdcall ExpInterlockedPopEntrySList(PSLIST_HEADER ListHead);
// void __stdcall KeReleaseSpinLockFromDpcLevel(PKSPIN_LOCK SpinLock);
// void __stdcall ExFreePoolWithTag(PVOID P, ULONG Tag);
// NTSTATUS __stdcall PsCreateSystemThread(PHANDLE ThreadHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PKSTART_ROUTINE StartRoutine, PVOID StartContext);
// NTSTATUS __stdcall PsTerminateSystemThread(NTSTATUS ExitStatus);
// BOOLEAN __stdcall ExAcquireResourceSharedLite(PERESOURCE Resource, BOOLEAN Wait);
// void __stdcall ExReleaseResourceLite(PERESOURCE Resource);
// NTSTATUS __stdcall ZwClose(HANDLE Handle);
// USHORT __stdcall ExQueryDepthSList(PSLIST_HEADER SListHead);
// NTSTATUS __stdcall ObReferenceObjectByHandle(HANDLE Handle, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PVOID *Object, POBJECT_HANDLE_INFORMATION HandleInformation);
// NTSTATUS __stdcall KeWaitForSingleObject(PVOID Object, KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
// NTSTATUS __stdcall ExDeleteResourceLite(PERESOURCE Resource);
// void __stdcall ExInitializePagedLookasideList(PPAGED_LOOKASIDE_LIST Lookaside, PALLOCATE_FUNCTION Allocate, PFREE_FUNCTION Free, ULONG Flags, SIZE_T Size, ULONG Tag, USHORT Depth);
// LONG_PTR __stdcall ObfDereferenceObject(PVOID Object);
// NTSTATUS __stdcall ExInitializeResourceLite(PERESOURCE Resource);
// NTSTATUS __stdcall KeWaitForMultipleObjects(ULONG Count, PVOID Object[], WAIT_TYPE WaitType, KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PKWAIT_BLOCK WaitBlockArray);
// void __stdcall KeAcquireSpinLockAtDpcLevel(PKSPIN_LOCK SpinLock);
// void __stdcall ExDeleteNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside);
// KIRQL __stdcall KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock);
// NTSTATUS __stdcall IoGetDeviceObjectPointer(PUNICODE_STRING ObjectName, ACCESS_MASK DesiredAccess, PFILE_OBJECT *FileObject, PDEVICE_OBJECT *DeviceObject);
// void __stdcall KeInitializeDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext);
// void __stdcall KeInitializeTimer(PKTIMER Timer);
// BOOLEAN __stdcall KeSetTimer(PKTIMER Timer, LARGE_INTEGER DueTime, PKDPC Dpc);
// BOOLEAN __stdcall KeCancelTimer(PKTIMER);
// NTSTATUS __stdcall KeDelayExecutionThread(KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Interval);
// NTSTATUS __stdcall RtlHashUnicodeString(PCUNICODE_STRING String, BOOLEAN CaseInSensitive, ULONG HashAlgorithm, PULONG HashValue);
// NTSTATUS __stdcall IoWMIRegistrationControl(PDEVICE_OBJECT DeviceObject, ULONG Action);
// void __stdcall ExDeletePagedLookasideList(PPAGED_LOOKASIDE_LIST Lookaside);
// PVOID __stdcall ExAllocatePoolWithTag(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag);
// PIRP __stdcall IoBuildDeviceIoControlRequest(ULONG IoControlCode, PDEVICE_OBJECT DeviceObject, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, BOOLEAN InternalDeviceIoControl, PKEVENT Event, PIO_STATUS_BLOCK IoStatusBlock);
__int64 __fastcall sub_65008(unsigned __int8 a1, __int64 a2, unsigned int a3, unsigned int *a4, __int64 a5, unsigned int *a6);

//-------------------------------------------------------------------------
// Data declarations

__int64 qword_4C8A0[2] = { -3689348814741962752i64, -3689348814741910324i64 }; // weak
unsigned __int8 byte_4D200[352] =
{
  6u,
  128u,
  128u,
  134u,
  128u,
  129u,
  128u,
  0u,
  0u,
  16u,
  3u,
  134u,
  128u,
  134u,
  130u,
  128u,
  20u,
  5u,
  5u,
  69u,
  69u,
  69u,
  133u,
  133u,
  133u,
  5u,
  0u,
  0u,
  48u,
  48u,
  128u,
  80u,
  128u,
  128u,
  0u,
  8u,
  0u,
  32u,
  32u,
  48u,
  80u,
  87u,
  128u,
  0u,
  7u,
  0u,
  55u,
  48u,
  48u,
  80u,
  80u,
  136u,
  0u,
  0u,
  0u,
  32u,
  40u,
  128u,
  136u,
  128u,
  128u,
  0u,
  0u,
  0u,
  96u,
  96u,
  96u,
  104u,
  104u,
  96u,
  0u,
  0u,
  7u,
  120u,
  112u,
  112u,
  119u,
  112u,
  112u,
  8u,
  8u,
  0u,
  0u,
  8u,
  0u,
  8u,
  0u,
  7u,
  8u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
_UNKNOWN unk_4DAD0; // weak
_UNKNOWN unk_4DAE0; // weak
_UNKNOWN unk_4DAF0; // weak
_UNKNOWN unk_4DB00; // weak
_UNKNOWN unk_4DB10; // weak
_UNKNOWN unk_4DB20; // weak
_UNKNOWN unk_4DB30; // weak
_UNKNOWN unk_4DB40; // weak
_DWORD dword_4DB50[30] =
{
  1,
  11,
  23,
  53,
  97,
  193,
  389,
  769,
  1543,
  3079,
  6151,
  12289,
  24593,
  49157,
  98317,
  196613,
  393241,
  786433,
  1572869,
  3145739,
  6291469,
  12582917,
  25165843,
  50331653,
  100663319,
  201326611,
  402653189,
  805306457,
  1610612741,
  0
}; // idb
_UNKNOWN unk_4DBC8; // weak
_UNKNOWN unk_4DBD8; // weak
_UNKNOWN unk_4DBE8; // weak
_UNKNOWN unk_4DBF8; // weak
_UNKNOWN unk_4DC08; // weak
_UNKNOWN unk_4DC18; // weak
_UNKNOWN unk_4DC28; // weak
_UNKNOWN unk_4DC38; // weak
_UNKNOWN unk_4DC48; // weak
_UNKNOWN unk_4DC58; // weak
_UNKNOWN unk_4DC78; // weak
_UNKNOWN unk_4DC88; // weak
_UNKNOWN unk_4DC98; // weak
_UNKNOWN unk_4DCA8; // weak
_UNKNOWN unk_4DCB8; // weak
_UNKNOWN unk_4DCC8; // weak
_UNKNOWN unk_4DCD8; // weak
_UNKNOWN unk_4DCE8; // weak
_UNKNOWN unk_4DCF8; // weak
_UNKNOWN unk_4DD08; // weak
_UNKNOWN unk_4DD18; // weak
_UNKNOWN unk_4DD28; // weak
_UNKNOWN unk_4DD38; // weak
_UNKNOWN unk_4DD48; // weak
_UNKNOWN unk_4DD7A; // weak
char *off_5F110 = "(null)"; // weak
wchar_t *off_5F118 = L"(null)"; // weak
void *off_5F148 = &off_5F148; // weak
char aUnknownModule[15] = "Unknown module"; // weak
char byte_5F190 = '\x1F'; // weak
wchar_t a00[3] = L"00"; // weak
wchar_t aNprotreceivedp[21] = L"NProtReceivedPackets"; // weak
__int64 (__fastcall *qword_5F3B0)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = NULL; // weak
__int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = NULL; // weak
__int64 (__fastcall *qword_5F3C0)(_QWORD, _QWORD, _QWORD) = NULL; // weak
__int64 (__fastcall *qword_5F3C8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = NULL; // weak
__int64 (__fastcall *qword_5F3D0)(_QWORD, _QWORD, _QWORD, _QWORD) = NULL; // weak
int dword_5F3D8 = 0; // weak
PVOID qword_5F3E0 = NULL; // idb
PVOID qword_5F3E8 = NULL; // idb
char byte_5F3F0[8] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
char byte_5F3F8[156] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',  }; // idb
char byte_5F494; // weak
char byte_5F495; // weak
char byte_5F496; // weak
char byte_5F497; // weak
PVOID qword_5F498; // idb
int dword_5F4A0; // weak
int dword_5F4A4; // weak
int dword_5F4A8; // weak
int dword_5F4AC; // weak
__int64 qword_5F4B0; // weak
__int64 qword_5F4B8; // weak
__int64 qword_5F4C0; // weak
__int64 qword_5F4C8; // weak
__int64 qword_5F4D0; // weak
__int64 qword_5F4D8; // weak
__int64 qword_5F4E0; // weak
__int64 qword_5F4E8; // weak
__int64 qword_5F4F0; // weak
__int64 qword_5F4F8; // weak
__int64 qword_5F500; // weak
__int64 qword_5F508; // weak
__int64 qword_5F510; // weak
__int64 qword_5F518; // weak
__int64 qword_5F520; // weak
__int64 qword_5F528; // weak
__int64 qword_5F530; // weak
__int64 qword_5F538; // weak
__int64 qword_5F540; // weak
__int64 qword_5F548; // weak
__int64 qword_5F550; // weak
__int64 qword_5F558; // weak
__int64 qword_5F560; // weak
__int64 qword_5F568; // weak
__int64 qword_5F570; // weak
__int64 qword_5F578; // weak
__int64 qword_5F580; // weak
PVOID qword_5F588; // idb
PVOID qword_5F590; // idb
PVOID qword_5F598; // idb
PVOID qword_5F5A0; // idb
PVOID qword_5F5A8; // idb
PVOID qword_5F5B0; // idb
PVOID Dst; // idb
PVOID P; // idb
int dword_5F5E0; // weak
__int64 qword_61BD0; // weak
union _LARGE_INTEGER PerformanceFrequency; // idb
PVOID qword_61BE0; // idb
__int64 qword_61BE8; // weak
__int64 qword_61BF0; // weak
__int64 qword_61BF8; // weak
PVOID qword_61C00; // idb
__int64 qword_61C08; // weak
PVOID qword_61C10; // idb
__int64 qword_61C18; // weak
_WORD word_61C20[520]; // idb
int dword_62030; // weak
PVOID qword_62038; // idb
__int64 qword_62040; // weak
PVOID qword_62048; // idb
PVOID qword_62050; // idb
int dword_62058; // weak
int dword_6205C; // weak
char byte_62060; // weak
char byte_62061; // weak
char byte_62062; // weak
char byte_62063; // weak
char byte_62064; // weak
__int64 (__fastcall *qword_62068)(_QWORD); // weak
__int64 qword_62070; // weak
PVOID qword_62078; // idb
PVOID qword_62080; // idb
PVOID qword_62088; // idb
__int64 qword_62090; // weak
char byte_620A0; // weak
struct _ERESOURCE stru_620A8; // idb
PVOID qword_62110; // idb
struct _ERESOURCE Resource; // idb
char byte_62188; // weak
__int64 qword_62190; // weak
__int64 qword_62198; // weak
__int64 qword_621A0; // weak
struct _KDPC Dpc; // idb
struct _KTIMER Timer; // idb
__int64 qword_62240; // weak
__int64 qword_62248; // weak
__int64 qword_62250; // weak
__int64 qword_62260; // weak
char byte_62268; // weak
char byte_62269; // weak
__int16 word_6226A; // weak
int dword_6226C; // weak
__int64 qword_62280; // weak
__int64 qword_62288; // weak
__int64 qword_62290; // weak
__int64 qword_622A0; // weak
char byte_622A8; // weak
char byte_622A9; // weak
__int16 word_622AA; // weak
int dword_622AC; // weak
__int64 qword_622C0; // weak
__int64 qword_622C8; // weak
__int64 qword_622D0; // weak
__int64 qword_622E0; // weak
char byte_622E8; // weak
char byte_622E9; // weak
__int16 word_622EA; // weak
int dword_622EC; // weak
__int64 qword_62300; // weak
__int64 qword_62308; // weak
__int64 qword_62310; // weak
__int64 qword_62320; // weak
char byte_62328; // weak
char byte_62329; // weak
__int16 word_6232A; // weak
int dword_6232C; // weak
__int64 qword_62340; // weak
__int64 qword_62348; // weak
__int64 qword_62350; // weak
__int64 qword_62360; // weak
char byte_62368; // weak
char byte_62369; // weak
__int16 word_6236A; // weak
int dword_6236C; // weak


//----- (0000000000011008) ----------------------------------------------------
__int64 __fastcall sub_11008(__int64 a1, unsigned __int16 a2, __int64 a3)
{
  return qword_5F3B8(a1, 43i64, a3, a2, 0i64);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001102C) ----------------------------------------------------
__int64 __fastcall sub_1102C(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+68h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, a3, a2, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000011068) ----------------------------------------------------
__int64 __fastcall sub_11068(__int64 a1, __int64 a2, __int64 a3, __int16 a4, __int64 a5)
{
  char *v7; // rsi
  __int64 *v8; // rax
  __int64 v9; // r8
  SIZE_T v10; // rbx
  unsigned __int64 v11; // rcx
  int *v12; // rdx
  __int64 v13; // r9
  char *v15; // rax
  __int64 v16; // rbp
  const void **i; // rdi
  size_t v18; // rbx
  unsigned int v19; // ebx
  __int64 WnodeEventItem[7]; // [rsp+30h] [rbp-D8h] BYREF
  int v21; // [rsp+68h] [rbp-A0h] BYREF
  char *v22; // [rsp+70h] [rbp-98h]
  int v23; // [rsp+78h] [rbp-90h]
  __int16 v24; // [rsp+128h] [rbp+20h] BYREF

  v24 = a4;
  v7 = 0i64;
  memset(WnodeEventItem, 0, 0x30ui64);
  WnodeEventItem[1] = a1;
  WnodeEventItem[6] = (__int64)&v24;
  v8 = &a5;
  WnodeEventItem[3] = a3;
  HIDWORD(WnodeEventItem[5]) = 1703936;
  BYTE4(WnodeEventItem[0]) = -1;
  v21 = 2;
  v9 = a5;
  v10 = 0i64;
  v11 = 0i64;
  if ( a5 )
  {
    v12 = &v21;
    do
    {
      v13 = v8[1];
      ++v11;
      v12 += 4;
      v10 += v13;
      if ( v11 <= 7 )
      {
        *((_QWORD *)v12 - 1) = v9;
        *v12 = v13;
      }
      v8 += 2;
      v9 = *v8;
    }
    while ( *v8 );
  }
  if ( v10 > 0x2000 )
    return 3221225473i64;
  if ( v11 <= 7 )
  {
    LOWORD(WnodeEventItem[0]) = 16 * (v11 + 4);
  }
  else
  {
    v15 = (char *)ExAllocatePoolWithTag(NonPagedPool, v10, 0x45435453u);
    v7 = v15;
    if ( !v15 )
      return 3221225495i64;
    v22 = v15;
    v23 = v10;
    v16 = 0i64;
    for ( i = (const void **)&a5; *i; i += 2 )
    {
      v18 = (size_t)i[1];
      memmove(&v7[v16], *i, v18);
      v16 += v18;
    }
    LOWORD(WnodeEventItem[0]) = 80;
  }
  v19 = IoWMIWriteEvent(WnodeEventItem);
  if ( v7 )
    ExFreePoolWithTag(v7, 0);
  return v19;
}

//----- (00000000000111BC) ----------------------------------------------------
__int64 __fastcall sub_111BC(__int64 a1, char a2, __int64 *a3, __int64 a4)
{
  __int64 result; // rax

  result = 0i64;
  if ( a2 == 1 || !a2 )
  {
    if ( a2 )
    {
      *(_DWORD *)(a4 + 44) = *((_DWORD *)a3 + 1);
      *(_BYTE *)(a4 + 41) = *((_BYTE *)a3 + 2);
      result = *a3;
    }
    else
    {
      *(_BYTE *)(a4 + 41) = 0;
      *(_DWORD *)(a4 + 44) = 0;
    }
    *(_QWORD *)(a4 + 24) = result;
  }
  return result;
}

//----- (00000000000111F4) ----------------------------------------------------
NTSTATUS __stdcall DriverEntry(_DRIVER_OBJECT *DriverObject, PUNICODE_STRING RegistryPath)
{
  int v3; // eax
  void **v4; // rcx
  __int64 *v5; // rbx
  __int64 v6; // rcx
  ULONG v7; // edx
  struct _DEVICE_OBJECT *v8; // rcx
  PVOID v9; // rax
  int v10; // eax
  NTSTATUS result; // eax
  struct _UNICODE_STRING SystemRoutineName; // [rsp+30h] [rbp-18h] BYREF
  unsigned int v13; // [rsp+50h] [rbp+8h] BYREF

  qword_62248 = (__int64)&unk_4DAD0;
  qword_62250 = (__int64)&qword_62280;
  qword_62288 = (__int64)&unk_4DAE0;
  qword_62290 = (__int64)&qword_622C0;
  qword_62240 = 0i64;
  qword_622C8 = (__int64)&unk_4DAF0;
  qword_62260 = 0i64;
  qword_622D0 = (__int64)&qword_62300;
  byte_62268 = 1;
  qword_62308 = (__int64)&unk_4DB00;
  byte_62269 = 0;
  qword_62310 = (__int64)&qword_62340;
  word_6226A = 0;
  dword_6226C = 0;
  qword_62280 = 0i64;
  qword_622A0 = 0i64;
  qword_62348 = (__int64)&unk_4DB10;
  byte_622A8 = 1;
  byte_622A9 = 0;
  word_622AA = 0;
  dword_622AC = 0;
  qword_622C0 = 0i64;
  qword_622E0 = 0i64;
  byte_622E8 = 1;
  byte_622E9 = 0;
  word_622EA = 0;
  dword_622EC = 0;
  qword_62300 = 0i64;
  qword_62320 = 0i64;
  byte_62328 = 1;
  byte_62329 = 0;
  word_6232A = 0;
  dword_6232C = 0;
  qword_62340 = 0i64;
  qword_62350 = 0i64;
  qword_62360 = 0i64;
  byte_62368 = 1;
  byte_62369 = 0;
  word_6236A = 0;
  dword_6236C = 0;
  v13 = 0;
  RtlInitUnicodeString(&SystemRoutineName, L"PsGetVersion");
  qword_5F3D0 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))MmGetSystemRoutineAddress(&SystemRoutineName);
  RtlInitUnicodeString(&SystemRoutineName, L"WmiTraceMessage");
  qword_5F3B8 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))MmGetSystemRoutineAddress(&SystemRoutineName);
  if ( !qword_5F3B8 )
  {
    qword_5F3B8 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_11068;
    v3 = 1;
LABEL_3:
    dword_5F3D8 = v3;
    goto LABEL_10;
  }
  RtlInitUnicodeString(&SystemRoutineName, L"WmiQueryTraceInformation");
  qword_5F3B0 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))MmGetSystemRoutineAddress(&SystemRoutineName);
  v3 = 2;
  dword_5F3D8 = 2;
  if ( qword_5F3D0 )
  {
    qword_5F3D0(&v13, 0i64, 0i64, 0i64);
    v3 = dword_5F3D8;
  }
  if ( v13 >= 6 )
  {
    RtlInitUnicodeString(&SystemRoutineName, L"EtwRegisterClassicProvider");
    qword_5F3C8 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))MmGetSystemRoutineAddress(&SystemRoutineName);
    if ( qword_5F3C8 )
    {
      RtlInitUnicodeString(&SystemRoutineName, L"EtwUnregister");
      qword_5F3C0 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))MmGetSystemRoutineAddress(&SystemRoutineName);
      v3 = 4;
      goto LABEL_3;
    }
    v3 = dword_5F3D8;
  }
LABEL_10:
  v4 = (void **)off_5F148;
  v5 = &qword_62240;
  qword_62260 = 0i64;
  if ( off_5F148 != &qword_62240 )
  {
    off_5F148 = &qword_62240;
    if ( v3 == 4 )
    {
      do
      {
        v6 = v5[1];
        v5[7] = 0i64;
        qword_5F3C8(v6, 0i64, sub_111BC, v5, v5 + 7);
        v5 = (__int64 *)v5[2];
      }
      while ( v5 );
    }
    else
    {
      if ( v3 == 2 )
      {
        v7 = -2147418111;
        v8 = (struct _DEVICE_OBJECT *)&qword_62240;
        qword_62240 = (__int64)sub_65008;
      }
      else
      {
        qword_62240 = 0i64;
        v7 = 1;
        v8 = (struct _DEVICE_OBJECT *)DriverObject;
      }
      IoWMIRegistrationControl(v8, v7);
    }
    v4 = (void **)off_5F148;
  }
  if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 300) & 1) != 0 && *((_BYTE *)v4 + 297) >= 5u )
    sub_11008((__int64)v4[35], 0xAu, (__int64)&unk_4DD48);
  sub_2C86C();
  sub_2C86C();
  if ( !P )
  {
    dword_5F5E0 = 5;
    qword_62090 = (__int64)aNprotreceivedp;
    v9 = sub_26404(2, 0x14u, 0x72746E63u);
    P = v9;
    if ( v9 )
      memset(v9, 0, 0x14ui64);
  }
  DriverObject->DriverUnload = (PDRIVER_UNLOAD)sub_11658;
  v10 = sub_118FC();
  if ( v10 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0xBu, (__int64)&unk_4DD48, v10);
    sub_11658((PDEVICE_OBJECT)DriverObject);
    result = -1073741823;
  }
  else
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 35), 0xCu, (__int64)&unk_4DD48);
    result = 0;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;
// 5F1B0: using guessed type wchar_t aNprotreceivedp[21];
// 5F3B0: using guessed type __int64 (__fastcall *qword_5F3B0)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 5F3C0: using guessed type __int64 (__fastcall *qword_5F3C0)(_QWORD, _QWORD, _QWORD);
// 5F3C8: using guessed type __int64 (__fastcall *qword_5F3C8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 5F3D0: using guessed type __int64 (__fastcall *qword_5F3D0)(_QWORD, _QWORD, _QWORD, _QWORD);
// 5F3D8: using guessed type int dword_5F3D8;
// 5F5E0: using guessed type int dword_5F5E0;
// 62090: using guessed type __int64 qword_62090;
// 62240: using guessed type __int64 qword_62240;
// 62248: using guessed type __int64 qword_62248;
// 62250: using guessed type __int64 qword_62250;
// 62260: using guessed type __int64 qword_62260;
// 62268: using guessed type char byte_62268;
// 62269: using guessed type char byte_62269;
// 6226A: using guessed type __int16 word_6226A;
// 6226C: using guessed type int dword_6226C;
// 62280: using guessed type __int64 qword_62280;
// 62288: using guessed type __int64 qword_62288;
// 62290: using guessed type __int64 qword_62290;
// 622A0: using guessed type __int64 qword_622A0;
// 622A8: using guessed type char byte_622A8;
// 622A9: using guessed type char byte_622A9;
// 622AA: using guessed type __int16 word_622AA;
// 622AC: using guessed type int dword_622AC;
// 622C0: using guessed type __int64 qword_622C0;
// 622C8: using guessed type __int64 qword_622C8;
// 622D0: using guessed type __int64 qword_622D0;
// 622E0: using guessed type __int64 qword_622E0;
// 622E8: using guessed type char byte_622E8;
// 622E9: using guessed type char byte_622E9;
// 622EA: using guessed type __int16 word_622EA;
// 622EC: using guessed type int dword_622EC;
// 62300: using guessed type __int64 qword_62300;
// 62308: using guessed type __int64 qword_62308;
// 62310: using guessed type __int64 qword_62310;
// 62320: using guessed type __int64 qword_62320;
// 62328: using guessed type char byte_62328;
// 62329: using guessed type char byte_62329;
// 6232A: using guessed type __int16 word_6232A;
// 6232C: using guessed type int dword_6232C;
// 62340: using guessed type __int64 qword_62340;
// 62348: using guessed type __int64 qword_62348;
// 62350: using guessed type __int64 qword_62350;
// 62360: using guessed type __int64 qword_62360;
// 62368: using guessed type char byte_62368;
// 62369: using guessed type char byte_62369;
// 6236A: using guessed type __int16 word_6236A;
// 6236C: using guessed type int dword_6236C;

//----- (0000000000011658) ----------------------------------------------------
void __fastcall sub_11658(PDEVICE_OBJECT DeviceObject)
{
  void **v2; // rcx
  PVOID v3; // rbx
  __int64 v4; // rdx
  __int64 v5; // r8
  void **v6; // rbx
  ULONG v7; // edx
  struct _DEVICE_OBJECT *v8; // rcx
  void *v9; // rcx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0xDu, (__int64)&unk_4DD48);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 300) & 1) != 0 && *((_BYTE *)v2 + 297) >= 5u )
      sub_11008((__int64)v2[35], 0x14u, (__int64)&unk_4DD48);
  }
  sub_3027C(0);
  KeCancelTimer(&Timer);
  v3 = qword_5F498;
  if ( qword_5F498 )
  {
    if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 108) < 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
      sub_26384(*((_QWORD *)off_5F148 + 11), 0x2Du);
    sub_285FC(v3);
  }
  if ( byte_5F494 )
    sub_2D528();
  sub_146C4();
  sub_30C50();
  if ( byte_5F494 )
  {
    sub_2D654();
    byte_5F494 = 0;
  }
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x15u, (__int64)&unk_4DD48);
    v6 = (void **)off_5F148;
  }
  if ( P )
  {
    sub_26488(P, 0x72746E63u);
    P = 0i64;
    v6 = (void **)off_5F148;
  }
  if ( v6 != &off_5F148 )
  {
    if ( _bittest((const signed __int32 *)v6 + 43, 0x12u) && *((_BYTE *)v6 + 169) >= 5u )
    {
      sub_11008((__int64)v6[19], 0xDu, (__int64)&unk_4DC18);
      v6 = (void **)off_5F148;
    }
    if ( v6 != &off_5F148 )
    {
      if ( _bittest((const signed __int32 *)v6 + 43, 0x12u) && *((_BYTE *)v6 + 169) >= 5u )
      {
        sub_1102C((__int64)v6[19], 0xEu, (__int64)&unk_4DC18, 0);
        v6 = (void **)off_5F148;
      }
      if ( v6 != &off_5F148 )
      {
        if ( (*((_BYTE *)v6 + 300) & 1) != 0 && *((_BYTE *)v6 + 297) >= 5u )
        {
          sub_11008((__int64)v6[35], 0xEu, (__int64)&unk_4DD48);
          v6 = (void **)off_5F148;
        }
        if ( v6 != &off_5F148 )
        {
          if ( dword_5F3D8 == 4 )
          {
            while ( v6 )
            {
              v9 = v6[7];
              if ( v9 )
                qword_5F3C0(v9, v4, v5);
              v6 = (void **)v6[2];
            }
          }
          else
          {
            v7 = 2;
            if ( dword_5F3D8 == 2 )
            {
              v7 = -2147483646;
              v8 = (struct _DEVICE_OBJECT *)v6;
            }
            else
            {
              v8 = DeviceObject;
            }
            IoWMIRegistrationControl(v8, v7);
          }
          off_5F148 = &off_5F148;
        }
      }
    }
  }
}
// 118C4: variable 'v4' is possibly undefined
// 118C4: variable 'v5' is possibly undefined
// 5F148: using guessed type void *off_5F148;
// 5F3C0: using guessed type __int64 (__fastcall *qword_5F3C0)(_QWORD, _QWORD, _QWORD);
// 5F3D8: using guessed type int dword_5F3D8;
// 5F494: using guessed type char byte_5F494;

//----- (00000000000118FC) ----------------------------------------------------
__int64 sub_118FC()
{
  int v0; // eax
  unsigned int v1; // ebx
  void **v2; // rcx
  int v3; // eax
  int v4; // eax

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xFu, (__int64)&unk_4DD48);
  v0 = sub_11C4C();
  v1 = v0;
  if ( !v0 )
  {
    byte_5F494 = 1;
    v3 = sub_1486C();
    if ( v3 && off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x11u, (__int64)&unk_4DD48, v3);
    v4 = sub_25D6C();
    if ( v4 )
    {
      v2 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 1) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
        goto LABEL_21;
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x12u, (__int64)&unk_4DD48, v4);
    }
    v2 = (void **)off_5F148;
LABEL_21:
    v1 = 0;
    goto LABEL_22;
  }
  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x10u, (__int64)&unk_4DD48, v0);
    v2 = (void **)off_5F148;
  }
LABEL_22:
  if ( !v1 )
  {
    if ( v2 != &off_5F148 && *((char *)v2 + 108) < 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_26384((__int64)v2[11], 0x2Bu);
    qword_5F498 = (PVOID)sub_283D8();
    if ( qword_5F498 )
    {
      KeInitializeDpc(&Dpc, (PKDEFERRED_ROUTINE)DeferredRoutine, sub_11B24);
      KeInitializeTimer(&Timer);
      qword_621A0 = -10000000i64;
      KeSetTimer(&Timer, (LARGE_INTEGER)-10000000i64, &Dpc);
    }
    else
    {
      v1 = 3;
    }
    v2 = (void **)off_5F148;
  }
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 300) & 1) != 0 && *((_BYTE *)v2 + 297) >= 5u )
    sub_11008((__int64)v2[35], 0x13u, (__int64)&unk_4DD48);
  return v1;
}
// 5F148: using guessed type void *off_5F148;
// 5F494: using guessed type char byte_5F494;
// 621A0: using guessed type __int64 qword_621A0;

//----- (0000000000011B24) ----------------------------------------------------
void sub_11B24()
{
  _QWORD *v0; // rax

  v0 = sub_27398();
  if ( v0 )
  {
    sub_27504((__int64)v0);
  }
  else if ( off_5F148 != &off_5F148
         && _bittest((const signed __int32 *)off_5F148 + 43, 0xEu)
         && *((_BYTE *)off_5F148 + 169) >= 2u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x16u, (__int64)&unk_4DD48);
  }
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000011BB4) ----------------------------------------------------
__int64 sub_11BB4()
{
  __int64 result; // rax

  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 0xEu)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x17u, (__int64)&unk_4DD48);
  }
  result = sub_23424(*(PERESOURCE *)(qword_62198 + 24));
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 0xEu)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    result = sub_11008(*((_QWORD *)off_5F148 + 19), 0x18u, (__int64)&unk_4DD48);
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;
// 62198: using guessed type __int64 qword_62198;

//----- (0000000000011C4C) ----------------------------------------------------
__int64 sub_11C4C()
{
  int v0; // eax
  int v2; // eax
  unsigned int v3; // ebx
  void **v4; // rcx
  unsigned __int16 v5; // dx
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  __int64 v10[4]; // [rsp+20h] [rbp-C8h] BYREF
  int v11; // [rsp+40h] [rbp-A8h] BYREF
  char Dst[34]; // [rsp+44h] [rbp-A4h] BYREF
  char v13[94]; // [rsp+66h] [rbp-82h] BYREF
  int v14; // [rsp+C4h] [rbp-24h]
  char v15; // [rsp+C8h] [rbp-20h]

  v11 = 33644544;
  memmove(Dst, L"NetworkProtector", 0x22ui64);
  memset(v13, 0, sizeof(v13));
  v14 = 1414549070;
  v10[0] = (__int64)sub_12298;
  v15 = 30;
  v10[1] = (__int64)sub_12490;
  v10[2] = (__int64)sub_12598;
  v10[3] = (__int64)sub_1216C;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xAu, (__int64)&unk_4DD38);
  v0 = sub_2CC10((__int64)&v11, 148i64, v10);
  if ( v0 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0xBu, (__int64)&unk_4DD38, v0);
    return 258i64;
  }
  v2 = sub_30318(40004, 1);
  v3 = v2;
  if ( v2 )
  {
    v4 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      v5 = 12;
LABEL_16:
      sub_1102C((__int64)v4[35], v5, (__int64)&unk_4DD38, v2);
LABEL_70:
      v4 = (void **)off_5F148;
      goto LABEL_71;
    }
    goto LABEL_71;
  }
  v2 = sub_30318(40016, 1);
  v3 = v2;
  if ( v2 )
  {
    v4 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      v5 = 13;
      goto LABEL_16;
    }
LABEL_71:
    if ( !v3 )
      goto LABEL_73;
    goto LABEL_72;
  }
  v2 = sub_304F8(40000, (__int64)sub_12878);
  v3 = v2;
  if ( v2 )
  {
    v4 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      v5 = 14;
      goto LABEL_16;
    }
    goto LABEL_71;
  }
  v2 = sub_304F8(40043, (__int64)sub_12D54);
  v3 = v2;
  if ( v2 )
  {
    v4 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      v5 = 15;
      goto LABEL_16;
    }
    goto LABEL_71;
  }
  v2 = sub_33638(40050, (__int64)sub_132A0);
  v3 = v2;
  if ( v2 )
  {
    v4 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      v5 = 16;
      goto LABEL_16;
    }
    goto LABEL_71;
  }
  v2 = sub_33440(40019, (__int64)sub_12C30);
  v3 = v2;
  if ( v2 )
  {
    v4 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      v5 = 17;
      goto LABEL_16;
    }
    goto LABEL_71;
  }
  v6 = sub_33440(40017, (__int64)sub_12EC4);
  if ( v6 && off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x12u, (__int64)&unk_4DD38, v6);
  v7 = sub_33638(40045, (__int64)sub_13420);
  if ( v7 && off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x13u, (__int64)&unk_4DD38, v7);
  v8 = sub_33350();
  if ( v8 && off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x14u, (__int64)&unk_4DD38, v8);
  sub_3027C(0);
  if ( (unsigned int)sub_306EC() )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x15u, (__int64)&unk_4DD38);
    sub_30C50();
    v3 = 259;
  }
  else
  {
    v3 = sub_2D188();
    if ( !v3 )
    {
      v9 = sub_14440();
      v3 = v9;
      if ( !v9 )
      {
        sub_3027C(1);
        goto LABEL_70;
      }
      v4 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_1102C(*((_QWORD *)off_5F148 + 35), 0x16u, (__int64)&unk_4DD38, v9);
        goto LABEL_70;
      }
      goto LABEL_71;
    }
  }
LABEL_72:
  sub_2D654();
  v4 = (void **)off_5F148;
LABEL_73:
  if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 300) & 1) != 0 && *((_BYTE *)v4 + 297) >= 5u )
    sub_11008((__int64)v4[35], 0x17u, (__int64)&unk_4DD38);
  return v3;
}
// 4C630: using guessed type wchar_t aNetworkprotect[17];
// 5F148: using guessed type void *off_5F148;

//----- (000000000001216C) ----------------------------------------------------
__int64 __fastcall sub_1216C(__int64 a1)
{
  void **v2; // rcx
  _DWORD *v3; // rax
  __int64 result; // rax
  unsigned int v5; // eax
  unsigned int v6; // ebx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x18u, (__int64)&unk_4DD38);
    v2 = (void **)off_5F148;
  }
  v3 = *(_DWORD **)(a1 + 56);
  if ( v3 )
  {
    if ( *v3 == 8 )
    {
      v5 = sub_1589C(a1);
      v2 = (void **)off_5F148;
      v6 = v5;
    }
    else
    {
      if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 43, 8u) && *((_BYTE *)v2 + 169) >= 3u )
      {
        sub_11008((__int64)v2[19], 0x1Au, (__int64)&unk_4DD38);
        v2 = (void **)off_5F148;
      }
      v6 = 17;
    }
    if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 43, 8u) && *((_BYTE *)v2 + 169) >= 5u )
      sub_11008((__int64)v2[19], 0x1Bu, (__int64)&unk_4DD38);
    result = v6;
  }
  else
  {
    if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 43, 8u) && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x19u, (__int64)&unk_4DD38);
    result = 6i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000012298) ----------------------------------------------------
char __fastcall sub_12298(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  char v4; // r10

  *a4 = 0;
  v4 = 1;
  switch ( a1 )
  {
    case 33644546:
      *a2 = 0;
      goto LABEL_3;
    case 33644547:
      *a2 = 4;
      goto LABEL_3;
    case 33644548:
      *a2 = 32;
      goto LABEL_8;
    case 33644549:
      *a2 = 60;
      goto LABEL_8;
    case 33644550:
      *a2 = 33;
      goto LABEL_8;
    case 33644551:
      *a2 = 42;
      goto LABEL_14;
    case 33644552:
      *a2 = 43;
      goto LABEL_14;
    case 33644553:
      *a2 = 44;
      goto LABEL_3;
    case 33644554:
      *a2 = 48;
      goto LABEL_3;
    case 33644555:
      *a2 = 52;
      goto LABEL_3;
    case 33644556:
      *a2 = 56;
      goto LABEL_3;
    case 33644557:
      *a2 = 36;
      goto LABEL_11;
    case 33644558:
      *a2 = 40;
      goto LABEL_8;
    case 33644559:
      *a2 = 41;
      goto LABEL_14;
    case 33644560:
      *a2 = 8;
      goto LABEL_3;
    case 33644561:
      *a2 = 12;
      goto LABEL_3;
    case 33644562:
      *a2 = 16;
      goto LABEL_3;
    case 33644563:
      *a2 = 24;
      goto LABEL_3;
    case 33644564:
      *a2 = 61;
      goto LABEL_8;
    case 33644565:
      *a2 = 62;
LABEL_8:
      *a3 = 1;
      *a4 = 1;
      return v4;
    case 33644566:
      *a2 = 63;
LABEL_14:
      *a3 = 1;
      *a4 = 5;
      return v4;
    case 33644567:
      *a2 = 28;
      goto LABEL_3;
    case 33644568:
      *a2 = 20;
LABEL_3:
      *a3 = 4;
      return v4;
    case 33644569:
      *a2 = 64;
      goto LABEL_30;
    case 33644570:
      *a2 = 100;
      goto LABEL_11;
    case 33644571:
      *a2 = 104;
      goto LABEL_11;
    case 33644573:
      *a2 = 112;
LABEL_30:
      *a3 = 34;
      *a4 = 2;
      break;
    case 33644574:
      *a2 = 108;
LABEL_11:
      *a3 = 4;
      *a4 = 0;
      break;
    default:
      v4 = 0;
      break;
  }
  return v4;
}

//----- (0000000000012490) ----------------------------------------------------
__int64 __fastcall sub_12490(__int64 a1)
{
  __int64 result; // rax

  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1Cu, (__int64)&unk_4DD38);
  }
  result = 769i64;
  *(_DWORD *)(a1 + 36) = 3;
  *(_BYTE *)(a1 + 41) = 5;
  *(_DWORD *)a1 = 1;
  *(_DWORD *)(a1 + 4) = 25000;
  *(_DWORD *)(a1 + 8) = 1;
  *(_DWORD *)(a1 + 12) = 1;
  *(_BYTE *)(a1 + 32) = 1;
  *(_BYTE *)(a1 + 33) = 0;
  *(_BYTE *)(a1 + 40) = 1;
  *(_DWORD *)(a1 + 44) = 769;
  *(_DWORD *)(a1 + 48) = 769;
  *(_DWORD *)(a1 + 52) = 769;
  *(_DWORD *)(a1 + 56) = 769;
  *(_DWORD *)(a1 + 16) = 25000;
  *(_DWORD *)(a1 + 20) = 25000;
  *(_DWORD *)(a1 + 24) = 25000;
  *(_DWORD *)(a1 + 28) = 1;
  *(_BYTE *)(a1 + 60) = 1;
  *(_BYTE *)(a1 + 61) = 0;
  *(_BYTE *)(a1 + 62) = 0;
  *(_WORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 100) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 108) = 1;
  *(_BYTE *)(a1 + 42) = 12;
  *(_BYTE *)(a1 + 43) = 3;
  *(_BYTE *)(a1 + 63) = 2;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    result = sub_11008(*((_QWORD *)off_5F148 + 19), 0x1Du, (__int64)&unk_4DD38);
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000012598) ----------------------------------------------------
void __fastcall sub_12598(const signed __int32 *a1)
{
  void **v2; // rcx
  int v3; // eax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1Eu, (__int64)&unk_4DD38);
    v2 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v2 == &off_5F148 )
      return;
    if ( !_bittest((const signed __int32 *)v2 + 43, 8u) || *((_BYTE *)v2 + 169) < 2u )
      goto LABEL_16;
    sub_11008((__int64)v2[19], 0x1Fu, (__int64)&unk_4DD38);
    goto LABEL_15;
  }
  v3 = sub_16C40(a1);
  if ( !v3 )
  {
LABEL_15:
    v2 = (void **)off_5F148;
    goto LABEL_16;
  }
  v2 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return;
  if ( _bittest((const signed __int32 *)off_5F148 + 43, 8u) && *((_BYTE *)off_5F148 + 169) >= 2u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x20u, (__int64)&unk_4DD38, v3);
    goto LABEL_15;
  }
LABEL_16:
  if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 43, 8u) && *((_BYTE *)v2 + 169) >= 5u )
    sub_11008((__int64)v2[19], 0x21u, (__int64)&unk_4DD38);
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000126B4) ----------------------------------------------------
__int64 __fastcall sub_126B4(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+78h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DD28, 10i64, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001270C) ----------------------------------------------------
__int64 sub_1270C(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 v5; // [rsp+88h] [rbp+20h] BYREF
  va_list va; // [rsp+88h] [rbp+20h]
  const char *v7; // [rsp+90h] [rbp+28h]
  const char *v8; // [rsp+98h] [rbp+30h]
  va_list va1; // [rsp+A0h] [rbp+38h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, const char *);
  v8 = va_arg(va1, const char *);
  if ( v8 )
    strlen(v8);
  if ( v7 )
    strlen(v7);
  return qword_5F3B8(a1, 43i64, &unk_4DD28, 27i64, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000127D0) ----------------------------------------------------
__int64 __fastcall sub_127D0(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+78h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, a3, a2, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000012818) ----------------------------------------------------
__int64 sub_12818(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+98h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, a3, a2, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000012878) ----------------------------------------------------
__int64 __fastcall sub_12878(int a1, __int64 a2, __int64 a3, __int64 a4, int *a5)
{
  unsigned int v5; // esi
  void **v8; // rcx
  unsigned __int8 v9; // al
  int v10; // eax

  v5 = 0;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x15u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_126B4(*((_QWORD *)off_5F148 + 35), 10i64, (__int64)&unk_4DD28, a1);
  }
  *a5 = 1;
  if ( (unsigned __int8)sub_2DA90(0x2016002u) == 1 || (unsigned int)sub_2DA90(0x201601Au) )
  {
    if ( !a2 )
    {
      v8 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x15u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0xCu, (__int64)&unk_4DD28);
        v8 = (void **)off_5F148;
      }
      v5 = 4;
      goto LABEL_34;
    }
    if ( dword_5F5E0 )
      _InterlockedAdd((volatile signed __int32 *)P, 1u);
    v10 = sub_15538(a2, a4, a5, 0i64);
    v5 = v10;
    if ( v10 )
    {
      v8 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148
        || !_bittest((const signed __int32 *)off_5F148 + 75, 0x15u)
        || *((_BYTE *)off_5F148 + 297) < 2u )
      {
        goto LABEL_25;
      }
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0xDu, (__int64)&unk_4DD28, v10);
    }
  }
  else
  {
    v8 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 75, 0x15u)
      || *((_BYTE *)off_5F148 + 297) < 4u )
    {
      goto LABEL_25;
    }
    sub_2DA90(0x201601Au);
    v9 = sub_2DA90(0x2016002u);
    sub_127D0(*((_QWORD *)off_5F148 + 35), 0xBu, (__int64)&unk_4DD28, v9);
  }
  v8 = (void **)off_5F148;
LABEL_25:
  if ( a2 )
  {
    if ( *(char *)(a2 + 120) < 0 )
    {
      sub_13068(a2);
      v8 = (void **)off_5F148;
    }
    if ( v5 && (*(_BYTE *)(a2 + 120) & 4) != 0 )
    {
      sub_12B2C(a2, 0i64, a5, 0, 0i64, 0i64, v5);
      v8 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v5;
      if ( _bittest((const signed __int32 *)off_5F148 + 75, 0x15u) && *((_BYTE *)off_5F148 + 297) >= 5u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0xEu, (__int64)&unk_4DD28);
        v8 = (void **)off_5F148;
      }
    }
  }
LABEL_34:
  if ( v8 != &off_5F148 && _bittest((const signed __int32 *)v8 + 75, 0x15u) && *((_BYTE *)v8 + 297) >= 5u )
    sub_1102C((__int64)v8[35], 0x10u, (__int64)&unk_4DD28, v5);
  return v5;
}
// 5F148: using guessed type void *off_5F148;
// 5F5E0: using guessed type int dword_5F5E0;

//----- (0000000000012B2C) ----------------------------------------------------
__int64 __fastcall sub_12B2C(__int64 a1, __int64 a2, int *a3, int a4, __int64 a5, __int64 a6, int a7)
{
  int *v8; // r8
  const char *v9; // rdi
  const char *v10; // rax
  __int64 v11; // r9
  __int64 v12; // r10
  const char *v13; // rax
  char v15[128]; // [rsp+40h] [rbp-A8h] BYREF

  if ( a7 )
  {
    v13 = sub_34580(*a3);
    sub_4B484(v15, 0x80ui64, "|PROT-%I64u-%s-ERROR:0x%08X|", a6, v13, a7);
  }
  else
  {
    v9 = sub_34494(a4);
    v10 = sub_34580(*v8);
    sub_4B484(v15, 0x80ui64, "|PROT-%I64u-%s-ORIG:%s-GUID:%ws-ZONE:%ws|", a6, v10, v9, v11, v12);
  }
  return sub_347D0(a1, v15, strlen(v15));
}
// 12B80: variable 'v8' is possibly undefined
// 12BB8: variable 'v11' is possibly undefined
// 12BB8: variable 'v12' is possibly undefined

//----- (0000000000012C30) ----------------------------------------------------
__int64 __fastcall sub_12C30(int a1, unsigned __int64 *a2)
{
  void **v4; // rcx

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( _bittest((const signed __int32 *)off_5F148 + 75, 0x15u) && *((_BYTE *)off_5F148 + 297) >= 5u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x11u, (__int64)&unk_4DD28);
      v4 = (void **)off_5F148;
    }
    if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x15u) && *((_BYTE *)v4 + 297) >= 5u )
    {
      sub_1102C((__int64)v4[35], 0x12u, (__int64)&unk_4DD28, a1);
      v4 = (void **)off_5F148;
    }
  }
  if ( a2 )
  {
    sub_1314C(*a2);
LABEL_15:
    v4 = (void **)off_5F148;
    goto LABEL_16;
  }
  if ( v4 == &off_5F148 )
    return 0i64;
  if ( _bittest((const signed __int32 *)v4 + 75, 0x15u) && *((_BYTE *)v4 + 297) >= 2u )
  {
    sub_11008((__int64)v4[35], 0x13u, (__int64)&unk_4DD28);
    goto LABEL_15;
  }
LABEL_16:
  if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x15u) && *((_BYTE *)v4 + 297) >= 5u )
    sub_11008((__int64)v4[35], 0x14u, (__int64)&unk_4DD28);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000012D54) ----------------------------------------------------
__int64 __fastcall sub_12D54(int a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5)
{
  void **v7; // rcx
  int v9; // eax
  unsigned int v10; // ebx
  void **v11; // rcx

  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( _bittest((const signed __int32 *)off_5F148 + 75, 0x15u) && *((_BYTE *)off_5F148 + 297) >= 5u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x15u, (__int64)&unk_4DD28);
      v7 = (void **)off_5F148;
    }
    if ( v7 != &off_5F148 && _bittest((const signed __int32 *)v7 + 75, 0x15u) && *((_BYTE *)v7 + 297) >= 5u )
      sub_1102C((__int64)v7[35], 0x16u, (__int64)&unk_4DD28, a1);
  }
  *a5 = 1;
  if ( a2 )
  {
    v9 = sub_25448(a2, 1);
    v10 = v9;
    if ( v9 )
    {
      v11 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v10;
      if ( !_bittest((const signed __int32 *)off_5F148 + 75, 0x15u) || *((_BYTE *)off_5F148 + 297) < 5u )
      {
LABEL_21:
        if ( v11 != &off_5F148 && _bittest((const signed __int32 *)v11 + 75, 0x15u) && *((_BYTE *)v11 + 297) >= 5u )
          sub_11008((__int64)v11[35], 0x19u, (__int64)&unk_4DD28);
        return v10;
      }
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x18u, (__int64)&unk_4DD28, v9);
    }
    v11 = (void **)off_5F148;
    goto LABEL_21;
  }
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x15u)
    && *((_BYTE *)off_5F148 + 297) >= 2u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x17u, (__int64)&unk_4DD28);
  }
  return 4i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000012EC4) ----------------------------------------------------
__int64 __fastcall sub_12EC4(int a1, __int64 a2, unsigned int a3)
{
  void **v5; // r10
  const char *v6; // rax
  __int64 v7; // r10
  __int64 v8; // r8
  int v9; // eax

  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x15u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_142F4(*((_QWORD *)off_5F148 + 35), 0x1Au, (__int64)&unk_4DD28, a1);
    v5 = (void **)off_5F148;
  }
  if ( !a2 || a3 < 0x10 )
  {
    if ( v5 == &off_5F148 )
      return 0i64;
    if ( !_bittest((const signed __int32 *)v5 + 75, 0x15u) || *((_BYTE *)v5 + 297) < 2u )
      goto LABEL_21;
    sub_11008((__int64)v5[35], 0x1Du, (__int64)&unk_4DD28);
    goto LABEL_20;
  }
  if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 75, 0x15u) && *((_BYTE *)v5 + 297) >= 4u )
  {
    sub_34580(*(_DWORD *)a2);
    v6 = sub_347A8(*(_DWORD *)(a2 + 4));
    sub_1270C(*(_QWORD *)(v7 + 280), 27i64, (__int64)&unk_4DD28, *(_QWORD *)(a2 + 8), v6, v8);
  }
  v9 = sub_223D0(*(PERESOURCE *)(qword_62198 + 24), a2);
  if ( !v9 )
  {
LABEL_20:
    v5 = (void **)off_5F148;
    goto LABEL_21;
  }
  v5 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return 0i64;
  if ( _bittest((const signed __int32 *)off_5F148 + 75, 0x15u) && *((_BYTE *)off_5F148 + 297) >= 2u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x1Cu, (__int64)&unk_4DD28, v9);
    goto LABEL_20;
  }
LABEL_21:
  if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 75, 0x15u) && *((_BYTE *)v5 + 297) >= 5u )
    sub_11008((__int64)v5[35], 0x1Eu, (__int64)&unk_4DD28);
  return 0i64;
}
// 12F75: variable 'v7' is possibly undefined
// 12F8E: variable 'v8' is possibly undefined
// 5F148: using guessed type void *off_5F148;
// 62198: using guessed type __int64 qword_62198;

//----- (0000000000013068) ----------------------------------------------------
__int64 __fastcall sub_13068(__int64 a1)
{
  void **v2; // rcx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x15u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x1Fu, (__int64)&unk_4DD28);
    v2 = (void **)off_5F148;
  }
  if ( *(_QWORD *)(a1 + 312) )
  {
    sub_1314C(*(_QWORD *)(a1 + 312));
    goto LABEL_11;
  }
  if ( v2 == &off_5F148 )
    return 0i64;
  if ( _bittest((const signed __int32 *)v2 + 75, 0x15u) && *((_BYTE *)v2 + 297) >= 2u )
  {
    sub_11008((__int64)v2[35], 0x20u, (__int64)&unk_4DD28);
LABEL_11:
    v2 = (void **)off_5F148;
  }
  if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 75, 0x15u) && *((_BYTE *)v2 + 297) >= 5u )
    sub_11008((__int64)v2[35], 0x21u, (__int64)&unk_4DD28);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001314C) ----------------------------------------------------
__int64 __fastcall sub_1314C(unsigned __int64 a1)
{
  void **v1; // rax
  int v2; // eax
  void **v3; // rcx
  unsigned __int64 v5; // [rsp+30h] [rbp+8h]

  v5 = a1;
  v1 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( _bittest((const signed __int32 *)off_5F148 + 75, 0x15u) && *((_BYTE *)off_5F148 + 297) >= 5u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x22u, (__int64)&unk_4DD28);
      a1 = v5;
      v1 = (void **)off_5F148;
    }
    if ( v1 != &off_5F148 && _bittest((const signed __int32 *)v1 + 75, 0x15u) && *((_BYTE *)v1 + 297) >= 4u )
    {
      sub_17984((__int64)v1[35], 0x23u, (__int64)&unk_4DD28, a1);
      a1 = v5;
    }
  }
  v2 = sub_163F4(a1);
  if ( !v2 )
  {
    v3 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148 )
      return 0i64;
    if ( !_bittest((const signed __int32 *)off_5F148 + 75, 0x15u) || *((_BYTE *)off_5F148 + 297) < 5u )
      goto LABEL_19;
    sub_17984(*((_QWORD *)off_5F148 + 35), 0x25u, (__int64)&unk_4DD28, v5);
    goto LABEL_18;
  }
  v3 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return 0i64;
  if ( _bittest((const signed __int32 *)off_5F148 + 75, 0x15u) && *((_BYTE *)off_5F148 + 297) >= 3u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x24u, (__int64)&unk_4DD28, v2);
LABEL_18:
    v3 = (void **)off_5F148;
  }
LABEL_19:
  if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x15u) && *((_BYTE *)v3 + 297) >= 5u )
    sub_11008((__int64)v3[35], 0x26u, (__int64)&unk_4DD28);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000132A0) ----------------------------------------------------
__int64 __fastcall sub_132A0(int a1, __int64 a2, int a3, _DWORD *a4, void **a5, _DWORD *a6)
{
  void **v9; // rcx
  __int64 result; // rax
  PVOID v11; // rax

  v9 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x15u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x27u, (__int64)&unk_4DD28, a1);
    v9 = (void **)off_5F148;
  }
  if ( a3 == 232 )
  {
    v11 = sub_26404(2, 0xE8u, 0x6444504Eu);
    *a5 = v11;
    if ( v11 )
    {
      *a4 = 232;
      *a6 = 1682198606;
      memmove(*a5, &dword_5F4A0, 0xE8ui64);
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x15u)
        && *((_BYTE *)off_5F148 + 297) >= 5u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x2Au, (__int64)&unk_4DD28);
      }
      result = 0i64;
    }
    else
    {
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x15u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x29u, (__int64)&unk_4DD28);
      }
      result = 3i64;
    }
  }
  else
  {
    if ( v9 != &off_5F148 && _bittest((const signed __int32 *)v9 + 75, 0x15u) && *((_BYTE *)v9 + 297) >= 2u )
      sub_1102C((__int64)v9[35], 0x28u, (__int64)&unk_4DD28, a3);
    result = 6i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;
// 5F4A0: using guessed type int dword_5F4A0;

//----- (0000000000013420) ----------------------------------------------------
__int64 __fastcall sub_13420(int a1, __int64 a2, __int64 a3, _DWORD *a4, _QWORD *a5, _DWORD *a6)
{
  unsigned int v6; // ebx
  void **v10; // rcx
  _DWORD *v11; // rsi
  _QWORD *v12; // rdi
  PVOID v13; // rax
  void *v15[2]; // [rsp+40h] [rbp-28h] BYREF
  unsigned int v16; // [rsp+78h] [rbp+10h] BYREF

  v6 = 0;
  v15[0] = 0i64;
  v16 = 0;
  v10 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x15u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x2Bu, (__int64)&unk_4DD28, a1);
    v10 = (void **)off_5F148;
  }
  v11 = a6;
  v12 = a5;
  if ( a2 && a4 && a5 && a6 )
  {
    sub_25994(v15, &v16);
    v13 = sub_26404(2, v16, 0x614C504Eu);
    *v12 = v13;
    if ( v13 )
    {
      sub_4B4A8(v13, v16, v15[0], v16);
      sub_25C34(v15);
      *a4 = v16;
      *v11 = 1632391246;
      v10 = (void **)off_5F148;
    }
    else
    {
      v10 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x2Du, (__int64)&unk_4DD28);
        v10 = (void **)off_5F148;
      }
      v6 = 3;
    }
  }
  else
  {
    if ( v10 != &off_5F148 && _bittest((const signed __int32 *)v10 + 75, 0x16u) && *((_BYTE *)v10 + 297) >= 2u )
    {
      sub_12818((__int64)v10[35], 0x2Cu, (__int64)&unk_4DD28, a2, a4, a5, a6);
      v10 = (void **)off_5F148;
    }
    v6 = 4;
  }
  if ( v10 != &off_5F148 && _bittest((const signed __int32 *)v10 + 75, 0x15u) && *((_BYTE *)v10 + 297) >= 5u )
    sub_11008((__int64)v10[35], 0x2Eu, (__int64)&unk_4DD28);
  return v6;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000013618) ----------------------------------------------------
__int64 __fastcall sub_13618(__int64 a1, unsigned __int16 a2, __int64 a3, const char *a4)
{
  const char *v5; // rax

  if ( a4 )
    strlen(a4);
  v5 = "NULL";
  if ( a4 )
    v5 = a4;
  return qword_5F3B8(a1, 43i64, a3, a2, v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000013678) ----------------------------------------------------
void __fastcall sub_13678(__int64 *a1)
{
  void **v2; // rcx
  unsigned __int16 v3; // dx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( _bittest((const signed __int32 *)off_5F148 + 75, 0xDu) && *((_BYTE *)off_5F148 + 297) >= 5u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0xAu, (__int64)&unk_4DD18);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 )
    {
      if ( _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 4u )
      {
        sub_11008((__int64)v2[35], 0xBu, (__int64)&unk_4DD18);
        v2 = (void **)off_5F148;
      }
      if ( v2 != &off_5F148 )
      {
        if ( _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 4u )
        {
          sub_11008((__int64)v2[35], 0xCu, (__int64)&unk_4DD18);
          v2 = (void **)off_5F148;
        }
        if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 4u )
        {
          sub_11008((__int64)v2[35], 0xDu, (__int64)&unk_4DD18);
          v2 = (void **)off_5F148;
        }
      }
    }
  }
  if ( !a1 )
  {
    if ( v2 == &off_5F148 )
      return;
    if ( !_bittest((const signed __int32 *)v2 + 75, 0xDu) || *((_BYTE *)v2 + 297) < 2u )
      goto LABEL_30;
    v3 = 14;
    goto LABEL_22;
  }
  if ( (unsigned __int8)sub_2DA90(0x2016006u) )
  {
    sub_3C9C8(*a1);
    goto LABEL_29;
  }
  v2 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return;
  if ( _bittest((const signed __int32 *)off_5F148 + 75, 0xDu) && *((_BYTE *)off_5F148 + 297) >= 4u )
  {
    v3 = 15;
LABEL_22:
    sub_11008((__int64)v2[35], v3, (__int64)&unk_4DD18);
LABEL_29:
    v2 = (void **)off_5F148;
  }
LABEL_30:
  if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 5u )
    sub_11008((__int64)v2[35], 0x10u, (__int64)&unk_4DD18);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000013830) ----------------------------------------------------
__int64 __fastcall sub_13830(__int64 a1)
{
  void **v2; // rcx
  __int64 result; // rax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( _bittest((const signed __int32 *)off_5F148 + 75, 0xDu) && *((_BYTE *)off_5F148 + 297) >= 5u )
    {
      result = sub_11008(*((_QWORD *)off_5F148 + 35), 0x11u, (__int64)&unk_4DD18);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 )
    {
      if ( _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 4u )
      {
        result = sub_11008((__int64)v2[35], 0x12u, (__int64)&unk_4DD18);
        v2 = (void **)off_5F148;
      }
      if ( v2 != &off_5F148 )
      {
        if ( _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 4u )
        {
          result = sub_11008((__int64)v2[35], 0x13u, (__int64)&unk_4DD18);
          v2 = (void **)off_5F148;
        }
        if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 4u )
        {
          result = sub_11008((__int64)v2[35], 0x14u, (__int64)&unk_4DD18);
          v2 = (void **)off_5F148;
        }
      }
    }
  }
  if ( !a1 )
  {
    if ( v2 == &off_5F148 )
      return result;
    if ( !_bittest((const signed __int32 *)v2 + 75, 0xDu) || *((_BYTE *)v2 + 297) < 2u )
      goto LABEL_35;
    result = sub_11008((__int64)v2[35], 0x15u, (__int64)&unk_4DD18);
    goto LABEL_34;
  }
  if ( v2 != &off_5F148 )
  {
    if ( _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 4u )
    {
      result = sub_17984((__int64)v2[35], 0x16u, (__int64)&unk_4DD18, *(_QWORD *)a1);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 )
    {
      if ( _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 4u )
      {
        result = sub_1102C((__int64)v2[35], 0x17u, (__int64)&unk_4DD18, *(_DWORD *)(a1 + 12));
        v2 = (void **)off_5F148;
      }
      if ( v2 != &off_5F148 )
      {
        if ( !_bittest((const signed __int32 *)v2 + 75, 0xDu) || *((_BYTE *)v2 + 297) < 4u )
        {
LABEL_35:
          if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 5u )
            result = sub_11008((__int64)v2[35], 0x19u, (__int64)&unk_4DD18);
          return result;
        }
        result = sub_1102C((__int64)v2[35], 0x18u, (__int64)&unk_4DD18, *(_DWORD *)(a1 + 16));
LABEL_34:
        v2 = (void **)off_5F148;
        goto LABEL_35;
      }
    }
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000013A5C) ----------------------------------------------------
void __fastcall sub_13A5C(__int64 a1)
{
  void **v2; // rcx
  unsigned __int16 v3; // dx
  void **v4; // rcx
  void **v5; // rcx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x27u, (__int64)&unk_4DD18);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 )
    {
      if ( _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 4u )
      {
        sub_11008((__int64)v2[35], 0x28u, (__int64)&unk_4DD18);
        v2 = (void **)off_5F148;
      }
      if ( v2 != &off_5F148 )
      {
        if ( _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 4u )
        {
          sub_11008((__int64)v2[35], 0x29u, (__int64)&unk_4DD18);
          v2 = (void **)off_5F148;
        }
        if ( v2 != &off_5F148 )
        {
          if ( _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 4u )
          {
            sub_11008((__int64)v2[35], 0x2Au, (__int64)&unk_4DD18);
            v2 = (void **)off_5F148;
          }
          if ( v2 != &off_5F148 )
          {
            if ( _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 4u )
            {
              sub_11008((__int64)v2[35], 0x2Bu, (__int64)&unk_4DD18);
              v2 = (void **)off_5F148;
            }
            if ( v2 != &off_5F148 )
            {
              if ( _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 4u )
              {
                sub_11008((__int64)v2[35], 0x2Cu, (__int64)&unk_4DD18);
                v2 = (void **)off_5F148;
              }
              if ( v2 != &off_5F148 )
              {
                if ( _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 4u )
                {
                  sub_11008((__int64)v2[35], 0x2Du, (__int64)&unk_4DD18);
                  v2 = (void **)off_5F148;
                }
                if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 4u )
                {
                  sub_11008((__int64)v2[35], 0x2Eu, (__int64)&unk_4DD18);
                  v2 = (void **)off_5F148;
                }
              }
            }
          }
        }
      }
    }
  }
  if ( !a1 )
  {
    if ( v2 == &off_5F148 )
      return;
    if ( !_bittest((const signed __int32 *)v2 + 75, 0xDu) || *((_BYTE *)v2 + 297) < 4u )
      goto LABEL_86;
    v3 = 47;
    goto LABEL_38;
  }
  if ( (unsigned __int8)sub_2DA90(0x2016006u) )
  {
    v4 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 )
    {
      if ( _bittest((const signed __int32 *)off_5F148 + 75, 0xDu) && *((_BYTE *)off_5F148 + 297) >= 4u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x31u, (__int64)&unk_4DD18);
        v4 = (void **)off_5F148;
      }
      if ( v4 != &off_5F148 )
      {
        if ( _bittest((const signed __int32 *)v4 + 75, 0xDu) && *((_BYTE *)v4 + 297) >= 4u )
        {
          sub_11008((__int64)v4[35], 0x32u, (__int64)&unk_4DD18);
          v4 = (void **)off_5F148;
        }
        if ( v4 != &off_5F148 )
        {
          if ( _bittest((const signed __int32 *)v4 + 75, 0xDu) && *((_BYTE *)v4 + 297) >= 4u )
          {
            sub_11008((__int64)v4[35], 0x33u, (__int64)&unk_4DD18);
            v4 = (void **)off_5F148;
          }
          if ( v4 != &off_5F148 )
          {
            if ( _bittest((const signed __int32 *)v4 + 75, 0xDu) && *((_BYTE *)v4 + 297) >= 4u )
            {
              sub_11008((__int64)v4[35], 0x34u, (__int64)&unk_4DD18);
              v4 = (void **)off_5F148;
            }
            if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0xDu) && *((_BYTE *)v4 + 297) >= 4u )
              sub_11008((__int64)v4[35], 0x35u, (__int64)&unk_4DD18);
          }
        }
      }
    }
    sub_13F34(*(__int64 **)(a1 + 16));
    v5 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 )
    {
      if ( _bittest((const signed __int32 *)off_5F148 + 75, 0xDu) && *((_BYTE *)off_5F148 + 297) >= 4u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x36u, (__int64)&unk_4DD18);
        v5 = (void **)off_5F148;
      }
      if ( v5 != &off_5F148 )
      {
        if ( _bittest((const signed __int32 *)v5 + 75, 0xDu) && *((_BYTE *)v5 + 297) >= 4u )
        {
          sub_11008((__int64)v5[35], 0x37u, (__int64)&unk_4DD18);
          v5 = (void **)off_5F148;
        }
        if ( v5 != &off_5F148 )
        {
          if ( _bittest((const signed __int32 *)v5 + 75, 0xDu) && *((_BYTE *)v5 + 297) >= 4u )
          {
            sub_11008((__int64)v5[35], 0x38u, (__int64)&unk_4DD18);
            v5 = (void **)off_5F148;
          }
          if ( v5 != &off_5F148 )
          {
            if ( _bittest((const signed __int32 *)v5 + 75, 0xDu) && *((_BYTE *)v5 + 297) >= 4u )
            {
              sub_11008((__int64)v5[35], 0x39u, (__int64)&unk_4DD18);
              v5 = (void **)off_5F148;
            }
            if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 75, 0xDu) && *((_BYTE *)v5 + 297) >= 4u )
              sub_11008((__int64)v5[35], 0x3Au, (__int64)&unk_4DD18);
          }
        }
      }
    }
    sub_47580(*(_QWORD *)(a1 + 8));
    goto LABEL_85;
  }
  v2 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return;
  if ( _bittest((const signed __int32 *)off_5F148 + 75, 0xDu) && *((_BYTE *)off_5F148 + 297) >= 4u )
  {
    v3 = 48;
LABEL_38:
    sub_11008((__int64)v2[35], v3, (__int64)&unk_4DD18);
LABEL_85:
    v2 = (void **)off_5F148;
  }
LABEL_86:
  if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 5u )
    sub_11008((__int64)v2[35], 0x3Fu, (__int64)&unk_4DD18);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000013F34) ----------------------------------------------------
void __fastcall sub_13F34(__int64 *a1)
{
  void **v2; // rcx
  unsigned __int16 v3; // dx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( _bittest((const signed __int32 *)off_5F148 + 75, 0xDu) && *((_BYTE *)off_5F148 + 297) >= 5u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x53u, (__int64)&unk_4DD18);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 )
    {
      if ( _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 4u )
      {
        sub_11008((__int64)v2[35], 0x54u, (__int64)&unk_4DD18);
        v2 = (void **)off_5F148;
      }
      if ( v2 != &off_5F148 )
      {
        if ( _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 4u )
        {
          sub_11008((__int64)v2[35], 0x55u, (__int64)&unk_4DD18);
          v2 = (void **)off_5F148;
        }
        if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 4u )
        {
          sub_11008((__int64)v2[35], 0x56u, (__int64)&unk_4DD18);
          v2 = (void **)off_5F148;
        }
      }
    }
  }
  if ( !a1 )
  {
    if ( v2 == &off_5F148 )
      return;
    if ( !_bittest((const signed __int32 *)v2 + 75, 0xDu) || *((_BYTE *)v2 + 297) < 2u )
      goto LABEL_30;
    v3 = 87;
    goto LABEL_22;
  }
  if ( (unsigned __int8)sub_2DA90(0x2016006u) )
  {
    sub_47580(*a1);
    goto LABEL_29;
  }
  v2 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return;
  if ( _bittest((const signed __int32 *)off_5F148 + 75, 0xDu) && *((_BYTE *)off_5F148 + 297) >= 4u )
  {
    v3 = 88;
LABEL_22:
    sub_11008((__int64)v2[35], v3, (__int64)&unk_4DD18);
LABEL_29:
    v2 = (void **)off_5F148;
  }
LABEL_30:
  if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 75, 0xDu) && *((_BYTE *)v2 + 297) >= 5u )
    sub_11008((__int64)v2[35], 0x59u, (__int64)&unk_4DD18);
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000140EC) ----------------------------------------------------
void __fastcall sub_140EC(_QWORD *a1)
{
  void **v2; // rcx
  unsigned __int16 v3; // dx
  void **v4; // rcx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x11u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x5Au, (__int64)&unk_4DD18);
    v2 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 75, 0x11u) && *((_BYTE *)v2 + 297) >= 4u )
    {
      v3 = 91;
LABEL_37:
      sub_11008((__int64)v2[35], v3, (__int64)&unk_4DD18);
      return;
    }
    return;
  }
  if ( (unsigned __int8)sub_2DA90(0x2016006u) )
  {
    v4 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 )
    {
      if ( _bittest((const signed __int32 *)off_5F148 + 75, 0x11u) && *((_BYTE *)off_5F148 + 297) >= 4u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x5Du, (__int64)&unk_4DD18);
        v4 = (void **)off_5F148;
      }
      if ( v4 != &off_5F148 )
      {
        if ( _bittest((const signed __int32 *)v4 + 75, 0x11u) && *((_BYTE *)v4 + 297) >= 4u )
        {
          sub_11008((__int64)v4[35], 0x5Eu, (__int64)&unk_4DD18);
          v4 = (void **)off_5F148;
        }
        if ( v4 != &off_5F148 )
        {
          if ( _bittest((const signed __int32 *)v4 + 75, 0x11u) && *((_BYTE *)v4 + 297) >= 4u )
          {
            sub_17984((__int64)v4[35], 0x5Fu, (__int64)&unk_4DD18, *a1);
            v4 = (void **)off_5F148;
          }
          if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x11u) && *((_BYTE *)v4 + 297) >= 4u )
            sub_11008((__int64)v4[35], 0x60u, (__int64)&unk_4DD18);
        }
      }
    }
    sub_3DE0C(a1[3]);
    goto LABEL_32;
  }
  v2 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return;
  if ( _bittest((const signed __int32 *)off_5F148 + 75, 0x11u) && *((_BYTE *)off_5F148 + 297) >= 4u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x5Cu, (__int64)&unk_4DD18);
LABEL_32:
    v2 = (void **)off_5F148;
  }
  if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 75, 0x11u) && *((_BYTE *)v2 + 297) >= 5u )
  {
    v3 = 97;
    goto LABEL_37;
  }
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000142F4) ----------------------------------------------------
__int64 __fastcall sub_142F4(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+88h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, a3, a2, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001434C) ----------------------------------------------------
__int64 sub_1434C(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, &unk_4DD08, 87i64, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000143A4) ----------------------------------------------------
__int64 sub_143A4(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, a3, a2, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000143EC) ----------------------------------------------------
__int64 sub_143EC(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+88h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, a3, a2, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014440) ----------------------------------------------------
__int64 sub_14440()
{
  int v0; // eax
  unsigned int v1; // ebx
  _QWORD *v2; // rcx
  unsigned __int16 v3; // dx

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xAu, (__int64)&unk_4DD08);
  memset(&Resource, 0, 0x80ui64);
  v0 = sub_26ADC(&Resource);
  if ( v0 < 0 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0xBu, (__int64)&unk_4DD08, v0);
LABEL_10:
    v1 = 2;
LABEL_37:
    sub_350EC();
    sub_42424();
    goto LABEL_38;
  }
  byte_62188 = 1;
  KeEnterCriticalRegion();
  sub_26C84(&Resource);
  if ( (unsigned int)sub_28F10() )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      sub_11008(*((_QWORD *)off_5F148 + 35), 0xCu, (__int64)&unk_4DD08);
    goto LABEL_10;
  }
  v1 = sub_34FE8();
  if ( v1 )
  {
    v2 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 1) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
      goto LABEL_37;
    v3 = 13;
    goto LABEL_36;
  }
  v1 = sub_42254();
  if ( v1 )
  {
    v2 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 1) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
      goto LABEL_37;
    v3 = 14;
    goto LABEL_36;
  }
  v1 = sub_16DA0((PVOID **)&qword_62190);
  if ( v1 )
  {
    v2 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 1) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
      goto LABEL_37;
    v3 = 15;
    goto LABEL_36;
  }
  v1 = sub_19DB0((PVOID *)&qword_62198);
  if ( v1 )
  {
    v2 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 1) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
      goto LABEL_37;
    v3 = 16;
LABEL_36:
    sub_11008(v2[35], v3, (__int64)&unk_4DD08);
    goto LABEL_37;
  }
LABEL_38:
  sub_26E34(&Resource);
  KeLeaveCriticalRegion();
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x11u, (__int64)&unk_4DD08, v1);
  return v1;
}
// 5F148: using guessed type void *off_5F148;
// 62188: using guessed type char byte_62188;
// 62190: using guessed type __int64 qword_62190;
// 62198: using guessed type __int64 qword_62198;

//----- (00000000000146C4) ----------------------------------------------------
__int64 sub_146C4()
{
  unsigned int v0; // ebx
  unsigned int v1; // edi
  unsigned int v2; // edi

  v0 = 0;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x12u, (__int64)&unk_4DD08);
  if ( byte_62188 )
    KeEnterCriticalRegion();
  sub_26C84(&Resource);
  v1 = sub_1A2F8((PVOID *)&qword_62198);
  if ( v1 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x13u, (__int64)&unk_4DD08);
    v0 = v1;
  }
  v2 = sub_16F38((PVOID **)&qword_62190);
  if ( v2 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x14u, (__int64)&unk_4DD08);
    v0 = v2;
  }
  sub_29034();
  sub_350EC();
  sub_42424();
  if ( byte_62188 )
  {
    sub_26E34(&Resource);
    KeLeaveCriticalRegion();
    sub_26BB0(&Resource);
    byte_62188 = 0;
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x15u, (__int64)&unk_4DD08, v0);
  return v0;
}
// 5F148: using guessed type void *off_5F148;
// 62188: using guessed type char byte_62188;
// 62190: using guessed type __int64 qword_62190;
// 62198: using guessed type __int64 qword_62198;

//----- (000000000001486C) ----------------------------------------------------
__int64 sub_1486C()
{
  unsigned int v0; // ebx
  int v1; // eax
  _QWORD *v2; // rcx
  unsigned __int16 v3; // dx
  int v4; // eax
  void **v5; // rcx
  int v7; // [rsp+30h] [rbp+8h] BYREF
  const char *v8; // [rsp+38h] [rbp+10h] BYREF

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x16u, (__int64)&unk_4DD08);
  v0 = sub_2DCFC(0i64, 0x2016001u, &v8, &v7);
  if ( v0 )
    goto LABEL_28;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x17u, (__int64)&unk_4DD08);
  v1 = sub_15250(0i64);
  if ( v1 )
  {
    v2 = off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      v3 = 24;
LABEL_20:
      sub_1102C(v2[35], v3, (__int64)&unk_4DD08, v1);
      goto LABEL_22;
    }
  }
  else
  {
    v1 = sub_14A2C(v8, v7, 1);
    if ( v1 )
    {
      v2 = off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        v3 = 25;
        goto LABEL_20;
      }
    }
    else
    {
      sub_14DA8();
    }
  }
LABEL_22:
  v4 = sub_2DFD4((__int64)v8);
  v0 = v4;
  if ( !v4 )
  {
LABEL_28:
    v5 = (void **)off_5F148;
    goto LABEL_29;
  }
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x1Au, (__int64)&unk_4DD08, v4);
    v5 = (void **)off_5F148;
  }
  v0 = 0;
LABEL_29:
  if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 300) & 2) != 0 && *((_BYTE *)v5 + 297) >= 5u )
    sub_1102C((__int64)v5[35], 0x1Bu, (__int64)&unk_4DD08, v0);
  return v0;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000014A2C) ----------------------------------------------------
__int64 __fastcall sub_14A2C(const char *a1, int a2, char a3)
{
  int v3; // ebx
  int v6; // eax
  unsigned int v7; // edi
  int v8; // eax
  int v9; // esi
  void **v10; // rcx
  _QWORD *v11; // rcx
  unsigned __int16 v12; // dx
  __int64 v14; // [rsp+30h] [rbp-58h] BYREF
  int v15; // [rsp+38h] [rbp-50h] BYREF
  __int64 Dst[4]; // [rsp+40h] [rbp-48h] BYREF
  char v17; // [rsp+A8h] [rbp+20h] BYREF

  v3 = 0;
  v14 = 0i64;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_17814(*((_QWORD *)off_5F148 + 35), 0x1Cu, (__int64)&unk_4DD08, a1, a2);
  v6 = sub_3CE18((PVOID *)&v14, a1);
  v7 = v6;
  if ( !v6 )
  {
    KeEnterCriticalRegion();
    sub_26C84(&Resource);
    v8 = sub_1E228(qword_62198);
    v9 = v8;
    if ( v8 )
    {
      v7 = v8;
      v10 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 2) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
      {
LABEL_20:
        if ( v9 )
          goto LABEL_23;
        goto LABEL_21;
      }
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x1Du, (__int64)&unk_4DD08, v8);
    }
    else
    {
      v17 = 0;
      memset(Dst, 0, sizeof(Dst));
      Dst[1] = v14;
      if ( a3 )
      {
        v15 = 0;
      }
      else
      {
        v15 = 1;
        Dst[2] = qword_62190;
        Dst[3] = qword_62198;
      }
      v7 = sub_420EC(*(_QWORD *)qword_62190, sub_166F8, (__int64)&v15, &v17);
      if ( a3 && v17 )
        v7 = 6;
      if ( v7 )
      {
LABEL_21:
        v9 = sub_1E350(qword_62198);
        if ( !v9 )
        {
LABEL_27:
          sub_3C894((PVOID *)&v14);
          goto LABEL_32;
        }
        v10 = (void **)off_5F148;
LABEL_23:
        v7 = v9;
        if ( v10 != &off_5F148 && (*((_BYTE *)v10 + 300) & 2) != 0 && *((_BYTE *)v10 + 297) >= 2u )
          sub_1102C((__int64)v10[35], 0x1Eu, (__int64)&unk_4DD08, v9);
        goto LABEL_27;
      }
      memset(Dst, 0, sizeof(Dst));
      Dst[2] = qword_62190;
      v15 = 2;
      Dst[3] = qword_62198;
      Dst[1] = v14;
      v7 = sub_420EC(v14, sub_166F8, (__int64)&v15, 0i64);
    }
    v10 = (void **)off_5F148;
    goto LABEL_20;
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x1Fu, (__int64)&unk_4DD08, v6);
LABEL_32:
  if ( v7 )
  {
    if ( (unsigned int)sub_171A0((PVOID *)qword_62190) )
    {
      v11 = off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        v12 = 32;
LABEL_43:
        sub_11008(v11[35], v12, (__int64)&unk_4DD08);
        goto LABEL_44;
      }
    }
    else if ( (unsigned int)sub_1A6D8(qword_62198) )
    {
      v11 = off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        v12 = 33;
        goto LABEL_43;
      }
    }
  }
LABEL_44:
  if ( qword_62190 && *(_QWORD *)qword_62190 )
    v3 = sub_433EC(*(_QWORD *)(*(_QWORD *)qword_62190 + 16i64));
  dword_5F4A0 = v3;
  sub_26E34(&Resource);
  KeLeaveCriticalRegion();
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x22u, (__int64)&unk_4DD08, v7);
  return v7;
}
// 5F148: using guessed type void *off_5F148;
// 5F4A0: using guessed type int dword_5F4A0;
// 62190: using guessed type __int64 qword_62190;
// 62198: using guessed type __int64 qword_62198;

//----- (0000000000014DA8) ----------------------------------------------------
void sub_14DA8()
{
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0xDu)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x23u, (__int64)&unk_4DD08);
  }
  KeEnterCriticalRegion();
  sub_26D5C(&Resource);
  sub_13678((__int64 *)qword_62190);
  sub_13A5C(qword_62198);
  sub_26E34(&Resource);
  KeLeaveCriticalRegion();
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0xDu)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x24u, (__int64)&unk_4DD08);
  }
}
// 5F148: using guessed type void *off_5F148;
// 62190: using guessed type __int64 qword_62190;
// 62198: using guessed type __int64 qword_62198;

//----- (0000000000014E80) ----------------------------------------------------
__int64 __fastcall sub_14E80(__int64 a1, PVOID *a2, unsigned int *a3)
{
  void **v6; // rbx
  unsigned int v7; // ebx
  _QWORD *v8; // rcx
  unsigned __int16 v9; // dx
  PVOID *v10; // rcx
  void **v11; // rcx
  int v13; // [rsp+30h] [rbp-58h] BYREF
  __int64 Dst[4]; // [rsp+38h] [rbp-50h] BYREF
  __int64 v15; // [rsp+90h] [rbp+8h] BYREF

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_143EC(*((_QWORD *)off_5F148 + 35), 0x25u, (__int64)&unk_4DD08, a1, a2, a3);
    v6 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 300) & 2) != 0 && *((_BYTE *)v6 + 297) >= 4u )
      sub_11008((__int64)v6[35], 0x26u, (__int64)&unk_4DD08);
    KeEnterCriticalRegion();
    sub_26D5C(&Resource);
    v7 = sub_173BC((__int64 *)qword_62190, a2, a3);
    if ( v7 )
    {
      v8 = off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 2) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
        goto LABEL_20;
      v9 = 39;
    }
    else
    {
      v8 = off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 2) == 0 || *((_BYTE *)off_5F148 + 297) < 5u )
        goto LABEL_20;
      v9 = 40;
    }
    sub_11008(v8[35], v9, (__int64)&unk_4DD08);
LABEL_20:
    sub_26E34(&Resource);
    KeLeaveCriticalRegion();
LABEL_51:
    v11 = (void **)off_5F148;
    goto LABEL_52;
  }
  v15 = 0i64;
  memset(Dst, 0, sizeof(Dst));
  v10 = (PVOID *)&v15;
  v13 = 2;
  Dst[2] = (__int64)&v15;
  Dst[0] = a1;
  if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 300) & 2) != 0 && *((_BYTE *)v6 + 297) >= 4u )
  {
    sub_11008((__int64)v6[35], 0x29u, (__int64)&unk_4DD08);
    v10 = (PVOID *)Dst[2];
  }
  v7 = sub_3C5C4(v10, "1.0.0.5", 8u);
  if ( !v7 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x2Bu, (__int64)&unk_4DD08);
    KeEnterCriticalRegion();
    sub_26D5C(&Resource);
    v7 = sub_420EC(*(_QWORD *)qword_62190, sub_166F8, (__int64)&v13, 0i64);
    sub_26E34(&Resource);
    KeLeaveCriticalRegion();
    if ( v7 )
    {
      v11 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_1102C(*((_QWORD *)off_5F148 + 35), 0x2Eu, (__int64)&unk_4DD08, v7);
        goto LABEL_48;
      }
    }
    else
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x2Cu, (__int64)&unk_4DD08);
      v7 = sub_173BC((__int64 *)Dst[2], a2, a3);
      if ( !v7 )
        goto LABEL_48;
      v11 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x2Du, (__int64)&unk_4DD08);
LABEL_48:
        v11 = (void **)off_5F148;
        goto LABEL_49;
      }
    }
LABEL_49:
    if ( *(_QWORD *)Dst[2] )
    {
      sub_3C894((PVOID *)Dst[2]);
      goto LABEL_51;
    }
    goto LABEL_52;
  }
  v11 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return v7;
  if ( (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x2Au, (__int64)&unk_4DD08);
    goto LABEL_51;
  }
LABEL_52:
  if ( v11 != &off_5F148 && (*((_BYTE *)v11 + 300) & 2) != 0 && *((_BYTE *)v11 + 297) >= 5u )
    sub_142F4((__int64)v11[35], 0x2Fu, (__int64)&unk_4DD08, v7);
  return v7;
}
// 5F148: using guessed type void *off_5F148;
// 62190: using guessed type __int64 qword_62190;

//----- (0000000000015250) ----------------------------------------------------
__int64 __fastcall sub_15250(__int64 a1)
{
  int v2; // eax
  _QWORD *v3; // rcx
  unsigned __int16 v4; // dx
  int v5; // eax
  unsigned int v6; // ebx
  int v7; // eax
  int v9; // [rsp+30h] [rbp-38h] BYREF
  __int64 Dst[4]; // [rsp+38h] [rbp-30h] BYREF

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x30u, (__int64)&unk_4DD08);
  KeEnterCriticalRegion();
  sub_26C84(&Resource);
  v2 = sub_1E228(qword_62198);
  if ( v2 && off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x31u, (__int64)&unk_4DD08, v2);
  if ( a1 )
  {
    memset(Dst, 0, sizeof(Dst));
    Dst[2] = qword_62190;
    Dst[3] = qword_62198;
    v9 = 1;
    Dst[0] = a1;
    if ( (unsigned int)sub_420EC(*(_QWORD *)qword_62190, sub_166F8, (__int64)&v9, 0i64) )
    {
      v3 = off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        v4 = 52;
        goto LABEL_26;
      }
    }
  }
  else if ( (unsigned int)sub_1A6D8(qword_62198) )
  {
    v3 = off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      v4 = 50;
LABEL_26:
      sub_11008(v3[35], v4, (__int64)&unk_4DD08);
      goto LABEL_27;
    }
  }
  else if ( (unsigned int)sub_171A0((PVOID *)qword_62190) )
  {
    v3 = off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      v4 = 51;
      goto LABEL_26;
    }
  }
LABEL_27:
  v5 = sub_1E350(qword_62198);
  v6 = v5;
  if ( v5 && off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x35u, (__int64)&unk_4DD08, v5);
  if ( qword_62190 && *(_QWORD *)qword_62190 )
    v7 = sub_433EC(*(_QWORD *)(*(_QWORD *)qword_62190 + 16i64));
  else
    v7 = 0;
  dword_5F4A0 = v7;
  sub_26E34(&Resource);
  KeLeaveCriticalRegion();
  if ( v6 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 4u )
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x36u, (__int64)&unk_4DD08);
    sub_146C4();
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x37u, (__int64)&unk_4DD08, v6);
  return v6;
}
// 5F148: using guessed type void *off_5F148;
// 5F4A0: using guessed type int dword_5F4A0;
// 62190: using guessed type __int64 qword_62190;
// 62198: using guessed type __int64 qword_62198;

//----- (0000000000015538) ----------------------------------------------------
__int64 __fastcall sub_15538(__int64 a1, __int64 a2, int *a3, __int64 a4)
{
  wchar_t *v4; // rsi
  int v7; // eax
  unsigned int v8; // ebx
  const wchar_t *v9; // rdi
  void **v10; // rcx
  __int64 v12; // [rsp+40h] [rbp-38h] BYREF
  __int64 v13[6]; // [rsp+48h] [rbp-30h] BYREF
  int v14; // [rsp+80h] [rbp+8h] BYREF
  __int64 v15; // [rsp+90h] [rbp+18h] BYREF
  __int64 v16; // [rsp+98h] [rbp+20h]

  v16 = a4;
  v15 = 0i64;
  v12 = 0i64;
  v14 = 0;
  v4 = 0i64;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x38u, (__int64)&unk_4DD08);
  *a3 = 1;
  KeEnterCriticalRegion();
  sub_26D5C(&Resource);
  if ( !(unsigned int)sub_433EC(*(_QWORD *)(qword_62198 + 32))
    && off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x15u)
    && *((_BYTE *)off_5F148 + 297) >= 4u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x39u, (__int64)&unk_4DD08);
  }
  v7 = sub_17CB8(&v15, a1);
  v8 = v7;
  if ( v7 )
  {
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x15u)
      && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x3Au, (__int64)&unk_4DD08, v7);
    }
    _InterlockedAdd64(&qword_5F4B0, 1ui64);
  }
  else
  {
    if ( (*(_BYTE *)(a1 + 120) & 4) != 0 )
    {
      v4 = (wchar_t *)sub_26404(2, 0x4Cu, 0x47504E4Eu);
      *(_QWORD *)v4 = 0i64;
    }
    v8 = sub_1BEB4(qword_62198, v15, &v12, a3, &v14);
    if ( v8 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x3Bu, (__int64)&unk_4DD08);
      _InterlockedAdd64(&qword_5F4B8, 1ui64);
    }
    else if ( v12 )
    {
      if ( v4 )
      {
        v13[0] = 0i64;
        sub_3ED70(v12, 1066, v13);
        v9 = *(const wchar_t **)(v13[0] + 4);
        if ( v9 )
        {
          if ( (int)unknown_libname_2(v4, 37i64, 0x7FFFFFFFi64) >= 0 )
            RtlStringCopyWorkerW(v4, 0x25ui64, 0i64, v9, 0x7FFFFFFEui64);
        }
      }
    }
  }
  sub_26E34(&Resource);
  KeLeaveCriticalRegion();
  if ( v8 || (*(_BYTE *)(a1 + 120) & 4) == 0 )
    goto LABEL_35;
  sub_12B2C(a1, (__int64)v4, a3, v14, (v15 + 114) & -(__int64)(v15 != 0), v16, 0);
  v10 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x15u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x3Cu, (__int64)&unk_4DD08);
LABEL_35:
    v10 = (void **)off_5F148;
  }
  if ( v4 )
  {
    sub_26488(v4, 0x47504E4Eu);
    v10 = (void **)off_5F148;
  }
  if ( v15 )
  {
    sub_19244(&v15);
    v10 = (void **)off_5F148;
  }
  if ( v10 != &off_5F148 && (*((_BYTE *)v10 + 300) & 8) != 0 && *((_BYTE *)v10 + 297) >= 5u )
    sub_1102C((__int64)v10[35], 0x3Du, (__int64)&unk_4DD08, v8);
  return v8;
}
// 4C114: using guessed type __int64 __fastcall unknown_libname_2(_QWORD, _QWORD, _QWORD);
// 5F148: using guessed type void *off_5F148;
// 5F4B0: using guessed type __int64 qword_5F4B0;
// 5F4B8: using guessed type __int64 qword_5F4B8;
// 62198: using guessed type __int64 qword_62198;

//----- (000000000001589C) ----------------------------------------------------
__int64 __fastcall sub_1589C(__int64 a1)
{
  unsigned int v2; // ebx
  void **v3; // rcx
  __int64 v4; // rdi
  unsigned __int16 v5; // dx
  __int64 v6; // rcx
  int *v7; // rdi
  int v8; // eax
  __int64 v9; // rbp
  int v10; // edx
  int v11; // er12
  _DWORD *v12; // rbp
  void *v13; // rcx
  _DWORD *v14; // rax
  _DWORD *v15; // r12
  _QWORD *v16; // rcx
  unsigned __int16 v17; // dx
  char v18; // bl
  size_t MaxCount; // [rsp+70h] [rbp+8h] BYREF
  PVOID P; // [rsp+78h] [rbp+10h] BYREF
  void *Src; // [rsp+80h] [rbp+18h] BYREF

  v2 = 6;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x3Eu, (__int64)&unk_4DD08);
    v3 = (void **)off_5F148;
  }
  v4 = *(_QWORD *)(a1 + 56);
  if ( !v4 )
  {
    if ( v3 != &off_5F148 )
    {
      if ( _bittest((const signed __int32 *)v3 + 43, 8u) && *((_BYTE *)v3 + 169) >= 2u )
      {
        v5 = 63;
LABEL_10:
        v6 = (__int64)v3[19];
LABEL_25:
        sub_11008(v6, v5, (__int64)&unk_4DD08);
        v3 = (void **)off_5F148;
        goto LABEL_26;
      }
      goto LABEL_26;
    }
    goto LABEL_30;
  }
  v7 = (int *)(v4 + 4);
  if ( !v7 )
  {
    if ( v3 != &off_5F148 )
    {
      if ( _bittest((const signed __int32 *)v3 + 43, 8u) && *((_BYTE *)v3 + 169) >= 2u )
      {
        v5 = 64;
        goto LABEL_10;
      }
LABEL_26:
      if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 300) & 2) != 0 && *((_BYTE *)v3 + 297) >= 2u )
        sub_11008((__int64)v3[35], 0x4Eu, (__int64)&unk_4DD08);
    }
LABEL_30:
    v10 = 17;
LABEL_94:
    sub_329E8(a1, v10, 0, 0i64);
    goto LABEL_109;
  }
  v8 = v7[4];
  v9 = (unsigned int)v7[9];
  switch ( v8 )
  {
    case -1:
      v14 = sub_26404(1, 8u, 0x7552504Eu);
      v15 = v14;
      if ( !v14 )
      {
        v16 = off_5F148;
        if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 2) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
          goto LABEL_106;
        v17 = 76;
        goto LABEL_105;
      }
      goto LABEL_107;
    case 0:
      if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 300) & 2) != 0 && *((_BYTE *)v3 + 297) >= 4u )
        sub_11008((__int64)v3[35], 0x41u, (__int64)&unk_4DD08);
      v18 = 1;
      goto LABEL_88;
    case 4:
      MaxCount = 0i64;
      if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 300) & 2) != 0 && *((_BYTE *)v3 + 297) >= 4u )
        sub_11008((__int64)v3[35], 0x45u, (__int64)&unk_4DD08);
      sub_29320((int *)((char *)v7 + v9 + 44), *(int *)((char *)v7 + v9 + 40), (__int64 *)&MaxCount);
      sub_14DA8();
      v2 = sub_15250(MaxCount);
      if ( v2 && off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
        sub_1102C(*((_QWORD *)off_5F148 + 35), 0x46u, (__int64)&unk_4DD08, v2);
      sub_14DA8();
      if ( MaxCount )
      {
        sub_29264((PVOID)MaxCount);
        MaxCount = 0i64;
      }
      if ( !v2 )
        v2 = sub_16A88(*v7);
      v14 = sub_26404(1, 8u, 0x7552504Eu);
      v15 = v14;
      if ( !v14 )
      {
        v16 = off_5F148;
        if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 2) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
          goto LABEL_106;
        v17 = 71;
        goto LABEL_105;
      }
LABEL_107:
      *v14 = 4;
      v14[1] = v2;
      sub_329E8(a1, 0, 8u, v14);
      v13 = v15;
      goto LABEL_108;
  }
  if ( v8 != 5 )
  {
    if ( v8 != 6 )
    {
      if ( v3 != &off_5F148 )
      {
        if ( (*((_BYTE *)v3 + 300) & 2) != 0 && *((_BYTE *)v3 + 297) >= 4u )
        {
          v6 = (__int64)v3[35];
          v5 = 77;
          goto LABEL_25;
        }
        goto LABEL_26;
      }
      goto LABEL_30;
    }
    if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 300) & 2) != 0 && *((_BYTE *)v3 + 297) >= 4u )
      sub_11008((__int64)v3[35], 0x42u, (__int64)&unk_4DD08);
    v18 = 0;
LABEL_88:
    sub_14DA8();
    v2 = sub_14A2C((const char *)v7 + v9 + 44, *(int *)((char *)v7 + v9 + 40), v18);
    if ( v2 )
    {
      sub_1486C();
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
        sub_1102C(*((_QWORD *)off_5F148 + 35), 0x43u, (__int64)&unk_4DD08, v2);
      v10 = 0x80000000;
      goto LABEL_94;
    }
    sub_14DA8();
    v2 = sub_16A88(*v7);
    sub_14DA8();
    v14 = sub_26404(1, 8u, 0x7552504Eu);
    v15 = v14;
    if ( !v14 )
    {
      v16 = off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 2) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
        goto LABEL_106;
      v17 = 68;
LABEL_105:
      sub_1102C(v16[35], v17, (__int64)&unk_4DD08, v2);
LABEL_106:
      sub_329E8(a1, 0x80000000, 0, 0i64);
      v2 = 3;
      goto LABEL_109;
    }
    goto LABEL_107;
  }
  Src = 0i64;
  LODWORD(MaxCount) = 0;
  P = 0i64;
  if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 300) & 2) != 0 && *((_BYTE *)v3 + 297) >= 4u )
    sub_11008((__int64)v3[35], 0x48u, (__int64)&unk_4DD08);
  sub_29320((int *)((char *)v7 + v9 + 44), *(int *)((char *)v7 + v9 + 40), (__int64 *)&P);
  v2 = sub_14E80((__int64)P, &Src, (unsigned int *)&MaxCount);
  if ( v2 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x49u, (__int64)&unk_4DD08, v2);
    sub_329E8(a1, 0x80000000, 0, 0i64);
    v2 = 12;
    if ( P )
      sub_29264(P);
  }
  else
  {
    if ( P )
    {
      sub_29264(P);
      P = 0i64;
    }
    v11 = MaxCount;
    v12 = sub_26404(1, (int)MaxCount + 4, 0x7552504Eu);
    if ( v12 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 4u )
        sub_1102C(*((_QWORD *)off_5F148 + 35), 0x4Bu, (__int64)&unk_4DD08, MaxCount);
      *v12 = MaxCount;
      memmove(v12 + 1, Src, (unsigned int)MaxCount);
      sub_329E8(a1, 0, v11 + 4, v12);
    }
    else
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
        sub_1102C(*((_QWORD *)off_5F148 + 35), 0x4Au, (__int64)&unk_4DD08, 0);
      sub_329E8(a1, 0x80000000, 0, 0i64);
      v2 = 3;
    }
    if ( Src )
      sub_26488(Src, 0x7552504Eu);
    if ( v12 )
    {
      v13 = v12;
LABEL_108:
      sub_26488(v13, 0x7552504Eu);
      goto LABEL_109;
    }
  }
LABEL_109:
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x4Fu, (__int64)&unk_4DD08, v2);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000015FB8) ----------------------------------------------------
__int64 __fastcall sub_15FB8(__int64 a1, __int64 a2, unsigned __int8 *a3)
{
  unsigned int v6; // ebx

  v6 = 0;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 35), 0x50u, (__int64)&unk_4DD08, a1, a2);
  if ( (unsigned int)sub_29498(a1, (__int64)sub_1609C, a2, a3) )
    v6 = 6;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x51u, (__int64)&unk_4DD08, v6);
  return v6;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001609C) ----------------------------------------------------
unsigned __int8 __fastcall sub_1609C(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int8 v6; // bl
  void **v7; // rcx
  __int64 v9; // [rsp+30h] [rbp-38h] BYREF
  __int64 v10; // [rsp+38h] [rbp-30h] BYREF
  __int64 v11; // [rsp+40h] [rbp-28h]
  unsigned __int8 v12; // [rsp+70h] [rbp+8h] BYREF
  int v13; // [rsp+88h] [rbp+20h] BYREF

  v6 = 0;
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_143EC(*((_QWORD *)off_5F148 + 35), 0x52u, (__int64)&unk_4DD08, a1, a2, a3);
    v7 = (void **)off_5F148;
  }
  if ( a1 )
  {
    if ( a3 )
    {
      if ( a2 )
      {
        v6 = 1;
        if ( *(_DWORD *)(a2 + 8) == 11 && *(_DWORD *)(a2 + 12) == 4 )
        {
          v9 = 0i64;
          if ( !(unsigned int)sub_29964(a1, &v9) )
          {
            v12 = 1;
            v10 = a3;
            v11 = 0i64;
            v11 = **(unsigned int **)(a2 + 16);
            if ( !(unsigned int)sub_2A67C(v9, (__int64)sub_16220, (__int64)&v10, &v12)
              && !(unsigned int)sub_29A80(a1, &v13) )
            {
              if ( v13 == 2 || v13 == 4 )
              {
                v6 = v12 == 0;
              }
              else if ( v13 == 3 || v13 == 5 )
              {
                v6 = v12;
              }
            }
          }
          v7 = (void **)off_5F148;
        }
      }
    }
  }
  if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 300) & 2) != 0 && *((_BYTE *)v7 + 297) >= 5u )
    sub_1102C((__int64)v7[35], 0x53u, (__int64)&unk_4DD08, v6);
  return v6;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000016220) ----------------------------------------------------
unsigned __int8 __fastcall sub_16220(__int64 a1, __int64 a2)
{
  unsigned __int8 v4; // bl
  void **v5; // rcx
  int v6; // edx
  int v7; // er9
  int v8; // edx
  int v10; // eax
  int v11; // edx
  __int64 v12; // rcx
  int v13; // eax
  _DWORD *v14; // [rsp+58h] [rbp+10h] BYREF
  __int64 v15; // [rsp+60h] [rbp+18h] BYREF

  v4 = 1;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_143A4(*((_QWORD *)off_5F148 + 35), 0x54u, (__int64)&unk_4DD08, a1, a2);
    v5 = (void **)off_5F148;
  }
  if ( a2 )
  {
    v6 = *(_DWORD *)(a2 + 8);
    v14 = 0i64;
    v7 = 6;
    v8 = v6 - 1066;
    if ( v8 )
    {
      if ( v8 != 18 )
      {
        v7 = 18;
        goto LABEL_9;
      }
      if ( *(_DWORD *)(a1 + 8) != 265 || *(_DWORD *)(a1 + 12) != 4 )
        goto LABEL_9;
      v10 = sub_398F8((__int64 *)&v14, **(_DWORD **)(a1 + 16));
    }
    else
    {
      if ( *(_DWORD *)(a1 + 8) != 260 )
        goto LABEL_9;
      v10 = sub_395A8((__int64 *)&v14, *(const wchar_t **)(a1 + 16));
    }
    v7 = v10;
    if ( !v10 )
    {
      if ( !*v14
        || (v11 = *(_DWORD *)(a2 + 8), v12 = *(_QWORD *)a2, v15 = 0i64, (unsigned int)sub_3ED70(v12, v11, &v15))
        || (v13 = sub_3C074(v14, v15), v13 != 7) && v13 != 3 )
      {
        v5 = (void **)off_5F148;
LABEL_15:
        if ( v14 )
        {
          sub_3B0E0((__int64 *)&v14);
          v5 = (void **)off_5F148;
        }
        goto LABEL_17;
      }
      goto LABEL_13;
    }
    v5 = (void **)off_5F148;
LABEL_9:
    if ( v5 == &off_5F148 || (*((_BYTE *)v5 + 300) & 2) == 0 || *((_BYTE *)v5 + 297) < 2u )
      goto LABEL_14;
    sub_1102C((__int64)v5[35], 0x55u, (__int64)&unk_4DD08, v7);
LABEL_13:
    v5 = (void **)off_5F148;
LABEL_14:
    v4 = 0;
    goto LABEL_15;
  }
LABEL_17:
  if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 300) & 2) != 0 && *((_BYTE *)v5 + 297) >= 5u )
    sub_1102C((__int64)v5[35], 0x56u, (__int64)&unk_4DD08, v4);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000163F4) ----------------------------------------------------
__int64 __fastcall sub_163F4(unsigned __int64 a1)
{
  __int64 v1; // r8
  unsigned int v2; // ebx
  ULONG_PTR *v3; // rdi
  void **v4; // rcx
  unsigned int v5; // eax
  __int64 v7; // [rsp+20h] [rbp-28h]
  int v9; // [rsp+58h] [rbp+10h] BYREF

  KeEnterCriticalRegion();
  sub_26C84(&Resource);
  v2 = 0;
  v3 = *(ULONG_PTR **)(qword_62198 + 16);
  v9 = 0;
  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x10u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x2Au, (__int64)&unk_4DCC8);
    v4 = (void **)off_5F148;
  }
  if ( !v3 )
  {
    if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x10u) && *((_BYTE *)v4 + 297) >= 2u )
    {
      sub_17984((__int64)v4[35], 0x2Bu, (__int64)&unk_4DCC8, 0i64, 0);
      v4 = (void **)off_5F148;
    }
    v2 = 4;
    goto LABEL_21;
  }
  LOBYTE(v1) = 1;
  sub_45E1C(*v3, a1, v1, &v9);
  if ( !v9 )
  {
    v4 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148 )
      goto LABEL_30;
    if ( !_bittest((const signed __int32 *)off_5F148 + 75, 0x10u) || *((_BYTE *)off_5F148 + 297) < 5u )
      goto LABEL_21;
    sub_17984(*((_QWORD *)off_5F148 + 35), 0x2Du, (__int64)&unk_4DCC8, a1, 0);
    goto LABEL_20;
  }
  v5 = sub_473B0(v9);
  v2 = v5;
  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( !_bittest((const signed __int32 *)off_5F148 + 75, 0x10u) || *((_BYTE *)off_5F148 + 297) < 2u )
    {
LABEL_21:
      if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x10u) && *((_BYTE *)v4 + 297) >= 5u )
      {
        sub_1102C((__int64)v4[35], 0x2Eu, (__int64)&unk_4DCC8, v2);
        v4 = (void **)off_5F148;
      }
      goto LABEL_25;
    }
    sub_17814(*((_QWORD *)off_5F148 + 35), 0x2Cu, (__int64)&unk_4DCC8, a1, v5);
LABEL_20:
    v4 = (void **)off_5F148;
    goto LABEL_21;
  }
LABEL_25:
  if ( v2 && v4 != &off_5F148 && (*((_BYTE *)v4 + 300) & 2) != 0 && *((_BYTE *)v4 + 297) >= 2u )
  {
    LODWORD(v7) = v2;
    sub_1434C((__int64)v4[35], 87i64, (__int64)&unk_4DD08, a1, v7);
  }
LABEL_30:
  sub_26E34(&Resource);
  KeLeaveCriticalRegion();
  return v2;
}
// 164CF: variable 'v1' is possibly undefined
// 165D5: variable 'v7' is possibly undefined
// 5F148: using guessed type void *off_5F148;
// 62198: using guessed type __int64 qword_62198;

//----- (000000000001660C) ----------------------------------------------------
bool __fastcall sub_1660C(wchar_t *Str1, __int64 a2, const wchar_t *a3)
{
  bool v4; // di
  void **v6; // rcx
  int v7; // eax

  v4 = 0;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_143EC(*((_QWORD *)off_5F148 + 35), 0x58u, (__int64)&unk_4DD08, Str1, a2, a3);
    v6 = (void **)off_5F148;
  }
  if ( a3 )
  {
    v7 = _wcsicmp(Str1, a3);
    v6 = (void **)off_5F148;
    v4 = v7 == 0;
  }
  if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 300) & 2) != 0 && *((_BYTE *)v6 + 297) >= 5u )
    sub_1102C((__int64)v6[35], 0x59u, (__int64)&unk_4DD08, v4);
  return !v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000166F8) ----------------------------------------------------
unsigned __int8 __fastcall sub_166F8(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int8 v6; // bl
  void **v7; // rcx
  unsigned __int16 v8; // dx
  unsigned __int8 v9; // al
  int v10; // eax
  __int64 v11; // r10
  int v12; // eax
  __int64 v13; // rcx
  unsigned __int8 v15; // [rsp+70h] [rbp+18h] BYREF
  __int64 v16; // [rsp+78h] [rbp+20h] BYREF

  v6 = 1;
  v15 = 0;
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_143EC(*((_QWORD *)off_5F148 + 35), 0x5Au, (__int64)&unk_4DD08, a1, a2, a3);
    v7 = (void **)off_5F148;
  }
  if ( !a3 )
    goto LABEL_57;
  if ( *(_QWORD *)(a3 + 8) )
  {
    if ( (unsigned int)sub_15FB8(*(_QWORD *)(a3 + 8), a2, &v15) )
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 2) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
        goto LABEL_57;
      v8 = 91;
      goto LABEL_56;
    }
LABEL_18:
    v9 = v15;
    v7 = (void **)off_5F148;
    goto LABEL_20;
  }
  if ( *(_QWORD *)(a3 + 16) )
  {
    if ( (unsigned int)sub_420EC(
                         *(_QWORD *)(a3 + 16),
                         (unsigned __int8 (__fastcall *)(_QWORD, __int64, __int64))sub_1660C,
                         a1,
                         &v15) )
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 2) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
        goto LABEL_57;
      v8 = 92;
      goto LABEL_56;
    }
    goto LABEL_18;
  }
  v9 = 1;
  v15 = 1;
LABEL_20:
  if ( !v9 )
    goto LABEL_65;
  if ( *(_DWORD *)a3 != 1 )
  {
    if ( !*(_DWORD *)a3 )
    {
LABEL_57:
      v6 = 0;
      goto LABEL_65;
    }
    if ( *(_DWORD *)a3 != 2 )
      goto LABEL_65;
    v16 = 0i64;
    if ( (unsigned int)sub_3D4C4((PVOID *)&v16, a2) )
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 2) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
        goto LABEL_57;
      v8 = 95;
    }
    else if ( (unsigned int)sub_17050(*(_QWORD *)(a3 + 24), v16) )
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 2) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
        goto LABEL_57;
      v8 = 96;
    }
    else
    {
      v13 = *(_QWORD *)(a3 + 32);
      if ( !v13 || !(unsigned int)sub_1AFDC(v13, v16) )
      {
        v7 = (void **)off_5F148;
        goto LABEL_65;
      }
      v7 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 2) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
        goto LABEL_57;
      v8 = 97;
    }
LABEL_56:
    sub_11008((__int64)v7[35], v8, (__int64)&unk_4DD08);
    v7 = (void **)off_5F148;
    goto LABEL_57;
  }
  v10 = sub_1BC58(*(_QWORD *)(a3 + 32), a2);
  if ( !v10 || v10 == 5 )
  {
    v7 = (void **)off_5F148;
  }
  else
  {
    v7 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x5Du, (__int64)&unk_4DD08);
      v7 = (void **)off_5F148;
    }
    v6 = 0;
  }
  v11 = **(_QWORD **)(a3 + 24);
  if ( v11 && a2 )
  {
    v12 = sub_42F90(*(int **)(v11 + 16), a2, sub_3F594, (void (__fastcall *)(_QWORD *))sub_3DA00, 1);
    v7 = (void **)off_5F148;
  }
  else
  {
    if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 172) & 2) != 0 && *((_BYTE *)v7 + 169) >= 2u )
    {
      sub_11008((__int64)v7[19], 0x100u, (__int64)&unk_4DBD8);
      v7 = (void **)off_5F148;
    }
    v12 = 4;
  }
  if ( v12 && v12 != 5 )
  {
    if ( v7 == &off_5F148 || (*((_BYTE *)v7 + 300) & 2) == 0 || *((_BYTE *)v7 + 297) < 2u )
      goto LABEL_57;
    v8 = 94;
    goto LABEL_56;
  }
LABEL_65:
  if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 300) & 2) != 0 && *((_BYTE *)v7 + 297) >= 5u )
    sub_1102C((__int64)v7[35], 0x62u, (__int64)&unk_4DD08, v6);
  return v6;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000016A88) ----------------------------------------------------
__int64 __fastcall sub_16A88(int a1)
{
  int v2; // eax
  unsigned int v3; // ebx
  void **v4; // rcx
  int v5; // eax
  int v7; // [rsp+58h] [rbp+10h] BYREF
  PVOID P; // [rsp+60h] [rbp+18h] BYREF

  P = 0i64;
  v7 = 0;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x63u, (__int64)&unk_4DD08);
  v2 = sub_173BC((__int64 *)qword_62190, &P, (unsigned int *)&v7);
  v3 = v2;
  if ( !v2 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 4u )
      sub_127D0(*((_QWORD *)off_5F148 + 35), 0x65u, (__int64)&unk_4DD08, a1);
    v5 = sub_2E210(0i64, 0x2016001u, (__int64)P, v7);
    v3 = v5;
    if ( v5 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
        sub_127D0(*((_QWORD *)off_5F148 + 35), 0x66u, (__int64)&unk_4DD08, v5);
      v3 = 8;
    }
    sub_26488(P, 0x7552504Eu);
    goto LABEL_21;
  }
  v4 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return v3;
  if ( (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x64u, (__int64)&unk_4DD08, v2);
LABEL_21:
    v4 = (void **)off_5F148;
  }
  if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 300) & 2) != 0 && *((_BYTE *)v4 + 297) >= 5u )
    sub_1102C((__int64)v4[35], 0x67u, (__int64)&unk_4DD08, v3);
  return v3;
}
// 5F148: using guessed type void *off_5F148;
// 62190: using guessed type __int64 qword_62190;

//----- (0000000000016C40) ----------------------------------------------------
__int64 __fastcall sub_16C40(const signed __int32 *a1)
{
  unsigned int v2; // ebx
  int v3; // eax

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x68u, (__int64)&unk_4DD08);
  KeEnterCriticalRegion();
  sub_26C84(&Resource);
  if ( a1 )
  {
    v3 = sub_1E434(qword_62198, a1);
    v2 = v3;
    if ( v3 && off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x6Au, (__int64)&unk_4DD08, v3);
  }
  else
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x69u, (__int64)&unk_4DD08);
    v2 = 4;
  }
  sub_26E34(&Resource);
  KeLeaveCriticalRegion();
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 2) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x6Bu, (__int64)&unk_4DD08, v2);
  return v2;
}
// 5F148: using guessed type void *off_5F148;
// 62198: using guessed type __int64 qword_62198;

//----- (0000000000016DA0) ----------------------------------------------------
__int64 __fastcall sub_16DA0(PVOID **a1)
{
  void **v2; // rcx
  unsigned int v3; // ebx
  PVOID *v4; // rax
  int v5; // eax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xAu, (__int64)&unk_4DCF8);
    v2 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 300) & 1) != 0 && *((_BYTE *)v2 + 297) >= 2u )
      sub_11008((__int64)v2[35], 0xBu, (__int64)&unk_4DCF8);
    v3 = 4;
LABEL_22:
    sub_16F38(a1);
    goto LABEL_23;
  }
  v4 = (PVOID *)sub_26404(1, 8u, 0x7552504Eu);
  *a1 = v4;
  if ( !v4 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      sub_11008(*((_QWORD *)off_5F148 + 35), 0xCu, (__int64)&unk_4DCF8);
    v3 = 3;
    goto LABEL_22;
  }
  *v4 = 0i64;
  v5 = sub_171A0(*a1);
  v3 = v5;
  if ( v5 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0xDu, (__int64)&unk_4DCF8, v5);
    goto LABEL_22;
  }
LABEL_23:
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0xEu, (__int64)&unk_4DCF8, v3);
  return v3;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000016F38) ----------------------------------------------------
__int64 __fastcall sub_16F38(PVOID **a1)
{
  unsigned int v2; // ebx
  void **v3; // rcx

  v2 = 0;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xFu, (__int64)&unk_4DCF8);
    v3 = (void **)off_5F148;
  }
  if ( a1 && *a1 )
  {
    if ( **a1 )
      sub_3C894(*a1);
    sub_26488(*a1, 0x7552504Eu);
    *a1 = 0i64;
    v3 = (void **)off_5F148;
  }
  else
  {
    if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 300) & 1) != 0 && *((_BYTE *)v3 + 297) >= 3u )
    {
      sub_11008((__int64)v3[35], 0x10u, (__int64)&unk_4DCF8);
      v3 = (void **)off_5F148;
    }
    v2 = 4;
  }
  if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 300) & 1) != 0 && *((_BYTE *)v3 + 297) >= 5u )
    sub_1102C((__int64)v3[35], 0x11u, (__int64)&unk_4DCF8, v2);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000017050) ----------------------------------------------------
__int64 __fastcall sub_17050(__int64 a1, __int64 a2)
{
  void **v4; // rcx
  unsigned int v5; // eax
  unsigned int v6; // ebx
  __int64 result; // rax

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 4) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x12u, (__int64)&unk_4DCF8);
    v4 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    if ( *(_QWORD *)a1 )
    {
      v5 = sub_42D48(*(int **)(*(_QWORD *)a1 + 16i64), a2, 0i64);
      v4 = (void **)off_5F148;
      v6 = v5;
    }
    else
    {
      if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      {
        sub_11008((__int64)v4[19], 0xFFu, (__int64)&unk_4DBD8);
        v4 = (void **)off_5F148;
      }
      v6 = 4;
    }
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 300) & 4) != 0 && *((_BYTE *)v4 + 297) >= 5u )
      sub_1102C((__int64)v4[35], 0x14u, (__int64)&unk_4DCF8, v6);
    result = v6;
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 300) & 4) != 0 && *((_BYTE *)v4 + 297) >= 5u )
      sub_143A4((__int64)v4[35], 0x13u, (__int64)&unk_4DCF8, a1, a2);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000171A0) ----------------------------------------------------
__int64 __fastcall sub_171A0(PVOID *a1)
{
  void **v2; // rcx
  unsigned int v3; // ebx
  unsigned int *v4; // rax
  size_t v5; // rsi
  char *v6; // rax
  char *v7; // rdi
  _QWORD *v8; // rcx
  unsigned __int16 v9; // dx
  int v11; // eax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 4) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x15u, (__int64)&unk_4DCF8);
    v2 = (void **)off_5F148;
  }
  if ( a1 )
  {
    v4 = (unsigned int *)*a1;
    if ( *a1 )
    {
      v5 = v4[3];
      v6 = (char *)sub_26404(1, v4[3], 0x7552504Eu);
      v7 = v6;
      if ( !v6 )
      {
        v8 = off_5F148;
        if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 4) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
          return 3i64;
        v9 = 23;
LABEL_17:
        sub_11008(v8[35], v9, (__int64)&unk_4DCF8);
        return 3i64;
      }
      memmove(v6, *(const void **)((char *)*a1 + 4), v5);
    }
    else
    {
      LODWORD(v5) = 8;
      v7 = (char *)sub_26404(1, 8u, 0x7552504Eu);
      if ( !v7 )
      {
        v8 = off_5F148;
        if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 4) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
          return 3i64;
        v9 = 24;
        goto LABEL_17;
      }
      strcpy(v7, "1.0.0.5");
    }
    v11 = sub_3C5C4(a1, v7, v5);
    v3 = v11;
    if ( v11 && off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 4) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x19u, (__int64)&unk_4DCF8, v11);
    sub_26488(v7, 0x7552504Eu);
    v2 = (void **)off_5F148;
    goto LABEL_32;
  }
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 300) & 4) != 0 && *((_BYTE *)v2 + 297) >= 5u )
  {
    sub_11008((__int64)v2[35], 0x16u, (__int64)&unk_4DCF8);
    v2 = (void **)off_5F148;
  }
  v3 = 4;
LABEL_32:
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 300) & 4) != 0 && *((_BYTE *)v2 + 297) >= 5u )
    sub_1102C((__int64)v2[35], 0x1Au, (__int64)&unk_4DCF8, v3);
  return v3;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000173BC) ----------------------------------------------------
__int64 __fastcall sub_173BC(__int64 *a1, PVOID *a2, unsigned int *a3)
{
  void **v6; // rcx
  void **v7; // rcx
  unsigned int v8; // ebx
  _QWORD *v9; // rax
  int v10; // eax

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 4) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x1Bu, (__int64)&unk_4DCF8);
    v6 = (void **)off_5F148;
  }
  if ( a1 && a2 && a3 )
  {
    sub_3CC40(*a1, 0i64, a3);
    if ( *a3 )
    {
      v9 = sub_26404(1, *a3, 0x7552504Eu);
      *a2 = v9;
      if ( v9 )
      {
        v10 = sub_3CC40(*a1, v9, a3);
        v8 = v10;
        if ( !v10 )
          goto LABEL_27;
        v7 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 4) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
        {
          sub_1102C(*((_QWORD *)off_5F148 + 35), 0x1Fu, (__int64)&unk_4DCF8, v10);
          v7 = (void **)off_5F148;
        }
      }
      else
      {
        v7 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 4) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
        {
          sub_11008(*((_QWORD *)off_5F148 + 35), 0x1Eu, (__int64)&unk_4DCF8);
          v7 = (void **)off_5F148;
        }
        v8 = 3;
      }
    }
    else
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 4) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x1Du, (__int64)&unk_4DCF8);
        v7 = (void **)off_5F148;
      }
      v8 = 5;
    }
    if ( !*a2 )
      goto LABEL_28;
    sub_26488(*a2, 0x7552504Eu);
    *a2 = 0i64;
    *a3 = 0;
LABEL_27:
    v7 = (void **)off_5F148;
LABEL_28:
    if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 300) & 4) != 0 && *((_BYTE *)v7 + 297) >= 5u )
      sub_1102C((__int64)v7[35], 0x20u, (__int64)&unk_4DCF8, v8);
    return v8;
  }
  if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 300) & 4) != 0 && *((_BYTE *)v6 + 297) >= 2u )
    sub_143EC((__int64)v6[35], 0x1Cu, (__int64)&unk_4DCF8, a1, a2, a3);
  return 4i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000017608) ----------------------------------------------------
__int64 __fastcall sub_17608(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+118h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DCE8, 36i64, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000176E4) ----------------------------------------------------
__int64 __fastcall sub_176E4(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+158h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DCE8, 29i64, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000017814) ----------------------------------------------------
__int64 sub_17814(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, a3, a2, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000017860) ----------------------------------------------------
__int64 __fastcall sub_17860(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4)
{
  __int64 v5; // rcx
  const wchar_t *v6; // rdi
  bool v7; // zf

  if ( a4 && *a4 )
  {
    v5 = -1i64;
    v6 = a4;
    do
    {
      if ( !v5 )
        break;
      v7 = *v6++ == 0;
      --v5;
    }
    while ( !v7 );
  }
  if ( a4 )
  {
    if ( !*a4 )
      a4 = L"<NULL>";
  }
  else
  {
    a4 = L"NULL";
  }
  return qword_5F3B8(a1, 43i64, a3, a2, a4);
}
// 4C6E0: using guessed type wchar_t aNull_4[7];
// 4C6F0: using guessed type wchar_t aNull[5];
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000178E0) ----------------------------------------------------
__int64 __fastcall sub_178E0(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+D8h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DCE8, 24i64, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000017984) ----------------------------------------------------
__int64 sub_17984(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, a3, a2, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000179C0) ----------------------------------------------------
__int64 sub_179C0(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+98h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, &unk_4DCE8, 262i64, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000017A34) ----------------------------------------------------
__int64 sub_17A34(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+A8h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, &unk_4DCE8, 243i64, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000017AB4) ----------------------------------------------------
__int64 sub_17AB4(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+B8h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, &unk_4DCE8, 230i64, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000017B40) ----------------------------------------------------
__int64 __fastcall sub_17B40(__int64 a1, __int64 a2, __int64 a3, const char *a4, _WORD *a5)
{
  __int64 v6; // rcx
  _WORD *v7; // rdi
  bool v8; // zf
  const char *v9; // rax

  if ( a5 && *a5 )
  {
    v6 = -1i64;
    v7 = a5;
    do
    {
      if ( !v6 )
        break;
      v8 = *v7++ == 0;
      --v6;
    }
    while ( !v8 );
  }
  if ( a4 )
    strlen(a4);
  v9 = "NULL";
  if ( a4 )
    v9 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DCE8, 281i64, v9);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000017C08) ----------------------------------------------------
__int64 __fastcall sub_17C08(__int64 a1, unsigned __int16 a2, __int64 a3, const char *a4, const char *a5)
{
  const char *v7; // rcx

  if ( a5 )
    strlen(a5);
  if ( a4 )
    strlen(a4);
  v7 = "NULL";
  if ( a4 )
    v7 = a4;
  return qword_5F3B8(a1, 43i64, a3, a2, v7);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000017CB8) ----------------------------------------------------
__int64 __fastcall sub_17CB8(__int64 *a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 *v3; // rbp
  void **v4; // rcx
  unsigned __int16 v5; // dx
  _DWORD *v7; // rax
  int v8; // edx
  __int64 v9; // rcx
  int v10; // edx
  int v11; // edx
  int v12; // edx
  char v13; // al
  int v14; // edx
  int v15; // edx
  int v16; // edx
  int v17; // edx
  void **v18; // rcx
  const char *v19; // rax
  const char *v20; // rax
  int v21; // eax
  __int64 v22; // rax
  _BYTE *v23; // rax
  __int64 v24; // r13
  int v25; // er14
  void **v26; // r12
  _BYTE *v27; // r14
  const signed __int32 *v28; // rax
  const char *v29; // rax
  unsigned __int8 v30; // cl
  __int64 v31; // rdx
  int v32; // ecx
  int v33; // ecx
  int v34; // ecx
  char v35; // al
  _BYTE *v36; // rax
  __int64 v37; // r13
  int v38; // er12
  const signed __int32 *v39; // rax
  _QWORD *v40; // rcx
  unsigned __int16 v41; // dx
  const char *v42; // rax
  _BYTE *v43; // rax
  __int64 v44; // r12
  int v45; // eax
  unsigned int v46; // er13
  _QWORD *v47; // rcx
  unsigned __int16 v48; // dx
  int v49; // eax
  unsigned int v50; // ebx
  int v51; // ecx
  int v52; // edi
  _WORD *v53; // rax
  __int64 v54; // rbx
  _QWORD *v55; // rcx
  unsigned __int16 v56; // dx
  _WORD *v57; // rax
  __int64 v58; // rbx
  _BYTE *v59; // rax
  _BYTE *v60; // rbx
  void **v61; // rcx
  _BYTE *v62; // r12
  void **v63; // rcx
  _BYTE *v64; // r12
  void **v65; // rcx
  unsigned __int16 v66; // dx
  _BYTE *v67; // r12
  void **v68; // rcx
  _BYTE *v69; // r12
  __int64 v70; // rax
  __int64 v71; // rax
  __int64 v72; // rax
  unsigned __int16 v73; // dx
  int v74; // eax
  _BYTE *v75; // [rsp+130h] [rbp-58h]
  _BYTE *v76; // [rsp+130h] [rbp-58h]
  __int64 *v77; // [rsp+190h] [rbp+8h]
  __int64 v78; // [rsp+198h] [rbp+10h]
  unsigned __int16 v79; // [rsp+1A8h] [rbp+20h] BYREF

  v78 = a2;
  v77 = a1;
  v2 = a2;
  v3 = a1;
  v79 = 0;
  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xAu, (__int64)&unk_4DCE8);
    v4 = (void **)off_5F148;
  }
  if ( !v3 )
  {
    if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0xAu) && *((_BYTE *)v4 + 297) >= 2u )
    {
      v5 = 11;
LABEL_10:
      sub_17984((__int64)v4[35], v5, (__int64)&unk_4DCE8, 0i64);
      goto LABEL_11;
    }
    goto LABEL_11;
  }
  if ( !v2 )
  {
    if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0xAu) && *((_BYTE *)v4 + 297) >= 2u )
    {
      v5 = 12;
      goto LABEL_10;
    }
LABEL_11:
    if ( (unsigned int)dword_5F5E0 > 1 )
      _InterlockedAdd((volatile signed __int32 *)P + 1, 1u);
    return 4i64;
  }
  if ( !*(_QWORD *)(v2 + 16) )
  {
    if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0xAu) && *((_BYTE *)v4 + 297) >= 2u )
      sub_11008((__int64)v4[35], 0xDu, (__int64)&unk_4DCE8);
    goto LABEL_11;
  }
  v7 = sub_26948((__int64)qword_5F588);
  *v3 = (__int64)v7;
  if ( !v7 )
  {
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
      && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0xEu, (__int64)&unk_4DCE8);
    }
    return 3i64;
  }
  memset(v7, 0, 0xA0ui64);
  sub_1E93C((void *)(*v3 + 96));
  *(_DWORD *)(*v3 + 152) ^= (*(_DWORD *)(*v3 + 152) ^ ((unsigned __int8)sub_4AAA8(*(_BYTE **)(v2 + 16)) << 12)) & 0x1000;
  v8 = *(_DWORD *)(v2 + 332);
  v9 = *v3 + 96;
  if ( *v3 != -96 )
  {
    *(_BYTE *)(*v3 + 148) &= 0xF0u;
    if ( v8 > 5 )
    {
      v14 = v8 - 7;
      if ( !v14 )
      {
        v13 = 8;
        goto LABEL_53;
      }
      v15 = v14 - 1;
      if ( !v15 )
      {
        v13 = 9;
        goto LABEL_53;
      }
      v16 = v15 - 1;
      if ( !v16 )
      {
        v13 = 10;
        goto LABEL_53;
      }
      v17 = v16 - 1;
      if ( v17 )
      {
        if ( v17 == 1 )
        {
          v13 = 5;
          goto LABEL_53;
        }
        goto LABEL_42;
      }
    }
    else
    {
      if ( v8 == 5 )
      {
        v13 = 7;
        goto LABEL_53;
      }
      if ( !v8 )
        goto LABEL_42;
      v10 = v8 - 1;
      if ( v10 )
      {
        v11 = v10 - 1;
        if ( !v11 )
        {
          v13 = 3;
          goto LABEL_53;
        }
        v12 = v11 - 1;
        if ( !v12 )
        {
          v13 = 4;
          goto LABEL_53;
        }
        if ( v12 == 1 )
        {
          v13 = 6;
LABEL_53:
          *(_BYTE *)(v9 + 52) |= v13;
LABEL_58:
          v18 = (void **)off_5F148;
          goto LABEL_59;
        }
LABEL_42:
        v13 = 1;
        goto LABEL_53;
      }
    }
    v13 = 2;
    goto LABEL_53;
  }
  v18 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    goto LABEL_63;
  if ( _bittest((const signed __int32 *)off_5F148 + 75, 0xAu) && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    v19 = sub_346D0(v8);
    sub_13618(*((_QWORD *)off_5F148 + 35), 0xFu, (__int64)&unk_4DCE8, v19);
    goto LABEL_58;
  }
LABEL_59:
  if ( v18 != &off_5F148 && _bittest((const signed __int32 *)v18 + 75, 0xAu) && *((_BYTE *)v18 + 297) >= 5u )
  {
    v20 = sub_346D0(*(_DWORD *)(v2 + 332));
    sub_13618(*((_QWORD *)off_5F148 + 35), 0x10u, (__int64)&unk_4DCE8, v20);
    v18 = (void **)off_5F148;
  }
LABEL_63:
  if ( *(_QWORD *)(v2 + 344) )
  {
    if ( v18 != &off_5F148 && _bittest((const signed __int32 *)v18 + 75, 0xAu) && *((_BYTE *)v18 + 297) >= 5u )
      sub_143A4((__int64)v18[35], 0x11u, (__int64)&unk_4DCE8);
    *(_QWORD *)(*v3 + 16) = *(_QWORD *)(v2 + 344);
    *(_DWORD *)(*v3 + 152) |= 1u;
    *(_QWORD *)(*v3 + 24) = *(_QWORD *)(v2 + 352);
    *(_DWORD *)(*v3 + 152) |= 2u;
    v21 = sub_33D7C(
            *(_QWORD *)(v2 + 344),
            (__int64 *)((*v3 + 104) & ((unsigned __int128)-(__int128)(unsigned __int64)(*v3 + 96) >> 64)),
            (__int64 *)(*v3 + 96));
    if ( !v21 )
      goto LABEL_77;
    v18 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
      && *((_BYTE *)off_5F148 + 297) >= 5u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x12u, (__int64)&unk_4DCE8, v21);
LABEL_77:
      v18 = (void **)off_5F148;
      goto LABEL_78;
    }
  }
  else if ( v18 != &off_5F148 && _bittest((const signed __int32 *)v18 + 75, 0xAu) && *((_BYTE *)v18 + 297) >= 3u )
  {
    sub_11008((__int64)v18[35], 0x13u, (__int64)&unk_4DCE8);
    goto LABEL_77;
  }
LABEL_78:
  if ( *(_QWORD *)(v2 + 312) )
  {
    if ( v18 != &off_5F148 && _bittest((const signed __int32 *)v18 + 75, 0xAu) && *((_BYTE *)v18 + 297) >= 5u )
      sub_17984((__int64)v18[35], 0x14u, (__int64)&unk_4DCE8);
    *(_DWORD *)(*v3 + 152) |= 0x100u;
    if ( *(_DWORD *)(v2 + 336) == 2 )
      v22 = *(_QWORD *)(v2 + 320);
    else
      v22 = *(_QWORD *)(v2 + 312);
    *(_QWORD *)(*v3 + 88) = v22;
  }
  else if ( v18 != &off_5F148 && _bittest((const signed __int32 *)v18 + 75, 0xAu) && *((_BYTE *)v18 + 297) >= 3u )
  {
    sub_11008((__int64)v18[35], 0x15u, (__int64)&unk_4DCE8);
  }
  v23 = sub_48250(*(_BYTE **)(v2 + 16), 1);
  v24 = (__int64)v23;
  if ( v23 )
  {
    if ( (unsigned int)sub_48BF8((__int64)v23, (_DWORD *)(*v3 + 40)) )
    {
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x16u, (__int64)&unk_4DCE8);
      }
    }
    else
    {
      *(_DWORD *)(*v3 + 152) |= 0x10u;
    }
    v25 = sub_48CA8(v24, (_DWORD *)(*v3 + 56));
    if ( v25 )
    {
      v26 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148
        || !_bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
        || *((_BYTE *)off_5F148 + 297) < 2u )
      {
        goto LABEL_105;
      }
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x17u, (__int64)&unk_4DCE8);
    }
    else
    {
      *(_DWORD *)(*v3 + 152) |= 0x20u;
    }
    v26 = (void **)off_5F148;
LABEL_105:
    if ( !v25 && v26 != &off_5F148 && _bittest((const signed __int32 *)v26 + 75, 0xAu) && *((_BYTE *)v26 + 297) >= 5u )
    {
      sub_178E0((__int64)v26[35], 24i64, (__int64)&unk_4DCE8, *(unsigned __int8 *)(*v3 + 40));
      v26 = (void **)off_5F148;
      v2 = v78;
    }
    v27 = (_BYTE *)(*v3 + 36);
    if ( v26 != &off_5F148 && (*((_BYTE *)v26 + 172) & 0x20) != 0 && *((_BYTE *)v26 + 169) >= 5u )
      sub_143A4((__int64)v26[19], 0x47u, (__int64)&unk_4DB30, v24, *v3 + 36);
    *v27 = *(_BYTE *)(v24 + 9);
    v28 = (const signed __int32 *)off_5F148;
    if ( off_5F148 != &off_5F148 )
    {
      if ( (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x48u, (__int64)&unk_4DB30);
        v28 = (const signed __int32 *)off_5F148;
      }
      if ( v28 != (const signed __int32 *)&off_5F148 && _bittest(v28 + 75, 0xAu) && *((_BYTE *)v28 + 297) >= 5u )
      {
        v29 = sub_34658(*(_DWORD *)(*v3 + 36));
        sub_13618(*((_QWORD *)off_5F148 + 35), 0x1Au, (__int64)&unk_4DCE8, v29);
      }
    }
    v30 = *(_BYTE *)(*v3 + 36);
    v31 = *v3 + 96;
    if ( *v3 != -96 )
    {
      *(_BYTE *)(*v3 + 148) &= 0xFu;
      v32 = v30 - 1;
      if ( v32 )
      {
        v33 = v32 - 5;
        if ( v33 )
        {
          v34 = v33 - 11;
          if ( v34 )
          {
            if ( v34 == 41 )
              v35 = 48;
            else
              v35 = 64;
          }
          else
          {
            v35 = 16;
          }
        }
        else
        {
          v35 = 0;
        }
      }
      else
      {
        v35 = 32;
      }
      *(_BYTE *)(v31 + 52) |= v35;
    }
LABEL_161:
    *(_DWORD *)(*v3 + 152) |= 8u;
    goto LABEL_167;
  }
  v36 = sub_48250(*(_BYTE **)(v2 + 16), 2);
  v37 = (__int64)v36;
  v75 = v36;
  if ( v36 )
  {
    if ( (unsigned int)sub_49430((__int64)v36, (__m128i *)(*v3 + 40)) )
    {
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x1Bu, (__int64)&unk_4DCE8);
      }
    }
    else
    {
      *(_DWORD *)(*v3 + 152) |= 0x10u;
    }
    v38 = sub_494E4(v37, (__m128i *)(*v3 + 56));
    if ( v38 )
    {
      v39 = (const signed __int32 *)off_5F148;
      if ( off_5F148 == &off_5F148
        || !_bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
        || *((_BYTE *)off_5F148 + 297) < 2u )
      {
LABEL_147:
        if ( !v38
          && v39 != (const signed __int32 *)&off_5F148
          && _bittest(v39 + 75, 0xAu)
          && *((_BYTE *)v39 + 297) >= 5u )
        {
          sub_176E4(
            *((_QWORD *)off_5F148 + 35),
            29i64,
            (__int64)&unk_4DCE8,
            (unsigned __int8)HIBYTE(*(_WORD *)(*v3 + 40)) | (unsigned __int16)(*(unsigned __int8 *)(*v3 + 40) << 8));
          v3 = v77;
          v2 = v78;
          v37 = (__int64)v75;
        }
        if ( !(unsigned int)sub_48E1C(v37, (unsigned __int8 *)(*v3 + 36), 0i64) )
        {
          if ( off_5F148 != &off_5F148
            && _bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
            && *((_BYTE *)off_5F148 + 297) >= 5u )
          {
            v42 = sub_34658(*(_DWORD *)(*v3 + 36));
            sub_13618(*((_QWORD *)off_5F148 + 35), 0x1Fu, (__int64)&unk_4DCE8, v42);
          }
          goto LABEL_161;
        }
        v40 = off_5F148;
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
        {
          v41 = 30;
LABEL_166:
          sub_11008(v40[35], v41, (__int64)&unk_4DCE8);
          goto LABEL_167;
        }
        goto LABEL_167;
      }
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x1Cu, (__int64)&unk_4DCE8);
    }
    else
    {
      *(_DWORD *)(*v3 + 152) |= 0x20u;
    }
    v39 = (const signed __int32 *)off_5F148;
    goto LABEL_147;
  }
  v40 = off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
    && *((_BYTE *)off_5F148 + 297) >= 4u )
  {
    v41 = 32;
    goto LABEL_166;
  }
LABEL_167:
  v43 = sub_48250(*(_BYTE **)(v2 + 16), 0);
  v44 = (__int64)v43;
  v76 = v43;
  if ( !v43 )
  {
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
      && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x21u, (__int64)&unk_4DCE8);
    }
    if ( (unsigned int)dword_5F5E0 > 1 )
      _InterlockedAdd((volatile signed __int32 *)P + 1, 1u);
    return 18i64;
  }
  v45 = sub_4879C((__int64)v43, *v3 + 72);
  v46 = v45;
  if ( v45 )
  {
    v47 = off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
      || *((_BYTE *)off_5F148 + 297) < 2u )
    {
      goto LABEL_181;
    }
    v48 = 34;
LABEL_180:
    sub_1102C(v47[35], v48, (__int64)&unk_4DCE8, v45);
LABEL_181:
    if ( (unsigned int)dword_5F5E0 > 1 )
      _InterlockedAdd((volatile signed __int32 *)P + 1, 1u);
    return v46;
  }
  v45 = sub_48854(v44, *v3 + 78);
  v46 = v45;
  if ( v45 )
  {
    v47 = off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
      || *((_BYTE *)off_5F148 + 297) < 2u )
    {
      goto LABEL_181;
    }
    v48 = 35;
    goto LABEL_180;
  }
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_17608(*((_QWORD *)off_5F148 + 35), 36i64, (__int64)&unk_4DCE8, *(unsigned __int8 *)(*v3 + 72));
    v3 = v77;
    v2 = v78;
    v44 = (__int64)v76;
  }
  v49 = sub_48908(v44, &v79);
  v50 = v49;
  if ( v49 )
  {
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
      && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x25u, (__int64)&unk_4DCE8, v49);
    }
    if ( (unsigned int)dword_5F5E0 <= 1 )
      return v50;
LABEL_199:
    _InterlockedAdd((volatile signed __int32 *)P + 1, 1u);
    return v50;
  }
  switch ( v79 )
  {
    case 0x800u:
      v51 = 2048;
      break;
    case 0x806u:
      v51 = 2054;
      break;
    case 0x8035u:
      v51 = 32821;
      break;
    case 0x86DDu:
      v51 = 34525;
      break;
    default:
      v51 = 0;
      break;
  }
  v52 = 4;
  *(_DWORD *)(*v3 + 32) = v51;
  *(_DWORD *)(*v3 + 152) |= 4u;
  v53 = sub_48250(*(_BYTE **)(v2 + 16), 3);
  v54 = (__int64)v53;
  if ( v53 )
  {
    sub_49AAC(v53, (_WORD *)(*v3 + 84));
    sub_49B70(v54, (_WORD *)(*v3 + 86));
    v55 = off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
      || *((_BYTE *)off_5F148 + 297) < 5u )
    {
      goto LABEL_221;
    }
    v56 = 38;
LABEL_220:
    sub_127D0(v55[35], v56, (__int64)&unk_4DCE8, *(unsigned __int16 *)(*v3 + 84));
LABEL_221:
    *(_DWORD *)(*v3 + 152) |= 0x40u;
    *(_DWORD *)(*v3 + 152) |= 0x80u;
    goto LABEL_226;
  }
  v57 = sub_48250(*(_BYTE **)(v2 + 16), 4);
  v58 = (__int64)v57;
  if ( v57 )
  {
    sub_49CE4(v57, (_WORD *)(*v3 + 84));
    sub_49DA8(v58, (_WORD *)(*v3 + 86));
    v55 = off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
      || *((_BYTE *)off_5F148 + 297) < 5u )
    {
      goto LABEL_221;
    }
    v56 = 39;
    goto LABEL_220;
  }
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x28u, (__int64)&unk_4DCE8);
  }
LABEL_226:
  v59 = sub_48250(*(_BYTE **)(v2 + 16), 6);
  v60 = v59;
  if ( v59 )
  {
    if ( v79 == 2048 )
    {
      v62 = (_BYTE *)(*v3 + 156);
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_143A4(*((_QWORD *)off_5F148 + 19), 0xBBu, (__int64)&unk_4DB30, v59, *v3 + 156);
      *v62 = *v60;
      v63 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 )
      {
        if ( (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        {
          sub_11008(*((_QWORD *)off_5F148 + 19), 0xBCu, (__int64)&unk_4DB30);
          v63 = (void **)off_5F148;
        }
        if ( v63 != &off_5F148 && _bittest((const signed __int32 *)v63 + 75, 0xAu) && *((_BYTE *)v63 + 297) >= 5u )
          sub_1102C((__int64)v63[35], 0x2Bu, (__int64)&unk_4DCE8, *(unsigned __int8 *)(*v3 + 156));
      }
      *(_DWORD *)(*v3 + 152) |= 0x200u;
      v64 = (_BYTE *)(*v3 + 157);
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_143A4(*((_QWORD *)off_5F148 + 19), 0xBDu, (__int64)&unk_4DB30, v60, *v3 + 157);
      *v64 = v60[1];
      v65 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        goto LABEL_282;
      if ( (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 19), 0xBEu, (__int64)&unk_4DB30);
        v65 = (void **)off_5F148;
      }
      if ( v65 == &off_5F148 || !_bittest((const signed __int32 *)v65 + 75, 0xAu) || *((_BYTE *)v65 + 297) < 5u )
        goto LABEL_282;
      v66 = 45;
    }
    else
    {
      if ( v79 != 0x86DD )
        goto LABEL_283;
      v67 = (_BYTE *)(*v3 + 156);
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_143A4(*((_QWORD *)off_5F148 + 19), 0xC7u, (__int64)&unk_4DB30, v59, *v3 + 156);
      *v67 = *v60;
      v68 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 )
      {
        if ( (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        {
          sub_11008(*((_QWORD *)off_5F148 + 19), 0xC8u, (__int64)&unk_4DB30);
          v68 = (void **)off_5F148;
        }
        if ( v68 != &off_5F148 && _bittest((const signed __int32 *)v68 + 75, 0xAu) && *((_BYTE *)v68 + 297) >= 5u )
          sub_1102C((__int64)v68[35], 0x2Fu, (__int64)&unk_4DCE8, *(unsigned __int8 *)(*v3 + 156));
      }
      *(_DWORD *)(*v3 + 152) |= 0x200u;
      v69 = (_BYTE *)(*v3 + 157);
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_143A4(*((_QWORD *)off_5F148 + 19), 0xC9u, (__int64)&unk_4DB30, v60, *v3 + 157);
      *v69 = v60[1];
      v65 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        goto LABEL_282;
      if ( (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 19), 0xCAu, (__int64)&unk_4DB30);
        v65 = (void **)off_5F148;
      }
      if ( v65 == &off_5F148 || !_bittest((const signed __int32 *)v65 + 75, 0xAu) || *((_BYTE *)v65 + 297) < 5u )
      {
LABEL_282:
        *(_DWORD *)(*v3 + 152) |= 0x400u;
        goto LABEL_283;
      }
      v66 = 49;
    }
    sub_1102C((__int64)v65[35], v66, (__int64)&unk_4DCE8, *(unsigned __int8 *)(*v3 + 157));
    goto LABEL_282;
  }
  v61 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
    && *((_BYTE *)off_5F148 + 297) >= 4u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x29u, (__int64)&unk_4DCE8);
LABEL_283:
    v61 = (void **)off_5F148;
  }
  v70 = *v3;
  if ( (*(_BYTE *)(v2 + 120) & 0x10) != 0 )
  {
    v71 = v70 + 96;
    if ( !v71 )
      goto LABEL_290;
    *(_BYTE *)(v71 + 53) &= 0xA0u;
    *(_BYTE *)(v71 + 53) |= 0x20u;
  }
  else
  {
    v72 = v70 + 96;
    if ( !v72 )
      goto LABEL_290;
    *(_BYTE *)(v72 + 53) &= 0x80u;
  }
  v61 = (void **)off_5F148;
LABEL_290:
  if ( *v3 != -96 )
  {
    v52 = 0;
    *(_BYTE *)(*v3 + 112) = byte_5F190;
    v61 = (void **)off_5F148;
  }
  v50 = v52 != 0;
  if ( v52 )
  {
    if ( v61 != &off_5F148 && _bittest((const signed __int32 *)v61 + 75, 0xAu) && *((_BYTE *)v61 + 297) >= 2u )
    {
      v73 = 50;
LABEL_297:
      sub_1102C((__int64)v61[35], v73, (__int64)&unk_4DCE8, v50);
      goto LABEL_298;
    }
    goto LABEL_298;
  }
  v74 = sub_1EA0C(*v3 + 96, v2 + 372);
  v50 = v74 != 0;
  if ( v74 )
  {
    v61 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
      && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      v73 = 51;
      goto LABEL_297;
    }
LABEL_298:
    if ( (unsigned int)dword_5F5E0 <= 1 )
      return v50;
    goto LABEL_199;
  }
  *(_QWORD *)*v3 = *(_QWORD *)(v2 + 8);
  *(_QWORD *)(*v3 + 8) = *(_QWORD *)v2;
  *(_DWORD *)(*v3 + 152) ^= (*(_DWORD *)(*v3 + 152) ^ (((*(_BYTE *)(v2 + 120) & 0x20) == 32) << 11)) & 0x800;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x34u, (__int64)&unk_4DCE8);
  }
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;
// 5F190: using guessed type char byte_5F190;
// 5F5E0: using guessed type int dword_5F5E0;

//----- (0000000000019244) ----------------------------------------------------
__int64 __fastcall sub_19244(__int64 *a1)
{
  void **v2; // rcx
  __int64 result; // rax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x35u, (__int64)&unk_4DCE8);
    v2 = (void **)off_5F148;
  }
  if ( a1 && *a1 )
  {
    sub_269B0((__int64)qword_5F588, *a1);
    *a1 = 0i64;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
      && *((_BYTE *)off_5F148 + 297) >= 5u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x37u, (__int64)&unk_4DCE8);
    }
    result = 0i64;
  }
  else
  {
    if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 75, 0xAu) && *((_BYTE *)v2 + 297) >= 2u )
      sub_17984((__int64)v2[35], 0x36u, (__int64)&unk_4DCE8, a1);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000019344) ----------------------------------------------------
__int64 __fastcall sub_19344(__int64 a1, int a2, __int64 *a3)
{
  const signed __int32 *v6; // r10
  unsigned __int16 *v7; // rdx
  __int64 v9; // rdx
  int v10; // edx
  __int64 v11; // rdx
  __int64 v12; // rdx
  int v13; // edx
  const wchar_t *v14; // rax
  __int64 v15; // r10
  char v16; // al

  v6 = (const signed __int32 *)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0xAu)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x38u, (__int64)&unk_4DCE8);
    v6 = (const signed __int32 *)off_5F148;
  }
  if ( a2 > 47 )
  {
    if ( a2 == 256 )
    {
      if ( (*(_BYTE *)(a1 + 152) & 8) != 0 )
      {
        v10 = *(_DWORD *)(a1 + 36);
        return sub_391AC(a3, v10);
      }
      return 5i64;
    }
    v13 = 512;
    if ( a2 == 512 )
    {
      v16 = *(_BYTE *)(a1 + 148);
      switch ( v16 & 0xF )
      {
        case 0:
          return 5i64;
        case 3:
          v13 = 513;
          break;
        case 4:
          v13 = 514;
          break;
        case 5:
          v13 = 520;
          break;
        case 6:
          v13 = 515;
          break;
        case 7:
          v13 = 516;
          break;
        case 8:
          v13 = 517;
          break;
        case 9:
          v13 = 518;
          break;
        case 10:
          v13 = 519;
          break;
      }
    }
    else
    {
      if ( a2 == 1125 )
        return sub_395A8(a3, (const wchar_t *)(a1 + 114));
      if ( a2 == 2047 )
      {
        if ( (*(_BYTE *)(a1 + 152) & 4) != 0 )
        {
          v10 = *(_DWORD *)(a1 + 32);
          return sub_391AC(a3, v10);
        }
        return 5i64;
      }
      if ( a2 != 45056 )
      {
        if ( a2 == 49152 || a2 == 51200 )
        {
          if ( _bittest((const signed __int32 *)(a1 + 152), 9u) )
          {
            v10 = *(unsigned __int8 *)(a1 + 156);
            return sub_391AC(a3, v10);
          }
        }
        else
        {
          if ( a2 != 53248 && a2 != 55296 )
          {
LABEL_53:
            if ( v6 != (const signed __int32 *)&off_5F148 && _bittest(v6 + 75, 0xAu) && *((_BYTE *)v6 + 297) >= 5u )
            {
              v14 = sub_352B8(a2);
              sub_17860(*(_QWORD *)(v15 + 280), 0x39u, (__int64)&unk_4DCE8, v14);
            }
            return 5i64;
          }
          if ( _bittest((const signed __int32 *)(a1 + 152), 0xAu) )
          {
            v10 = *(unsigned __int8 *)(a1 + 157);
            return sub_391AC(a3, v10);
          }
        }
        return 5i64;
      }
      if ( (*(_BYTE *)(a1 + 149) & 0x60) != 0 )
      {
        v13 = 45058;
        if ( (*(_BYTE *)(a1 + 149) & 0x60) != 32 )
          v13 = 0;
      }
      else
      {
        v13 = 45057;
      }
    }
    return sub_398F8(a3, v13);
  }
  switch ( a2 )
  {
    case 47:
      if ( (*(_BYTE *)(a1 + 152) & 0x20) != 0 && *(_DWORD *)(a1 + 32) == 34525 )
      {
        v7 = (unsigned __int16 *)(a1 + 56);
        return sub_3A090(a3, v7, 0x80u);
      }
      return 5i64;
    case 3:
      if ( a1 != -96 )
      {
        v12 = *(_QWORD *)(a1 + 104);
LABEL_37:
        if ( v12 != -1 )
          return sub_392B4(a3, v12);
        return 5i64;
      }
LABEL_36:
      v12 = -1i64;
      goto LABEL_37;
    case 5:
      if ( a1 != -96 )
      {
        v12 = *(_QWORD *)(a1 + 96);
        goto LABEL_37;
      }
      goto LABEL_36;
    case 28:
      if ( (*(_BYTE *)(a1 + 152) & 0x10) == 0 || *(_DWORD *)(a1 + 32) != 2048 )
        return 5i64;
      v11 = a1 + 40;
      return sub_39CFC(a3, v11, 32);
    case 29:
      if ( (*(_BYTE *)(a1 + 152) & 0x20) == 0 || *(_DWORD *)(a1 + 32) != 2048 )
        return 5i64;
      v11 = a1 + 56;
      return sub_39CFC(a3, v11, 32);
    case 30:
      if ( (*(_BYTE *)(a1 + 152) & 0x40) != 0 )
      {
        v10 = *(unsigned __int16 *)(a1 + 84);
        return sub_391AC(a3, v10);
      }
      return 5i64;
  }
  if ( a2 != 31 )
  {
    switch ( a2 )
    {
      case ' ':
        v9 = a1 + 72;
        break;
      case '!':
        v9 = a1 + 78;
        break;
      case '.':
        if ( (*(_BYTE *)(a1 + 152) & 0x10) != 0 && *(_DWORD *)(a1 + 32) == 34525 )
        {
          v7 = (unsigned __int16 *)(a1 + 40);
          return sub_3A090(a3, v7, 0x80u);
        }
        return 5i64;
      default:
        goto LABEL_53;
    }
    return sub_3AA24(a3, v9);
  }
  if ( *(char *)(a1 + 152) >= 0 )
    return 5i64;
  v10 = *(unsigned __int16 *)(a1 + 86);
  return sub_391AC(a3, v10);
}
// 195A7: variable 'v15' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (00000000000196F0) ----------------------------------------------------
__int64 __fastcall sub_196F0(__int64 a1, __int64 a2)
{
  unsigned int v4; // ebx
  __int64 v5; // rax
  __int64 v6; // rdi
  int v7; // edx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  __int64 v12; // rdx
  int v13; // eax
  bool v14; // zf
  __int64 v15; // rdx
  int v16; // eax
  bool v17; // zf
  __int64 v18; // rdx
  const char *v19; // r9
  __int64 v21; // rdx
  _DWORD *v22; // [rsp+50h] [rbp+18h] BYREF
  _QWORD *v23; // [rsp+58h] [rbp+20h] BYREF

  v23 = 0i64;
  v22 = 0i64;
  v4 = 0x2000;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 8u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x3Bu, (__int64)&unk_4DCE8);
  }
  sub_439A0(a2, (__int64)&v23);
  while ( !sub_43C74(v23) )
  {
    v5 = sub_43E74((__int64)v23);
    v6 = v5;
    if ( v5 )
      v7 = *(_DWORD *)(v5 + 8);
    else
      v7 = 0;
    if ( (unsigned int)sub_19344(a1, v7, (__int64 *)&v22) )
    {
LABEL_33:
      v4 = 4096;
      break;
    }
    if ( v6 )
      v8 = *(_DWORD *)(v6 + 12);
    else
      v8 = 0;
    v9 = v8 - 1;
    if ( v9 )
    {
      v10 = v9 - 1;
      if ( !v10 )
      {
        if ( v6 )
          v18 = *(_QWORD *)v6;
        else
          v18 = 0i64;
        v14 = (unsigned int)sub_3C074(v22, v18) == 7;
LABEL_32:
        if ( v14 )
          goto LABEL_33;
        goto LABEL_48;
      }
      v11 = v10 - 1;
      if ( v11 )
      {
        if ( v11 != 1 )
          goto LABEL_33;
        v12 = v6 ? *(_QWORD *)v6 : 0i64;
        v13 = sub_3C074(v22, v12);
        if ( v13 == 7 )
          goto LABEL_33;
        v14 = v13 == 3;
        goto LABEL_32;
      }
      if ( v6 )
        v15 = *(_QWORD *)v6;
      else
        v15 = 0i64;
      v16 = sub_3C074(v22, v15);
      if ( v16 == 7 )
        goto LABEL_48;
      v17 = v16 == 3;
    }
    else
    {
      if ( v6 )
        v21 = *(_QWORD *)v6;
      else
        v21 = 0i64;
      v17 = (unsigned int)sub_3C074(v22, v21) == 7;
    }
    if ( !v17 )
      goto LABEL_33;
LABEL_48:
    sub_43D50((__int64)v23);
    sub_3B0E0((__int64 *)&v22);
  }
  sub_43B64((__int64 *)&v23);
  if ( v22 )
    sub_3B0E0((__int64 *)&v22);
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 8u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    v19 = "NNS_ERROR_DOESNT_MATCH";
    if ( v4 == 0x2000 )
      v19 = "NNS_ERROR_MATCHES";
    sub_13618(*((_QWORD *)off_5F148 + 35), 0x3Cu, (__int64)&unk_4DCE8, v19);
  }
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000198E8) ----------------------------------------------------
__int64 __fastcall sub_198E8(__int64 a1, __int64 a2, __int64 *a3)
{
  int v3; // esi
  void **v7; // rcx
  __int64 v8; // rdi
  bool v9; // bl
  _QWORD *v10; // rcx
  unsigned __int16 v11; // dx
  __int64 v12; // rax
  unsigned int v13; // ebx
  _QWORD *v15; // [rsp+60h] [rbp+8h] BYREF

  v3 = 0;
  v15 = 0i64;
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 8u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_143EC(*((_QWORD *)off_5F148 + 35), 0x56u, (__int64)&unk_4DCE8, a1, a2, a3);
    v7 = (void **)off_5F148;
  }
  if ( a1 && a2 && a3 )
  {
    *a3 = 0i64;
    sub_439A0(a1, (__int64)&v15);
    while ( 1 )
    {
      if ( sub_43C74(v15) )
      {
LABEL_34:
        v13 = v3 != 0x2000 ? 5 : 0;
        sub_43B64((__int64 *)&v15);
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 75, 8u)
          && *((_BYTE *)off_5F148 + 297) >= 5u )
        {
          sub_1102C(*((_QWORD *)off_5F148 + 35), 0x5Bu, (__int64)&unk_4DCE8, v13);
        }
        return v13;
      }
      v8 = sub_43E74((__int64)v15);
      v9 = !(unsigned int)sub_1AD88(v8, 1099) || !(unsigned int)sub_1AD88(v8, 1100);
      if ( (unsigned int)sub_2DA90(0x201601Au) )
      {
        if ( v9 )
          goto LABEL_25;
        v10 = off_5F148;
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 75, 8u)
          && *((_BYTE *)off_5F148 + 297) >= 5u )
        {
          v11 = 88;
LABEL_19:
          sub_11008(v10[35], v11, (__int64)&unk_4DCE8);
          goto LABEL_26;
        }
      }
      else
      {
        if ( !v9 )
        {
LABEL_25:
          v12 = sub_3EC78(v8);
          v3 = sub_196F0(a2, v12);
          if ( v3 == 0x2000 )
          {
            if ( off_5F148 != &off_5F148
              && _bittest((const signed __int32 *)off_5F148 + 75, 8u)
              && *((_BYTE *)off_5F148 + 297) >= 4u )
            {
              sub_11008(*((_QWORD *)off_5F148 + 35), 0x5Au, (__int64)&unk_4DCE8);
            }
            *a3 = v8;
            goto LABEL_34;
          }
          goto LABEL_26;
        }
        v10 = off_5F148;
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 75, 8u)
          && *((_BYTE *)off_5F148 + 297) >= 5u )
        {
          v11 = 89;
          goto LABEL_19;
        }
      }
LABEL_26:
      sub_43D50((__int64)v15);
    }
  }
  if ( v7 != &off_5F148 && _bittest((const signed __int32 *)v7 + 75, 8u) && *((_BYTE *)v7 + 297) >= 2u )
    sub_143EC((__int64)v7[35], 0x57u, (__int64)&unk_4DCE8, a1, a2, a3);
  return 4i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000019B54) ----------------------------------------------------
__int64 __fastcall sub_19B54(_QWORD *a1)
{
  unsigned int v2; // ebx
  void **v3; // rcx
  _QWORD *v4; // rax

  v2 = 0;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x20) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x61u, (__int64)&unk_4DCE8);
    v3 = (void **)off_5F148;
  }
  if ( a1 )
  {
    v4 = sub_26948((__int64)qword_5F5A8);
    *a1 = v4;
    if ( v4 )
    {
      *v4 = 0i64;
      v4[1] = 0i64;
      v4[2] = 0i64;
      v3 = (void **)off_5F148;
    }
    else
    {
      v3 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x63u, (__int64)&unk_4DCE8);
        v3 = (void **)off_5F148;
      }
      v2 = 3;
    }
  }
  else
  {
    if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 300) & 0x20) != 0 && *((_BYTE *)v3 + 297) >= 2u )
    {
      sub_11008((__int64)v3[35], 0x62u, (__int64)&unk_4DCE8);
      v3 = (void **)off_5F148;
    }
    v2 = 4;
  }
  if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 300) & 8) != 0 && *((_BYTE *)v3 + 297) >= 5u )
    sub_1102C((__int64)v3[35], 0x64u, (__int64)&unk_4DCE8, v2);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000019CAC) ----------------------------------------------------
__int64 __fastcall sub_19CAC(__int64 a1)
{
  unsigned int v2; // ebx
  void **v3; // rcx

  v2 = 0;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x20) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x65u, (__int64)&unk_4DCE8);
    v3 = (void **)off_5F148;
  }
  if ( a1 )
  {
    sub_269B0((__int64)qword_5F5A8, a1);
    v3 = (void **)off_5F148;
  }
  else
  {
    if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 300) & 0x20) != 0 && *((_BYTE *)v3 + 297) >= 3u )
    {
      sub_11008((__int64)v3[35], 0x66u, (__int64)&unk_4DCE8);
      v3 = (void **)off_5F148;
    }
    v2 = 4;
  }
  if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 300) & 0x20) != 0 && *((_BYTE *)v3 + 297) >= 5u )
    sub_1102C((__int64)v3[35], 0x67u, (__int64)&unk_4DCE8, v2);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000019DB0) ----------------------------------------------------
__int64 __fastcall sub_19DB0(PVOID *a1)
{
  void **v2; // rcx
  unsigned int v3; // ebx
  _QWORD *v4; // rcx
  unsigned __int16 v5; // dx
  __int64 *v6; // rax
  int v7; // eax
  void **v8; // rcx
  unsigned __int16 v9; // dx
  unsigned __int8 v10; // al
  int v12; // [rsp+80h] [rbp+8h] BYREF

  v12 = 0;
  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x68u, (__int64)&unk_4DCE8);
    v2 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 300) & 0x10) != 0 && *((_BYTE *)v2 + 297) >= 2u )
      sub_11008((__int64)v2[35], 0x69u, (__int64)&unk_4DCE8);
    v3 = 4;
    goto LABEL_75;
  }
  *a1 = 0i64;
  qword_5F588 = sub_26670(1i64, 0xA0u, 0x4552504Eu);
  if ( !qword_5F588 )
  {
    v4 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 0x10) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
      goto LABEL_17;
    v5 = 106;
LABEL_16:
    sub_11008(v4[35], v5, (__int64)&unk_4DCE8);
LABEL_17:
    v3 = 3;
LABEL_75:
    sub_1A2F8(a1);
    goto LABEL_76;
  }
  qword_5F590 = sub_26670(1i64, 0x18u, 0x6852504Eu);
  if ( !qword_5F590 )
  {
    v4 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 0x10) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
      goto LABEL_17;
    v5 = 107;
    goto LABEL_16;
  }
  qword_5F5A8 = sub_26670(1i64, 0x18u, 0x6152504Eu);
  if ( !qword_5F5A8 )
  {
    v4 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 8) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
      goto LABEL_17;
    v5 = 108;
    goto LABEL_16;
  }
  qword_5F598 = sub_26670(1i64, 0x38u, 0x4450504Eu);
  if ( !qword_5F598 )
  {
    v4 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 0x10) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
      goto LABEL_17;
    v5 = 109;
    goto LABEL_16;
  }
  qword_5F5A0 = sub_26670(1i64, 8u, 0x5252504Eu);
  if ( !qword_5F5A0 )
  {
    v4 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 0x10) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
      goto LABEL_17;
    v5 = 110;
    goto LABEL_16;
  }
  v6 = (__int64 *)sub_26404(1, 0x28u, 0x7552504Eu);
  *a1 = v6;
  if ( !v6 )
  {
    v4 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 0x10) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
      goto LABEL_17;
    v5 = 111;
    goto LABEL_16;
  }
  v7 = sub_42500(0x52617645u, v6 + 4, 3, 0i64);
  v3 = v7;
  if ( v7 )
  {
    v8 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      v9 = 112;
LABEL_73:
      sub_1102C((__int64)v8[35], v9, (__int64)&unk_4DCE8, v7);
      v8 = (void **)off_5F148;
      goto LABEL_74;
    }
  }
  else
  {
    *((_QWORD *)*a1 + 2) = 0i64;
    v7 = sub_1EE78((PVOID *)*a1 + 2);
    v3 = v7;
    if ( v7 )
    {
      v8 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        v9 = 113;
        goto LABEL_73;
      }
    }
    else
    {
      *((_QWORD *)*a1 + 3) = 0i64;
      v7 = sub_21884((PERESOURCE *)*a1 + 3);
      v3 = v7;
      if ( v7 )
      {
        v8 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
        {
          v9 = 114;
          goto LABEL_73;
        }
      }
      else
      {
        *(_QWORD *)*a1 = 0i64;
        *((_QWORD *)*a1 + 1) = 0i64;
        v10 = sub_2DA90(0x2016008u);
        *((_QWORD *)*a1 + 1) = sub_4481C(
                                 v10,
                                 0i64,
                                 1i64,
                                 0x4152504Eu,
                                 0i64,
                                 0,
                                 0i64,
                                 0i64,
                                 (__int64)sub_19CAC,
                                 (__int64)sub_13830,
                                 &v12);
        if ( v12 )
        {
          v7 = sub_473B0(v12);
          v3 = v7;
          v8 = (void **)off_5F148;
          if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
          {
            v9 = 116;
            goto LABEL_73;
          }
        }
        else
        {
          v7 = sub_24174();
          v3 = v7;
          if ( v7 )
          {
            v8 = (void **)off_5F148;
            if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
            {
              v9 = 117;
              goto LABEL_73;
            }
          }
          else
          {
            v7 = sub_250B4();
            v3 = v7;
            if ( !v7 )
            {
LABEL_76:
              v8 = (void **)off_5F148;
              goto LABEL_77;
            }
            v8 = (void **)off_5F148;
            if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
            {
              v9 = 118;
              goto LABEL_73;
            }
          }
        }
      }
    }
  }
LABEL_74:
  if ( v3 )
    goto LABEL_75;
LABEL_77:
  if ( v8 != &off_5F148 && (*((_BYTE *)v8 + 300) & 0x10) != 0 && *((_BYTE *)v8 + 297) >= 5u )
    sub_1102C((__int64)v8[35], 0x77u, (__int64)&unk_4DCE8, v3);
  return v3;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001A2F8) ----------------------------------------------------
__int64 __fastcall sub_1A2F8(PVOID *a1)
{
  void **v2; // rcx
  ULONG_PTR v3; // rcx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  unsigned int v8; // edi
  void **v9; // rcx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x78u, (__int64)&unk_4DCE8);
    v2 = (void **)off_5F148;
  }
  if ( a1 && *a1 )
  {
    sub_42938((__int64 *)*a1 + 4, 0i64);
    v3 = *((_QWORD *)*a1 + 1);
    if ( v3 )
    {
      v4 = sub_44B4C(v3);
      if ( v4 )
      {
        v5 = sub_473B0(v4);
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
          sub_1102C(*((_QWORD *)off_5F148 + 35), 0x7Cu, (__int64)&unk_4DCE8, v5);
      }
    }
    else if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x7Du, (__int64)&unk_4DCE8);
    }
    v6 = sub_21A90((PERESOURCE *)*a1 + 3);
    if ( v6 && off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x7Eu, (__int64)&unk_4DCE8, v6);
    v7 = sub_1F0D4((PVOID *)*a1 + 2);
    v8 = v7;
    if ( v7 && off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x7Fu, (__int64)&unk_4DCE8, v7);
    sub_26488(*a1, 0x7552504Eu);
    *a1 = 0i64;
  }
  else
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 300) & 0x10) != 0 && *((_BYTE *)v2 + 297) >= 5u )
      sub_11008((__int64)v2[35], 0x79u, (__int64)&unk_4DCE8);
    v8 = 4;
  }
  sub_25160();
  v9 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x13u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xEu, (__int64)&unk_4DCA8);
    v9 = (void **)off_5F148;
  }
  if ( Dst )
  {
    sub_26488(Dst, 0x6C5A504Eu);
    Dst = 0i64;
LABEL_43:
    v9 = (void **)off_5F148;
    goto LABEL_44;
  }
  if ( v9 == &off_5F148 )
    goto LABEL_48;
  if ( _bittest((const signed __int32 *)v9 + 75, 0x13u) && *((_BYTE *)v9 + 297) >= 2u )
  {
    sub_11008((__int64)v9[35], 0xFu, (__int64)&unk_4DCA8);
    goto LABEL_43;
  }
LABEL_44:
  if ( v9 != &off_5F148 && _bittest((const signed __int32 *)v9 + 75, 0x13u) && *((_BYTE *)v9 + 297) >= 5u )
  {
    sub_11008((__int64)v9[35], 0x10u, (__int64)&unk_4DCA8);
    v9 = (void **)off_5F148;
  }
LABEL_48:
  if ( qword_5F588 )
  {
    sub_26828(qword_5F588);
    qword_5F588 = 0i64;
    v9 = (void **)off_5F148;
  }
  if ( qword_5F590 )
  {
    sub_26828(qword_5F590);
    qword_5F590 = 0i64;
    v9 = (void **)off_5F148;
  }
  if ( qword_5F5A8 )
  {
    sub_26828(qword_5F5A8);
    qword_5F5A8 = 0i64;
    v9 = (void **)off_5F148;
  }
  if ( qword_5F598 )
  {
    sub_26828(qword_5F598);
    qword_5F598 = 0i64;
    v9 = (void **)off_5F148;
  }
  if ( qword_5F5A0 )
  {
    sub_26828(qword_5F5A0);
    qword_5F5A0 = 0i64;
    v9 = (void **)off_5F148;
  }
  if ( v9 != &off_5F148 && (*((_BYTE *)v9 + 300) & 0x10) != 0 && *((_BYTE *)v9 + 297) >= 5u )
    sub_1102C((__int64)v9[35], 0x80u, (__int64)&unk_4DCE8, v8);
  return v8;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001A6D8) ----------------------------------------------------
__int64 __fastcall sub_1A6D8(__int64 a1)
{
  void **v2; // rcx
  unsigned int v3; // ebx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  unsigned __int16 v7; // dx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x81u, (__int64)&unk_4DCE8);
    v2 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 300) & 0x10) != 0 && *((_BYTE *)v2 + 297) >= 5u )
    {
      sub_11008((__int64)v2[35], 0x82u, (__int64)&unk_4DCE8);
      v2 = (void **)off_5F148;
    }
    v3 = 4;
    goto LABEL_28;
  }
  v4 = sub_42A4C(*(_QWORD *)(a1 + 32), 0i64);
  v3 = v4;
  if ( !v4 )
  {
    v5 = sub_44FD8(*(_QWORD *)(a1 + 8));
    if ( v5 )
    {
      v6 = sub_473B0(v5);
      v3 = v6;
      v2 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v3;
      if ( (*((_BYTE *)off_5F148 + 300) & 0x10) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
        goto LABEL_28;
      v7 = 133;
    }
    else
    {
      v6 = sub_24AD0();
      v3 = v6;
      if ( !v6 )
        goto LABEL_27;
      v2 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v3;
      if ( (*((_BYTE *)off_5F148 + 300) & 0x10) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
        goto LABEL_28;
      v7 = 134;
    }
    sub_1102C((__int64)v2[35], v7, (__int64)&unk_4DCE8, v6);
    goto LABEL_27;
  }
  v2 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return v3;
  if ( (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x83u, (__int64)&unk_4DCE8, v4);
LABEL_27:
    v2 = (void **)off_5F148;
  }
LABEL_28:
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 300) & 0x10) != 0 && *((_BYTE *)v2 + 297) >= 5u )
    sub_1102C((__int64)v2[35], 0x87u, (__int64)&unk_4DCE8, v3);
  return v3;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001A8A4) ----------------------------------------------------
__int64 __fastcall sub_1A8A4(__int64 a1, __int64 a2)
{
  unsigned int v2; // ebp
  int v5; // er14
  int v6; // eax
  void **v7; // rcx
  unsigned __int16 v8; // dx
  unsigned __int64 v9; // r15
  int v10; // eax
  unsigned int v11; // eax
  int v12; // er9
  unsigned __int64 *v14; // [rsp+60h] [rbp+8h] BYREF
  __int64 v15; // [rsp+70h] [rbp+18h] BYREF

  v14 = 0i64;
  v2 = 0;
  v5 = 1;
  if ( a1 && a2 )
  {
    v6 = sub_3ED70(a2, 3, &v15);
    if ( v6 )
    {
      if ( v6 == 5 )
      {
        v5 = 2;
        v6 = sub_3ED70(a2, 5, &v15);
      }
      if ( v6 && v6 != 5 )
      {
        v7 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 )
        {
          if ( (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
          {
            v8 = 140;
LABEL_43:
            v12 = 0;
            goto LABEL_44;
          }
          goto LABEL_46;
        }
        return v2;
      }
    }
    v9 = *(_QWORD *)(v15 + 4);
    v10 = sub_1E020(a1, v9, (__int64 *)&v14);
    if ( v10 == 5 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x8Du, (__int64)&unk_4DCE8);
      v11 = sub_19B54(&v14);
      v2 = v11;
      if ( v11 )
      {
        v7 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 )
          return v2;
        if ( (*((_BYTE *)off_5F148 + 300) & 8) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
          goto LABEL_46;
        v8 = 142;
LABEL_22:
        v12 = v11;
LABEL_44:
        sub_1102C((__int64)v7[35], v8, (__int64)&unk_4DCE8, v12);
        goto LABEL_45;
      }
      *v14 = v9;
      *((_DWORD *)v14 + 2) = v5;
      *((_DWORD *)v14 + 3) = 0;
      *((_DWORD *)v14 + 4) = 0;
      v11 = sub_1DD60(a1, v14);
      v2 = v11;
      if ( v11 )
      {
        v7 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 )
          return v2;
        if ( (*((_BYTE *)off_5F148 + 300) & 8) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
          goto LABEL_46;
        v8 = 143;
        goto LABEL_22;
      }
    }
    else
    {
      if ( v10 )
      {
        v7 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 )
        {
          if ( (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
          {
            v8 = 145;
            goto LABEL_43;
          }
LABEL_46:
          if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 300) & 0x10) != 0 && *((_BYTE *)v7 + 297) >= 5u )
            sub_1102C((__int64)v7[35], 0x92u, (__int64)&unk_4DCE8, v2);
        }
        return v2;
      }
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x90u, (__int64)&unk_4DCE8);
    }
    if ( (unsigned int)sub_3ED70(a2, 45056, &v15) == 5 )
    {
      ++*((_DWORD *)v14 + 4);
    }
    else if ( *(_DWORD *)(v15 + 4) != 45057 )
    {
      if ( *(_DWORD *)(v15 + 4) == 45058 )
        ++*((_DWORD *)v14 + 4);
      goto LABEL_45;
    }
    ++*((_DWORD *)v14 + 3);
LABEL_45:
    v7 = (void **)off_5F148;
    goto LABEL_46;
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 35), 0x8Bu, (__int64)&unk_4DCE8, a1, a2);
  return 4i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001ABC4) ----------------------------------------------------
__int64 __fastcall sub_1ABC4(__int64 a1)
{
  void **v2; // rcx
  unsigned int v4; // ebx
  wchar_t *v5; // rbx
  int v6; // eax
  char v7; // [rsp+30h] [rbp+8h] BYREF
  _QWORD *v8; // [rsp+38h] [rbp+10h] BYREF
  __int64 v9; // [rsp+40h] [rbp+18h] BYREF

  v8 = 0i64;
  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x96u, (__int64)&unk_4DCE8);
    v2 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 300) & 0x10) != 0 && *((_BYTE *)v2 + 297) >= 5u )
      sub_17984((__int64)v2[35], 0x97u, (__int64)&unk_4DCE8, 0i64);
    return 4i64;
  }
  v4 = sub_3ED70(a1, 1125, &v9);
  if ( !v4 )
  {
    if ( *(_DWORD *)v9 == 7 )
    {
      v4 = sub_242E8(*(wchar_t **)(v9 + 4), &v7);
    }
    else
    {
      if ( *(_DWORD *)v9 != 10 )
      {
LABEL_25:
        v4 = sub_1E76C();
        goto LABEL_26;
      }
      v4 = sub_439A0(*(_QWORD *)(v9 + 4), (__int64)&v8);
      while ( !sub_43C74(v8) )
      {
        v5 = *(wchar_t **)(sub_43E74((__int64)v8) + 4);
        sub_43D50((__int64)v8);
        v6 = sub_242E8(v5, &v7);
        v4 = v6;
        if ( v6 )
        {
          if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
            sub_1102C(*((_QWORD *)off_5F148 + 35), 0x98u, (__int64)&unk_4DCE8, v6);
          break;
        }
      }
      sub_43B64((__int64 *)&v8);
    }
    if ( v4 )
      goto LABEL_26;
    goto LABEL_25;
  }
LABEL_26:
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x99u, (__int64)&unk_4DCE8, v4);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001AD88) ----------------------------------------------------
__int64 __fastcall sub_1AD88(__int64 a1, int a2)
{
  int v4; // edi
  void **v5; // r10
  const wchar_t *v6; // rax
  __int64 v7; // r10
  unsigned int v9; // ebx
  const wchar_t *v10; // rax
  __int64 v11; // r10
  void **v12; // r10
  const wchar_t *v13; // rax
  __int64 v14; // r10
  const wchar_t *v15; // rax
  __int64 v16; // r10
  _QWORD *v17; // [rsp+40h] [rbp+8h] BYREF
  _DWORD *v18; // [rsp+50h] [rbp+18h] BYREF

  v18 = 0i64;
  v17 = 0i64;
  v4 = 1084;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    v6 = sub_36CB0(a2);
    sub_17860(*(_QWORD *)(v7 + 280), 0x9Au, (__int64)&unk_4DCE8, v6);
    v5 = (void **)off_5F148;
  }
  if ( a1 )
  {
    v9 = sub_3ED70(a1, 1084, &v18);
    if ( !v9 )
    {
      v9 = 5;
      if ( *v18 == 8 )
      {
        v4 = v18[1];
        if ( v4 == a2 )
        {
          v9 = 0;
          goto LABEL_32;
        }
        v12 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 )
          return v9;
        if ( (*((_BYTE *)off_5F148 + 300) & 0x10) == 0 || *((_BYTE *)off_5F148 + 297) < 5u )
          goto LABEL_37;
        v13 = sub_36CB0(v4);
        sub_17860(*(_QWORD *)(v14 + 280), 0x9Du, (__int64)&unk_4DCE8, v13);
      }
      else
      {
        if ( *v18 != 10 )
          goto LABEL_36;
        sub_439A0(*(_QWORD *)(v18 + 1), (__int64)&v17);
        while ( !sub_43C74(v17) )
        {
          v4 = *(_DWORD *)(sub_43E74((__int64)v17) + 4);
          if ( v4 == a2 )
          {
            v9 = 0;
            break;
          }
          if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
          {
            v10 = sub_36CB0(v4);
            sub_17860(*(_QWORD *)(v11 + 280), 0x9Cu, (__int64)&unk_4DCE8, v10);
          }
          sub_43D50((__int64)v17);
        }
        sub_43B64((__int64 *)&v17);
      }
      if ( !v9 )
      {
LABEL_32:
        v12 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 )
        {
          if ( (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 4u )
          {
            v15 = sub_36CB0(v4);
            sub_17860(*(_QWORD *)(v16 + 280), 0x9Eu, (__int64)&unk_4DCE8, v15);
            goto LABEL_36;
          }
LABEL_37:
          if ( v12 != &off_5F148 && (*((_BYTE *)v12 + 300) & 0x10) != 0 && *((_BYTE *)v12 + 297) >= 5u )
            sub_1102C((__int64)v12[35], 0x9Fu, (__int64)&unk_4DCE8, v9);
        }
        return v9;
      }
    }
LABEL_36:
    v12 = (void **)off_5F148;
    goto LABEL_37;
  }
  if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 300) & 0x10) != 0 && *((_BYTE *)v5 + 297) >= 2u )
    sub_17984((__int64)v5[35], 0x9Bu, (__int64)&unk_4DCE8, 0i64);
  return 4i64;
}
// 1ADE5: variable 'v7' is possibly undefined
// 1AEBC: variable 'v11' is possibly undefined
// 1AF30: variable 'v14' is possibly undefined
// 1AF72: variable 'v16' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000001AFDC) ----------------------------------------------------
__int64 __fastcall sub_1AFDC(__int64 a1, __int64 a2)
{
  void **v4; // rcx
  int v5; // eax
  unsigned int v6; // ebx
  void **v7; // rcx
  unsigned __int16 v8; // dx
  bool v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+70h] [rbp+18h] BYREF
  char v12; // [rsp+78h] [rbp+20h] BYREF

  v12 = 0;
  v10 = 0;
  v11 = 0;
  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xA0u, (__int64)&unk_4DCE8);
    v4 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    v5 = sub_3F278(a2, &v10);
    v6 = v5;
    if ( v5 )
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 )
      {
        if ( (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
        {
          v8 = 162;
LABEL_44:
          sub_1102C((__int64)v7[35], v8, (__int64)&unk_4DCE8, v5);
          goto LABEL_45;
        }
        goto LABEL_46;
      }
    }
    else if ( v10 )
    {
      v5 = sub_42D48(*(int **)(a1 + 32), a2, sub_3F3B8);
      v6 = v5;
      if ( v5 )
      {
        v7 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 )
        {
          if ( (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
          {
            v8 = 164;
            goto LABEL_44;
          }
LABEL_46:
          if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 300) & 0x10) != 0 && *((_BYTE *)v7 + 297) >= 5u )
            sub_1102C((__int64)v7[35], 0xABu, (__int64)&unk_4DCE8, v6);
          return v6;
        }
      }
      else
      {
        v5 = sub_3F008(a2, &v11);
        v6 = v5;
        if ( v5 )
        {
          v7 = (void **)off_5F148;
          if ( off_5F148 != &off_5F148 )
          {
            if ( (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
            {
              v8 = 165;
              goto LABEL_44;
            }
            goto LABEL_46;
          }
        }
        else
        {
          v5 = sub_3F130(a2, &v12);
          v6 = v5;
          if ( v5 )
          {
            v7 = (void **)off_5F148;
            if ( off_5F148 != &off_5F148 )
            {
              if ( (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
              {
                v8 = 166;
                goto LABEL_44;
              }
              goto LABEL_46;
            }
          }
          else if ( v11 && (v5 = sub_1ABC4(a2), (v6 = v5) != 0) )
          {
            v7 = (void **)off_5F148;
            if ( off_5F148 != &off_5F148 )
            {
              if ( (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
              {
                v8 = 167;
                goto LABEL_44;
              }
              goto LABEL_46;
            }
          }
          else
          {
            if ( v12 )
              goto LABEL_45;
            v5 = sub_1A8A4(a1, a2);
            v6 = v5;
            if ( !v5 )
              goto LABEL_45;
            v7 = (void **)off_5F148;
            if ( off_5F148 != &off_5F148 )
            {
              if ( (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
              {
                v8 = 170;
                goto LABEL_44;
              }
              goto LABEL_46;
            }
          }
        }
      }
    }
    else
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 )
      {
        if ( (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
        {
          sub_11008(*((_QWORD *)off_5F148 + 35), 0xA3u, (__int64)&unk_4DCE8);
LABEL_45:
          v7 = (void **)off_5F148;
          goto LABEL_46;
        }
        goto LABEL_46;
      }
    }
    return v6;
  }
  if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 300) & 0x10) != 0 && *((_BYTE *)v4 + 297) >= 5u )
    sub_143A4((__int64)v4[35], 0xA1u, (__int64)&unk_4DCE8, a1, a2);
  return 4i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001B2D0) ----------------------------------------------------
__int64 sub_1B2D0()
{
  unsigned __int8 v0; // di
  unsigned int v1; // eax
  void **v2; // r10
  unsigned int v3; // ebx
  int i; // ebp
  int j; // esi
  char v7[8]; // [rsp+20h] [rbp-48h] BYREF
  char v8[32]; // [rsp+28h] [rbp-40h] BYREF

  v7[0] = 0;
  v0 = 0;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xB0u, (__int64)&unk_4DCE8);
  v1 = sub_24920((__int64)v8, v7);
  v2 = (void **)off_5F148;
  v3 = v1;
  while ( 1 )
  {
    for ( i = 1; i < 12; i = sub_1EB00(i) )
    {
      for ( j = 0; j < 96; j = sub_1EB84(j) )
      {
        if ( !v3 )
        {
          if ( v2 != &off_5F148 )
          {
            if ( (*((_BYTE *)v2 + 300) & 0x10) != 0 && *((_BYTE *)v2 + 297) >= 5u )
            {
              sub_11008((__int64)v2[35], 0xACu, (__int64)&unk_4DCE8);
              v2 = (void **)off_5F148;
            }
            if ( v2 != &off_5F148 )
            {
              if ( (*((_BYTE *)v2 + 300) & 0x10) != 0 && *((_BYTE *)v2 + 297) >= 5u )
              {
                sub_11008((__int64)v2[35], 0xACu, (__int64)&unk_4DCE8);
                v2 = (void **)off_5F148;
              }
              if ( v2 != &off_5F148 )
              {
                if ( (*((_BYTE *)v2 + 300) & 0x10) != 0 && *((_BYTE *)v2 + 297) >= 5u )
                {
                  sub_11008((__int64)v2[35], 0xACu, (__int64)&unk_4DCE8);
                  v2 = (void **)off_5F148;
                }
                if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 300) & 0x10) != 0 && *((_BYTE *)v2 + 297) >= 5u )
                  sub_11008((__int64)v2[35], 0xACu, (__int64)&unk_4DCE8);
              }
            }
          }
          v3 = 0;
        }
      }
    }
    if ( v0 >= (unsigned int)v7[0] )
      break;
    ++v0;
  }
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 300) & 0x10) != 0 && *((_BYTE *)v2 + 297) >= 5u )
    sub_1102C((__int64)v2[35], 0xB5u, (__int64)&unk_4DCE8, v3);
  return v3;
}
// 1B369: variable 'v2' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000001B4D4) ----------------------------------------------------
__int64 __fastcall sub_1B4D4(__int64 a1, __int64 a2)
{
  void **v4; // rcx
  unsigned int v5; // eax
  unsigned int v6; // ebx
  void **v7; // rcx
  unsigned __int16 v8; // dx
  int v9; // er9
  unsigned __int64 v10; // rbp
  unsigned int v11; // eax
  __int64 v12; // r8
  __int64 v14; // [rsp+60h] [rbp+8h] BYREF
  __int64 v15; // [rsp+70h] [rbp+18h] BYREF

  v14 = 0i64;
  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xB6u, (__int64)&unk_4DCE8);
    v4 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    v5 = sub_3ED70(a2, 3, &v15);
    v6 = v5;
    if ( v5 )
    {
      if ( v5 == 5 )
        v6 = sub_3ED70(a2, 5, &v15);
      if ( v6 && v6 != 5 )
      {
        v7 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 )
        {
          if ( (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
          {
            v8 = 184;
            v9 = v6;
LABEL_47:
            sub_1102C((__int64)v7[35], v8, (__int64)&unk_4DCE8, v9);
            goto LABEL_48;
          }
LABEL_49:
          if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 300) & 0x10) != 0 && *((_BYTE *)v7 + 297) >= 5u )
            sub_1102C((__int64)v7[35], 0xBDu, (__int64)&unk_4DCE8, v6);
        }
        return v6;
      }
    }
    v10 = *(_QWORD *)(v15 + 4);
    v11 = sub_1E020(a1, v10, &v14);
    v6 = v11;
    if ( v11 )
    {
      if ( v11 != 5 )
      {
        v7 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 )
          return v6;
        if ( (*((_BYTE *)off_5F148 + 300) & 8) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
          goto LABEL_49;
        v8 = 185;
LABEL_46:
        v9 = v11;
        goto LABEL_47;
      }
      v6 = 0;
LABEL_48:
      v7 = (void **)off_5F148;
      goto LABEL_49;
    }
    v11 = sub_3ED70(a2, 45056, &v15);
    v6 = v11;
    if ( v11 )
    {
      if ( v11 != 5 )
      {
        v7 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 )
          return v6;
        if ( (*((_BYTE *)off_5F148 + 300) & 8) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
          goto LABEL_49;
        v8 = 186;
        goto LABEL_46;
      }
      --*(_DWORD *)(v14 + 16);
    }
    else if ( *(_DWORD *)(v15 + 4) != 45057 )
    {
      if ( *(_DWORD *)(v15 + 4) == 45058 )
        --*(_DWORD *)(v14 + 16);
      goto LABEL_34;
    }
    --*(_DWORD *)(v14 + 12);
LABEL_34:
    if ( *(_DWORD *)(v14 + 12) || *(_DWORD *)(v14 + 16) )
      goto LABEL_48;
    v11 = sub_1DEC4(a1, v10, v12);
    v6 = v11;
    if ( v11 )
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v6;
      if ( (*((_BYTE *)off_5F148 + 300) & 8) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
        goto LABEL_49;
      v8 = 187;
      goto LABEL_46;
    }
    v11 = sub_1B2D0();
    v6 = v11;
    if ( v11 )
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v6;
      if ( (*((_BYTE *)off_5F148 + 300) & 8) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
        goto LABEL_49;
      v8 = 188;
      goto LABEL_46;
    }
    goto LABEL_48;
  }
  if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 300) & 0x10) != 0 && *((_BYTE *)v4 + 297) >= 2u )
    sub_143A4((__int64)v4[35], 0xB7u, (__int64)&unk_4DCE8, a1, a2);
  return 4i64;
}
// 1B6C0: variable 'v12' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000001B7C4) ----------------------------------------------------
__int64 __fastcall sub_1B7C4(__int64 a1, __int64 a2)
{
  void **v3; // rcx
  __int64 result; // rax
  __int64 v5; // rsi
  void **v6; // r10
  int v7; // eax
  int i; // edi
  int j; // ebx
  int v10; // [rsp+58h] [rbp+10h] BYREF
  ULONG_PTR v11; // [rsp+60h] [rbp+18h] BYREF

  v10 = 0;
  v11 = 0i64;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xBEu, (__int64)&unk_4DCE8);
    v3 = (void **)off_5F148;
  }
  if ( a2 )
  {
    v5 = sub_4688C(*(_QWORD *)(a2 + 8), &v11, &v10);
    if ( !v5 )
    {
      v6 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 300) & 0x10) == 0 || *((_BYTE *)off_5F148 + 297) < 5u )
        goto LABEL_17;
      v7 = sub_473B0(v10);
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0xC0u, (__int64)&unk_4DCE8, v7);
    }
    while ( 1 )
    {
      v6 = (void **)off_5F148;
LABEL_17:
      for ( i = 1; i < 12; i = sub_1EB00(i) )
      {
        for ( j = 0; j < 96; j = sub_1EB84(j) )
        {
          if ( v6 != &off_5F148 )
          {
            if ( (*((_BYTE *)v6 + 300) & 0x10) != 0 && *((_BYTE *)v6 + 297) >= 5u )
            {
              sub_11008((__int64)v6[35], 0xACu, (__int64)&unk_4DCE8);
              v6 = (void **)off_5F148;
            }
            if ( v6 != &off_5F148 )
            {
              if ( (*((_BYTE *)v6 + 300) & 0x10) != 0 && *((_BYTE *)v6 + 297) >= 5u )
              {
                sub_11008((__int64)v6[35], 0xACu, (__int64)&unk_4DCE8);
                v6 = (void **)off_5F148;
              }
              if ( v6 != &off_5F148 )
              {
                if ( (*((_BYTE *)v6 + 300) & 0x10) != 0 && *((_BYTE *)v6 + 297) >= 5u )
                {
                  sub_11008((__int64)v6[35], 0xACu, (__int64)&unk_4DCE8);
                  v6 = (void **)off_5F148;
                }
                if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 300) & 0x10) != 0 && *((_BYTE *)v6 + 297) >= 5u )
                  sub_11008((__int64)v6[35], 0xACu, (__int64)&unk_4DCE8);
              }
            }
          }
        }
      }
      if ( !v5 )
        break;
      v5 = sub_46A58(*(_QWORD *)(a2 + 8), &v11, 0i64, &v10);
    }
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 300) & 0x10) != 0 && *((_BYTE *)v6 + 297) >= 5u )
      sub_1102C((__int64)v6[35], 0xC5u, (__int64)&unk_4DCE8, 0);
    result = 0i64;
  }
  else
  {
    if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 300) & 0x10) != 0 && *((_BYTE *)v3 + 297) >= 2u )
      sub_11008((__int64)v3[35], 0xBFu, (__int64)&unk_4DCE8);
    result = 4i64;
  }
  return result;
}
// 1B8D6: variable 'v6' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000001BA3C) ----------------------------------------------------
__int64 __fastcall sub_1BA3C(__int64 a1, __int64 a2)
{
  void **v4; // rcx
  unsigned int v6; // ebx
  wchar_t *v7; // rbx
  int v8; // eax
  _QWORD *v9; // rcx
  unsigned __int16 v10; // dx
  unsigned __int8 v11; // [rsp+48h] [rbp+10h] BYREF
  _QWORD *v12; // [rsp+50h] [rbp+18h] BYREF
  __int64 v13; // [rsp+58h] [rbp+20h] BYREF

  v12 = 0i64;
  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xC6u, (__int64)&unk_4DCE8);
    v4 = (void **)off_5F148;
  }
  if ( !a2 )
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 300) & 0x10) != 0 && *((_BYTE *)v4 + 297) >= 2u )
      sub_17984((__int64)v4[35], 0xC7u, (__int64)&unk_4DCE8, 0i64);
    return 4i64;
  }
  v6 = sub_3ED70(a2, 1125, &v13);
  if ( !v6 )
  {
    if ( *(_DWORD *)v13 == 7 )
    {
      v6 = sub_247BC(*(wchar_t **)(v13 + 4), (char *)&v11);
      if ( v6 )
        goto LABEL_33;
      v6 = sub_24530(v11, (__int64)sub_1B7C4, a1);
    }
    else
    {
      if ( *(_DWORD *)v13 != 10 )
      {
LABEL_32:
        v6 = sub_1E76C();
        goto LABEL_33;
      }
      v6 = sub_439A0(*(_QWORD *)(v13 + 4), (__int64)&v12);
      while ( 1 )
      {
        if ( sub_43C74(v12) )
          goto LABEL_28;
        v7 = *(wchar_t **)(sub_43E74((__int64)v12) + 4);
        sub_43D50((__int64)v12);
        v8 = sub_247BC(v7, (char *)&v11);
        v6 = v8;
        if ( v8 )
          break;
        v8 = sub_24530(v11, (__int64)sub_1B7C4, a1);
        v6 = v8;
        if ( v8 )
        {
          v9 = off_5F148;
          if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
          {
            v10 = 201;
LABEL_27:
            sub_1102C(v9[35], v10, (__int64)&unk_4DCE8, v8);
            goto LABEL_28;
          }
          goto LABEL_28;
        }
      }
      v9 = off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        v10 = 200;
        goto LABEL_27;
      }
LABEL_28:
      sub_43B64((__int64 *)&v12);
    }
    if ( v6 )
      goto LABEL_33;
    goto LABEL_32;
  }
LABEL_33:
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0xCAu, (__int64)&unk_4DCE8, v6);
  return v6;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001BC58) ----------------------------------------------------
__int64 __fastcall sub_1BC58(__int64 a1, __int64 a2)
{
  void **v4; // rcx
  int v5; // eax
  unsigned int v6; // ebx
  unsigned __int16 v7; // dx
  char v9; // [rsp+50h] [rbp+8h] BYREF
  char v10; // [rsp+60h] [rbp+18h] BYREF

  v9 = 0;
  v10 = 0;
  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xCBu, (__int64)&unk_4DCE8);
    v4 = (void **)off_5F148;
  }
  if ( !a1 || !a2 )
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 300) & 0x10) != 0 && *((_BYTE *)v4 + 297) >= 2u )
    {
      sub_143A4((__int64)v4[35], 0xCCu, (__int64)&unk_4DCE8, a1, a2);
      v4 = (void **)off_5F148;
    }
    v6 = 4;
    goto LABEL_37;
  }
  sub_42F90(*(int **)(a1 + 32), a2, sub_3F594, 0i64, 0);
  v5 = sub_3F130(a2, &v9);
  v6 = v5;
  if ( !v5 )
  {
    v5 = sub_3F008(a2, &v10);
    v6 = v5;
    if ( v5 )
    {
      v4 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v6;
      if ( (*((_BYTE *)off_5F148 + 300) & 0x10) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
        goto LABEL_37;
      v7 = 206;
    }
    else if ( v9 || (v5 = sub_1B4D4(a1, a2), (v6 = v5) == 0) )
    {
      if ( !v10 || (v5 = sub_1BA3C(a1, a2), (v6 = v5) == 0) )
      {
        v6 = 0;
        goto LABEL_13;
      }
      v4 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v6;
      if ( (*((_BYTE *)off_5F148 + 300) & 0x10) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
        goto LABEL_37;
      v7 = 213;
    }
    else
    {
      v4 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v6;
      if ( (*((_BYTE *)off_5F148 + 300) & 0x10) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
        goto LABEL_37;
      v7 = 212;
    }
LABEL_12:
    sub_1102C((__int64)v4[35], v7, (__int64)&unk_4DCE8, v5);
LABEL_13:
    v4 = (void **)off_5F148;
    goto LABEL_37;
  }
  v4 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return v6;
  if ( (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
  {
    v7 = 205;
    goto LABEL_12;
  }
LABEL_37:
  if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 300) & 0x10) != 0 && *((_BYTE *)v4 + 297) >= 5u )
    sub_1102C((__int64)v4[35], 0xD6u, (__int64)&unk_4DCE8, v6);
  return v6;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001BEB4) ----------------------------------------------------
__int64 __fastcall sub_1BEB4(__int64 a1, __int64 a2, _QWORD *a3, int *a4, int *a5)
{
  int *v9; // rsi
  int *v10; // r8
  int v11; // eax
  unsigned int v12; // ebx
  void **v13; // rcx
  unsigned __int16 v14; // dx
  int v15; // eax
  int v16; // ecx
  __int64 v17; // rcx
  int v18; // er9
  int v19; // er8
  __int64 v21; // [rsp+40h] [rbp-38h] BYREF
  int v22; // [rsp+90h] [rbp+18h] BYREF
  int v23; // [rsp+98h] [rbp+20h] BYREF

  v21 = 0i64;
  v22 = 0;
  v23 = 1;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xE0u, (__int64)&unk_4DCE8);
  v9 = a5;
  v10 = a5;
  *a4 = 1;
  *a3 = 0i64;
  v11 = sub_1C1A0(a1, a2, v10, &v21, &v23, &v22);
  v12 = v11;
  if ( !v11 )
  {
    sub_1E830(*v9);
    if ( (unsigned int)dword_5F5E0 > 2 )
      _InterlockedAdd((volatile signed __int32 *)P + 2, 1u);
    v15 = sub_1CC44(a1, v21, a2, a4, *v9, v23, &v22);
    if ( v15 && off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0xE2u, (__int64)&unk_4DCE8, v15);
    v16 = *v9;
    if ( (unsigned int)(*v9 - 2) > 1 )
    {
      if ( (unsigned int)(v16 - 101) > 6 )
      {
        if ( (unsigned int)(v16 - 201) <= 4 )
        {
          if ( *a4 == 1 || *a4 == 3 )
          {
            _InterlockedAdd64(&qword_5F4E8, 1ui64);
          }
          else if ( *(_WORD *)a4 == 4 && _bittest(a4, 0x1Eu) )
          {
            _InterlockedAdd64(&qword_5F4F8, 1ui64);
          }
          else
          {
            _InterlockedAdd64(&qword_5F4F0, 1ui64);
          }
        }
      }
      else if ( *a4 == 1 || *a4 == 3 )
      {
        _InterlockedAdd64(&qword_5F4D0, 1ui64);
      }
      else if ( *(_WORD *)a4 == 4 && _bittest(a4, 0x1Eu) )
      {
        _InterlockedAdd64(&qword_5F4E0, 1ui64);
      }
      else
      {
        _InterlockedAdd64(&qword_5F4D8, 1ui64);
      }
    }
    else if ( *a4 == 1 || *a4 == 3 )
    {
      _InterlockedAdd64(&qword_5F4C0, 1ui64);
    }
    else
    {
      _InterlockedAdd64(&qword_5F4C8, 1ui64);
    }
    v17 = v21;
    v18 = *v9;
    v19 = *a4;
    *a3 = v21;
    v11 = sub_1CFDC(v17, a2, v19, v18);
    v12 = v11;
    if ( !v11 )
      goto LABEL_44;
    v13 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148 )
      return v12;
    if ( (*((_BYTE *)off_5F148 + 300) & 8) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
      goto LABEL_45;
    v14 = 227;
LABEL_43:
    sub_1102C((__int64)v13[35], v14, (__int64)&unk_4DCE8, v11);
LABEL_44:
    v13 = (void **)off_5F148;
    goto LABEL_45;
  }
  v13 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return v12;
  if ( (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
  {
    v14 = 225;
    goto LABEL_43;
  }
LABEL_45:
  if ( v13 != &off_5F148 && (*((_BYTE *)v13 + 300) & 8) != 0 && *((_BYTE *)v13 + 297) >= 5u )
    sub_1102C((__int64)v13[35], 0xE4u, (__int64)&unk_4DCE8, v12);
  return v12;
}
// 5F148: using guessed type void *off_5F148;
// 5F4C0: using guessed type __int64 qword_5F4C0;
// 5F4C8: using guessed type __int64 qword_5F4C8;
// 5F4D0: using guessed type __int64 qword_5F4D0;
// 5F4D8: using guessed type __int64 qword_5F4D8;
// 5F4E0: using guessed type __int64 qword_5F4E0;
// 5F4E8: using guessed type __int64 qword_5F4E8;
// 5F4F0: using guessed type __int64 qword_5F4F0;
// 5F4F8: using guessed type __int64 qword_5F4F8;
// 5F5E0: using guessed type int dword_5F5E0;

//----- (000000000001C1A0) ----------------------------------------------------
__int64 __fastcall sub_1C1A0(__int64 a1, __int64 a2, int *a3, __int64 *a4, int *a5, _DWORD *a6)
{
  unsigned int v10; // edi
  void **v11; // rcx
  int v12; // eax
  int v13; // eax
  unsigned __int16 v14; // dx
  unsigned int v15; // eax
  __int64 v17; // [rsp+20h] [rbp-48h]

  v10 = 0;
  v11 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xE5u, (__int64)&unk_4DCE8);
    v11 = (void **)off_5F148;
  }
  if ( !a1 || !a2 || !a3 || !a4 || !a5 || !a6 )
  {
    if ( v11 != &off_5F148 && (*((_BYTE *)v11 + 300) & 8) != 0 && *((_BYTE *)v11 + 297) >= 2u )
    {
      sub_17AB4((__int64)v11[35], 230i64, (__int64)&unk_4DCE8, a1, a2, a3, a4, a5, a6);
      v11 = (void **)off_5F148;
    }
    v10 = 4;
    goto LABEL_80;
  }
  *a3 = 0;
  *a4 = 0i64;
  *a6 = 0;
  *a5 = 1;
  if ( (unsigned int)sub_2DA90(0x201600Du) )
  {
    if ( !_bittest((const signed __int32 *)(a2 + 152), 8u) )
      goto LABEL_42;
    v12 = sub_1F96C(*(__int64 **)(a1 + 16), *(_QWORD *)(a2 + 88), a3, a6, a5, a4);
    v10 = v12;
    if ( v12 )
    {
      if ( v12 == 5 )
      {
        v11 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
        {
          sub_17984(*((_QWORD *)off_5F148 + 35), 0xE9u, (__int64)&unk_4DCE8, *(_QWORD *)(a2 + 88));
          goto LABEL_42;
        }
      }
      else
      {
        v11 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
        {
          sub_1102C(*((_QWORD *)off_5F148 + 35), 0xEAu, (__int64)&unk_4DCE8, v12);
          goto LABEL_42;
        }
      }
    }
    else
    {
      v11 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 4u )
      {
        sub_17984(*((_QWORD *)off_5F148 + 35), 0xEBu, (__int64)&unk_4DCE8, *(_QWORD *)(a2 + 88));
        v11 = (void **)off_5F148;
      }
      if ( *a3 > 200 && *a3 < 206 )
      {
        *a3 = 3;
LABEL_38:
        v11 = (void **)off_5F148;
        goto LABEL_80;
      }
      if ( *a3 > 100 && *a3 < 108 )
      {
        *a3 = 2;
        goto LABEL_42;
      }
    }
  }
  else
  {
    v11 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 )
    {
      if ( (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0xE7u, (__int64)&unk_4DCE8);
        v11 = (void **)off_5F148;
      }
      if ( v11 != &off_5F148 && _bittest((const signed __int32 *)v11 + 75, 0xEu) && *((_BYTE *)v11 + 297) >= 5u )
      {
        sub_11008((__int64)v11[35], 0xE8u, (__int64)&unk_4DCE8);
LABEL_42:
        v11 = (void **)off_5F148;
        goto LABEL_43;
      }
    }
  }
LABEL_43:
  if ( *a3 > 1 && *a3 < 4 )
    goto LABEL_80;
  v13 = sub_1C738(a1, a2, a3, a4, a5);
  v10 = v13;
  if ( !v13 )
  {
    if ( !*a4 )
    {
      if ( *a3 == 302 )
      {
        v11 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 )
          return v10;
        if ( !_bittest((const signed __int32 *)off_5F148 + 75, 8u) || *((_BYTE *)off_5F148 + 297) < 4u )
          goto LABEL_80;
        v14 = 237;
LABEL_56:
        sub_11008((__int64)v11[35], v14, (__int64)&unk_4DCE8);
        goto LABEL_38;
      }
      if ( *a5 == 1 )
      {
        v11 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 )
          return v10;
        if ( !_bittest((const signed __int32 *)off_5F148 + 75, 8u) || *((_BYTE *)off_5F148 + 297) < 5u )
          goto LABEL_80;
        v14 = 238;
        goto LABEL_56;
      }
    }
    if ( !_bittest((const signed __int32 *)(a2 + 152), 8u)
      || !*(_QWORD *)(a2 + 88)
      || !sub_1FE44(*a3, *a5, *a4, (_WORD *)(a2 + 114)) )
    {
      goto LABEL_38;
    }
    v15 = sub_1F420(*(ULONG_PTR **)(a1 + 16), *(_QWORD *)(a2 + 88), *a3, *a5, (_WORD *)(a2 + 114), *a4);
    v10 = v15;
    if ( v15 )
    {
      v11 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v10;
      if ( !_bittest((const signed __int32 *)off_5F148 + 75, 8u) || *((_BYTE *)off_5F148 + 297) < 3u )
        goto LABEL_80;
      LODWORD(v17) = v15;
      sub_17814(*((_QWORD *)off_5F148 + 35), 0xEFu, (__int64)&unk_4DCE8, *(_QWORD *)(a2 + 88), v17);
    }
    else
    {
      v11 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v10;
      if ( !_bittest((const signed __int32 *)off_5F148 + 75, 8u) || *((_BYTE *)off_5F148 + 297) < 4u )
        goto LABEL_80;
      sub_17984(*((_QWORD *)off_5F148 + 35), 0xF0u, (__int64)&unk_4DCE8, *(_QWORD *)(a2 + 88));
    }
    v11 = (void **)off_5F148;
    goto LABEL_80;
  }
  v11 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return v10;
  if ( _bittest((const signed __int32 *)off_5F148 + 75, 8u) && *((_BYTE *)off_5F148 + 297) >= 2u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0xECu, (__int64)&unk_4DCE8, v13);
    goto LABEL_38;
  }
LABEL_80:
  if ( v11 != &off_5F148 && _bittest((const signed __int32 *)v11 + 75, 8u) && *((_BYTE *)v11 + 297) >= 5u )
    sub_1102C((__int64)v11[35], 0xF1u, (__int64)&unk_4DCE8, v10);
  return v10;
}
// 1C620: variable 'v17' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000001C738) ----------------------------------------------------
__int64 __fastcall sub_1C738(__int64 a1, __int64 a2, int *a3, __int64 *a4, int *a5)
{
  char v5; // di
  __int64 v8; // r9
  void **v10; // r10
  int *v11; // rbp
  unsigned __int64 v12; // r13
  unsigned __int64 v13; // r12
  unsigned int v14; // er14
  int v15; // eax
  __int64 v16; // rcx
  int v17; // edi
  unsigned __int16 v18; // dx
  int v19; // eax
  bool v20; // zf
  const char *v21; // rax
  __int64 v22; // r10
  const char *v23; // r8
  __int64 v25[9]; // [rsp+40h] [rbp-48h] BYREF
  __int64 v26; // [rsp+90h] [rbp+8h] BYREF
  __int64 v27; // [rsp+98h] [rbp+10h]

  v27 = a2;
  v5 = 0;
  v8 = a2;
  v25[0] = 0i64;
  v26 = 0i64;
  v10 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 8u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xF2u, (__int64)&unk_4DCE8);
    v10 = (void **)off_5F148;
    v8 = v27;
  }
  v11 = a5;
  if ( !a1 || !v8 || !a3 || !a4 || !a5 )
  {
    if ( v10 != &off_5F148 && _bittest((const signed __int32 *)v10 + 75, 8u) && *((_BYTE *)v10 + 297) >= 2u )
    {
      sub_17A34((__int64)v10[35], 243i64, (__int64)&unk_4DCE8, a1, v8, a3, a4, a5, v25[0]);
      v10 = (void **)off_5F148;
    }
    v14 = 4;
    goto LABEL_75;
  }
  *a3 = 0;
  *a4 = 0i64;
  *v11 = 1;
  if ( v8 == -96 )
    v12 = -1i64;
  else
    v12 = *(_QWORD *)(v8 + 96);
  if ( v8 == -96 )
    v13 = -1i64;
  else
    v13 = *(_QWORD *)(v8 + 104);
  if ( v12 != -1i64 || v13 != -1i64 )
    v5 = 1;
  v14 = sub_198E8(*(_QWORD *)(a1 + 32), v8, a4);
  if ( !v14 )
    *a3 = 102 - (v5 != 0);
  sub_42938(v25, 0i64);
  if ( *a4 )
    goto LABEL_28;
  v14 = 0;
  if ( (unsigned int)sub_2DA90(0x201601Au) )
  {
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 8u)
      && *((_BYTE *)off_5F148 + 297) >= 5u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0xF4u, (__int64)&unk_4DCE8);
    }
    *a3 = 302;
    goto LABEL_28;
  }
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 8u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xF5u, (__int64)&unk_4DCE8);
  }
  *a3 = 201;
  if ( !v5 )
  {
    *v11 = 2;
    *a3 = 202;
LABEL_28:
    v10 = (void **)off_5F148;
    goto LABEL_75;
  }
  *v11 = 3;
  *a3 = 203;
  v15 = sub_1E020(a1, v13, &v26);
  v16 = v26;
  v17 = v15;
  if ( v26 && *(_DWORD *)(v26 + 8) == 1 )
  {
    v10 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 8u)
      && *((_BYTE *)off_5F148 + 297) >= 5u )
    {
      v18 = 248;
LABEL_51:
      sub_11008((__int64)v10[35], v18, (__int64)&unk_4DCE8);
      v16 = v26;
      v10 = (void **)off_5F148;
      goto LABEL_52;
    }
  }
  else
  {
    v19 = sub_1E020(a1, v12, &v26);
    v16 = v26;
    v17 = v19;
    if ( !v26 || *(_DWORD *)(v26 + 8) != 2 )
    {
      v26 = 0i64;
      v10 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148
        || !_bittest((const signed __int32 *)off_5F148 + 75, 8u)
        || *((_BYTE *)off_5F148 + 297) < 5u )
      {
LABEL_61:
        if ( v17 == 5 )
        {
          if ( v10 == &off_5F148 )
            return v14;
          if ( !_bittest((const signed __int32 *)v10 + 75, 8u) || *((_BYTE *)v10 + 297) < 5u )
            goto LABEL_75;
          sub_11008((__int64)v10[35], 0xFAu, (__int64)&unk_4DCE8);
          goto LABEL_28;
        }
        v14 = v17;
        if ( v10 == &off_5F148 )
          return v14;
        if ( _bittest((const signed __int32 *)v10 + 75, 8u) && *((_BYTE *)v10 + 297) >= 2u )
        {
          sub_1102C((__int64)v10[35], 0xF9u, (__int64)&unk_4DCE8, v17);
          goto LABEL_28;
        }
        goto LABEL_75;
      }
      v18 = 246;
      goto LABEL_51;
    }
    v10 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 8u)
      && *((_BYTE *)off_5F148 + 297) >= 5u )
    {
      v18 = 247;
      goto LABEL_51;
    }
  }
LABEL_52:
  if ( !v16 || v17 )
    goto LABEL_61;
  if ( (*(_BYTE *)(v27 + 149) & 0x60) == 0 )
  {
    v20 = *(_DWORD *)(v16 + 12) == 0;
LABEL_58:
    if ( v20 )
    {
      *v11 = 4;
      *a3 = 204;
    }
    else
    {
      *v11 = 5;
      *a3 = 205;
    }
    goto LABEL_28;
  }
  if ( (*(_BYTE *)(v27 + 149) & 0x60) == 32 )
  {
    v20 = *(_DWORD *)(v16 + 16) == 0;
    goto LABEL_58;
  }
LABEL_75:
  if ( v10 != &off_5F148 )
  {
    if ( _bittest((const signed __int32 *)v10 + 75, 8u) && *((_BYTE *)v10 + 297) >= 5u )
    {
      sub_1E710(*v11);
      v21 = sub_34494(*a3);
      sub_17C08(*(_QWORD *)(v22 + 280), 0xFBu, (__int64)&unk_4DCE8, v21, v23);
      v10 = (void **)off_5F148;
    }
    if ( v10 != &off_5F148 && _bittest((const signed __int32 *)v10 + 75, 8u) && *((_BYTE *)v10 + 297) >= 5u )
      sub_1102C((__int64)v10[35], 0xFCu, (__int64)&unk_4DCE8, v14);
  }
  return v14;
}
// 1CBC0: variable 'v22' is possibly undefined
// 1CBDB: variable 'v23' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000001CC44) ----------------------------------------------------
__int64 __fastcall sub_1CC44(__int64 a1, __int64 a2, __int64 a3, int *a4, int a5, int a6, int *a7)
{
  unsigned int v7; // edi
  int *v12; // rbp
  void **v13; // rcx
  unsigned __int16 v14; // dx
  int v15; // ebx
  int v16; // eax
  __int64 v17; // rsi
  int v18; // eax
  bool v19; // cc
  __int64 v21; // [rsp+88h] [rbp+20h] BYREF

  v7 = 0;
  v21 = 0i64;
  v12 = a7;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 8u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_12818(*((_QWORD *)off_5F148 + 35), 0xFDu, (__int64)&unk_4DCE8, a2, a3, a4, a7);
  }
  *a4 = 1;
  if ( (unsigned __int8)sub_2DA90(0x201600Eu) )
  {
    if ( a2 )
    {
      v13 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 8u)
        && *((_BYTE *)off_5F148 + 297) >= 4u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x102u, (__int64)&unk_4DCE8);
        v13 = (void **)off_5F148;
      }
      v15 = a5;
      if ( a5 > 1 && a5 < 4 )
        goto LABEL_42;
      sub_439A0(*(_QWORD *)(a2 + 84), (__int64)&v21);
      v17 = sub_43E74(v21);
      sub_43B64(&v21);
      if ( !v17 )
      {
        v13 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 )
          return v7;
        if ( !_bittest((const signed __int32 *)off_5F148 + 75, 8u) || *((_BYTE *)off_5F148 + 297) < 2u )
          goto LABEL_52;
        v14 = 259;
        goto LABEL_10;
      }
      sub_41FFC(v17, v12);
    }
    else
    {
      v15 = a5;
      if ( a5 == 302 )
      {
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 75, 8u)
          && *((_BYTE *)off_5F148 + 297) >= 4u )
        {
          sub_11008(*((_QWORD *)off_5F148 + 35), a5 - 47, (__int64)&unk_4DCE8);
        }
        *v12 = 770;
      }
      else if ( a5 <= 1 || a5 >= 4 )
      {
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 75, 8u)
          && *((_BYTE *)off_5F148 + 297) >= 5u )
        {
          sub_11008(*((_QWORD *)off_5F148 + 35), 0x100u, (__int64)&unk_4DCE8);
        }
        v16 = sub_1D780(a6, (_WORD *)(a3 + 114), v12);
        v7 = v16;
        if ( v16 )
        {
          v13 = (void **)off_5F148;
          if ( off_5F148 == &off_5F148 )
            return v7;
          if ( !_bittest((const signed __int32 *)off_5F148 + 75, 8u) || *((_BYTE *)off_5F148 + 297) < 2u )
            goto LABEL_52;
          sub_1102C(*((_QWORD *)off_5F148 + 35), 0x101u, (__int64)&unk_4DCE8, v16);
          goto LABEL_51;
        }
      }
    }
    v13 = (void **)off_5F148;
LABEL_42:
    if ( *v12 == 770 )
    {
      v19 = (unsigned int)dword_5F5E0 <= 3;
      *a4 = 4;
      if ( !v19 )
        _InterlockedAdd((volatile signed __int32 *)P + 3, 1u);
      goto LABEL_51;
    }
    if ( *v12 == 780 )
    {
      v18 = sub_22AB4(*(PERESOURCE *)(a1 + 24), a3, a4, v15);
      v7 = v18;
      if ( v18 )
      {
        v13 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 )
          return v7;
        if ( !_bittest((const signed __int32 *)off_5F148 + 75, 8u) || *((_BYTE *)off_5F148 + 297) < 2u )
          goto LABEL_52;
        sub_1102C(*((_QWORD *)off_5F148 + 35), 0x104u, (__int64)&unk_4DCE8, v18);
      }
      goto LABEL_51;
    }
    goto LABEL_52;
  }
  v13 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return v7;
  if ( _bittest((const signed __int32 *)off_5F148 + 75, 8u) && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    v14 = 254;
LABEL_10:
    sub_11008((__int64)v13[35], v14, (__int64)&unk_4DCE8);
LABEL_51:
    v13 = (void **)off_5F148;
  }
LABEL_52:
  if ( v13 != &off_5F148 && _bittest((const signed __int32 *)v13 + 75, 8u) && *((_BYTE *)v13 + 297) >= 5u )
    sub_1102C((__int64)v13[35], 0x105u, (__int64)&unk_4DCE8, v7);
  return v7;
}
// 5F148: using guessed type void *off_5F148;
// 5F5E0: using guessed type int dword_5F5E0;

//----- (000000000001CFDC) ----------------------------------------------------
__int64 __fastcall sub_1CFDC(__int64 a1, __int64 a2, int a3, int a4)
{
  unsigned int v4; // ebp
  __int16 v6; // r13
  __int64 v9; // rdi
  unsigned int v10; // er15
  void **v11; // rcx
  unsigned __int16 v12; // dx
  char v13; // al
  const wchar_t *v14; // r12
  const wchar_t *v15; // r9
  __int64 v16; // rbx
  _WORD *v17; // rdi
  __int64 v18; // rcx
  bool v19; // zf
  _QWORD *v20; // rcx
  unsigned __int16 v21; // dx
  unsigned int v22; // er13
  PVOID v23; // rax
  int v24; // ecx
  const wchar_t *v25; // r12
  const wchar_t *v26; // rbp
  int v27; // eax
  int v28; // eax
  unsigned int v30; // [rsp+40h] [rbp-58h] BYREF
  _QWORD *v31; // [rsp+48h] [rbp-50h] BYREF
  __int64 v32; // [rsp+50h] [rbp-48h] BYREF
  __int64 v33; // [rsp+58h] [rbp-40h] BYREF
  STRSAFE_PCNZWCH pszSrc; // [rsp+60h] [rbp-38h]

  v4 = 0;
  v6 = a3;
  pszSrc = 0i64;
  v9 = 0i64;
  v31 = 0i64;
  v30 = 0;
  v10 = 0;
  v32 = 0i64;
  v33 = 0i64;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 9u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_179C0(*((_QWORD *)off_5F148 + 35), 262i64, (__int64)&unk_4DCE8, a1, a2, a3, a4);
  }
  if ( !(unsigned __int8)sub_2DA90(0x2016005u) )
  {
    v11 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 9u)
      && *((_BYTE *)off_5F148 + 297) >= 5u )
    {
      v12 = 263;
LABEL_10:
      sub_11008((__int64)v11[35], v12, (__int64)&unk_4DCE8);
LABEL_104:
      v11 = (void **)off_5F148;
      goto LABEL_105;
    }
    goto LABEL_105;
  }
  if ( (unsigned int)(a4 - 2) > 1 || (unsigned __int8)sub_2DA90(0x2016014u) )
  {
    if ( a4 == 302 )
    {
      v11 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 9u)
        && *((_BYTE *)off_5F148 + 297) >= 5u )
      {
        v12 = 265;
        goto LABEL_10;
      }
      goto LABEL_105;
    }
    if ( !a1 && !(unsigned __int8)sub_2DA90(0x2016015u) )
    {
      v11 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 9u)
        && *((_BYTE *)off_5F148 + 297) >= 5u )
      {
        v12 = 266;
        goto LABEL_10;
      }
      goto LABEL_105;
    }
    v13 = sub_2DA90(0x2016016u);
    if ( (v6 == 1 || v6 == 3) && (v13 & 1) == 0 )
    {
      v11 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 9u)
        && *((_BYTE *)off_5F148 + 297) >= 5u )
      {
        v12 = 267;
        goto LABEL_10;
      }
      goto LABEL_105;
    }
    if ( (v6 == 2 || v6 == 4) && (v13 & 2) == 0 )
    {
      v11 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 9u)
        && *((_BYTE *)off_5F148 + 297) >= 5u )
      {
        v12 = 268;
        goto LABEL_10;
      }
      goto LABEL_105;
    }
    if ( a1 )
    {
      v4 = sub_3ED70(a1, 1066, &v32);
      if ( v4 )
      {
        v11 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 75, 9u)
          && *((_BYTE *)off_5F148 + 297) >= 2u )
        {
          v12 = 269;
          goto LABEL_10;
        }
        goto LABEL_105;
      }
      v14 = *(const wchar_t **)(v32 + 4);
      pszSrc = v14;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 9u)
        && *((_BYTE *)off_5F148 + 297) >= 5u )
      {
        sub_17860(*((_QWORD *)off_5F148 + 35), 0x10Eu, (__int64)&unk_4DCE8, v14);
      }
      if ( !(unsigned int)sub_3ED70(a1, 1124, &v33)
        && off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 9u)
        && *((_BYTE *)off_5F148 + 297) >= 5u )
      {
        v15 = L"FALSE";
        if ( *(_BYTE *)(v33 + 4) )
          v15 = L"TRUE";
        sub_17860(*((_QWORD *)off_5F148 + 35), 0x10Fu, (__int64)&unk_4DCE8, v15);
      }
    }
    v16 = -1i64;
    if ( (*(_BYTE *)(a2 + 152) & 1) != 0 )
    {
      v4 = sub_33F40(*(_QWORD *)(a2 + 16), &v31, &v30);
      if ( v4 )
      {
        v20 = off_5F148;
        if ( off_5F148 == &off_5F148
          || !_bittest((const signed __int32 *)off_5F148 + 75, 9u)
          || *((_BYTE *)off_5F148 + 297) < 2u )
        {
          goto LABEL_75;
        }
        v21 = 273;
      }
      else
      {
        if ( v31[3] )
        {
          v17 = (_WORD *)v31[3];
          v18 = -1i64;
          do
          {
            if ( !v18 )
              break;
            v19 = *v17++ == 0;
            --v18;
          }
          while ( !v19 );
          v10 = 2 * ~(_DWORD)v18;
          goto LABEL_75;
        }
        v20 = off_5F148;
        if ( off_5F148 == &off_5F148
          || !_bittest((const signed __int32 *)off_5F148 + 75, 9u)
          || *((_BYTE *)off_5F148 + 297) < 2u )
        {
          goto LABEL_75;
        }
        v21 = 272;
      }
      sub_17984(v20[35], v21, (__int64)&unk_4DCE8, *(_QWORD *)(a2 + 16));
    }
LABEL_75:
    v22 = v10 + 249;
    v23 = sub_26404(1, v10 + 249, 0x746D7450u);
    v9 = (__int64)v23;
    if ( v23 )
    {
      memset(v23, 0, v22);
      sub_1DAFC(a2, v9);
      if ( (*(_BYTE *)(a2 + 152) & 1) != 0 )
      {
        *(_DWORD *)(v9 + 200) |= 1u;
        v24 = *(_DWORD *)(v9 + 200);
        *(_QWORD *)(v9 + 204) = *(_QWORD *)(a2 + 16);
        if ( v31 )
        {
          if ( v31[3] )
          {
            *(_DWORD *)(v9 + 200) = v24 | 4;
            if ( a2 != -96 )
              v16 = *(_QWORD *)(a2 + 96);
            *(_QWORD *)(v9 + 220) = v16;
            v25 = (const wchar_t *)v31[3];
            if ( (int)unknown_libname_2(v9 + 248, (unsigned __int64)v10 >> 1, 0x7FFFFFFFi64) >= 0 )
              RtlStringCopyWorkerW((NTSTRSAFE_PWSTR)(v9 + 248), (unsigned __int64)v10 >> 1, 0i64, v25, 0x7FFFFFFEui64);
            *(_DWORD *)(v9 + 244) += v10;
            *(_DWORD *)(v9 + 228) = v10;
          }
        }
      }
      if ( (*(_BYTE *)(a2 + 152) & 2) != 0 )
      {
        *(_DWORD *)(v9 + 200) |= 2u;
        *(_QWORD *)(v9 + 212) = *(_QWORD *)(a2 + 24);
      }
      v26 = pszSrc;
      *(_DWORD *)(v9 + 84) = a4;
      if ( v26 && (int)unknown_libname_2(v9 + 88, 37i64, 0x7FFFFFFFi64) >= 0 )
        RtlStringCopyWorkerW((NTSTRSAFE_PWSTR)(v9 + 88), 0x25ui64, 0i64, v26, 0x7FFFFFFEui64);
      *(_DWORD *)(v9 + 196) = a3;
      if ( (int)unknown_libname_2(v9 + 162, 17i64, 0x7FFFFFFFi64) >= 0 )
        RtlStringCopyWorkerW((NTSTRSAFE_PWSTR)(v9 + 162), 0x11ui64, 0i64, (STRSAFE_PCNZWCH)(a2 + 114), 0x7FFFFFFEui64);
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 9u)
        && *((_BYTE *)off_5F148 + 297) >= 4u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x113u, (__int64)&unk_4DCE8);
      }
      v27 = sub_33838(40015i64, (const void *)v9, v22);
      v4 = v27;
      if ( !v27 )
        goto LABEL_104;
      v11 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 9u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_1102C(*((_QWORD *)off_5F148 + 35), 0x114u, (__int64)&unk_4DCE8, v27);
        goto LABEL_104;
      }
    }
    else
    {
      v11 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 9u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_1102C(*((_QWORD *)off_5F148 + 35), 0x112u, (__int64)&unk_4DCE8, 249);
        goto LABEL_104;
      }
    }
    goto LABEL_105;
  }
  v11 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 9u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    v12 = 264;
    goto LABEL_10;
  }
LABEL_105:
  if ( !v31 )
    goto LABEL_112;
  v28 = sub_34384((PVOID *)&v31);
  if ( !v28 )
    goto LABEL_111;
  v11 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 9u)
    && *((_BYTE *)off_5F148 + 297) >= 2u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x115u, (__int64)&unk_4DCE8, v28);
LABEL_111:
    v11 = (void **)off_5F148;
  }
LABEL_112:
  if ( v9 )
  {
    sub_26488((PVOID)v9, 0x746D7450u);
    v11 = (void **)off_5F148;
  }
  if ( v11 != &off_5F148 && _bittest((const signed __int32 *)v11 + 75, 9u) && *((_BYTE *)v11 + 297) >= 5u )
    sub_1102C((__int64)v11[35], 0x116u, (__int64)&unk_4DCE8, v4);
  return v4;
}
// 4C114: using guessed type __int64 __fastcall unknown_libname_2(_QWORD, _QWORD, _QWORD);
// 4C740: using guessed type wchar_t aTrue_1[5];
// 4C750: using guessed type wchar_t aFalse_0[6];
// 5F148: using guessed type void *off_5F148;

//----- (000000000001D780) ----------------------------------------------------
__int64 __fastcall sub_1D780(int a1, _WORD *a2, int *a3)
{
  unsigned int v6; // ebx
  void **v7; // r10
  const char *v8; // rax
  __int64 v9; // r10
  int v10; // edi
  int v11; // er13
  int v12; // er14
  int v13; // eax
  int v14; // edi
  const char *v15; // r9
  bool v16; // zf
  const wchar_t *v17; // rdi
  __int64 v18; // rcx
  int v19; // ebp
  int v20; // ebp
  int v21; // ebp
  unsigned int v22; // ecx
  const wchar_t *v23; // rax
  __int64 v24; // r10

  v6 = 0;
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 300) < 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    v8 = sub_1E710(a1);
    sub_13618(*(_QWORD *)(v9 + 280), 0x117u, (__int64)&unk_4DCE8, v8);
    v7 = (void **)off_5F148;
  }
  if ( !a3 || !a2 )
  {
    if ( v7 != &off_5F148 && *((char *)v7 + 300) < 0 && *((_BYTE *)v7 + 297) >= 2u )
    {
      sub_143A4((__int64)v7[35], 0x118u, (__int64)&unk_4DCE8, a3, a2);
      v7 = (void **)off_5F148;
    }
    goto LABEL_57;
  }
  *a3 = 769;
  if ( !(unsigned __int8)sub_2DA90(0x201601Bu) )
    goto LABEL_34;
  v10 = sub_2DA90(0x2016009u);
  v11 = sub_2DA90(0x201600Au);
  v12 = sub_2DA90(0x201600Bu);
  v13 = sub_2DA90(0x201600Cu);
  if ( v10 != 769 || v11 != 780 || v12 != 780 )
    goto LABEL_14;
  if ( v13 != 770 )
  {
    v14 = 0;
    if ( v13 == 780 )
      goto LABEL_15;
LABEL_14:
    v14 = 1;
    goto LABEL_15;
  }
  v14 = 2;
LABEL_15:
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 300) < 0 && *((_BYTE *)off_5F148 + 297) >= 4u )
  {
    if ( v14 )
    {
      if ( v14 == 1 )
        v15 = "ADMIN_PERMISSIVE";
      else
        v15 = "ADMIN_RESTRICTIVE";
    }
    else
    {
      v15 = "USER";
    }
    sub_17B40(*((_QWORD *)off_5F148 + 35), 281i64, (__int64)&unk_4DCE8, v15, a2);
    v7 = (void **)off_5F148;
  }
  v16 = v14 == 2;
  if ( v14 == 2 )
  {
    v17 = L"WORK";
    v18 = 5i64;
    do
    {
      if ( !v18 )
        break;
      v16 = *a2++ == *v17++;
      --v18;
    }
    while ( v16 );
    if ( v16 )
    {
      if ( (unsigned int)sub_2DA90(0x201601Eu) )
      {
        v7 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 )
          return v6;
        if ( *((char *)off_5F148 + 300) >= 0 || *((_BYTE *)off_5F148 + 297) < 4u )
          goto LABEL_49;
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x11Au, (__int64)&unk_4DCE8);
LABEL_48:
        v7 = (void **)off_5F148;
LABEL_49:
        if ( v7 == &off_5F148 )
          return v6;
        if ( *((char *)v7 + 300) < 0 && *((_BYTE *)v7 + 297) >= 5u )
        {
          v23 = sub_36CB0(*a3);
          sub_17860(*(_QWORD *)(v24 + 280), 0x11Cu, (__int64)&unk_4DCE8, v23);
          v7 = (void **)off_5F148;
        }
        goto LABEL_58;
      }
LABEL_34:
      v7 = (void **)off_5F148;
      goto LABEL_35;
    }
  }
LABEL_35:
  v19 = a1 - 2;
  if ( !v19 )
  {
    v22 = 33644553;
    goto LABEL_47;
  }
  v20 = v19 - 1;
  if ( !v20 )
  {
    v22 = 33644554;
    goto LABEL_47;
  }
  v21 = v20 - 1;
  if ( !v21 )
  {
    v22 = 33644555;
    goto LABEL_47;
  }
  if ( v21 == 1 )
  {
    v22 = 33644556;
LABEL_47:
    *a3 = sub_2DA90(v22);
    goto LABEL_48;
  }
  if ( v7 != &off_5F148 && *((char *)v7 + 300) < 0 && *((_BYTE *)v7 + 297) >= 3u )
  {
    sub_11008((__int64)v7[35], 0x11Bu, (__int64)&unk_4DCE8);
    v7 = (void **)off_5F148;
  }
LABEL_57:
  v6 = 4;
LABEL_58:
  if ( v7 != &off_5F148 && *((char *)v7 + 300) < 0 && *((_BYTE *)v7 + 297) >= 5u )
    sub_1102C((__int64)v7[35], 0x11Du, (__int64)&unk_4DCE8, v6);
  return v6;
}
// 1D8BB: conditional instruction was optimized away because of 'edi.4==2'
// 1D7D3: variable 'v9' is possibly undefined
// 1DA2F: variable 'v24' is possibly undefined
// 4C760: using guessed type wchar_t aWork[5];
// 5F148: using guessed type void *off_5F148;

//----- (000000000001DAFC) ----------------------------------------------------
__int64 __fastcall sub_1DAFC(__int64 a1, __int64 a2)
{
  unsigned int v4; // esi
  void **v5; // rcx
  int v6; // eax
  int v7; // edx

  v4 = 0;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_143A4(*((_QWORD *)off_5F148 + 35), 0x11Eu, (__int64)&unk_4DCE8, a1, a2);
    v5 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    *(_QWORD *)a2 = *(_QWORD *)a1;
    *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 8);
    if ( (*(_BYTE *)(a1 + 149) & 0x60) != 0 )
    {
      v6 = 2;
      if ( (*(_BYTE *)(a1 + 149) & 0x60) != 32 )
        v6 = 0;
    }
    else
    {
      v6 = 1;
    }
    *(_DWORD *)(a2 + 16) = v6;
    *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 72);
    *(_WORD *)(a2 + 24) = *(_WORD *)(a1 + 76);
    *(_DWORD *)(a2 + 26) = *(_DWORD *)(a1 + 78);
    *(_WORD *)(a2 + 30) = *(_WORD *)(a1 + 82);
    *(_DWORD *)(a2 + 32) ^= (*(_DWORD *)(a2 + 32) ^ (*(_DWORD *)(a1 + 152) >> 2)) & 1;
    *(_DWORD *)(a2 + 36) = *(_DWORD *)(a1 + 32);
    if ( (*(_BYTE *)(a1 + 152) & 0x10) != 0 )
    {
      *(_DWORD *)(a2 + 32) |= 2u;
      *(__m128i *)(a2 + 40) = _mm_loadu_si128((const __m128i *)(a1 + 40));
    }
    v7 = 4;
    if ( (*(_BYTE *)(a1 + 152) & 0x20) != 0 )
    {
      *(_DWORD *)(a2 + 32) |= 4u;
      *(__m128i *)(a2 + 56) = _mm_loadu_si128((const __m128i *)(a1 + 56));
    }
    if ( (*(_BYTE *)(a1 + 152) & 8) != 0 )
    {
      *(_DWORD *)(a2 + 32) |= 8u;
      *(_DWORD *)(a2 + 72) = *(_DWORD *)(a1 + 36);
    }
    if ( (*(_BYTE *)(a1 + 152) & 0x40) != 0 )
    {
      *(_DWORD *)(a2 + 32) |= 0x10u;
      *(_WORD *)(a2 + 76) = *(_WORD *)(a1 + 84);
    }
    if ( *(char *)(a1 + 152) < 0 )
    {
      *(_DWORD *)(a2 + 32) |= 0x20u;
      *(_WORD *)(a2 + 78) = *(_WORD *)(a1 + 86);
    }
    if ( (*(_BYTE *)(a1 + 148) & 0xF) != 1 )
    {
      switch ( *(_BYTE *)(a1 + 148) & 0xF )
      {
        case 3:
          v7 = 2;
          goto LABEL_39;
        case 4:
          v7 = 3;
          goto LABEL_39;
        case 5:
          v7 = 11;
          goto LABEL_39;
        case 6:
LABEL_39:
          *(_DWORD *)(a2 + 32) &= 0xFFFFFFBF;
          *(_DWORD *)(a2 + 80) = v7;
          *(_DWORD *)(a2 + 32) |= (v7 != 0) << 6;
          v5 = (void **)off_5F148;
          goto LABEL_45;
        case 7:
          v7 = 5;
          goto LABEL_39;
        case 8:
          v7 = 7;
          goto LABEL_39;
        case 9:
          v7 = 8;
          goto LABEL_39;
        case 10:
          v7 = 9;
          goto LABEL_39;
      }
    }
    v7 = 0;
    goto LABEL_39;
  }
  if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 300) & 8) != 0 && *((_BYTE *)v5 + 297) >= 2u )
  {
    sub_11008((__int64)v5[35], 0x11Fu, (__int64)&unk_4DCE8);
    v5 = (void **)off_5F148;
  }
  v4 = 4;
LABEL_45:
  if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 300) & 8) != 0 && *((_BYTE *)v5 + 297) >= 5u )
    sub_1102C((__int64)v5[35], 0x120u, (__int64)&unk_4DCE8, v4);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001DD60) ----------------------------------------------------
__int64 __fastcall sub_1DD60(__int64 a1, unsigned __int64 *a2)
{
  unsigned int v4; // ebx
  void **v5; // rcx
  int v6; // eax
  unsigned int v7; // eax
  void **v8; // rcx
  unsigned int v10; // [rsp+20h] [rbp-18h]

  v4 = 0;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x121u, (__int64)&unk_4DCE8);
    v5 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    v6 = sub_45BFC(*(_QWORD *)(a1 + 8), *a2, (__int64)a2, 0i64);
    if ( v6 )
    {
      v7 = sub_473B0(v6);
      v4 = v7;
      v8 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v4;
      if ( (*((_BYTE *)off_5F148 + 300) & 8) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
      {
LABEL_13:
        if ( v8 != &off_5F148 && (*((_BYTE *)v8 + 300) & 8) != 0 && *((_BYTE *)v8 + 297) >= 5u )
          sub_1102C((__int64)v8[35], 0x124u, (__int64)&unk_4DCE8, v4);
        return v4;
      }
      v10 = v7;
      sub_17814(*((_QWORD *)off_5F148 + 35), 0x123u, (__int64)&unk_4DCE8, *a2, v10);
    }
    v8 = (void **)off_5F148;
    goto LABEL_13;
  }
  if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 300) & 8) != 0 && *((_BYTE *)v5 + 297) >= 5u )
    sub_143A4((__int64)v5[35], 0x122u, (__int64)&unk_4DCE8, a1, a2);
  return 4i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001DEC4) ----------------------------------------------------
__int64 __fastcall sub_1DEC4(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  unsigned int v3; // ebx
  void **v6; // rcx
  unsigned int v8; // eax
  void **v9; // rcx
  int v10; // [rsp+40h] [rbp+8h] BYREF

  v3 = 0;
  v10 = 0;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x125u, (__int64)&unk_4DCE8);
    v6 = (void **)off_5F148;
  }
  if ( a1 )
  {
    LOBYTE(a3) = 1;
    sub_45E1C(*(_QWORD *)(a1 + 8), a2, a3, &v10);
    if ( v10 )
    {
      v8 = sub_473B0(v10);
      v3 = v8;
      v9 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v3;
      if ( (*((_BYTE *)off_5F148 + 300) & 8) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
      {
LABEL_17:
        if ( v9 != &off_5F148 && (*((_BYTE *)v9 + 300) & 8) != 0 && *((_BYTE *)v9 + 297) >= 5u )
          sub_1102C((__int64)v9[35], 0x128u, (__int64)&unk_4DCE8, v3);
        return v3;
      }
      sub_17814(*((_QWORD *)off_5F148 + 35), 0x127u, (__int64)&unk_4DCE8, a2, v8);
    }
    v9 = (void **)off_5F148;
    goto LABEL_17;
  }
  if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 300) & 8) != 0 && *((_BYTE *)v6 + 297) >= 5u )
    sub_17984((__int64)v6[35], 0x126u, (__int64)&unk_4DCE8, 0i64);
  return 4i64;
}
// 1DF78: variable 'a3' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000001E020) ----------------------------------------------------
__int64 __fastcall sub_1E020(__int64 a1, unsigned __int64 a2, __int64 *a3)
{
  unsigned int v3; // ebx
  void **v7; // rcx
  __int64 v8; // rax
  unsigned int v9; // eax
  int v11; // [rsp+50h] [rbp+8h] BYREF

  v3 = 0;
  v11 = 0;
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x129u, (__int64)&unk_4DCE8);
    v7 = (void **)off_5F148;
  }
  if ( !a1 || !a3 )
  {
    if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 300) & 8) != 0 && *((_BYTE *)v7 + 297) >= 5u )
    {
      sub_143A4((__int64)v7[35], 0x12Au, (__int64)&unk_4DCE8, a1, a3);
      v7 = (void **)off_5F148;
    }
    v3 = 4;
    goto LABEL_27;
  }
  v8 = sub_460A0(*(_QWORD *)(a1 + 8), a2, 0i64, &v11);
  *a3 = v8;
  if ( !v8 )
  {
    v9 = sub_473B0(v11);
    v3 = v9;
    if ( v9 == 5 )
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v3;
      if ( (*((_BYTE *)off_5F148 + 300) & 8) == 0 || *((_BYTE *)off_5F148 + 297) < 3u )
        goto LABEL_27;
      sub_17984(*((_QWORD *)off_5F148 + 35), 0x12Cu, (__int64)&unk_4DCE8, a2);
    }
    else
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v3;
      if ( (*((_BYTE *)off_5F148 + 300) & 8) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
        goto LABEL_27;
      sub_17814(*((_QWORD *)off_5F148 + 35), 0x12Du, (__int64)&unk_4DCE8, a2, v9);
    }
    goto LABEL_21;
  }
  v7 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return v3;
  if ( (*((_BYTE *)off_5F148 + 300) & 8) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_17984(*((_QWORD *)off_5F148 + 35), 0x12Bu, (__int64)&unk_4DCE8, a2);
LABEL_21:
    v7 = (void **)off_5F148;
  }
LABEL_27:
  if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 300) & 8) != 0 && *((_BYTE *)v7 + 297) >= 5u )
    sub_1102C((__int64)v7[35], 0x12Eu, (__int64)&unk_4DCE8, v3);
  return v3;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001E228) ----------------------------------------------------
__int64 __fastcall sub_1E228(__int64 a1)
{
  void **v2; // rcx
  unsigned int v3; // ebx
  int v4; // eax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x12Fu, (__int64)&unk_4DCE8);
    v2 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 300) & 0x10) != 0 && *((_BYTE *)v2 + 297) >= 2u )
    {
      sub_11008((__int64)v2[35], 0x130u, (__int64)&unk_4DCE8);
      v2 = (void **)off_5F148;
    }
    v3 = 4;
    goto LABEL_17;
  }
  v4 = sub_1F2A0(*(ULONG_PTR **)(a1 + 16));
  v3 = v4;
  if ( !v4 )
    goto LABEL_16;
  v2 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return v3;
  if ( (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x131u, (__int64)&unk_4DCE8, v4);
LABEL_16:
    v2 = (void **)off_5F148;
  }
LABEL_17:
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 300) & 0x10) != 0 && *((_BYTE *)v2 + 297) >= 5u )
    sub_1102C((__int64)v2[35], 0x133u, (__int64)&unk_4DCE8, v3);
  return v3;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001E350) ----------------------------------------------------
__int64 __fastcall sub_1E350(__int64 a1)
{
  unsigned int v2; // ebx
  void **v3; // rcx

  v2 = 0;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x134u, (__int64)&unk_4DCE8);
    v3 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 300) & 0x10) != 0 && *((_BYTE *)v3 + 297) >= 2u )
    {
      sub_11008((__int64)v3[35], 0x135u, (__int64)&unk_4DCE8);
      v3 = (void **)off_5F148;
    }
    v2 = 4;
  }
  if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 300) & 0x10) != 0 && *((_BYTE *)v3 + 297) >= 5u )
    sub_1102C((__int64)v3[35], 0x136u, (__int64)&unk_4DCE8, v2);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001E434) ----------------------------------------------------
__int64 __fastcall sub_1E434(__int64 a1, const signed __int32 *a2)
{
  unsigned int v4; // ebx
  void **v5; // rcx
  unsigned __int16 v6; // dx
  int v7; // eax

  v4 = 0;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x137u, (__int64)&unk_4DCE8);
    v5 = (void **)off_5F148;
  }
  if ( !a1 || !a2 )
  {
    if ( v5 == &off_5F148 )
      return v4;
    if ( (*((_BYTE *)v5 + 300) & 0x10) == 0 || *((_BYTE *)v5 + 297) < 2u )
      goto LABEL_51;
    sub_143A4((__int64)v5[35], 0x138u, (__int64)&unk_4DCE8, a1, a2);
    goto LABEL_50;
  }
  if ( _bittest(a2, 0xCu) )
  {
    if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 300) & 0x10) != 0 && *((_BYTE *)v5 + 297) >= 4u )
      sub_11008((__int64)v5[35], 0x139u, (__int64)&unk_4DCE8);
    if ( !(unsigned int)sub_2DA90(0x201600Du) )
    {
      v4 = sub_1F2A0(*(ULONG_PTR **)(a1 + 16));
      if ( v4 )
      {
        v5 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 )
          return v4;
        if ( (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
        {
          v6 = 314;
LABEL_18:
          sub_11008((__int64)v5[35], v6, (__int64)&unk_4DCE8);
LABEL_50:
          v5 = (void **)off_5F148;
          goto LABEL_51;
        }
        goto LABEL_51;
      }
    }
    v5 = (void **)off_5F148;
  }
  if ( _bittest(a2, 0x18u) )
  {
    if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 300) & 0x10) != 0 && *((_BYTE *)v5 + 297) >= 4u )
      sub_11008((__int64)v5[35], 0x13Bu, (__int64)&unk_4DCE8);
    v4 = sub_1E76C();
    if ( v4 )
    {
      v5 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v4;
      if ( (*((_BYTE *)off_5F148 + 300) & 0x10) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
        goto LABEL_51;
      v6 = 316;
      goto LABEL_18;
    }
    v5 = (void **)off_5F148;
  }
  if ( _bittest(a2, 0x19u) )
  {
    if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 300) & 0x10) != 0 && *((_BYTE *)v5 + 297) >= 4u )
      sub_11008((__int64)v5[35], 0x13Du, (__int64)&unk_4DCE8);
    if ( (unsigned int)sub_2DA90(0x201600Du) )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 4u )
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x13Eu, (__int64)&unk_4DCE8);
      v7 = sub_1F2A0(*(ULONG_PTR **)(a1 + 16));
      v4 = v7;
      if ( v7 )
      {
        v5 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 )
          return v4;
        if ( (*((_BYTE *)off_5F148 + 300) & 0x10) == 0 || *((_BYTE *)off_5F148 + 297) < 2u )
          goto LABEL_51;
        sub_1102C(*((_QWORD *)off_5F148 + 35), 0x13Fu, (__int64)&unk_4DCE8, v7);
      }
    }
    goto LABEL_50;
  }
LABEL_51:
  if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 300) & 0x10) != 0 && *((_BYTE *)v5 + 297) >= 5u )
    sub_1102C((__int64)v5[35], 0x140u, (__int64)&unk_4DCE8, v4);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001E710) ----------------------------------------------------
const char *__fastcall sub_1E710(int a1)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx

  if ( !a1 )
    return "E_NNS_TERMINATOR_TYPE_UNKNOWN";
  v1 = a1 - 1;
  if ( !v1 )
    return "E_NNS_TERMINATOR_TYPE_NONE";
  v2 = v1 - 1;
  if ( !v2 )
    return "E_NNS_TERMINATOR_TYPE_NO_PID";
  v3 = v2 - 1;
  if ( !v3 )
    return "E_NNS_TERMINATOR_TYPE_PID";
  v4 = v3 - 1;
  if ( !v4 )
    return "E_NNS_TERMINATOR_TYPE_DIRECTION";
  if ( v4 == 1 )
    return "E_NNS_TERMINATOR_TYPE_NO_FULL_MATCH";
  return "UNKNOWN";
}

//----- (000000000001E76C) ----------------------------------------------------
__int64 sub_1E76C()
{
  unsigned int v0; // ebx
  wchar_t v2[20]; // [rsp+20h] [rbp-38h] BYREF

  v0 = sub_2D7F0(33644569i64, v2);
  if ( !v0 )
  {
    sub_4B54C(a00, 17i64, (__int16 *)v2);
    v0 = sub_247BC(v2, &byte_5F190);
    if ( v0 == 5 )
    {
      v0 = 0;
      byte_5F190 = 31;
    }
    if ( v0 && off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 0x10) != 0 && *((_BYTE *)off_5F148 + 297) >= 2u )
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x141u, (__int64)&unk_4DCE8);
  }
  return v0;
}
// 5F148: using guessed type void *off_5F148;
// 5F190: using guessed type char byte_5F190;
// 5F198: using guessed type wchar_t a00[3];

//----- (000000000001E830) ----------------------------------------------------
void __fastcall sub_1E830(int a1)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx

  if ( a1 > 106 )
  {
    v7 = a1 - 107;
    if ( v7 )
    {
      v8 = v7 - 94;
      if ( v8 )
      {
        v9 = v8 - 1;
        if ( v9 )
        {
          v10 = v9 - 1;
          if ( v10 )
          {
            v11 = v10 - 1;
            if ( v11 )
            {
              v12 = v11 - 1;
              if ( v12 )
              {
                v13 = v12 - 96;
                if ( v13 )
                {
                  if ( v13 != 1 )
                  {
LABEL_18:
                    _InterlockedAdd64(&qword_5F500, 1ui64);
                    return;
                  }
                  _InterlockedAdd64(&qword_5F580, 1ui64);
                }
                else
                {
                  _InterlockedAdd64(&qword_5F578, 1ui64);
                }
              }
              else
              {
                _InterlockedAdd64(&qword_5F570, 1ui64);
              }
            }
            else
            {
              _InterlockedAdd64(&qword_5F568, 1ui64);
            }
          }
          else
          {
            _InterlockedAdd64(&qword_5F560, 1ui64);
          }
        }
        else
        {
          _InterlockedAdd64(&qword_5F558, 1ui64);
        }
      }
      else
      {
        _InterlockedAdd64(&qword_5F550, 1ui64);
      }
    }
    else
    {
      _InterlockedAdd64(&qword_5F548, 1ui64);
    }
  }
  else
  {
    if ( a1 != 106 )
    {
      if ( a1 )
      {
        v1 = a1 - 2;
        if ( !v1 )
        {
          _InterlockedAdd64(&qword_5F508, 1ui64);
          return;
        }
        v2 = v1 - 1;
        if ( !v2 )
        {
          _InterlockedAdd64(&qword_5F510, 1ui64);
          return;
        }
        v3 = v2 - 98;
        if ( !v3 )
        {
          _InterlockedAdd64(&qword_5F518, 1ui64);
          return;
        }
        v4 = v3 - 1;
        if ( !v4 )
        {
          _InterlockedAdd64(&qword_5F520, 1ui64);
          return;
        }
        v5 = v4 - 1;
        if ( !v5 )
        {
          _InterlockedAdd64(&qword_5F528, 1ui64);
          return;
        }
        v6 = v5 - 1;
        if ( !v6 )
        {
          _InterlockedAdd64(&qword_5F530, 1ui64);
          return;
        }
        if ( v6 == 1 )
        {
          _InterlockedAdd64(&qword_5F538, 1ui64);
          return;
        }
      }
      goto LABEL_18;
    }
    _InterlockedAdd64(&qword_5F540, 1ui64);
  }
}
// 5F500: using guessed type __int64 qword_5F500;
// 5F508: using guessed type __int64 qword_5F508;
// 5F510: using guessed type __int64 qword_5F510;
// 5F518: using guessed type __int64 qword_5F518;
// 5F520: using guessed type __int64 qword_5F520;
// 5F528: using guessed type __int64 qword_5F528;
// 5F530: using guessed type __int64 qword_5F530;
// 5F538: using guessed type __int64 qword_5F538;
// 5F540: using guessed type __int64 qword_5F540;
// 5F548: using guessed type __int64 qword_5F548;
// 5F550: using guessed type __int64 qword_5F550;
// 5F558: using guessed type __int64 qword_5F558;
// 5F560: using guessed type __int64 qword_5F560;
// 5F568: using guessed type __int64 qword_5F568;
// 5F570: using guessed type __int64 qword_5F570;
// 5F578: using guessed type __int64 qword_5F578;
// 5F580: using guessed type __int64 qword_5F580;

//----- (000000000001E93C) ----------------------------------------------------
__int64 __fastcall sub_1E93C(void *Dst)
{
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0xBu)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x15u, (__int64)&unk_4DCD8);
  }
  memset(Dst, 0, 0x38ui64);
  *(_QWORD *)Dst = -1i64;
  *((_QWORD *)Dst + 1) = -1i64;
  *((_BYTE *)Dst + 16) = 31;
  sub_4B54C((_WORD *)Dst + 9, 17i64, (__int16 *)qword_4C8A0);
  *((_BYTE *)Dst + 52) |= 0x5Bu;
  *((_BYTE *)Dst + 53) |= 0x40u;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0xBu)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x16u, (__int64)&unk_4DCD8);
  }
  return 0i64;
}
// 4C8A0: using guessed type __int64 qword_4C8A0[2];
// 5F148: using guessed type void *off_5F148;

//----- (000000000001EA0C) ----------------------------------------------------
__int64 __fastcall sub_1EA0C(__int64 a1, __int64 a2)
{
  _QWORD *v5; // rcx
  unsigned __int16 v6; // dx
  __int64 v7; // [rsp+30h] [rbp+8h] BYREF

  if ( !a1 )
    return 4i64;
  if ( (unsigned __int8)sub_2DA90(0x201601Bu) )
  {
    v7 = 0i64;
    sub_4B4A8(&v7, 8ui64, (const void *)(a2 + 12), 6ui64);
    sub_25714(v7, 17i64, (_WORD *)(a1 + 18));
    v5 = off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 75, 0xCu)
      || *((_BYTE *)off_5F148 + 297) < 4u )
    {
      return 0i64;
    }
    v6 = 29;
  }
  else
  {
    sub_4B54C((_WORD *)(a1 + 18), 17i64, (__int16 *)a00);
    v5 = off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 75, 0xCu)
      || *((_BYTE *)off_5F148 + 297) < 4u )
    {
      return 0i64;
    }
    v6 = 30;
  }
  sub_17860(v5[35], v6, (__int64)&unk_4DCD8, (const wchar_t *)(a1 + 18));
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;
// 5F198: using guessed type wchar_t a00[3];

//----- (000000000001EB00) ----------------------------------------------------
__int64 __fastcall sub_1EB00(int a1)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx

  if ( a1 <= 7 )
  {
    if ( a1 == 7 )
      return 8i64;
    v1 = a1 - 1;
    if ( !v1 )
      return 2i64;
    v2 = v1 - 1;
    if ( !v2 )
      return 3i64;
    v3 = v2 - 1;
    if ( !v3 )
      return 4i64;
    v4 = v3 - 1;
    if ( !v4 )
      return 5i64;
    v5 = v4 - 1;
    if ( !v5 )
      return 6i64;
    if ( v5 == 1 )
      return 7i64;
    return 11i64;
  }
  v7 = a1 - 8;
  if ( !v7 )
    return 9i64;
  v8 = v7 - 1;
  if ( !v8 )
    return 10i64;
  v9 = v8 - 1;
  if ( v9 )
  {
    v10 = v9 - 1;
    if ( v10 )
    {
      if ( v10 != 1 )
        return 11i64;
    }
  }
  return 12i64;
}

//----- (000000000001EB84) ----------------------------------------------------
__int64 __fastcall sub_1EB84(int a1)
{
  __int64 result; // rax
  unsigned int v2; // edx

  switch ( a1 )
  {
    case 0:
      return 16i64;
    case 16:
      return 32i64;
    case 32:
      return 48i64;
    case 48:
      return 64i64;
  }
  result = 80i64;
  if ( a1 != 64 )
  {
    if ( a1 == 80 )
    {
      result = 96i64;
    }
    else
    {
      v2 = 96;
      if ( a1 != 96 )
        v2 = 80;
      result = v2;
    }
  }
  return result;
}

//----- (000000000001EBD4) ----------------------------------------------------
__int64 sub_1EBD4(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 v4; // rcx
  _WORD *v5; // rdi
  bool v6; // zf
  __int64 v8; // [rsp+88h] [rbp+20h] BYREF
  va_list va; // [rsp+88h] [rbp+20h]
  _WORD *v10; // [rsp+90h] [rbp+28h]
  const char *v11; // [rsp+98h] [rbp+30h]
  va_list va1; // [rsp+A0h] [rbp+38h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _WORD *);
  v11 = va_arg(va1, const char *);
  if ( v11 )
    strlen(v11);
  if ( v10 && *v10 )
  {
    v4 = -1i64;
    v5 = v10;
    do
    {
      if ( !v4 )
        break;
      v6 = *v5++ == 0;
      --v4;
    }
    while ( !v6 );
  }
  return qword_5F3B8(a1, 43i64, &unk_4DCC8, 40i64, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001ECC0) ----------------------------------------------------
__int64 sub_1ECC0(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 v4; // rcx
  _WORD *v5; // rdi
  bool v6; // zf
  __int64 v7; // rcx
  _WORD *v8; // rdi
  __int64 v10; // [rsp+B8h] [rbp+20h] BYREF
  va_list va; // [rsp+B8h] [rbp+20h]
  _WORD *v12; // [rsp+C0h] [rbp+28h]
  const char *v13; // [rsp+C8h] [rbp+30h]
  _WORD *v14; // [rsp+D0h] [rbp+38h]
  const char *v15; // [rsp+D8h] [rbp+40h]
  va_list va1; // [rsp+E0h] [rbp+48h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _WORD *);
  v13 = va_arg(va1, const char *);
  v14 = va_arg(va1, _WORD *);
  v15 = va_arg(va1, const char *);
  if ( v15 )
    strlen(v15);
  if ( v14 && *v14 )
  {
    v4 = -1i64;
    v5 = v14;
    do
    {
      if ( !v4 )
        break;
      v6 = *v5++ == 0;
      --v4;
    }
    while ( !v6 );
  }
  if ( v13 )
    strlen(v13);
  if ( v12 && *v12 )
  {
    v7 = -1i64;
    v8 = v12;
    do
    {
      if ( !v7 )
        break;
      v6 = *v8++ == 0;
      --v7;
    }
    while ( !v6 );
  }
  return qword_5F3B8(a1, 43i64, &unk_4DCC8, 35i64, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001EE78) ----------------------------------------------------
__int64 __fastcall sub_1EE78(PVOID *a1)
{
  unsigned int v1; // ebx
  void **v3; // rcx
  _QWORD *v4; // rcx
  unsigned __int16 v5; // dx
  PVOID v6; // rax
  unsigned __int8 v7; // al
  _DWORD *v8; // rax
  int v9; // ecx
  int v10; // eax
  void **v11; // rcx
  int v13; // [rsp+70h] [rbp+8h] BYREF

  v1 = 0;
  v13 = 0;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0xFu)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xAu, (__int64)&unk_4DCC8);
    v3 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0xFu) && *((_BYTE *)v3 + 297) >= 2u )
      sub_11008((__int64)v3[35], 0xBu, (__int64)&unk_4DCC8);
    v1 = 4;
    goto LABEL_29;
  }
  *a1 = 0i64;
  qword_5F5B0 = sub_26670(1i64, 0x20u, 0x7352504Eu);
  if ( !qword_5F5B0 )
  {
    v4 = off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 75, 0xFu)
      || *((_BYTE *)off_5F148 + 297) < 2u )
    {
      goto LABEL_17;
    }
    v5 = 12;
LABEL_16:
    sub_11008(v4[35], v5, (__int64)&unk_4DCC8);
LABEL_17:
    v1 = 3;
    goto LABEL_29;
  }
  v6 = sub_26404(1, 8u, 0x7552504Eu);
  *a1 = v6;
  if ( !v6 )
  {
    v4 = off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 75, 0xFu)
      || *((_BYTE *)off_5F148 + 297) < 2u )
    {
      goto LABEL_17;
    }
    v5 = 13;
    goto LABEL_16;
  }
  v7 = sub_2DA90(0x201600Fu);
  v8 = sub_4481C(v7, 0i64, 1i64, 0x53524854u, 0i64, 2, 0i64, 0i64, (__int64)sub_1FD10, (__int64)sub_140EC, &v13);
  v9 = v13;
  *(_QWORD *)*a1 = v8;
  if ( !v9 )
  {
LABEL_30:
    v11 = (void **)off_5F148;
    goto LABEL_31;
  }
  v10 = sub_473B0(v9);
  v1 = v10;
  v11 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0xFu)
    && *((_BYTE *)off_5F148 + 297) >= 2u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0xEu, (__int64)&unk_4DCC8, v10);
    v11 = (void **)off_5F148;
  }
  if ( v1 )
  {
LABEL_29:
    sub_1F0D4(a1);
    goto LABEL_30;
  }
LABEL_31:
  if ( v11 != &off_5F148 && _bittest((const signed __int32 *)v11 + 75, 0xFu) && *((_BYTE *)v11 + 297) >= 5u )
    sub_1102C((__int64)v11[35], 0xFu, (__int64)&unk_4DCC8, v1);
  return v1;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001F0D4) ----------------------------------------------------
__int64 __fastcall sub_1F0D4(PVOID *a1)
{
  unsigned int v2; // ebx
  void **v3; // rcx
  ULONG_PTR *v4; // rax
  int v5; // eax
  int v6; // eax

  v2 = 0;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 300) & 1) != 0 && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x10u, (__int64)&unk_4DCC8);
    v3 = (void **)off_5F148;
  }
  if ( a1 && (v4 = (ULONG_PTR *)*a1) != 0i64 )
  {
    if ( *v4 )
    {
      v5 = sub_44B4C(*v4);
      if ( v5 )
      {
        v6 = sub_473B0(v5);
        v2 = v6;
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 75, 0xFu)
          && *((_BYTE *)off_5F148 + 297) >= 2u )
        {
          sub_1102C(*((_QWORD *)off_5F148 + 35), 0x12u, (__int64)&unk_4DCC8, v6);
        }
      }
    }
    else if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0xFu) && *((_BYTE *)v3 + 297) >= 2u )
    {
      sub_11008((__int64)v3[35], 0x13u, (__int64)&unk_4DCC8);
    }
    sub_26488(*a1, 0x7552504Eu);
    *a1 = 0i64;
    v3 = (void **)off_5F148;
  }
  else
  {
    if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0xFu) && *((_BYTE *)v3 + 297) >= 5u )
    {
      sub_17984((__int64)v3[35], 0x11u, (__int64)&unk_4DCC8, a1);
      v3 = (void **)off_5F148;
    }
    v2 = 4;
  }
  if ( qword_5F5B0 )
  {
    sub_26828(qword_5F5B0);
    qword_5F5B0 = 0i64;
    v3 = (void **)off_5F148;
  }
  if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0xFu) && *((_BYTE *)v3 + 297) >= 5u )
    sub_1102C((__int64)v3[35], 0x14u, (__int64)&unk_4DCC8, v2);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001F2A0) ----------------------------------------------------
__int64 __fastcall sub_1F2A0(ULONG_PTR *a1)
{
  unsigned int v2; // ebx
  void **v3; // rcx
  int v4; // eax
  int v5; // eax

  v2 = 0;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x10u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x15u, (__int64)&unk_4DCC8);
    v3 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x10u) && *((_BYTE *)v3 + 297) >= 2u )
    {
      sub_17984((__int64)v3[35], 0x16u, (__int64)&unk_4DCC8, 0i64);
      v3 = (void **)off_5F148;
    }
    v2 = 4;
    goto LABEL_21;
  }
  v4 = sub_44FD8(*a1);
  if ( !v4 )
  {
    v3 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148 )
      return v2;
    if ( !_bittest((const signed __int32 *)off_5F148 + 75, 0x10u) || *((_BYTE *)off_5F148 + 297) < 5u )
      goto LABEL_21;
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x18u, (__int64)&unk_4DCC8);
    goto LABEL_20;
  }
  v5 = sub_473B0(v4);
  v2 = v5;
  v3 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return v2;
  if ( _bittest((const signed __int32 *)off_5F148 + 75, 0x10u) && *((_BYTE *)off_5F148 + 297) >= 2u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x17u, (__int64)&unk_4DCC8, v5);
LABEL_20:
    v3 = (void **)off_5F148;
  }
LABEL_21:
  if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x10u) && *((_BYTE *)v3 + 297) >= 5u )
    sub_1102C((__int64)v3[35], 0x19u, (__int64)&unk_4DCC8, v2);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001F420) ----------------------------------------------------
__int64 __fastcall sub_1F420(ULONG_PTR *a1, unsigned __int64 a2, int a3, int a4, _WORD *a5, __int64 a6)
{
  unsigned int v9; // ebx
  void **v10; // r11
  __int64 v11; // rbp
  int v12; // eax
  const char *v13; // rax
  __int64 v14; // r11
  const char *v15; // r8
  const char *v16; // rax
  __int64 v17; // r11
  __int64 v18; // rdi
  unsigned int v19; // eax
  unsigned __int16 v20; // dx
  __int64 v21; // rdi
  int *v22; // r13
  int *v23; // r15
  int v24; // esi
  const wchar_t *v25; // rax
  __int64 v26; // r11
  __int64 v27; // r8
  __int64 v28; // r9
  __int64 v29; // r10
  _QWORD *v31; // [rsp+40h] [rbp-58h] BYREF
  __int64 v32; // [rsp+48h] [rbp-50h] BYREF
  __int64 v33; // [rsp+50h] [rbp-48h] BYREF
  __int64 v34; // [rsp+58h] [rbp-40h]
  int v35; // [rsp+A0h] [rbp+8h] BYREF
  unsigned __int64 v36; // [rsp+A8h] [rbp+10h]

  v36 = a2;
  v35 = 769;
  v9 = 0;
  v31 = 0i64;
  v32 = 0i64;
  v33 = 0i64;
  v34 = 0i64;
  v10 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x10u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x1Au, (__int64)&unk_4DCC8);
    v10 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v10 != &off_5F148 && _bittest((const signed __int32 *)v10 + 75, 0x10u) && *((_BYTE *)v10 + 297) >= 2u )
    {
      sub_143A4((__int64)v10[35], 0x1Bu, (__int64)&unk_4DCC8, 0i64, a6);
      v10 = (void **)off_5F148;
    }
    v9 = 4;
    goto LABEL_66;
  }
  v11 = a6;
  if ( (unsigned int)(a3 - 201) > 4 )
  {
    if ( (unsigned int)(a3 - 101) <= 6 )
    {
      if ( !a6 )
      {
        if ( v10 == &off_5F148 || !_bittest((const signed __int32 *)v10 + 75, 0x10u) || *((_BYTE *)v10 + 297) < 2u )
          goto LABEL_24;
        v16 = sub_34494(a3);
        sub_13618(*(_QWORD *)(v17 + 280), 0x1Eu, (__int64)&unk_4DCC8, v16);
        goto LABEL_23;
      }
      sub_439A0(*(_QWORD *)(a6 + 84), (__int64)&v32);
      v18 = sub_43E74(v32);
      sub_43B64(&v32);
      if ( !v18 )
      {
        v10 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 )
          return v9;
        if ( !_bittest((const signed __int32 *)off_5F148 + 75, 0x10u) || *((_BYTE *)off_5F148 + 297) < 2u )
          goto LABEL_66;
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x1Fu, (__int64)&unk_4DCC8);
        goto LABEL_65;
      }
      if ( (unsigned int)sub_3ED70(v11, 1066, &v33) )
      {
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 75, 0x10u)
          && *((_BYTE *)off_5F148 + 297) >= 3u )
        {
          sub_11008(*((_QWORD *)off_5F148 + 35), 0x20u, (__int64)&unk_4DCC8);
        }
      }
      else
      {
        v34 = *(_QWORD *)(v33 + 4);
      }
      sub_41FFC(v18, &v35);
    }
LABEL_43:
    v19 = sub_1FBB4(&v31);
    v9 = v19;
    if ( v19 )
    {
      v10 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v9;
      if ( !_bittest((const signed __int32 *)off_5F148 + 75, 0x10u) || *((_BYTE *)off_5F148 + 297) < 2u )
        goto LABEL_66;
      v20 = 33;
LABEL_48:
      sub_17814((__int64)v10[35], v20, (__int64)&unk_4DCC8, v36, v19);
      goto LABEL_65;
    }
    v21 = (__int64)v31;
    *v31 = v36;
    v22 = (int *)(v21 + 8);
    v23 = (int *)(v21 + 12);
    *(_DWORD *)(v21 + 8) = a3;
    *(_DWORD *)(v21 + 12) = v35;
    *(_DWORD *)(v21 + 16) = a4;
    *(_QWORD *)(v21 + 24) = v11;
    v24 = sub_45BFC(*a1, v36, v21, 0i64);
    if ( v24 )
    {
      sub_1FD10(v21);
      v19 = sub_473B0(v24);
      v9 = v19;
      v10 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v9;
      if ( !_bittest((const signed __int32 *)off_5F148 + 75, 0x10u) || *((_BYTE *)off_5F148 + 297) < 2u )
        goto LABEL_66;
      v20 = 34;
      goto LABEL_48;
    }
    if ( *v22 <= 200 || *v22 >= 206 )
    {
      if ( *v22 <= 100 || *v22 >= 108 )
        goto LABEL_61;
      _InterlockedAdd(&dword_5F4A4, 1u);
    }
    else
    {
      _InterlockedAdd(&dword_5F4A8, 1u);
    }
    v21 = (__int64)v31;
LABEL_61:
    v10 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148 )
      return v9;
    if ( !_bittest((const signed __int32 *)off_5F148 + 75, 0x10u) || *((_BYTE *)off_5F148 + 297) < 2u )
      goto LABEL_66;
    sub_1E710(a4);
    sub_34494(*v22);
    v25 = sub_352B8(*v23);
    sub_1ECC0(*(_QWORD *)(v26 + 280), 35i64, (__int64)&unk_4DCC8, *(_QWORD *)v21, v25, v27, v28, v29);
    goto LABEL_65;
  }
  if ( (unsigned int)(a4 - 2) > 3 )
  {
    if ( v10 == &off_5F148 || !_bittest((const signed __int32 *)v10 + 75, 0x10u) || *((_BYTE *)v10 + 297) < 2u )
      goto LABEL_24;
    sub_1E710(a4);
    v13 = sub_34494(a3);
    sub_17C08(*(_QWORD *)(v14 + 280), 0x1Cu, (__int64)&unk_4DCC8, v13, v15);
LABEL_23:
    v10 = (void **)off_5F148;
LABEL_24:
    v9 = 6;
    goto LABEL_66;
  }
  v12 = sub_1D780(a4, a5, &v35);
  v9 = v12;
  if ( !v12 )
    goto LABEL_43;
  v10 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return v9;
  if ( _bittest((const signed __int32 *)off_5F148 + 75, 0x10u) && *((_BYTE *)off_5F148 + 297) >= 2u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x1Du, (__int64)&unk_4DCC8, v12);
LABEL_65:
    v10 = (void **)off_5F148;
  }
LABEL_66:
  if ( v10 != &off_5F148 && _bittest((const signed __int32 *)v10 + 75, 0x10u) && *((_BYTE *)v10 + 297) >= 5u )
    sub_1102C((__int64)v10[35], 0x24u, (__int64)&unk_4DCC8, v9);
  return v9;
}
// 1F5D1: variable 'v14' is possibly undefined
// 1F5EC: variable 'v15' is possibly undefined
// 1F634: variable 'v17' is possibly undefined
// 1F8DF: variable 'v26' is possibly undefined
// 1F909: variable 'v27' is possibly undefined
// 1F909: variable 'v28' is possibly undefined
// 1F909: variable 'v29' is possibly undefined
// 5F148: using guessed type void *off_5F148;
// 5F4A4: using guessed type int dword_5F4A4;
// 5F4A8: using guessed type int dword_5F4A8;

//----- (000000000001F96C) ----------------------------------------------------
__int64 __fastcall sub_1F96C(__int64 *a1, unsigned __int64 a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _QWORD *a6)
{
  unsigned int v6; // ebx
  void **v10; // r10
  _QWORD *v11; // rdi
  _DWORD *v12; // r12
  __int64 v13; // rax
  unsigned int v14; // eax
  __int64 v15; // r9
  const wchar_t *v16; // rax
  _QWORD *v17; // r9
  __int64 v18; // r10
  __int64 v19; // r8
  int v21; // [rsp+70h] [rbp+8h] BYREF
  __int64 v22; // [rsp+78h] [rbp+10h]

  v22 = a2;
  v6 = 0;
  v21 = 0;
  v10 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x10u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x25u, (__int64)&unk_4DCC8);
    a2 = v22;
    v10 = (void **)off_5F148;
  }
  v11 = a6;
  if ( !a1 || !a4 || !a6 )
  {
    if ( v10 != &off_5F148 && _bittest((const signed __int32 *)v10 + 75, 0x10u) && *((_BYTE *)v10 + 297) >= 2u )
    {
      sub_143EC((__int64)v10[35], 0x26u, (__int64)&unk_4DCC8, a1, a4, a6);
      v10 = (void **)off_5F148;
    }
    v6 = 4;
    goto LABEL_23;
  }
  v12 = a5;
  *a3 = 0;
  *a4 = 0;
  *v12 = 1;
  *v11 = 0i64;
  v13 = sub_460A0(*a1, a2, 0i64, &v21);
  if ( !v21 )
  {
    *a3 = *(_DWORD *)(v13 + 8);
    *a4 = *(_DWORD *)(v13 + 12);
    *v12 = *(_DWORD *)(v13 + 16);
    *v11 = *(_QWORD *)(v13 + 24);
    v10 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148 )
      return v6;
    if ( !_bittest((const signed __int32 *)off_5F148 + 75, 0x10u) || *((_BYTE *)off_5F148 + 297) < 5u )
      goto LABEL_23;
    sub_34494(*(_DWORD *)(v13 + 8));
    v16 = sub_352B8(*(_DWORD *)(v15 + 12));
    sub_1EBD4(*(_QWORD *)(v18 + 280), 40i64, (__int64)&unk_4DCC8, *v17, v16, v19);
    goto LABEL_13;
  }
  v14 = sub_473B0(v21);
  v6 = v14;
  v10 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return v6;
  if ( _bittest((const signed __int32 *)off_5F148 + 75, 0x10u) && *((_BYTE *)off_5F148 + 297) >= 3u )
  {
    sub_17814(*((_QWORD *)off_5F148 + 35), 0x27u, (__int64)&unk_4DCC8, v22, v14);
LABEL_13:
    v10 = (void **)off_5F148;
  }
LABEL_23:
  if ( v10 != &off_5F148 && _bittest((const signed __int32 *)v10 + 75, 0x10u) && *((_BYTE *)v10 + 297) >= 5u )
    sub_1102C((__int64)v10[35], 0x29u, (__int64)&unk_4DCC8, v6);
  return v6;
}
// 1FAE8: variable 'v15' is possibly undefined
// 1FAF7: variable 'v18' is possibly undefined
// 1FAF4: variable 'v17' is possibly undefined
// 1FB10: variable 'v19' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000001FBB4) ----------------------------------------------------
__int64 __fastcall sub_1FBB4(_QWORD *a1)
{
  unsigned int v2; // ebx
  void **v3; // rcx
  _DWORD *v4; // rax

  v2 = 0;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x10u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x2Fu, (__int64)&unk_4DCC8);
    v3 = (void **)off_5F148;
  }
  if ( a1 )
  {
    v4 = sub_26948((__int64)qword_5F5B0);
    *a1 = v4;
    if ( v4 )
    {
      memset(v4, 0, 0x20ui64);
      v3 = (void **)off_5F148;
    }
    else
    {
      v3 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x10u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x31u, (__int64)&unk_4DCC8);
        v3 = (void **)off_5F148;
      }
      v2 = 3;
    }
  }
  else
  {
    if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x10u) && *((_BYTE *)v3 + 297) >= 2u )
    {
      sub_11008((__int64)v3[35], 0x30u, (__int64)&unk_4DCC8);
      v3 = (void **)off_5F148;
    }
    v2 = 4;
  }
  if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x10u) && *((_BYTE *)v3 + 297) >= 5u )
    sub_1102C((__int64)v3[35], 0x32u, (__int64)&unk_4DCC8, v2);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000001FD10) ----------------------------------------------------
__int64 __fastcall sub_1FD10(__int64 a1)
{
  unsigned int v2; // ebx
  void **v3; // rcx
  int v4; // eax

  v2 = 0;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x10u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x33u, (__int64)&unk_4DCC8);
    v3 = (void **)off_5F148;
  }
  if ( a1 )
  {
    v4 = *(_DWORD *)(a1 + 8);
    if ( v4 <= 200 || v4 >= 206 )
    {
      if ( v4 > 100 && v4 < 108 )
        _InterlockedAdd(&dword_5F4A4, 0xFFFFFFFF);
    }
    else
    {
      _InterlockedAdd(&dword_5F4A8, 0xFFFFFFFF);
    }
    sub_269B0((__int64)qword_5F5B0, a1);
    v3 = (void **)off_5F148;
  }
  else
  {
    if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x10u) && *((_BYTE *)v3 + 297) >= 5u )
    {
      sub_11008((__int64)v3[35], 0x34u, (__int64)&unk_4DCC8);
      v3 = (void **)off_5F148;
    }
    v2 = 4;
  }
  if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x10u) && *((_BYTE *)v3 + 297) >= 5u )
    sub_1102C((__int64)v3[35], 0x35u, (__int64)&unk_4DCC8, v2);
  return v2;
}
// 5F148: using guessed type void *off_5F148;
// 5F4A4: using guessed type int dword_5F4A4;
// 5F4A8: using guessed type int dword_5F4A8;

//----- (000000000001FE44) ----------------------------------------------------
char __fastcall sub_1FE44(int a1, int a2, __int64 a3, _WORD *a4)
{
  char v8; // bl
  int v9; // eax
  int v10; // edi
  void **v11; // r10
  const char *v12; // rax
  __int64 v13; // r10
  const char *v14; // r8
  int v15; // eax
  void **v16; // rcx
  unsigned __int16 v17; // dx
  __int64 v18; // rcx
  unsigned __int16 v19; // dx
  _QWORD *v20; // rcx
  __int64 v22; // [rsp+30h] [rbp-38h] BYREF
  int v23; // [rsp+70h] [rbp+8h] BYREF

  v8 = 0;
  v9 = sub_2DA90(0x201600Du);
  v10 = v9;
  v11 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x10u)
    && *((_BYTE *)off_5F148 + 297) >= 4u )
  {
    v12 = sub_34494(a1);
    sub_17C08(*(_QWORD *)(v13 + 280), 0x36u, (__int64)&unk_4DCC8, v12, v14);
    v11 = (void **)off_5F148;
  }
  if ( (unsigned int)(a1 - 201) > 4 || v10 != 2 && v10 != 3 )
  {
    if ( (unsigned int)(a1 - 101) > 6 || v10 != 1 && v10 != 3 )
      return v8;
    v22 = 0i64;
    if ( a3 )
    {
      if ( (unsigned int)sub_3ED70(a3, 1124, &v22) )
      {
        v20 = off_5F148;
        if ( off_5F148 == &off_5F148
          || !_bittest((const signed __int32 *)off_5F148 + 75, 8u)
          || *((_BYTE *)off_5F148 + 297) < 5u )
        {
          return v8;
        }
        v19 = 61;
      }
      else
      {
        if ( *(_BYTE *)(v22 + 4) )
        {
          v16 = (void **)off_5F148;
          if ( off_5F148 == &off_5F148
            || !_bittest((const signed __int32 *)off_5F148 + 75, 0x10u)
            || *((_BYTE *)off_5F148 + 297) < 4u )
          {
            goto LABEL_23;
          }
          v17 = 59;
          goto LABEL_22;
        }
        v20 = off_5F148;
        if ( off_5F148 == &off_5F148
          || !_bittest((const signed __int32 *)off_5F148 + 75, 8u)
          || *((_BYTE *)off_5F148 + 297) < 5u )
        {
          return v8;
        }
        v19 = 60;
      }
      v18 = v20[35];
    }
    else
    {
      if ( v11 == &off_5F148 || !_bittest((const signed __int32 *)v11 + 75, 0x10u) || *((_BYTE *)v11 + 297) < 2u )
        return v8;
      v18 = (__int64)v11[35];
      v19 = 58;
    }
    sub_11008(v18, v19, (__int64)&unk_4DCC8);
    return v8;
  }
  v23 = 769;
  v15 = sub_1D780(a2, a4, &v23);
  if ( v15 )
  {
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x10u)
      && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x37u, (__int64)&unk_4DCC8, v15);
    }
    return v8;
  }
  v16 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x10u)
    && *((_BYTE *)off_5F148 + 297) >= 4u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x38u, (__int64)&unk_4DCC8, v23);
    v16 = (void **)off_5F148;
  }
  if ( v23 != 780 )
  {
    if ( v16 == &off_5F148 || !_bittest((const signed __int32 *)v16 + 75, 0x10u) || *((_BYTE *)v16 + 297) < 4u )
      goto LABEL_23;
    v17 = 57;
LABEL_22:
    sub_11008((__int64)v16[35], v17, (__int64)&unk_4DCC8);
LABEL_23:
    v8 = 1;
  }
  return v8;
}
// 1FEEF: variable 'v13' is possibly undefined
// 1FF06: variable 'v14' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (0000000000020144) ----------------------------------------------------
__int64 __fastcall sub_20144(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, const char *a5)
{
  int v7; // [rsp+78h] [rbp+20h] BYREF

  v7 = a4;
  if ( a5 )
    strlen(a5);
  return qword_5F3B8(a1, 43i64, a3, a2, &v7);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000201C4) ----------------------------------------------------
__int64 sub_201C4(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 v5; // [rsp+A8h] [rbp+20h] BYREF
  va_list va; // [rsp+A8h] [rbp+20h]
  __int64 v7; // [rsp+B0h] [rbp+28h]
  const char *v8; // [rsp+B8h] [rbp+30h]
  __int64 v9; // [rsp+C0h] [rbp+38h]
  const char *v10; // [rsp+C8h] [rbp+40h]
  va_list va1; // [rsp+D0h] [rbp+48h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, const char *);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, const char *);
  if ( v10 )
    strlen(v10);
  if ( v8 )
    strlen(v8);
  return qword_5F3B8(a1, 43i64, &unk_4DCB8, 134i64, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000202B4) ----------------------------------------------------
__int64 sub_202B4(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 v5; // [rsp+78h] [rbp+20h] BYREF
  va_list va; // [rsp+78h] [rbp+20h]
  const char *v7; // [rsp+80h] [rbp+28h]
  va_list va1; // [rsp+88h] [rbp+30h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, const char *);
  if ( v7 )
    strlen(v7);
  return qword_5F3B8(a1, 43i64, &unk_4DCB8, 115i64, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000020340) ----------------------------------------------------
__int64 sub_20340(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, &unk_4DCB8, 91i64, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000020394) ----------------------------------------------------
__int64 sub_20394(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  __int64 v5; // [rsp+78h] [rbp+20h] BYREF
  va_list va; // [rsp+78h] [rbp+20h]
  const char *v7; // [rsp+80h] [rbp+28h]
  va_list va1; // [rsp+88h] [rbp+30h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, const char *);
  if ( v7 )
    strlen(v7);
  return qword_5F3B8(a1, 43i64, &unk_4DCB8, a2, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002041C) ----------------------------------------------------
__int64 sub_2041C(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  __int64 v5; // [rsp+88h] [rbp+20h] BYREF
  va_list va; // [rsp+88h] [rbp+20h]
  const char *v7; // [rsp+90h] [rbp+28h]
  va_list va1; // [rsp+98h] [rbp+30h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, const char *);
  if ( v7 )
    strlen(v7);
  return qword_5F3B8(a1, 43i64, &unk_4DCB8, a2, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000204BC) ----------------------------------------------------
__int64 sub_204BC(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, &unk_4DCB8, a2, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000020510) ----------------------------------------------------
__int64 sub_20510(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  __int64 v5; // [rsp+98h] [rbp+20h] BYREF
  va_list va; // [rsp+98h] [rbp+20h]
  __int64 v7; // [rsp+A0h] [rbp+28h]
  const char *v8; // [rsp+A8h] [rbp+30h]
  va_list va1; // [rsp+B0h] [rbp+38h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, const char *);
  if ( v8 )
    strlen(v8);
  return qword_5F3B8(a1, 43i64, &unk_4DCB8, a2, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000205C0) ----------------------------------------------------
__int64 sub_205C0(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 v5; // [rsp+78h] [rbp+20h] BYREF
  va_list va; // [rsp+78h] [rbp+20h]
  const char *v7; // [rsp+80h] [rbp+28h]
  va_list va1; // [rsp+88h] [rbp+30h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, const char *);
  if ( v7 )
    strlen(v7);
  return qword_5F3B8(a1, 43i64, &unk_4DCB8, 141i64, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002064C) ----------------------------------------------------
__int64 sub_2064C(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 v5; // [rsp+98h] [rbp+20h] BYREF
  va_list va; // [rsp+98h] [rbp+20h]
  __int64 v7; // [rsp+A0h] [rbp+28h]
  __int64 v8; // [rsp+A8h] [rbp+30h]
  const char *v9; // [rsp+B0h] [rbp+38h]
  va_list va1; // [rsp+B8h] [rbp+40h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, const char *);
  if ( v9 )
    strlen(v9);
  return qword_5F3B8(a1, 43i64, &unk_4DCB8, 100i64, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000206FC) ----------------------------------------------------
__int64 sub_206FC(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 v5; // [rsp+78h] [rbp+20h] BYREF
  va_list va; // [rsp+78h] [rbp+20h]
  const char *v7; // [rsp+80h] [rbp+28h]
  va_list va1; // [rsp+88h] [rbp+30h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, const char *);
  if ( v7 )
    strlen(v7);
  return qword_5F3B8(a1, 43i64, &unk_4DCB8, 92i64, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000020788) ----------------------------------------------------
__int64 __fastcall sub_20788(__int64 a1, __int64 a2, __int64 a3, const char *a4)
{
  const char *v5; // rax

  if ( a4 )
    strlen(a4);
  v5 = "NULL";
  if ( a4 )
    v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DCB8, 122i64, v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000020830) ----------------------------------------------------
__int64 __fastcall sub_20830(__int64 a1, __int64 a2, __int64 a3, const char *a4, char a5, const char *a6)
{
  const char *v7; // rcx

  if ( a6 )
    strlen(a6);
  if ( a4 )
    strlen(a4);
  v7 = "NULL";
  if ( a4 )
    v7 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DCB8, 104i64, v7);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002090C) ----------------------------------------------------
__int64 __fastcall sub_2090C(__int64 a1, __int64 a2, __int64 a3, const char *a4)
{
  const char *v5; // rax

  if ( a4 )
    strlen(a4);
  v5 = "NULL";
  if ( a4 )
    v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DCB8, 121i64, v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000209CC) ----------------------------------------------------
__int64 __fastcall sub_209CC(__int64 a1, __int64 a2, __int64 a3, const char *a4, char a5, const char *a6)
{
  const char *v7; // rcx

  if ( a6 )
    strlen(a6);
  if ( a4 )
    strlen(a4);
  v7 = "NULL";
  if ( a4 )
    v7 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DCB8, 86i64, v7);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000020A84) ----------------------------------------------------
__int64 __fastcall sub_20A84(__int64 *a1, __int64 a2, int a3)
{
  void **v6; // rcx
  unsigned int v7; // ebx
  _QWORD *v8; // rax
  int v9; // eax
  int v10; // eax

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xAu, (__int64)&unk_4DCB8);
    v6 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 75, 0x12u) && *((_BYTE *)v6 + 297) >= 2u )
      sub_17984((__int64)v6[35], 0xBu, (__int64)&unk_4DCB8, 0i64);
    v7 = 4;
LABEL_29:
    sub_20CF8(a1);
    goto LABEL_30;
  }
  *a1 = 0i64;
  v8 = sub_26404(1, 0x38u, 0x6B52504Eu);
  *a1 = (__int64)v8;
  if ( !v8 )
  {
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
      && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0xCu, (__int64)&unk_4DCB8);
    }
    v7 = 3;
    goto LABEL_29;
  }
  *v8 = a2;
  *(_DWORD *)(*a1 + 8) = a3;
  *(_QWORD *)(*a1 + 24) = MEMORY[0xFFFFF78000000014];
  *(_DWORD *)(*a1 + 12) = 0;
  *(_QWORD *)(*a1 + 16) = 0i64;
  *(_DWORD *)(*a1 + 32) = 0;
  *(_QWORD *)(*a1 + 40) = 0i64;
  *(_QWORD *)(*a1 + 48) = 0i64;
  v9 = sub_42500(0x6B52504Eu, (__int64 *)(*a1 + 40), 2, (void (__fastcall *)(__int64 *))sub_21014);
  v7 = v9;
  if ( v9 )
  {
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
      && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0xDu, (__int64)&unk_4DCB8, v9);
    }
    *(_QWORD *)(*a1 + 40) = 0i64;
    goto LABEL_29;
  }
  v10 = sub_42500(0x6B52504Eu, (__int64 *)(*a1 + 48), 0, (void (__fastcall *)(__int64 *))sub_2128C);
  v7 = v10;
  if ( v10 )
  {
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
      && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0xEu, (__int64)&unk_4DCB8, v10);
    }
    *(_QWORD *)(*a1 + 48) = 0i64;
    goto LABEL_29;
  }
LABEL_30:
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0xFu, (__int64)&unk_4DCB8, v7);
  }
  return v7;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000020CF8) ----------------------------------------------------
__int64 __fastcall sub_20CF8(__int64 *a1)
{
  void **v2; // rcx
  int v3; // eax
  int v4; // eax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x10u, (__int64)&unk_4DCB8);
    v2 = (void **)off_5F148;
  }
  if ( a1 && *a1 )
  {
    sub_23C04(*a1);
    v3 = sub_42938((__int64 *)(*a1 + 48), (void (__fastcall *)(__int64 *))sub_2128C);
    if ( v3
      && off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
      && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x12u, (__int64)&unk_4DCB8, v3);
    }
    v4 = sub_42938((__int64 *)(*a1 + 40), (void (__fastcall *)(__int64 *))sub_21014);
    if ( v4
      && off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
      && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x13u, (__int64)&unk_4DCB8, v4);
    }
    sub_26488((PVOID)*a1, 0x6B52504Eu);
    *a1 = 0i64;
    goto LABEL_22;
  }
  if ( v2 == &off_5F148 )
    return 0i64;
  if ( _bittest((const signed __int32 *)v2 + 75, 0x12u) && *((_BYTE *)v2 + 297) >= 5u )
  {
    sub_17984((__int64)v2[35], 0x11u, (__int64)&unk_4DCB8, a1);
LABEL_22:
    v2 = (void **)off_5F148;
  }
  if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 75, 0x12u) && *((_BYTE *)v2 + 297) >= 5u )
    sub_11008((__int64)v2[35], 0x14u, (__int64)&unk_4DCB8);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000020EA4) ----------------------------------------------------
__int64 __fastcall sub_20EA4(_QWORD *a1, __int64 a2)
{
  unsigned int v3; // ebx
  void **v4; // rcx
  _QWORD *v5; // r11

  v3 = 0;
  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x15u, (__int64)&unk_4DCB8);
    v4 = (void **)off_5F148;
  }
  if ( a1 )
  {
    *a1 = 0i64;
    v5 = sub_26404(1, 8u, 0x6B52504Eu);
    *a1 = v5;
    if ( v5 )
    {
      *v5 = a2;
      v4 = (void **)off_5F148;
    }
    else
    {
      v4 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x17u, (__int64)&unk_4DCB8);
        v4 = (void **)off_5F148;
      }
      v3 = 3;
    }
  }
  else
  {
    if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x12u) && *((_BYTE *)v4 + 297) >= 2u )
    {
      sub_11008((__int64)v4[35], 0x16u, (__int64)&unk_4DCB8);
      v4 = (void **)off_5F148;
    }
    v3 = 4;
  }
  if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x12u) && *((_BYTE *)v4 + 297) >= 5u )
    sub_1102C((__int64)v4[35], 0x18u, (__int64)&unk_4DCB8, v3);
  return v3;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000021014) ----------------------------------------------------
__int64 __fastcall sub_21014(PVOID *a1)
{
  unsigned int v2; // ebx
  void **v3; // rcx

  v2 = 0;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x19u, (__int64)&unk_4DCB8);
    v3 = (void **)off_5F148;
  }
  if ( a1 && *a1 )
  {
    sub_26488(*a1, 0x6B52504Eu);
    *a1 = 0i64;
    v3 = (void **)off_5F148;
  }
  else
  {
    if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x12u) && *((_BYTE *)v3 + 297) >= 5u )
    {
      sub_17984((__int64)v3[35], 0x1Au, (__int64)&unk_4DCB8, a1);
      v3 = (void **)off_5F148;
    }
    v2 = 4;
  }
  if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x12u) && *((_BYTE *)v3 + 297) >= 5u )
    sub_11008((__int64)v3[35], 0x1Bu, (__int64)&unk_4DCB8);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000021120) ----------------------------------------------------
__int64 __fastcall sub_21120(_QWORD *a1, __int64 a2)
{
  unsigned int v4; // ebx
  void **v5; // rcx
  _QWORD *v6; // rax

  v4 = 0;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x1Cu, (__int64)&unk_4DCB8);
    v5 = (void **)off_5F148;
  }
  if ( a1 )
  {
    *a1 = 0i64;
    v6 = sub_26404(1, 8u, 0x6B52504Eu);
    *a1 = v6;
    if ( v6 )
    {
      *v6 = a2;
      v5 = (void **)off_5F148;
    }
    else
    {
      v5 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x1Eu, (__int64)&unk_4DCB8);
        v5 = (void **)off_5F148;
      }
      v4 = 3;
    }
  }
  else
  {
    if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 75, 0x12u) && *((_BYTE *)v5 + 297) >= 2u )
    {
      sub_11008((__int64)v5[35], 0x1Du, (__int64)&unk_4DCB8);
      v5 = (void **)off_5F148;
    }
    v4 = 4;
  }
  if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 75, 0x12u) && *((_BYTE *)v5 + 297) >= 5u )
    sub_1102C((__int64)v5[35], 0x1Fu, (__int64)&unk_4DCB8, v4);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002128C) ----------------------------------------------------
__int64 __fastcall sub_2128C(PVOID *a1)
{
  unsigned int v2; // ebx
  void **v3; // rcx

  v2 = 0;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x20u, (__int64)&unk_4DCB8);
    v3 = (void **)off_5F148;
  }
  if ( a1 && *a1 )
  {
    sub_26488(*a1, 0x6B52504Eu);
    *a1 = 0i64;
    v3 = (void **)off_5F148;
  }
  else
  {
    if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x12u) && *((_BYTE *)v3 + 297) >= 5u )
    {
      sub_17984((__int64)v3[35], 0x21u, (__int64)&unk_4DCB8, a1);
      v3 = (void **)off_5F148;
    }
    v2 = 4;
  }
  if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x12u) && *((_BYTE *)v3 + 297) >= 5u )
    sub_11008((__int64)v3[35], 0x22u, (__int64)&unk_4DCB8);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000021398) ----------------------------------------------------
__int64 __fastcall sub_21398(__int64 a1, __int64 a2)
{
  unsigned int v4; // ebx
  void **v5; // rcx

  v4 = 1;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x23u, (__int64)&unk_4DCB8);
    v5 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    if ( *(_QWORD *)a1 == *(_QWORD *)a2 && *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8) )
    {
      if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 75, 0x12u) && *((_BYTE *)v5 + 297) >= 5u )
      {
        sub_11008((__int64)v5[35], 0x25u, (__int64)&unk_4DCB8);
        v5 = (void **)off_5F148;
      }
      v4 = 7;
    }
    else
    {
      v4 = 8;
    }
  }
  else
  {
    if ( v5 == &off_5F148 )
      return v4;
    if ( _bittest((const signed __int32 *)v5 + 75, 0x12u) && *((_BYTE *)v5 + 297) >= 5u )
    {
      sub_143A4((__int64)v5[35], 0x24u, (__int64)&unk_4DCB8, a1, a2);
      v5 = (void **)off_5F148;
    }
  }
  if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 75, 0x12u) && *((_BYTE *)v5 + 297) >= 5u )
    sub_1102C((__int64)v5[35], 0x26u, (__int64)&unk_4DCB8, v4);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000214EC) ----------------------------------------------------
__int64 __fastcall sub_214EC(__int64 a1, __int64 a2)
{
  unsigned int v4; // ebx
  void **v5; // rcx
  __int64 v6; // rdx
  int v7; // eax

  v4 = 1;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x27u, (__int64)&unk_4DCB8);
    v5 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    v4 = 8;
    if ( a2 == -96 )
      v6 = -1i64;
    else
      v6 = *(_QWORD *)(a2 + 96);
    if ( *(_QWORD *)a1 == v6 )
    {
      v7 = sub_431EC(*(int **)(a1 + 40), a2 + 88, 0i64, (__int64 (__fastcall *)(_QWORD, __int64))sub_216C0, 1);
      if ( v7 )
      {
        v5 = (void **)off_5F148;
        if ( v7 != 5 )
        {
          if ( off_5F148 != &off_5F148
            && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
            && *((_BYTE *)off_5F148 + 297) >= 5u )
          {
            sub_1102C(*((_QWORD *)off_5F148 + 35), 0x2Au, (__int64)&unk_4DCB8, v7);
            v5 = (void **)off_5F148;
          }
          v4 = 1;
        }
      }
      else
      {
        v5 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
          && *((_BYTE *)off_5F148 + 297) >= 5u )
        {
          sub_11008(*((_QWORD *)off_5F148 + 35), 0x29u, (__int64)&unk_4DCB8);
          v5 = (void **)off_5F148;
        }
        v4 = 7;
      }
    }
  }
  else
  {
    if ( v5 == &off_5F148 )
      return v4;
    if ( _bittest((const signed __int32 *)v5 + 75, 0x12u) && *((_BYTE *)v5 + 297) >= 5u )
    {
      sub_143A4((__int64)v5[35], 0x28u, (__int64)&unk_4DCB8, a1, a2);
      v5 = (void **)off_5F148;
    }
  }
  if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 75, 0x12u) && *((_BYTE *)v5 + 297) >= 5u )
    sub_1102C((__int64)v5[35], 0x2Bu, (__int64)&unk_4DCB8, v4);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000216C0) ----------------------------------------------------
__int64 __fastcall sub_216C0(_QWORD *a1, _QWORD *a2)
{
  unsigned int v4; // ebx
  void **v5; // rcx

  v4 = 1;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x2Cu, (__int64)&unk_4DCB8);
    v5 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    if ( *a1 == *a2 )
    {
      if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 75, 0x12u) && *((_BYTE *)v5 + 297) >= 5u )
      {
        sub_11008((__int64)v5[35], 0x2Eu, (__int64)&unk_4DCB8);
        v5 = (void **)off_5F148;
      }
      v4 = 7;
    }
    else if ( *a1 <= *a2 )
    {
      if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 75, 0x12u) && *((_BYTE *)v5 + 297) >= 5u )
      {
        sub_11008((__int64)v5[35], 0x30u, (__int64)&unk_4DCB8);
        v5 = (void **)off_5F148;
      }
      v4 = 5;
    }
    else
    {
      if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 75, 0x12u) && *((_BYTE *)v5 + 297) >= 5u )
      {
        sub_11008((__int64)v5[35], 0x2Fu, (__int64)&unk_4DCB8);
        v5 = (void **)off_5F148;
      }
      v4 = 6;
    }
  }
  else
  {
    if ( v5 == &off_5F148 )
      return v4;
    if ( _bittest((const signed __int32 *)v5 + 75, 0x12u) && *((_BYTE *)v5 + 297) >= 5u )
    {
      sub_143A4((__int64)v5[35], 0x2Du, (__int64)&unk_4DCB8, a1, a2);
      v5 = (void **)off_5F148;
    }
  }
  if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 75, 0x12u) && *((_BYTE *)v5 + 297) >= 5u )
    sub_1102C((__int64)v5[35], 0x31u, (__int64)&unk_4DCB8, v4);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000021884) ----------------------------------------------------
__int64 __fastcall sub_21884(PERESOURCE *a1)
{
  void **v2; // rcx
  unsigned int v3; // ebx
  struct _ERESOURCE *v4; // rax
  int v5; // eax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x32u, (__int64)&unk_4DCB8);
    v2 = (void **)off_5F148;
  }
  if ( a1 )
  {
    *a1 = 0i64;
    v4 = (struct _ERESOURCE *)sub_26404(2, 0x70u, 0x7552504Eu);
    *a1 = v4;
    if ( v4 )
    {
      memset(v4, 0, 0x70ui64);
      sub_26ADC(*a1);
      KeEnterCriticalRegion();
      sub_26C84(*a1);
      v5 = sub_42500(0x6B52504Eu, (__int64 *)&(*a1)[1], 0, (void (__fastcall *)(__int64 *))sub_20CF8);
      v3 = v5;
      if ( v5
        && off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_1102C(*((_QWORD *)off_5F148 + 35), 0x35u, (__int64)&unk_4DCB8, v5);
      }
      sub_26E34(*a1);
      KeLeaveCriticalRegion();
      v2 = (void **)off_5F148;
    }
    else
    {
      v2 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x34u, (__int64)&unk_4DCB8);
        v2 = (void **)off_5F148;
      }
      v3 = 3;
    }
  }
  else
  {
    if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 75, 0x12u) && *((_BYTE *)v2 + 297) >= 2u )
    {
      sub_11008((__int64)v2[35], 0x33u, (__int64)&unk_4DCB8);
      v2 = (void **)off_5F148;
    }
    v3 = 4;
  }
  if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 75, 0x12u) && *((_BYTE *)v2 + 297) >= 5u )
    sub_1102C((__int64)v2[35], 0x36u, (__int64)&unk_4DCB8, v3);
  return v3;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000021A90) ----------------------------------------------------
__int64 __fastcall sub_21A90(PERESOURCE *a1)
{
  void **v2; // rcx
  int v3; // eax
  unsigned int v4; // ebx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x37u, (__int64)&unk_4DCB8);
    v2 = (void **)off_5F148;
  }
  if ( a1 && *a1 )
  {
    KeEnterCriticalRegion();
    sub_26C84(*a1);
    v3 = sub_42938((__int64 *)&(*a1)[1], (void (__fastcall *)(__int64 *))sub_20CF8);
    v4 = v3;
    if ( v3
      && off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
      && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x39u, (__int64)&unk_4DCB8, v3);
    }
    sub_26E34(*a1);
    KeLeaveCriticalRegion();
    if ( !v4 )
    {
      sub_26BB0(*a1);
      sub_26488(*a1, 0x7552504Eu);
    }
    v2 = (void **)off_5F148;
  }
  else
  {
    if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 75, 0x12u) && *((_BYTE *)v2 + 297) >= 2u )
    {
      sub_17984((__int64)v2[35], 0x38u, (__int64)&unk_4DCB8, a1);
      v2 = (void **)off_5F148;
    }
    v4 = 4;
  }
  if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 75, 0x12u) && *((_BYTE *)v2 + 297) >= 5u )
    sub_1102C((__int64)v2[35], 0x3Au, (__int64)&unk_4DCB8, v4);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000021C3C) ----------------------------------------------------
__int64 __fastcall sub_21C3C(__int64 a1, __int64 a2)
{
  void **v4; // rcx
  unsigned int v5; // ebx
  int v6; // eax

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x3Bu, (__int64)&unk_4DCB8);
    v4 = (void **)off_5F148;
  }
  if ( a1 )
  {
    v6 = sub_42D48(*(int **)(a1 + 104), a2, 0i64);
    v5 = v6;
    if ( v6
      && off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
      && *((_BYTE *)off_5F148 + 297) >= 5u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x3Du, (__int64)&unk_4DCB8, v6);
    }
    _InterlockedAdd(&dword_5F4AC, 1u);
    v4 = (void **)off_5F148;
  }
  else
  {
    if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x12u) && *((_BYTE *)v4 + 297) >= 2u )
    {
      sub_11008((__int64)v4[35], 0x3Cu, (__int64)&unk_4DCB8);
      v4 = (void **)off_5F148;
    }
    v5 = 4;
  }
  if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x12u) && *((_BYTE *)v4 + 297) >= 5u )
    sub_1102C((__int64)v4[35], 0x3Eu, (__int64)&unk_4DCB8, v5);
  return v5;
}
// 5F148: using guessed type void *off_5F148;
// 5F4AC: using guessed type int dword_5F4AC;

//----- (0000000000021D80) ----------------------------------------------------
__int64 __fastcall sub_21D80(__int64 a1, __int64 a2)
{
  void **v4; // rcx
  unsigned int v5; // ebx
  int v6; // eax

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x3Fu, (__int64)&unk_4DCB8);
    v4 = (void **)off_5F148;
  }
  if ( a1 )
  {
    v6 = sub_42F90(*(int **)(a1 + 104), a2, sub_21398, (void (__fastcall *)(_QWORD *))sub_20CF8, 0);
    v5 = v6;
    if ( v6
      && off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
      && *((_BYTE *)off_5F148 + 297) >= 5u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x41u, (__int64)&unk_4DCB8, v6);
    }
    _InterlockedAdd(&dword_5F4AC, 0xFFFFFFFF);
    v4 = (void **)off_5F148;
  }
  else
  {
    if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x12u) && *((_BYTE *)v4 + 297) >= 2u )
    {
      sub_11008((__int64)v4[35], 0x40u, (__int64)&unk_4DCB8);
      v4 = (void **)off_5F148;
    }
    v5 = 4;
  }
  if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x12u) && *((_BYTE *)v4 + 297) >= 5u )
    sub_1102C((__int64)v4[35], 0x42u, (__int64)&unk_4DCB8, v5);
  return v5;
}
// 5F148: using guessed type void *off_5F148;
// 5F4AC: using guessed type int dword_5F4AC;

//----- (0000000000021ED4) ----------------------------------------------------
__int64 __fastcall sub_21ED4(__int64 *a1, __int64 a2, int a3, _DWORD *a4)
{
  void **v8; // rcx
  unsigned int v9; // edi
  int v10; // eax
  _QWORD *v11; // rdi
  _WORD *v12; // rdi
  __int64 v13; // r12
  __int64 v14; // rcx
  bool v15; // zf
  unsigned int v16; // er13
  PVOID v17; // rax
  unsigned int v18; // eax
  __int64 v19; // rbp
  __int64 *v20; // rsi
  int v21; // eax
  PVOID v23[2]; // [rsp+30h] [rbp-38h] BYREF
  unsigned int v24; // [rsp+70h] [rbp+8h] BYREF

  v23[0] = 0i64;
  v24 = 0;
  v8 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x4Au, (__int64)&unk_4DCB8);
    v8 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    if ( (*(_BYTE *)(a2 + 152) & 1) == 0 )
    {
LABEL_8:
      v9 = 6;
      goto LABEL_40;
    }
    v10 = sub_33F40(*(_QWORD *)(a2 + 16), v23, &v24);
    v9 = v10;
    if ( v10 )
    {
      v8 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_1102C(*((_QWORD *)off_5F148 + 35), 0x4Cu, (__int64)&unk_4DCB8, v10);
        v8 = (void **)off_5F148;
      }
    }
    else
    {
      v11 = v23[0];
      *a4 = 171;
      if ( !v11[3] )
      {
        v8 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
          && *((_BYTE *)off_5F148 + 297) >= 2u )
        {
          sub_11008(*((_QWORD *)off_5F148 + 35), 0x4Du, (__int64)&unk_4DCB8);
          v8 = (void **)off_5F148;
        }
        goto LABEL_8;
      }
      v12 = (_WORD *)v11[3];
      v13 = -1i64;
      v14 = -1i64;
      do
      {
        if ( !v14 )
          break;
        v15 = *v12++ == 0;
        --v14;
      }
      while ( !v15 );
      v16 = 2 * ~(_DWORD)v14;
      *a4 = v16 + 171;
      v17 = sub_26404(1, v16 + 171, 0x6B52504Eu);
      *a1 = (__int64)v17;
      if ( v17 )
      {
        memset(v17, 0, (unsigned int)*a4);
        v18 = sub_1DAFC(a2, *a1);
        v19 = *a1;
        v9 = v18;
        if ( (int)unknown_libname_2(*a1 + 84, 17i64, 0x7FFFFFFFi64) >= 0 )
          RtlStringCopyWorkerW((NTSTRSAFE_PWSTR)(v19 + 84), 0x11ui64, 0i64, (STRSAFE_PCNZWCH)(a2 + 114), 0x7FFFFFFEui64);
        *(_DWORD *)(*a1 + 118) = a3;
        *(_DWORD *)(*a1 + 122) |= 1u;
        *(_QWORD *)(*a1 + 126) = *(_QWORD *)(a2 + 16);
        if ( (*(_BYTE *)(a2 + 152) & 2) != 0 )
        {
          *(_DWORD *)(*a1 + 122) |= 2u;
          *(_QWORD *)(*a1 + 134) = *(_QWORD *)(a2 + 24);
        }
        *(_DWORD *)(*a1 + 122) |= 4u;
        v20 = (__int64 *)(a2 + 96);
        if ( v20 )
          v13 = *v20;
        *(_QWORD *)(*a1 + 142) = v13;
        *(_DWORD *)(*a1 + 150) = v16;
        *(_DWORD *)(*a1 + 154) = 0;
        *(_DWORD *)(*a1 + 122) &= 0xFFFFFFF7;
        *(_DWORD *)(*a1 + 158) = 0;
        *(_DWORD *)(*a1 + 162) = 0;
        *(_DWORD *)(*a1 + 166) = v16;
        memmove((void *)(*a1 + 170), *((const void **)v23[0] + 3), v16);
        v8 = (void **)off_5F148;
      }
      else
      {
        v8 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
          && *((_BYTE *)off_5F148 + 297) >= 2u )
        {
          sub_11008(*((_QWORD *)off_5F148 + 35), 0x4Eu, (__int64)&unk_4DCB8);
          v8 = (void **)off_5F148;
        }
        v9 = 3;
      }
    }
  }
  else
  {
    if ( v8 != &off_5F148 && _bittest((const signed __int32 *)v8 + 75, 0x12u) && *((_BYTE *)v8 + 297) >= 2u )
    {
      sub_143A4((__int64)v8[35], 0x4Bu, (__int64)&unk_4DCB8, a1, a2);
      v8 = (void **)off_5F148;
    }
    v9 = 4;
  }
LABEL_40:
  if ( v23[0] )
  {
    v21 = sub_34384(v23);
    if ( !v21 )
    {
LABEL_46:
      v8 = (void **)off_5F148;
      goto LABEL_47;
    }
    v8 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148 )
      return v9;
    if ( _bittest((const signed __int32 *)off_5F148 + 75, 0x12u) && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x4Fu, (__int64)&unk_4DCB8, v21);
      goto LABEL_46;
    }
  }
LABEL_47:
  if ( v8 != &off_5F148 && _bittest((const signed __int32 *)v8 + 75, 0x12u) && *((_BYTE *)v8 + 297) >= 5u )
    sub_1102C((__int64)v8[35], 0x50u, (__int64)&unk_4DCB8, v9);
  return v9;
}
// 4C114: using guessed type __int64 __fastcall unknown_libname_2(_QWORD, _QWORD, _QWORD);
// 5F148: using guessed type void *off_5F148;

//----- (00000000000222C0) ----------------------------------------------------
__int64 __fastcall sub_222C0(PVOID *a1)
{
  unsigned int v2; // ebx
  void **v3; // rcx

  v2 = 0;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x51u, (__int64)&unk_4DCB8);
    v3 = (void **)off_5F148;
  }
  if ( a1 && *a1 )
  {
    sub_26488(*a1, 0x6B52504Eu);
    *a1 = 0i64;
    v3 = (void **)off_5F148;
  }
  else
  {
    if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x12u) && *((_BYTE *)v3 + 297) >= 5u )
    {
      sub_17984((__int64)v3[35], 0x52u, (__int64)&unk_4DCB8, a1);
      v3 = (void **)off_5F148;
    }
    v2 = 4;
  }
  if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x12u) && *((_BYTE *)v3 + 297) >= 5u )
    sub_1102C((__int64)v3[35], 0x53u, (__int64)&unk_4DCB8, v2);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000223D0) ----------------------------------------------------
__int64 __fastcall sub_223D0(PERESOURCE Resource, __int64 a2)
{
  void **v4; // rcx
  int v5; // eax
  int *v6; // rcx
  unsigned int v7; // ebx
  __int64 v8; // r11
  const char *v9; // rax
  __int64 v10; // r10
  const char *v11; // r8
  char v12; // r11
  int v13; // eax
  __int64 v15; // [rsp+30h] [rbp-58h] BYREF
  int v16[12]; // [rsp+38h] [rbp-50h] BYREF
  __int64 v17; // [rsp+90h] [rbp+8h] BYREF

  v17 = 0i64;
  v15 = 0i64;
  memset(v16, 0, sizeof(v16));
  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x54u, (__int64)&unk_4DCB8);
    v4 = (void **)off_5F148;
  }
  if ( Resource && a2 )
  {
    KeEnterCriticalRegion();
    sub_26C84(Resource);
    v5 = *(_DWORD *)(a2 + 4);
    v6 = (int *)Resource[1].SystemResourcesList.Flink;
    v15 = *(_QWORD *)(a2 + 8);
    v16[0] = v5;
    v7 = sub_431EC(v6, (__int64)&v15, &v17, sub_21398, 0);
    if ( !v7 )
    {
      v8 = v17;
      if ( *(_DWORD *)(v17 + 32) == 3
        && off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
        && *((_BYTE *)off_5F148 + 297) >= 5u )
      {
        sub_34580(*(_DWORD *)(v17 + 12));
        v9 = sub_34580(*(_DWORD *)a2);
        sub_209CC(*(_QWORD *)(v10 + 280), 86i64, (__int64)&unk_4DCB8, v9, v12, v11);
        v8 = v17;
      }
      *(_DWORD *)(v8 + 32) = 3;
      *(_DWORD *)(v17 + 12) = *(_DWORD *)a2;
      v13 = sub_23C04(v17);
      v7 = v13;
      if ( v13
        && off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_1102C(*((_QWORD *)off_5F148 + 35), 0x57u, (__int64)&unk_4DCB8, v13);
      }
    }
    sub_26E34(Resource);
    KeLeaveCriticalRegion();
    v4 = (void **)off_5F148;
  }
  else
  {
    if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x12u) && *((_BYTE *)v4 + 297) >= 2u )
    {
      sub_143A4((__int64)v4[35], 0x55u, (__int64)&unk_4DCB8, Resource, a2);
      v4 = (void **)off_5F148;
    }
    v7 = 4;
  }
  if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x12u) && *((_BYTE *)v4 + 297) >= 5u )
    sub_1102C((__int64)v4[35], 0x58u, (__int64)&unk_4DCB8, v7);
  return v7;
}
// 224F7: variable 'v10' is possibly undefined
// 22511: variable 'v12' is possibly undefined
// 22511: variable 'v11' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (0000000000022628) ----------------------------------------------------
__int64 __fastcall sub_22628(__int64 a1, __int64 a2, _QWORD *a3, _BYTE *a4)
{
  unsigned int v8; // ebx
  void **v9; // r10
  __int64 v10; // r9
  int v11; // eax
  __int64 v12; // r10
  int v13; // ebx
  int v14; // ecx
  unsigned __int16 v15; // dx
  __int64 v16; // r10
  int *v17; // rcx
  __int64 v19; // [rsp+40h] [rbp-58h] BYREF
  int v20[12]; // [rsp+48h] [rbp-50h] BYREF

  v8 = 0;
  v19 = 0i64;
  memset(v20, 0, sizeof(v20));
  v9 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x59u, (__int64)&unk_4DCB8);
    v9 = (void **)off_5F148;
  }
  if ( !a1 || !a2 || !a3 || !a4 )
  {
    if ( v9 != &off_5F148 && _bittest((const signed __int32 *)v9 + 75, 0x12u) && *((_BYTE *)v9 + 297) >= 2u )
    {
      sub_12818((__int64)v9[35], 0x5Au, (__int64)&unk_4DCB8, a1, a2, a3, a4);
      v9 = (void **)off_5F148;
    }
    v8 = 4;
    goto LABEL_73;
  }
  *a4 = 0;
  if ( !_bittest((const signed __int32 *)(a2 + 152), 8u) )
    goto LABEL_22;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    if ( a2 == -96 )
      v10 = -1i64;
    else
      v10 = *(_QWORD *)(a2 + 96);
    sub_20340(*((_QWORD *)off_5F148 + 35), 91i64, (__int64)&unk_4DCB8, v10, *(_QWORD *)(a2 + 88));
  }
  v11 = sub_431EC(*(int **)(a1 + 104), a2, a3, sub_214EC, 0);
  v8 = v11;
  if ( !v11 )
  {
    v9 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
      || *((_BYTE *)off_5F148 + 297) < 5u )
    {
LABEL_23:
      if ( !_bittest((const signed __int32 *)(a2 + 152), 8u) || v8 == 5 )
      {
        v13 = 2;
        if ( v9 != &off_5F148 && _bittest((const signed __int32 *)v9 + 75, 0x12u) && *((_BYTE *)v9 + 297) >= 5u )
        {
          if ( (*(_BYTE *)(a2 + 149) & 0x60) != 0 )
          {
            v14 = 2;
            if ( (*(_BYTE *)(a2 + 149) & 0x60) != 32 )
              v14 = 0;
          }
          else
          {
            v14 = 1;
          }
          sub_347A8(v14);
          sub_20394(*(_QWORD *)(v16 + 280), 0x5Fu, (__int64)&unk_4DCB8);
        }
        if ( a2 == -96 )
          v19 = -1i64;
        else
          v19 = *(_QWORD *)(a2 + 96);
        if ( (*(_BYTE *)(a2 + 149) & 0x60) != 0 )
        {
          if ( (*(_BYTE *)(a2 + 149) & 0x60) != 32 )
            v13 = 0;
        }
        else
        {
          v13 = 1;
        }
        v17 = *(int **)(a1 + 104);
        v20[0] = v13;
        v11 = sub_431EC(v17, (__int64)&v19, a3, sub_21398, 0);
        v8 = v11;
        if ( !v11 )
        {
          v9 = (void **)off_5F148;
          if ( off_5F148 == &off_5F148 )
            return v8;
          if ( !_bittest((const signed __int32 *)off_5F148 + 75, 0x12u) || *((_BYTE *)off_5F148 + 297) < 5u )
            goto LABEL_73;
          sub_17984(*((_QWORD *)off_5F148 + 35), 0x60u, (__int64)&unk_4DCB8, *a3);
          goto LABEL_43;
        }
        if ( v11 == 5 )
        {
          v9 = (void **)off_5F148;
          if ( off_5F148 == &off_5F148 )
            return v8;
          if ( !_bittest((const signed __int32 *)off_5F148 + 75, 0x12u) || *((_BYTE *)off_5F148 + 297) < 5u )
            goto LABEL_73;
          sub_11008(*((_QWORD *)off_5F148 + 35), 0x61u, (__int64)&unk_4DCB8);
          goto LABEL_43;
        }
        v9 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 )
          return v8;
        if ( !_bittest((const signed __int32 *)off_5F148 + 75, 0x12u) || *((_BYTE *)off_5F148 + 297) < 5u )
          goto LABEL_73;
        v15 = 98;
LABEL_42:
        sub_1102C((__int64)v9[35], v15, (__int64)&unk_4DCB8, v11);
LABEL_43:
        v9 = (void **)off_5F148;
        goto LABEL_73;
      }
      goto LABEL_73;
    }
    sub_347A8(*(_DWORD *)(*a3 + 8i64));
    sub_206FC(*(_QWORD *)(v12 + 280), 92i64, (__int64)&unk_4DCB8);
LABEL_22:
    v9 = (void **)off_5F148;
    goto LABEL_23;
  }
  if ( v11 == 5 )
  {
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
      && *((_BYTE *)off_5F148 + 297) >= 5u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x5Du, (__int64)&unk_4DCB8);
    }
    *a4 = 1;
    goto LABEL_22;
  }
  v9 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return v8;
  if ( _bittest((const signed __int32 *)off_5F148 + 75, 0x12u) && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    v15 = 94;
    goto LABEL_42;
  }
LABEL_73:
  if ( v9 != &off_5F148 && _bittest((const signed __int32 *)v9 + 75, 0x12u) && *((_BYTE *)v9 + 297) >= 5u )
    sub_1102C((__int64)v9[35], 0x63u, (__int64)&unk_4DCB8, v8);
  return v8;
}
// 2278F: variable 'v12' is possibly undefined
// 228C0: variable 'v16' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (0000000000022AB4) ----------------------------------------------------
__int64 __fastcall sub_22AB4(PERESOURCE Resource, __int64 a2, int *a3, int a4)
{
  unsigned int v4; // ebx
  char v9; // bp
  char v10; // r12
  void **v11; // r10
  const char *v12; // rax
  __int64 v13; // r10
  __int64 v14; // r8
  unsigned int v15; // eax
  int v16; // edi
  int *v17; // r10
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  __int64 v21; // r10
  const char *v22; // rax
  __int64 v23; // r11
  _QWORD *v24; // r10
  const char *v25; // r8
  char v26; // bp
  int v27; // er8
  __int64 *v28; // r12
  __int64 v29; // rbp
  __int64 v30; // rdx
  const char *v31; // rax
  __int64 v32; // r10
  unsigned __int16 v33; // dx
  const char *v34; // rax
  __int64 v35; // r10
  const char *v36; // rax
  _QWORD *v37; // r8
  __int64 v38; // r10
  unsigned __int16 v39; // dx
  int v40; // eax
  int v41; // eax
  int v42; // eax
  void **v43; // r10
  const char *v44; // rax
  __int64 v45; // r10
  const char *v46; // rax
  __int64 v48; // [rsp+28h] [rbp-60h]
  __int64 v49; // [rsp+30h] [rbp-58h]
  char v50[4]; // [rsp+40h] [rbp-48h] BYREF
  unsigned int v51; // [rsp+44h] [rbp-44h] BYREF
  __int64 v52; // [rsp+48h] [rbp-40h] BYREF
  __int64 v53; // [rsp+50h] [rbp-38h] BYREF
  PVOID v54; // [rsp+58h] [rbp-30h] BYREF
  char v55; // [rsp+90h] [rbp+8h]

  v4 = 0;
  v54 = 0i64;
  v51 = 0;
  v52 = 0i64;
  v53 = 0i64;
  v9 = 0;
  v50[0] = 0;
  v10 = 0;
  v11 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    v12 = sub_34494(a4);
    sub_2064C(*(_QWORD *)(v13 + 280), 100i64, (__int64)&unk_4DCB8, Resource, a2, v14, v12);
    v11 = (void **)off_5F148;
  }
  if ( !Resource || !a2 || !a3 )
  {
    if ( v11 != &off_5F148 && _bittest((const signed __int32 *)v11 + 75, 0x12u) && *((_BYTE *)v11 + 297) >= 2u )
    {
      sub_143EC((__int64)v11[35], 0x65u, (__int64)&unk_4DCB8, Resource, a2, a3);
      v11 = (void **)off_5F148;
    }
    v4 = 4;
    goto LABEL_136;
  }
  *a3 = 1;
  if ( !(unsigned __int8)sub_2DA90(0x2016011u) )
  {
    v11 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
      && *((_BYTE *)off_5F148 + 297) >= 5u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x66u, (__int64)&unk_4DCB8);
LABEL_142:
      v11 = (void **)off_5F148;
      goto LABEL_143;
    }
    goto LABEL_143;
  }
  *a3 = sub_2DA90(0x2016010u);
  if ( (*(_BYTE *)(a2 + 152) & 1) != 0 )
  {
    KeEnterCriticalRegion();
    sub_26C84(Resource);
    v9 = 1;
    v55 = 1;
    v15 = sub_22628((__int64)Resource, a2, &v52, v50);
    v4 = v15;
    v16 = 2;
    if ( !v15 )
    {
      *(_QWORD *)(v52 + 24) = MEMORY[0xFFFFF78000000014];
      v17 = (int *)v52;
      *a3 = 1073741828;
      v18 = v17[8];
      if ( v18 == 4 )
      {
        if ( _bittest((const signed __int32 *)(a2 + 152), 0xBu) )
        {
          v18 = 3;
        }
        else
        {
          v18 = 1;
          v17[8] = 1;
          *(_DWORD *)(v52 + 12) = 0;
          v17 = (int *)v52;
        }
      }
      v19 = v18 - 1;
      if ( v19 )
      {
        v20 = v19 - 1;
        if ( v20 )
        {
          if ( v20 != 1 )
          {
            v4 = 6;
            if ( off_5F148 != &off_5F148
              && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
              && *((_BYTE *)off_5F148 + 297) >= 3u )
            {
              sub_347A8(v17[2]);
              v22 = sub_23730(*(_DWORD *)(v21 + 32));
              sub_20830(*(_QWORD *)(v23 + 280), 104i64, (__int64)&unk_4DCB8, v22, *v24, v25);
            }
            goto LABEL_137;
          }
          *a3 = v17[3];
        }
        else
        {
          v10 = 1;
        }
        v26 = 0;
LABEL_74:
        if ( v50[0] )
        {
          v4 = sub_23778((__int64)v17, *(_QWORD *)(a2 + 88));
          if ( v4 )
          {
            v11 = (void **)off_5F148;
            if ( off_5F148 != &off_5F148
              && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
              && *((_BYTE *)off_5F148 + 297) >= 2u )
            {
              v36 = sub_347A8(*(_DWORD *)(v52 + 8));
              v39 = 108;
LABEL_80:
              LODWORD(v49) = v4;
              sub_20510(*(_QWORD *)(v38 + 280), v39, (__int64)&unk_4DCB8, *(_QWORD *)(a2 + 8), *v37, v36, v49);
              goto LABEL_57;
            }
            goto LABEL_71;
          }
          v17 = (int *)v52;
        }
        if ( v10 )
        {
          v4 = sub_239B0((__int64)v17, *(_QWORD *)(a2 + 8));
          if ( v4 )
          {
            v11 = (void **)off_5F148;
            if ( off_5F148 != &off_5F148
              && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
              && *((_BYTE *)off_5F148 + 297) >= 2u )
            {
              v36 = sub_347A8(*(_DWORD *)(v52 + 8));
              v39 = 109;
              goto LABEL_80;
            }
            goto LABEL_71;
          }
        }
        sub_26E34(Resource);
        KeLeaveCriticalRegion();
        v55 = 0;
        if ( !v26 )
        {
          v11 = (void **)off_5F148;
          if ( off_5F148 != &off_5F148
            && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
            && *((_BYTE *)off_5F148 + 297) >= 4u )
          {
            sub_11008(*((_QWORD *)off_5F148 + 35), 0x6Eu, (__int64)&unk_4DCB8);
            v11 = (void **)off_5F148;
          }
          v4 = 0;
          goto LABEL_143;
        }
        if ( (unsigned int)dword_5F5E0 > 4 )
          _InterlockedAdd((volatile signed __int32 *)P + 4, 1u);
        v40 = sub_21ED4((__int64 *)&v54, a2, a4, &v51);
        v4 = v40;
        if ( v40 )
        {
          v11 = (void **)off_5F148;
          if ( off_5F148 != &off_5F148
            && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
            && *((_BYTE *)off_5F148 + 297) >= 2u )
          {
            sub_1102C(*((_QWORD *)off_5F148 + 35), 0x71u, (__int64)&unk_4DCB8, v40);
            goto LABEL_57;
          }
          v9 = 0;
LABEL_136:
          if ( !v4 )
            goto LABEL_140;
          goto LABEL_137;
        }
        v41 = sub_2DA90(0x2016003u);
        v42 = sub_308AC(40016, v54, v51, v41, a3);
        if ( v42 )
        {
          v43 = (void **)off_5F148;
          if ( off_5F148 == &off_5F148
            || !_bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
            || *((_BYTE *)off_5F148 + 297) < 2u )
          {
            goto LABEL_111;
          }
          sub_1102C(*((_QWORD *)off_5F148 + 35), 0x72u, (__int64)&unk_4DCB8, v42);
        }
        else
        {
          v43 = (void **)off_5F148;
          if ( off_5F148 == &off_5F148
            || !_bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
            || *((_BYTE *)off_5F148 + 297) < 4u )
          {
            goto LABEL_111;
          }
          v44 = sub_34580(*a3);
          sub_202B4(*(_QWORD *)(v45 + 280), 115i64, (__int64)&unk_4DCB8, *(_QWORD *)(a2 + 8), v44, 0i64);
        }
        v43 = (void **)off_5F148;
LABEL_111:
        if ( !*a3 )
        {
          if ( v43 != &off_5F148 && _bittest((const signed __int32 *)v43 + 75, 0x12u) && *((_BYTE *)v43 + 297) >= 4u )
            sub_17984((__int64)v43[35], 0x74u, (__int64)&unk_4DCB8, *(_QWORD *)(a2 + 8));
          *a3 = sub_2DA90(0x2016010u);
        }
        v4 = sub_222C0(&v54);
        goto LABEL_142;
      }
      *(_QWORD *)(v52 + 16) = MEMORY[0xFFFFF78000000014];
      *(_DWORD *)(v52 + 32) = 2;
      v17 = (int *)v52;
LABEL_73:
      v10 = 1;
      v26 = 1;
      goto LABEL_74;
    }
    if ( v15 == 5 )
    {
      if ( (*(_BYTE *)(a2 + 149) & 0x60) != 0 )
      {
        v27 = 2;
        if ( (*(_BYTE *)(a2 + 149) & 0x60) != 32 )
          v27 = 0;
      }
      else
      {
        v27 = 1;
      }
      v28 = (__int64 *)(a2 + 96);
      v29 = -1i64;
      if ( a2 == -96 )
        v30 = -1i64;
      else
        v30 = *v28;
      v4 = sub_20A84(&v53, v30, v27);
      if ( v4 )
      {
        v11 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
          && *((_BYTE *)off_5F148 + 297) >= 2u )
        {
          if ( (*(_BYTE *)(a2 + 149) & 0x60) != 0 )
          {
            if ( (*(_BYTE *)(a2 + 149) & 0x60) != 32 )
              v16 = 0;
          }
          else
          {
            v16 = 1;
          }
          if ( a2 != -96 )
            v29 = *v28;
          v31 = sub_347A8(v16);
          v33 = 105;
          goto LABEL_56;
        }
      }
      else
      {
        v4 = sub_21C3C((__int64)Resource, v53);
        if ( !v4 )
        {
          *a3 = 1073741828;
          *(_QWORD *)(v53 + 16) = MEMORY[0xFFFFF78000000014];
          *(_DWORD *)(v53 + 32) = 2;
          v17 = (int *)v53;
          v52 = v53;
          goto LABEL_73;
        }
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
          && *((_BYTE *)off_5F148 + 297) >= 2u )
        {
          if ( (*(_BYTE *)(a2 + 149) & 0x60) != 0 )
          {
            if ( (*(_BYTE *)(a2 + 149) & 0x60) != 32 )
              v16 = 0;
          }
          else
          {
            v16 = 1;
          }
          if ( a2 != -96 )
            v29 = *v28;
          v34 = sub_347A8(v16);
          LODWORD(v48) = v4;
          sub_2041C(*(_QWORD *)(v35 + 280), 0x6Au, (__int64)&unk_4DCB8, v29, v34, v48);
        }
        sub_20CF8(&v53);
        v11 = (void **)off_5F148;
        v53 = 0i64;
      }
LABEL_71:
      v9 = 1;
      goto LABEL_136;
    }
    v11 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
      || *((_BYTE *)off_5F148 + 297) < 2u )
    {
      goto LABEL_136;
    }
    if ( (*(_BYTE *)(a2 + 149) & 0x60) != 0 )
    {
      if ( (*(_BYTE *)(a2 + 149) & 0x60) != 32 )
        v16 = 0;
    }
    else
    {
      v16 = 1;
    }
    if ( a2 == -96 )
      v29 = -1i64;
    else
      v29 = *(_QWORD *)(a2 + 96);
    v31 = sub_347A8(v16);
    v33 = 107;
LABEL_56:
    LODWORD(v48) = v4;
    sub_2041C(*(_QWORD *)(v32 + 280), v33, (__int64)&unk_4DCB8, v29, v31, v48);
LABEL_57:
    v11 = (void **)off_5F148;
    v9 = v55;
    goto LABEL_136;
  }
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 2u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x67u, (__int64)&unk_4DCB8);
  }
  v4 = 6;
LABEL_137:
  if ( v53 )
    sub_21D80((__int64)Resource, v53);
  *a3 = sub_2DA90(0x2016010u);
  v11 = (void **)off_5F148;
LABEL_140:
  if ( v9 )
  {
    sub_26E34(Resource);
    KeLeaveCriticalRegion();
    goto LABEL_142;
  }
LABEL_143:
  if ( v11 != &off_5F148 && _bittest((const signed __int32 *)v11 + 75, 0x12u) && *((_BYTE *)v11 + 297) >= 5u )
  {
    if ( a3 )
      v46 = sub_34580(*a3);
    else
      v46 = "NULL";
    sub_20144((__int64)v11[35], 0x76u, (__int64)&unk_4DCB8, v4, v46);
  }
  return v4;
}
// 22B26: variable 'v13' is possibly undefined
// 22B49: variable 'v14' is possibly undefined
// 22D32: variable 'v21' is possibly undefined
// 22D3E: variable 'v23' is possibly undefined
// 22D48: variable 'v24' is possibly undefined
// 22D63: variable 'v25' is possibly undefined
// 22E5B: variable 'v32' is possibly undefined
// 22E75: variable 'v48' is possibly undefined
// 22EF7: variable 'v35' is possibly undefined
// 22FD3: variable 'v38' is possibly undefined
// 22FE3: variable 'v37' is possibly undefined
// 22FF2: variable 'v49' is possibly undefined
// 2320E: variable 'v45' is possibly undefined
// 233DD: variable 'v11' is possibly undefined
// 5F148: using guessed type void *off_5F148;
// 5F5E0: using guessed type int dword_5F5E0;

//----- (0000000000023424) ----------------------------------------------------
__int64 __fastcall sub_23424(PERESOURCE Resource)
{
  unsigned int v2; // edi
  void **v3; // rcx
  signed __int64 v4; // rbx
  __int64 v5; // rsi
  const char *v6; // rax
  __int64 v7; // r10
  const char *v8; // rax
  __int64 v9; // r10
  int v10; // eax
  _QWORD *v12; // [rsp+60h] [rbp+8h] BYREF

  v2 = 0;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x77u, (__int64)&unk_4DCB8);
    v3 = (void **)off_5F148;
  }
  if ( !Resource )
  {
    v2 = 4;
    if ( v3 != &off_5F148 )
    {
      if ( _bittest((const signed __int32 *)v3 + 75, 0x12u) && *((_BYTE *)v3 + 297) >= 2u )
      {
        sub_11008((__int64)v3[35], 0x78u, (__int64)&unk_4DCB8);
        goto LABEL_33;
      }
      goto LABEL_34;
    }
    return v2;
  }
  v12 = 0i64;
  v4 = MEMORY[0xFFFFF78000000014];
  KeEnterCriticalRegion();
  sub_26C84(Resource);
  sub_439A0((__int64)Resource[1].SystemResourcesList.Flink, (__int64)&v12);
  while ( !sub_43C74(v12) )
  {
    v5 = sub_43E74((__int64)v12);
    if ( !v2 )
      v2 = sub_43D50((__int64)v12);
    if ( *(_DWORD *)(v5 + 32) == 2 )
    {
      if ( v4 > *(_QWORD *)(v5 + 16) + 10000 * (unsigned int)sub_2DA90(0x2016018u) )
      {
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
          && *((_BYTE *)off_5F148 + 297) >= 4u )
        {
          v6 = sub_23730(*(_DWORD *)(v5 + 32));
          sub_2090C(*(_QWORD *)(v7 + 280), 121i64, (__int64)&unk_4DCB8, v6);
        }
        *(_DWORD *)(v5 + 32) = 3;
        *(_DWORD *)(v5 + 12) = sub_2DA90(0x2016017u);
        sub_23C04(v5);
        *(_QWORD *)(v5 + 24) = MEMORY[0xFFFFF78000000014];
      }
      goto LABEL_31;
    }
    if ( v4 <= *(_QWORD *)(v5 + 24) + 10000 * (unsigned int)sub_2DA90(0x2016013u) )
    {
LABEL_31:
      if ( v2 )
        break;
    }
    else
    {
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
        && *((_BYTE *)off_5F148 + 297) >= 4u )
      {
        v8 = sub_23730(*(_DWORD *)(v5 + 32));
        sub_20788(*(_QWORD *)(v9 + 280), 122i64, (__int64)&unk_4DCB8, v8);
      }
      sub_23C04(v5);
      v10 = sub_21D80((__int64)Resource, v5);
      v2 = v10;
      if ( v10 )
      {
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
          && *((_BYTE *)off_5F148 + 297) >= 2u )
        {
          sub_1102C(*((_QWORD *)off_5F148 + 35), 0x7Bu, (__int64)&unk_4DCB8, v10);
        }
        goto LABEL_31;
      }
    }
  }
  sub_43B64((__int64 *)&v12);
  sub_26E34(Resource);
  KeLeaveCriticalRegion();
LABEL_33:
  v3 = (void **)off_5F148;
LABEL_34:
  if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x12u) && *((_BYTE *)v3 + 297) >= 5u )
    sub_1102C((__int64)v3[35], 0x7Cu, (__int64)&unk_4DCB8, v2);
  return v2;
}
// 2358D: variable 'v7' is possibly undefined
// 23634: variable 'v9' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (0000000000023730) ----------------------------------------------------
const char *__fastcall sub_23730(int a1)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx

  if ( a1 )
  {
    v1 = a1 - 1;
    if ( !v1 )
      return "ASK_PENDING";
    v2 = v1 - 1;
    if ( !v2 )
      return "ASK_REQUESTED";
    v3 = v2 - 1;
    if ( !v3 )
      return "RESPONDED";
    if ( v3 == 1 )
      return "TIMED_OUT";
  }
  return "UNKNOWN";
}

//----- (0000000000023778) ----------------------------------------------------
__int64 __fastcall sub_23778(__int64 a1, __int64 a2)
{
  void **v3; // r10
  unsigned int v4; // ebx
  const char *v5; // rax
  __int64 v6; // r10
  unsigned int v7; // eax
  unsigned __int16 v8; // dx
  __int64 v10; // [rsp+20h] [rbp-28h]
  __int64 v11; // [rsp+50h] [rbp+8h] BYREF
  __int64 v12; // [rsp+58h] [rbp+10h]

  v12 = a2;
  v11 = 0i64;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x7Du, (__int64)&unk_4DCB8);
    v3 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x12u) && *((_BYTE *)v3 + 297) >= 2u )
    {
      sub_11008((__int64)v3[35], 0x7Eu, (__int64)&unk_4DCB8);
      v3 = (void **)off_5F148;
    }
    v4 = 4;
    goto LABEL_32;
  }
  if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x12u) && *((_BYTE *)v3 + 297) >= 5u )
  {
    v5 = sub_347A8(*(_DWORD *)(a1 + 8));
    sub_20394(*(_QWORD *)(v6 + 280), 0x7Fu, (__int64)&unk_4DCB8, *(_QWORD *)a1, v5);
  }
  v7 = sub_20EA4(&v11, v12);
  v4 = v7;
  if ( v7 )
  {
    v3 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
      && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      v8 = 128;
LABEL_20:
      LODWORD(v10) = v7;
      sub_204BC((__int64)v3[35], v8, (__int64)&unk_4DCB8, v12, v10);
LABEL_30:
      v3 = (void **)off_5F148;
      goto LABEL_31;
    }
  }
  else
  {
    v7 = sub_42D48(*(int **)(a1 + 40), v11, (__int64 (__fastcall *)(_QWORD, _QWORD))sub_216C0);
    v4 = v7;
    if ( !v7 )
    {
      v3 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v4;
      if ( !_bittest((const signed __int32 *)off_5F148 + 75, 0x12u) || *((_BYTE *)off_5F148 + 297) < 5u )
        goto LABEL_34;
      sub_17984(*((_QWORD *)off_5F148 + 35), 0x82u, (__int64)&unk_4DCB8, v12);
      goto LABEL_30;
    }
    v3 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
      && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      v8 = 129;
      goto LABEL_20;
    }
  }
LABEL_31:
  if ( v4 )
  {
LABEL_32:
    if ( v11 )
    {
      sub_21014((PVOID *)&v11);
      v3 = (void **)off_5F148;
    }
  }
LABEL_34:
  if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x12u) && *((_BYTE *)v3 + 297) >= 5u )
    sub_1102C((__int64)v3[35], 0x83u, (__int64)&unk_4DCB8, v4);
  return v4;
}
// 23844: variable 'v6' is possibly undefined
// 238B7: variable 'v10' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (00000000000239B0) ----------------------------------------------------
__int64 __fastcall sub_239B0(__int64 a1, __int64 a2)
{
  void **v4; // r10
  unsigned int v5; // ebx
  const char *v6; // rax
  __int64 v7; // r10
  __int64 v8; // r8
  unsigned int v9; // eax
  unsigned __int16 v10; // dx
  __int64 v12; // [rsp+20h] [rbp-38h]
  __int64 v13; // [rsp+60h] [rbp+8h] BYREF

  v13 = 0i64;
  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x84u, (__int64)&unk_4DCB8);
    v4 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x12u) && *((_BYTE *)v4 + 297) >= 2u )
    {
      sub_11008((__int64)v4[35], 0x85u, (__int64)&unk_4DCB8);
      v4 = (void **)off_5F148;
    }
    v5 = 4;
    goto LABEL_32;
  }
  if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x12u) && *((_BYTE *)v4 + 297) >= 5u )
  {
    sub_347A8(*(_DWORD *)(a1 + 8));
    v6 = sub_23730(*(_DWORD *)(a1 + 32));
    sub_201C4(*(_QWORD *)(v7 + 280), 134i64, (__int64)&unk_4DCB8, a2, a1, v6, *(_QWORD *)a1, v8);
  }
  v9 = sub_21120(&v13, a2);
  v5 = v9;
  if ( v9 )
  {
    v4 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
      && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      v10 = 135;
LABEL_20:
      LODWORD(v12) = v9;
      sub_204BC((__int64)v4[35], v10, (__int64)&unk_4DCB8, a2, v12);
LABEL_30:
      v4 = (void **)off_5F148;
      goto LABEL_31;
    }
  }
  else
  {
    v9 = sub_42D48(*(int **)(a1 + 48), v13, 0i64);
    v5 = v9;
    if ( !v9 )
    {
      v4 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v5;
      if ( !_bittest((const signed __int32 *)off_5F148 + 75, 0x12u) || *((_BYTE *)off_5F148 + 297) < 5u )
        goto LABEL_34;
      sub_17984(*((_QWORD *)off_5F148 + 35), 0x89u, (__int64)&unk_4DCB8, a2);
      goto LABEL_30;
    }
    v4 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
      && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      v10 = 136;
      goto LABEL_20;
    }
  }
LABEL_31:
  if ( v5 )
  {
LABEL_32:
    if ( v13 )
    {
      sub_2128C((PVOID *)&v13);
      v4 = (void **)off_5F148;
    }
  }
LABEL_34:
  if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x12u) && *((_BYTE *)v4 + 297) >= 5u )
    sub_1102C((__int64)v4[35], 0x8Au, (__int64)&unk_4DCB8, v5);
  return v5;
}
// 23A89: variable 'v7' is possibly undefined
// 23AB5: variable 'v8' is possibly undefined
// 23B10: variable 'v12' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (0000000000023C04) ----------------------------------------------------
__int64 __fastcall sub_23C04(__int64 a1)
{
  unsigned int v2; // ebp
  __int64 *v3; // rax
  int v4; // ecx
  int v5; // eax
  int v6; // eax
  void **v7; // r10
  const char *v8; // rax
  __int64 v9; // r10
  __int64 v10; // r12
  PVOID **v11; // rdi
  PVOID *v12; // rsi
  __int64 v13; // rcx
  PVOID *v14; // rax
  __int64 i; // rbx
  __int64 v17; // [rsp+30h] [rbp-38h] BYREF
  int v18; // [rsp+38h] [rbp-30h]
  int v19; // [rsp+70h] [rbp+8h] BYREF
  PVOID **v20; // [rsp+78h] [rbp+10h] BYREF

  v20 = 0i64;
  v2 = sub_439A0(*(_QWORD *)(a1 + 48), (__int64)&v20);
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x8Bu, (__int64)&unk_4DCB8);
  }
  while ( !v2 )
  {
    if ( sub_43C74(v20) )
      break;
    v3 = (__int64 *)sub_43E74((__int64)v20);
    v17 = 0i64;
    v18 = 0;
    v4 = *(_DWORD *)(a1 + 12);
    v19 = 1;
    v18 = v4;
    v17 = *v3;
    v5 = sub_2DA90(0x2016012u);
    v6 = sub_308AC(40004, &v17, 0xCu, v5, &v19);
    v2 = v6;
    if ( v6 )
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148
        || !_bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
        || *((_BYTE *)off_5F148 + 297) < 2u )
      {
        goto LABEL_17;
      }
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x8Cu, (__int64)&unk_4DCB8, v6);
    }
    else
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148
        || !_bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
        || *((_BYTE *)off_5F148 + 297) < 4u )
      {
        goto LABEL_17;
      }
      v8 = sub_34580(v18);
      sub_205C0(*(_QWORD *)(v9 + 280), 141i64, (__int64)&unk_4DCB8, v17, v8, 0i64);
    }
    v7 = (void **)off_5F148;
LABEL_17:
    v10 = 0i64;
    if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 172) & 0x10) != 0 && *((_BYTE *)v7 + 169) >= 5u )
    {
      sub_143A4((__int64)v7[19], 0x55u, (__int64)&unk_4DBC8, &v20, sub_2128C);
      v7 = (void **)off_5F148;
    }
    v11 = v20;
    if ( v20 )
    {
      v12 = v20[1];
      if ( sub_2128C )
        sub_2128C(*v20);
      v13 = (__int64)v12[1];
      v14 = *v11;
      for ( i = v13; (PVOID *)i != v14; i = *(_QWORD *)(i + 8) )
        v10 = i;
      if ( v12[2] == v14 )
        v12[2] = (PVOID)v10;
      if ( v13 == i )
        v12[1] = *(PVOID *)(v13 + 8);
      if ( v10 )
        *(_QWORD *)(v10 + 8) = *(_QWORD *)(i + 8);
      sub_43D50((__int64)v20);
      sub_269B0((__int64)qword_62088, i);
      --*((_DWORD *)v12 + 6);
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x10) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x57u, (__int64)&unk_4DBC8, *((_DWORD *)v12 + 6));
    }
    else if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 172) & 0x10) != 0 && *((_BYTE *)v7 + 169) >= 2u )
    {
      sub_11008((__int64)v7[19], 0x56u, (__int64)&unk_4DBC8);
    }
  }
  sub_43B64((__int64 *)&v20);
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x12u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x8Eu, (__int64)&unk_4DCB8, v2);
  }
  return v2;
}
// 23D68: variable 'v9' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (0000000000023F38) ----------------------------------------------------
__int64 __fastcall sub_23F38(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+98h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DCA8, 44i64, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000023FA8) ----------------------------------------------------
__int64 __fastcall sub_23FA8(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4)
{
  __int64 v5; // rcx
  const wchar_t *v6; // rdi
  bool v7; // zf

  if ( a4 && *a4 )
  {
    v5 = -1i64;
    v6 = a4;
    do
    {
      if ( !v5 )
        break;
      v7 = *v6++ == 0;
      --v5;
    }
    while ( !v7 );
  }
  if ( a4 )
  {
    if ( !*a4 )
      a4 = L"<NULL>";
  }
  else
  {
    a4 = L"NULL";
  }
  return qword_5F3B8(a1, 43i64, a3, a2, a4);
}
// 4C6E0: using guessed type wchar_t aNull_4[7];
// 4C6F0: using guessed type wchar_t aNull[5];
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000024040) ----------------------------------------------------
__int64 __fastcall sub_24040(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4)
{
  __int64 v5; // rcx
  const wchar_t *v6; // rdi
  bool v7; // zf

  if ( a4 && *a4 )
  {
    v5 = -1i64;
    v6 = a4;
    do
    {
      if ( !v5 )
        break;
      v7 = *v6++ == 0;
      --v5;
    }
    while ( !v7 );
  }
  if ( a4 )
  {
    if ( !*a4 )
      a4 = L"<NULL>";
  }
  else
  {
    a4 = L"NULL";
  }
  return qword_5F3B8(a1, 43i64, &unk_4DCA8, 41i64, a4);
}
// 4C6E0: using guessed type wchar_t aNull_4[7];
// 4C6F0: using guessed type wchar_t aNull[5];
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000024104) ----------------------------------------------------
__int64 __fastcall sub_24104(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 (__fastcall *a5)(__int64 a1, __int64 a2))
{
  int v6; // [rsp+88h] [rbp+20h] BYREF

  v6 = a4;
  a5 = sub_1B7C4;
  return qword_5F3B8(a1, 43i64, &unk_4DCA8, 23i64, &v6);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000024174) ----------------------------------------------------
__int64 sub_24174()
{
  unsigned int v0; // ebx
  void **v1; // rcx
  PVOID v2; // rax

  v0 = 0;
  v1 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x13u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xAu, (__int64)&unk_4DCA8);
    v1 = (void **)off_5F148;
  }
  if ( Dst )
  {
    if ( v1 != &off_5F148 && _bittest((const signed __int32 *)v1 + 75, 0x13u) && *((_BYTE *)v1 + 297) >= 2u )
    {
      sub_11008((__int64)v1[35], 0xBu, (__int64)&unk_4DCA8);
      v1 = (void **)off_5F148;
    }
    v0 = 16;
  }
  else
  {
    v2 = sub_26404(1, 0x1F0u, 0x6C5A504Eu);
    Dst = v2;
    if ( v2 )
    {
      memset(v2, 0, 0x1F0ui64);
      v1 = (void **)off_5F148;
      byte_5F495 = 0;
    }
    else
    {
      v1 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x13u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_1102C(*((_QWORD *)off_5F148 + 35), 0xCu, (__int64)&unk_4DCA8, 496);
        v1 = (void **)off_5F148;
      }
      v0 = 3;
    }
  }
  if ( v1 != &off_5F148 && _bittest((const signed __int32 *)v1 + 75, 0x13u) && *((_BYTE *)v1 + 297) >= 5u )
    sub_1102C((__int64)v1[35], 0xDu, (__int64)&unk_4DCA8, v0);
  return v0;
}
// 5F148: using guessed type void *off_5F148;
// 5F495: using guessed type char byte_5F495;

//----- (00000000000242E8) ----------------------------------------------------
__int64 __fastcall sub_242E8(wchar_t *a1, char *a2)
{
  void **v4; // rcx
  unsigned int v5; // ebx
  int v6; // eax
  _DWORD *v7; // r8
  char v9; // [rsp+60h] [rbp+18h] BYREF
  __int64 v10; // [rsp+68h] [rbp+20h] BYREF

  v9 = -1;
  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x13u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_23FA8(*((_QWORD *)off_5F148 + 35), 0x11u, (__int64)&unk_4DCA8, a1);
    v4 = (void **)off_5F148;
  }
  if ( !Dst )
  {
    if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x13u) && *((_BYTE *)v4 + 297) >= 2u )
    {
      sub_11008((__int64)v4[35], 0x12u, (__int64)&unk_4DCA8);
      v4 = (void **)off_5F148;
    }
    v5 = 16;
    goto LABEL_34;
  }
  if ( !a2 )
  {
    if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x13u) && *((_BYTE *)v4 + 297) >= 2u )
    {
      sub_11008((__int64)v4[35], 0x13u, (__int64)&unk_4DCA8);
      v4 = (void **)off_5F148;
    }
    v5 = 4;
    goto LABEL_34;
  }
  v6 = sub_24BCC(a1, a2, &v10, &v9);
  v7 = Dst;
  v5 = v6;
  if ( !v6 )
    goto LABEL_32;
  if ( v6 == 5 )
  {
    if ( v9 == -1 )
    {
      v4 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x13u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x15u, (__int64)&unk_4DCA8);
        v4 = (void **)off_5F148;
      }
      v5 = 10;
      goto LABEL_34;
    }
    if ( (unsigned __int8)byte_5F495 <= v9 )
      byte_5F495 = v9 + 1;
    v5 = 0;
    *((_QWORD *)Dst + 2 * v9) = v10;
    *a2 = v9;
LABEL_32:
    ++v7[4 * (unsigned __int8)*a2 + 2];
    goto LABEL_33;
  }
  v4 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return v5;
  if ( _bittest((const signed __int32 *)off_5F148 + 75, 0x13u) && *((_BYTE *)off_5F148 + 297) >= 2u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 35), 0x14u, (__int64)&unk_4DCA8, v6);
LABEL_33:
    v4 = (void **)off_5F148;
  }
LABEL_34:
  if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x13u) && *((_BYTE *)v4 + 297) >= 5u )
    sub_127D0((__int64)v4[35], 0x16u, (__int64)&unk_4DCA8, v5);
  return v5;
}
// 5F148: using guessed type void *off_5F148;
// 5F495: using guessed type char byte_5F495;

//----- (0000000000024530) ----------------------------------------------------
__int64 __fastcall sub_24530(unsigned __int8 a1, __int64 a2, __int64 a3)
{
  unsigned int v5; // ebx
  void **v6; // r10
  _QWORD *v7; // r8
  unsigned __int8 v8; // dl
  int v9; // eax
  int v10; // eax
  void *v11; // rcx
  int v12; // eax
  __int16 v13; // cx
  bool v14; // sf

  v5 = 0;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x13u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_24104(*((_QWORD *)off_5F148 + 35), 23i64, (__int64)&unk_4DCA8, a1, sub_1B7C4);
    v6 = (void **)off_5F148;
  }
  v7 = Dst;
  if ( !Dst )
  {
    if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 75, 0x13u) && *((_BYTE *)v6 + 297) >= 2u )
    {
      sub_11008((__int64)v6[35], (_WORD)Dst + 24, (__int64)&unk_4DCA8);
      v6 = (void **)off_5F148;
    }
    v5 = 16;
    goto LABEL_36;
  }
  v8 = byte_5F495;
  if ( a1 < (unsigned __int8)byte_5F495 )
  {
    v9 = *((_DWORD *)Dst + 4 * a1 + 2);
    if ( v9 )
    {
      v10 = v9 - 1;
      *((_DWORD *)Dst + 4 * a1 + 2) = v10;
      if ( v10 )
      {
        v6 = (void **)off_5F148;
        goto LABEL_36;
      }
      v11 = off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x13u)
        && *((_BYTE *)off_5F148 + 297) >= 4u )
      {
        sub_1102C(*((_QWORD *)off_5F148 + 35), 0x1Au, (__int64)&unk_4DCA8, a1);
        v7 = Dst;
        v8 = byte_5F495;
      }
      v7[2 * a1] = 0i64;
      if ( sub_1B7C4 )
      {
        LOBYTE(v11) = a1;
        v12 = sub_1B7C4((__int64)v11, a3);
        v5 = v12;
        v6 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148
          || !_bittest((const signed __int32 *)off_5F148 + 75, 0x13u)
          || *((_BYTE *)off_5F148 + 297) < 4u )
        {
          v7 = Dst;
          v8 = byte_5F495;
          goto LABEL_24;
        }
        sub_1102C(*((_QWORD *)off_5F148 + 35), 0x1Bu, (__int64)&unk_4DCA8, v12);
        v7 = Dst;
        v8 = byte_5F495;
      }
      v6 = (void **)off_5F148;
LABEL_24:
      if ( a1 == v8 - 1 )
      {
        v13 = v8 - 1;
        if ( v13 >= 0 )
        {
          do
          {
            if ( LODWORD(v7[2 * v13 + 1]) )
              break;
            --v8;
            v14 = --v13 < 0;
            byte_5F495 = v8;
          }
          while ( !v14 );
        }
      }
      goto LABEL_36;
    }
  }
  if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 75, 0x13u) && *((_BYTE *)v6 + 297) >= 4u )
  {
    sub_1102C((__int64)v6[35], 0x19u, (__int64)&unk_4DCA8, a1);
    v6 = (void **)off_5F148;
  }
  v5 = 5;
LABEL_36:
  if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 75, 0x13u) && *((_BYTE *)v6 + 297) >= 5u )
    sub_1102C((__int64)v6[35], 0x1Cu, (__int64)&unk_4DCA8, v5);
  return v5;
}
// 2467D: variable 'v11' is possibly undefined
// 5F148: using guessed type void *off_5F148;
// 5F495: using guessed type char byte_5F495;

//----- (00000000000247BC) ----------------------------------------------------
__int64 __fastcall sub_247BC(wchar_t *a1, char *a2)
{
  void **v4; // rcx
  unsigned int v5; // ebx
  unsigned int v6; // eax

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x13u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_23FA8(*((_QWORD *)off_5F148 + 35), 0x1Du, (__int64)&unk_4DCA8, a1);
    v4 = (void **)off_5F148;
  }
  if ( Dst )
  {
    if ( a2 )
    {
      v6 = sub_24BCC(a1, a2, 0i64, 0i64);
      v4 = (void **)off_5F148;
      v5 = v6;
    }
    else
    {
      if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x13u) && *((_BYTE *)v4 + 297) >= 2u )
      {
        sub_11008((__int64)v4[35], 0x1Fu, (__int64)&unk_4DCA8);
        v4 = (void **)off_5F148;
      }
      v5 = 4;
    }
  }
  else
  {
    if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x13u) && *((_BYTE *)v4 + 297) >= 2u )
    {
      sub_11008((__int64)v4[35], 0x1Eu, (__int64)&unk_4DCA8);
      v4 = (void **)off_5F148;
    }
    v5 = 16;
  }
  if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 75, 0x13u) && *((_BYTE *)v4 + 297) >= 5u )
    sub_127D0((__int64)v4[35], 0x20u, (__int64)&unk_4DCA8, v5);
  return v5;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000024920) ----------------------------------------------------
__int64 __fastcall sub_24920(__int64 a1, _BYTE *a2)
{
  unsigned int v4; // ebx
  void **v5; // rcx
  _DWORD *v6; // r8
  unsigned __int16 v7; // dx
  int v8; // edx
  char v9; // cl

  v4 = 0;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x13u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_143A4(*((_QWORD *)off_5F148 + 35), 0x21u, (__int64)&unk_4DCA8, a1, a2);
    v5 = (void **)off_5F148;
  }
  v6 = Dst;
  if ( !Dst )
  {
    if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 75, 0x13u) && *((_BYTE *)v5 + 297) >= 2u )
    {
      sub_11008((__int64)v5[35], (_WORD)Dst + 34, (__int64)&unk_4DCA8);
      v5 = (void **)off_5F148;
    }
    v4 = 16;
    goto LABEL_28;
  }
  if ( !a1 )
  {
    if ( v5 == &off_5F148 || !_bittest((const signed __int32 *)v5 + 75, 0x13u) || *((_BYTE *)v5 + 297) < 2u )
      goto LABEL_17;
    v7 = 35;
LABEL_16:
    sub_11008((__int64)v5[35], v7, (__int64)&unk_4DCA8);
    v5 = (void **)off_5F148;
LABEL_17:
    v4 = 4;
    goto LABEL_28;
  }
  if ( !a2 )
  {
    if ( v5 == &off_5F148 || !_bittest((const signed __int32 *)v5 + 75, 0x13u) || *((_BYTE *)v5 + 297) < 2u )
      goto LABEL_17;
    v7 = 36;
    goto LABEL_16;
  }
  v8 = (unsigned __int8)byte_5F495;
  v9 = 0;
  for ( *a2 = 0; v9 < v8; ++v9 )
  {
    if ( v6[4 * v9 + 2] )
      *(_BYTE *)((unsigned __int8)(*a2)++ + a1) = v9;
  }
  v5 = (void **)off_5F148;
LABEL_28:
  if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 75, 0x13u) && *((_BYTE *)v5 + 297) >= 5u )
    sub_127D0((__int64)v5[35], 0x25u, (__int64)&unk_4DCA8, v4);
  return v4;
}
// 5F148: using guessed type void *off_5F148;
// 5F495: using guessed type char byte_5F495;

//----- (0000000000024AD0) ----------------------------------------------------
__int64 sub_24AD0()
{
  unsigned int v0; // ebx
  void **v1; // rcx

  v0 = 0;
  v1 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x13u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x26u, (__int64)&unk_4DCA8);
    v1 = (void **)off_5F148;
  }
  if ( Dst )
  {
    memset(Dst, 0, 0x1F0ui64);
    v1 = (void **)off_5F148;
    byte_5F495 = 0;
  }
  else
  {
    if ( v1 != &off_5F148 && _bittest((const signed __int32 *)v1 + 75, 0x13u) && *((_BYTE *)v1 + 297) >= 2u )
    {
      sub_11008((__int64)v1[35], 0x27u, (__int64)&unk_4DCA8);
      v1 = (void **)off_5F148;
    }
    v0 = 16;
  }
  if ( v1 != &off_5F148 && _bittest((const signed __int32 *)v1 + 75, 0x13u) && *((_BYTE *)v1 + 297) >= 5u )
    sub_1102C((__int64)v1[35], 0x28u, (__int64)&unk_4DCA8, v0);
  return v0;
}
// 5F148: using guessed type void *off_5F148;
// 5F495: using guessed type char byte_5F495;

//----- (0000000000024BCC) ----------------------------------------------------
__int64 __fastcall sub_24BCC(wchar_t *a1, char *a2, _QWORD *a3, char *a4)
{
  char v8; // si
  void **v9; // rcx
  wchar_t *v10; // r8
  int v11; // ebx
  __int64 v12; // rax
  __int16 v13; // dx
  int v14; // eax
  __int64 v15; // r10
  char v16; // r8
  char v17; // cl
  int v18; // er9
  char v19; // cl
  __int64 v21; // [rsp+70h] [rbp+8h] BYREF

  v8 = -1;
  v9 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x13u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_24040(*((_QWORD *)off_5F148 + 35), 41i64, (__int64)&unk_4DCA8, a1);
    v9 = (void **)off_5F148;
  }
  if ( a1 )
  {
    v10 = a1;
    v11 = 0;
    v12 = 0xFFFFi64;
    do
    {
      if ( !*v10 )
        break;
      ++v10;
      --v12;
    }
    while ( v12 );
    if ( v12 )
    {
      v13 = -1 - v12;
      goto LABEL_14;
    }
    v13 = 0;
  }
  else
  {
    v13 = v21;
  }
  v11 = -1073741811;
LABEL_14:
  if ( v11 >= 0 )
  {
    v14 = sub_4ACDC(a1, v13, 0i64, (ULONG *)&v21);
    v11 = v14;
    if ( v14 )
    {
      v9 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return (unsigned int)v11;
      if ( _bittest((const signed __int32 *)off_5F148 + 75, 0x13u) && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_1102C(*((_QWORD *)off_5F148 + 35), 0x2Bu, (__int64)&unk_4DCA8, v14);
        v9 = (void **)off_5F148;
      }
    }
    else
    {
      v15 = v21;
      if ( a3 )
        *a3 = v21;
      v16 = byte_5F495;
      v17 = 0;
      v18 = (unsigned __int8)byte_5F495;
      if ( byte_5F495 )
      {
        while ( *((_QWORD *)Dst + 2 * v17) != v15 || !*((_DWORD *)Dst + 4 * v17 + 2) )
        {
          if ( v8 == -1 )
          {
            v8 = -1;
            if ( !*((_DWORD *)Dst + 4 * v17 + 2) )
              v8 = v17;
          }
          if ( ++v17 >= (int)(unsigned __int8)byte_5F495 )
            goto LABEL_40;
        }
        *a2 = v17;
      }
LABEL_40:
      if ( v17 >= v18 )
      {
        v11 = 5;
        if ( (unsigned __int8)v16 < 0x1Fu )
        {
          v19 = v8;
          if ( v8 == -1 )
            v19 = v16;
          v8 = v19;
        }
        if ( a4 )
          *a4 = v8;
      }
      v9 = (void **)off_5F148;
    }
  }
  else
  {
    if ( v9 != &off_5F148 && _bittest((const signed __int32 *)v9 + 75, 0x13u) && *((_BYTE *)v9 + 297) >= 2u )
    {
      sub_1102C((__int64)v9[35], 0x2Au, (__int64)&unk_4DCA8, v11);
      v9 = (void **)off_5F148;
    }
    if ( _bittest(&v11, 0x1Du) )
    {
      v11 = (unsigned __int16)v11;
    }
    else if ( (v11 & 0xC0000000) != 0 )
    {
      v11 = 4;
    }
    else
    {
      v11 = 0;
    }
  }
  if ( v9 != &off_5F148 && _bittest((const signed __int32 *)v9 + 75, 0x13u) && *((_BYTE *)v9 + 297) >= 5u )
    sub_23F38((__int64)v9[35], 44i64, (__int64)&unk_4DCA8, v11);
  return (unsigned int)v11;
}
// 24CF2: conditional instruction was optimized away because of 'ebx.4==C000000D'
// 5F148: using guessed type void *off_5F148;
// 5F495: using guessed type char byte_5F495;

//----- (0000000000024EEC) ----------------------------------------------------
__int64 sub_24EEC(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  __int64 v4; // rcx
  _WORD *v5; // rdi
  bool v6; // zf
  __int64 v8; // [rsp+78h] [rbp+20h] BYREF
  va_list va; // [rsp+78h] [rbp+20h]
  _WORD *v10; // [rsp+80h] [rbp+28h]
  va_list va1; // [rsp+88h] [rbp+30h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _WORD *);
  if ( v10 && *v10 )
  {
    v4 = -1i64;
    v5 = v10;
    do
    {
      if ( !v4 )
        break;
      v6 = *v5++ == 0;
      --v4;
    }
    while ( !v6 );
  }
  return qword_5F3B8(a1, 43i64, &unk_4DC98, a2, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000024F94) ----------------------------------------------------
__int64 __fastcall sub_24F94(__int64 a1, __int64 a2, __int64 a3, int a4, char a5, _WORD *a6)
{
  __int64 v7; // rcx
  _WORD *v8; // rdi
  bool v9; // zf
  int v11; // [rsp+88h] [rbp+20h] BYREF

  v11 = a4;
  if ( a6 && *a6 )
  {
    v7 = -1i64;
    v8 = a6;
    do
    {
      if ( !v7 )
        break;
      v9 = *v8++ == 0;
      --v7;
    }
    while ( !v9 );
  }
  return qword_5F3B8(a1, 43i64, &unk_4DC98, 63i64, &v11);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000025058) ----------------------------------------------------
__int64 __fastcall sub_25058(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+88h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DC98, a2, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000250B4) ----------------------------------------------------
__int64 sub_250B4()
{
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xAu, (__int64)&unk_4DC98);
  }
  sub_26ADC(&stru_620A8);
  byte_620A0 = 1;
  sub_25248(1);
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xBu, (__int64)&unk_4DC98);
  }
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;
// 620A0: using guessed type char byte_620A0;

//----- (0000000000025160) ----------------------------------------------------
__int64 sub_25160()
{
  void **v0; // rcx

  v0 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xCu, (__int64)&unk_4DC98);
    v0 = (void **)off_5F148;
  }
  if ( qword_62110 )
  {
    sub_26488(qword_62110, 0x614C504Eu);
    qword_62110 = 0i64;
    v0 = (void **)off_5F148;
  }
  if ( byte_620A0 )
  {
    sub_26BB0(&stru_620A8);
    v0 = (void **)off_5F148;
    byte_620A0 = 0;
  }
  if ( v0 != &off_5F148 && _bittest((const signed __int32 *)v0 + 75, 0x16u) && *((_BYTE *)v0 + 297) >= 5u )
    sub_11008((__int64)v0[35], 0xDu, (__int64)&unk_4DC98);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;
// 620A0: using guessed type char byte_620A0;

//----- (0000000000025248) ----------------------------------------------------
__int64 __fastcall sub_25248(char a1)
{
  unsigned int v2; // ebx
  PVOID v3; // rax
  _DWORD *v4; // rax

  v2 = 0;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0xEu, (__int64)&unk_4DC98);
  }
  KeEnterCriticalRegion();
  sub_26C84(&stru_620A8);
  v3 = qword_62110;
  if ( qword_62110 )
  {
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
      && *((_BYTE *)off_5F148 + 297) >= 4u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0xFu, (__int64)&unk_4DC98);
      v3 = qword_62110;
    }
    sub_26488(v3, 0x614C504Eu);
    qword_62110 = 0i64;
  }
  if ( a1 )
  {
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
      && *((_BYTE *)off_5F148 + 297) >= 4u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x10u, (__int64)&unk_4DC98);
    }
    v4 = sub_26404(2, 0xDu, 0x614C504Eu);
    qword_62110 = v4;
    if ( v4 )
    {
      *v4 = 1;
      *((_DWORD *)qword_62110 + 1) = 13;
      *((_DWORD *)qword_62110 + 2) = 0;
    }
    else
    {
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x11u, (__int64)&unk_4DC98);
      }
      v2 = 3;
    }
  }
  sub_26E34(&stru_620A8);
  KeLeaveCriticalRegion();
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x12u, (__int64)&unk_4DC98);
  }
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000025448) ----------------------------------------------------
__int64 __fastcall sub_25448(__int64 a1, char a2)
{
  unsigned int v4; // ebx
  void **v5; // rcx
  __int64 result; // rax
  PVOID v7; // rax
  int v8; // eax

  v4 = 0;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x13u, (__int64)&unk_4DC98);
    v5 = (void **)off_5F148;
  }
  if ( a1 )
  {
    if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 75, 0x16u) && *((_BYTE *)v5 + 297) >= 4u )
      sub_25058((__int64)v5[35], 0x15u, (__int64)&unk_4DC98, *(_DWORD *)a1);
    if ( (unsigned __int8)sub_2DA90(0x201601Bu) )
    {
      if ( *(_DWORD *)a1 == 1 )
      {
        sub_25248(0);
        KeEnterCriticalRegion();
        sub_26C84(&stru_620A8);
        v7 = sub_26404(2, *(_DWORD *)(a1 + 4), 0x614C504Eu);
        qword_62110 = v7;
        if ( v7 )
        {
          sub_4B4A8(v7, *(unsigned int *)(a1 + 4), (const void *)a1, *(unsigned int *)(a1 + 4));
        }
        else
        {
          if ( off_5F148 != &off_5F148
            && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
            && *((_BYTE *)off_5F148 + 297) >= 2u )
          {
            sub_11008(*((_QWORD *)off_5F148 + 35), 0x18u, (__int64)&unk_4DC98);
          }
          v4 = 3;
        }
        sub_26E34(&stru_620A8);
        KeLeaveCriticalRegion();
      }
      else
      {
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
          && *((_BYTE *)off_5F148 + 297) >= 2u )
        {
          sub_127D0(*((_QWORD *)off_5F148 + 35), 0x17u, (__int64)&unk_4DC98, *(_DWORD *)a1);
        }
        v4 = 25;
      }
    }
    else
    {
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x16u, (__int64)&unk_4DC98);
      }
      v4 = 7;
    }
    if ( a2 )
    {
      v8 = sub_25F94();
      v4 = v8;
      if ( v8 )
      {
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
          && *((_BYTE *)off_5F148 + 297) >= 2u )
        {
          sub_1102C(*((_QWORD *)off_5F148 + 35), 0x19u, (__int64)&unk_4DC98, v8);
        }
      }
    }
    sub_261B0();
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
      && *((_BYTE *)off_5F148 + 297) >= 5u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x1Au, (__int64)&unk_4DC98);
    }
    result = v4;
  }
  else
  {
    if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 75, 0x16u) && *((_BYTE *)v5 + 297) >= 2u )
      sub_17984((__int64)v5[35], 0x14u, (__int64)&unk_4DC98, 0i64);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000025714) ----------------------------------------------------
__int64 __fastcall sub_25714(__int64 a1, __int64 a2, _WORD *a3)
{
  unsigned int v5; // edi
  void **v6; // rcx
  unsigned int v7; // edx
  unsigned int v8; // eax
  __int16 *v9; // rbx
  __int16 *v10; // rax
  void **v11; // rcx

  v5 = 5;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x1Bu, (__int64)&unk_4DC98);
    v6 = (void **)off_5F148;
  }
  if ( a3 )
  {
    if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 75, 0x16u) && *((_BYTE *)v6 + 297) >= 5u )
      sub_17984((__int64)v6[35], 0x1Du, (__int64)&unk_4DC98, a1);
    KeEnterCriticalRegion();
    sub_26D5C(&stru_620A8);
    if ( qword_62110 )
    {
      v7 = *((_DWORD *)qword_62110 + 2);
      v8 = 0;
      v9 = (__int16 *)((char *)qword_62110 + 12);
      if ( v7 )
      {
        while ( *(_QWORD *)v9 != a1 )
        {
          ++v8;
          v9 += 21;
          if ( v8 >= v7 )
            goto LABEL_24;
        }
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
          && *((_BYTE *)off_5F148 + 297) >= 5u )
        {
          sub_24EEC(*((_QWORD *)off_5F148 + 35), 0x1Eu, (__int64)&unk_4DC98, *(_QWORD *)v9, v9 + 4);
        }
        v5 = 0;
        sub_4B54C(a3, 17i64, v9 + 4);
      }
    }
    else if ( off_5F148 != &off_5F148
           && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
           && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 35), 0x1Fu, (__int64)&unk_4DC98);
    }
LABEL_24:
    sub_26E34(&stru_620A8);
    KeLeaveCriticalRegion();
    if ( v5 )
    {
      v10 = (__int16 *)sub_2E4DC();
      sub_4B54C(a3, 17i64, v10);
      sub_2E6AC();
      v11 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v5;
      if ( !_bittest((const signed __int32 *)off_5F148 + 75, 0x16u) || *((_BYTE *)off_5F148 + 297) < 5u )
      {
LABEL_30:
        if ( v11 != &off_5F148 && _bittest((const signed __int32 *)v11 + 75, 0x16u) && *((_BYTE *)v11 + 297) >= 5u )
          sub_11008((__int64)v11[35], 0x21u, (__int64)&unk_4DC98);
        return v5;
      }
      sub_24EEC(*((_QWORD *)off_5F148 + 35), 0x20u, (__int64)&unk_4DC98, a1, a3);
    }
    v11 = (void **)off_5F148;
    goto LABEL_30;
  }
  if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 75, 0x16u) && *((_BYTE *)v6 + 297) >= 2u )
    sub_17814((__int64)v6[35], 0x1Cu, (__int64)&unk_4DC98, 0i64, 17);
  return 4i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000025994) ----------------------------------------------------
__int64 __fastcall sub_25994(void **a1, _DWORD *a2)
{
  unsigned int v4; // ebx
  void **v5; // rcx
  PVOID v6; // rax
  size_t v7; // rcx

  v4 = 0;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x22u, (__int64)&unk_4DC98);
    v5 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 75, 0x16u) && *((_BYTE *)v5 + 297) >= 5u )
      sub_11008((__int64)v5[35], 0x24u, (__int64)&unk_4DC98);
    if ( !(unsigned __int8)sub_2DA90(0x201601Bu) )
    {
      v5 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x25u, (__int64)&unk_4DC98);
        v5 = (void **)off_5F148;
      }
      v4 = 7;
      goto LABEL_36;
    }
    KeEnterCriticalRegion();
    sub_26D5C(&stru_620A8);
    if ( qword_62110 )
    {
      v6 = sub_26404(2, *((_DWORD *)qword_62110 + 1), 0x614C504Eu);
      *a1 = v6;
      if ( !v6 )
      {
        v5 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
          && *((_BYTE *)off_5F148 + 297) >= 2u )
        {
          sub_11008(*((_QWORD *)off_5F148 + 35), 0x26u, (__int64)&unk_4DC98);
          v5 = (void **)off_5F148;
        }
        v4 = 3;
        goto LABEL_36;
      }
      v7 = *((unsigned int *)qword_62110 + 1);
      *a2 = v7;
      sub_4B4A8(*a1, v7, qword_62110, v7);
    }
    else
    {
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x27u, (__int64)&unk_4DC98);
      }
      v4 = 5;
    }
    sub_26E34(&stru_620A8);
    KeLeaveCriticalRegion();
    v5 = (void **)off_5F148;
    goto LABEL_36;
  }
  if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 75, 0x16u) && *((_BYTE *)v5 + 297) >= 2u )
  {
    sub_143A4((__int64)v5[35], 0x23u, (__int64)&unk_4DC98, a1, a2);
    v5 = (void **)off_5F148;
  }
  v4 = 4;
LABEL_36:
  if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 75, 0x16u) && *((_BYTE *)v5 + 297) >= 5u )
    sub_11008((__int64)v5[35], 0x28u, (__int64)&unk_4DC98);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000025C34) ----------------------------------------------------
__int64 __fastcall sub_25C34(PVOID *a1)
{
  unsigned int v2; // ebx
  void **v3; // rcx

  v2 = 0;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x29u, (__int64)&unk_4DC98);
    v3 = (void **)off_5F148;
  }
  if ( a1 )
  {
    if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x16u) && *((_BYTE *)v3 + 297) >= 5u )
      sub_11008((__int64)v3[35], 0x2Bu, (__int64)&unk_4DC98);
    sub_26488(*a1, 0x614C504Eu);
    *a1 = 0i64;
    v3 = (void **)off_5F148;
  }
  else
  {
    if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x16u) && *((_BYTE *)v3 + 297) >= 2u )
    {
      sub_17984((__int64)v3[35], 0x2Au, (__int64)&unk_4DC98, 0i64);
      v3 = (void **)off_5F148;
    }
    v2 = 4;
  }
  if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x16u) && *((_BYTE *)v3 + 297) >= 5u )
    sub_11008((__int64)v3[35], 0x2Cu, (__int64)&unk_4DC98);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000025D6C) ----------------------------------------------------
__int64 sub_25D6C()
{
  int v0; // eax
  unsigned int v1; // ebx
  void **v2; // rcx
  unsigned __int16 v3; // dx
  int *v4; // rdi
  int v5; // eax
  int v7; // [rsp+50h] [rbp+8h] BYREF
  int *v8; // [rsp+58h] [rbp+10h] BYREF

  v8 = 0i64;
  v7 = 0;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x2Du, (__int64)&unk_4DC98);
  }
  v0 = sub_2DCFC(0i64, 0x201601Cu, &v8, &v7);
  v1 = v0;
  if ( v0 )
  {
    v2 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
      && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      v3 = 46;
LABEL_24:
      sub_1102C((__int64)v2[35], v3, (__int64)&unk_4DC98, v0);
      goto LABEL_25;
    }
    goto LABEL_26;
  }
  v4 = v8;
  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
    && *((_BYTE *)off_5F148 + 297) >= 4u )
  {
    sub_25058(*((_QWORD *)off_5F148 + 35), 0x2Fu, (__int64)&unk_4DC98, *v8);
    v2 = (void **)off_5F148;
  }
  if ( *v4 != 1 )
  {
    if ( v2 == &off_5F148 || !_bittest((const signed __int32 *)v2 + 75, 0x16u) || *((_BYTE *)v2 + 297) < 2u )
      goto LABEL_26;
    sub_127D0((__int64)v2[35], 0x30u, (__int64)&unk_4DC98, *v4);
LABEL_25:
    v2 = (void **)off_5F148;
    goto LABEL_26;
  }
  v0 = sub_25448((__int64)v4, 0);
  v1 = v0;
  if ( !v0 )
    goto LABEL_25;
  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
    && *((_BYTE *)off_5F148 + 297) >= 2u )
  {
    v3 = 49;
    goto LABEL_24;
  }
LABEL_26:
  if ( v8 )
  {
    v5 = sub_2DFD4((__int64)v8);
    v1 = v5;
    if ( v5 )
    {
      v2 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_1102C(*((_QWORD *)off_5F148 + 35), 0x32u, (__int64)&unk_4DC98, v5);
        v2 = (void **)off_5F148;
      }
      v1 = 0;
    }
    else
    {
      v2 = (void **)off_5F148;
    }
  }
  if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 75, 0x16u) && *((_BYTE *)v2 + 297) >= 5u )
    sub_11008((__int64)v2[35], 0x33u, (__int64)&unk_4DC98);
  return v1;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000025F94) ----------------------------------------------------
__int64 sub_25F94()
{
  unsigned int v0; // ebx
  int *v1; // rdi
  int v2; // eax
  void **v3; // rcx

  v0 = 0;
  v1 = 0i64;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
    && *((_BYTE *)off_5F148 + 297) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x34u, (__int64)&unk_4DC98);
  }
  KeEnterCriticalRegion();
  sub_26D5C(&stru_620A8);
  if ( qword_62110 )
  {
    v1 = (int *)sub_26404(2, *((_DWORD *)qword_62110 + 1), 0x614C504Eu);
    if ( !v1 )
    {
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
        && *((_BYTE *)off_5F148 + 297) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 35), 0x35u, (__int64)&unk_4DC98);
      }
      v0 = 3;
    }
    sub_4B4A8(v1, *((unsigned int *)qword_62110 + 1), qword_62110, *((unsigned int *)qword_62110 + 1));
  }
  else if ( off_5F148 != &off_5F148
         && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
         && *((_BYTE *)off_5F148 + 297) >= 2u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x36u, (__int64)&unk_4DC98);
  }
  sub_26E34(&stru_620A8);
  KeLeaveCriticalRegion();
  if ( v0 || (v2 = sub_2E210(0i64, 0x201601Cu, (__int64)v1, v1[1]), (v0 = v2) == 0) )
  {
    v3 = (void **)off_5F148;
  }
  else
  {
    v3 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
      && *((_BYTE *)off_5F148 + 297) >= 2u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x37u, (__int64)&unk_4DC98, v2);
      v3 = (void **)off_5F148;
    }
    v0 = 8;
  }
  if ( v1 )
  {
    sub_26488(v1, 0x614C504Eu);
    v3 = (void **)off_5F148;
  }
  if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 75, 0x16u) && *((_BYTE *)v3 + 297) >= 5u )
    sub_11008((__int64)v3[35], 0x3Cu, (__int64)&unk_4DC98);
  return v0;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000261B0) ----------------------------------------------------
__int64 sub_261B0()
{
  unsigned int v0; // ebx
  _DWORD *v1; // r11
  void **v2; // rcx
  char *v3; // rdi

  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
    && *((_BYTE *)off_5F148 + 297) >= 4u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x3Du, (__int64)&unk_4DC98);
  }
  KeEnterCriticalRegion();
  v0 = 0;
  sub_26D5C(&stru_620A8);
  v1 = qword_62110;
  if ( qword_62110 )
  {
    v2 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
      && *((_BYTE *)off_5F148 + 297) >= 4u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 35), 0x3Eu, (__int64)&unk_4DC98, *((_DWORD *)qword_62110 + 2));
      v2 = (void **)off_5F148;
      v1 = qword_62110;
    }
    v3 = (char *)(v1 + 3);
    if ( v1[2] )
    {
      do
      {
        if ( v2 != &off_5F148 && _bittest((const signed __int32 *)v2 + 75, 0x16u) && *((_BYTE *)v2 + 297) >= 4u )
        {
          sub_24F94((__int64)v2[35], 63i64, (__int64)&unk_4DC98, v0, *(_QWORD *)v3, (_WORD *)v3 + 4);
          v2 = (void **)off_5F148;
          v1 = qword_62110;
        }
        ++v0;
        v3 += 42;
      }
      while ( v0 < v1[2] );
    }
  }
  else if ( off_5F148 != &off_5F148
         && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
         && *((_BYTE *)off_5F148 + 297) >= 3u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x40u, (__int64)&unk_4DC98);
  }
  sub_26E34(&stru_620A8);
  KeLeaveCriticalRegion();
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 75, 0x16u)
    && *((_BYTE *)off_5F148 + 297) >= 4u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 35), 0x41u, (__int64)&unk_4DC98);
  }
  return 5i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000026384) ----------------------------------------------------
__int64 __fastcall sub_26384(__int64 a1, unsigned __int16 a2)
{
  strlen(aUnknownModule);
  return qword_5F3B8(a1, 43i64, &unk_4DC88, a2, aUnknownModule);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000026404) ----------------------------------------------------
PVOID __fastcall sub_26404(int a1, unsigned int a2, ULONG a3)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 4) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_26384(*((_QWORD *)off_5F148 + 11), 0xAu);
  return sub_2772C(a1, a2, a3);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000026488) ----------------------------------------------------
void __fastcall sub_26488(PVOID P, ULONG Tag)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 4) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_26384(*((_QWORD *)off_5F148 + 11), 0xBu);
  sub_27848(P, Tag);
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000264FC) ----------------------------------------------------
PVOID __fastcall sub_264FC(__int64 a1, void *a2, unsigned int a3, unsigned int a4)
{
  size_t v5; // rsi
  void **v7; // rcx
  PVOID v8; // rax
  PVOID v9; // rbx

  v5 = a3;
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 108) & 4) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    {
      sub_26384(*((_QWORD *)off_5F148 + 11), 0xCu);
      v7 = (void **)off_5F148;
    }
    if ( v7 != &off_5F148 )
    {
      if ( (*((_BYTE *)v7 + 108) & 2) != 0 && *((_BYTE *)v7 + 105) >= 4u )
      {
        sub_11008((__int64)v7[11], 0x10u, (__int64)&unk_4DC78);
        v7 = (void **)off_5F148;
      }
      if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 108) & 4) != 0 && *((_BYTE *)v7 + 105) >= 6u )
        sub_27600((__int64)v7[11], 17i64, (__int64)&unk_4DC78, (int)a2);
    }
  }
  v8 = sub_2772C(1, a4, 0x706D744Eu);
  v9 = v8;
  if ( v8 && a2 )
  {
    memmove(v8, a2, v5);
    sub_27848(a2, 0x706D744Eu);
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_1102C(*((_QWORD *)off_5F148 + 11), 0x12u, (__int64)&unk_4DC78, (int)v9);
  return v9;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000026670) ----------------------------------------------------
char *__fastcall sub_26670(__int64 a1, unsigned int a2, ULONG a3)
{
  __int64 v4; // rdi
  void **v5; // rcx
  char *v6; // rbx
  char *v7; // rax

  v4 = a2;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 4) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
  {
    sub_26384(*((_QWORD *)off_5F148 + 11), 0xDu);
    v5 = (void **)off_5F148;
  }
  v6 = 0i64;
  if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 108) & 2) != 0 && *((_BYTE *)v5 + 105) >= 4u )
  {
    sub_11008((__int64)v5[11], 0x13u, (__int64)&unk_4DC78);
    v5 = (void **)off_5F148;
  }
  if ( (_DWORD)v4 )
  {
    v7 = (char *)sub_2772C(2, 0xC0u, a3);
    v6 = v7;
    if ( v7 )
    {
      memset(v7, 0, 0xC0ui64);
      *((_DWORD *)v6 + 1) = v4;
      *(_DWORD *)v6 = 1;
      *((_DWORD *)v6 + 2) = a3;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 108) & 4) == 0 || *((_BYTE *)off_5F148 + 105) < 5u )
        goto LABEL_17;
      sub_11008(*((_QWORD *)off_5F148 + 11), 0x14u, (__int64)&unk_4DC78);
      if ( *(_DWORD *)v6 == 2 )
        ExInitializeNPagedLookasideList((PNPAGED_LOOKASIDE_LIST)(v6 + 64), 0i64, 0i64, 0, v4 + 7, a3, 0);
      if ( *(_DWORD *)v6 == 1 )
LABEL_17:
        ExInitializePagedLookasideList((PPAGED_LOOKASIDE_LIST)(v6 + 64), 0i64, 0i64, 0, v4 + 7, a3, 0);
    }
    v5 = (void **)off_5F148;
  }
  if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 108) & 2) != 0 && *((_BYTE *)v5 + 105) >= 4u )
    sub_1102C((__int64)v5[11], 0x15u, (__int64)&unk_4DC78, (int)v6);
  return v6;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000026828) ----------------------------------------------------
void __fastcall sub_26828(PVOID P)
{
  void **v2; // rcx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 108) & 4) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    {
      sub_26384(*((_QWORD *)off_5F148 + 11), 0xEu);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 )
    {
      if ( (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      {
        sub_11008((__int64)v2[11], 0x16u, (__int64)&unk_4DC78);
        v2 = (void **)off_5F148;
      }
      if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 108) & 4) != 0 && *((_BYTE *)v2 + 105) >= 5u )
        sub_11008((__int64)v2[11], 0x17u, (__int64)&unk_4DC78);
    }
  }
  if ( *(_DWORD *)P == 2 )
  {
    ExDeleteNPagedLookasideList((PNPAGED_LOOKASIDE_LIST)((char *)P + 64));
  }
  else if ( *(_DWORD *)P == 1 )
  {
    ExDeletePagedLookasideList((PPAGED_LOOKASIDE_LIST)((char *)P + 64));
  }
  sub_27848(P, *((_DWORD *)P + 2));
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x18u, (__int64)&unk_4DC78);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000026948) ----------------------------------------------------
_DWORD *__fastcall sub_26948(__int64 a1)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 4) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_26384(*((_QWORD *)off_5F148 + 11), 0xFu);
  return sub_27940(a1);
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000269B0) ----------------------------------------------------
void __fastcall sub_269B0(__int64 a1, __int64 a2)
{
  void **v4; // rcx
  struct _SLIST_ENTRY *v5; // rdi

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 108) & 4) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    {
      sub_26384(*((_QWORD *)off_5F148 + 11), 0x10u);
      v4 = (void **)off_5F148;
    }
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 108) & 2) != 0 && *((_BYTE *)v4 + 105) >= 4u )
    {
      sub_11008((__int64)v4[11], 0x1Bu, (__int64)&unk_4DC78);
      v4 = (void **)off_5F148;
    }
  }
  v5 = (struct _SLIST_ENTRY *)(a2 - 4);
  if ( LODWORD(v5->Next) )
  {
    if ( LODWORD(v5->Next) == 1 )
    {
      sub_27848(v5, *(_DWORD *)(a1 + 8));
LABEL_18:
      v4 = (void **)off_5F148;
      goto LABEL_19;
    }
  }
  else if ( *(_DWORD *)a1 == 2 || *(_DWORD *)a1 == 1 )
  {
    ++*(_DWORD *)(a1 + 92);
    if ( ExQueryDepthSList((PSLIST_HEADER)(a1 + 64)) < *(_WORD *)(a1 + 80) )
    {
      ExpInterlockedPushEntrySList((PSLIST_HEADER)(a1 + 64), v5);
    }
    else
    {
      ++*(_DWORD *)(a1 + 96);
      (*(void (__fastcall **)(struct _SLIST_ENTRY *))(a1 + 120))(v5);
    }
    goto LABEL_18;
  }
LABEL_19:
  if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 108) & 2) != 0 && *((_BYTE *)v4 + 105) >= 4u )
    sub_11008((__int64)v4[11], 0x1Cu, (__int64)&unk_4DC78);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000026ADC) ----------------------------------------------------
__int64 __fastcall sub_26ADC(PERESOURCE Resource)
{
  void **v2; // rcx
  int v3; // eax
  unsigned int v4; // ebx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 108) & 0x20) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    {
      sub_26384(*((_QWORD *)off_5F148 + 11), 0x12u);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x1Fu, (__int64)&unk_4DC78);
  }
  v3 = ExInitializeResourceLite(Resource);
  v4 = v3;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_1102C(*((_QWORD *)off_5F148 + 11), 0x20u, (__int64)&unk_4DC78, v3);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000026BB0) ----------------------------------------------------
__int64 __fastcall sub_26BB0(PERESOURCE Resource)
{
  void **v2; // rcx
  int v3; // eax
  unsigned int v4; // ebx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 108) & 0x20) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    {
      sub_26384(*((_QWORD *)off_5F148 + 11), 0x13u);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x21u, (__int64)&unk_4DC78);
  }
  v3 = ExDeleteResourceLite(Resource);
  v4 = v3;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_1102C(*((_QWORD *)off_5F148 + 11), 0x22u, (__int64)&unk_4DC78, v3);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000026C84) ----------------------------------------------------
BOOLEAN __fastcall sub_26C84(PERESOURCE Resource)
{
  void **v2; // rcx
  BOOLEAN v3; // al
  BOOLEAN v4; // bl

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 108) & 0x20) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    {
      sub_26384(*((_QWORD *)off_5F148 + 11), 0x15u);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x25u, (__int64)&unk_4DC78);
  }
  v3 = ExAcquireResourceExclusiveLite(Resource, 1u);
  v4 = v3;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_1102C(*((_QWORD *)off_5F148 + 11), 0x26u, (__int64)&unk_4DC78, v3);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000026D5C) ----------------------------------------------------
BOOLEAN __fastcall sub_26D5C(PERESOURCE Resource)
{
  void **v2; // rcx
  BOOLEAN v3; // al
  BOOLEAN v4; // bl

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 108) & 0x20) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    {
      sub_26384(*((_QWORD *)off_5F148 + 11), 0x16u);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x27u, (__int64)&unk_4DC78);
  }
  v3 = ExAcquireResourceSharedLite(Resource, 1u);
  v4 = v3;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_1102C(*((_QWORD *)off_5F148 + 11), 0x28u, (__int64)&unk_4DC78, v3);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000026E34) ----------------------------------------------------
void __fastcall sub_26E34(PERESOURCE Resource)
{
  void **v2; // rcx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 108) & 0x20) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    {
      sub_26384(*((_QWORD *)off_5F148 + 11), 0x18u);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x2Bu, (__int64)&unk_4DC78);
  }
  ExReleaseResourceLite(Resource);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x2Cu, (__int64)&unk_4DC78);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000026F00) ----------------------------------------------------
void __fastcall sub_26F00(PKSPIN_LOCK SpinLock, KIRQL *a2)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 0x20) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_26384(*((_QWORD *)off_5F148 + 11), 0x1Bu);
  sub_27AC8(SpinLock, a2);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000026F78) ----------------------------------------------------
void __fastcall sub_26F78(PKSPIN_LOCK SpinLock, KIRQL a2)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 0x20) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_26384(*((_QWORD *)off_5F148 + 11), 0x1Cu);
  sub_27B80(SpinLock, a2);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000026FEC) ----------------------------------------------------
int __fastcall sub_26FEC(PRKEVENT Event)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 0x20) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_26384(*((_QWORD *)off_5F148 + 11), 0x1Fu);
  return sub_27DA4(Event);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000027054) ----------------------------------------------------
int __fastcall sub_27054(PRKEVENT Event)
{
  void **v2; // rcx
  int result; // eax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 108) & 0x20) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    {
      sub_26384(*((_QWORD *)off_5F148 + 11), 0x20u);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x3Bu, (__int64)&unk_4DC78);
  }
  result = KeResetEvent(Event);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    result = sub_11008(*((_QWORD *)off_5F148 + 11), 0x3Cu, (__int64)&unk_4DC78);
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000027120) ----------------------------------------------------
void __fastcall sub_27120(__int64 a1)
{
  void **v2; // rcx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 108) & 0x20) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    {
      sub_26384(*((_QWORD *)off_5F148 + 11), 0x21u);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x3Du, (__int64)&unk_4DC78);
  }
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 1;
  KeInitializeEvent((PRKEVENT)(a1 + 24), SynchronizationEvent, 0);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x3Eu, (__int64)&unk_4DC78);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000027200) ----------------------------------------------------
void __fastcall sub_27200(PFAST_MUTEX FastMutex)
{
  void **v2; // rcx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 108) & 0x20) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    {
      sub_26384(*((_QWORD *)off_5F148 + 11), 0x22u);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x3Fu, (__int64)&unk_4DC78);
  }
  ExAcquireFastMutex(FastMutex);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x40u, (__int64)&unk_4DC78);
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000272CC) ----------------------------------------------------
void __fastcall sub_272CC(PFAST_MUTEX FastMutex)
{
  void **v2; // rcx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 108) & 0x20) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    {
      sub_26384(*((_QWORD *)off_5F148 + 11), 0x24u);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x43u, (__int64)&unk_4DC78);
  }
  ExReleaseFastMutex(FastMutex);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x44u, (__int64)&unk_4DC78);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000027398) ----------------------------------------------------
_QWORD *sub_27398()
{
  PVOID v0; // rsi
  void **v1; // rcx
  _QWORD *v2; // rbx
  _QWORD *v3; // rdi

  v0 = qword_5F498;
  v1 = (void **)off_5F148;
  v2 = 0i64;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 108) < 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
  {
    sub_26384(*((_QWORD *)off_5F148 + 11), 0x2Eu);
    v1 = (void **)off_5F148;
  }
  v3 = 0i64;
  if ( v1 != &off_5F148 && (*((_BYTE *)v1 + 108) & 2) != 0 && *((_BYTE *)v1 + 105) >= 4u )
  {
    sub_11008((__int64)v1[11], 0x68u, (__int64)&unk_4DC78);
    v1 = (void **)off_5F148;
  }
  if ( v0 && sub_11BB4 )
  {
    v3 = sub_2772C(2, 0x2Cu, 0x6E635749u);
LABEL_16:
    if ( v3 )
    {
      memset(v3, 0, 0x2Cui64);
      v3[4] = 0i64;
      v2 = v3 + 5;
      v3[1] = v3;
      *v3 = v3;
      v3[3] = sub_11BB4;
      v3[2] = v0;
    }
    v1 = (void **)off_5F148;
    goto LABEL_19;
  }
  if ( v1 == &off_5F148 )
    return v2;
  if ( *((char *)v1 + 108) < 0 && *((_BYTE *)v1 + 105) >= 3u )
  {
    sub_11008((__int64)v1[11], 0x69u, (__int64)&unk_4DC78);
    goto LABEL_16;
  }
LABEL_19:
  if ( v1 != &off_5F148 && (*((_BYTE *)v1 + 108) & 2) != 0 && *((_BYTE *)v1 + 105) >= 4u )
    sub_1102C((__int64)v1[11], 0x6Au, (__int64)&unk_4DC78, (int)v2);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000027504) ----------------------------------------------------
void __fastcall sub_27504(__int64 a1)
{
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 108) < 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_26384(*((_QWORD *)off_5F148 + 11), 0x30u);
  sub_28A1C(a1);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000027570) ----------------------------------------------------
__int64 __fastcall sub_27570(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+B8h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DC78, 14i64, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000027600) ----------------------------------------------------
__int64 __fastcall sub_27600(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+C8h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DC78, 17i64, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002769C) ----------------------------------------------------
__int64 __fastcall sub_2769C(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+B8h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DC78, 11i64, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002772C) ----------------------------------------------------
PVOID __fastcall sub_2772C(int a1, unsigned int a2, ULONG a3)
{
  SIZE_T v4; // rdi
  void **v6; // rcx
  PVOID v7; // rax
  PVOID v8; // rbx

  v4 = a2;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 11), 0xAu, (__int64)&unk_4DC78);
      v6 = (void **)off_5F148;
    }
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 108) & 4) != 0 && *((_BYTE *)v6 + 105) >= 6u )
      sub_2769C((__int64)v6[11], 11i64, (__int64)&unk_4DC78, v4);
  }
  v7 = ExAllocatePoolWithTag((POOL_TYPE)(a1 != 2), v4, a3);
  v8 = v7;
  if ( v7 )
    memset(v7, 0, v4);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_1102C(*((_QWORD *)off_5F148 + 11), 0xCu, (__int64)&unk_4DC78, (int)v8);
  return v8;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000027848) ----------------------------------------------------
void __fastcall sub_27848(PVOID P, ULONG Tag)
{
  void **v4; // rcx

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 11), 0xDu, (__int64)&unk_4DC78);
      v4 = (void **)off_5F148;
    }
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 108) & 4) != 0 && *((_BYTE *)v4 + 105) >= 6u )
    {
      sub_27570((__int64)v4[11], 14i64, (__int64)&unk_4DC78, (int)P);
      v4 = (void **)off_5F148;
    }
  }
  if ( P )
  {
    ExFreePoolWithTag(P, Tag);
    v4 = (void **)off_5F148;
  }
  if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 108) & 2) != 0 && *((_BYTE *)v4 + 105) >= 4u )
    sub_11008((__int64)v4[11], 0xFu, (__int64)&unk_4DC78);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000027940) ----------------------------------------------------
_DWORD *__fastcall sub_27940(__int64 a1)
{
  _DWORD *v2; // rbx
  _DWORD *v3; // rax

  v2 = 0i64;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x19u, (__int64)&unk_4DC78);
  if ( (*(_DWORD *)a1 == 2 || *(_DWORD *)a1 == 1)
    && ((++*(_DWORD *)(a1 + 84), (v3 = ExpInterlockedPopEntrySList((PSLIST_HEADER)(a1 + 64))) != 0i64)
     || (++*(_DWORD *)(a1 + 88),
         (v3 = (_DWORD *)(*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(a1 + 112))(
                           *(unsigned int *)(a1 + 100),
                           *(unsigned int *)(a1 + 108),
                           *(unsigned int *)(a1 + 104))) != 0i64)) )
  {
    *v3 = 0;
  }
  else
  {
    v3 = sub_2772C(*(_DWORD *)a1, *(_DWORD *)(a1 + 4) + 7, *(_DWORD *)(a1 + 8));
    if ( !v3 )
      goto LABEL_14;
    *v3 = 1;
  }
  v2 = v3 + 1;
  if ( v3 != (_DWORD *)-4i64 )
    memset(v3 + 1, 0, *(unsigned int *)(a1 + 4));
LABEL_14:
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_1102C(*((_QWORD *)off_5F148 + 11), 0x1Au, (__int64)&unk_4DC78, (int)v2);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000027A44) ----------------------------------------------------
__int64 __fastcall sub_27A44(_QWORD *a1)
{
  __int64 result; // rax

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    result = sub_11008(*((_QWORD *)off_5F148 + 11), 0x2Fu, (__int64)&unk_4DC78);
  *a1 = 0i64;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    result = sub_11008(*((_QWORD *)off_5F148 + 11), 0x30u, (__int64)&unk_4DC78);
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000027AC8) ----------------------------------------------------
void __fastcall sub_27AC8(PKSPIN_LOCK SpinLock, KIRQL *a2)
{
  unsigned __int8 v4; // si

  v4 = KeGetCurrentIrql();
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x31u, (__int64)&unk_4DC78);
  if ( v4 == 2 )
  {
    *a2 = 2;
    KeAcquireSpinLockAtDpcLevel(SpinLock);
  }
  else
  {
    *a2 = KeAcquireSpinLockRaiseToDpc(SpinLock);
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x32u, (__int64)&unk_4DC78);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000027B80) ----------------------------------------------------
void __fastcall sub_27B80(PKSPIN_LOCK SpinLock, KIRQL a2)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x33u, (__int64)&unk_4DC78);
  if ( a2 == 2 )
    KeReleaseSpinLockFromDpcLevel(SpinLock);
  else
    KeReleaseSpinLock(SpinLock, a2);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x34u, (__int64)&unk_4DC78);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000027C24) ----------------------------------------------------
bool __fastcall sub_27C24(struct _KEVENT **a1, char a2)
{
  struct _KEVENT *v4; // rax
  struct _KEVENT *v5; // rdi

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x35u, (__int64)&unk_4DC78);
  *a1 = 0i64;
  v4 = (struct _KEVENT *)sub_2772C(2, 0x18u, 0x6E634556u);
  v5 = v4;
  if ( v4 )
  {
    KeInitializeEvent(v4, (EVENT_TYPE)(a2 == 0), 0);
    *a1 = v5;
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_1102C(*((_QWORD *)off_5F148 + 11), 0x36u, (__int64)&unk_4DC78, v5 != 0i64);
  return v5 != 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000027D0C) ----------------------------------------------------
void __fastcall sub_27D0C(PVOID P)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x37u, (__int64)&unk_4DC78);
  KeClearEvent((PRKEVENT)P);
  sub_27848(P, 0x6E634556u);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x38u, (__int64)&unk_4DC78);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000027DA4) ----------------------------------------------------
int __fastcall sub_27DA4(PRKEVENT Event)
{
  int result; // eax

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x39u, (__int64)&unk_4DC78);
  result = KeSetEvent(Event, 0, 0);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    result = sub_11008(*((_QWORD *)off_5F148 + 11), 0x3Au, (__int64)&unk_4DC78);
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000027E34) ----------------------------------------------------
void __fastcall HandleInformation(PVOID StartContext)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x49u, (__int64)&unk_4DC78);
  (*(void (__fastcall **)(_QWORD))StartContext)(*((_QWORD *)StartContext + 1));
  sub_27848(StartContext, 0x6E635448u);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x4Au, (__int64)&unk_4DC78);
  PsTerminateSystemThread(0);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000027ED0) ----------------------------------------------------
unsigned __int8 __fastcall sub_27ED0(PVOID *Object, __int64 a2, __int64 (__fastcall *a3)(void ***a1))
{
  unsigned __int8 v5; // bl
  __int64 (__fastcall **v6)(void ***); // rax
  __int64 (__fastcall **StartContext)(void ***); // rsi
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+40h] [rbp-48h] BYREF
  void *ThreadHandle; // [rsp+90h] [rbp+8h] BYREF

  v5 = 1;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x4Bu, (__int64)&unk_4DC78);
  v6 = (__int64 (__fastcall **)(void ***))sub_2772C(2, 0x10u, 0x6E635448u);
  *Object = 0i64;
  StartContext = v6;
  if ( !v6 )
    goto LABEL_10;
  memset(&ObjectAttributes.RootDirectory, 0, 0x28ui64);
  ThreadHandle = 0i64;
  *StartContext = sub_280CC;
  ObjectAttributes.Length = 48;
  StartContext[1] = a3;
  if ( !PsCreateSystemThread(
          &ThreadHandle,
          0x1F03FFu,
          &ObjectAttributes,
          0i64,
          0i64,
          (PKSTART_ROUTINE)HandleInformation,
          StartContext) )
  {
    ObReferenceObjectByHandle(ThreadHandle, 0, 0i64, 0, Object, 0i64);
    ZwClose(ThreadHandle);
  }
  if ( !*Object )
  {
    sub_27848(StartContext, 0x6E635448u);
LABEL_10:
    v5 = 0;
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_1102C(*((_QWORD *)off_5F148 + 11), 0x4Cu, (__int64)&unk_4DC78, v5);
  return v5;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000028038) ----------------------------------------------------
__int64 __fastcall sub_28038(PVOID Object)
{
  void **v2; // rcx
  __int64 result; // rax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
  {
    result = sub_11008(*((_QWORD *)off_5F148 + 11), 0x4Du, (__int64)&unk_4DC78);
    v2 = (void **)off_5F148;
  }
  if ( Object )
  {
    result = ObfDereferenceObject(Object);
    v2 = (void **)off_5F148;
  }
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
    result = sub_11008((__int64)v2[11], 0x4Eu, (__int64)&unk_4DC78);
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000280CC) ----------------------------------------------------
__int64 __fastcall sub_280CC(void ***a1)
{
  void **v1; // r12
  __int64 v2; // rdi
  void *v4; // rax
  ULONG v5; // er14
  void *v6; // rdx
  void **v7; // r10
  unsigned int v8; // ebp
  __int64 v9; // rsi
  __int64 v10; // r13
  __int64 v11; // rsi
  _QWORD **v12; // rcx
  _QWORD *v13; // rbx
  _QWORD *v14; // rax
  char *v15; // rcx
  void (__fastcall *v16)(_QWORD *); // rax
  __int64 result; // rax
  void **v18; // rcx
  PVOID v19[2]; // [rsp+30h] [rbp-48h] BYREF
  __int64 v20; // [rsp+40h] [rbp-38h]
  KIRQL v21; // [rsp+80h] [rbp+8h] BYREF

  v1 = *a1;
  v2 = *((int *)a1 + 2);
  v4 = **a1;
  v5 = 2;
  v21 = 0;
  v19[0] = v4;
  v6 = (void *)*((_QWORD *)v1[3] + 3);
  v20 = 0i64;
  v19[1] = v6;
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x53u, (__int64)&unk_4DC78);
    v7 = (void **)off_5F148;
  }
  if ( *((_BYTE *)v1 + 12) )
  {
    v5 = 3;
    v20 = *((_QWORD *)v1[3] + 4 * (unsigned int)v2 + 3);
  }
  if ( a1[2] )
  {
    if ( v7 != &off_5F148 && *((char *)v7 + 108) < 0 && *((_BYTE *)v7 + 105) >= 5u )
      sub_1102C((__int64)v7[11], 0x54u, (__int64)&unk_4DC78, v2);
    sub_27DA4((PRKEVENT)a1[2]);
  }
  while ( 1 )
  {
    result = sub_28BA8(v5, v19);
    if ( !(_DWORD)result )
      break;
    v8 = 0;
    v9 = 0i64;
    if ( (_DWORD)result == 2 )
    {
      v8 = v2;
      v9 = v2;
    }
    if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 108) < 0 && *((_BYTE *)off_5F148 + 105) >= 5u )
      sub_1102C(*((_QWORD *)off_5F148 + 11), 0x56u, (__int64)&unk_4DC78, v2);
    v10 = 32i64 * v8;
    sub_27AC8((PKSPIN_LOCK)((char *)v1[3] + v10), &v21);
    v11 = 32 * v9;
    v12 = (_QWORD **)((char *)v1[3] + v11 + 8);
    v13 = 0i64;
    if ( *v12 != v12 )
    {
      v13 = *v12;
      v14 = (_QWORD *)**v12;
      *v12 = v14;
      v14[1] = v12;
      if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 108) < 0 && *((_BYTE *)off_5F148 + 105) >= 5u )
        sub_127D0(*((_QWORD *)off_5F148 + 11), 0x57u, (__int64)&unk_4DC78, v2);
      v15 = (char *)v1[3];
      if ( *(char **)&v15[v11 + 8] != &v15[v11 + 8] )
        sub_27DA4(*(PRKEVENT *)&v15[v11 + 24]);
    }
    sub_27B80((PKSPIN_LOCK)((char *)v1[3] + v10), v21);
    if ( v13 )
    {
      if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 108) < 0 && *((_BYTE *)off_5F148 + 105) >= 5u )
        sub_127D0(*((_QWORD *)off_5F148 + 11), 0x58u, (__int64)&unk_4DC78, v2);
      v16 = (void (__fastcall *)(_QWORD *))v13[3];
      if ( v16 )
        v16(v13 + 5);
      sub_28958((__int64)(v13 + 5), 0);
      if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 108) < 0 && *((_BYTE *)off_5F148 + 105) >= 5u )
        sub_127D0(*((_QWORD *)off_5F148 + 11), 0x59u, (__int64)&unk_4DC78, v2);
    }
  }
  v18 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( *((char *)off_5F148 + 108) < 0 && *((_BYTE *)off_5F148 + 105) >= 5u )
    {
      result = sub_1102C(*((_QWORD *)off_5F148 + 11), 0x55u, (__int64)&unk_4DC78, v2);
      v18 = (void **)off_5F148;
    }
    if ( v18 != &off_5F148 && (*((_BYTE *)v18 + 108) & 2) != 0 && *((_BYTE *)v18 + 105) >= 4u )
      result = sub_11008((__int64)v18[11], 0x5Au, (__int64)&unk_4DC78);
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000283D8) ----------------------------------------------------
__int64 sub_283D8()
{
  int v0; // ebx
  PVOID v1; // rax
  __int64 v2; // rdi
  PVOID v3; // rax
  unsigned int v4; // esi
  _QWORD *v5; // r11
  __int64 v6; // r12
  unsigned int v7; // ebp
  PVOID *v8; // rcx
  __int64 v10; // [rsp+30h] [rbp-38h] BYREF
  unsigned int v11; // [rsp+38h] [rbp-30h]
  PVOID P; // [rsp+40h] [rbp-28h] BYREF

  v0 = 0;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x5Bu, (__int64)&unk_4DC78);
  v1 = sub_2772C(2, 0x20u, 0x6E635450u);
  v2 = (__int64)v1;
  if ( v1
    && (memset(v1, 0, 0x20ui64),
        sub_27C24((struct _KEVENT **)v2, 1),
        *(_DWORD *)(v2 + 8) = 1,
        *(_BYTE *)(v2 + 12) = 0,
        *(_QWORD *)(v2 + 16) = sub_2772C(2, 8u, 0x6E635450u),
        v3 = sub_2772C(2, 0x20u, 0x6E635450u),
        *(_QWORD *)(v2 + 24) = v3,
        *(_QWORD *)(v2 + 16))
    && v3 )
  {
    v10 = v2;
    sub_27C24((struct _KEVENT **)&P, 0);
    **(_QWORD **)(v2 + 16) = 0i64;
    memset(*(void **)(v2 + 24), 0, 0x20ui64);
    sub_27A44(*(_QWORD **)(v2 + 24));
    sub_27C24((struct _KEVENT **)(*(_QWORD *)(v2 + 24) + 24i64), 0);
    v4 = 0;
    v5 = (_QWORD *)(*(_QWORD *)(v2 + 24) + 8i64);
    v6 = 0i64;
    v5[1] = v5;
    *v5 = v5;
    while ( 1 )
    {
      if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 108) < 0 && *((_BYTE *)off_5F148 + 105) >= 5u )
        sub_127D0(*((_QWORD *)off_5F148 + 11), 0x5Cu, (__int64)&unk_4DC78, v4 + 1);
      v7 = v4 + 1;
      v8 = (PVOID *)(*(_QWORD *)(v2 + 16) + 8i64 * v4);
      v11 = v4 + 1;
      sub_27ED0(v8, (__int64)sub_280CC, (__int64 (__fastcall *)(void ***))&v10);
      if ( !*(_QWORD *)(v6 + *(_QWORD *)(v2 + 16)) )
        break;
      sub_28B00(P);
      v6 += 8i64;
      ++v4;
      if ( v7 )
        goto LABEL_17;
    }
    v0 = -16777213;
LABEL_17:
    sub_27D0C(P);
  }
  else
  {
    v0 = -16777213;
  }
  if ( v0 && v2 )
  {
    sub_285FC((PVOID)v2);
    v2 = 0i64;
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_1102C(*((_QWORD *)off_5F148 + 11), 0x5Du, (__int64)&unk_4DC78, v2);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000285FC) ----------------------------------------------------
__int64 __fastcall sub_285FC(PVOID P)
{
  void **v2; // rcx
  unsigned int v3; // eax
  __int64 v4; // rsi
  __int64 v5; // rbp
  __int64 v6; // r12
  void **v7; // rcx
  __int64 v8; // rdx
  _QWORD **v9; // rcx
  _QWORD *v10; // rdi
  _QWORD *v11; // rax
  unsigned int v12; // esi
  __int64 v13; // rdi
  __int64 v14; // rbp
  KIRQL v16; // [rsp+50h] [rbp+8h] BYREF

  v16 = 0;
  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x5Eu, (__int64)&unk_4DC78);
    v2 = (void **)off_5F148;
  }
  if ( *((_BYTE *)P + 12) )
    v3 = *((_DWORD *)P + 2) + 1;
  else
    v3 = 1;
  if ( v3 )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = v3;
    do
    {
      sub_27AC8((PKSPIN_LOCK)(v5 + *((_QWORD *)P + 3)), &v16);
      v7 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 108) < 0 && *((_BYTE *)off_5F148 + 105) >= 5u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 11), 0x5Fu, (__int64)&unk_4DC78);
        v7 = (void **)off_5F148;
      }
      v8 = *((_QWORD *)P + 3);
      if ( *(_QWORD *)(v4 + v8 + 8) != v4 + v8 + 8 )
      {
        do
        {
          v9 = (_QWORD **)(v4 + v8 + 8);
          v10 = *v9;
          v11 = (_QWORD *)**v9;
          *v9 = v11;
          v11[1] = v9;
          if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 108) < 0 && *((_BYTE *)off_5F148 + 105) >= 5u )
            sub_1102C(*((_QWORD *)off_5F148 + 11), 0x60u, (__int64)&unk_4DC78, (int)v10);
          sub_28958((__int64)(v10 + 5), 1);
          v8 = *((_QWORD *)P + 3);
        }
        while ( *(_QWORD *)(v4 + v8 + 8) != v4 + v8 + 8 );
        v7 = (void **)off_5F148;
      }
      if ( v7 != &off_5F148 && *((char *)v7 + 108) < 0 && *((_BYTE *)v7 + 105) >= 5u )
        sub_11008((__int64)v7[11], 0x61u, (__int64)&unk_4DC78);
      sub_27B80((PKSPIN_LOCK)(v5 + *((_QWORD *)P + 3)), v16);
      v5 += 32i64;
      v4 += 32i64;
      --v6;
    }
    while ( v6 );
    v2 = (void **)off_5F148;
  }
  if ( *(_QWORD *)P )
  {
    if ( v2 != &off_5F148 && *((char *)v2 + 108) < 0 && *((_BYTE *)v2 + 105) >= 5u )
      sub_11008((__int64)v2[11], 0x62u, (__int64)&unk_4DC78);
    sub_27DA4(*(PRKEVENT *)P);
    v2 = (void **)off_5F148;
  }
  if ( v2 != &off_5F148 && *((char *)v2 + 108) < 0 && *((_BYTE *)v2 + 105) >= 5u )
  {
    sub_1102C((__int64)v2[11], 0x63u, (__int64)&unk_4DC78, *((_DWORD *)P + 2));
    v2 = (void **)off_5F148;
  }
  v12 = 0;
  if ( *((_DWORD *)P + 2) )
  {
    v13 = 0i64;
    v14 = 32i64;
    do
    {
      if ( *(_QWORD *)(v13 + *((_QWORD *)P + 2)) )
      {
        if ( v2 != &off_5F148 && *((char *)v2 + 108) < 0 && *((_BYTE *)v2 + 105) >= 5u )
          sub_1102C((__int64)v2[11], 0x64u, (__int64)&unk_4DC78, v12);
        sub_28B00(*(PVOID *)(v13 + *((_QWORD *)P + 2)));
        if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 108) < 0 && *((_BYTE *)off_5F148 + 105) >= 5u )
          sub_1102C(*((_QWORD *)off_5F148 + 11), 0x65u, (__int64)&unk_4DC78, v12);
        sub_28038(*(PVOID *)(v13 + *((_QWORD *)P + 2)));
        *(_QWORD *)(v13 + *((_QWORD *)P + 2)) = 0i64;
        if ( *((_BYTE *)P + 12) )
          sub_27D0C(*(PVOID *)(*((_QWORD *)P + 3) + v14 + 24));
        v2 = (void **)off_5F148;
      }
      ++v12;
      v14 += 32i64;
      v13 += 8i64;
    }
    while ( v12 < *((_DWORD *)P + 2) );
  }
  if ( v2 != &off_5F148 && *((char *)v2 + 108) < 0 && *((_BYTE *)v2 + 105) >= 5u )
    sub_11008((__int64)v2[11], 0x66u, (__int64)&unk_4DC78);
  sub_27D0C(*(PVOID *)(*((_QWORD *)P + 3) + 24i64));
  sub_27D0C(*(PVOID *)P);
  sub_27848(*((PVOID *)P + 2), 0x6E635450u);
  sub_27848(*((PVOID *)P + 3), 0x6E635450u);
  sub_27848(P, 0x6E635450u);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x67u, (__int64)&unk_4DC78);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000028958) ----------------------------------------------------
void __fastcall sub_28958(__int64 a1, char a2)
{
  void **v4; // rcx
  void (__fastcall *v5)(__int64); // rax

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x6Bu, (__int64)&unk_4DC78);
    v4 = (void **)off_5F148;
  }
  if ( a1 )
  {
    if ( a2 )
    {
      v5 = *(void (__fastcall **)(__int64))(a1 - 8);
      if ( v5 )
        v5(a1);
    }
    sub_27848((PVOID)(a1 - 40), 0x6E635749u);
    v4 = (void **)off_5F148;
  }
  if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 108) & 2) != 0 && *((_BYTE *)v4 + 105) >= 4u )
    sub_11008((__int64)v4[11], 0x6Cu, (__int64)&unk_4DC78);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000028A1C) ----------------------------------------------------
void __fastcall sub_28A1C(__int64 a1)
{
  void **v2; // rcx
  __int64 v3; // rdi
  _QWORD *v4; // rbx
  KSPIN_LOCK *v5; // rcx
  __int64 v6; // r11
  _QWORD *v7; // rax
  KIRQL v8; // [rsp+30h] [rbp+8h] BYREF

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x6Du, (__int64)&unk_4DC78);
    v2 = (void **)off_5F148;
  }
  if ( a1 )
  {
    v3 = *(_QWORD *)(a1 - 24);
    v4 = (_QWORD *)(a1 - 40);
    v5 = *(KSPIN_LOCK **)(v3 + 24);
    v8 = 0;
    sub_27AC8(v5, &v8);
    v6 = *(_QWORD *)(v3 + 24);
    v7 = *(_QWORD **)(v6 + 16);
    v6 += 8i64;
    v4[1] = v7;
    *v4 = v6;
    *v7 = v4;
    *(_QWORD *)(v6 + 8) = v4;
    sub_27DA4(*(PRKEVENT *)(*(_QWORD *)(v3 + 24) + 24i64));
    sub_27B80(*(PKSPIN_LOCK *)(v3 + 24), v8);
    v2 = (void **)off_5F148;
  }
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
    sub_11008((__int64)v2[11], 0x6Eu, (__int64)&unk_4DC78);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000028B00) ----------------------------------------------------
__int64 __fastcall sub_28B00(PVOID Object)
{
  int v2; // eax
  unsigned int v3; // ebx

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x6Fu, (__int64)&unk_4DC78);
  v2 = KeWaitForSingleObject(Object, Executive, 0, 0, 0i64);
  v3 = v2;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_1102C(*((_QWORD *)off_5F148 + 11), 0x70u, (__int64)&unk_4DC78, v2);
  return v3;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000028BA8) ----------------------------------------------------
__int64 __fastcall sub_28BA8(ULONG Count, PVOID Object[])
{
  struct _KWAIT_BLOCK *WaitBlockArray; // rdi
  unsigned int v6; // ebx

  WaitBlockArray = 0i64;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 11), 0x71u, (__int64)&unk_4DC78);
  if ( Count > 3 )
  {
    WaitBlockArray = (struct _KWAIT_BLOCK *)sub_2772C(2, 48 * Count, 0x6E635742u);
    if ( !WaitBlockArray )
      return 4278190083i64;
  }
  v6 = KeWaitForMultipleObjects(Count, Object, WaitAny, Executive, 0, 0, 0i64, WaitBlockArray);
  if ( WaitBlockArray )
    sub_27848(WaitBlockArray, 0x6E635742u);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 2) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_1102C(*((_QWORD *)off_5F148 + 11), 0x72u, (__int64)&unk_4DC78, v6);
  return v6;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000028CB4) ----------------------------------------------------
__int64 __fastcall sub_28CB4(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+78h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, a3, a2, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000028D00) ----------------------------------------------------
__int64 __fastcall sub_28D00(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+98h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DC58, a2, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000028D6C) ----------------------------------------------------
__int64 sub_28D6C(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+88h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, &unk_4DC58, 31i64, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000028DD0) ----------------------------------------------------
__int64 sub_28DD0(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+98h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, a3, a2, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000028E34) ----------------------------------------------------
__int64 sub_28E34(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+98h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, a3, a2, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000028E98) ----------------------------------------------------
__int64 sub_28E98(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+A8h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, a3, a2, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000028F10) ----------------------------------------------------
__int64 sub_28F10()
{
  void **v0; // rcx
  __int64 result; // rax
  int v2; // eax
  unsigned int v3; // ebx

  v0 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xAu, (__int64)&unk_4DC58);
    v0 = (void **)off_5F148;
  }
  if ( byte_5F496 )
  {
    if ( v0 != &off_5F148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
      sub_11008((__int64)v0[19], 0xBu, (__int64)&unk_4DC58);
    sub_29034();
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0xCu, (__int64)&unk_4DC58);
    result = 0x80000000i64;
  }
  else
  {
    v2 = sub_2B5DC();
    v3 = v2;
    byte_5F496 = v2 == 0;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0xDu, (__int64)&unk_4DC58, v2);
    result = v3;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;
// 5F496: using guessed type char byte_5F496;

//----- (0000000000029034) ----------------------------------------------------
__int64 sub_29034()
{
  void **v0; // rcx
  __int64 result; // rax

  v0 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xEu, (__int64)&unk_4DC58);
    v0 = (void **)off_5F148;
  }
  if ( byte_5F496 )
  {
    sub_2B6B4();
    byte_5F496 = 0;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x11u, (__int64)&unk_4DC58);
    result = 0i64;
  }
  else
  {
    if ( v0 != &off_5F148 )
    {
      if ( (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
      {
        sub_11008((__int64)v0[19], 0xFu, (__int64)&unk_4DC58);
        v0 = (void **)off_5F148;
      }
      if ( v0 != &off_5F148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 5u )
        sub_11008((__int64)v0[19], 0x10u, (__int64)&unk_4DC58);
    }
    result = 0x80000000i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;
// 5F496: using guessed type char byte_5F496;

//----- (0000000000029144) ----------------------------------------------------
__int64 __fastcall sub_29144(__int64 *a1)
{
  __int64 result; // rax
  int v3; // eax
  unsigned int v4; // ebx

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x12u, (__int64)&unk_4DC58, a1);
  if ( !byte_5F496 )
    return 0x80000000i64;
  if ( !a1 )
    return 2147483649i64;
  v3 = sub_2C3CC(0x30u, a1);
  v4 = v3;
  if ( v3 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x13u, (__int64)&unk_4DC58, v3);
    result = v4;
  }
  else
  {
    sub_2B764(*a1);
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_17984(*((_QWORD *)off_5F148 + 19), 0x14u, (__int64)&unk_4DC58, *a1);
    result = 0i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;
// 5F496: using guessed type char byte_5F496;

//----- (0000000000029264) ----------------------------------------------------
__int64 __fastcall sub_29264(PVOID P)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x15u, (__int64)&unk_4DC58, P);
  if ( !byte_5F496 )
    return 0x80000000i64;
  if ( !P )
    return 2147483649i64;
  sub_2C584(P);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x16u, (__int64)&unk_4DC58);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;
// 5F496: using guessed type char byte_5F496;

//----- (0000000000029320) ----------------------------------------------------
__int64 __fastcall sub_29320(_DWORD *a1, int a2, __int64 *a3)
{
  int v7; // eax
  unsigned int v8; // edi
  _DWORD *v9; // [rsp+50h] [rbp+8h] BYREF
  int v10; // [rsp+58h] [rbp+10h] BYREF

  v9 = a1;
  v10 = a2;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_28D6C(*((_QWORD *)off_5F148 + 19), 31i64, (__int64)&unk_4DC58, a1, a2, a3);
  if ( !byte_5F496 )
    return 0x80000000i64;
  if ( !a1 || !a2 || !a3 )
    return 2147483649i64;
  v7 = sub_29144(a3);
  v8 = v7;
  if ( v7 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x20u, (__int64)&unk_4DC58, v7);
  }
  else
  {
    v8 = sub_2BCB8(*a3, &v9, &v10, sub_29B50);
    if ( v8 == -2147483647 )
      v8 = -2147483644;
    if ( v8 )
    {
      sub_29264((PVOID)*a3);
      *a3 = 0i64;
    }
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_28CB4(*((_QWORD *)off_5F148 + 19), 0x21u, (__int64)&unk_4DC58, v8);
  }
  return v8;
}
// 5F148: using guessed type void *off_5F148;
// 5F496: using guessed type char byte_5F496;

//----- (0000000000029498) ----------------------------------------------------
__int64 __fastcall sub_29498(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 *a4)
{
  unsigned int v7; // edi
  __int64 result; // rax
  int v9; // eax
  unsigned int v10; // ebx
  _QWORD *v11; // rcx
  unsigned int v12; // eax
  unsigned int v13; // eax
  unsigned __int8 v14; // al
  _QWORD *v15; // [rsp+40h] [rbp-48h] BYREF
  _QWORD *v16; // [rsp+48h] [rbp-40h] BYREF
  __int64 v17; // [rsp+50h] [rbp-38h] BYREF
  __int64 v18; // [rsp+58h] [rbp-30h] BYREF
  char v19[32]; // [rsp+60h] [rbp-28h] BYREF

  v7 = 0;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_12818(*((_QWORD *)off_5F148 + 19), 0x22u, (__int64)&unk_4DC58, a1, sub_1609C, a3, a4);
  if ( !byte_5F496 )
    return 0x80000000i64;
  if ( !a1 || !sub_1609C || !a4 )
    return 2147483649i64;
  *a4 = 0;
  v9 = sub_2BE4C(a1, &v16);
  v10 = v9;
  if ( !v9 )
  {
    while ( 1 )
    {
      v11 = v16;
      *a4 = 1;
      sub_2C2A0(v11, &v18);
      v12 = sub_2BE4C(v18, &v15);
      if ( v12 )
      {
        if ( v12 != 1073741825 )
        {
          v7 = v12;
          goto LABEL_21;
        }
      }
      else
      {
        while ( 1 )
        {
          sub_2C2A0(v15, &v17);
          if ( !*(_QWORD *)(v17 + 32) )
            break;
          v13 = sub_2A590(*(_QWORD *)(v17 + 32), (__int64)v19);
          if ( v13 )
          {
            v7 = v13;
            goto LABEL_33;
          }
          v14 = sub_1609C(v17, (__int64)v19, a3);
          *a4 = v14;
          if ( !v14 || (unsigned int)sub_2BFE0(v15) )
            goto LABEL_33;
        }
        v7 = -2147483641;
      }
LABEL_33:
      sub_2C17C(v15);
      if ( v7 || *a4 || (unsigned int)sub_2BFE0(v16) )
        goto LABEL_21;
    }
  }
  if ( v9 == 1073741825 )
  {
LABEL_21:
    sub_2C17C(v16);
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_127D0(*((_QWORD *)off_5F148 + 19), 0x24u, (__int64)&unk_4DC58, v7);
    result = v7;
  }
  else
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x23u, (__int64)&unk_4DC58, v9);
    result = v10;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;
// 5F496: using guessed type char byte_5F496;

//----- (00000000000296E0) ----------------------------------------------------
__int64 __fastcall sub_296E0(PVOID P)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x32u, (__int64)&unk_4DC58, P);
  if ( !byte_5F496 )
    return 0x80000000i64;
  if ( !P )
    return 2147483649i64;
  sub_2C584(P);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x33u, (__int64)&unk_4DC58);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;
// 5F496: using guessed type char byte_5F496;

//----- (000000000002979C) ----------------------------------------------------
__int64 __fastcall sub_2979C(__int64 a1, __int64 a2, unsigned int a3, __int64 **a4)
{
  unsigned int v5; // esi
  __int64 result; // rax
  bool v9; // al
  int v10; // eax
  unsigned int v11; // ebx
  __int64 *v12; // rbx

  v5 = a3;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_28DD0(*((_QWORD *)off_5F148 + 19), 0x42u, (__int64)&unk_4DC58, a1, a2, a3, a4);
  if ( !byte_5F496 )
    return 0x80000000i64;
  if ( !a1 || !sub_2AC14(a1) || a2 && !sub_2AB60(a2) || v5 > 5 || !a4 )
    return 2147483649i64;
  if ( !v5 || v5 == 1 )
  {
    if ( a2 )
      return 2147483649i64;
  }
  else
  {
    if ( v5 == 2 || v5 == 3 )
    {
      if ( !a2 )
        return 2147483649i64;
      v9 = sub_2AC14(a2);
    }
    else
    {
      if ( !a2 )
        return 2147483649i64;
      v9 = sub_2ACB8(a2);
    }
    if ( !v9 )
      return 2147483649i64;
  }
  v10 = sub_2C3CC(0x30u, a4);
  v11 = v10;
  if ( v10 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x43u, (__int64)&unk_4DC58, v10);
    result = v11;
  }
  else
  {
    v12 = *a4;
    sub_2C4B0(*a4, (__int64)sub_29D9C, (__int64)sub_29E48, (__int64)sub_29F0C);
    *((_DWORD *)v12 + 6) = v5;
    v12[4] = a1;
    v12[5] = a2;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_17984(*((_QWORD *)off_5F148 + 19), 0x44u, (__int64)&unk_4DC58, *a4);
    result = 0i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;
// 5F496: using guessed type char byte_5F496;

//----- (0000000000029964) ----------------------------------------------------
__int64 __fastcall sub_29964(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax
  __int64 v5; // r9

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x49u, (__int64)&unk_4DC58, a1, a2);
  if ( !byte_5F496 )
    return 0x80000000i64;
  if ( !a1 || !a2 )
    return 2147483649i64;
  v5 = *(_QWORD *)(a1 + 40);
  *a2 = v5;
  if ( v5 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_17984(*((_QWORD *)off_5F148 + 19), 0x4Bu, (__int64)&unk_4DC58);
    result = 0i64;
  }
  else
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x4Au, (__int64)&unk_4DC58);
    result = 2147483656i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;
// 5F496: using guessed type char byte_5F496;

//----- (0000000000029A80) ----------------------------------------------------
__int64 __fastcall sub_29A80(__int64 a1, int *a2)
{
  int v5; // er9

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x4Cu, (__int64)&unk_4DC58, a1, a2);
  if ( !byte_5F496 )
    return 0x80000000i64;
  if ( !a1 || !a2 )
    return 2147483649i64;
  v5 = *(_DWORD *)(a1 + 24);
  *a2 = v5;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x4Du, (__int64)&unk_4DC58, v5);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;
// 5F496: using guessed type char byte_5F496;

//----- (0000000000029B50) ----------------------------------------------------
__int64 __fastcall sub_29B50(_DWORD **a1, _DWORD *a2, __int64 *a3)
{
  void **v6; // rcx
  unsigned int v7; // ebx
  int v8; // eax
  unsigned int v10; // esi

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      sub_28DD0(*((_QWORD *)off_5F148 + 19), 0x52u, (__int64)&unk_4DC58, a1, a2, *a2, a3);
      v6 = (void **)off_5F148;
    }
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 1) != 0 && *((_BYTE *)v6 + 169) >= 5u )
    {
      sub_17984((__int64)v6[19], 0x2Fu, (__int64)&unk_4DC58, a3);
      v6 = (void **)off_5F148;
    }
  }
  if ( !byte_5F496 )
  {
    v7 = 0x80000000;
    goto LABEL_24;
  }
  if ( !a3 )
  {
    v7 = -2147483647;
LABEL_24:
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 1) != 0 && *((_BYTE *)v6 + 169) >= 5u )
      sub_1102C((__int64)v6[19], 0x53u, (__int64)&unk_4DC58, v7);
    return v7;
  }
  v8 = sub_2C3CC(0x30u, a3);
  v7 = v8;
  if ( v8 )
  {
    v6 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x30u, (__int64)&unk_4DC58, v8);
      v6 = (void **)off_5F148;
    }
  }
  else
  {
    sub_2B764(*a3);
    v6 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      sub_17984(*((_QWORD *)off_5F148 + 19), 0x31u, (__int64)&unk_4DC58, *a3);
      v6 = (void **)off_5F148;
    }
    v7 = 0;
  }
  if ( v7 )
    goto LABEL_24;
  v10 = sub_2BCB8(*a3, a1, a2, (__int64 (__fastcall *)(_DWORD **, _DWORD *, __int64 *))sub_2A0B4);
  if ( v10 == -2147483647 )
    v10 = -2147483644;
  if ( v10 )
  {
    sub_296E0((PVOID)*a3);
    *a3 = 0i64;
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_28D00(*((_QWORD *)off_5F148 + 19), 0x54u, (__int64)&unk_4DC58, v10);
  return v10;
}
// 5F148: using guessed type void *off_5F148;
// 5F496: using guessed type char byte_5F496;

//----- (0000000000029D9C) ----------------------------------------------------
__int64 __fastcall sub_29D9C(__int64 a1)
{
  __int64 result; // rax
  void *v3; // rcx

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x55u, (__int64)&unk_4DC58, a1);
  result = sub_2A330(*(PVOID *)(a1 + 32));
  v3 = *(void **)(a1 + 40);
  if ( v3 )
    result = sub_2A330(v3);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    result = sub_11008(*((_QWORD *)off_5F148 + 19), 0x56u, (__int64)&unk_4DC58);
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000029E48) ----------------------------------------------------
__int64 __fastcall sub_29E48(__int64 a1)
{
  __int64 v2; // rcx
  int v3; // ebx
  unsigned int v4; // ebx

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x57u, (__int64)&unk_4DC58, a1);
  v2 = *(_QWORD *)(a1 + 40);
  v3 = 0;
  if ( v2 )
    v3 = sub_2A8A0(v2);
  v4 = sub_2A8A0(*(_QWORD *)(a1 + 32)) + v3 + 4;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x58u, (__int64)&unk_4DC58, v4);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000029F0C) ----------------------------------------------------
__int64 __fastcall sub_29F0C(__int64 a1, void **a2, int *a3)
{
  __int64 result; // rax
  int v7; // eax
  unsigned int v8; // ebx
  __int64 v9; // rcx

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_28E34(*((_QWORD *)off_5F148 + 19), 0x59u, (__int64)&unk_4DC58, a1, a2, a3, *a3);
  if ( *a3 >= (unsigned int)sub_29E48(a1) )
  {
    *(_DWORD *)*a2 = *(_DWORD *)(a1 + 24);
    *a2 = (char *)*a2 + 4;
    *a3 -= 4;
    v7 = sub_2A944(*(_QWORD *)(a1 + 32), a2, a3);
    v8 = v7;
    if ( v7 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x5Bu, (__int64)&unk_4DC58, v7);
    }
    else
    {
      v9 = *(_QWORD *)(a1 + 40);
      if ( v9 )
        v8 = sub_2A944(v9, a2, a3);
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_142F4(*((_QWORD *)off_5F148 + 19), 0x5Cu, (__int64)&unk_4DC58, v8);
    }
    result = v8;
  }
  else
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x5Au, (__int64)&unk_4DC58);
    result = 2147483651i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002A0B4) ----------------------------------------------------
__int64 __fastcall sub_2A0B4(const void **a1, int *a2, __int64 **a3)
{
  unsigned int v7; // esi
  unsigned int v8; // ebx
  PVOID P; // [rsp+78h] [rbp+10h] BYREF
  PVOID v10; // [rsp+88h] [rbp+20h] BYREF

  P = 0i64;
  v10 = 0i64;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_28E98(*((_QWORD *)off_5F148 + 19), 0x5Du, (__int64)&unk_4DC58, a1, *a1, a2, *a2, a3);
  if ( (unsigned int)*a2 < 4 )
    return 2147483651i64;
  v7 = *(_DWORD *)*a1;
  *a1 = (char *)*a1 + 4;
  *a2 -= 4;
  v8 = sub_2AA24(a1, a2, (__int64 **)&P);
  if ( v8 == -2147483647 )
    v8 = -2147483644;
  if ( !v8 )
  {
    if ( sub_2AC14((__int64)P) )
    {
      if ( !v7 || v7 == 1 )
        goto LABEL_19;
      v8 = sub_2AA24(a1, a2, (__int64 **)&v10);
      if ( v8 == -2147483647 )
        v8 = -2147483644;
      if ( !v8 )
      {
LABEL_19:
        v8 = sub_2979C((__int64)P, (__int64)v10, v7, a3);
        if ( v8 == -2147483647 )
          v8 = -2147483644;
        if ( !v8 )
          goto LABEL_24;
      }
    }
    else
    {
      v8 = -2147483644;
    }
  }
  if ( P )
    sub_2A330(P);
  if ( v10 )
    sub_2A330(v10);
LABEL_24:
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_28D00(*((_QWORD *)off_5F148 + 19), 0x5Eu, (__int64)&unk_4DC58, v8);
  return v8;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002A274) ----------------------------------------------------
__int64 __fastcall sub_2A274(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+78h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, a3, 10i64, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002A2C4) ----------------------------------------------------
__int64 __fastcall sub_2A2C4(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+98h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DC48, a2, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002A330) ----------------------------------------------------
__int64 __fastcall sub_2A330(PVOID P)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_17984(*((_QWORD *)off_5F148 + 19), 0xAu, (__int64)&unk_4DC48, P);
  if ( !byte_5F496 )
    return 0x80000000i64;
  if ( !P || !sub_2AB60((__int64)P) )
    return 2147483649i64;
  sub_2C584(P);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xBu, (__int64)&unk_4DC48);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;
// 5F496: using guessed type char byte_5F496;

//----- (000000000002A3F8) ----------------------------------------------------
__int64 __fastcall sub_2A3F8(int a1, const void *a2, unsigned int a3, __int64 **a4)
{
  size_t v5; // rbp
  __int64 result; // rax
  unsigned int v9; // ebx
  __int64 *v10; // rbx
  void *v11; // r8

  v5 = a3;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_2A2C4(*((_QWORD *)off_5F148 + 19), 0xCu, (__int64)&unk_4DC48, a1);
  if ( !byte_5F496 )
    return 0x80000000i64;
  if ( !a4 || !a2 )
    return 2147483649i64;
  v9 = sub_2C3CC((int)v5 + 40, a4);
  if ( v9 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0xDu, (__int64)&unk_4DC48, v9);
    result = v9;
  }
  else
  {
    v10 = *a4;
    v11 = sub_2AD5C;
    if ( sub_2ADEC )
      v11 = sub_2ADEC;
    sub_2C4B0(*a4, 0i64, (__int64)v11, 0i64);
    *((_DWORD *)v10 + 6) = 1;
    *((_DWORD *)v10 + 8) = a1;
    memmove(v10 + 5, a2, v5);
    *((_DWORD *)v10 + 9) = v5;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_17984(*((_QWORD *)off_5F148 + 19), 0xEu, (__int64)&unk_4DC48, *a4);
    result = 0i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;
// 5F496: using guessed type char byte_5F496;

//----- (000000000002A590) ----------------------------------------------------
__int64 __fastcall sub_2A590(__int64 a1, __int64 a2)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x16u, (__int64)&unk_4DC48, a1, a2);
  if ( !byte_5F496 )
    return 0x80000000i64;
  if ( !a1 || !a2 || !sub_2AC14(a1) )
    return 2147483649i64;
  *(_QWORD *)a2 = a1;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 36);
  *(_QWORD *)(a2 + 16) = a1 + 40;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x17u, (__int64)&unk_4DC48);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;
// 5F496: using guessed type char byte_5F496;

//----- (000000000002A67C) ----------------------------------------------------
__int64 __fastcall sub_2A67C(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 *a4)
{
  __int64 result; // rax
  unsigned __int8 v8; // al
  int v9; // eax
  unsigned int v10; // ebx
  unsigned __int8 v11; // al
  int v12; // eax
  _QWORD *v13; // [rsp+40h] [rbp-38h] BYREF
  __int64 v14; // [rsp+48h] [rbp-30h] BYREF
  char v15[32]; // [rsp+50h] [rbp-28h] BYREF

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_12818(*((_QWORD *)off_5F148 + 19), 0x18u, (__int64)&unk_4DC48, a1, sub_16220, a3, a4);
  if ( !byte_5F496 )
    return 0x80000000i64;
  if ( !a1 || !sub_16220 || !a4 || !sub_2AB60(a1) )
    return 2147483649i64;
  if ( sub_2AC14(a1) )
  {
    sub_2A590(a1, (__int64)v15);
    v8 = sub_16220((__int64)v15, a3);
    *a4 = v8;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x19u, (__int64)&unk_4DC48, v8);
    result = 0i64;
  }
  else
  {
    v9 = sub_2BE4C(a1 + 32, &v13);
    v10 = v9;
    if ( v9 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x1Au, (__int64)&unk_4DC48, v9);
    }
    else
    {
      do
      {
        sub_2C2A0(v13, &v14);
        sub_2A590(v14, (__int64)v15);
        v11 = sub_16220((__int64)v15, a3);
        *a4 = v11;
      }
      while ( v11 && !(unsigned int)sub_2BFE0(v13) );
      v12 = sub_2C17C(v13);
      v10 = v12;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_127D0(*((_QWORD *)off_5F148 + 19), 0x1Bu, (__int64)&unk_4DC48, v12);
    }
    result = v10;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;
// 5F496: using guessed type char byte_5F496;

//----- (000000000002A8A0) ----------------------------------------------------
__int64 __fastcall sub_2A8A0(__int64 a1)
{
  int v2; // eax
  unsigned int v3; // ebx

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x2Du, (__int64)&unk_4DC48, a1);
  v2 = sub_2C640(a1);
  v3 = v2;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x2Eu, (__int64)&unk_4DC48, v2);
  return v3;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002A944) ----------------------------------------------------
__int64 __fastcall sub_2A944(__int64 a1, void **a2, int *a3)
{
  unsigned int v6; // ebx
  int v8; // [rsp+30h] [rbp-18h]

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    v8 = *a3;
    sub_28E34(*((_QWORD *)off_5F148 + 19), 0x2Fu, (__int64)&unk_4DC48, a1, a2, a3, v8);
  }
  v6 = sub_2C724(a1, a2, a3);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_142F4(*((_QWORD *)off_5F148 + 19), 0x30u, (__int64)&unk_4DC48, v6);
  return v6;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002AA24) ----------------------------------------------------
__int64 __fastcall sub_2AA24(const void **a1, int *a2, __int64 **a3)
{
  int v7; // ecx
  int v8; // ecx
  unsigned int v9; // ebx
  unsigned int v10; // eax
  int v11; // [rsp+30h] [rbp-18h]

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    v11 = *a2;
    sub_28E98(*((_QWORD *)off_5F148 + 19), 0x31u, (__int64)&unk_4DC48, a1, *a1, a2, v11, a3);
  }
  if ( (unsigned int)*a2 < 4 )
    return 2147483651i64;
  v7 = *(_DWORD *)*a1;
  *a1 = (char *)*a1 + 4;
  *a2 -= 4;
  v8 = v7 - 1;
  if ( v8 )
  {
    if ( v8 != 1 )
    {
      v9 = -2147483644;
      goto LABEL_13;
    }
    v10 = sub_2B2B4((_DWORD **)a1, a2, a3);
  }
  else
  {
    v10 = sub_2AE94(a1, a2, a3);
  }
  v9 = v10;
LABEL_13:
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_2A2C4(*((_QWORD *)off_5F148 + 19), 0x32u, (__int64)&unk_4DC48, v9);
  return v9;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002AB60) ----------------------------------------------------
unsigned __int8 __fastcall sub_2AB60(__int64 a1)
{
  void **v2; // rcx
  unsigned __int8 v3; // bl

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x33u, (__int64)&unk_4DC48, a1);
    v2 = (void **)off_5F148;
  }
  v3 = 0;
  if ( *(int *)(a1 + 24) > 0 && *(int *)(a1 + 24) < 3 )
    v3 = 1;
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 5u )
    sub_1102C((__int64)v2[19], 0x34u, (__int64)&unk_4DC48, v3);
  return v3;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002AC14) ----------------------------------------------------
bool __fastcall sub_2AC14(__int64 a1)
{
  void **v2; // rcx
  bool v3; // bl

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x35u, (__int64)&unk_4DC48, a1);
    v2 = (void **)off_5F148;
  }
  v3 = *(_DWORD *)(a1 + 24) == 1;
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 5u )
    sub_1102C((__int64)v2[19], 0x36u, (__int64)&unk_4DC48, v3);
  return v3;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002ACB8) ----------------------------------------------------
bool __fastcall sub_2ACB8(__int64 a1)
{
  void **v2; // rcx
  bool v3; // bl

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x37u, (__int64)&unk_4DC48, a1);
    v2 = (void **)off_5F148;
  }
  v3 = *(_DWORD *)(a1 + 24) == 2;
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 5u )
    sub_1102C((__int64)v2[19], 0x38u, (__int64)&unk_4DC48, v3);
  return v3;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002AD5C) ----------------------------------------------------
__int64 sub_2AD5C()
{
  void **v0; // rcx

  v0 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x39u, (__int64)&unk_4DC48);
      v0 = (void **)off_5F148;
    }
    if ( v0 != &off_5F148 && (*((_BYTE *)v0 + 172) & 2) != 0 && *((_BYTE *)v0 + 169) >= 5u )
      sub_1102C((__int64)v0[19], 0x3Au, (__int64)&unk_4DC48, 4);
  }
  return 4i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002ADEC) ----------------------------------------------------
__int64 __fastcall sub_2ADEC(__int64 a1)
{
  unsigned int v2; // ebx

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x3Du, (__int64)&unk_4DC48, a1);
  v2 = sub_2AD5C() + *(_DWORD *)(a1 + 36) + 8;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x3Eu, (__int64)&unk_4DC48, v2);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002AE94) ----------------------------------------------------
__int64 __fastcall sub_2AE94(const void **a1, _DWORD *a2, __int64 **a3)
{
  int v7; // ecx
  __int64 v8; // r12
  unsigned int v9; // eax
  unsigned int v10; // esi

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_28E98(*((_QWORD *)off_5F148 + 19), 0x3Fu, (__int64)&unk_4DC48, a1, *a1, a2, *a2, a3);
  if ( *a2 < 4u )
    return 2147483651i64;
  v7 = *(_DWORD *)*a1;
  *a1 = (char *)*a1 + 4;
  *a2 -= 4;
  if ( *a2 < 4u )
    return 2147483651i64;
  v8 = *(unsigned int *)*a1;
  *a1 = (char *)*a1 + 4;
  *a2 -= 4;
  if ( (unsigned int)v8 > *a2 )
    return 2147483651i64;
  v9 = sub_2A3F8(v7, *a1, v8, a3);
  *a1 = (char *)*a1 + v8;
  *a2 -= v8;
  v10 = v9;
  if ( v9 == -2147483647 )
    v10 = -2147483644;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_2A2C4(*((_QWORD *)off_5F148 + 19), 0x40u, (__int64)&unk_4DC48, v10);
  return v10;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002AFDC) ----------------------------------------------------
void __fastcall sub_2AFDC(__int64 a1)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x41u, (__int64)&unk_4DC48, a1);
  sub_2B824(a1 + 32);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x42u, (__int64)&unk_4DC48);
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002B07C) ----------------------------------------------------
__int64 __fastcall sub_2B07C(__int64 a1)
{
  int v2; // ebx
  unsigned int v3; // ebx

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x43u, (__int64)&unk_4DC48, a1);
  v2 = sub_2BA80(a1 + 32);
  v3 = sub_2AD5C() + v2;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x44u, (__int64)&unk_4DC48, v3);
  return v3;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002B134) ----------------------------------------------------
__int64 __fastcall sub_2B134(__int64 a1, void **a2, int *a3)
{
  void **v6; // rcx
  unsigned int v7; // ebx
  __int64 v9; // [rsp+20h] [rbp-28h]
  __int64 v10; // [rsp+30h] [rbp-18h]
  int v11; // [rsp+30h] [rbp-18h]

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      v11 = *a3;
      sub_28E34(*((_QWORD *)off_5F148 + 19), 0x45u, (__int64)&unk_4DC48, a1, a2, a3, v11);
      v6 = (void **)off_5F148;
    }
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 2) != 0 && *((_BYTE *)v6 + 169) >= 5u )
    {
      LODWORD(v10) = *a3;
      sub_28E34((__int64)v6[19], 0x3Bu, (__int64)&unk_4DC48, a1, a2, a3, v10);
    }
  }
  *(_DWORD *)*a2 = *(_DWORD *)(a1 + 24);
  *a2 = (char *)*a2 + 4;
  *a3 -= 4;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    LODWORD(v9) = *a3;
    sub_17814(*((_QWORD *)off_5F148 + 19), 0x3Cu, (__int64)&unk_4DC48, *a2, v9);
  }
  v7 = sub_2BB58(a1 + 32, a2, a3);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_142F4(*((_QWORD *)off_5F148 + 19), 0x47u, (__int64)&unk_4DC48, v7);
  return v7;
}
// 2B1E9: variable 'v10' is possibly undefined
// 2B237: variable 'v9' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000002B2B4) ----------------------------------------------------
__int64 __fastcall sub_2B2B4(_DWORD **a1, _DWORD *a2, __int64 **a3)
{
  void **v6; // rcx
  unsigned int v7; // ebx
  int v8; // eax
  __int64 *v9; // rbx
  void *v10; // r8
  unsigned int v12; // esi

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      sub_28E98(*((_QWORD *)off_5F148 + 19), 0x48u, (__int64)&unk_4DC48, a1, *a1, a2, *a2, a3);
      v6 = (void **)off_5F148;
    }
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 2) != 0 && *((_BYTE *)v6 + 169) >= 5u )
    {
      sub_17984((__int64)v6[19], 0x1Cu, (__int64)&unk_4DC48, a3);
      v6 = (void **)off_5F148;
    }
  }
  if ( !byte_5F496 )
  {
    v7 = 0x80000000;
    goto LABEL_26;
  }
  if ( !a3 )
  {
    v7 = -2147483647;
LABEL_26:
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 2) != 0 && *((_BYTE *)v6 + 169) >= 5u )
      sub_1102C((__int64)v6[19], 0x49u, (__int64)&unk_4DC48, v7);
    return v7;
  }
  v8 = sub_2C3CC(0x50u, a3);
  v7 = v8;
  if ( v8 )
  {
    v6 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x1Du, (__int64)&unk_4DC48, v8);
      v6 = (void **)off_5F148;
    }
  }
  else
  {
    v9 = *a3;
    v10 = sub_2AD5C;
    if ( sub_2B07C )
      v10 = sub_2B07C;
    sub_2C4B0(*a3, (__int64)sub_2AFDC, (__int64)v10, (__int64)sub_2B134);
    *((_DWORD *)v9 + 6) = 2;
    sub_2B764((__int64)(v9 + 4));
    v6 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      sub_17984(*((_QWORD *)off_5F148 + 19), 0x1Eu, (__int64)&unk_4DC48, *a3);
      v6 = (void **)off_5F148;
    }
    v7 = 0;
  }
  if ( v7 )
    goto LABEL_26;
  v12 = sub_2BCB8((__int64)(*a3 + 4), a1, a2, (__int64 (__fastcall *)(_DWORD **, _DWORD *, __int64 *))sub_2AA24);
  if ( v12 == -2147483647 )
    v12 = -2147483644;
  if ( v12 )
  {
    sub_2A330(*a3);
    *a3 = 0i64;
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_2A2C4(*((_QWORD *)off_5F148 + 19), 0x4Au, (__int64)&unk_4DC48, v12);
  return v12;
}
// 2AA24: using guessed type __int64 __fastcall sub_2AA24();
// 5F148: using guessed type void *off_5F148;
// 5F496: using guessed type char byte_5F496;

//----- (000000000002B54C) ----------------------------------------------------
__int64 sub_2B54C(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+B8h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, &unk_4DC38, 28i64, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002B5DC) ----------------------------------------------------
__int64 sub_2B5DC()
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xAu, (__int64)&unk_4DC38);
  qword_5F3E0 = sub_26670(1i64, 0x28u, 0x54736352u);
  qword_5F3E8 = sub_26670(1i64, 0x28u, 0x54736352u);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xBu, (__int64)&unk_4DC38);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002B6B4) ----------------------------------------------------
void sub_2B6B4()
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xCu, (__int64)&unk_4DC38);
  sub_26828(qword_5F3E0);
  sub_26828(qword_5F3E8);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xDu, (__int64)&unk_4DC38);
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002B764) ----------------------------------------------------
__int64 __fastcall sub_2B764(__int64 a1)
{
  __int64 result; // rax

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_17984(*((_QWORD *)off_5F148 + 19), 0xEu, (__int64)&unk_4DC38, a1);
  sub_2C4B0((__int64 *)a1, (__int64)sub_2B824, (__int64)sub_2BA80, (__int64)sub_2BB58);
  *(_DWORD *)(a1 + 24) = 0;
  result = a1 + 32;
  *(_QWORD *)(a1 + 40) = a1 + 32;
  *(_QWORD *)(a1 + 32) = a1 + 32;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    result = sub_11008(*((_QWORD *)off_5F148 + 19), 0xFu, (__int64)&unk_4DC38);
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002B824) ----------------------------------------------------
void __fastcall sub_2B824(__int64 a1)
{
  void **v2; // rcx
  _QWORD **v3; // rbx
  _QWORD *v4; // rbp
  _QWORD *v5; // rax
  _QWORD **v6; // rsi
  _QWORD *v7; // rdx
  PVOID v8; // rcx
  _QWORD *v9; // rax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x10u, (__int64)&unk_4DC38, a1);
    v2 = (void **)off_5F148;
  }
  v3 = (_QWORD **)(a1 + 32);
  if ( *v3 != v3 )
  {
    do
    {
      v4 = *v3;
      v5 = (_QWORD *)**v3;
      v6 = (_QWORD **)(*v3 + 3);
      *v3 = v5;
      v5[1] = v3;
      while ( *v6 != v6 )
      {
        v7 = *v6;
        v8 = qword_5F3E8;
        v9 = (_QWORD *)**v6;
        *v6 = v9;
        v9[1] = v6;
        sub_269B0((__int64)v8, (__int64)(v7 - 2));
      }
      sub_2C584((PVOID)v4[2]);
      sub_269B0((__int64)qword_5F3E0, (__int64)v4);
      --*(_DWORD *)(a1 + 24);
    }
    while ( *v3 != v3 );
    v2 = (void **)off_5F148;
  }
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 5u )
    sub_11008((__int64)v2[19], 0x11u, (__int64)&unk_4DC38);
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002B954) ----------------------------------------------------
__int64 __fastcall sub_2B954(__int64 a1, __int64 a2)
{
  _DWORD *v4; // rax
  _QWORD *v5; // r11
  __int64 result; // rax
  _QWORD *v7; // rax

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x12u, (__int64)&unk_4DC38, a1, a2);
  v4 = sub_26948((__int64)qword_5F3E0);
  v5 = v4;
  if ( v4 )
  {
    *((_QWORD *)v4 + 2) = a2;
    v7 = *(_QWORD **)(a1 + 40);
    *v5 = a1 + 32;
    v5[1] = v7;
    *v7 = v5;
    *(_QWORD *)(a1 + 40) = v5;
    v5[4] = v5 + 3;
    v5[3] = v5 + 3;
    ++*(_DWORD *)(a1 + 24);
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x14u, (__int64)&unk_4DC38);
    result = 0i64;
  }
  else
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x13u, (__int64)&unk_4DC38);
    result = 2147483650i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002BA80) ----------------------------------------------------
__int64 __fastcall sub_2BA80(__int64 a1)
{
  void **v2; // rcx
  _QWORD *v3; // rsi
  unsigned int v4; // ebx
  _QWORD *v5; // rdi
  int v6; // eax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x17u, (__int64)&unk_4DC38, a1);
    v2 = (void **)off_5F148;
  }
  v3 = (_QWORD *)(a1 + 32);
  v4 = 4;
  v5 = (_QWORD *)*v3;
  if ( (_QWORD *)*v3 != v3 )
  {
    do
    {
      v6 = sub_2C640(v5[2]);
      v5 = (_QWORD *)*v5;
      v4 += v6;
    }
    while ( v5 != v3 );
    v2 = (void **)off_5F148;
  }
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 5u )
    sub_1102C((__int64)v2[19], 0x18u, (__int64)&unk_4DC38, v4);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002BB58) ----------------------------------------------------
__int64 __fastcall sub_2BB58(__int64 a1, void **a2, int *a3)
{
  unsigned int v6; // edi
  __int64 result; // rax
  _QWORD *v8; // rbp
  _QWORD *i; // rbx

  v6 = 0;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_28E34(*((_QWORD *)off_5F148 + 19), 0x19u, (__int64)&unk_4DC38, a1, a2, a3, *a3);
  if ( *a3 >= (unsigned int)sub_2BA80(a1) )
  {
    *(_DWORD *)*a2 = *(_DWORD *)(a1 + 24);
    *a2 = (char *)*a2 + 4;
    *a3 -= 4;
    v8 = (_QWORD *)(a1 + 32);
    for ( i = (_QWORD *)*v8; i != v8; i = (_QWORD *)*i )
    {
      v6 = sub_2C724(i[2], a2, a3);
      if ( v6 )
        break;
    }
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_142F4(*((_QWORD *)off_5F148 + 19), 0x1Bu, (__int64)&unk_4DC38, v6);
    result = v6;
  }
  else
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x1Au, (__int64)&unk_4DC38);
    result = 2147483651i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002BCB8) ----------------------------------------------------
__int64 __fastcall sub_2BCB8(__int64 a1, _DWORD **a2, _DWORD *a3, __int64 (__fastcall *a4)(_DWORD **, _DWORD *, __int64 *))
{
  __int64 result; // rax
  int v9; // esi
  unsigned int v10; // er12
  unsigned int v11; // ebx
  __int64 v12; // [rsp+20h] [rbp-58h]
  __int64 v13; // [rsp+90h] [rbp+18h] BYREF

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_2B54C(*((_QWORD *)off_5F148 + 19), 28i64, (__int64)&unk_4DC38, a1, a2, *a2, a3, *a3, a4);
  if ( *a3 < 4u )
    return 2147483651i64;
  v9 = 0;
  v10 = *(*a2)++;
  *a3 -= 4;
  if ( v10 )
  {
    while ( 1 )
    {
      v11 = a4(a2, a3, &v13);
      if ( !v11 )
        v11 = sub_2B954(a1, v13);
      if ( v11 == -2147483647 )
        v11 = -2147483644;
      if ( v11 )
        break;
      if ( ++v9 >= v10 )
        goto LABEL_14;
    }
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x1Du, (__int64)&unk_4DC38, v11);
    result = v11;
  }
  else
  {
LABEL_14:
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      LODWORD(v12) = *a3;
      sub_17814(*((_QWORD *)off_5F148 + 19), 0x1Eu, (__int64)&unk_4DC38, *a2, v12);
    }
    result = 0i64;
  }
  return result;
}
// 2BDE2: variable 'v12' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000002BE4C) ----------------------------------------------------
__int64 __fastcall sub_2BE4C(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax
  _DWORD *v5; // rax
  _DWORD *v6; // r11
  _QWORD *v7; // rdx
  _QWORD *v8; // rax
  _QWORD *v9; // rax
  _QWORD *v10; // rcx
  __int64 v11; // rax

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x1Fu, (__int64)&unk_4DC38, a1, a2);
  if ( !a1 || !a2 )
    return 2147483649i64;
  v5 = sub_26948((__int64)qword_5F3E8);
  v6 = v5;
  *a2 = v5;
  if ( v5 )
  {
    *(_QWORD *)v5 = a1;
    v7 = v5 + 4;
    v8 = (_QWORD *)(a1 + 32);
    v7[1] = v7;
    *v7 = v7;
    if ( (_QWORD *)*v8 == v8 )
    {
      *((_QWORD *)v6 + 1) = 0i64;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x21u, (__int64)&unk_4DC38);
      result = 1073741825i64;
    }
    else
    {
      v9 = (_QWORD *)*v8;
      *((_QWORD *)v6 + 1) = v9;
      v10 = v9 + 3;
      v11 = v9[3];
      v7[1] = v10;
      *v7 = v11;
      *(_QWORD *)(v11 + 8) = v7;
      *v10 = v7;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_17984(*((_QWORD *)off_5F148 + 19), 0x22u, (__int64)&unk_4DC38, *a2);
      result = 0i64;
    }
  }
  else
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x20u, (__int64)&unk_4DC38);
    result = 2147483650i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002BFE0) ----------------------------------------------------
__int64 __fastcall sub_2BFE0(_QWORD *a1)
{
  void **v2; // rcx
  __int64 result; // rax
  unsigned __int16 v4; // dx
  _QWORD *v5; // rdx
  _QWORD *v6; // rax
  __int64 v7; // rcx
  __int64 *v8; // rcx
  __int64 v9; // rax
  _QWORD *v10; // rcx
  __int64 v11; // rax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x23u, (__int64)&unk_4DC38, a1);
    v2 = (void **)off_5F148;
  }
  if ( !a1 )
    return 2147483649i64;
  if ( !*a1 )
  {
    if ( v2 == &off_5F148 || (*((_BYTE *)v2 + 172) & 4) == 0 || *((_BYTE *)v2 + 169) < 5u )
      return 2147483654i64;
    v4 = 36;
LABEL_12:
    sub_11008((__int64)v2[19], v4, (__int64)&unk_4DC38);
    return 2147483654i64;
  }
  if ( !a1[1] )
  {
    if ( v2 == &off_5F148 || (*((_BYTE *)v2 + 172) & 4) == 0 || *((_BYTE *)v2 + 169) < 5u )
      return 2147483654i64;
    v4 = 37;
    goto LABEL_12;
  }
  v5 = a1 + 2;
  v6 = (_QWORD *)a1[3];
  v7 = a1[2];
  *v6 = v7;
  *(_QWORD *)(v7 + 8) = v6;
  v8 = (__int64 *)a1[1];
  if ( *v8 == *a1 + 32i64 )
  {
    a1[1] = 0i64;
    a1[3] = a1 + 2;
    *v5 = v5;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x26u, (__int64)&unk_4DC38);
    result = 1073741825i64;
  }
  else
  {
    v9 = *v8;
    a1[1] = *v8;
    v10 = (_QWORD *)(v9 + 24);
    v11 = *(_QWORD *)(v9 + 24);
    a1[3] = v10;
    *v5 = v11;
    *(_QWORD *)(v11 + 8) = v5;
    *v10 = v5;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x27u, (__int64)&unk_4DC38);
    result = 0i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002C17C) ----------------------------------------------------
__int64 __fastcall sub_2C17C(_QWORD *a1)
{
  void **v2; // rcx
  __int64 result; // rax
  _QWORD *v4; // rax
  __int64 v5; // rcx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x28u, (__int64)&unk_4DC38, a1);
    v2 = (void **)off_5F148;
  }
  if ( !a1 )
    return 2147483649i64;
  if ( *a1 )
  {
    if ( a1[1] )
    {
      v4 = (_QWORD *)a1[3];
      v5 = a1[2];
      *v4 = v5;
      *(_QWORD *)(v5 + 8) = v4;
      a1[3] = a1 + 2;
      a1[2] = a1 + 2;
    }
    sub_269B0((__int64)qword_5F3E8, (__int64)a1);
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x2Au, (__int64)&unk_4DC38);
    result = 0i64;
  }
  else
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 5u )
      sub_11008((__int64)v2[19], 0x29u, (__int64)&unk_4DC38);
    result = 2147483654i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002C2A0) ----------------------------------------------------
__int64 __fastcall sub_2C2A0(_QWORD *a1, _QWORD *a2)
{
  void **v4; // rcx
  unsigned __int16 v6; // dx
  __int64 v7; // r9

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x2Bu, (__int64)&unk_4DC38, a1, a2);
    v4 = (void **)off_5F148;
  }
  if ( !a1 )
    return 2147483649i64;
  if ( !*a1 )
  {
    if ( v4 == &off_5F148 || (*((_BYTE *)v4 + 172) & 4) == 0 || *((_BYTE *)v4 + 169) < 5u )
      return 2147483654i64;
    v6 = 44;
LABEL_12:
    sub_11008((__int64)v4[19], v6, (__int64)&unk_4DC38);
    return 2147483654i64;
  }
  v7 = a1[1];
  if ( !v7 )
  {
    if ( v4 == &off_5F148 || (*((_BYTE *)v4 + 172) & 4) == 0 || *((_BYTE *)v4 + 169) < 5u )
      return 2147483654i64;
    v6 = 45;
    goto LABEL_12;
  }
  *a2 = *(_QWORD *)(v7 + 16);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x2Eu, (__int64)&unk_4DC38);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002C3CC) ----------------------------------------------------
__int64 __fastcall sub_2C3CC(unsigned int a1, _QWORD *a2)
{
  PVOID v4; // rax
  unsigned int v5; // ebx

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_2A274(*((_QWORD *)off_5F148 + 19), 10i64, (__int64)&unk_4DC28, a1);
  v4 = sub_26404(1, a1, 0x54736352u);
  *a2 = v4;
  v5 = v4 == 0i64 ? 0x80000002 : 0;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_28CB4(*((_QWORD *)off_5F148 + 19), 0xBu, (__int64)&unk_4DC28, v5);
  return v5;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002C4B0) ----------------------------------------------------
void **__fastcall sub_2C4B0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  void **result; // rax
  void *retaddr; // [rsp+48h] [rbp+0h] BYREF

  result = &retaddr;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    result = (void **)sub_12818(*((_QWORD *)off_5F148 + 19), 0xCu, (__int64)&unk_4DC28, a1, a2, a3, a4);
  *a1 = a2;
  a1[1] = a3;
  a1[2] = a4;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    result = (void **)sub_11008(*((_QWORD *)off_5F148 + 19), 0xDu, (__int64)&unk_4DC28);
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002C584) ----------------------------------------------------
void __fastcall sub_2C584(PVOID P)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_17984(*((_QWORD *)off_5F148 + 19), 0xEu, (__int64)&unk_4DC28, P);
  if ( *(_QWORD *)P )
    (*(void (__fastcall **)(PVOID))P)(P);
  sub_26488(P, 0x54736352u);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xFu, (__int64)&unk_4DC28);
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002C640) ----------------------------------------------------
__int64 __fastcall sub_2C640(__int64 a1)
{
  void **v2; // rcx
  __int64 (__fastcall *v3)(__int64); // rax
  int v4; // eax
  unsigned int v5; // ebx
  __int64 result; // rax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x10u, (__int64)&unk_4DC28, a1);
    v2 = (void **)off_5F148;
  }
  v3 = *(__int64 (__fastcall **)(__int64))(a1 + 8);
  if ( v3 )
  {
    v4 = v3(a1);
    v5 = v4;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x11u, (__int64)&unk_4DC28, v4);
    result = v5;
  }
  else
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 8) != 0 && *((_BYTE *)v2 + 169) >= 5u )
      sub_11008((__int64)v2[19], 0x12u, (__int64)&unk_4DC28);
    result = 0i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002C724) ----------------------------------------------------
__int64 __fastcall sub_2C724(__int64 a1, void **a2, int *a3)
{
  unsigned int v6; // eax
  size_t v7; // r12
  __int64 (__fastcall *v9)(__int64, void **, int *); // rax
  __int64 v10; // [rsp+20h] [rbp-38h]
  int v11; // [rsp+30h] [rbp-28h]

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    v11 = *a3;
    sub_28E34(*((_QWORD *)off_5F148 + 19), 0x13u, (__int64)&unk_4DC28, a1, a2, a3, v11);
  }
  v6 = sub_2C640(a1);
  v7 = v6;
  if ( v6 > *a3 )
    return 2147483651i64;
  v9 = *(__int64 (__fastcall **)(__int64, void **, int *))(a1 + 16);
  if ( v9 )
    return v9(a1, a2, a3);
  memmove(*a2, (const void *)(a1 + 24), v7);
  *a2 = (char *)*a2 + v7;
  *a3 -= v7;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    LODWORD(v10) = *a3;
    sub_17814(*((_QWORD *)off_5F148 + 19), 0x14u, (__int64)&unk_4DC28, *a2, v10);
  }
  return 0i64;
}
// 2C812: variable 'v10' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000002C838) ----------------------------------------------------
void __fastcall DeferredRoutine(_KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
  if ( DeferredContext )
    ((void (__fastcall *)(_KDPC *, PVOID, PVOID, PVOID))DeferredContext)(
      Dpc,
      DeferredContext,
      SystemArgument1,
      SystemArgument2);
  KeSetTimer(&Timer, (LARGE_INTEGER)qword_621A0, &::Dpc);
}
// 621A0: using guessed type __int64 qword_621A0;

//----- (000000000002C86C) ----------------------------------------------------
__int64 sub_2C86C()
{
  unsigned __int8 v0; // bl
  unsigned __int8 v2; // [rsp+48h] [rbp+10h]
  unsigned __int8 v3; // [rsp+50h] [rbp+18h]

  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 0x12u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0xAu, (__int64)&unk_4DC18, 1);
  }
  v0 = KeGetCurrentIrql();
  __writecr8(2ui64);
  v3 = 0;
  KeStallExecutionProcessor(1u);
  v2 = 0;
  __writecr8(v0);
  qword_61BD0 = v2 - (unsigned __int64)v3;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 0x12u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_28CB4(*((_QWORD *)off_5F148 + 19), 0xBu, (__int64)&unk_4DC18, 1);
  }
  KeQueryPerformanceCounter(&PerformanceFrequency);
  byte_5F497 = 1;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 0x12u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0xCu, (__int64)&unk_4DC18, 0);
  }
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;
// 5F497: using guessed type char byte_5F497;
// 61BD0: using guessed type __int64 qword_61BD0;

//----- (000000000002C9A0) ----------------------------------------------------
__int64 __fastcall sub_2C9A0(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+88h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, a3, a2, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002C9F4) ----------------------------------------------------
__int64 __fastcall sub_2C9F4(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, __int64 a6, int a7)
{
  int v8; // [rsp+98h] [rbp+20h] BYREF

  v8 = a4;
  a7 = 0;
  return qword_5F3B8(a1, 43i64, &unk_4DC08, 125i64, &v8);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002CA64) ----------------------------------------------------
__int64 __fastcall sub_2CA64(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+98h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DC08, a2, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002CAD0) ----------------------------------------------------
__int64 __fastcall sub_2CAD0(__int64 a1)
{
  int v2; // [rsp+98h] [rbp+20h] BYREF

  v2 = 0;
  return qword_5F3B8(a1, 43i64, &unk_4DC08, 58i64, &v2);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002CB44) ----------------------------------------------------
__int64 __fastcall sub_2CB44(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+88h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DC08, a2, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002CBA0) ----------------------------------------------------
__int64 __fastcall sub_2CBA0(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+98h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DC08, 115i64, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002CC10) ----------------------------------------------------
__int64 __fastcall sub_2CC10(__int64 a1, __int64 a2, _QWORD *a3)
{
  bool v5; // r13
  void **v6; // rcx
  unsigned __int16 v7; // dx
  unsigned int v8; // edi
  int v9; // er9
  unsigned int v10; // eax
  _WORD *v11; // rdx
  char *v12; // rax
  char *v13; // rbx
  PVOID v14; // rax
  unsigned int v15; // edx
  __int64 v16; // r8
  _QWORD *v17; // rax
  char *v18; // rcx
  unsigned int *v19; // rbx
  unsigned int v20; // eax
  void *v21; // rcx

  v5 = 0;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xAu, (__int64)&unk_4DC08);
    v6 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v6 == &off_5F148 || !_bittest((const signed __int32 *)v6 + 43, 8u) || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_12;
    v7 = 11;
    goto LABEL_10;
  }
  v9 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 0xFF000000) != 0x2000000 || (v9 & 0xFFFF00) == 0 || (_BYTE)v9 )
  {
    if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 43, 8u) && *((_BYTE *)v6 + 169) >= 2u )
    {
      sub_1102C((__int64)v6[19], 0xCu, (__int64)&unk_4DC08, v9);
      v6 = (void **)off_5F148;
    }
    v8 = 4;
    goto LABEL_63;
  }
  v10 = 0;
  v11 = (_WORD *)(a1 + 4);
  do
  {
    if ( !*v11 )
      break;
    ++v10;
    ++v11;
  }
  while ( v10 < 0x40 );
  if ( v10 >= 0x40 )
  {
    if ( v6 == &off_5F148 || !_bittest((const signed __int32 *)v6 + 43, 8u) || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_12;
    v7 = 13;
LABEL_10:
    sub_11008((__int64)v6[19], v7, (__int64)&unk_4DC08);
LABEL_11:
    v6 = (void **)off_5F148;
LABEL_12:
    v8 = 4;
    goto LABEL_67;
  }
  if ( !a3 || !*a3 )
  {
    if ( v6 == &off_5F148 || !_bittest((const signed __int32 *)v6 + 43, 8u) || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_12;
    sub_17984((__int64)v6[19], 0xEu, (__int64)&unk_4DC08, a3);
    goto LABEL_11;
  }
  v12 = (char *)sub_26404(2, 0x1F4u, 0x66634E4Eu);
  v13 = v12;
  qword_61BE0 = v12;
  if ( !v12 )
  {
    v6 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && _bittest((const signed __int32 *)off_5F148 + 43, 8u) && *((_BYTE *)off_5F148 + 169) )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0xFu, (__int64)&unk_4DC08, 148);
      v6 = (void **)off_5F148;
      v13 = (char *)qword_61BE0;
    }
    v8 = 3;
    goto LABEL_68;
  }
  memset(v12, 0, 0x1F4ui64);
  if ( v13 == (char *)-128i64 )
  {
LABEL_39:
    v6 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && _bittest((const signed __int32 *)off_5F148 + 43, 8u) && *((_BYTE *)off_5F148 + 169) )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x10u, (__int64)&unk_4DC08);
      v6 = (void **)off_5F148;
      v13 = (char *)qword_61BE0;
    }
    v8 = 9;
    goto LABEL_68;
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 0x20) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
    sub_26384(*((_QWORD *)off_5F148 + 11), 0x1Du);
  v5 = sub_27C24((struct _KEVENT **)v13 + 23, 1);
  sub_27120((__int64)(v13 + 128));
  *((_DWORD *)v13 + 48) = 0;
  *((_DWORD *)v13 + 49) = 0;
  v13[200] = 0;
  if ( !v5 )
  {
    v13 = (char *)qword_61BE0;
    goto LABEL_39;
  }
  v14 = sub_26404(1, 4 * (unsigned int)*(unsigned __int8 *)(a1 + 136), 0x66634E4Eu);
  v13 = (char *)qword_61BE0;
  *((_QWORD *)qword_61BE0 + 26) = v14;
  if ( v14 )
  {
    v15 = 0;
    if ( *(_BYTE *)(a1 + 136) )
    {
      v16 = 0i64;
      do
      {
        *(_DWORD *)(v16 + *((_QWORD *)v13 + 26)) = *(_DWORD *)a1 | ++v15;
        v16 += 4i64;
      }
      while ( v15 < *(unsigned __int8 *)(a1 + 136) );
    }
    *(_DWORD *)v13 = 2;
    *((_DWORD *)v13 + 1) = 148;
    v13[8] = 0;
    *((_DWORD *)v13 + 4) = *(_DWORD *)a1;
    v13[20] = *(_BYTE *)(a1 + 136);
    *((_QWORD *)v13 + 3) = *((_QWORD *)v13 + 26);
    *((_QWORD *)v13 + 4) = sub_2E790;
    sub_26ADC((PERESOURCE)(v13 + 216));
    v17 = (char *)qword_61BE0 + 56;
    v18 = (char *)qword_61BE0 + 72;
    *((_QWORD *)qword_61BE0 + 8) = (char *)qword_61BE0 + 56;
    *v17 = v17;
    sub_27120((__int64)v18);
    v19 = (unsigned int *)qword_61BE0;
    memmove((char *)qword_61BE0 + 320, a3, 0x20ui64);
    v20 = sub_300A8((__int16 *)(a1 + 4), *(_DWORD *)(a1 + 132), v19 + 4);
    v6 = (void **)off_5F148;
    v8 = v20;
LABEL_63:
    if ( !v8 )
      goto LABEL_72;
    v13 = (char *)qword_61BE0;
    goto LABEL_65;
  }
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && _bittest((const signed __int32 *)off_5F148 + 43, 8u) && *((_BYTE *)off_5F148 + 169) )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x11u, (__int64)&unk_4DC08, 4 * *(unsigned __int8 *)(a1 + 136));
    v6 = (void **)off_5F148;
    v13 = (char *)qword_61BE0;
  }
  v8 = 3;
LABEL_65:
  if ( !v5 )
    goto LABEL_68;
  sub_4AE98((__int64)(v13 + 128));
  v6 = (void **)off_5F148;
LABEL_67:
  v13 = (char *)qword_61BE0;
LABEL_68:
  if ( v13 )
  {
    v21 = (void *)*((_QWORD *)v13 + 26);
    if ( v21 )
    {
      sub_26488(v21, 0x66634E4Eu);
      v13 = (char *)qword_61BE0;
    }
    sub_26488(v13, 0x66634E4Eu);
    v6 = (void **)off_5F148;
    qword_61BE0 = 0i64;
  }
LABEL_72:
  if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 43, 8u) && *((_BYTE *)v6 + 169) >= 5u )
    sub_1102C((__int64)v6[19], 0x12u, (__int64)&unk_4DC08, v8);
  return v8;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002D188) ----------------------------------------------------
__int64 sub_2D188()
{
  char v0; // di
  void **v1; // rcx
  PVOID v2; // rdx
  unsigned int v3; // ebx
  void *v4; // rcx
  int v5; // eax
  _QWORD *v6; // rax
  unsigned int v7; // eax
  PRKEVENT *v8; // rbx
  int v9; // eax

  v0 = 0;
  v1 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x13u, (__int64)&unk_4DC08);
    v1 = (void **)off_5F148;
  }
  v2 = qword_61BE0;
  if ( !qword_61BE0 )
  {
    if ( v1 != &off_5F148 && _bittest((const signed __int32 *)v1 + 43, 8u) && *((_BYTE *)v1 + 169) >= 2u )
    {
      sub_11008((__int64)v1[19], 0x14u, (__int64)&unk_4DC08);
      v1 = (void **)off_5F148;
    }
    v3 = 16;
    goto LABEL_62;
  }
  if ( *((_QWORD *)qword_61BE0 + 5) )
  {
    if ( v1 != &off_5F148 && _bittest((const signed __int32 *)v1 + 43, 8u) && *((_BYTE *)v1 + 169) >= 2u )
    {
      sub_11008((__int64)v1[19], 0x15u, (__int64)&unk_4DC08);
      v1 = (void **)off_5F148;
    }
    v3 = 6;
    goto LABEL_62;
  }
  v4 = (void *)*((_QWORD *)qword_61BE0 + 26);
  if ( v4 )
  {
    sub_26488(v4, 0x66634E4Eu);
    v2 = qword_61BE0;
    *((_QWORD *)qword_61BE0 + 26) = 0i64;
  }
  v5 = sub_30B00(6u, (__int64)v2 + 40);
  v3 = v5;
  if ( v5 )
  {
    v1 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
      && *((_BYTE *)off_5F148 + 169) >= 2u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x16u, (__int64)&unk_4DC08, v5);
      v1 = (void **)off_5F148;
    }
LABEL_54:
    if ( !v3 || !v0 )
      goto LABEL_62;
    sub_4AF10((PFAST_MUTEX)((char *)qword_61BE0 + 128));
LABEL_26:
    v1 = (void **)off_5F148;
    goto LABEL_62;
  }
  v6 = (_QWORD *)*((_QWORD *)qword_61BE0 + 5);
  if ( !v6 || !*v6 || !v6[1] || !v6[2] || !v6[3] || !v6[4] || !v6[5] || !v6[6] || !v6[7] || !v6[8] || !v6[9] || !v6[10] )
  {
    v3 = 2;
    goto LABEL_26;
  }
  v7 = ((__int64 (__fastcall *)(_QWORD, char *))*v6)(*((unsigned int *)qword_61BE0 + 4), (char *)qword_61BE0 + 48);
  if ( v7 < 0x700 )
  {
    v8 = (PRKEVENT *)((char *)qword_61BE0 + 128);
    if ( qword_61BE0 != (PVOID)-128i64
      && !*((_DWORD *)qword_61BE0 + 48)
      && !*((_BYTE *)qword_61BE0 + 200)
      && !*((_DWORD *)qword_61BE0 + 49) )
    {
      sub_27200((PFAST_MUTEX)((char *)qword_61BE0 + 128));
      sub_26FEC(v8[7]);
      v0 = 1;
      *((_BYTE *)v8 + 72) = 1;
      sub_272CC((PFAST_MUTEX)v8);
      v9 = sub_2ED48();
      v3 = v9;
      if ( !v9 )
        goto LABEL_26;
      v1 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
        && *((_BYTE *)off_5F148 + 169) >= 2u )
      {
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x19u, (__int64)&unk_4DC08, v9);
        v1 = (void **)off_5F148;
      }
      v3 = 0;
      goto LABEL_54;
    }
    v1 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
      && *((_BYTE *)off_5F148 + 169) >= 2u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x18u, (__int64)&unk_4DC08);
      v1 = (void **)off_5F148;
    }
    v3 = 9;
  }
  else
  {
    v1 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
      && *((_BYTE *)off_5F148 + 169) >= 2u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x17u, (__int64)&unk_4DC08, v7);
      v1 = (void **)off_5F148;
    }
    v3 = 8;
  }
LABEL_62:
  if ( v1 != &off_5F148 && _bittest((const signed __int32 *)v1 + 43, 8u) && *((_BYTE *)v1 + 169) >= 5u )
    sub_1102C((__int64)v1[19], 0x1Au, (__int64)&unk_4DC08, v3);
  return v3;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002D528) ----------------------------------------------------
__int64 (**sub_2D528())(void)
{
  void **v0; // rcx
  __int64 (**result)(void); // rax
  unsigned __int16 v2; // dx

  v0 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1Bu, (__int64)&unk_4DC08);
    v0 = (void **)off_5F148;
  }
  result = (__int64 (**)(void))qword_61BE0;
  if ( qword_61BE0 )
  {
    sub_4AF10((PFAST_MUTEX)((char *)qword_61BE0 + 128));
    result = (__int64 (**)(void))*((_QWORD *)qword_61BE0 + 5);
    if ( result && *((_QWORD *)qword_61BE0 + 6) )
    {
      result = (__int64 (**)(void))result[1]();
      *((_QWORD *)qword_61BE0 + 6) = 0i64;
    }
    v0 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
      && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      v2 = 30;
      return (__int64 (**)(void))sub_11008((__int64)v0[19], v2, (__int64)&unk_4DC08);
    }
  }
  else if ( v0 != &off_5F148 )
  {
    if ( _bittest((const signed __int32 *)v0 + 43, 8u) && *((_BYTE *)v0 + 169) >= 2u )
    {
      result = (__int64 (**)(void))sub_11008((__int64)v0[19], (unsigned __int16)qword_61BE0 + 28, (__int64)&unk_4DC08);
      v0 = (void **)off_5F148;
    }
    if ( v0 != &off_5F148 && _bittest((const signed __int32 *)v0 + 43, 8u) && *((_BYTE *)v0 + 169) >= 5u )
    {
      v2 = 29;
      return (__int64 (**)(void))sub_11008((__int64)v0[19], v2, (__int64)&unk_4DC08);
    }
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002D654) ----------------------------------------------------
void sub_2D654()
{
  void **v0; // rcx
  unsigned __int16 v1; // dx
  char *v2; // rcx
  _QWORD *v3; // rcx
  _QWORD *v4; // rax
  _QWORD **v5; // rdx

  v0 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1Fu, (__int64)&unk_4DC08);
    v0 = (void **)off_5F148;
  }
  if ( qword_61BE0 )
  {
    sub_30C50();
    sub_4AE98((__int64)qword_61BE0 + 128);
    v2 = (char *)qword_61BE0;
    if ( !*((_QWORD *)qword_61BE0 + 26) )
      goto LABEL_18;
    v3 = (_QWORD *)*((_QWORD *)qword_61BE0 + 26);
    while ( 1 )
    {
      sub_26488(v3, 0x66634E4Eu);
      v2 = (char *)qword_61BE0;
LABEL_18:
      v5 = (_QWORD **)(v2 + 56);
      if ( *v5 == v5 )
        break;
      v4 = (_QWORD *)**v5;
      v3 = *v5 - 5;
      *v5 = v4;
      v4[1] = v5;
    }
    sub_26BB0((PERESOURCE)(v2 + 216));
    sub_26488(qword_61BE0, 0x66634E4Eu);
    qword_61BE0 = 0i64;
    v0 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
      && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      v1 = 34;
      goto LABEL_23;
    }
  }
  else if ( v0 != &off_5F148 )
  {
    if ( _bittest((const signed __int32 *)v0 + 43, 8u) && *((_BYTE *)v0 + 169) >= 2u )
    {
      sub_11008((__int64)v0[19], 0x20u, (__int64)&unk_4DC08);
      v0 = (void **)off_5F148;
    }
    if ( v0 != &off_5F148 && _bittest((const signed __int32 *)v0 + 43, 8u) && *((_BYTE *)v0 + 169) >= 5u )
    {
      v1 = 33;
LABEL_23:
      sub_11008((__int64)v0[19], v1, (__int64)&unk_4DC08);
      return;
    }
  }
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002D7F0) ----------------------------------------------------
__int64 __fastcall sub_2D7F0(__int64 a1, void *a2)
{
  void *v2; // rsi
  unsigned int v3; // edi
  void **v4; // rcx
  char *v5; // rbx
  int v8; // [rsp+28h] [rbp-30h]
  unsigned int v9; // [rsp+30h] [rbp-28h] BYREF
  char v10[36]; // [rsp+34h] [rbp-24h] BYREF
  size_t MaxCount; // [rsp+78h] [rbp+20h] BYREF

  v2 = a2;
  v3 = 0;
  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    v8 = 34;
    sub_142F4(*((_QWORD *)off_5F148 + 19), 0x25u, (__int64)&unk_4DC08, 33644569);
    v4 = (void **)off_5F148;
  }
  if ( qword_61BE0 )
  {
    if ( *((_BYTE *)qword_61BE0 + 20) > 0x18u )
    {
      if ( v2 )
      {
        if ( (*((unsigned __int8 (__fastcall **)(__int64, unsigned int *, size_t *, char *, void *, int))qword_61BE0 + 40))(
               33644569i64,
               &v9,
               &MaxCount,
               v10,
               a2,
               v8) )
        {
          if ( (unsigned int)MaxCount <= 0x22 )
          {
            KeEnterCriticalRegion();
            sub_26D5C((PERESOURCE)((char *)qword_61BE0 + 216));
            v5 = (char *)qword_61BE0;
            memmove(v2, (char *)qword_61BE0 + v9 + 352, (unsigned int)MaxCount);
            sub_26E34((PERESOURCE)(v5 + 216));
            KeLeaveCriticalRegion();
            v4 = (void **)off_5F148;
            goto LABEL_34;
          }
          v4 = (void **)off_5F148;
          if ( off_5F148 == &off_5F148
            || !_bittest((const signed __int32 *)off_5F148 + 43, 8u)
            || *((_BYTE *)off_5F148 + 169) < 2u )
          {
            goto LABEL_17;
          }
          sub_2CB44(*((_QWORD *)off_5F148 + 19), 0x2Au, (__int64)&unk_4DC08, MaxCount);
        }
        else
        {
          v4 = (void **)off_5F148;
          if ( off_5F148 == &off_5F148
            || !_bittest((const signed __int32 *)off_5F148 + 43, 8u)
            || *((_BYTE *)off_5F148 + 169) < 2u )
          {
            goto LABEL_17;
          }
          sub_1102C(*((_QWORD *)off_5F148 + 19), 0x29u, (__int64)&unk_4DC08, 33644569);
        }
      }
      else
      {
        if ( v4 == &off_5F148 || !_bittest((const signed __int32 *)v4 + 43, 8u) || *((_BYTE *)v4 + 169) < 2u )
          goto LABEL_17;
        sub_11008((__int64)v4[19], 0x28u, (__int64)&unk_4DC08);
      }
    }
    else
    {
      if ( v4 == &off_5F148 || !_bittest((const signed __int32 *)v4 + 43, 8u) || *((_BYTE *)v4 + 169) < 2u )
        goto LABEL_17;
      sub_127D0((__int64)v4[19], 0x27u, (__int64)&unk_4DC08, 33644569);
    }
    v4 = (void **)off_5F148;
LABEL_17:
    v3 = 4;
    goto LABEL_34;
  }
  if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 43, 8u) && *((_BYTE *)v4 + 169) >= 2u )
  {
    sub_11008((__int64)v4[19], 0x26u, (__int64)&unk_4DC08);
    v4 = (void **)off_5F148;
  }
  v3 = 16;
LABEL_34:
  if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 43, 8u) && *((_BYTE *)v4 + 169) >= 5u )
    sub_1102C((__int64)v4[19], 0x2Bu, (__int64)&unk_4DC08, v3);
  return v3;
}
// 2D93D: variable 'a2' is possibly undefined
// 2D93D: variable 'v8' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000002DA90) ----------------------------------------------------
__int64 __fastcall sub_2DA90(unsigned int a1)
{
  void **v2; // r10
  unsigned __int16 v3; // dx
  unsigned __int8 (__fastcall *v5)(_QWORD, unsigned int *, size_t *, char *); // r11
  __int64 v6; // rcx
  unsigned __int16 v7; // dx
  char *v8; // rbx
  char v9[40]; // [rsp+30h] [rbp-28h] BYREF
  unsigned int Dst; // [rsp+68h] [rbp+10h] BYREF
  size_t MaxCount; // [rsp+70h] [rbp+18h] BYREF
  unsigned int v12; // [rsp+78h] [rbp+20h] BYREF

  Dst = 0;
  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x2Cu, (__int64)&unk_4DC08, a1);
    v2 = (void **)off_5F148;
  }
  if ( !qword_61BE0 )
  {
    if ( v2 == &off_5F148 || !_bittest((const signed __int32 *)v2 + 43, 8u) || *((_BYTE *)v2 + 169) < 2u )
      return 0i64;
    v3 = (_WORD)qword_61BE0 + 45;
    goto LABEL_10;
  }
  v5 = (unsigned __int8 (__fastcall *)(_QWORD, unsigned int *, size_t *, char *))*((_QWORD *)qword_61BE0 + 40);
  if ( !v5 )
  {
    if ( v2 == &off_5F148 || !_bittest((const signed __int32 *)v2 + 43, 8u) || *((_BYTE *)v2 + 169) < 2u )
      return 0i64;
    v3 = 46;
LABEL_10:
    sub_11008((__int64)v2[19], v3, (__int64)&unk_4DC08);
    return 0i64;
  }
  if ( (unsigned __int8)(a1 - 1) >= (unsigned int)*((unsigned __int8 *)qword_61BE0 + 20) )
  {
    if ( v2 == &off_5F148 || !_bittest((const signed __int32 *)v2 + 43, 8u) || *((_BYTE *)v2 + 169) < 2u )
      return 0i64;
    v6 = (__int64)v2[19];
    v7 = 47;
    goto LABEL_22;
  }
  if ( !v5(a1, &v12, &MaxCount, v9) )
  {
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
      && *((_BYTE *)off_5F148 + 169) >= 2u )
    {
      sub_127D0(*((_QWORD *)off_5F148 + 19), 0x30u, (__int64)&unk_4DC08, a1);
    }
    return 0i64;
  }
  if ( (unsigned int)MaxCount > 4 )
  {
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 43, 8u)
      || *((_BYTE *)off_5F148 + 169) < 2u )
    {
      return 0i64;
    }
    v6 = *((_QWORD *)off_5F148 + 19);
    v7 = 49;
LABEL_22:
    sub_2CB44(v6, v7, (__int64)&unk_4DC08, a1);
    return 0i64;
  }
  KeEnterCriticalRegion();
  sub_26D5C((PERESOURCE)((char *)qword_61BE0 + 216));
  v8 = (char *)qword_61BE0;
  memmove(&Dst, (char *)qword_61BE0 + v12 + 352, (unsigned int)MaxCount);
  sub_26E34((PERESOURCE)(v8 + 216));
  KeLeaveCriticalRegion();
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x32u, (__int64)&unk_4DC08, Dst);
  }
  return Dst;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002DCFC) ----------------------------------------------------
__int64 __fastcall sub_2DCFC(__int64 a1, unsigned int a2, _QWORD *a3, _DWORD *a4)
{
  _DWORD *v4; // rbp
  _QWORD *v5; // rdi
  unsigned int v7; // ebx
  void **v8; // rcx
  unsigned __int16 v9; // dx
  unsigned __int16 v10; // dx
  __int64 v11; // rsi
  __int64 v12; // r12
  int v13; // eax
  char v17; // [rsp+80h] [rbp+18h] BYREF

  v4 = a4;
  v5 = a3;
  v7 = 0;
  v8 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_2CAD0(*((_QWORD *)off_5F148 + 19));
    v8 = (void **)off_5F148;
  }
  if ( !v5 )
  {
    if ( v8 == &off_5F148 || !_bittest((const signed __int32 *)v8 + 43, 8u) || *((_BYTE *)v8 + 169) < 2u )
      goto LABEL_11;
    v9 = 59;
LABEL_10:
    sub_11008((__int64)v8[19], v9, (__int64)&unk_4DC08);
    v8 = (void **)off_5F148;
LABEL_11:
    v7 = 4;
    goto LABEL_47;
  }
  if ( !v4 )
  {
    if ( v8 == &off_5F148 || !_bittest((const signed __int32 *)v8 + 43, 8u) || *((_BYTE *)v8 + 169) < 2u )
      goto LABEL_11;
    v9 = 60;
    goto LABEL_10;
  }
  if ( !qword_61BE0 )
  {
    if ( v8 == &off_5F148 || !_bittest((const signed __int32 *)v8 + 43, 8u) || *((_BYTE *)v8 + 169) < 2u )
      goto LABEL_23;
    v10 = 61;
LABEL_22:
    sub_11008((__int64)v8[19], v10, (__int64)&unk_4DC08);
    v8 = (void **)off_5F148;
LABEL_23:
    v7 = 16;
    goto LABEL_47;
  }
  v11 = *((_QWORD *)qword_61BE0 + 5);
  if ( !v11 )
  {
    if ( v8 == &off_5F148 || !_bittest((const signed __int32 *)v8 + 43, 8u) || *((_BYTE *)v8 + 169) < 2u )
      goto LABEL_23;
    v10 = 62;
    goto LABEL_22;
  }
  v12 = *((_QWORD *)qword_61BE0 + 6);
  if ( (*(unsigned int (__fastcall **)(__int64, _QWORD, char *))(v11 + 40))(v12, 0i64, &v17) || !v17 )
  {
    v8 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 43, 8u)
      || *((_BYTE *)off_5F148 + 169) < 2u )
    {
      goto LABEL_46;
    }
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x3Fu, (__int64)&unk_4DC08, 0);
    goto LABEL_45;
  }
  *v5 = 0i64;
  *v4 = 0;
  v13 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD *, _DWORD *, _QWORD *, _DWORD *))(v11 + 16))(
          v12,
          0i64,
          a2,
          v5,
          v4,
          a3,
          a4);
  if ( v13 || !*v5 )
  {
    v8 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 43, 8u)
      || *((_BYTE *)off_5F148 + 169) < 2u )
    {
      goto LABEL_46;
    }
    sub_2C9A0(*((_QWORD *)off_5F148 + 19), 0x40u, (__int64)&unk_4DC08, v13);
LABEL_45:
    v8 = (void **)off_5F148;
LABEL_46:
    v7 = 8;
    goto LABEL_47;
  }
  v8 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return v7;
  if ( _bittest((const signed __int32 *)off_5F148 + 43, 8u) && *((_BYTE *)off_5F148 + 169) >= 4u )
  {
    sub_2CA64(*((_QWORD *)off_5F148 + 19), 0x41u, (__int64)&unk_4DC08, a2);
    v8 = (void **)off_5F148;
  }
LABEL_47:
  if ( v8 != &off_5F148 && _bittest((const signed __int32 *)v8 + 43, 8u) && *((_BYTE *)v8 + 169) >= 5u )
    sub_1102C((__int64)v8[19], 0x42u, (__int64)&unk_4DC08, v7);
  return v7;
}
// 2DE8E: variable 'a3' is possibly undefined
// 2DE8E: variable 'a4' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000002DFD4) ----------------------------------------------------
__int64 __fastcall sub_2DFD4(__int64 a1)
{
  unsigned int v2; // ebx
  void **v3; // rcx
  unsigned __int16 v4; // dx
  char v5; // si
  int v6; // eax

  v2 = 0;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x43u, (__int64)&unk_4DC08, a1);
    v3 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 43, 8u) && *((_BYTE *)v3 + 169) >= 2u )
    {
      sub_11008((__int64)v3[19], 0x44u, (__int64)&unk_4DC08);
      v3 = (void **)off_5F148;
    }
    v2 = 4;
    goto LABEL_38;
  }
  if ( !qword_61BE0 )
  {
    if ( v3 == &off_5F148 || !_bittest((const signed __int32 *)v3 + 43, 8u) || *((_BYTE *)v3 + 169) < 2u )
      goto LABEL_17;
    v4 = (_WORD)qword_61BE0 + 69;
LABEL_16:
    sub_11008((__int64)v3[19], v4, (__int64)&unk_4DC08);
    v3 = (void **)off_5F148;
LABEL_17:
    v2 = 16;
    goto LABEL_38;
  }
  if ( !*((_QWORD *)qword_61BE0 + 5) )
  {
    if ( v3 == &off_5F148 || !_bittest((const signed __int32 *)v3 + 43, 8u) || *((_BYTE *)v3 + 169) < 2u )
      goto LABEL_17;
    v4 = 70;
    goto LABEL_16;
  }
  v5 = sub_4AFB8((PFAST_MUTEX)((char *)qword_61BE0 + 128));
  if ( v5 )
  {
    v6 = (*(__int64 (__fastcall **)(_QWORD, __int64))(*((_QWORD *)qword_61BE0 + 5) + 32i64))(
           *((_QWORD *)qword_61BE0 + 6),
           a1);
    if ( v6 )
    {
      v3 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
        && *((_BYTE *)off_5F148 + 169) >= 2u )
      {
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x48u, (__int64)&unk_4DC08, v6);
        v3 = (void **)off_5F148;
      }
      v2 = 8;
    }
    else
    {
      v3 = (void **)off_5F148;
    }
  }
  else
  {
    v3 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
      && *((_BYTE *)off_5F148 + 169) >= 2u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x47u, (__int64)&unk_4DC08);
      v3 = (void **)off_5F148;
    }
    v2 = 9;
  }
  if ( v5 )
  {
    sub_4B020((PFAST_MUTEX)((char *)qword_61BE0 + 128));
    v3 = (void **)off_5F148;
  }
LABEL_38:
  if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 43, 8u) && *((_BYTE *)v3 + 169) >= 5u )
    sub_1102C((__int64)v3[19], 0x49u, (__int64)&unk_4DC08, v2);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002E210) ----------------------------------------------------
__int64 __fastcall sub_2E210(__int64 a1, unsigned int a2, __int64 a3, int a4)
{
  int v4; // er13
  unsigned int v7; // ebx
  void **v8; // rcx
  unsigned __int16 v9; // dx
  __int64 v10; // rdi
  __int64 v11; // rbp
  int v12; // eax
  __int64 v14; // [rsp+28h] [rbp-40h]
  char v16; // [rsp+80h] [rbp+18h] BYREF

  v4 = a4;
  v7 = 0;
  v8 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    HIDWORD(v14) = HIDWORD(a3);
    sub_2CA64(*((_QWORD *)off_5F148 + 19), 0x4Au, (__int64)&unk_4DC08, 0);
    v8 = (void **)off_5F148;
  }
  if ( !a3 )
  {
    if ( v8 != &off_5F148 && _bittest((const signed __int32 *)v8 + 43, 8u) && *((_BYTE *)v8 + 169) >= 2u )
    {
      sub_11008((__int64)v8[19], 0x4Bu, (__int64)&unk_4DC08);
      v8 = (void **)off_5F148;
    }
    v7 = 4;
    goto LABEL_44;
  }
  if ( !qword_61BE0 )
  {
    if ( v8 == &off_5F148 || !_bittest((const signed __int32 *)v8 + 43, 8u) || *((_BYTE *)v8 + 169) < 2u )
      goto LABEL_17;
    v9 = 76;
LABEL_16:
    sub_11008((__int64)v8[19], v9, (__int64)&unk_4DC08);
    v8 = (void **)off_5F148;
LABEL_17:
    v7 = 16;
    goto LABEL_44;
  }
  v10 = *((_QWORD *)qword_61BE0 + 5);
  if ( !v10 )
  {
    if ( v8 == &off_5F148 || !_bittest((const signed __int32 *)v8 + 43, 8u) || *((_BYTE *)v8 + 169) < 2u )
      goto LABEL_17;
    v9 = 77;
    goto LABEL_16;
  }
  v11 = *((_QWORD *)qword_61BE0 + 6);
  if ( v8 != &off_5F148 && _bittest((const signed __int32 *)v8 + 43, 8u) && *((_BYTE *)v8 + 169) >= 4u )
    sub_11008((__int64)v8[19], 0x4Eu, (__int64)&unk_4DC08);
  if ( (*(unsigned int (__fastcall **)(__int64, _QWORD, char *))(v10 + 40))(v11, 0i64, &v16) || !v16 )
  {
    v8 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 43, 8u)
      || *((_BYTE *)off_5F148 + 169) < 2u )
    {
      goto LABEL_43;
    }
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x4Fu, (__int64)&unk_4DC08, 0);
    goto LABEL_42;
  }
  LODWORD(v14) = v4;
  v12 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, __int64, __int64, int))(v10 + 24))(
          v11,
          0i64,
          0i64,
          a2,
          a3,
          v14,
          a4);
  if ( v12 )
  {
    v8 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 43, 8u)
      || *((_BYTE *)off_5F148 + 169) < 2u )
    {
      goto LABEL_43;
    }
    sub_2C9A0(*((_QWORD *)off_5F148 + 19), 0x50u, (__int64)&unk_4DC08, v12);
LABEL_42:
    v8 = (void **)off_5F148;
LABEL_43:
    v7 = 8;
    goto LABEL_44;
  }
  v8 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return v7;
  if ( _bittest((const signed __int32 *)off_5F148 + 43, 8u) && *((_BYTE *)off_5F148 + 169) >= 4u )
  {
    sub_127D0(*((_QWORD *)off_5F148 + 19), 0x51u, (__int64)&unk_4DC08, a2);
    v8 = (void **)off_5F148;
  }
LABEL_44:
  if ( v8 != &off_5F148 && _bittest((const signed __int32 *)v8 + 43, 8u) && *((_BYTE *)v8 + 169) >= 5u )
    sub_1102C((__int64)v8[19], 0x52u, (__int64)&unk_4DC08, v7);
  return v7;
}
// 2E3A9: variable 'v14' is possibly undefined
// 2E3A9: variable 'a4' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000002E4DC) ----------------------------------------------------
char *sub_2E4DC()
{
  char *v0; // rbx
  void **v1; // rcx
  unsigned int v3; // [rsp+58h] [rbp+10h] BYREF
  char v4; // [rsp+60h] [rbp+18h] BYREF
  char v5; // [rsp+68h] [rbp+20h] BYREF

  v0 = 0i64;
  v1 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x53u, (__int64)&unk_4DC08, 33644573);
    v1 = (void **)off_5F148;
  }
  if ( qword_61BE0 )
  {
    if ( *((_BYTE *)qword_61BE0 + 20) > 0x1Cu )
    {
      if ( (*((unsigned __int8 (__fastcall **)(__int64, unsigned int *, char *, char *))qword_61BE0 + 40))(
             33644573i64,
             &v3,
             &v5,
             &v4) )
      {
        KeEnterCriticalRegion();
        sub_26D5C((PERESOURCE)((char *)qword_61BE0 + 216));
        v0 = (char *)qword_61BE0 + v3 + 352;
      }
      else
      {
        v1 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 )
          return v0;
        if ( !_bittest((const signed __int32 *)off_5F148 + 43, 8u) || *((_BYTE *)off_5F148 + 169) < 2u )
          goto LABEL_22;
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x56u, (__int64)&unk_4DC08, 33644573);
      }
    }
    else
    {
      if ( v1 == &off_5F148 )
        return v0;
      if ( !_bittest((const signed __int32 *)v1 + 43, 8u) || *((_BYTE *)v1 + 169) < 2u )
        goto LABEL_22;
      sub_127D0((__int64)v1[19], 0x55u, (__int64)&unk_4DC08, 33644573);
    }
    goto LABEL_21;
  }
  if ( v1 == &off_5F148 )
    return v0;
  if ( _bittest((const signed __int32 *)v1 + 43, 8u) && *((_BYTE *)v1 + 169) >= 2u )
  {
    sub_11008((__int64)v1[19], 0x54u, (__int64)&unk_4DC08);
LABEL_21:
    v1 = (void **)off_5F148;
  }
LABEL_22:
  if ( v1 != &off_5F148 && _bittest((const signed __int32 *)v1 + 43, 8u) && *((_BYTE *)v1 + 169) >= 5u )
    sub_17984((__int64)v1[19], 0x57u, (__int64)&unk_4DC08, v0);
  return v0;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002E6AC) ----------------------------------------------------
void sub_2E6AC()
{
  void **v0; // rcx

  v0 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x58u, (__int64)&unk_4DC08);
    v0 = (void **)off_5F148;
  }
  if ( qword_61BE0 )
  {
    sub_26E34((PERESOURCE)((char *)qword_61BE0 + 216));
    KeLeaveCriticalRegion();
    goto LABEL_11;
  }
  if ( v0 == &off_5F148 )
    return;
  if ( _bittest((const signed __int32 *)v0 + 43, 8u) && *((_BYTE *)v0 + 169) >= 2u )
  {
    sub_11008((__int64)v0[19], (_WORD)qword_61BE0 + 89, (__int64)&unk_4DC08);
LABEL_11:
    v0 = (void **)off_5F148;
  }
  if ( v0 != &off_5F148 && _bittest((const signed __int32 *)v0 + 43, 8u) && *((_BYTE *)v0 + 169) >= 5u )
    sub_11008((__int64)v0[19], 0x5Au, (__int64)&unk_4DC08);
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002E790) ----------------------------------------------------
__int64 __fastcall sub_2E790(__int64 a1)
{
  char *v1; // r8
  unsigned int v2; // ebx
  __int64 (__fastcall **v4)(_QWORD, _QWORD); // r13
  __int64 v5; // r14
  int v6; // ebp
  void **v7; // rcx
  _DWORD *v8; // rdi
  unsigned __int16 v10; // dx
  unsigned __int16 v11; // dx
  int v12; // edx
  int *v13; // rdi
  int *v14; // rbp
  int v15; // edi
  int *v16; // rbp
  int v17; // edi

  v1 = (char *)qword_61BE0;
  v2 = 0;
  v4 = (__int64 (__fastcall **)(_QWORD, _QWORD))*((_QWORD *)qword_61BE0 + 5);
  v5 = *((_QWORD *)qword_61BE0 + 6);
  v6 = 0;
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x5Bu, (__int64)&unk_4DC08);
    v1 = (char *)qword_61BE0;
    v7 = (void **)off_5F148;
  }
  if ( !a1 )
    goto LABEL_6;
  v8 = *(_DWORD **)(a1 + 56);
  if ( !v8 )
    goto LABEL_6;
  switch ( *v8 )
  {
    case 0:
      v16 = v8 + 1;
      if ( v7 != &off_5F148 && _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 4u )
      {
        sub_11008((__int64)v7[19], 0x5Cu, (__int64)&unk_4DC08);
        v1 = (char *)qword_61BE0;
        v7 = (void **)off_5F148;
      }
      if ( v8 != (_DWORD *)-4i64 )
      {
        if ( !sub_4AFB8((PFAST_MUTEX)(v1 + 128)) )
          goto LABEL_26;
        v2 = sub_2FDD0(*v16);
        if ( v2 )
          goto LABEL_65;
        v17 = v4[9](v5, (unsigned int)*v16);
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
          && *((_BYTE *)off_5F148 + 169) >= 4u )
        {
          sub_127D0(*((_QWORD *)off_5F148 + 19), v2 + 93, (__int64)&unk_4DC08, *v16);
        }
        sub_4B020((PFAST_MUTEX)((char *)qword_61BE0 + 128));
        if ( !v17 )
          goto LABEL_26;
        v2 = 8;
        v7 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 )
        {
          if ( _bittest((const signed __int32 *)off_5F148 + 43, 8u) && *((_BYTE *)off_5F148 + 169) >= 2u )
          {
            v10 = 94;
            goto LABEL_91;
          }
          goto LABEL_93;
        }
        goto LABEL_53;
      }
LABEL_6:
      v2 = 2;
      goto LABEL_93;
    case 1:
      v14 = v8 + 1;
      if ( v7 != &off_5F148 && _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 4u )
      {
        sub_11008((__int64)v7[19], 0x5Fu, (__int64)&unk_4DC08);
        v1 = (char *)qword_61BE0;
        v7 = (void **)off_5F148;
      }
      if ( v8 != (_DWORD *)-4i64 )
      {
        if ( !sub_4AFB8((PFAST_MUTEX)(v1 + 128)) )
          goto LABEL_26;
        v2 = sub_2FF2C(*v14);
        if ( v2 )
        {
LABEL_65:
          sub_4B020((PFAST_MUTEX)((char *)qword_61BE0 + 128));
LABEL_92:
          v7 = (void **)off_5F148;
          goto LABEL_93;
        }
        v15 = v4[10](v5, (unsigned int)*v14);
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
          && *((_BYTE *)off_5F148 + 169) >= 4u )
        {
          sub_127D0(*((_QWORD *)off_5F148 + 19), 0x60u, (__int64)&unk_4DC08, *v14);
        }
        sub_4B020((PFAST_MUTEX)((char *)qword_61BE0 + 128));
        if ( !v15 )
          goto LABEL_26;
        v2 = 8;
        v7 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 )
        {
          if ( _bittest((const signed __int32 *)off_5F148 + 43, 8u) && *((_BYTE *)off_5F148 + 169) >= 2u )
          {
            v10 = 97;
            goto LABEL_91;
          }
LABEL_93:
          if ( v7 != &off_5F148 && _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 2u )
            sub_11008((__int64)v7[19], 0x68u, (__int64)&unk_4DC08);
          if ( v2 )
            goto LABEL_53;
          goto LABEL_98;
        }
LABEL_53:
        v12 = v2;
        goto LABEL_27;
      }
      goto LABEL_6;
    case 2:
      if ( sub_4AFB8((PFAST_MUTEX)(v1 + 128)) )
      {
        v2 = sub_2F414(v8[1], v8[2], v8[3], v8 + 4);
        sub_4B020((PFAST_MUTEX)((char *)qword_61BE0 + 128));
      }
      goto LABEL_53;
    case 3:
      if ( sub_4AFB8((PFAST_MUTEX)(v1 + 128)) )
      {
        v2 = sub_2FA0C((unsigned int)v8[1], v8[2], a1);
        sub_4B020((PFAST_MUTEX)((char *)qword_61BE0 + 128));
      }
      goto LABEL_28;
    case 4:
      v13 = v8 + 1;
      if ( v7 != &off_5F148 && _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 4u )
      {
        sub_11008((__int64)v7[19], 0x62u, (__int64)&unk_4DC08);
        v1 = (char *)qword_61BE0;
      }
      if ( sub_4AFB8((PFAST_MUTEX)(v1 + 128)) )
      {
        if ( v13 )
        {
          v6 = v4[8](v5, (unsigned int)*v13);
          if ( off_5F148 != &off_5F148
            && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
            && *((_BYTE *)off_5F148 + 169) >= 4u )
          {
            sub_127D0(*((_QWORD *)off_5F148 + 19), 0x63u, (__int64)&unk_4DC08, *v13);
          }
        }
        sub_4B020((PFAST_MUTEX)((char *)qword_61BE0 + 128));
        if ( !v13 || v6 )
        {
          v2 = 8;
          if ( off_5F148 != &off_5F148
            && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
            && *((_BYTE *)off_5F148 + 169) >= 2u )
          {
            sub_11008(*((_QWORD *)off_5F148 + 19), 0x64u, (__int64)&unk_4DC08);
          }
        }
      }
      goto LABEL_53;
    case 5:
      if ( v7 == &off_5F148 || !_bittest((const signed __int32 *)v7 + 43, 8u) || *((_BYTE *)v7 + 169) < 4u )
        goto LABEL_26;
      v11 = 101;
      goto LABEL_25;
  }
  if ( *v8 != 6 )
  {
    if ( *((_QWORD *)v1 + 43) )
      return (*((__int64 (__fastcall **)(__int64, _QWORD, char *, void *))v1 + 43))(
               a1,
               (unsigned int)(*v8 - 5),
               v1,
               &unk_4DC08);
    if ( v7 == &off_5F148 )
    {
LABEL_98:
      v2 = 17;
      goto LABEL_53;
    }
    if ( _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 3u )
    {
      v10 = 103;
LABEL_91:
      sub_11008((__int64)v7[19], v10, (__int64)&unk_4DC08);
      goto LABEL_92;
    }
    goto LABEL_93;
  }
  if ( v7 != &off_5F148 && _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 4u )
  {
    v11 = 102;
LABEL_25:
    sub_11008((__int64)v7[19], v11, (__int64)&unk_4DC08);
  }
LABEL_26:
  v12 = 0;
LABEL_27:
  sub_329E8(a1, v12, 0, 0i64);
LABEL_28:
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x69u, (__int64)&unk_4DC08, v2);
  }
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000002ED48) ----------------------------------------------------
__int64 sub_2ED48()
{
  __int64 v0; // rsi
  __int64 v1; // r15
  unsigned int v2; // er13
  int v3; // eax
  void *v4; // rbp
  void **v5; // r14
  unsigned int v6; // er12
  void (__fastcall *v7)(char *); // rax
  int v8; // eax
  void **v9; // r10
  _DWORD *v10; // r11
  unsigned int i; // er9
  void (__fastcall *v12)(int *); // rax
  PVOID v13; // r11
  int v14; // esi
  unsigned int v15; // eax
  unsigned int v16; // esi
  PVOID v17; // rax
  char *v18; // rbx
  int v19; // eax
  int v20; // ebx
  unsigned int v21; // eax
  unsigned int v22; // ebx
  int v23; // eax
  char *v24; // rsi
  size_t v25; // r8
  void (__fastcall *v26)(int *); // rax
  __int64 v28; // [rsp+20h] [rbp-A8h]
  __int64 v29; // [rsp+28h] [rbp-A0h]
  __int64 v30; // [rsp+30h] [rbp-98h]
  int v31; // [rsp+38h] [rbp-90h]
  char v32[8]; // [rsp+40h] [rbp-88h] BYREF
  void *Src; // [rsp+48h] [rbp-80h] BYREF
  __int64 v34; // [rsp+50h] [rbp-78h]
  int v35[28]; // [rsp+58h] [rbp-70h] BYREF
  _BYTE v36[28]; // [rsp+5Ch] [rbp-6Ch] BYREF
  char v37; // [rsp+D0h] [rbp+8h] BYREF
  size_t MaxCount; // [rsp+D8h] [rbp+10h] BYREF
  unsigned int v39; // [rsp+E0h] [rbp+18h] BYREF
  size_t v40; // [rsp+E8h] [rbp+20h] BYREF

  v0 = *((_QWORD *)qword_61BE0 + 6);
  v1 = *((_QWORD *)qword_61BE0 + 5);
  v34 = v0;
  v2 = 0;
  v37 = 0;
  v35[0] = 0;
  memset(v36, 0, sizeof(v36));
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x6Au, (__int64)&unk_4DC08);
  }
  v3 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))(v1 + 40))(v0, 0i64, &v37);
  if ( !v3 )
  {
    v13 = qword_61BE0;
    v20 = *((_DWORD *)qword_61BE0 + 4);
    v21 = v20 | *((char *)qword_61BE0 + 20);
    v22 = v20 | 1;
    if ( v22 > v21 )
    {
LABEL_73:
      v9 = (void **)off_5F148;
      goto LABEL_74;
    }
    while ( 1 )
    {
      Src = 0i64;
      LODWORD(MaxCount) = 0;
      if ( (*((unsigned __int8 (__fastcall **)(_QWORD, unsigned int *, size_t *, char *, _DWORD))v13 + 40))(
             v22,
             &v39,
             &v40,
             v32,
             v28) )
      {
        v23 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, void **, size_t *))(v1 + 16))(
                v0,
                0i64,
                v22,
                &Src,
                &MaxCount);
        if ( v23 || !Src )
        {
          v9 = (void **)off_5F148;
          if ( off_5F148 != &off_5F148
            && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
            && *((_BYTE *)off_5F148 + 169) >= 2u )
          {
            LODWORD(v28) = v22;
            sub_127D0(*((_QWORD *)off_5F148 + 19), 0x70u, (__int64)&unk_4DC08, v23);
            v9 = (void **)off_5F148;
          }
          v2 = 8;
          goto LABEL_66;
        }
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
          && *((_BYTE *)off_5F148 + 169) >= 4u )
        {
          sub_1102C(*((_QWORD *)off_5F148 + 19), 0x71u, (__int64)&unk_4DC08, v22);
        }
        KeEnterCriticalRegion();
        LODWORD(v28) = 0;
        sub_26C84((PERESOURCE)((char *)qword_61BE0 + 216));
        v24 = (char *)qword_61BE0;
        v25 = (unsigned int)MaxCount;
        if ( (unsigned int)MaxCount >= (unsigned int)v40 )
          v25 = (unsigned int)v40;
        memmove((char *)qword_61BE0 + v39 + 352, Src, v25);
        sub_26E34((PERESOURCE)(v24 + 216));
        KeLeaveCriticalRegion();
        v0 = v34;
        (*(void (__fastcall **)(__int64, void *))(v1 + 32))(v34, Src);
        v35[(unsigned __int8)(v22 - 1) >> 5] |= 1 << ((v22 - 1) & 0x1F);
      }
      v9 = (void **)off_5F148;
LABEL_66:
      v13 = qword_61BE0;
      if ( ++v22 > (*((_DWORD *)qword_61BE0 + 4) | (unsigned int)*((char *)qword_61BE0 + 20)) )
        goto LABEL_74;
    }
  }
  v4 = 0i64;
  v5 = 0i64;
  v6 = 0;
  if ( v3 == 1879048199 || v3 == 1879048193 )
  {
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
      && *((_BYTE *)off_5F148 + 169) >= 3u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x6Bu, (__int64)&unk_4DC08, 0);
    }
  }
  else if ( off_5F148 != &off_5F148
         && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
         && *((_BYTE *)off_5F148 + 169) >= 3u )
  {
    LODWORD(v28) = 0;
    sub_127D0(*((_QWORD *)off_5F148 + 19), 0x6Cu, (__int64)&unk_4DC08, v3);
  }
  v7 = (void (__fastcall *)(char *))*((_QWORD *)qword_61BE0 + 41);
  if ( v7 )
    v7((char *)qword_61BE0 + 352);
  v8 = (*(__int64 (__fastcall **)(__int64, _QWORD))(v1 + 64))(v0, 0i64);
  if ( v8 )
  {
    v9 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
      && *((_BYTE *)off_5F148 + 169) >= 2u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x6Du, (__int64)&unk_4DC08, v8);
      v9 = (void **)off_5F148;
    }
    v10 = qword_61BE0;
    for ( i = *((_DWORD *)qword_61BE0 + 4) | 1; i <= (v10[4] | (unsigned int)*((char *)v10 + 20)); ++i )
      v35[(unsigned __int8)(i - 1) >> 5] |= 1 << ((i - 1) & 0x1F);
    v12 = (void (__fastcall *)(int *))*((_QWORD *)v10 + 42);
    if ( v12 )
    {
      v12(v35);
      v9 = (void **)off_5F148;
    }
    v2 = 8;
    goto LABEL_76;
  }
  v9 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 4u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x6Eu, (__int64)&unk_4DC08, 0);
    v9 = (void **)off_5F148;
  }
  v13 = qword_61BE0;
  v14 = *((_DWORD *)qword_61BE0 + 4);
  v15 = v14 | *((char *)qword_61BE0 + 20);
  v16 = v14 | 1;
  if ( v16 > v15 )
    goto LABEL_74;
  do
  {
    if ( !(*((unsigned __int8 (__fastcall **)(_QWORD, unsigned int *, size_t *, size_t *, __int64, __int64))v13 + 40))(
            v16,
            &v39,
            &MaxCount,
            &v40,
            v28,
            v29) )
      goto LABEL_44;
    if ( (unsigned int)MaxCount > v6 )
    {
      if ( (unsigned int)MaxCount > 8 )
      {
        if ( v4 )
        {
          v31 = 0;
          v30 = 0i64;
          v29 = 0i64;
          LODWORD(v28) = 1886221390;
          v17 = sub_264FC(1i64, v4, v6, MaxCount);
        }
        else
        {
          LODWORD(v29) = 0;
          v28 = 0i64;
          v17 = sub_26404(1, MaxCount, 0x706D744Eu);
        }
        v4 = v17;
        v5 = (void **)v17;
        v6 = v17 != 0i64 ? MaxCount : 0;
      }
      else
      {
        v5 = &Src;
        v6 = 8;
      }
    }
    v35[(unsigned __int8)(v16 - 1) >> 5] |= 1 << ((v16 - 1) & 0x1F);
    if ( !v5 )
    {
      v2 = 3;
LABEL_44:
      v9 = (void **)off_5F148;
      goto LABEL_45;
    }
    KeEnterCriticalRegion();
    sub_26D5C((PERESOURCE)((char *)qword_61BE0 + 216));
    v18 = (char *)qword_61BE0;
    memmove(v5, (char *)qword_61BE0 + v39 + 352, (unsigned int)MaxCount);
    sub_26E34((PERESOURCE)(v18 + 216));
    KeLeaveCriticalRegion();
    LODWORD(v29) = MaxCount;
    v19 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, void **, __int64, __int64, int))(v1 + 24))(
            v34,
            0i64,
            0i64,
            v16,
            v5,
            v29,
            v30,
            v31);
    if ( !v19 )
      goto LABEL_44;
    v9 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
      && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      LODWORD(v28) = v16;
      sub_127D0(*((_QWORD *)off_5F148 + 19), 0x6Fu, (__int64)&unk_4DC08, v19);
      v9 = (void **)off_5F148;
    }
    v2 = 8;
LABEL_45:
    v13 = qword_61BE0;
    ++v16;
  }
  while ( v16 <= (*((_DWORD *)qword_61BE0 + 4) | (unsigned int)*((char *)qword_61BE0 + 20)) );
  if ( v4 )
  {
    sub_26488(v4, 0x706D744Eu);
    v13 = qword_61BE0;
    goto LABEL_73;
  }
LABEL_74:
  v26 = (void (__fastcall *)(int *))*((_QWORD *)v13 + 42);
  if ( v26 )
  {
    v26(v35);
    v9 = (void **)off_5F148;
  }
LABEL_76:
  if ( v9 != &off_5F148 && _bittest((const signed __int32 *)v9 + 43, 8u) && *((_BYTE *)v9 + 169) >= 5u )
    sub_1102C((__int64)v9[19], 0x72u, (__int64)&unk_4DC08, v2);
  return v2;
}
// 2EFCE: variable 'v28' is possibly undefined
// 2EFCE: variable 'v29' is possibly undefined
// 2F14B: variable 'v30' is possibly undefined
// 2F14B: variable 'v31' is possibly undefined
// 5F148: using guessed type void *off_5F148;
// 2ED48: using guessed type int var_70[28];

//----- (000000000002F414) ----------------------------------------------------
__int64 __fastcall sub_2F414(unsigned int a1, int a2, unsigned int a3, _DWORD *a4)
{
  _QWORD *v4; // rsi
  __int64 v6; // rax
  __int64 v7; // r15
  _QWORD *v9; // r14
  unsigned int v10; // ebx
  void **v13; // rcx
  _QWORD *i; // rax
  char *v16; // rsi
  size_t v17; // r8
  char *v18; // rcx
  _QWORD *v19; // rax
  void (__fastcall *v20)(int *); // rdx
  int v21; // eax
  _QWORD *v22; // rcx
  unsigned __int16 v23; // dx
  __int64 v24; // r9
  _QWORD *v25; // rcx
  unsigned __int16 v26; // dx
  unsigned __int64 v27; // r11
  __int64 v28; // rcx
  int v29; // eax
  int v30; // [rsp+20h] [rbp-78h]
  __int64 v31; // [rsp+20h] [rbp-78h]
  unsigned int v32; // [rsp+28h] [rbp-70h]
  __int64 v33; // [rsp+28h] [rbp-70h]
  _DWORD *v34; // [rsp+30h] [rbp-68h]
  unsigned int v35; // [rsp+40h] [rbp-58h] BYREF
  int v36; // [rsp+44h] [rbp-54h] BYREF
  __int64 v37; // [rsp+48h] [rbp-50h]
  int v38[8]; // [rsp+50h] [rbp-48h] BYREF
  _BYTE v39[28]; // [rsp+54h] [rbp-44h] BYREF
  size_t MaxCount; // [rsp+A0h] [rbp+8h] BYREF

  v4 = qword_61BE0;
  v6 = *((_QWORD *)qword_61BE0 + 6);
  v7 = *((_QWORD *)qword_61BE0 + 5);
  v9 = 0i64;
  v10 = 0;
  v35 = 0;
  LODWORD(MaxCount) = 0;
  v38[0] = 0;
  v37 = v6;
  memset(v39, 0, sizeof(v39));
  v13 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( _bittest((const signed __int32 *)off_5F148 + 43, 8u) && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      v34 = a4;
      v32 = a3;
      v30 = a2;
      sub_2CBA0(*((_QWORD *)off_5F148 + 19), 115i64, (__int64)&unk_4DC08, a1);
      v4 = qword_61BE0;
      v13 = (void **)off_5F148;
    }
    if ( v13 != &off_5F148 && _bittest((const signed __int32 *)v13 + 43, 8u) && *((_BYTE *)v13 + 169) >= 4u )
    {
      sub_11008((__int64)v13[19], 0x74u, (__int64)&unk_4DC08);
      v4 = qword_61BE0;
      v13 = (void **)off_5F148;
    }
  }
  if ( a1 )
  {
    for ( i = (_QWORD *)v4[7]; i != v4 + 7; i = (_QWORD *)*i )
    {
      v9 = i - 5;
      if ( *((_DWORD *)i - 10) == a1 )
        goto LABEL_15;
    }
    v9 = 0i64;
LABEL_15:
    if ( !v9 )
    {
      if ( v13 != &off_5F148 && _bittest((const signed __int32 *)v13 + 43, 8u) && *((_BYTE *)v13 + 169) >= 2u )
        sub_1102C((__int64)v13[19], 0x75u, (__int64)&unk_4DC08, a1);
      return 4i64;
    }
  }
  if ( !((unsigned __int8 (__fastcall *)(_QWORD, unsigned int *, size_t *, int *, int, unsigned int))v4[40])(
          a3,
          &v35,
          &MaxCount,
          &v36,
          v30,
          v32) )
  {
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
      && *((_BYTE *)off_5F148 + 169) >= 2u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x76u, (__int64)&unk_4DC08, a3);
    }
    return 4i64;
  }
  if ( a1 )
  {
    v16 = (char *)v9 + v35 + 56;
    sub_27200((PFAST_MUTEX)((char *)qword_61BE0 + 72));
  }
  else
  {
    v16 = (char *)qword_61BE0 + v35 + 352;
    KeEnterCriticalRegion();
    sub_26C84((PERESOURCE)((char *)qword_61BE0 + 216));
  }
  if ( v36 < 0 )
    goto LABEL_34;
  if ( v36 <= 1 )
    goto LABEL_77;
  if ( v36 == 2 )
  {
    if ( a4 )
    {
      v24 = (unsigned int)*a4;
      if ( 2 * v24 <= (unsigned __int64)(unsigned int)MaxCount )
      {
        memmove(v16, a4 + 1, 2 * v24);
        v27 = 2i64 * (unsigned int)*a4;
        if ( v27 >= (unsigned int)MaxCount )
          goto LABEL_44;
        v17 = (unsigned int)MaxCount - v27;
        v18 = &v16[v27];
        goto LABEL_43;
      }
      v22 = off_5F148;
      if ( off_5F148 == &off_5F148
        || !_bittest((const signed __int32 *)off_5F148 + 43, 8u)
        || *((_BYTE *)off_5F148 + 169) < 2u )
      {
LABEL_64:
        v10 = 6;
        goto LABEL_44;
      }
      v23 = 121;
LABEL_58:
      sub_2C9A0(v22[19], v23, (__int64)&unk_4DC08, v24);
      goto LABEL_64;
    }
    v25 = off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 43, 8u)
      || *((_BYTE *)off_5F148 + 169) < 2u )
    {
      goto LABEL_64;
    }
    v26 = 122;
LABEL_63:
    sub_11008(v25[19], v26, (__int64)&unk_4DC08);
    goto LABEL_64;
  }
  if ( v36 > 4 )
  {
    if ( v36 > 7 )
    {
LABEL_34:
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
        && *((_BYTE *)off_5F148 + 169) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x7Bu, (__int64)&unk_4DC08);
      }
      v10 = 4;
      goto LABEL_44;
    }
LABEL_77:
    memmove(v16, a4, (unsigned int)MaxCount);
    goto LABEL_44;
  }
  if ( !a4 )
  {
    v25 = off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 43, 8u)
      || *((_BYTE *)off_5F148 + 169) < 2u )
    {
      goto LABEL_64;
    }
    v26 = 120;
    goto LABEL_63;
  }
  if ( *a4 > (unsigned int)MaxCount )
  {
    v22 = off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 43, 8u)
      || *((_BYTE *)off_5F148 + 169) < 2u )
    {
      goto LABEL_64;
    }
    v23 = 119;
    LODWORD(v24) = *a4;
    goto LABEL_58;
  }
  memmove(v16, a4 + 1, (unsigned int)*a4);
  if ( *a4 < (unsigned int)MaxCount )
  {
    v17 = (unsigned int)(MaxCount - *a4);
    v18 = &v16[*a4];
LABEL_43:
    memset(v18, 0, v17);
  }
LABEL_44:
  if ( a1 )
  {
    if ( !v10 )
    {
      v28 = v37;
      *((_DWORD *)v9 + (((a3 - 1) >> 5) & 7) + 1) |= 1 << ((a3 - 1) & 0x1F);
      v29 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, char *, _DWORD))(v7 + 24))(
              v28,
              a1,
              0i64,
              a3,
              v16,
              MaxCount);
      if ( v29 )
      {
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
          && *((_BYTE *)off_5F148 + 169) >= 2u )
        {
          LODWORD(v33) = a3;
          LODWORD(v31) = a1;
          sub_2C9F4(*((_QWORD *)off_5F148 + 19), 125i64, (__int64)&unk_4DC08, v29, v31, v33, 0);
        }
        v10 = 8;
      }
    }
    sub_272CC((PFAST_MUTEX)((char *)qword_61BE0 + 72));
  }
  else
  {
    sub_26E34((PERESOURCE)((char *)qword_61BE0 + 216));
    KeLeaveCriticalRegion();
    if ( !v10 )
    {
      v19 = qword_61BE0;
      v38[((a3 - 1) >> 5) & 7] |= 1 << ((a3 - 1) & 0x1F);
      v20 = (void (__fastcall *)(int *))v19[42];
      if ( v20 )
        v20(v38);
      v21 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, char *, _DWORD, _DWORD *))(v7 + 24))(
              v37,
              0i64,
              0i64,
              a3,
              v16,
              MaxCount,
              v34);
      if ( v21 )
      {
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
          && *((_BYTE *)off_5F148 + 169) >= 2u )
        {
          sub_2C9A0(*((_QWORD *)off_5F148 + 19), 0x7Cu, (__int64)&unk_4DC08, v21);
        }
        v10 = 8;
      }
    }
  }
  return v10;
}
// 2F664: conditional instruction was optimized away because of 'eax.4>=3'
// 2F596: variable 'v30' is possibly undefined
// 2F596: variable 'v32' is possibly undefined
// 2F785: variable 'v34' is possibly undefined
// 2F9C3: variable 'v31' is possibly undefined
// 2F9C3: variable 'v33' is possibly undefined
// 5F148: using guessed type void *off_5F148;
// 2F414: using guessed type int var_48[8];

//----- (000000000002FA0C) ----------------------------------------------------
__int64 __fastcall sub_2FA0C(__int64 a1, unsigned int a2, __int64 a3)
{
  unsigned int v5; // ebx
  void **v6; // rcx
  void **v7; // rcx
  int v8; // edx
  char *v9; // rbp
  unsigned int v10; // er8
  __int64 *v11; // r9
  unsigned int v12; // er12
  _DWORD *v13; // rsi
  unsigned __int16 v14; // dx
  int v15; // eax
  __int64 Dst; // [rsp+30h] [rbp-38h] BYREF
  unsigned int v18; // [rsp+38h] [rbp-30h] BYREF
  int v19; // [rsp+3Ch] [rbp-2Ch] BYREF
  size_t MaxCount; // [rsp+88h] [rbp+20h] BYREF

  v5 = 0;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( _bittest((const signed __int32 *)off_5F148 + 43, 8u) && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x7Eu, (__int64)&unk_4DC08);
      v6 = (void **)off_5F148;
    }
    if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 43, 8u) && *((_BYTE *)v6 + 169) >= 4u )
      sub_1102C((__int64)v6[19], 0x7Fu, (__int64)&unk_4DC08, a2);
  }
  if ( !(*((unsigned __int8 (__fastcall **)(_QWORD, unsigned int *, size_t *, int *))qword_61BE0 + 40))(
          a2,
          &v18,
          &MaxCount,
          &v19) )
  {
    v7 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 )
    {
      if ( _bittest((const signed __int32 *)off_5F148 + 43, 8u) && *((_BYTE *)off_5F148 + 169) >= 2u )
      {
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x80u, (__int64)&unk_4DC08, a2);
LABEL_46:
        v7 = (void **)off_5F148;
      }
LABEL_47:
      if ( v7 != &off_5F148 && _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 2u )
        sub_11008((__int64)v7[19], 0x85u, (__int64)&unk_4DC08);
    }
LABEL_51:
    v8 = 17;
LABEL_52:
    v11 = 0i64;
    v5 = v8;
    v10 = 0;
    goto LABEL_53;
  }
  if ( !(_DWORD)MaxCount )
  {
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
      && *((_BYTE *)off_5F148 + 169) >= 2u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x81u, (__int64)&unk_4DC08, a2);
    }
    v8 = 12;
    goto LABEL_52;
  }
  v9 = (char *)qword_61BE0 + v18 + 352;
  if ( v19 < 0 )
  {
LABEL_41:
    v7 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148 )
      goto LABEL_51;
    if ( !_bittest((const signed __int32 *)off_5F148 + 43, 8u) || *((_BYTE *)off_5F148 + 169) < 2u )
      goto LABEL_47;
    v14 = 132;
    goto LABEL_45;
  }
  if ( v19 <= 1 )
  {
LABEL_40:
    LODWORD(Dst) = 0;
    memmove(&Dst, (char *)qword_61BE0 + v18 + 352, (unsigned int)MaxCount);
    v8 = 0;
    v10 = 4;
    v11 = &Dst;
    goto LABEL_53;
  }
  if ( v19 == 2 )
  {
    v12 = MaxCount + 4;
    v13 = sub_26404(1, (int)MaxCount + 4, 0x66634E4Eu);
    if ( !v13 )
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        goto LABEL_51;
      if ( !_bittest((const signed __int32 *)off_5F148 + 43, 8u) || *((_BYTE *)off_5F148 + 169) < 2u )
        goto LABEL_47;
      v14 = 131;
      goto LABEL_45;
    }
    v15 = (unsigned int)MaxCount >> 1;
  }
  else
  {
    if ( v19 > 4 )
    {
      if ( v19 > 6 )
      {
        if ( v19 == 7 )
        {
          Dst = 0i64;
          memmove(&Dst, (char *)qword_61BE0 + v18 + 352, (unsigned int)MaxCount);
          v8 = 0;
          v10 = 8;
          v11 = &Dst;
LABEL_53:
          sub_329E8(a3, v8, v10, v11);
          goto LABEL_54;
        }
        goto LABEL_41;
      }
      goto LABEL_40;
    }
    v12 = MaxCount + 4;
    v13 = sub_26404(1, (int)MaxCount + 4, 0x66634E4Eu);
    if ( !v13 )
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        goto LABEL_51;
      if ( !_bittest((const signed __int32 *)off_5F148 + 43, 8u) || *((_BYTE *)off_5F148 + 169) < 2u )
        goto LABEL_47;
      v14 = 130;
LABEL_45:
      sub_11008((__int64)v7[19], v14, (__int64)&unk_4DC08);
      goto LABEL_46;
    }
    v15 = MaxCount;
  }
  *v13 = v15;
  memmove(v13 + 1, v9, (unsigned int)MaxCount);
  sub_329E8(a3, 0, v12, v13);
  sub_26488(v13, 0x66634E4Eu);
LABEL_54:
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x86u, (__int64)&unk_4DC08, v5);
  }
  return v5;
}
// 2FB90: conditional instruction was optimized away because of 'eax.4>=3'
// 5F148: using guessed type void *off_5F148;

//----- (000000000002FDD0) ----------------------------------------------------
__int64 __fastcall sub_2FDD0(int a1)
{
  unsigned int v1; // edi
  char *v4; // r10
  char *i; // rax
  char *v6; // rax
  _DWORD *v7; // rax
  _QWORD *v8; // rsi
  char *v9; // rbx
  _QWORD *v10; // rdx
  __int64 v11; // rcx

  v1 = 0;
  if ( !a1 )
    return 6i64;
  sub_27200((PFAST_MUTEX)((char *)qword_61BE0 + 72));
  v4 = (char *)qword_61BE0;
  for ( i = (char *)*((_QWORD *)qword_61BE0 + 7); i != (char *)qword_61BE0 + 56; i = (char *)*((_QWORD *)v6 + 5) )
  {
    v6 = i - 40;
    if ( *(_DWORD *)v6 == a1 )
      goto LABEL_8;
  }
  v6 = 0i64;
LABEL_8:
  if ( v6 )
  {
    v1 = 6;
  }
  else
  {
    v7 = sub_26404(1, *((_DWORD *)qword_61BE0 + 1) + 56, 0x66634E4Eu);
    v8 = v7;
    if ( v7 )
    {
      *v7 = a1;
      memset(v7 + 1, 0, 0x20ui64);
      KeEnterCriticalRegion();
      sub_26D5C((PERESOURCE)((char *)qword_61BE0 + 216));
      v9 = (char *)qword_61BE0;
      memmove(v8 + 7, (char *)qword_61BE0 + 352, *((unsigned int *)qword_61BE0 + 1));
      sub_26E34((PERESOURCE)(v9 + 216));
      KeLeaveCriticalRegion();
      v4 = (char *)qword_61BE0;
      v10 = (char *)qword_61BE0 + 56;
      v11 = *((_QWORD *)qword_61BE0 + 7);
      v8[6] = (char *)qword_61BE0 + 56;
      v8[5] = v11;
      *(_QWORD *)(v11 + 8) = v8 + 5;
      *v10 = v8 + 5;
    }
    else
    {
      v4 = (char *)qword_61BE0;
      v1 = 3;
    }
  }
  sub_272CC((PFAST_MUTEX)(v4 + 72));
  return v1;
}

//----- (000000000002FF2C) ----------------------------------------------------
__int64 __fastcall sub_2FF2C(int a1)
{
  __int64 result; // rax
  char *v3; // r11
  _QWORD *i; // rax
  char *v5; // rdi
  __int64 v6; // rcx
  _QWORD *v7; // rax
  char *v8; // rbx
  void (__fastcall *v9)(char *); // rax

  if ( !a1 )
    return 6i64;
  sub_27200((PFAST_MUTEX)((char *)qword_61BE0 + 72));
  v3 = (char *)qword_61BE0;
  for ( i = (_QWORD *)*((_QWORD *)qword_61BE0 + 7); i != (_QWORD *)((char *)qword_61BE0 + 56); i = (_QWORD *)*i )
  {
    v5 = (char *)(i - 5);
    if ( *((_DWORD *)i - 10) == a1 )
      goto LABEL_8;
  }
  v5 = 0i64;
LABEL_8:
  if ( v5 )
  {
    v6 = *((_QWORD *)v5 + 5);
    v7 = (_QWORD *)*((_QWORD *)v5 + 6);
    *v7 = v6;
    *(_QWORD *)(v6 + 8) = v7;
    sub_272CC((PFAST_MUTEX)(v3 + 72));
    KeEnterCriticalRegion();
    sub_26C84((PERESOURCE)((char *)qword_61BE0 + 216));
    v8 = (char *)qword_61BE0;
    memmove((char *)qword_61BE0 + 352, v5 + 56, *((unsigned int *)qword_61BE0 + 1));
    sub_26E34((PERESOURCE)(v8 + 216));
    KeLeaveCriticalRegion();
    v9 = (void (__fastcall *)(char *))*((_QWORD *)qword_61BE0 + 42);
    if ( v9 )
      v9(v5 + 4);
    sub_26488(v5, 0x66634E4Eu);
    result = 0i64;
  }
  else
  {
    sub_272CC((PFAST_MUTEX)((char *)qword_61BE0 + 72));
    result = 5i64;
  }
  return result;
}

//----- (0000000000030054) ----------------------------------------------------
__int64 sub_30054(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, &unk_4DBF8, 288i64, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000300A8) ----------------------------------------------------
__int64 __fastcall sub_300A8(__int16 *a1, int a2, unsigned int *a3)
{
  void **v6; // rbx
  __int64 v7; // rcx
  unsigned __int16 v8; // dx

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xAu, (__int64)&unk_4DBF8);
    v6 = (void **)off_5F148;
  }
  if ( !byte_62062 )
  {
    memset(&qword_61C00, 0, 0x470ui64);
    if ( a3 )
    {
      if ( !(unsigned int)sub_327A0(a3) )
      {
        dword_62058 = 0;
        dword_6205C = 0;
        byte_62063 = 0;
        byte_62060 = 0;
        byte_62061 = 0;
        sub_4B54C(word_61C20, 520i64, a1);
        dword_62030 = a2;
        byte_62062 = 1;
        sub_3027C(1);
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
          sub_1102C(*((_QWORD *)off_5F148 + 19), 0xEu, (__int64)&unk_4DBF8, 0);
        return 0i64;
      }
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 1) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        return 264i64;
      v7 = *((_QWORD *)off_5F148 + 19);
      v8 = 13;
    }
    else
    {
      if ( v6 == &off_5F148 || (*((_BYTE *)v6 + 172) & 1) == 0 || *((_BYTE *)v6 + 169) < 2u )
        return 264i64;
      v7 = (__int64)v6[19];
      v8 = 12;
    }
    sub_11008(v7, v8, (__int64)&unk_4DBF8);
    return 264i64;
  }
  if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 1) != 0 && *((_BYTE *)v6 + 169) >= 2u )
    sub_11008((__int64)v6[19], 0xBu, (__int64)&unk_4DBF8);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;
// 62030: using guessed type int dword_62030;
// 62058: using guessed type int dword_62058;
// 6205C: using guessed type int dword_6205C;
// 62060: using guessed type char byte_62060;
// 62061: using guessed type char byte_62061;
// 62062: using guessed type char byte_62062;
// 62063: using guessed type char byte_62063;

//----- (000000000003027C) ----------------------------------------------------
__int64 __fastcall sub_3027C(char a1)
{
  void **v2; // rcx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xFu, (__int64)&unk_4DBF8);
    v2 = (void **)off_5F148;
  }
  byte_62064 = a1;
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 1) != 0 && *((_BYTE *)v2 + 169) >= 5u )
    sub_1102C((__int64)v2[19], 0x10u, (__int64)&unk_4DBF8, 0);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;
// 62064: using guessed type char byte_62064;

//----- (0000000000030318) ----------------------------------------------------
__int64 __fastcall sub_30318(int a1, int a2)
{
  void **v4; // rcx
  __int64 result; // rax
  _QWORD *v6; // rax
  _QWORD *v7; // rcx
  void **v8; // rcx

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x11u, (__int64)&unk_4DBF8);
    v4 = (void **)off_5F148;
  }
  if ( byte_62062 )
  {
    if ( !dword_62058 )
    {
      qword_61C08 = (__int64)&qword_61C00;
      qword_61C00 = &qword_61C00;
    }
    v6 = sub_26404(2, 0x28u, 0x74785072u);
    if ( v6 )
    {
      v6[4] = 0i64;
      *((_DWORD *)v6 + 4) = a1;
      *((_DWORD *)v6 + 6) = a2;
      *((_DWORD *)v6 + 7) = 2;
      v7 = (_QWORD *)qword_61C08;
      *v6 = &qword_61C00;
      v6[1] = v7;
      *v7 = v6;
      ++dword_62058;
      qword_61C08 = (__int64)v6;
      v8 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 )
      {
        if ( (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
        {
          sub_1102C(*((_QWORD *)off_5F148 + 19), 0x14u, (__int64)&unk_4DBF8, a1);
          v8 = (void **)off_5F148;
        }
        if ( v8 != &off_5F148 && (*((_BYTE *)v8 + 172) & 1) != 0 && *((_BYTE *)v8 + 169) >= 5u )
          sub_1102C((__int64)v8[19], 0x15u, (__int64)&unk_4DBF8, 0);
      }
      result = 0i64;
    }
    else
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x13u, (__int64)&unk_4DBF8);
      result = 3i64;
    }
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x12u, (__int64)&unk_4DBF8);
    result = 258i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;
// 61C08: using guessed type __int64 qword_61C08;
// 62058: using guessed type int dword_62058;
// 62062: using guessed type char byte_62062;

//----- (00000000000304F8) ----------------------------------------------------
__int64 __fastcall sub_304F8(int a1, __int64 a2)
{
  void **v4; // rcx
  __int64 result; // rax
  _QWORD *v6; // rax
  _QWORD *v7; // rcx
  void **v8; // rcx

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x16u, (__int64)&unk_4DBF8);
    v4 = (void **)off_5F148;
  }
  if ( byte_62062 )
  {
    if ( !dword_6205C )
    {
      qword_61C18 = (__int64)&qword_61C10;
      qword_61C10 = &qword_61C10;
    }
    v6 = sub_26404(2, 0x48u, 0x746D436Eu);
    if ( v6 )
    {
      v6[6] = 0i64;
      *((_DWORD *)v6 + 4) = a1;
      v6[4] = a2;
      *((_DWORD *)v6 + 6) = 1;
      *((_DWORD *)v6 + 7) = 6;
      v6[8] = &qword_61C00;
      v7 = (_QWORD *)qword_61C18;
      *v6 = &qword_61C10;
      v6[1] = v7;
      *v7 = v6;
      ++dword_6205C;
      qword_61C18 = (__int64)v6;
      v8 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 )
      {
        if ( (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
        {
          sub_1102C(*((_QWORD *)off_5F148 + 19), 0x19u, (__int64)&unk_4DBF8, a1);
          v8 = (void **)off_5F148;
        }
        if ( v8 != &off_5F148 && (*((_BYTE *)v8 + 172) & 1) != 0 && *((_BYTE *)v8 + 169) >= 5u )
          sub_1102C((__int64)v8[19], 0x1Au, (__int64)&unk_4DBF8, 0);
      }
      result = 0i64;
    }
    else
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x18u, (__int64)&unk_4DBF8);
      result = 3i64;
    }
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x17u, (__int64)&unk_4DBF8);
    result = 258i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;
// 61C18: using guessed type __int64 qword_61C18;
// 6205C: using guessed type int dword_6205C;
// 62062: using guessed type char byte_62062;

//----- (00000000000306EC) ----------------------------------------------------
__int64 sub_306EC()
{
  void **v0; // rcx
  _QWORD *v2; // rcx
  unsigned __int16 v3; // dx

  v0 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1Bu, (__int64)&unk_4DBF8);
    v0 = (void **)off_5F148;
  }
  if ( !byte_62062 )
  {
    if ( v0 != &off_5F148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
      sub_11008((__int64)v0[19], 0x1Cu, (__int64)&unk_4DBF8);
    return 258i64;
  }
  if ( !dword_62058 && !dword_6205C && v0 != &off_5F148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
    sub_11008((__int64)v0[19], 0x1Du, (__int64)&unk_4DBF8);
  if ( (unsigned int)sub_30EC0() )
  {
    v2 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 1) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
      return 257i64;
    v3 = 30;
LABEL_22:
    sub_11008(v2[19], v3, (__int64)&unk_4DBF8);
    return 257i64;
  }
  if ( (unsigned int)sub_3150C() )
  {
    v2 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 1) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
      return 257i64;
    v3 = 31;
    goto LABEL_22;
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x20u, (__int64)&unk_4DBF8);
  sub_33C84();
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x21u, (__int64)&unk_4DBF8, 0);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;
// 62058: using guessed type int dword_62058;
// 6205C: using guessed type int dword_6205C;
// 62062: using guessed type char byte_62062;

//----- (00000000000308AC) ----------------------------------------------------
__int64 __fastcall sub_308AC(int a1, const void *a2, unsigned int a3, int a4, int *a5)
{
  unsigned int v9; // ebx
  void **v10; // rcx
  void **v12; // rcx

  v9 = 0;
  v10 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 0xAu)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x22u, (__int64)&unk_4DBF8);
    v10 = (void **)off_5F148;
  }
  if ( !byte_62063 )
  {
    if ( v10 != &off_5F148 && _bittest((const signed __int32 *)v10 + 43, 0xAu) && *((_BYTE *)v10 + 169) >= 2u )
      sub_11008((__int64)v10[19], 0x23u, (__int64)&unk_4DBF8);
    return 260i64;
  }
  if ( (unsigned int)(a1 - 40000) > 0x4D )
  {
    if ( v10 != &off_5F148 && _bittest((const signed __int32 *)v10 + 43, 0xAu) && *((_BYTE *)v10 + 169) >= 2u )
      sub_11008((__int64)v10[19], 0x24u, (__int64)&unk_4DBF8);
    return 261i64;
  }
  if ( !a2 )
  {
    if ( v10 != &off_5F148 && _bittest((const signed __int32 *)v10 + 43, 0xAu) && *((_BYTE *)v10 + 169) >= 2u )
      sub_11008((__int64)v10[19], 0x25u, (__int64)&unk_4DBF8);
    return 4i64;
  }
  if ( *((_QWORD *)qword_62048 + 8 * (unsigned __int64)(unsigned int)(a1 - 40000) + 4) )
  {
    if ( (unsigned int)sub_322F4(a1, a2, a3, a5) )
    {
      v12 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 43, 0xAu)
        && *((_BYTE *)off_5F148 + 169) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x27u, (__int64)&unk_4DBF8);
        v12 = (void **)off_5F148;
      }
      v9 = 262;
      goto LABEL_37;
    }
  }
  else if ( (unsigned int)sub_31FD0(a1, a2, a3, a4, a5) )
  {
    v12 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 43, 0xAu)
      && *((_BYTE *)off_5F148 + 169) >= 2u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x26u, (__int64)&unk_4DBF8);
      v12 = (void **)off_5F148;
    }
    v9 = 263;
    goto LABEL_37;
  }
  v12 = (void **)off_5F148;
LABEL_37:
  if ( v12 != &off_5F148 && _bittest((const signed __int32 *)v12 + 43, 0xAu) && *((_BYTE *)v12 + 169) >= 5u )
    sub_1102C((__int64)v12[19], 0x28u, (__int64)&unk_4DBF8, v9);
  return v9;
}
// 5F148: using guessed type void *off_5F148;
// 62063: using guessed type char byte_62063;

//----- (0000000000030B00) ----------------------------------------------------
__int64 __fastcall sub_30B00(unsigned int a1, __int64 a2)
{
  void **v4; // rcx
  __int64 result; // rax
  int v6; // eax

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x35u, (__int64)&unk_4DBF8);
    v4 = (void **)off_5F148;
  }
  if ( byte_62063 )
  {
    if ( qword_62038 && a2 )
    {
      v6 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(*((_QWORD *)qword_62038 + 1) + 8i64))(
             **((_QWORD **)qword_62038 + 1),
             a1,
             a2);
      v4 = (void **)off_5F148;
    }
    else
    {
      v6 = 1796;
    }
    if ( v6 )
    {
      if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 2u )
        sub_1102C((__int64)v4[19], 0x37u, (__int64)&unk_4DBF8, v6);
      result = 257i64;
    }
    else
    {
      if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 5u )
        sub_1102C((__int64)v4[19], 0x38u, (__int64)&unk_4DBF8, 0);
      result = 0i64;
    }
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x36u, (__int64)&unk_4DBF8);
    result = 260i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;
// 62063: using guessed type char byte_62063;

//----- (0000000000030C50) ----------------------------------------------------
__int64 sub_30C50()
{
  void **v0; // rcx
  int v2; // eax
  unsigned int v3; // edi
  void **v4; // rbx
  PVOID *v5; // rcx
  PVOID *v6; // rcx

  v0 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x39u, (__int64)&unk_4DBF8);
    v0 = (void **)off_5F148;
  }
  if ( byte_62062 )
  {
    v2 = sub_31C70();
    v3 = v2;
    if ( v2 )
    {
      v4 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      {
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x3Bu, (__int64)&unk_4DBF8, v2);
        v4 = (void **)off_5F148;
      }
      if ( v3 != 260 )
        return v3;
    }
    else
    {
      v4 = (void **)off_5F148;
    }
    if ( dword_62058 )
    {
      v5 = (PVOID *)qword_61C00;
      if ( qword_61C00 != &qword_61C00 )
      {
        do
        {
          qword_61C00 = *v5;
          *((_QWORD *)qword_61C00 + 1) = &qword_61C00;
          sub_26488(v5, 0x74785072u);
          v5 = (PVOID *)qword_61C00;
        }
        while ( qword_61C00 != &qword_61C00 );
        v4 = (void **)off_5F148;
      }
    }
    if ( dword_6205C )
    {
      v6 = (PVOID *)qword_61C10;
      if ( qword_61C10 != &qword_61C10 )
      {
        do
        {
          qword_61C10 = *v6;
          *((_QWORD *)qword_61C10 + 1) = &qword_61C10;
          sub_26488(v6, 0x746D436Eu);
          v6 = (PVOID *)qword_61C10;
        }
        while ( qword_61C10 != &qword_61C10 );
        v4 = (void **)off_5F148;
      }
    }
    if ( qword_62048 && byte_62060 == 1 )
    {
      sub_26488(qword_62048, 0x74785072u);
      qword_62048 = 0i64;
      v4 = (void **)off_5F148;
    }
    if ( qword_62050 && byte_62061 == 1 )
    {
      sub_26488(qword_62050, 0x746D436Eu);
      v4 = (void **)off_5F148;
    }
    memset(&qword_61C00, 0, 0x470ui64);
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 5u )
      sub_1102C((__int64)v4[19], 0x3Cu, (__int64)&unk_4DBF8, v3);
    return v3;
  }
  if ( v0 != &off_5F148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
    sub_11008((__int64)v0[19], 0x3Au, (__int64)&unk_4DBF8);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;
// 62058: using guessed type int dword_62058;
// 6205C: using guessed type int dword_6205C;
// 62060: using guessed type char byte_62060;
// 62061: using guessed type char byte_62061;
// 62062: using guessed type char byte_62062;

//----- (0000000000030EC0) ----------------------------------------------------
__int64 sub_30EC0()
{
  void **v0; // rcx
  PVOID v1; // rax
  PVOID v3; // rax

  v0 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x3Du, (__int64)&unk_4DBF8);
    v0 = (void **)off_5F148;
  }
  if ( dword_62058 )
  {
    v1 = sub_26404(2, 0x1340u, 0x74785072u);
    qword_62048 = v1;
    if ( !v1 )
      return 3i64;
    memset(v1, 0, 0x1340ui64);
    if ( (unsigned int)sub_31148(0) )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x3Eu, (__int64)&unk_4DBF8);
      sub_26488(qword_62048, 0x74785072u);
      qword_62048 = 0i64;
      return 1i64;
    }
    v0 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x3Fu, (__int64)&unk_4DBF8);
      v0 = (void **)off_5F148;
    }
    byte_62060 = 1;
  }
  if ( dword_6205C )
  {
    v3 = sub_26404(2, 0x9A0u, 0x746D436Eu);
    qword_62050 = v3;
    if ( v3 )
    {
      memset(v3, 0, 0x9A0ui64);
      if ( (unsigned int)sub_31148(1) )
      {
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
          sub_11008(*((_QWORD *)off_5F148 + 19), 0x40u, (__int64)&unk_4DBF8);
        sub_26488(qword_62050, 0x746D436Eu);
        qword_62050 = 0i64;
        return 1i64;
      }
      v0 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x41u, (__int64)&unk_4DBF8);
        v0 = (void **)off_5F148;
      }
      byte_62061 = 1;
      goto LABEL_33;
    }
    return 3i64;
  }
LABEL_33:
  if ( v0 != &off_5F148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 5u )
    sub_1102C((__int64)v0[19], 0x42u, (__int64)&unk_4DBF8, 0);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;
// 62058: using guessed type int dword_62058;
// 6205C: using guessed type int dword_6205C;
// 62060: using guessed type char byte_62060;
// 62061: using guessed type char byte_62061;

//----- (0000000000031148) ----------------------------------------------------
__int64 __fastcall sub_31148(int a1)
{
  unsigned int v2; // edi
  void **v3; // rcx
  PVOID *j; // rbx
  int v5; // edx
  unsigned int v6; // er9
  unsigned __int64 v7; // r8
  PVOID *i; // rbx
  unsigned int v9; // er9
  __int64 v10; // r8
  __int64 (__fastcall *v11)(__int64, __int64, __int64); // rcx
  int v12; // eax

  v2 = 0;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x43u, (__int64)&unk_4DBF8);
    v3 = (void **)off_5F148;
  }
  if ( a1 )
  {
    for ( i = (PVOID *)qword_61C10; i != &qword_61C10; i = (PVOID *)*i )
    {
      v9 = *((_DWORD *)i + 4) - 40000;
      if ( v9 >= 0x4D )
      {
        if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 172) & 1) != 0 && *((_BYTE *)v3 + 169) >= 2u )
        {
          sub_1102C((__int64)v3[19], 0x45u, (__int64)&unk_4DBF8, v9);
          v3 = (void **)off_5F148;
        }
        v2 = 1;
      }
      else
      {
        v10 = 32i64 * v9;
        *(_DWORD *)((char *)qword_62050 + v10) = *((_DWORD *)i + 4);
        *(_DWORD *)((char *)qword_62050 + v10 + 4) = -1;
        *(_DWORD *)((char *)qword_62050 + v10 + 8) = *((_DWORD *)i + 6);
        *(_DWORD *)((char *)qword_62050 + v10 + 12) = *((_DWORD *)i + 7);
        *(_QWORD *)((char *)qword_62050 + v10 + 24) = i + 3;
        if ( *((_DWORD *)i + 4) == 40005 )
        {
          v11 = sub_33170;
        }
        else
        {
          v12 = *((_DWORD *)i + 4);
          if ( v12 == 40015
            || v12 == 40016
            || v12 == 40017
            || v12 == 40018
            || v12 == 40019
            || v12 == 40020
            || v12 == 40021
            || v12 == 40023
            || v12 == 40022
            || v12 == 40039
            || v12 == 40044
            || v12 == 40024
            || v12 == 40036
            || v12 == 40012
            || v12 == 40037
            || v12 == 40014
            || v12 == 40041
            || v12 == 40042
            || v12 == 40013
            || v12 == 40038
            || v12 == 40025 )
          {
            v11 = sub_33AE0;
          }
          else if ( v12 == 40011
                 || v12 == 40053
                 || v12 == 40050
                 || v12 == 40051
                 || v12 == 40052
                 || v12 == 40045
                 || v12 == 40003 )
          {
            v11 = sub_32E58;
          }
          else
          {
            v11 = sub_32BE4;
          }
        }
        *(_QWORD *)((char *)qword_62050 + v10 + 16) = v11;
        v3 = (void **)off_5F148;
      }
    }
  }
  else
  {
    for ( j = (PVOID *)qword_61C00; j != &qword_61C00; j = (PVOID *)*j )
    {
      v5 = *((_DWORD *)j + 4);
      v6 = v5 - 40000;
      if ( (unsigned int)(v5 - 40000) >= 0x4D )
      {
        if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 172) & 1) != 0 && *((_BYTE *)v3 + 169) >= 2u )
        {
          sub_1102C((__int64)v3[19], 0x44u, (__int64)&unk_4DBF8, v6);
          v3 = (void **)off_5F148;
        }
        v2 = 1;
      }
      else
      {
        v7 = (unsigned __int64)v6 << 6;
        *(_DWORD *)((char *)qword_62048 + v7) = v5;
        *(_DWORD *)((char *)qword_62048 + v7 + 4) = *((_DWORD *)j + 6);
        *(_DWORD *)((char *)qword_62048 + v7 + 8) = -1;
        *(_QWORD *)((char *)qword_62048 + v7 + 16) = 0i64;
        *(_DWORD *)((char *)qword_62048 + v7 + 24) = *((_DWORD *)j + 7);
        *(_QWORD *)((char *)qword_62048 + v7 + 32) = (unsigned __int64)sub_32548 & -(__int64)(j[4] != 0i64);
        *(_QWORD *)((char *)qword_62048 + v7 + 40) = j + 3;
        *(_DWORD *)((char *)qword_62048 + v7 + 48) = 0;
        *(_QWORD *)((char *)qword_62048 + v7 + 56) = 0i64;
        v3 = (void **)off_5F148;
      }
    }
  }
  if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 172) & 1) != 0 && *((_BYTE *)v3 + 169) >= 5u )
    sub_1102C((__int64)v3[19], 0x46u, (__int64)&unk_4DBF8, v2);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003150C) ----------------------------------------------------
__int64 sub_3150C()
{
  void **v0; // rcx
  _QWORD *v1; // rax
  _QWORD *v2; // rbx
  int v3; // edi
  void **v4; // rcx
  unsigned __int16 v5; // dx
  int v6; // er9
  unsigned int v7; // esi
  __int64 v8; // rdi
  _QWORD *v9; // rbp
  int v10; // er12
  int v11; // eax
  __int64 v12; // rax
  int v13; // eax
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // rcx
  void **v18; // r10
  unsigned int v19; // ebx
  __int64 v20; // rdi
  int v21; // er9
  __int64 v22; // rax
  unsigned int v23; // ebx
  __int64 v24; // rdi
  __int64 v25; // rax
  __int64 v26; // rax
  unsigned __int16 v27; // dx
  __int64 (__fastcall **v28)(_QWORD *, _QWORD, _WORD *); // [rsp+60h] [rbp+8h] BYREF

  v0 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_23FA8(*((_QWORD *)off_5F148 + 19), 0x47u, (__int64)&unk_4DBF8, word_61C20);
    v0 = (void **)off_5F148;
  }
  if ( byte_62060 || byte_62061 )
    goto LABEL_11;
  if ( v0 != &off_5F148 )
  {
    if ( (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
    {
      sub_11008((__int64)v0[19], 0x48u, (__int64)&unk_4DBF8);
      v0 = (void **)off_5F148;
    }
LABEL_11:
    if ( v0 != &off_5F148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 4u )
      sub_17984((__int64)v0[19], 0x49u, (__int64)&unk_4DBF8, &qword_62038);
  }
  qword_62038 = 0i64;
  v1 = sub_26404(2, 0x38u, 0x41434E50u);
  v2 = v1;
  if ( !v1 )
  {
    v3 = 1793;
LABEL_25:
    v4 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 1) == 0 || !*((_BYTE *)off_5F148 + 169) )
      return 260i64;
    v5 = 74;
    v6 = v3;
LABEL_53:
    v16 = (__int64)v4[19];
    goto LABEL_54;
  }
  memset(v1, 0, 0x38ui64);
  v3 = sub_4B084(v2 + 6, v2 + 1);
  if ( v3
    || (v3 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD *))(v2[1] + 8i64))(
               *(_QWORD *)v2[1],
               4026531842i64,
               v2 + 2)) != 0
    || (v3 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD *))(v2[1] + 8i64))(
               *(_QWORD *)v2[1],
               4026531845i64,
               v2 + 5)) != 0
    || (v3 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD *))(v2[1] + 8i64))(
               *(_QWORD *)v2[1],
               4026531843i64,
               v2 + 4)) != 0
    || (v3 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD *))(v2[1] + 8i64))(
               *(_QWORD *)v2[1],
               4026531844i64,
               v2 + 3)) != 0 )
  {
    sub_4B208(v2);
    v2 = qword_62038;
  }
  else
  {
    *(_BYTE *)v2 = 1;
    qword_62038 = v2;
  }
  if ( v3 )
    goto LABEL_25;
  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
  {
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x4Bu, (__int64)&unk_4DBF8, &qword_62038, 0i64, 0);
    v4 = (void **)off_5F148;
    v2 = qword_62038;
  }
  v7 = dword_62030;
  v8 = 0i64;
  v9 = v2;
  v10 = 1796;
  if ( v2 )
  {
    v11 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD))(v2[1] + 8i64))(*(_QWORD *)v2[1], 1i64, &v28);
    v4 = (void **)off_5F148;
    v2 = qword_62038;
    if ( !v11 )
    {
      v12 = (*v28)(v9, v7, word_61C20);
      v4 = (void **)off_5F148;
      v2 = qword_62038;
      v8 = v12;
    }
  }
  qword_62040 = v8;
  if ( !v8 )
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) )
      sub_11008((__int64)v4[19], 0x4Cu, (__int64)&unk_4DBF8);
    return 260i64;
  }
  if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 4u )
  {
    sub_143EC((__int64)v4[19], 0x4Du, (__int64)&unk_4DBF8, v2, v8, &qword_61BE8);
    v4 = (void **)off_5F148;
    v8 = qword_62040;
    v2 = qword_62038;
  }
  v13 = 1796;
  if ( !v8 || (v14 = *(_QWORD *)(v8 + 1112)) == 0 )
  {
LABEL_49:
    if ( v4 == &off_5F148 || (*((_BYTE *)v4 + 172) & 1) == 0 || !*((_BYTE *)v4 + 169) )
      return 260i64;
    v5 = 78;
    v6 = v13;
    goto LABEL_53;
  }
  v13 = (*(__int64 (__fastcall **)(_QWORD *, __int64, __int64 *))(v14 + 112))(v2, v8, &qword_61BE8);
  if ( v13 )
  {
    v4 = (void **)off_5F148;
    goto LABEL_49;
  }
  v18 = (void **)off_5F148;
  if ( !dword_62058 )
  {
LABEL_71:
    if ( dword_6205C )
    {
      v23 = 0;
      v24 = 0i64;
      do
      {
        if ( v18 != &off_5F148 && (*((_BYTE *)v18 + 172) & 1) != 0 && *((_BYTE *)v18 + 169) >= 4u )
        {
          sub_143EC(
            (__int64)v18[19],
            0x52u,
            (__int64)&unk_4DBF8,
            qword_62038,
            qword_62040,
            (char *)qword_62050 + 32 * v23);
          v18 = (void **)off_5F148;
        }
        if ( *(_DWORD *)((char *)qword_62050 + v24) )
        {
          v21 = 1796;
          if ( !qword_62040 )
            goto LABEL_105;
          v25 = *(_QWORD *)(qword_62040 + 1112);
          if ( !v25 )
            goto LABEL_105;
          v21 = (*(__int64 (__fastcall **)(__int64, char *, __int64, __int64))(v25 + 40))(
                  qword_62040,
                  (char *)qword_62050 + 32 * v23,
                  v15,
                  1796i64);
          if ( v21 )
          {
            v18 = (void **)off_5F148;
LABEL_105:
            if ( v18 != &off_5F148 && (*((_BYTE *)v18 + 172) & 1) != 0 && *((_BYTE *)v18 + 169) )
            {
              v27 = 83;
LABEL_103:
              sub_127D0((__int64)v18[19], v27, (__int64)&unk_4DBF8, v21);
            }
            return 260i64;
          }
          v18 = (void **)off_5F148;
          if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) )
          {
            sub_1102C(*((_QWORD *)off_5F148 + 19), 0x54u, (__int64)&unk_4DBF8, v23);
            v18 = (void **)off_5F148;
          }
        }
        ++v23;
        v24 += 32i64;
      }
      while ( v23 < 0x4D );
    }
    if ( v18 != &off_5F148 && (*((_BYTE *)v18 + 172) & 1) != 0 && *((_BYTE *)v18 + 169) >= 4u )
    {
      sub_143A4((__int64)v18[19], 0x55u, (__int64)&unk_4DBF8, qword_62038, qword_62040);
      v18 = (void **)off_5F148;
    }
    if ( qword_62040 )
    {
      v26 = *(_QWORD *)(qword_62040 + 1112);
      if ( v26 )
      {
        v10 = (*(__int64 (__fastcall **)(PVOID))(v26 + 8))(qword_62038);
        if ( !v10 )
        {
          byte_62063 = 1;
          if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
            sub_1102C(*((_QWORD *)off_5F148 + 19), 0x57u, (__int64)&unk_4DBF8, 0);
          return 0i64;
        }
        v18 = (void **)off_5F148;
      }
    }
    if ( v18 == &off_5F148 || (*((_BYTE *)v18 + 172) & 1) == 0 || !*((_BYTE *)v18 + 169) )
      return 260i64;
    v16 = (__int64)v18[19];
    v5 = 86;
    v6 = v10;
LABEL_54:
    sub_1102C(v16, v5, (__int64)&unk_4DBF8, v6);
    return 260i64;
  }
  v19 = 0;
  v20 = 0i64;
  while ( 1 )
  {
    if ( v18 != &off_5F148 && (*((_BYTE *)v18 + 172) & 1) != 0 && *((_BYTE *)v18 + 169) >= 4u )
    {
      sub_143EC(
        (__int64)v18[19],
        0x4Fu,
        (__int64)&unk_4DBF8,
        qword_62038,
        qword_62040,
        (char *)qword_62048 + 64 * (unsigned __int64)v19);
      v18 = (void **)off_5F148;
    }
    if ( !*(_DWORD *)((char *)qword_62048 + v20) )
      goto LABEL_70;
    v21 = 1796;
    if ( !qword_62040 )
      goto LABEL_99;
    v22 = *(_QWORD *)(qword_62040 + 1112);
    if ( !v22 )
      goto LABEL_99;
    v21 = (*(__int64 (__fastcall **)(__int64, char *, __int64, __int64))(v22 + 64))(
            qword_62040,
            (char *)qword_62048 + 64 * (unsigned __int64)v19,
            v15,
            1796i64);
    if ( v21 )
      break;
    v18 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x51u, (__int64)&unk_4DBF8, v19);
      v18 = (void **)off_5F148;
    }
LABEL_70:
    ++v19;
    v20 += 64i64;
    if ( v19 >= 0x4D )
      goto LABEL_71;
  }
  v18 = (void **)off_5F148;
LABEL_99:
  if ( v18 != &off_5F148 && (*((_BYTE *)v18 + 172) & 1) != 0 && *((_BYTE *)v18 + 169) )
  {
    v27 = 80;
    goto LABEL_103;
  }
  return 260i64;
}
// 31989: variable 'v15' is possibly undefined
// 5F148: using guessed type void *off_5F148;
// 61BE8: using guessed type __int64 qword_61BE8;
// 62030: using guessed type int dword_62030;
// 62040: using guessed type __int64 qword_62040;
// 62058: using guessed type int dword_62058;
// 6205C: using guessed type int dword_6205C;
// 62060: using guessed type char byte_62060;
// 62061: using guessed type char byte_62061;
// 62063: using guessed type char byte_62063;

//----- (0000000000031C70) ----------------------------------------------------
__int64 sub_31C70()
{
  void **v0; // rcx
  unsigned int v2; // ebx
  __int64 v3; // rdx
  unsigned int v4; // eax
  PVOID v5; // rdi
  __int64 v6; // rax
  int v7; // esi
  int v8; // eax
  int v9; // er11
  char v10; // al
  __int64 v11; // rax
  __int64 v12; // r8
  int v13; // eax
  __int64 v14; // rdx
  __int64 v15; // [rsp+20h] [rbp-28h]
  __int64 v16; // [rsp+50h] [rbp+8h] BYREF

  v0 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x58u, (__int64)&unk_4DBF8);
    v0 = (void **)off_5F148;
  }
  if ( !byte_62063 )
  {
    if ( v0 != &off_5F148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
      sub_11008((__int64)v0[19], 0x59u, (__int64)&unk_4DBF8);
    return 260i64;
  }
  if ( v0 != &off_5F148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 4u )
  {
    sub_17984((__int64)v0[19], 0x5Au, (__int64)&unk_4DBF8, qword_62040);
    v0 = (void **)off_5F148;
  }
  v2 = 0;
  if ( qword_62040 )
  {
    v3 = *(_QWORD *)(qword_62040 + 1112);
    if ( v3 )
    {
      v4 = (*(__int64 (__fastcall **)(__int64))(v3 + 88))(qword_62040);
      v0 = (void **)off_5F148;
      v2 = v4;
    }
  }
  if ( v0 != &off_5F148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 4u )
  {
    sub_17814((__int64)v0[19], 0x5Bu, (__int64)&unk_4DBF8, qword_62038, v2);
    v0 = (void **)off_5F148;
  }
  v5 = qword_62038;
  v6 = 0i64;
  v7 = 1796;
  v16 = 0i64;
  if ( qword_62038 )
  {
    v8 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64 *))(*((_QWORD *)qword_62038 + 1) + 8i64))(
           **((_QWORD **)qword_62038 + 1),
           1i64,
           &v16);
    v0 = (void **)off_5F148;
    v9 = v8;
    v6 = v16;
  }
  else
  {
    v9 = 1796;
  }
  if ( !v9 )
  {
    v10 = (*(__int64 (__fastcall **)(PVOID, _QWORD))(v6 + 80))(v5, v2);
    v0 = (void **)off_5F148;
    if ( v10 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
      {
        LODWORD(v15) = v2;
        sub_17814(*((_QWORD *)off_5F148 + 19), 0x5Du, (__int64)&unk_4DBF8, qword_62038, v15);
        v0 = (void **)off_5F148;
      }
      v11 = qword_62040;
      if ( qword_62040 )
      {
        v12 = *(_QWORD *)(qword_62040 + 1112);
        if ( v12 )
        {
          v13 = (*(__int64 (__fastcall **)(PVOID, __int64))(v12 + 16))(qword_62038, qword_62040);
          v0 = (void **)off_5F148;
          v7 = v13;
          v11 = qword_62040;
        }
      }
      if ( v7 )
      {
        if ( v0 != &off_5F148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
          sub_1102C((__int64)v0[19], 0x5Eu, (__int64)&unk_4DBF8, v7 != 0);
        return 257i64;
      }
      if ( v0 != &off_5F148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 4u )
      {
        sub_11008((__int64)v0[19], 0x5Fu, (__int64)&unk_4DBF8);
        v0 = (void **)off_5F148;
        v11 = qword_62040;
      }
      if ( !v11 )
        goto LABEL_52;
      v14 = *(_QWORD *)(v11 + 1112);
      if ( !v14 )
        goto LABEL_52;
      (*(void (__fastcall **)(__int64))(v14 + 32))(v11);
      goto LABEL_51;
    }
  }
  if ( v0 != &off_5F148 )
  {
    if ( (*((_BYTE *)v0 + 172) & 1) == 0 || *((_BYTE *)v0 + 169) < 2u )
    {
LABEL_52:
      if ( v0 != &off_5F148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 4u )
        sub_17984((__int64)v0[19], 0x60u, (__int64)&unk_4DBF8, qword_62038);
      goto LABEL_56;
    }
    sub_11008((__int64)v0[19], 0x5Cu, (__int64)&unk_4DBF8);
LABEL_51:
    v0 = (void **)off_5F148;
    goto LABEL_52;
  }
LABEL_56:
  sub_4B208(qword_62038);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x61u, (__int64)&unk_4DBF8, 0);
  return 0i64;
}
// 31E38: variable 'v15' is possibly undefined
// 5F148: using guessed type void *off_5F148;
// 62040: using guessed type __int64 qword_62040;
// 62063: using guessed type char byte_62063;

//----- (0000000000031FD0) ----------------------------------------------------
__int64 __fastcall sub_31FD0(int a1, const void *a2, unsigned int a3, int a4, int *a5)
{
  unsigned int v5; // edi
  size_t v7; // rbp
  void **v10; // r10
  __int64 v11; // rdx
  int v12; // er9
  __int64 v13; // rax
  int v15; // eax
  void **v16; // rcx
  __int64 v17; // rdx
  int *v18; // rbx
  void **v19; // rcx
  char v20[8]; // [rsp+40h] [rbp-38h] BYREF
  __int64 v21; // [rsp+48h] [rbp-30h] BYREF
  int v22; // [rsp+80h] [rbp+8h] BYREF

  v5 = 0;
  v7 = a3;
  v21 = 0i64;
  v22 = 0;
  v10 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( _bittest((const signed __int32 *)off_5F148 + 43, 0xAu) && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      sub_142F4(*((_QWORD *)off_5F148 + 19), 0x62u, (__int64)&unk_4DBF8, a1);
      v10 = (void **)off_5F148;
    }
    if ( v10 != &off_5F148 && _bittest((const signed __int32 *)v10 + 43, 0xAu) && *((_BYTE *)v10 + 169) >= 4u )
    {
      sub_28DD0((__int64)v10[19], 0x63u, (__int64)&unk_4DBF8, qword_62038, &unk_61C20, v7, &v21);
      v10 = (void **)off_5F148;
    }
  }
  v11 = *((_QWORD *)qword_62048 + 8 * (unsigned __int64)(unsigned int)(a1 - 40000) + 2);
  v21 = 0i64;
  if ( !qword_62038 )
  {
    v12 = 1799;
    goto LABEL_15;
  }
  if ( !v11 )
  {
    v12 = 1796;
    goto LABEL_15;
  }
  v13 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD))(*((_QWORD *)qword_62038 + 5) + 16i64))(
          **((_QWORD **)qword_62038 + 5),
          v11,
          (unsigned int)v7);
  v21 = v13;
  if ( !v13 )
  {
    v10 = (void **)off_5F148;
    v12 = 1798;
LABEL_15:
    if ( v10 != &off_5F148 && _bittest((const signed __int32 *)v10 + 43, 0xAu) && *((_BYTE *)v10 + 169) >= 2u )
      sub_1102C((__int64)v10[19], 0x64u, (__int64)&unk_4DBF8, v12);
    return 1i64;
  }
  if ( a4 )
  {
    *(_DWORD *)(v13 + 32) = a4;
    v13 = v21;
  }
  memmove(*(void **)(v13 + 56), a2, v7);
  v15 = sub_4B278((__int64)qword_62038, v21);
  if ( v15 )
  {
    v16 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 43, 0xAu)
      && *((_BYTE *)off_5F148 + 169) >= 2u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x66u, (__int64)&unk_4DBF8, v15);
      v16 = (void **)off_5F148;
    }
    v5 = 263;
  }
  else
  {
    v16 = (void **)off_5F148;
  }
  v17 = v21;
  if ( qword_62038 && v21 )
  {
    v18 = a5;
    (*(void (__fastcall **)(_QWORD, __int64, int *, int *, char *, _QWORD))(*((_QWORD *)qword_62038 + 5) + 32i64))(
      **((_QWORD **)qword_62038 + 5),
      v21,
      &v22,
      a5,
      v20,
      0i64);
    v17 = v21;
  }
  else
  {
    if ( v16 != &off_5F148 && _bittest((const signed __int32 *)v16 + 43, 0xAu) && *((_BYTE *)v16 + 169) >= 4u )
    {
      sub_11008((__int64)v16[19], 0x67u, (__int64)&unk_4DBF8);
      v17 = v21;
    }
    v18 = a5;
    *a5 = 0;
  }
  v19 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 0xAu)
    && *((_BYTE *)off_5F148 + 169) >= 4u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x68u, (__int64)&unk_4DBF8, *v18);
    v17 = v21;
    v19 = (void **)off_5F148;
  }
  if ( v17 && qword_62038 )
  {
    (*(void (__fastcall **)(_QWORD))(*((_QWORD *)qword_62038 + 5) + 24i64))(**((_QWORD **)qword_62038 + 5));
    v19 = (void **)off_5F148;
  }
  if ( v19 != &off_5F148 && _bittest((const signed __int32 *)v19 + 43, 0xAu) && *((_BYTE *)v19 + 169) >= 5u )
    sub_1102C((__int64)v19[19], 0x69u, (__int64)&unk_4DBF8, v5);
  return v5;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000322F4) ----------------------------------------------------
__int64 __fastcall sub_322F4(int a1, const void *a2, unsigned int a3, _DWORD *a4)
{
  size_t v5; // rdi
  const void *v6; // rsi
  __int64 v8; // rdx
  int v9; // eax
  __int64 v10; // rax
  __int64 v11; // rbx
  void **v13; // rcx
  _QWORD *v14; // rdx
  int v15; // eax
  const void *v16; // [rsp+20h] [rbp-28h]

  v5 = a3;
  v6 = a2;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 0xAu)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    v16 = a2;
    sub_142F4(*((_QWORD *)off_5F148 + 19), 0x7Eu, (__int64)&unk_4DBF8, a1);
  }
  *a4 = 0;
  v8 = *((_QWORD *)qword_62048 + 8 * (unsigned __int64)(unsigned int)(a1 - 40000) + 2);
  if ( !qword_62038 )
  {
    v9 = 1799;
LABEL_11:
    if ( off_5F148 != &off_5F148
      && _bittest((const signed __int32 *)off_5F148 + 43, 0xAu)
      && *((_BYTE *)off_5F148 + 169) >= 2u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x7Fu, (__int64)&unk_4DBF8, v9);
    }
    return 1i64;
  }
  if ( !v8 )
  {
    v9 = 1796;
    goto LABEL_11;
  }
  v10 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD))(*((_QWORD *)qword_62038 + 5) + 16i64))(
          **((_QWORD **)qword_62038 + 5),
          v8,
          (unsigned int)v5);
  v11 = v10;
  if ( !v10 )
  {
    v9 = 1798;
    goto LABEL_11;
  }
  memmove(*(void **)(v10 + 56), v6, v5);
  v13 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 0xAu)
    && *((_BYTE *)off_5F148 + 169) >= 4u )
  {
    sub_143EC(*((_QWORD *)off_5F148 + 19), 0x81u, (__int64)&unk_4DBF8, qword_62038, v11, sub_32548);
    v13 = (void **)off_5F148;
  }
  v14 = qword_62038;
  if ( !qword_62038 )
  {
    v15 = 1799;
LABEL_26:
    if ( v13 != &off_5F148 && _bittest((const signed __int32 *)v13 + 43, 0xAu) && *((_BYTE *)v13 + 169) >= 2u )
    {
      sub_1102C((__int64)v13[19], 0x82u, (__int64)&unk_4DBF8, v15);
      v14 = qword_62038;
    }
    if ( v14 )
      (*(void (__fastcall **)(_QWORD, __int64))(v14[5] + 24i64))(*(_QWORD *)v14[5], v11);
    return 1i64;
  }
  if ( sub_32548 )
  {
    LOBYTE(v16) = 0;
    v15 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD, const void *, __int64 (__fastcall *)(__int64, __int64, __int64)))(*((_QWORD *)qword_62038 + 3) + 16i64))(
            **((_QWORD **)qword_62038 + 3),
            v11,
            0i64,
            0i64,
            v16,
            sub_32548);
    v13 = (void **)off_5F148;
    v14 = qword_62038;
  }
  else
  {
    v15 = 1796;
  }
  if ( v15 )
    goto LABEL_26;
  if ( v13 != &off_5F148 && _bittest((const signed __int32 *)v13 + 43, 0xAu) && *((_BYTE *)v13 + 169) >= 5u )
    sub_1102C((__int64)v13[19], 0x83u, (__int64)&unk_4DBF8, 0);
  return 0i64;
}
// 32488: variable 'v16' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (0000000000032548) ----------------------------------------------------
__int64 __fastcall sub_32548(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int v3; // esi
  void **v7; // rcx
  void (__fastcall *v9)(_QWORD, _QWORD, _QWORD, int *); // rdi
  unsigned __int16 v10; // dx
  char v11[40]; // [rsp+40h] [rbp-28h] BYREF
  int v12; // [rsp+80h] [rbp+18h] BYREF
  char v13; // [rsp+88h] [rbp+20h] BYREF

  v3 = 0;
  v12 = 0;
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 0xAu)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_143EC(*((_QWORD *)off_5F148 + 19), 0x84u, (__int64)&unk_4DBF8, a1, a2, a3);
    v7 = (void **)off_5F148;
  }
  if ( a3 )
  {
    if ( a2 )
    {
      v9 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, int *))(a2 + 8);
      if ( v9 )
      {
        if ( v7 != &off_5F148 && _bittest((const signed __int32 *)v7 + 43, 0xAu) && *((_BYTE *)v7 + 169) >= 4u )
        {
          sub_12818((__int64)v7[19], 0x86u, (__int64)&unk_4DBF8, qword_62038, a3, &v13, &v12);
          v7 = (void **)off_5F148;
        }
        if ( qword_62038 )
        {
          (*(void (__fastcall **)(_QWORD, __int64, char *, int *, char *, _QWORD))(*((_QWORD *)qword_62038 + 5) + 32i64))(
            **((_QWORD **)qword_62038 + 5),
            a3,
            &v13,
            &v12,
            v11,
            0i64);
        }
        else
        {
          v3 = 1799;
          if ( v7 != &off_5F148 && _bittest((const signed __int32 *)v7 + 43, 0xAu) && *((_BYTE *)v7 + 169) >= 2u )
            sub_1102C((__int64)v7[19], 0x87u, (__int64)&unk_4DBF8, 1799);
        }
        v9(*(unsigned int *)(a3 + 8), *(_QWORD *)(a3 + 56), *(unsigned int *)(a3 + 28), &v12);
        if ( qword_62038 )
          (*(void (__fastcall **)(_QWORD, __int64))(*((_QWORD *)qword_62038 + 5) + 24i64))(
            **((_QWORD **)qword_62038 + 5),
            a3);
        goto LABEL_34;
      }
      if ( v7 != &off_5F148 )
      {
        if ( _bittest((const signed __int32 *)v7 + 43, 0xAu) && *((_BYTE *)v7 + 169) >= 2u )
        {
          v10 = 136;
LABEL_33:
          sub_11008((__int64)v7[19], v10, (__int64)&unk_4DBF8);
LABEL_34:
          v7 = (void **)off_5F148;
          goto LABEL_35;
        }
        goto LABEL_35;
      }
    }
    else if ( v7 != &off_5F148 )
    {
      if ( _bittest((const signed __int32 *)v7 + 43, 0xAu) && *((_BYTE *)v7 + 169) >= 2u )
      {
        v10 = 137;
        goto LABEL_33;
      }
LABEL_35:
      if ( v7 != &off_5F148 && _bittest((const signed __int32 *)v7 + 43, 0xAu) && *((_BYTE *)v7 + 169) >= 5u )
        sub_1102C((__int64)v7[19], 0x8Au, (__int64)&unk_4DBF8, v3);
      return v3;
    }
    return v3;
  }
  if ( v7 != &off_5F148 && _bittest((const signed __int32 *)v7 + 43, 0xAu) && *((_BYTE *)v7 + 169) >= 2u )
    sub_11008((__int64)v7[19], 0x85u, (__int64)&unk_4DBF8);
  return 3899654172i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000327A0) ----------------------------------------------------
__int64 __fastcall sub_327A0(unsigned int *a1)
{
  void **v2; // rcx
  __int64 result; // rax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x8Bu, (__int64)&unk_4DBF8);
    v2 = (void **)off_5F148;
  }
  qword_61BE8 = 0i64;
  qword_61BF0 = 0i64;
  qword_61BF8 = 0i64;
  qword_61BE8 = *a1;
  HIDWORD(qword_61BE8) = *((unsigned __int8 *)a1 + 4);
  qword_61BF0 = *((_QWORD *)a1 + 1);
  if ( *((_QWORD *)a1 + 2) )
  {
    qword_61BF8 = (__int64)sub_328FC;
    qword_62068 = (__int64 (__fastcall *)(_QWORD))*((_QWORD *)a1 + 2);
    if ( v2 != &off_5F148 )
    {
      if ( (*((_BYTE *)v2 + 172) & 1) != 0 && *((_BYTE *)v2 + 169) >= 4u )
      {
        sub_11008((__int64)v2[19], 0x8Cu, (__int64)&unk_4DBF8);
        v2 = (void **)off_5F148;
      }
      if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 1) != 0 && *((_BYTE *)v2 + 169) >= 5u )
        sub_1102C((__int64)v2[19], 0x8Eu, (__int64)&unk_4DBF8, 0);
    }
    result = 0i64;
  }
  else
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 1) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x8Du, (__int64)&unk_4DBF8);
    result = 264i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;
// 61BE8: using guessed type __int64 qword_61BE8;
// 61BF0: using guessed type __int64 qword_61BF0;
// 61BF8: using guessed type __int64 qword_61BF8;
// 62068: using guessed type __int64 (__fastcall *qword_62068)(_QWORD);

//----- (00000000000328FC) ----------------------------------------------------
__int64 __fastcall sub_328FC(__int64 a1, __int64 a2, __int64 a3)
{
  void **v4; // rcx

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( _bittest((const signed __int32 *)off_5F148 + 43, 8u) && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x8Fu, (__int64)&unk_4DBF8);
      v4 = (void **)off_5F148;
    }
    if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 43, 8u) && *((_BYTE *)v4 + 169) >= 4u )
    {
      sub_17984((__int64)v4[19], 0x90u, (__int64)&unk_4DBF8, a3);
      v4 = (void **)off_5F148;
    }
  }
  if ( qword_62068 )
  {
    qword_62068(a3);
    v4 = (void **)off_5F148;
  }
  if ( v4 != &off_5F148 && _bittest((const signed __int32 *)v4 + 43, 8u) && *((_BYTE *)v4 + 169) >= 5u )
    sub_1102C((__int64)v4[19], 0x91u, (__int64)&unk_4DBF8, 0);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;
// 62068: using guessed type __int64 (__fastcall *qword_62068)(_QWORD);

//----- (00000000000329E8) ----------------------------------------------------
__int64 __fastcall sub_329E8(__int64 a1, int a2, unsigned int a3, void *a4)
{
  unsigned int v8; // ebx
  void **v9; // rcx
  _DWORD *v11; // rdi
  __int64 v12; // r8
  int v13; // eax

  v8 = 6;
  v9 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 8u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_127D0(*((_QWORD *)off_5F148 + 19), 0x92u, (__int64)&unk_4DBF8, a2);
    v9 = (void **)off_5F148;
  }
  if ( !byte_62063 )
  {
    if ( v9 != &off_5F148 && _bittest((const signed __int32 *)v9 + 43, 8u) && *((_BYTE *)v9 + 169) >= 2u )
      sub_11008((__int64)v9[19], 0x93u, (__int64)&unk_4DBF8);
    return 260i64;
  }
  v11 = *(_DWORD **)(a1 + 56);
  if ( v11 )
  {
    if ( a2 && v9 != &off_5F148 && _bittest((const signed __int32 *)v9 + 43, 8u) && *((_BYTE *)v9 + 169) >= 3u )
    {
      sub_1102C((__int64)v9[19], 0x94u, (__int64)&unk_4DBF8, a2);
      v9 = (void **)off_5F148;
    }
    v12 = a2 != 0 ? 0x80000000 : 0;
    if ( *v11 == 3 || *v11 == 8 )
    {
      v13 = sub_4B2BC((__int64)qword_62038, a1, v12, a3, a4);
    }
    else
    {
      if ( !qword_62038 )
      {
        v13 = 1799;
        goto LABEL_24;
      }
      v13 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD, _QWORD))(*((_QWORD *)qword_62038 + 3) + 24i64))(
              **((_QWORD **)qword_62038 + 3),
              a1,
              v12,
              0i64,
              0i64);
    }
    v9 = (void **)off_5F148;
LABEL_24:
    if ( v13 )
    {
      if ( v9 != &off_5F148 && _bittest((const signed __int32 *)v9 + 43, 8u) && *((_BYTE *)v9 + 169) >= 2u )
      {
        sub_1102C((__int64)v9[19], 0x95u, (__int64)&unk_4DBF8, v13);
        v9 = (void **)off_5F148;
      }
      v8 = 273;
    }
    else
    {
      v8 = 0;
    }
  }
  if ( v9 != &off_5F148 && _bittest((const signed __int32 *)v9 + 43, 8u) && *((_BYTE *)v9 + 169) >= 5u )
    sub_1102C((__int64)v9[19], 0x96u, (__int64)&unk_4DBF8, v8);
  return v8;
}
// 5F148: using guessed type void *off_5F148;
// 62063: using guessed type char byte_62063;

//----- (0000000000032BE4) ----------------------------------------------------
__int64 __fastcall sub_32BE4(__int64 a1, __int64 a2, __int64 a3)
{
  void **v6; // rcx
  void (__fastcall *v7)(_QWORD, _QWORD, _QWORD, __int64, unsigned int *); // rax
  unsigned int v8; // ebx
  unsigned int v9; // eax
  unsigned __int16 v11; // dx
  unsigned int v12; // [rsp+58h] [rbp+20h] BYREF

  v12 = 3;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( _bittest((const signed __int32 *)off_5F148 + 43, 0xAu) && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      sub_143EC(*((_QWORD *)off_5F148 + 19), 0x97u, (__int64)&unk_4DBF8, a1, a2, a3);
      v6 = (void **)off_5F148;
    }
    if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 4u )
    {
      sub_1102C((__int64)v6[19], 0x98u, (__int64)&unk_4DBF8, *(_DWORD *)a3);
      v6 = (void **)off_5F148;
    }
  }
  if ( !byte_62064 )
  {
    if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 3u )
      sub_11008((__int64)v6[19], 0x99u, (__int64)&unk_4DBF8);
    return 0i64;
  }
  if ( !a2 )
  {
    if ( v6 != &off_5F148 )
    {
      if ( !_bittest((const signed __int32 *)v6 + 43, 0xAu) || *((_BYTE *)v6 + 169) < 2u )
        goto LABEL_37;
      v11 = 157;
LABEL_36:
      sub_11008((__int64)v6[19], v11, (__int64)&unk_4DBF8);
      v6 = (void **)off_5F148;
      goto LABEL_37;
    }
    return 0i64;
  }
  v7 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, __int64, unsigned int *))(a2 + 8);
  if ( !v7 )
  {
    if ( v6 != &off_5F148 )
    {
      if ( !_bittest((const signed __int32 *)v6 + 43, 0xAu) || *((_BYTE *)v6 + 169) < 2u )
        goto LABEL_37;
      v11 = 156;
      goto LABEL_36;
    }
    return 0i64;
  }
  v7(*(unsigned int *)(a3 + 8), *(_QWORD *)(a3 + 56), *(unsigned int *)(a3 + 28), a3, &v12);
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 0xAu)
    && *((_BYTE *)off_5F148 + 169) >= 4u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x9Au, (__int64)&unk_4DBF8, v12);
    v6 = (void **)off_5F148;
  }
  if ( !qword_62038 )
  {
    v8 = 1799;
    goto LABEL_23;
  }
  v9 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD, _QWORD))(*((_QWORD *)qword_62038 + 3) + 24i64))(
         **((_QWORD **)qword_62038 + 3),
         a3,
         v12,
         0i64,
         0i64);
  v6 = (void **)off_5F148;
  v8 = v9;
  if ( !v9 )
  {
LABEL_37:
    if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 5u )
      sub_1102C((__int64)v6[19], 0x9Eu, (__int64)&unk_4DBF8, 0);
    return 0i64;
  }
LABEL_23:
  if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 2u )
    sub_1102C((__int64)v6[19], 0x9Bu, (__int64)&unk_4DBF8, v8);
  return v8;
}
// 5F148: using guessed type void *off_5F148;
// 62064: using guessed type char byte_62064;

//----- (0000000000032E58) ----------------------------------------------------
__int64 __fastcall sub_32E58(__int64 a1, __int64 a2, __int64 a3)
{
  void **v6; // rcx
  void (__fastcall *v7)(_QWORD, _QWORD, _QWORD, unsigned int *, PVOID *, __int64 *); // rax
  void **v8; // rcx
  int v9; // eax
  unsigned int v10; // ebx
  unsigned __int16 v12; // dx
  __int64 v13; // [rsp+20h] [rbp-28h]
  __int64 Tag; // [rsp+30h] [rbp-18h] BYREF
  PVOID P[2]; // [rsp+38h] [rbp-10h] BYREF
  unsigned int v16; // [rsp+68h] [rbp+20h] BYREF

  P[0] = 0i64;
  v16 = 0;
  LODWORD(Tag) = 0;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( _bittest((const signed __int32 *)off_5F148 + 43, 0xAu) && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      sub_143EC(*((_QWORD *)off_5F148 + 19), 0x9Fu, (__int64)&unk_4DBF8, a1, a2, a3, Tag);
      v6 = (void **)off_5F148;
    }
    if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 4u )
    {
      sub_1102C((__int64)v6[19], 0xA0u, (__int64)&unk_4DBF8, *(_DWORD *)a3);
      v6 = (void **)off_5F148;
    }
  }
  if ( !byte_62064 )
  {
    if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 3u )
      sub_11008((__int64)v6[19], 0xA1u, (__int64)&unk_4DBF8);
    return 0i64;
  }
  if ( !a2 )
  {
    if ( v6 == &off_5F148 )
      return 0i64;
    if ( !_bittest((const signed __int32 *)v6 + 43, 0xAu) || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_46;
    v12 = 167;
    goto LABEL_44;
  }
  v7 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, unsigned int *, PVOID *, __int64 *))(a2 + 16);
  if ( !v7 )
  {
    if ( v6 == &off_5F148 )
      return 0i64;
    if ( !_bittest((const signed __int32 *)v6 + 43, 0xAu) || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_46;
    v12 = 166;
LABEL_44:
    sub_11008((__int64)v6[19], v12, (__int64)&unk_4DBF8);
    goto LABEL_45;
  }
  v7(*(unsigned int *)(a3 + 8), *(_QWORD *)(a3 + 56), *(unsigned int *)(a3 + 28), &v16, P, &Tag);
  v8 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( _bittest((const signed __int32 *)off_5F148 + 43, 0xAu) && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0xA2u, (__int64)&unk_4DBF8, 5);
      v8 = (void **)off_5F148;
    }
    if ( v8 != &off_5F148 && _bittest((const signed __int32 *)v8 + 43, 0xAu) && *((_BYTE *)v8 + 169) >= 4u )
      sub_1102C((__int64)v8[19], 0xA3u, (__int64)&unk_4DBF8, v16);
  }
  v9 = sub_4B2BC((__int64)qword_62038, a3, 5i64, v16, P[0]);
  v10 = v9;
  if ( !v9 )
  {
    if ( !P[0] || !v16 )
      goto LABEL_45;
    LODWORD(v13) = 0;
    sub_26488(P[0], Tag);
    v6 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 )
    {
      if ( _bittest((const signed __int32 *)off_5F148 + 43, 0xAu) && *((_BYTE *)off_5F148 + 169) >= 4u )
      {
        sub_17984(*((_QWORD *)off_5F148 + 19), 0xA5u, (__int64)&unk_4DBF8, P[0], v13);
LABEL_45:
        v6 = (void **)off_5F148;
      }
LABEL_46:
      if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 5u )
        sub_1102C((__int64)v6[19], 0xA8u, (__int64)&unk_4DBF8, 0);
    }
    return 0i64;
  }
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 0xAu)
    && *((_BYTE *)off_5F148 + 169) >= 2u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0xA4u, (__int64)&unk_4DBF8, v9);
  }
  return v10;
}
// 330C7: variable 'v13' is possibly undefined
// 5F148: using guessed type void *off_5F148;
// 62064: using guessed type char byte_62064;

//----- (0000000000033170) ----------------------------------------------------
__int64 __fastcall sub_33170(__int64 a1, __int64 a2, __int64 a3)
{
  void **v6; // rcx
  void (__fastcall *v7)(_QWORD, _QWORD, __int64, __int64); // rax
  unsigned __int16 v8; // dx

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      sub_143EC(*((_QWORD *)off_5F148 + 19), 0xF7u, (__int64)&unk_4DBF8, a1, a2, a3);
      v6 = (void **)off_5F148;
    }
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 1) != 0 && *((_BYTE *)v6 + 169) >= 4u )
    {
      sub_1102C((__int64)v6[19], 0xF8u, (__int64)&unk_4DBF8, *(_DWORD *)a3);
      v6 = (void **)off_5F148;
    }
  }
  if ( !byte_62064 )
  {
    if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 3u )
      sub_11008((__int64)v6[19], 0xF9u, (__int64)&unk_4DBF8);
    return 0i64;
  }
  if ( a2 )
  {
    v7 = *(void (__fastcall **)(_QWORD, _QWORD, __int64, __int64))(a2 + 24);
    if ( v7 )
    {
      v7(*(unsigned int *)(a3 + 8), *(_QWORD *)(a3 + 56), 1024i64, a1);
      v6 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return 0i64;
      if ( (*((_BYTE *)off_5F148 + 172) & 1) == 0 || *((_BYTE *)off_5F148 + 169) < 4u )
        goto LABEL_30;
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0xFAu, (__int64)&unk_4DBF8, 3);
      goto LABEL_29;
    }
    if ( v6 == &off_5F148 )
      return 0i64;
    if ( (*((_BYTE *)v6 + 172) & 1) == 0 || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_30;
    v8 = 251;
  }
  else
  {
    if ( v6 == &off_5F148 )
      return 0i64;
    if ( (*((_BYTE *)v6 + 172) & 1) == 0 || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_30;
    v8 = 252;
  }
  sub_11008((__int64)v6[19], v8, (__int64)&unk_4DBF8);
LABEL_29:
  v6 = (void **)off_5F148;
LABEL_30:
  if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 1) != 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_1102C((__int64)v6[19], 0xFDu, (__int64)&unk_4DBF8, 0);
  return 0i64;
}
// 33273: variable 'a1' is possibly undefined
// 5F148: using guessed type void *off_5F148;
// 62064: using guessed type char byte_62064;

//----- (0000000000033350) ----------------------------------------------------
__int64 sub_33350()
{
  void **v0; // rcx
  __int64 result; // rax
  int v2; // eax
  unsigned int v3; // ebx

  v0 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xFEu, (__int64)&unk_4DBF8);
    v0 = (void **)off_5F148;
  }
  if ( byte_62062 )
  {
    v2 = sub_30318(40015, 2);
    v3 = v2;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x100u, (__int64)&unk_4DBF8, v2);
    result = v3;
  }
  else
  {
    if ( v0 != &off_5F148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
      sub_11008((__int64)v0[19], 0xFFu, (__int64)&unk_4DBF8);
    result = 258i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;
// 62062: using guessed type char byte_62062;

//----- (0000000000033440) ----------------------------------------------------
__int64 __fastcall sub_33440(int a1, __int64 a2)
{
  void **v4; // rcx
  __int64 result; // rax
  _QWORD *v6; // rax
  _QWORD *v7; // rcx
  void **v8; // rcx

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x101u, (__int64)&unk_4DBF8);
    v4 = (void **)off_5F148;
  }
  if ( byte_62062 )
  {
    if ( !dword_6205C )
    {
      qword_61C18 = (__int64)&qword_61C10;
      qword_61C10 = &qword_61C10;
    }
    v6 = sub_26404(2, 0x48u, 0x746D436Eu);
    if ( v6 )
    {
      v6[4] = 0i64;
      v6[6] = 0i64;
      *((_DWORD *)v6 + 4) = a1;
      v6[7] = a2;
      *((_DWORD *)v6 + 6) = 1;
      *((_DWORD *)v6 + 7) = 6;
      v6[8] = &qword_61C00;
      v7 = (_QWORD *)qword_61C18;
      *v6 = &qword_61C10;
      v6[1] = v7;
      *v7 = v6;
      ++dword_6205C;
      qword_61C18 = (__int64)v6;
      v8 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 )
      {
        if ( (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
        {
          sub_1102C(*((_QWORD *)off_5F148 + 19), 0x104u, (__int64)&unk_4DBF8, a1);
          v8 = (void **)off_5F148;
        }
        if ( v8 != &off_5F148 && (*((_BYTE *)v8 + 172) & 1) != 0 && *((_BYTE *)v8 + 169) >= 5u )
          sub_1102C((__int64)v8[19], 0x105u, (__int64)&unk_4DBF8, 0);
      }
      result = 0i64;
    }
    else
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x103u, (__int64)&unk_4DBF8);
      result = 3i64;
    }
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x102u, (__int64)&unk_4DBF8);
    result = 258i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;
// 61C18: using guessed type __int64 qword_61C18;
// 6205C: using guessed type int dword_6205C;
// 62062: using guessed type char byte_62062;

//----- (0000000000033638) ----------------------------------------------------
__int64 __fastcall sub_33638(int a1, __int64 a2)
{
  void **v4; // rcx
  __int64 result; // rax
  _QWORD *v6; // rax
  _QWORD *v7; // rcx
  void **v8; // rcx

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x106u, (__int64)&unk_4DBF8);
    v4 = (void **)off_5F148;
  }
  if ( byte_62062 )
  {
    if ( !dword_6205C )
    {
      qword_61C18 = (__int64)&qword_61C10;
      qword_61C10 = &qword_61C10;
    }
    v6 = sub_26404(2, 0x48u, 0x746D436Eu);
    if ( v6 )
    {
      v6[4] = 0i64;
      v6[6] = 0i64;
      v6[7] = 0i64;
      *((_DWORD *)v6 + 4) = a1;
      v6[5] = a2;
      *((_DWORD *)v6 + 6) = 1;
      *((_DWORD *)v6 + 7) = 6;
      v6[8] = &qword_61C00;
      v7 = (_QWORD *)qword_61C18;
      *v6 = &qword_61C10;
      v6[1] = v7;
      *v7 = v6;
      ++dword_6205C;
      qword_61C18 = (__int64)v6;
      v8 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 )
      {
        if ( (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
        {
          sub_1102C(*((_QWORD *)off_5F148 + 19), 0x109u, (__int64)&unk_4DBF8, a1);
          v8 = (void **)off_5F148;
        }
        if ( v8 != &off_5F148 && (*((_BYTE *)v8 + 172) & 1) != 0 && *((_BYTE *)v8 + 169) >= 5u )
          sub_1102C((__int64)v8[19], 0x10Au, (__int64)&unk_4DBF8, 0);
      }
      result = 0i64;
    }
    else
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x108u, (__int64)&unk_4DBF8);
      result = 3i64;
    }
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x107u, (__int64)&unk_4DBF8);
    result = 258i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;
// 61C18: using guessed type __int64 qword_61C18;
// 6205C: using guessed type int dword_6205C;
// 62062: using guessed type char byte_62062;

//----- (0000000000033838) ----------------------------------------------------
__int64 __fastcall sub_33838(__int64 a1, const void *a2, unsigned int a3)
{
  unsigned int v3; // ebx
  size_t v4; // rdi
  void **v6; // rcx
  __int64 v8; // rdx
  __int64 v9; // rax
  unsigned __int16 v10; // dx
  int v11; // eax
  __int64 v12; // [rsp+78h] [rbp+20h] BYREF

  v3 = 0;
  v4 = a3;
  v12 = 0i64;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 0xDu)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x10Bu, (__int64)&unk_4DBF8);
    v6 = (void **)off_5F148;
  }
  if ( byte_62063 )
  {
    if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 43, 0xDu) && *((_BYTE *)v6 + 169) >= 4u )
    {
      sub_28DD0((__int64)v6[19], 0x10Eu, (__int64)&unk_4DBF8, qword_62038, &unk_61C20, v4, &v12);
      v6 = (void **)off_5F148;
    }
    v8 = *((_QWORD *)qword_62048 + 122);
    v12 = 0i64;
    if ( qword_62038 )
    {
      if ( v8 )
      {
        v9 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD))(*((_QWORD *)qword_62038 + 5) + 16i64))(
               **((_QWORD **)qword_62038 + 5),
               v8,
               (unsigned int)v4);
        v12 = v9;
        if ( v9 )
        {
          memmove(*(void **)(v9 + 56), a2, v4);
          if ( off_5F148 != &off_5F148
            && _bittest((const signed __int32 *)off_5F148 + 43, 0xDu)
            && *((_BYTE *)off_5F148 + 169) >= 4u )
          {
            sub_143A4(*((_QWORD *)off_5F148 + 19), 0x111u, (__int64)&unk_4DBF8, qword_62038, v12);
          }
          v11 = sub_4B278((__int64)qword_62038, v12);
          if ( v11 )
          {
            v6 = (void **)off_5F148;
            if ( off_5F148 != &off_5F148
              && _bittest((const signed __int32 *)off_5F148 + 43, 0xDu)
              && *((_BYTE *)off_5F148 + 169) >= 2u )
            {
              sub_1102C(*((_QWORD *)off_5F148 + 19), 0x112u, (__int64)&unk_4DBF8, v11);
              v6 = (void **)off_5F148;
            }
            v3 = 263;
          }
          else
          {
            v6 = (void **)off_5F148;
          }
          if ( v12 )
          {
            if ( qword_62038 )
            {
              (*(void (__fastcall **)(_QWORD))(*((_QWORD *)qword_62038 + 5) + 24i64))(**((_QWORD **)qword_62038 + 5));
              v6 = (void **)off_5F148;
            }
            v12 = 0i64;
          }
          if ( v6 == &off_5F148 || !_bittest((const signed __int32 *)v6 + 43, 0xDu) || *((_BYTE *)v6 + 169) < 5u )
            return v3;
          v10 = 275;
          goto LABEL_44;
        }
        v6 = (void **)off_5F148;
        v3 = 1798;
      }
      else
      {
        v3 = 1796;
      }
    }
    else
    {
      v3 = 1799;
    }
    if ( v6 == &off_5F148 || !_bittest((const signed __int32 *)v6 + 43, 0xDu) || *((_BYTE *)v6 + 169) < 2u )
      return v3;
    v10 = 271;
LABEL_44:
    sub_1102C((__int64)v6[19], v10, (__int64)&unk_4DBF8, v3);
    return v3;
  }
  if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 43, 0xDu) && *((_BYTE *)v6 + 169) >= 2u )
    sub_11008((__int64)v6[19], 0x10Cu, (__int64)&unk_4DBF8);
  return 260i64;
}
// 5F148: using guessed type void *off_5F148;
// 62063: using guessed type char byte_62063;

//----- (0000000000033AE0) ----------------------------------------------------
__int64 __fastcall sub_33AE0(__int64 a1, __int64 a2, __int64 a3)
{
  void **v6; // rcx
  void (__fastcall *v7)(_QWORD, _QWORD, _QWORD, __int64); // rax
  unsigned __int16 v8; // dx

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      sub_143EC(*((_QWORD *)off_5F148 + 19), 0x114u, (__int64)&unk_4DBF8, a1, a2, a3);
      v6 = (void **)off_5F148;
    }
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 1) != 0 && *((_BYTE *)v6 + 169) >= 4u )
    {
      sub_1102C((__int64)v6[19], 0x115u, (__int64)&unk_4DBF8, *(_DWORD *)a3);
      v6 = (void **)off_5F148;
    }
  }
  if ( !byte_62064 )
  {
    if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 3u )
      sub_11008((__int64)v6[19], 0x116u, (__int64)&unk_4DBF8);
    return 0i64;
  }
  if ( !a2 )
  {
    if ( v6 == &off_5F148 )
      return 0i64;
    if ( (*((_BYTE *)v6 + 172) & 1) == 0 || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_27;
    v8 = 280;
    goto LABEL_25;
  }
  v7 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, __int64))(a2 + 32);
  if ( !v7 )
  {
    if ( v6 == &off_5F148 )
      return 0i64;
    if ( (*((_BYTE *)v6 + 172) & 1) == 0 || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_27;
    v8 = 279;
LABEL_25:
    sub_11008((__int64)v6[19], v8, (__int64)&unk_4DBF8);
    goto LABEL_26;
  }
  v7(*(unsigned int *)(a3 + 8), *(_QWORD *)(a3 + 56), *(unsigned int *)(a3 + 28), a1);
LABEL_26:
  v6 = (void **)off_5F148;
LABEL_27:
  if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 1) != 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_1102C((__int64)v6[19], 0x119u, (__int64)&unk_4DBF8, 0);
  return 0i64;
}
// 33BE1: variable 'a1' is possibly undefined
// 5F148: using guessed type void *off_5F148;
// 62064: using guessed type char byte_62064;

//----- (0000000000033C84) ----------------------------------------------------
__int64 sub_33C84()
{
  unsigned int v0; // ebx
  void **v1; // rcx
  int v2; // eax

  v0 = 0;
  v1 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x11Au, (__int64)&unk_4DBF8);
    v1 = (void **)off_5F148;
  }
  if ( qword_62070 )
    goto LABEL_12;
  v2 = sub_30B00(9u, (__int64)&qword_62070);
  v0 = v2;
  if ( !v2 )
    goto LABEL_11;
  v1 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return v0;
  if ( (*((_BYTE *)off_5F148 + 172) & 1) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x11Bu, (__int64)&unk_4DBF8, v2);
LABEL_11:
    v1 = (void **)off_5F148;
  }
LABEL_12:
  if ( v1 != &off_5F148 && (*((_BYTE *)v1 + 172) & 1) != 0 && *((_BYTE *)v1 + 169) >= 5u )
    sub_1102C((__int64)v1[19], 0x11Cu, (__int64)&unk_4DBF8, v0);
  return v0;
}
// 5F148: using guessed type void *off_5F148;
// 62070: using guessed type __int64 qword_62070;

//----- (0000000000033D7C) ----------------------------------------------------
__int64 __fastcall sub_33D7C(__int64 a1, __int64 *a2, __int64 *a3)
{
  void **v6; // rcx
  __int64 v7; // rbx
  __int64 result; // rax
  int v9; // eax
  void **v10; // rcx
  __int64 v11; // rax

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 0x13u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x11Du, (__int64)&unk_4DBF8);
    v6 = (void **)off_5F148;
  }
  v7 = 0i64;
  if ( qword_62070 )
  {
    v9 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64 *))(qword_62070 + 16))(a1, a2, a3);
    if ( v9 )
    {
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 43, 0x13u)
        && *((_BYTE *)off_5F148 + 169) >= 2u )
      {
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x11Fu, (__int64)&unk_4DBF8, v9);
      }
      result = 275i64;
    }
    else
    {
      if ( a2 && !*a2 )
        *a2 = -1i64;
      if ( a3 && !*a3 )
        *a3 = -1i64;
      v10 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 )
      {
        if ( _bittest((const signed __int32 *)off_5F148 + 43, 0x13u) && *((_BYTE *)off_5F148 + 169) >= 4u )
        {
          if ( a3 )
            v11 = *a3;
          else
            v11 = 0i64;
          if ( a2 )
            v7 = *a2;
          sub_30054(*((_QWORD *)off_5F148 + 19), 288i64, (__int64)&unk_4DBF8, v7, v11);
          v10 = (void **)off_5F148;
        }
        if ( v10 != &off_5F148 && _bittest((const signed __int32 *)v10 + 43, 0x13u) && *((_BYTE *)v10 + 169) >= 5u )
          sub_1102C((__int64)v10[19], 0x121u, (__int64)&unk_4DBF8, 0);
      }
      result = 0i64;
    }
  }
  else
  {
    if ( v6 != &off_5F148 && _bittest((const signed __int32 *)v6 + 43, 0x13u) && *((_BYTE *)v6 + 169) >= 2u )
      sub_11008((__int64)v6[19], 0x11Eu, (__int64)&unk_4DBF8);
    result = 258i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;
// 62070: using guessed type __int64 qword_62070;

//----- (0000000000033F40) ----------------------------------------------------
__int64 __fastcall sub_33F40(__int64 a1, _QWORD *a2, unsigned int *a3)
{
  unsigned int v6; // ebx
  void **v7; // rcx
  int v8; // eax
  char v9; // di
  void **v10; // rcx
  PVOID v11; // rax
  int v12; // eax

  v6 = 0;
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 0x13u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x122u, (__int64)&unk_4DBF8);
    v7 = (void **)off_5F148;
  }
  if ( a2 && a3 )
  {
    *a2 = 0i64;
    *a3 = 0;
    if ( !qword_62070 )
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 43, 0x13u)
        && *((_BYTE *)off_5F148 + 169) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x124u, (__int64)&unk_4DBF8);
        v7 = (void **)off_5F148;
      }
      v6 = 258;
      goto LABEL_74;
    }
    v8 = (*(__int64 (__fastcall **)(__int64, _QWORD, unsigned int *))qword_62070)(a1, 0i64, a3);
    if ( v8 && v8 != 1800 )
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 43, 0x13u)
        && *((_BYTE *)off_5F148 + 169) >= 2u )
      {
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x125u, (__int64)&unk_4DBF8, v8);
        v7 = (void **)off_5F148;
      }
      v6 = 276;
      goto LABEL_74;
    }
    v9 = (*(__int64 (__fastcall **)(__int64))(qword_62070 + 8))(a1);
    if ( (v9 & 1) != 0 )
    {
      v10 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148
        || !_bittest((const signed __int32 *)off_5F148 + 43, 0x13u)
        || *((_BYTE *)off_5F148 + 169) < 5u )
      {
        goto LABEL_26;
      }
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x126u, (__int64)&unk_4DBF8);
    }
    v10 = (void **)off_5F148;
LABEL_26:
    if ( (v9 & 2) != 0
      && v10 != &off_5F148
      && _bittest((const signed __int32 *)v10 + 43, 0x13u)
      && *((_BYTE *)v10 + 169) >= 5u )
    {
      sub_11008((__int64)v10[19], 0x127u, (__int64)&unk_4DBF8);
      v10 = (void **)off_5F148;
    }
    if ( (v9 & 4) != 0
      && v10 != &off_5F148
      && _bittest((const signed __int32 *)v10 + 43, 0x13u)
      && *((_BYTE *)v10 + 169) >= 5u )
    {
      sub_11008((__int64)v10[19], 0x128u, (__int64)&unk_4DBF8);
      v10 = (void **)off_5F148;
    }
    if ( (v9 & 8) != 0
      && v10 != &off_5F148
      && _bittest((const signed __int32 *)v10 + 43, 0x13u)
      && *((_BYTE *)v10 + 169) >= 5u )
    {
      sub_11008((__int64)v10[19], 0x129u, (__int64)&unk_4DBF8);
      v10 = (void **)off_5F148;
    }
    if ( (v9 & 0x10) != 0
      && v10 != &off_5F148
      && _bittest((const signed __int32 *)v10 + 43, 0x13u)
      && *((_BYTE *)v10 + 169) >= 5u )
    {
      sub_11008((__int64)v10[19], 0x12Au, (__int64)&unk_4DBF8);
      v10 = (void **)off_5F148;
    }
    if ( (v9 & 0x20) != 0
      && v10 != &off_5F148
      && _bittest((const signed __int32 *)v10 + 43, 0x13u)
      && *((_BYTE *)v10 + 169) >= 5u )
    {
      sub_11008((__int64)v10[19], 0x12Bu, (__int64)&unk_4DBF8);
      v10 = (void **)off_5F148;
    }
    if ( (v9 & 0x40) != 0
      && v10 != &off_5F148
      && _bittest((const signed __int32 *)v10 + 43, 0x13u)
      && *((_BYTE *)v10 + 169) >= 5u )
    {
      sub_11008((__int64)v10[19], 0x12Cu, (__int64)&unk_4DBF8);
    }
    v11 = sub_26404(1, *a3, 0x666E4950u);
    *a2 = v11;
    if ( v11 )
    {
      memset(v11, 0, *a3);
      v12 = (*(__int64 (__fastcall **)(__int64, _QWORD, unsigned int *))qword_62070)(a1, *a2, a3);
      if ( v12 )
      {
        v7 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148
          && _bittest((const signed __int32 *)off_5F148 + 43, 0x13u)
          && *((_BYTE *)off_5F148 + 169) >= 2u )
        {
          sub_1102C(*((_QWORD *)off_5F148 + 19), 0x12Eu, (__int64)&unk_4DBF8, v12);
          v7 = (void **)off_5F148;
        }
        v6 = 275;
      }
      else
      {
        v7 = (void **)off_5F148;
      }
    }
    else
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148
        && _bittest((const signed __int32 *)off_5F148 + 43, 0x13u)
        && *((_BYTE *)off_5F148 + 169) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x12Du, (__int64)&unk_4DBF8);
        v7 = (void **)off_5F148;
      }
      v6 = 3;
    }
    goto LABEL_74;
  }
  if ( v7 != &off_5F148 && _bittest((const signed __int32 *)v7 + 43, 0x13u) && *((_BYTE *)v7 + 169) >= 2u )
  {
    sub_143A4((__int64)v7[19], 0x123u, (__int64)&unk_4DBF8, a2, a3);
    v7 = (void **)off_5F148;
  }
  v6 = 4;
LABEL_74:
  if ( v7 != &off_5F148 && _bittest((const signed __int32 *)v7 + 43, 0x13u) && *((_BYTE *)v7 + 169) >= 5u )
    sub_1102C((__int64)v7[19], 0x12Fu, (__int64)&unk_4DBF8, v6);
  return v6;
}
// 5F148: using guessed type void *off_5F148;
// 62070: using guessed type __int64 qword_62070;

//----- (0000000000034384) ----------------------------------------------------
__int64 __fastcall sub_34384(PVOID *a1)
{
  unsigned int v2; // ebx
  void **v3; // rcx

  v2 = 0;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 0x13u)
    && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x130u, (__int64)&unk_4DBF8);
    v3 = (void **)off_5F148;
  }
  if ( a1 && *a1 )
  {
    sub_26488(*a1, 0x666E4950u);
    *a1 = 0i64;
    v3 = (void **)off_5F148;
  }
  else
  {
    if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 43, 0x13u) && *((_BYTE *)v3 + 169) >= 2u )
    {
      sub_17984((__int64)v3[19], 0x131u, (__int64)&unk_4DBF8, a1);
      v3 = (void **)off_5F148;
    }
    v2 = 4;
  }
  if ( v3 != &off_5F148 && _bittest((const signed __int32 *)v3 + 43, 0x13u) && *((_BYTE *)v3 + 169) >= 5u )
    sub_1102C((__int64)v3[19], 0x132u, (__int64)&unk_4DBF8, v2);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000034494) ----------------------------------------------------
const char *__fastcall sub_34494(int a1)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx

  if ( a1 <= 106 )
  {
    if ( a1 == 106 )
      return "RULE_SYS_SFBOOT_NON_SFBOOT_SET";
    if ( !a1 )
      return "UNK";
    v1 = a1 - 2;
    if ( !v1 )
      return "STATEFUL_CACHE_RULE";
    v2 = v1 - 1;
    if ( !v2 )
      return "STATEFUL_CACHE_TERM";
    v3 = v2 - 98;
    if ( !v3 )
      return "RULE_APP";
    v4 = v3 - 1;
    if ( !v4 )
      return "RULE_SYS";
    v5 = v4 - 1;
    if ( !v5 )
      return "RULE_APP_SFBOOT";
    v6 = v5 - 1;
    if ( !v6 )
      return "RULE_SYS_SFBOOT";
    if ( v6 == 1 )
      return "RULE_APP_SFBOOT_NON_SFBOOT_SET";
    return "UNKNOWN";
  }
  v8 = a1 - 107;
  if ( !v8 )
    return "RULE_SYS_NO_HASH_SET";
  v9 = v8 - 94;
  if ( !v9 )
    return "TERM_NONE";
  v10 = v9 - 1;
  if ( !v10 )
    return "TERM_NO_PID";
  v11 = v10 - 1;
  if ( !v11 )
    return "TERM_PID";
  v12 = v11 - 1;
  if ( !v12 )
    return "TERM_DIRECTION";
  v13 = v12 - 1;
  if ( !v13 )
    return "TERM_NO_FULL_MATCH";
  v14 = v13 - 96;
  if ( !v14 )
    return "USER_RESPONSE";
  if ( v14 != 1 )
    return "UNKNOWN";
  return "ISOLATION";
}

//----- (0000000000034580) ----------------------------------------------------
const char *__fastcall sub_34580(int a1)
{
  const char *result; // rax

  if ( !(_WORD)a1 )
    return "UNKNOWN";
  switch ( (unsigned __int16)a1 )
  {
    case 1u:
      return "W_ALLOW";
    case 2u:
      return "W_DENY";
    case 3u:
      return "S_ALLOW";
  }
  if ( (unsigned __int16)a1 != 4 )
  {
    if ( (unsigned __int16)a1 == 5 )
      return "NOT_PROCESSED";
    return "UNKNOWN";
  }
  if ( _bittest(&a1, 0x1Eu) )
    result = "S_DENY_PENDING";
  else
    result = "S_DENY";
  return result;
}

//----- (00000000000345E4) ----------------------------------------------------
const char *__fastcall sub_345E4(int a1)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx

  v1 = a1 - 1;
  if ( !v1 )
    return "NOT_COMPARABLE";
  v2 = v1 - 1;
  if ( !v2 )
    return "INCOMPATIBLE";
  v3 = v2 - 1;
  if ( !v3 )
    return "INCLUDED";
  v4 = v3 - 1;
  if ( !v4 )
    return "NOT_INCLUDED";
  v5 = v4 - 1;
  if ( !v5 )
    return "LESSER";
  v6 = v5 - 1;
  if ( !v6 )
    return "GREATER";
  v7 = v6 - 1;
  if ( !v7 )
    return "EQUAL";
  if ( v7 == 1 )
    return "NOT_EQUAL";
  return "NO STRING FOR THIS VALUE";
}

//----- (0000000000034658) ----------------------------------------------------
const char *__fastcall sub_34658(unsigned int a1)
{
  switch ( a1 )
  {
    case 0u:
      return "UNKNOWN";
    case 1u:
      return "ICMP";
    case 6u:
      return "TCP";
    case 0x11u:
      return "UDP";
    case 0x3Au:
      return "ICMPV6";
  }
  sub_4B484(byte_5F3F8, 4ui64, "%d", a1);
  return byte_5F3F8;
}

//----- (00000000000346D0) ----------------------------------------------------
const char *__fastcall sub_346D0(int a1)
{
  __int64 v1; // r9
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx

  v1 = (unsigned int)a1;
  if ( a1 <= 5 )
  {
    switch ( a1 )
    {
      case 5:
        return "HTTPS";
      case 0:
        return "UNKNOWN";
      case 1:
        return "PENDING";
      case 2:
        return "DNS";
      case 3:
        return "DHCP";
      case 4:
        return "HTTP";
    }
    goto LABEL_19;
  }
  v3 = a1 - 7;
  if ( !v3 )
    return "SMTP";
  v4 = v3 - 1;
  if ( !v4 )
    return "FTP";
  v5 = v4 - 1;
  if ( !v5 )
    return "POP3";
  v6 = v5 - 1;
  if ( !v6 )
    return "PAP";
  if ( v6 != 1 )
  {
LABEL_19:
    sub_4B484(byte_5F3F0, 4ui64, "%d", v1);
    return byte_5F3F0;
  }
  return "DHCPV6";
}

//----- (00000000000347A8) ----------------------------------------------------
const char *__fastcall sub_347A8(int a1)
{
  int v1; // ecx

  v1 = a1 - 1;
  if ( !v1 )
    return "INCOMING";
  if ( v1 == 1 )
    return "OUTGOING";
  return "UNKNOWN";
}

//----- (00000000000347D0) ----------------------------------------------------
__int64 __fastcall sub_347D0(__int64 a1, const void *a2, size_t a3)
{
  void **v6; // rcx
  _DWORD *v7; // rdx
  int v8; // eax
  size_t v9; // rdx

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x40) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x23u, (__int64)&unk_4DBE8);
    v6 = (void **)off_5F148;
  }
  v7 = *(_DWORD **)(a1 + 132);
  if ( !v7 || (v8 = *(_DWORD *)(a1 + 140)) == 0 )
  {
    if ( v6 == &off_5F148 )
      return 0i64;
    if ( (*((_BYTE *)v6 + 172) & 0x40) == 0 || *((_BYTE *)v6 + 169) < 4u )
    {
LABEL_19:
      if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 0x40) != 0 && *((_BYTE *)v6 + 169) >= 5u )
        sub_11008((__int64)v6[19], 0x26u, (__int64)&unk_4DBE8);
      return 0i64;
    }
    sub_11008((__int64)v6[19], 0x25u, (__int64)&unk_4DBE8);
LABEL_18:
    v6 = (void **)off_5F148;
    goto LABEL_19;
  }
  v9 = (unsigned int)(v8 - *v7);
  if ( v9 > a3 )
  {
    sub_4B4A8((void *)(**(unsigned int **)(a1 + 132) + *(_QWORD *)(a1 + 132) + 4i64), v9, a2, a3);
    **(_DWORD **)(a1 + 132) += a3;
    goto LABEL_18;
  }
  if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 0x40) != 0 && *((_BYTE *)v6 + 169) >= 2u )
    sub_11008((__int64)v6[19], 0x24u, (__int64)&unk_4DBE8);
  return 10i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000034930) ----------------------------------------------------
__int64 __fastcall sub_34930(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+B8h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DBD8, 44i64, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000349BC) ----------------------------------------------------
__int64 __fastcall sub_349BC(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+D8h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DBD8, a2, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000034A5C) ----------------------------------------------------
__int64 __fastcall sub_34A5C(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+E8h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DBD8, a2, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000034B0C) ----------------------------------------------------
__int64 __fastcall sub_34B0C(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4, _WORD *a5)
{
  __int64 v6; // rcx
  _WORD *v7; // rdi
  bool v8; // zf
  __int64 v9; // rcx
  const wchar_t *v10; // rdi

  if ( a5 && *a5 )
  {
    v6 = -1i64;
    v7 = a5;
    do
    {
      if ( !v6 )
        break;
      v8 = *v7++ == 0;
      --v6;
    }
    while ( !v8 );
  }
  if ( a4 && *a4 )
  {
    v9 = -1i64;
    v10 = a4;
    do
    {
      if ( !v9 )
        break;
      v8 = *v10++ == 0;
      --v9;
    }
    while ( !v8 );
  }
  if ( a4 )
  {
    if ( !*a4 )
      a4 = L"<NULL>";
  }
  else
  {
    a4 = L"NULL";
  }
  return qword_5F3B8(a1, 43i64, &unk_4DBD8, a2, a4);
}
// 4DD60: using guessed type wchar_t aNull_1[7];
// 4DD70: using guessed type wchar_t aNull_2[5];
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000034C0C) ----------------------------------------------------
__int64 __fastcall sub_34C0C(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4)
{
  __int64 v5; // rcx
  const wchar_t *v6; // rdi
  bool v7; // zf

  if ( a4 && *a4 )
  {
    v5 = -1i64;
    v6 = a4;
    do
    {
      if ( !v5 )
        break;
      v7 = *v6++ == 0;
      --v5;
    }
    while ( !v7 );
  }
  if ( a4 )
  {
    if ( !*a4 )
      a4 = L"<NULL>";
  }
  else
  {
    a4 = L"NULL";
  }
  return qword_5F3B8(a1, 43i64, &unk_4DBD8, 158i64, a4);
}
// 4DD60: using guessed type wchar_t aNull_1[7];
// 4DD70: using guessed type wchar_t aNull_2[5];
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000034CB0) ----------------------------------------------------
__int64 __fastcall sub_34CB0(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4)
{
  __int64 v5; // rcx
  const wchar_t *v6; // rdi
  bool v7; // zf

  if ( a4 && *a4 )
  {
    v5 = -1i64;
    v6 = a4;
    do
    {
      if ( !v5 )
        break;
      v7 = *v6++ == 0;
      --v5;
    }
    while ( !v7 );
  }
  if ( a4 )
  {
    if ( !*a4 )
      a4 = L"<NULL>";
  }
  else
  {
    a4 = L"NULL";
  }
  return qword_5F3B8(a1, 43i64, &unk_4DBD8, a2, a4);
}
// 4DD60: using guessed type wchar_t aNull_1[7];
// 4DD70: using guessed type wchar_t aNull_2[5];
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000034D50) ----------------------------------------------------
__int64 __fastcall sub_34D50(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4)
{
  __int64 v5; // rcx
  const wchar_t *v6; // rdi
  bool v7; // zf

  if ( a4 && *a4 )
  {
    v5 = -1i64;
    v6 = a4;
    do
    {
      if ( !v5 )
        break;
      v7 = *v6++ == 0;
      --v5;
    }
    while ( !v7 );
  }
  if ( a4 )
  {
    if ( !*a4 )
      a4 = L"<NULL>";
  }
  else
  {
    a4 = L"NULL";
  }
  return qword_5F3B8(a1, 43i64, &unk_4DBD8, 160i64, a4);
}
// 4DD60: using guessed type wchar_t aNull_1[7];
// 4DD70: using guessed type wchar_t aNull_2[5];
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000034DF4) ----------------------------------------------------
__int64 __fastcall sub_34DF4(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4, const char *a5)
{
  __int64 v7; // rcx
  const wchar_t *v8; // rdi
  bool v9; // zf

  if ( a5 )
    strlen(a5);
  if ( a4 && *a4 )
  {
    v7 = -1i64;
    v8 = a4;
    do
    {
      if ( !v7 )
        break;
      v9 = *v8++ == 0;
      --v7;
    }
    while ( !v9 );
  }
  if ( a4 )
  {
    if ( !*a4 )
      a4 = L"<NULL>";
  }
  else
  {
    a4 = L"NULL";
  }
  return qword_5F3B8(a1, 43i64, &unk_4DBD8, a2, a4);
}
// 4DD60: using guessed type wchar_t aNull_1[7];
// 4DD70: using guessed type wchar_t aNull_2[5];
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000034EC8) ----------------------------------------------------
__int64 __fastcall sub_34EC8(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  char v5; // [rsp+68h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DBD8, 53i64, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000034F10) ----------------------------------------------------
__int64 __fastcall sub_34F10(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+A8h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DBD8, 35i64, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000034F90) ----------------------------------------------------
__int64 sub_34F90(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+88h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, a3, a2, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000034FE8) ----------------------------------------------------
__int64 sub_34FE8()
{
  unsigned int v0; // ebx
  void **v1; // rcx

  v0 = 0;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xAu, (__int64)&unk_4DBD8);
  qword_62078 = sub_26670(1i64, 0x18u, 0x61566547u);
  if ( qword_62078 )
  {
    v1 = (void **)off_5F148;
  }
  else
  {
    v1 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0xBu, (__int64)&unk_4DBD8);
      v1 = (void **)off_5F148;
    }
    v0 = 3;
  }
  if ( v1 != &off_5F148 && (*((_BYTE *)v1 + 172) & 2) != 0 && *((_BYTE *)v1 + 169) >= 5u )
    sub_1102C((__int64)v1[19], 0xCu, (__int64)&unk_4DBD8, v0);
  return v0;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000350EC) ----------------------------------------------------
void sub_350EC()
{
  void **v0; // rcx

  v0 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xDu, (__int64)&unk_4DBD8);
    v0 = (void **)off_5F148;
  }
  if ( qword_62078 )
  {
    sub_26828(qword_62078);
    qword_62078 = 0i64;
LABEL_11:
    v0 = (void **)off_5F148;
    goto LABEL_12;
  }
  if ( v0 == &off_5F148 )
    return;
  if ( (*((_BYTE *)v0 + 172) & 2) != 0 && *((_BYTE *)v0 + 169) >= 5u )
  {
    sub_11008((__int64)v0[19], 0xEu, (__int64)&unk_4DBD8);
    goto LABEL_11;
  }
LABEL_12:
  if ( v0 != &off_5F148 && (*((_BYTE *)v0 + 172) & 2) != 0 && *((_BYTE *)v0 + 169) >= 5u )
    sub_11008((__int64)v0[19], 0xFu, (__int64)&unk_4DBD8);
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000351D0) ----------------------------------------------------
_DWORD *__fastcall sub_351D0(__int64 a1, unsigned int a2, const void *a3, unsigned int a4, unsigned int a5, _DWORD *a6, _DWORD *a7)
{
  _DWORD *result; // rax

  if ( a1 && a4 + a5 <= a2 )
  {
    memmove((void *)(a5 + a1), a3, a4);
    *a6 = a4 + a5;
  }
  result = a7;
  if ( a7 )
    *a7 += a4;
  return result;
}

//----- (0000000000035224) ----------------------------------------------------
const wchar_t *__fastcall sub_35224(int a1)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx

  if ( a1 <= 5 )
  {
    if ( a1 == 5 )
      return L"E_PRL_OPERATOR_BITWISE_AND";
    if ( !a1 )
      return L"E_PRL_OPERATOR_NONE";
    v1 = a1 - 1;
    if ( !v1 )
      return L"E_PRL_OPERATOR_EQUAL";
    v2 = v1 - 1;
    if ( !v2 )
      return L"E_PRL_OPERATOR_NOT_EQUAL";
    v3 = v2 - 1;
    if ( !v3 )
      return L"E_PRL_OPERATOR_IN";
    if ( v3 == 1 )
      return L"E_PRL_OPERATOR_NOT_IN";
    return L"NO_STRING_FOR_THIS_OPERATOR";
  }
  v5 = a1 - 6;
  if ( !v5 )
    return L"E_PRL_OPERATOR_BITWISE_OR";
  v6 = v5 - 1;
  if ( !v6 )
    return L"E_PRL_OPERATOR_AND";
  v7 = v6 - 1;
  if ( !v7 )
    return L"E_PRL_OPERATOR_OR";
  if ( v7 != 1 )
    return L"NO_STRING_FOR_THIS_OPERATOR";
  return L"E_PRL_OPERATOR_ASSIGN";
}
// 4E048: using guessed type wchar_t aEPrlOperatorNo_1[20];
// 4E070: using guessed type wchar_t aEPrlOperatorEq[21];
// 4E0A0: using guessed type wchar_t aEPrlOperatorNo_0[25];
// 4E0D8: using guessed type wchar_t aEPrlOperatorIn[18];
// 4E100: using guessed type wchar_t aEPrlOperatorNo[22];
// 4E130: using guessed type wchar_t aEPrlOperatorBi[27];
// 4E168: using guessed type wchar_t aEPrlOperatorBi_0[26];
// 4E1A0: using guessed type wchar_t aEPrlOperatorAn[19];
// 4E1C8: using guessed type wchar_t aEPrlOperatorOr[18];
// 4E1F0: using guessed type wchar_t aEPrlOperatorAs[22];
// 4E220: using guessed type wchar_t aNoStringForThi_1[28];

//----- (00000000000352B8) ----------------------------------------------------
const wchar_t *__fastcall sub_352B8(int a1)
{
  const wchar_t *result; // rax
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  int v21; // ecx
  int v22; // ecx
  int v23; // ecx
  int v24; // ecx
  int v25; // ecx
  int v26; // ecx
  int v27; // ecx
  int v28; // ecx
  int v29; // ecx
  int v30; // ecx
  int v31; // ecx
  int v32; // ecx
  int v33; // ecx
  int v34; // ecx
  int v35; // ecx
  int v36; // ecx
  int v37; // ecx
  int v38; // ecx
  int v39; // ecx
  int v40; // ecx
  int v41; // ecx
  int v42; // ecx
  int v43; // ecx
  int v44; // ecx
  int v45; // ecx
  int v46; // ecx
  int v47; // ecx
  int v48; // ecx
  int v49; // ecx
  int v50; // ecx
  int v51; // ecx
  int v52; // ecx
  int v53; // ecx
  int v54; // ecx
  int v55; // ecx
  int v56; // ecx
  int v57; // ecx
  int v58; // ecx
  int v59; // ecx
  int v60; // ecx
  int v61; // ecx
  int v62; // ecx
  int v63; // ecx
  int v64; // ecx
  int v65; // ecx
  int v66; // ecx
  int v67; // ecx
  int v68; // ecx
  int v69; // ecx
  int v70; // ecx
  int v71; // ecx
  int v72; // ecx
  int v73; // ecx
  int v74; // ecx
  int v75; // ecx
  int v76; // ecx
  int v77; // ecx
  int v78; // ecx
  int v79; // ecx
  int v80; // ecx
  int v81; // ecx
  int v82; // ecx
  int v83; // ecx
  int v84; // ecx
  int v85; // ecx
  int v86; // ecx
  int v87; // ecx
  int v88; // ecx
  int v89; // ecx
  int v90; // ecx
  int v91; // ecx
  int v92; // ecx
  int v93; // ecx
  int v94; // ecx
  int v95; // ecx
  int v96; // ecx
  int v97; // ecx
  int v98; // ecx
  int v99; // ecx
  int v100; // ecx
  int v101; // ecx
  int v102; // ecx
  int v103; // ecx
  int v104; // ecx
  int v105; // ecx
  int v106; // ecx
  int v107; // ecx
  int v108; // ecx
  int v109; // ecx
  int v110; // ecx
  int v111; // ecx
  int v112; // ecx
  int v113; // ecx
  int v114; // ecx
  int v115; // ecx
  int v116; // ecx
  int v117; // ecx
  int v118; // ecx
  int v119; // ecx
  int v120; // ecx
  int v121; // ecx
  int v122; // ecx
  int v123; // ecx
  int v124; // ecx
  int v125; // ecx
  int v126; // ecx
  int v127; // ecx
  int v128; // ecx
  int v129; // ecx
  int v130; // ecx
  int v131; // ecx
  int v132; // ecx
  int v133; // ecx
  int v134; // ecx
  int v135; // ecx
  int v136; // ecx
  int v137; // ecx
  int v138; // ecx
  int v139; // ecx
  int v140; // ecx
  int v141; // ecx
  int v142; // ecx
  int v143; // ecx
  int v144; // ecx
  int v145; // ecx
  int v146; // ecx
  int v147; // ecx
  int v148; // ecx
  int v149; // ecx
  int v150; // ecx
  int v151; // ecx
  int v152; // ecx
  int v153; // ecx
  int v154; // ecx
  int v155; // ecx
  int v156; // ecx
  int v157; // ecx
  int v158; // ecx
  int v159; // ecx
  int v160; // ecx
  int v161; // ecx
  int v162; // ecx
  int v163; // ecx
  int v164; // ecx
  int v165; // ecx
  int v166; // ecx
  int v167; // ecx
  int v168; // ecx
  int v169; // ecx

  if ( a1 <= 256 )
  {
    if ( a1 == 256 )
      return L"E_PRL_FIELD_IP_PROTOCOL";
    if ( a1 > 18 )
    {
      if ( a1 > 28 )
      {
        v18 = a1 - 29;
        if ( !v18 )
          return L"E_PRL_FIELD_DESTINATION_IP";
        v19 = v18 - 1;
        if ( !v19 )
          return L"E_PRL_FIELD_SOURCE_PORT";
        v20 = v19 - 1;
        if ( !v20 )
          return L"E_PRL_FIELD_DESTINATION_PORT";
        v21 = v20 - 1;
        if ( !v21 )
          return L"E_PRL_FIELD_SOURCE_MAC";
        v22 = v21 - 1;
        if ( !v22 )
          return L"E_PRL_FIELD_DESTINATION_MAC";
        v23 = v22 - 1;
        if ( !v23 )
          return L"E_PRL_FIELD_USER_PROFILE";
        v24 = v23 - 12;
        if ( !v24 )
          return L"E_PRL_FIELD_SOURCE_IP_V6";
        if ( v24 == 1 )
          return L"E_PRL_FIELD_DESTINATION_IPV6";
      }
      else
      {
        if ( a1 == 28 )
          return L"E_PRL_FIELD_SOURCE_IP";
        v10 = a1 - 19;
        if ( !v10 )
          return L"E_PRL_FIELD_BUFFERSIZE";
        v11 = v10 - 1;
        if ( !v11 )
          return L"E_PRL_FIELD_FILEOFFSET";
        v12 = v11 - 1;
        if ( !v12 )
          return L"E_PRL_FIELD_DISPOSITION";
        v13 = v12 - 1;
        if ( !v13 )
          return L"E_PRL_FIELD_PRLTEXT";
        v14 = v13 - 1;
        if ( !v14 )
          return L"E_PRL_FIELD_SAFEBOOT";
        v15 = v14 - 1;
        if ( !v15 )
          return L"E_PRL_FIELD_OPTIONS";
        v16 = v15 - 1;
        if ( !v16 )
          return L"E_PRL_FIELD_CREATE_MODE";
        v17 = v16 - 1;
        if ( !v17 )
          return L"E_PRL_FIELD_CREATE_OPTIONS";
        if ( v17 == 1 )
          return L"E_PRL_FIELD_ALLOCATION_SIZE";
      }
    }
    else
    {
      if ( a1 == 18 )
        return L"E_PRL_FIELD_BUFFER";
      if ( a1 > 8 )
      {
        v2 = a1 - 9;
        if ( !v2 )
          return L"E_PRL_FIELD_SRC_TID";
        v3 = v2 - 1;
        if ( !v3 )
          return L"E_PRL_FIELD_USER_SID";
        v4 = v3 - 1;
        if ( !v4 )
          return L"E_PRL_FIELD_SHARE_MODE";
        v5 = v4 - 1;
        if ( !v5 )
          return L"E_PRL_FIELD_ATTRIBUTES";
        v6 = v5 - 1;
        if ( !v6 )
          return L"E_PRL_FIELD_SHOWWINDOW";
        v7 = v6 - 1;
        if ( !v7 )
          return L"E_PRL_FIELD_COMMANDLINE";
        v8 = v7 - 1;
        if ( !v8 )
          return L"E_PRL_FIELD_TRANSACTION_ID";
        v9 = v8 - 1;
        if ( !v9 )
          return L"E_PRL_FIELD_EXTENSION";
        if ( v9 == 1 )
          return L"E_PRL_FIELD_ACCESS_MODE";
      }
      else
      {
        switch ( a1 )
        {
          case 8:
            return L"E_PRL_FIELD_TID";
          case -1:
            return L"Type unknown";
          case 0:
            return L"E_PRL_FIELD_UNKNOWN";
          case 1:
            return L"E_PRL_FIELD_PATH";
          case 2:
            return L"E_PRL_FIELD_SRC_PATH";
          case 3:
            return L"E_PRL_FIELD_PATH_HASH";
          case 4:
            return L"E_PRL_FIELD_APP_NAME";
          case 5:
            return L"E_PRL_FIELD_APP_NAME_HASH";
          case 6:
            return L"E_PRL_FIELD_PID";
          case 7:
            return L"E_PRL_FIELD_SRC_PID";
        }
      }
    }
    return L"NO_STRING_FOR_THIS_FIELD";
  }
  if ( a1 > 768 )
  {
    if ( a1 <= 1024 )
    {
      if ( a1 == 1024 )
        return L"E_PRL_FIELD_HEADER";
      if ( a1 > 775 )
      {
        v37 = a1 - 776;
        if ( !v37 )
          return L"E_PRL_FIELD_ACTION_UNGROUP";
        v38 = v37 - 1;
        if ( !v38 )
          return L"E_PRL_FIELD_ACTION_ACTIVATE";
        v39 = v38 - 1;
        if ( !v39 )
          return L"E_PRL_FIELD_ACTION_DEACTIVATE";
        v40 = v39 - 1;
        if ( !v40 )
          return L"E_PRL_FIELD_ACTION_DROP";
        if ( v40 == 1 )
          return L"E_PRL_FIELD_ACTION_ASK";
      }
      else
      {
        if ( a1 == 775 )
          return L"E_PRL_FIELD_ACTION_GROUP";
        v32 = a1 - 769;
        if ( !v32 )
          return L"E_PRL_FIELD_ACTION_ALLOW";
        v33 = v32 - 1;
        if ( !v33 )
          return L"E_PRL_FIELD_ACTION_DENY";
        v34 = v33 - 1;
        if ( !v34 )
          return L"E_PRL_FIELD_ACTION_NOTIFY";
        v35 = v34 - 1;
        if ( !v35 )
          return L"E_PRL_FIELD_ACTION_SEND";
        v36 = v35 - 1;
        if ( !v36 )
          return L"E_PRL_FIELD_ACTION_CALL";
        if ( v36 == 1 )
          return L"E_PRL_FIELD_ACTION_REPORT";
      }
      return L"NO_STRING_FOR_THIS_FIELD";
    }
    if ( a1 > 51342 )
    {
      if ( a1 > 51400 )
      {
        if ( a1 <= 55309 )
        {
          if ( a1 == 55309 )
            return L"E_PRL_FIELD_ICMPV6_CODE_PARAMETER_PROBLEM_UNRECOGNIZED_IPV6_OPTION_ENCOUNTERED";
          if ( a1 > 53269 )
          {
            if ( a1 > 55296 )
            {
              if ( a1 > 55303 )
              {
                v147 = a1 - 55304;
                if ( !v147 )
                  return L"E_PRL_FIELD_ICMPV6_CODE_DESTINATION_UNREACHABLE_ERROR_IN_SOURCE_ROUTING_HEADER";
                v148 = v147 - 1;
                if ( !v148 )
                  return L"E_PRL_FIELD_ICMPV6_CODE_TIME_EXCEEDED_HOP_LIMIT_EXCEEDED_IN_TRANSIT";
                v149 = v148 - 1;
                if ( !v149 )
                  return L"E_PRL_FIELD_ICMPV6_CODE_TIME_EXCEEDED_FRAGMENT_REASSEMBLY_TIME_EXCEEDED";
                v150 = v149 - 1;
                if ( !v150 )
                  return L"E_PRL_FIELD_ICMPV6_CODE_PARAMETER_PROBLEM_ERRONEOUS_HEADER_FIELD_ENCOUNTERED";
                if ( v150 == 1 )
                  return L"E_PRL_FIELD_ICMPV6_CODE_PARAMETER_PROBLEM_UNRECOGNIZED_NEXT_HEADER_TYPE_ENCOUNTERED";
              }
              else
              {
                if ( a1 == 55303 )
                  return L"E_PRL_FIELD_ICMPV6_CODE_DESTINATION_UNREACHABLE_REJECT_ROUTE_TO_DESTINATION";
                v142 = a1 - 55297;
                if ( !v142 )
                  return L"E_PRL_FIELD_ICMPV6_CODE_DESTINATION_UNREACHABLE_NO_ROUTE_TO_DESTINATION";
                v143 = v142 - 1;
                if ( !v143 )
                  return L"E_PRL_FIELD_ICMPV6_CODE_DESTINATION_UNREACHABLE_COMMUNICATION_WITH_DESTINATION_ADMINISTRATIVELY_PROHIBITED";
                v144 = v143 - 1;
                if ( !v144 )
                  return L"E_PRL_FIELD_ICMPV6_CODE_DESTINATION_UNREACHABLE_BEYOND_SCOPE_OF_SOURCE_ADDRESS";
                v145 = v144 - 1;
                if ( !v145 )
                  return L"E_PRL_FIELD_ICMPV6_CODE_DESTINATION_UNREACHABLE_ADDRESS_UNREACHABLE";
                v146 = v145 - 1;
                if ( !v146 )
                  return L"E_PRL_FIELD_ICMPV6_CODE_DESTINATION_UNREACHABLE_PORT_UNREACHABLE";
                if ( v146 == 1 )
                  return L"E_PRL_FIELD_ICMPV6_CODE_DESTINATION_UNREACHABLE_SOURCE_ADDRESS_FAILED_INGRESS_EGRESS_POLICY";
              }
            }
            else
            {
              if ( a1 == 55296 )
                return L"E_PRL_FIELD_ICMPV6_CODE";
              if ( a1 > 53276 )
              {
                v137 = a1 - 53277;
                if ( !v137 )
                  return L"E_PRL_FIELD_ICMP_CODE_PHOTURIS_BAD_SPI";
                v138 = v137 - 1;
                if ( !v138 )
                  return L"E_PRL_FIELD_ICMP_CODE_PHOTURIS_AUTHENTICATION_FAILED";
                v139 = v138 - 1;
                if ( !v139 )
                  return L"E_PRL_FIELD_ICMP_CODE_PHOTURIS_DECOMPRESSION_FAILED";
                v140 = v139 - 1;
                if ( !v140 )
                  return L"E_PRL_FIELD_ICMP_CODE_PHOTURIS_DECRYPTION_FAILED";
                v141 = v140 - 1;
                if ( !v141 )
                  return L"E_PRL_FIELD_ICMP_CODE_PHOTURIS_NEED_AUTHENTICATION";
                if ( v141 == 1 )
                  return L"E_PRL_FIELD_ICMP_CODE_PHOTURIS_NEED_AUTHORIZATION";
              }
              else
              {
                if ( a1 == 53276 )
                  return L"E_PRL_FIELD_ICMP_CODE_PARAMETER_PROBLEM_BAD_LENGTH";
                v132 = a1 - 53270;
                if ( !v132 )
                  return L"E_PRL_FIELD_ICMP_CODE_ROUTER_ADVERTISEMENT_NORMAL";
                v133 = v132 - 1;
                if ( !v133 )
                  return L"E_PRL_FIELD_ICMP_CODE_ROUTER_ADVERTISEMENT_NOT_COMMON_TRAFFIC";
                v134 = v133 - 1;
                if ( !v134 )
                  return L"E_PRL_FIELD_ICMP_CODE_TIME_EXCEEDED_TIME_TO_LIVE";
                v135 = v134 - 1;
                if ( !v135 )
                  return L"E_PRL_FIELD_ICMP_CODE_TIME_EXCEEDED_FRAGMENT_REASSEMBLY";
                v136 = v135 - 1;
                if ( !v136 )
                  return L"E_PRL_FIELD_ICMP_CODE_PARAMETER_PROBLEM_POINTER";
                if ( v136 == 1 )
                  return L"E_PRL_FIELD_ICMP_CODE_PARAMETER_PROBLEM_MISSING_OPTION";
              }
            }
          }
          else
          {
            if ( a1 == 53269 )
              return L"E_PRL_FIELD_ICMP_CODE_ALTERNATE_HOST_ADDR_ADDR_FOR_HOST";
            if ( a1 > 53256 )
            {
              if ( a1 > 53263 )
              {
                v128 = a1 - 53264;
                if ( !v128 )
                  return L"E_PRL_FIELD_ICMP_CODE_DESTINATION_UNREACHABLE_PRECEDENTE_CUTOFF_EFFECT";
                v129 = v128 - 1;
                if ( !v129 )
                  return L"E_PRL_FIELD_ICMP_CODE_REDIRECT_NET";
                v130 = v129 - 1;
                if ( !v130 )
                  return L"E_PRL_FIELD_ICMP_CODE_REDIRECT_HOST";
                v131 = v130 - 1;
                if ( !v131 )
                  return L"E_PRL_FIELD_ICMP_CODE_REDIRECT_TYPE_SERVICE_AND_NET";
                if ( v131 == 1 )
                  return L"E_PRL_FIELD_ICMP_CODE_REDIRECT_TYPE_SERVICE_AND_HOST";
              }
              else
              {
                if ( a1 == 53263 )
                  return L"E_PRL_FIELD_ICMP_CODE_DESTINATION_UNREACHABLE_HOST_PRECEDENTE_VIOLATION";
                v123 = a1 - 53257;
                if ( !v123 )
                  return L"E_PRL_FIELD_ICMP_CODE_DESTINATION_UNREACHABLE_SOURCE_HOST_ISOLATED";
                v124 = v123 - 1;
                if ( !v124 )
                  return L"E_PRL_FIELD_ICMP_CODE_DESTINATION_UNREACHABLE_COMM_WITH_DEST_NET_ADMIN_PROHIBITED";
                v125 = v124 - 1;
                if ( !v125 )
                  return L"E_PRL_FIELD_ICMP_CODE_DESTINATION_UNREACHABLE_COMM_WITH_DEST_HOST_ADMIN_PROHIBITED";
                v126 = v125 - 1;
                if ( !v126 )
                  return L"E_PRL_FIELD_ICMP_CODE_DESTINATION_UNREACHABLE_NET_SERVICE_TYPE";
                v127 = v126 - 1;
                if ( !v127 )
                  return L"E_PRL_FIELD_ICMP_CODE_DESTINATION_UNREACHABLE_HOST_SERVICE_TYPE";
                if ( v127 == 1 )
                  return L"E_PRL_FIELD_ICMP_CODE_DESTINATION_UNREACHABLE_COMM_ADMIN_PROHIBITED";
              }
            }
            else
            {
              if ( a1 == 53256 )
                return L"E_PRL_FIELD_ICMP_CODE_DESTINATION_UNREACHABLE_DEST_HOST_UNKNOWN";
              if ( a1 > 53249 )
              {
                v118 = a1 - 53250;
                if ( !v118 )
                  return L"E_PRL_FIELD_ICMP_CODE_DESTINATION_UNREACHABLE_HOST";
                v119 = v118 - 1;
                if ( !v119 )
                  return L"E_PRL_FIELD_ICMP_CODE_DESTINATION_UNREACHABLE_PROTOCOL";
                v120 = v119 - 1;
                if ( !v120 )
                  return L"E_PRL_FIELD_ICMP_CODE_DESTINATION_UNREACHABLE_PORT";
                v121 = v120 - 1;
                if ( !v121 )
                  return L"E_PRL_FIELD_ICMP_CODE_DESTINATION_UNREACHABLE_FRAGMENTATION_NOT_SET";
                v122 = v121 - 1;
                if ( !v122 )
                  return L"E_PRL_FIELD_ICMP_CODE_DESTINATION_UNREACHABLE_SOURCE_ROUTE_FAILED";
                if ( v122 == 1 )
                  return L"E_PRL_FIELD_ICMP_CODE_DESTINATION_UNREACHABLE_DEST_NET_UNKNOWN";
              }
              else
              {
                if ( a1 == 53249 )
                  return L"E_PRL_FIELD_ICMP_CODE_DESTINATION_UNREACHABLE_NET";
                v113 = a1 - 51401;
                if ( !v113 )
                  return L"E_PRL_FIELD_ICMPV6_TYPE_PRIVATE_EXPERIMENTATION_3";
                v114 = v113 - 1;
                if ( !v114 )
                  return L"E_PRL_FIELD_ICMPV6_TYPE_PRIVATE_EXPERIMENTATION_4";
                v115 = v114 - 1;
                if ( !v115 )
                  return L"E_PRL_FIELD_ICMPV6_TYPE_UNASSIGNED_4_LOWER";
                v116 = v115 - 52;
                if ( !v116 )
                  return L"E_PRL_FIELD_ICMPV6_TYPE_UNASSIGNED_4_UPPER";
                v117 = v116 - 1;
                if ( !v117 )
                  return L"E_PRL_FIELD_ICMPV6_TYPE_RESERVED_FOR_EXPANSION_OF_ICMPV6_INFORMATIONAL_MESSAGES";
                if ( v117 == 1792 )
                  return L"E_PRL_FIELD_ICMP_CODE";
              }
            }
          }
          return L"NO_STRING_FOR_THIS_FIELD";
        }
        if ( a1 <= 57360 )
        {
          if ( a1 == 57360 )
            return L"E_PRL_FIELD_URL_CAT_FASHION_BEAUTY";
          if ( a1 > 57347 )
          {
            if ( a1 > 57354 )
            {
              v166 = a1 - 57355;
              if ( !v166 )
                return L"E_PRL_FIELD_URL_CAT_CULTS";
              v167 = v166 - 1;
              if ( !v167 )
                return L"E_PRL_FIELD_URL_CAT_CHAT_INSTANTMESSAGING";
              v168 = v167 - 1;
              if ( !v168 )
                return L"E_PRL_FIELD_URL_CAT_DATING_PERSONALS";
              v169 = v168 - 1;
              if ( !v169 )
                return L"E_PRL_FIELD_URL_CAT_DOWNLOAD_SITES";
              if ( v169 == 1 )
                return L"E_PRL_FIELD_URL_CAT_ENTERTAINMENT";
            }
            else
            {
              if ( a1 == 57354 )
                return L"E_PRL_FIELD_URL_CAT_COMPROMISED";
              v161 = a1 - 57348;
              if ( !v161 )
                return L"E_PRL_FIELD_URL_CAT_SPAM";
              v162 = v161 - 1;
              if ( !v162 )
                return L"E_PRL_FIELD_URL_CAT_BOTNETS";
              v163 = v162 - 1;
              if ( !v163 )
                return L"E_PRL_FIELD_URL_CAT_ADVERTISEMENTS";
              v164 = v163 - 1;
              if ( !v164 )
                return L"E_PRL_FIELD_URL_CAT_ALCOHOL_TOBACCO";
              v165 = v164 - 1;
              if ( !v165 )
                return L"E_PRL_FIELD_URL_CAT_ANONYMIZERS";
              if ( v165 == 1 )
                return L"E_PRL_FIELD_URL_CAT_BUSINESS";
            }
          }
          else
          {
            if ( a1 == 57347 )
              return L"E_PRL_FIELD_URL_CAT_PHISHING";
            if ( a1 > 55316 )
            {
              v156 = a1 - 55317;
              if ( !v156 )
                return L"E_PRL_FIELD_ICMPV6_CODE_ICMP_NODE_INFORMATION_RESPONSE_SUCCESS";
              v157 = v156 - 1;
              if ( !v157 )
                return L"E_PRL_FIELD_ICMPV6_CODE_ICMP_NODE_INFORMATION_RESPONSE_REFUSED";
              v158 = v157 - 1;
              if ( !v158 )
                return L"E_PRL_FIELD_ICMPV6_CODE_ICMP_NODE_INFORMATION_RESPONSE_QTYPE_UNKNOWN";
              v159 = v158 - 2025;
              if ( !v159 )
                return L"E_PRL_FIELD_URL_CATEGORY";
              v160 = v159 - 1;
              if ( !v160 )
                return L"E_PRL_FIELD_URL_CAT_UNKNOWN";
              if ( v160 == 1 )
                return L"E_PRL_FIELD_URL_CAT_MALICIOUS";
            }
            else
            {
              if ( a1 == 55316 )
                return L"E_PRL_FIELD_ICMPV6_CODE_ICMP_NODE_INFORMATION_QUERY_IPV4_ADDRESS_SUBJECT";
              v151 = a1 - 55310;
              if ( !v151 )
                return L"E_PRL_FIELD_ICMPV6_CODE_PARAMETER_PROBLEM_IPV6_FIRST_FRAGMENT_HAS_INCOMPLETE_IPV6_HEADER_CHAIN";
              v152 = v151 - 1;
              if ( !v152 )
                return L"E_PRL_FIELD_ICMPV6_CODE_ROUTER_RENUMBERING_COMMAND";
              v153 = v152 - 1;
              if ( !v153 )
                return L"E_PRL_FIELD_ICMPV6_CODE_ROUTER_RENUMBERING_RESULT";
              v154 = v153 - 1;
              if ( !v154 )
                return L"E_PRL_FIELD_ICMPV6_CODE_ROUTER_RENUMBERING_SEQUENCE_NUMBER_RESET";
              v155 = v154 - 1;
              if ( !v155 )
                return L"E_PRL_FIELD_ICMPV6_CODE_ICMP_NODE_INFORMATION_QUERY_IPV6_ADDRESS_SUBJECT";
              if ( v155 == 1 )
                return L"E_PRL_FIELD_ICMPV6_CODE_ICMP_NODE_INFORMATION_QUERY_NAME_SUBJECT_OR_EMPTY";
            }
          }
          return L"NO_STRING_FOR_THIS_FIELD";
        }
        switch ( a1 )
        {
          case 57361:
            result = L"E_PRL_FIELD_URL_CAT_FORUMS_NEWSGROUPS";
            break;
          case 57362:
            result = L"E_PRL_FIELD_URL_CAT_GAMBLING";
            break;
          case 57363:
            result = L"E_PRL_FIELD_URL_CAT_HACKING";
            break;
          case 57364:
            result = L"E_PRL_FIELD_URL_CAT_HEALTH_MEDICINE";
            break;
          case 57365:
            result = L"E_PRL_FIELD_URL_CAT_ILLEGAL";
            break;
          case 57366:
            result = L"E_PRL_FIELD_URL_CAT_ILLEGAL_DRUG";
            break;
          case 57367:
            result = L"E_PRL_FIELD_URL_CAT_IMAGE_SHARING";
            break;
          case 57368:
            result = L"E_PRL_FIELD_URL_CAT_INFORMATION_SECURITY";
            break;
          case 57369:
            result = L"E_PRL_FIELD_URL_CAT_INTERNET_TOOLS";
            break;
          case 57370:
            result = L"E_PRL_FIELD_URL_CAT_JOB_SEARCH";
            break;
          case 57371:
            result = L"E_PRL_FIELD_URL_CAT_NETWORK_ERRORS";
            break;
          case 57372:
            result = L"E_PRL_FIELD_URL_CAT_NEWS";
            break;
          case 57373:
            result = L"E_PRL_FIELD_URL_CAT_OFFENSIVE";
            break;
          case 57374:
            result = L"E_PRL_FIELD_URL_CAT_PARKED_DOMAINS";
            break;
          case 57375:
            result = L"E_PRL_FIELD_URL_CAT_PEER_TO_PEER";
            break;
          case 57376:
            result = L"E_PRL_FIELD_URL_CAT_PERSONAL";
            break;
          case 57377:
            result = L"E_PRL_FIELD_URL_CAT_PORNOGRAPHY_NUDITY";
            break;
          case 57378:
            result = L"E_PRL_FIELD_URL_CAT_PRIVATE_IP_ADDRESSES";
            break;
          case 57379:
            result = L"E_PRL_FIELD_URL_CAT_RELIGION";
            break;
          case 57380:
            result = L"E_PRL_FIELD_URL_CAT_SEX_EDUCATION";
            break;
          case 57381:
            result = L"E_PRL_FIELD_URL_CAT_SHOPPING";
            break;
          case 57382:
            result = L"E_PRL_FIELD_URL_CAT_SOCIETY_EDUCATION";
            break;
          case 57383:
            result = L"E_PRL_FIELD_URL_CAT_STREAMING_DOWNLOADS";
            break;
          case 57384:
            result = L"E_PRL_FIELD_URL_CAT_TECHNOLOGY";
            break;
          case 57385:
            result = L"E_PRL_FIELD_URL_CAT_TRANSPORTATION_TRAVEL";
            break;
          case 57386:
            result = L"E_PRL_FIELD_URL_CAT_WEAPONS";
            break;
          default:
            return L"NO_STRING_FOR_THIS_FIELD";
        }
      }
      else if ( a1 == 51400 )
      {
        result = L"E_PRL_FIELD_ICMPV6_TYPE_UNASSIGNED_3_UPPER";
      }
      else
      {
        switch ( a1 )
        {
          case 51343:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_INVERSE_NEIGHBOR_DISCOVERY_ADVERTISEMENT_MESSAGE";
            break;
          case 51344:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_VERSION_2_MULTICAST_LISTENER_REPORT";
            break;
          case 51345:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_HOME_AGENT_ADDRESS_DISCOVERY_REQUEST_MESSAGE";
            break;
          case 51346:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_HOME_AGENT_ADDRESS_DISCOVERY_REPLY_MESSAGE";
            break;
          case 51347:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_MOBILE_PREFIX_SOLICITATION";
            break;
          case 51348:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_MOBILE_PREFIX_ADVERTISEMENT";
            break;
          case 51349:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_CERTIFICATION_PATH_SOLICITATION_MESSAGE";
            break;
          case 51350:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_CERTIFICATION_PATH_ADVERTISEMENT_MESSAGE";
            break;
          case 51351:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_ICMP_MESSAGES_UTILIZED_BY_EXPERIMENTAL_MOBILITY_PROTOCOLS";
            break;
          case 51352:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_MULTICAST_ROUTER_ADVERTISEMENT";
            break;
          case 51353:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_MULTICAST_ROUTER_SOLICITATION";
            break;
          case 51354:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_MULTICAST_ROUTER_TERMINATION";
            break;
          case 51355:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_FMIPV6_MESSAGES";
            break;
          case 51356:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_RPL_CONTROL_MESSAGE";
            break;
          case 51357:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_ILNPV6_LOCATOR_UPDATE_MESSAGE";
            break;
          case 51358:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_DUPLICATE_ADDRESS_REQUEST";
            break;
          case 51359:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_DUPLICATE_ADDRESS_CONFIRMATION";
            break;
          case 51360:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_UNASSIGNED_3_LOWER";
            break;
          default:
            return L"NO_STRING_FOR_THIS_FIELD";
        }
      }
    }
    else
    {
      if ( a1 == 51342 )
        return L"E_PRL_FIELD_ICMPV6_TYPE_INVERSE_NEIGHBOR_DISCOVERY_SOLICITATION_MESSAGE";
      if ( a1 > 40976 )
      {
        if ( a1 <= 49188 )
        {
          if ( a1 == 49188 )
            return L"E_PRL_FIELD_ICMP_TYPE_MOBILE_REGISTRATION_REQUEST";
          if ( a1 > 49158 )
          {
            if ( a1 > 49167 )
            {
              v95 = a1 - 49170;
              if ( !v95 )
                return L"E_PRL_FIELD_ICMP_TYPE_ADDRESS_MASK_REQUEST";
              v96 = v95 - 1;
              if ( !v96 )
                return L"E_PRL_FIELD_ICMP_TYPE_ADDRESS_MASK_REPLY";
              v97 = v96 - 12;
              if ( !v97 )
                return L"E_PRL_FIELD_ICMP_TYPE_TRACEROUTE";
              v98 = v97 - 1;
              if ( !v98 )
                return L"E_PRL_FIELD_ICMP_TYPE_DATAGRAM_CONVERSION_ERROR";
              v99 = v98 - 1;
              if ( !v99 )
                return L"E_PRL_FIELD_ICMP_TYPE_MOBILE_HOST_REDIRECT";
              v100 = v99 - 1;
              if ( !v100 )
                return L"E_PRL_FIELD_ICMP_TYPE_IPV6_WHERE_ARE_YOU";
              if ( v100 == 1 )
                return L"E_PRL_FIELD_ICMP_TYPE_IPV6_I_AM_HERE";
            }
            else
            {
              if ( a1 == 49167 )
                return L"E_PRL_FIELD_ICMP_TYPE_TIMESTAMP_REPLY";
              v89 = a1 - 49159;
              if ( !v89 )
                return L"E_PRL_FIELD_ICMP_TYPE_ALTERNATE_HOST_ADDR";
              v90 = v89 - 2;
              if ( !v90 )
                return L"E_PRL_FIELD_ICMP_TYPE_ECHO_REQUEST";
              v91 = v90 - 1;
              if ( !v91 )
                return L"E_PRL_FIELD_ICMP_TYPE_ROUTER_ADVERTISEMENT";
              v92 = v91 - 1;
              if ( !v92 )
                return L"E_PRL_FIELD_ICMP_TYPE_ROUTER_SOLICITATION";
              v93 = v92 - 1;
              if ( !v93 )
                return L"E_PRL_FIELD_ICMP_TYPE_TIME_EXCEEDED";
              v94 = v93 - 1;
              if ( !v94 )
                return L"E_PRL_FIELD_ICMP_TYPE_PARAMETER_PROBLEM";
              if ( v94 == 1 )
                return L"E_PRL_FIELD_ICMP_TYPE_TIMESTAMP";
            }
          }
          else
          {
            if ( a1 == 49158 )
              return L"E_PRL_FIELD_ICMP_TYPE_REDIRECT";
            if ( a1 > 40984 )
            {
              v83 = a1 - 45056;
              if ( !v83 )
                return L"E_PRL_FIELD_COMM_DIRECTION";
              v84 = v83 - 1;
              if ( !v84 )
                return L"E_PRL_FIELD_COMM_DIRECTION_INCOMING";
              v85 = v84 - 1;
              if ( !v85 )
                return L"E_PRL_FIELD_COMM_DIRECTION_OUTGOING";
              v86 = v85 - 4094;
              if ( !v86 )
                return L"E_PRL_FIELD_ICMP_TYPE";
              v87 = v86 - 1;
              if ( !v87 )
                return L"E_PRL_FIELD_ICMP_TYPE_ECHO_REPLY";
              v88 = v87 - 3;
              if ( !v88 )
                return L"E_PRL_FIELD_ICMP_TYPE_DESTINATION_UNREACHABLE";
              if ( v88 == 1 )
                return L"E_PRL_FIELD_ICMP_TYPE_SOURCE_QUENCH";
            }
            else
            {
              if ( a1 == 40984 )
                return L"E_PRL_FIELD_OPERATION_MODESUPERSEDE";
              v77 = a1 - 40977;
              if ( !v77 )
                return L"E_PRL_FIELD_OPERATION_WRITE";
              v78 = v77 - 1;
              if ( !v78 )
                return L"E_PRL_FIELD_OPERATION_CLOSE";
              v79 = v78 - 1;
              if ( !v79 )
                return L"E_PRL_FIELD_OPERATION_VOLUMEMOUNT";
              v80 = v79 - 1;
              if ( !v80 )
                return L"E_PRL_FIELD_OPERATION_VOLUMEUNMOUNT";
              v81 = v80 - 1;
              if ( !v81 )
                return L"E_PRL_FIELD_OPERATION_SET_ATTRIBUTES";
              v82 = v81 - 1;
              if ( !v82 )
                return L"E_PRL_FIELD_OPERATION_CREATE";
              if ( v82 == 1 )
                return L"E_PRL_FIELD_OPERATION_MODEOVERWRITE";
            }
          }
          return L"NO_STRING_FOR_THIS_FIELD";
        }
        if ( a1 <= 51303 )
        {
          if ( a1 == 51303 )
            return L"E_PRL_FIELD_ICMPV6_TYPE_UNASSIGNED_2_LOWER";
          if ( a1 > 51202 )
          {
            v107 = a1 - 51203;
            if ( !v107 )
              return L"E_PRL_FIELD_ICMPV6_TYPE_PACKET_TOO_BIG";
            v108 = v107 - 1;
            if ( !v108 )
              return L"E_PRL_FIELD_ICMPV6_TYPE_TIME_EXCEEDED";
            v109 = v108 - 1;
            if ( !v109 )
              return L"E_PRL_FIELD_ICMPV6_TYPE_PARAMETER_PROBLEM";
            v110 = v109 - 1;
            if ( !v110 )
              return L"E_PRL_FIELD_ICMPV6_TYPE_UNASSIGNED_1_LOWER";
            v111 = v110 - 94;
            if ( !v111 )
              return L"E_PRL_FIELD_ICMPV6_TYPE_UNASSIGNED_1_UPPER";
            v112 = v111 - 1;
            if ( !v112 )
              return L"E_PRL_FIELD_ICMPV6_TYPE_PRIVATE_EXPERIMENTATION_1";
            if ( v112 == 1 )
              return L"E_PRL_FIELD_ICMPV6_TYPE_PRIVATE_EXPERIMENTATION_2";
          }
          else
          {
            if ( a1 == 51202 )
              return L"E_PRL_FIELD_ICMPV6_TYPE_DESTINATION_UNREACHABLE";
            v101 = a1 - 49189;
            if ( !v101 )
              return L"E_PRL_FIELD_ICMP_TYPE_MOBILE_REGISTRATION_REPLY";
            v102 = v101 - 1;
            if ( !v102 )
              return L"E_PRL_FIELD_ICMP_TYPE_DOMAIN_NAME_REQUEST";
            v103 = v102 - 1;
            if ( !v103 )
              return L"E_PRL_FIELD_ICMP_TYPE_DOMAIN_NAME_REPLY";
            v104 = v103 - 1;
            if ( !v104 )
              return L"E_PRL_FIELD_ICMP_TYPE_SKIP";
            v105 = v104 - 1;
            if ( !v105 )
              return L"E_PRL_FIELD_ICMP_TYPE_PHOTURIS";
            v106 = v105 - 2007;
            if ( !v106 )
              return L"E_PRL_FIELD_ICMPV6_TYPE";
            if ( v106 == 1 )
              return L"E_PRL_FIELD_ICMPV6_TYPE_RESERVED";
          }
          return L"NO_STRING_FOR_THIS_FIELD";
        }
        switch ( a1 )
        {
          case 51327:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_UNASSIGNED_2_UPPER";
            break;
          case 51328:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_RESERVED_FOR_EXPANSION_OF_ICMPV6_ERROR_MESSAGES";
            break;
          case 51329:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_ECHO_REQUEST";
            break;
          case 51330:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_ECHO_REPLY";
            break;
          case 51331:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_MULTICAST_LISTENER_QUERY";
            break;
          case 51332:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_MULTICAST_LISTENER_REPORT";
            break;
          case 51333:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_MULTICAST_LISTENER_DONE";
            break;
          case 51334:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_ROUTER_SOLICITATION";
            break;
          case 51335:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_ROUTER_ADVERTISEMENT";
            break;
          case 51336:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_NEIGHBOR_SOLICITATION";
            break;
          case 51337:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_NEIGHBOR_ADVERTISEMENT";
            break;
          case 51338:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_REDIRECT_MESSAGE";
            break;
          case 51339:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_ROUTER_RENUMBERING";
            break;
          case 51340:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_ICMP_NODE_INFORMATION_QUERY";
            break;
          case 51341:
            result = L"E_PRL_FIELD_ICMPV6_TYPE_ICMP_NODE_INFORMATION_RESPONSE";
            break;
          default:
            return L"NO_STRING_FOR_THIS_FIELD";
        }
      }
      else
      {
        if ( a1 == 40976 )
          return L"E_PRL_FIELD_OPERATION_LOAD";
        if ( a1 <= 1106 )
        {
          if ( a1 == 1106 )
            return L"E_PRL_FIELD_HEADER_STAGE_NORMAL";
          if ( a1 > 1084 )
          {
            if ( a1 > 1092 )
            {
              v59 = a1 - 1093;
              if ( !v59 )
                return L"E_PRL_FIELD_HEADER_CATEGORIES_KERNEL";
              v60 = v59 - 1;
              if ( !v60 )
                return L"E_PRL_FIELD_HEADER_CATEGORIES_PROTEUS";
              v61 = v60 - 1;
              if ( !v61 )
                return L"E_PRL_FIELD_HEADER_CATEGORIES_SECURITY";
              v62 = v61 - 4;
              if ( !v62 )
                return L"E_PRL_FIELD_HEADER_CATEGORIES_FIREWALL_ISOLATION";
              v63 = v62 - 1;
              if ( !v63 )
                return L"E_PRL_FIELD_HEADER_CATEGORIES_FIREWALL_ISOLATION_AUX";
              v64 = v63 - 4;
              if ( !v64 )
                return L"E_PRL_FIELD_HEADER_STAGE";
              if ( v64 == 1 )
                return L"E_PRL_FIELD_HEADER_STAGE_BOOT";
            }
            else
            {
              if ( a1 == 1092 )
                return L"E_PRL_FIELD_HEADER_CATEGORIES_FIREWALL_ADMIN";
              v53 = a1 - 1085;
              if ( !v53 )
                return L"E_PRL_FIELD_HEADER_CATEGORIES_SELFPROTECTION";
              v54 = v53 - 1;
              if ( !v54 )
                return L"E_PRL_FIELD_HEADER_CATEGORIES_KRE";
              v55 = v54 - 1;
              if ( !v55 )
                return L"E_PRL_FIELD_HEADER_CATEGORIES_NETVIRUS";
              v56 = v55 - 1;
              if ( !v56 )
                return L"E_PRL_FIELD_HEADER_CATEGORIES_FIREWALL";
              v57 = v56 - 1;
              if ( !v57 )
                return L"E_PRL_FIELD_HEADER_CATEGORIES_FIREWALL_USER";
              v58 = v57 - 1;
              if ( !v58 )
                return L"E_PRL_FIELD_HEADER_CATEGORIES_FIREWALL_PANDA";
              if ( v58 == 1 )
                return L"E_PRL_FIELD_HEADER_CATEGORIES_FIREWALL_SAFEBOOT";
            }
          }
          else
          {
            if ( a1 == 1084 )
              return L"E_PRL_FIELD_HEADER_CATEGORIES";
            if ( a1 > 1046 )
            {
              v47 = a1 - 1064;
              if ( !v47 )
                return L"E_PRL_FIELD_HEADER_VERSION";
              v48 = v47 - 1;
              if ( !v48 )
                return L"E_PRL_FIELD_HEADER_DESCRIPTION";
              v49 = v48 - 1;
              if ( !v49 )
                return L"E_PRL_FIELD_HEADER_GUID";
              v50 = v49 - 1;
              if ( !v50 )
                return L"E_PRL_FIELD_HEADER_GROUP_ID";
              v51 = v50 - 1;
              if ( !v51 )
                return L"E_PRL_FIELD_HEADER_PRIORITY";
              v52 = v51 - 1;
              if ( !v52 )
                return L"E_PRL_FIELD_HEADER_FOOTPRINT";
              if ( v52 == 1 )
                return L"E_PRL_FIELD_HEADER_SNORT_ID";
            }
            else
            {
              if ( a1 == 1046 )
                return L"E_PRL_FIELD_HEADER_STATE_DISABLED";
              v41 = a1 - 1025;
              if ( !v41 )
                return L"E_PRL_FIELD_HEADER_SEVERITY";
              v42 = v41 - 1;
              if ( !v42 )
                return L"E_PRL_FIELD_HEADER_SEVERITY_CRITICAL";
              v43 = v42 - 1;
              if ( !v43 )
                return L"E_PRL_FIELD_HEADER_SEVERITY_HIGH";
              v44 = v43 - 1;
              if ( !v44 )
                return L"E_PRL_FIELD_HEADER_SEVERITY_MEDIUM";
              v45 = v44 - 1;
              if ( !v45 )
                return L"E_PRL_FIELD_HEADER_SEVERITY_LOW";
              v46 = v45 - 15;
              if ( !v46 )
                return L"E_PRL_FIELD_HEADER_STATE";
              if ( v46 == 1 )
                return L"E_PRL_FIELD_HEADER_STATE_ENABLED";
            }
          }
          return L"NO_STRING_FOR_THIS_FIELD";
        }
        if ( a1 <= 40960 )
        {
          if ( a1 == 40960 )
            return L"E_PRL_FIELD_OPERATION";
          if ( a1 > 36864 )
          {
            v71 = a1 - 36865;
            if ( !v71 )
              return L"E_PRL_FIELD_TARGET_INFO_FILE";
            v72 = v71 - 1;
            if ( !v72 )
              return L"E_PRL_FIELD_TARGET_INFO_REGISTRY";
            v73 = v72 - 1;
            if ( !v73 )
              return L"E_PRL_FIELD_TARGET_INFO_SERVICE";
            v74 = v73 - 1;
            if ( !v74 )
              return L"E_PRL_FIELD_TARGET_INFO_NETWORK_PACKET";
            v75 = v74 - 1;
            if ( !v75 )
              return L"E_PRL_FIELD_TARGET_INFO_PROCESS";
            v76 = v75 - 1;
            if ( !v76 )
              return L"E_PRL_FIELD_TARGET_INFO_THREAD";
            if ( v76 == 1 )
              return L"E_PRL_FIELD_TARGET_INFO_URL";
          }
          else
          {
            if ( a1 == 36864 )
              return L"E_PRL_FIELD_TARGET_INFO";
            v65 = a1 - 1124;
            if ( !v65 )
              return L"E_PRL_FIELD_HEADER_STATEFUL";
            v66 = v65 - 1;
            if ( !v66 )
              return L"E_PRL_FIELD_HEADER_ZONE";
            v67 = v66 - 922;
            if ( !v67 )
              return L"E_PRL_FIELD_ETH_PROTOCOL";
            v68 = v67 - 1;
            if ( !v68 )
              return L"E_PRL_FIELD_ETH_PROTOCOL_IPV4";
            v69 = v68 - 6;
            if ( !v69 )
              return L"E_PRL_FIELD_ETH_PROTOCOL_ARP";
            v70 = v69 - 30767;
            if ( !v70 )
              return L"E_PRL_FIELD_ETH_PROTOCOL_RARP";
            if ( v70 == 1704 )
              return L"E_PRL_FIELD_ETH_PROTOCOL_IPV6";
          }
          return L"NO_STRING_FOR_THIS_FIELD";
        }
        switch ( a1 )
        {
          case 40961:
            result = L"E_PRL_FIELD_OPERATION_NONE";
            break;
          case 40962:
            result = L"E_PRL_FIELD_OPERATION_ALL_OPS";
            break;
          case 40963:
            result = L"E_PRL_FIELD_OPERATION_READ";
            break;
          case 40964:
            result = L"E_PRL_FIELD_OPERATION_OPEN";
            break;
          case 40965:
            result = L"E_PRL_FIELD_OPERATION_RENAME";
            break;
          case 40966:
            result = L"E_PRL_FIELD_OPERATION_MODIFY";
            break;
          case 40967:
            result = L"E_PRL_FIELD_OPERATION_DELETE";
            break;
          case 40968:
            result = L"E_PRL_FIELD_OPERATION_QUERY";
            break;
          case 40969:
            result = L"E_PRL_FIELD_OPERATION_TERMINATE";
            break;
          case 40970:
            result = L"E_PRL_FIELD_OPERATION_END";
            break;
          case 40971:
            result = L"E_PRL_FIELD_OPERATION_SET_ALLOC_SIZE";
            break;
          case 40972:
            result = L"E_PRL_FIELD_OPERATION_CREATE_HARD_LINK";
            break;
          case 40973:
            result = L"E_PRL_FIELD_OPERATION_TRANSACTION_COMMIT";
            break;
          case 40974:
            result = L"E_PRL_FIELD_OPERATION_TRANSACTION_ROLLBACK";
            break;
          case 40975:
            result = L"E_PRL_FIELD_OPERATION_EXECUTE";
            break;
          default:
            return L"NO_STRING_FOR_THIS_FIELD";
        }
      }
    }
  }
  else
  {
    if ( a1 == 768 )
      return L"E_PRL_FIELD_ACTION";
    if ( a1 > 333 )
    {
      if ( a1 > 371 )
      {
        if ( a1 > 512 )
        {
          v25 = a1 - 513;
          if ( !v25 )
            return L"E_PRL_FIELD_AL_PROTOCOL_DNS";
          v26 = v25 - 1;
          if ( !v26 )
            return L"E_PRL_FIELD_AL_PROTOCOL_DHCP";
          v27 = v26 - 1;
          if ( !v27 )
            return L"E_PRL_FIELD_AL_PROTOCOL_HTTP";
          v28 = v27 - 1;
          if ( !v28 )
            return L"E_PRL_FIELD_AL_PROTOCOL_HTTPS";
          v29 = v28 - 1;
          if ( !v29 )
            return L"E_PRL_FIELD_AL_PROTOCOL_SMTP";
          v30 = v29 - 1;
          if ( !v30 )
            return L"E_PRL_FIELD_AL_PROTOCOL_FTP";
          v31 = v30 - 1;
          if ( !v31 )
            return L"E_PRL_FIELD_AL_PROTOCOL_POP3";
          if ( v31 == 1 )
            return L"E_PRL_FIELD_AL_PROTOCOL_DHCPV6";
          return L"NO_STRING_FOR_THIS_FIELD";
        }
        if ( a1 == 512 )
        {
          result = L"E_PRL_FIELD_AL_PROTOCOL";
        }
        else
        {
          switch ( a1 )
          {
            case 372:
              result = L"E_PRL_FIELD_IP_PROTOCOL_L2TP";
              break;
            case 373:
              result = L"E_PRL_FIELD_IP_PROTOCOL_DDX";
              break;
            case 374:
              result = L"E_PRL_FIELD_IP_PROTOCOL_IATP";
              break;
            case 375:
              result = L"E_PRL_FIELD_IP_PROTOCOL_STP";
              break;
            case 376:
              result = L"E_PRL_FIELD_IP_PROTOCOL_SRP";
              break;
            case 377:
              result = L"E_PRL_FIELD_IP_PROTOCOL_UTI";
              break;
            case 378:
              result = L"E_PRL_FIELD_IP_PROTOCOL_SMP";
              break;
            case 379:
              result = L"E_PRL_FIELD_IP_PROTOCOL_SM";
              break;
            case 380:
              result = L"E_PRL_FIELD_IP_PROTOCOL_PTP";
              break;
            case 381:
              result = L"E_PRL_FIELD_IP_PROTOCOL_ISIS_OVER_IPV4";
              break;
            case 382:
              result = L"E_PRL_FIELD_IP_PROTOCOL_FIRE";
              break;
            case 383:
              result = L"E_PRL_FIELD_IP_PROTOCOL_CRTP";
              break;
            case 384:
              result = L"E_PRL_FIELD_IP_PROTOCOL_CRUDP";
              break;
            case 385:
              result = L"E_PRL_FIELD_IP_PROTOCOL_SSCOPMCE";
              break;
            case 386:
              result = L"E_PRL_FIELD_IP_PROTOCOL_IPLT";
              break;
            case 387:
              result = L"E_PRL_FIELD_IP_PROTOCOL_SPS";
              break;
            case 388:
              result = L"E_PRL_FIELD_IP_PROTOCOL_PIPE";
              break;
            case 389:
              result = L"E_PRL_FIELD_IP_PROTOCOL_SCTP";
              break;
            case 390:
              result = L"E_PRL_FIELD_IP_PROTOCOL_FC";
              break;
            case 391:
              result = L"E_PRL_FIELD_IP_PROTOCOL_RSVP_E2E_IGNORE";
              break;
            case 392:
              result = L"E_PRL_FIELD_IP_PROTOCOL_MOBILITY_HEADER";
              break;
            case 393:
              result = L"E_PRL_FIELD_IP_PROTOCOL_UDP_LITE";
              break;
            case 394:
              result = L"E_PRL_FIELD_IP_PROTOCOL_MPLS_IN_IP";
              break;
            case 395:
              result = L"E_PRL_FIELD_IP_PROTOCOL_MANET";
              break;
            case 396:
              result = L"E_PRL_FIELD_IP_PROTOCOL_HIP";
              break;
            case 397:
              result = L"E_PRL_FIELD_IP_PROTOCOL_SHIM6";
              break;
            case 398:
              result = L"E_PRL_FIELD_IP_PROTOCOL_WESP";
              break;
            case 399:
              result = L"E_PRL_FIELD_IP_PROTOCOL_ROHC";
              break;
            default:
              return L"NO_STRING_FOR_THIS_FIELD";
          }
        }
      }
      else if ( a1 == 371 )
      {
        result = L"E_PRL_FIELD_IP_PROTOCOL_PROTOCOL_114";
      }
      else
      {
        switch ( a1 )
        {
          case 334:
            result = L"E_PRL_FIELD_IP_PROTOCOL_SUN_ND";
            break;
          case 335:
            result = L"E_PRL_FIELD_IP_PROTOCOL_WB_MON";
            break;
          case 336:
            result = L"E_PRL_FIELD_IP_PROTOCOL_WB_EXPAK";
            break;
          case 337:
            result = L"E_PRL_FIELD_IP_PROTOCOL_ISO_IP";
            break;
          case 338:
            result = L"E_PRL_FIELD_IP_PROTOCOL_VMTP";
            break;
          case 339:
            result = L"E_PRL_FIELD_IP_PROTOCOL_SECURE_VMTP";
            break;
          case 340:
            result = L"E_PRL_FIELD_IP_PROTOCOL_VINES";
            break;
          case 341:
            result = L"E_PRL_FIELD_IP_PROTOCOL_TTP";
            break;
          case 342:
            result = L"E_PRL_FIELD_IP_PROTOCOL_NSFNET_IGP";
            break;
          case 343:
            result = L"E_PRL_FIELD_IP_PROTOCOL_DGP";
            break;
          case 344:
            result = L"E_PRL_FIELD_IP_PROTOCOL_TCF";
            break;
          case 345:
            result = L"E_PRL_FIELD_IP_PROTOCOL_EIGRP";
            break;
          case 346:
            result = L"E_PRL_FIELD_IP_PROTOCOL_OSPFIGP";
            break;
          case 347:
            result = L"E_PRL_FIELD_IP_PROTOCOL_SPRITE_RPC";
            break;
          case 348:
            result = L"E_PRL_FIELD_IP_PROTOCOL_LARP";
            break;
          case 349:
            result = L"E_PRL_FIELD_IP_PROTOCOL_MTP";
            break;
          case 350:
            result = L"E_PRL_FIELD_IP_PROTOCOL_AX_25";
            break;
          case 351:
            result = L"E_PRL_FIELD_IP_PROTOCOL_IPIP";
            break;
          case 352:
            result = L"E_PRL_FIELD_IP_PROTOCOL_MICP";
            break;
          case 353:
            result = L"E_PRL_FIELD_IP_PROTOCOL_SCC_SP";
            break;
          case 354:
            result = L"E_PRL_FIELD_IP_PROTOCOL_ETHERIP";
            break;
          case 355:
            result = L"E_PRL_FIELD_IP_PROTOCOL_ENCAP";
            break;
          case 356:
            result = L"E_PRL_FIELD_IP_PROTOCOL_PROTOCOL_99";
            break;
          case 357:
            result = L"E_PRL_FIELD_IP_PROTOCOL_GMTP";
            break;
          case 358:
            result = L"E_PRL_FIELD_IP_PROTOCOL_IFMP";
            break;
          case 359:
            result = L"E_PRL_FIELD_IP_PROTOCOL_PNNI";
            break;
          case 360:
            result = L"E_PRL_FIELD_IP_PROTOCOL_PIM";
            break;
          case 361:
            result = L"E_PRL_FIELD_IP_PROTOCOL_ARIS";
            break;
          case 362:
            result = L"E_PRL_FIELD_IP_PROTOCOL_SCPS";
            break;
          case 363:
            result = L"E_PRL_FIELD_IP_PROTOCOL_QNX";
            break;
          case 364:
            result = L"E_PRL_FIELD_IP_PROTOCOL_A_N";
            break;
          case 365:
            result = L"E_PRL_FIELD_IP_PROTOCOL_IP_COMP";
            break;
          case 366:
            result = L"E_PRL_FIELD_IP_PROTOCOL_SNP";
            break;
          case 367:
            result = L"E_PRL_FIELD_IP_PROTOCOL_COMPAQ_PEER";
            break;
          case 368:
            result = L"E_PRL_FIELD_IP_PROTOCOL_IPX_IN_IP";
            break;
          case 369:
            result = L"E_PRL_FIELD_IP_PROTOCOL_VRRP";
            break;
          case 370:
            result = L"E_PRL_FIELD_IP_PROTOCOL_PGM";
            break;
          default:
            return L"NO_STRING_FOR_THIS_FIELD";
        }
      }
    }
    else if ( a1 == 333 )
    {
      result = L"E_PRL_FIELD_IP_PROTOCOL_BR_SAT_MON";
    }
    else
    {
      switch ( a1 )
      {
        case 257:
          result = L"E_PRL_FIELD_IP_PROTOCOL_HOPOPT";
          break;
        case 258:
          result = L"E_PRL_FIELD_IP_PROTOCOL_ICMP";
          break;
        case 259:
          result = L"E_PRL_FIELD_IP_PROTOCOL_IGMP";
          break;
        case 260:
          result = L"E_PRL_FIELD_IP_PROTOCOL_GGP";
          break;
        case 261:
          result = L"E_PRL_FIELD_IP_PROTOCOL_IPV4";
          break;
        case 262:
          result = L"E_PRL_FIELD_IP_PROTOCOL_ST";
          break;
        case 263:
          result = L"E_PRL_FIELD_IP_PROTOCOL_TCP";
          break;
        case 264:
          result = L"E_PRL_FIELD_IP_PROTOCOL_CBT";
          break;
        case 265:
          result = L"E_PRL_FIELD_IP_PROTOCOL_EGP";
          break;
        case 266:
          result = L"E_PRL_FIELD_IP_PROTOCOL_IGP";
          break;
        case 267:
          result = L"E_PRL_FIELD_IP_PROTOCOL_BBN_RCC_MON";
          break;
        case 268:
          result = L"E_PRL_FIELD_IP_PROTOCOL_NVP_II";
          break;
        case 269:
          result = L"E_PRL_FIELD_IP_PROTOCOL_PUP";
          break;
        case 270:
          result = L"E_PRL_FIELD_IP_PROTOCOL_ARGUS";
          break;
        case 271:
          result = L"E_PRL_FIELD_IP_PROTOCOL_EMCON";
          break;
        case 272:
          result = L"E_PRL_FIELD_IP_PROTOCOL_XNET";
          break;
        case 273:
          result = L"E_PRL_FIELD_IP_PROTOCOL_CHAOS";
          break;
        case 274:
          result = L"E_PRL_FIELD_IP_PROTOCOL_UDP";
          break;
        case 275:
          result = L"E_PRL_FIELD_IP_PROTOCOL_MUX";
          break;
        case 276:
          result = L"E_PRL_FIELD_IP_PROTOCOL_DCN_MEAS";
          break;
        case 277:
          result = L"E_PRL_FIELD_IP_PROTOCOL_HMP";
          break;
        case 278:
          result = L"E_PRL_FIELD_IP_PROTOCOL_PRM";
          break;
        case 279:
          result = L"E_PRL_FIELD_IP_PROTOCOL_XNS_IDP";
          break;
        case 280:
          result = L"E_PRL_FIELD_IP_PROTOCOL_TRUNK_1";
          break;
        case 281:
          result = L"E_PRL_FIELD_IP_PROTOCOL_TRUNK_2";
          break;
        case 282:
          result = L"E_PRL_FIELD_IP_PROTOCOL_LEAF_1";
          break;
        case 283:
          result = L"E_PRL_FIELD_IP_PROTOCOL_LEAF_2";
          break;
        case 284:
          result = L"E_PRL_FIELD_IP_PROTOCOL_RDP";
          break;
        case 285:
          result = L"E_PRL_FIELD_IP_PROTOCOL_IRTP";
          break;
        case 286:
          result = L"E_PRL_FIELD_IP_PROTOCOL_ISO_TP4";
          break;
        case 287:
          result = L"E_PRL_FIELD_IP_PROTOCOL_NETBLT";
          break;
        case 288:
          result = L"E_PRL_FIELD_IP_PROTOCOL_MFE_NSP";
          break;
        case 289:
          result = L"E_PRL_FIELD_IP_PROTOCOL_MERIT_INP";
          break;
        case 290:
          result = L"E_PRL_FIELD_IP_PROTOCOL_DCCP";
          break;
        case 291:
          result = L"E_PRL_FIELD_IP_PROTOCOL_3PC";
          break;
        case 292:
          result = L"E_PRL_FIELD_IP_PROTOCOL_IDPR";
          break;
        case 293:
          result = L"E_PRL_FIELD_IP_PROTOCOL_XTP";
          break;
        case 294:
          result = L"E_PRL_FIELD_IP_PROTOCOL_DDP";
          break;
        case 295:
          result = L"E_PRL_FIELD_IP_PROTOCOL_IDPR_CMTP";
          break;
        case 296:
          result = L"E_PRL_FIELD_IP_PROTOCOL_TP_PLUS_PLUS";
          break;
        case 297:
          result = L"E_PRL_FIELD_IP_PROTOCOL_IL";
          break;
        case 298:
          result = L"E_PRL_FIELD_IP_PROTOCOL_IPV6";
          break;
        case 299:
          result = L"E_PRL_FIELD_IP_PROTOCOL_SDRP";
          break;
        case 300:
          result = L"E_PRL_FIELD_IP_PROTOCOL_IPV6_ROUTE";
          break;
        case 301:
          result = L"E_PRL_FIELD_IP_PROTOCOL_IPV6_FRAG";
          break;
        case 302:
          result = L"E_PRL_FIELD_IP_PROTOCOL_IDRP";
          break;
        case 303:
          result = L"E_PRL_FIELD_IP_PROTOCOL_RSVP";
          break;
        case 304:
          result = L"E_PRL_FIELD_IP_PROTOCOL_GRE";
          break;
        case 305:
          result = L"E_PRL_FIELD_IP_PROTOCOL_DSR";
          break;
        case 306:
          result = L"E_PRL_FIELD_IP_PROTOCOL_BNA";
          break;
        case 307:
          result = L"E_PRL_FIELD_IP_PROTOCOL_ESP";
          break;
        case 308:
          result = L"E_PRL_FIELD_IP_PROTOCOL_AH";
          break;
        case 309:
          result = L"E_PRL_FIELD_IP_PROTOCOL_I_NLSP";
          break;
        case 310:
          result = L"E_PRL_FIELD_IP_PROTOCOL_SWIPE";
          break;
        case 311:
          result = L"E_PRL_FIELD_IP_PROTOCOL_NARP";
          break;
        case 312:
          result = L"E_PRL_FIELD_IP_PROTOCOL_MOBILE";
          break;
        case 313:
          result = L"E_PRL_FIELD_IP_PROTOCOL_TLSP";
          break;
        case 314:
          result = L"E_PRL_FIELD_IP_PROTOCOL_SKIP";
          break;
        case 315:
          result = L"E_PRL_FIELD_IP_PROTOCOL_ICMPV6";
          break;
        case 316:
          result = L"E_PRL_FIELD_IP_PROTOCOL_IPV6_NO_NXT";
          break;
        case 317:
          result = L"E_PRL_FIELD_IP_PROTOCOL_IPV6_OPTS";
          break;
        case 318:
          result = L"E_PRL_FIELD_IP_PROTOCOL_PROTOCOL_61";
          break;
        case 319:
          result = L"E_PRL_FIELD_IP_PROTOCOL_CFTP";
          break;
        case 320:
          result = L"E_PRL_FIELD_IP_PROTOCOL_PROTOCOL_63";
          break;
        case 321:
          result = L"E_PRL_FIELD_IP_PROTOCOL_SAT_EXPAK";
          break;
        case 322:
          result = L"E_PRL_FIELD_IP_PROTOCOL_KRYPTOLAN";
          break;
        case 323:
          result = L"E_PRL_FIELD_IP_PROTOCOL_RVD";
          break;
        case 324:
          result = L"E_PRL_FIELD_IP_PROTOCOL_IPPC";
          break;
        case 325:
          result = L"E_PRL_FIELD_IP_PROTOCOL_PROTOCOL_68";
          break;
        case 326:
          result = L"E_PRL_FIELD_IP_PROTOCOL_SAT_MON";
          break;
        case 327:
          result = L"E_PRL_FIELD_IP_PROTOCOL_VISA";
          break;
        case 328:
          result = L"E_PRL_FIELD_IP_PROTOCOL_IPCV";
          break;
        case 329:
          result = L"E_PRL_FIELD_IP_PROTOCOL_CPNX";
          break;
        case 330:
          result = L"E_PRL_FIELD_IP_PROTOCOL_CPHB";
          break;
        case 331:
          result = L"E_PRL_FIELD_IP_PROTOCOL_WSN";
          break;
        case 332:
          result = L"E_PRL_FIELD_IP_PROTOCOL_PVP";
          break;
        default:
          return L"NO_STRING_FOR_THIS_FIELD";
      }
    }
  }
  return result;
}
// 4E258: using guessed type wchar_t aTypeUnknown[13];
// 4E278: using guessed type wchar_t aEPrlFieldUnkno[20];
// 4E2A0: using guessed type wchar_t aEPrlFieldPath[17];
// 4E2C8: using guessed type wchar_t aEPrlFieldSrcPa[21];
// 4E2F8: using guessed type wchar_t aEPrlFieldPathH[22];
// 4E328: using guessed type wchar_t aEPrlFieldAppNa_0[21];
// 4E358: using guessed type wchar_t aEPrlFieldAppNa[26];
// 4E390: using guessed type wchar_t aEPrlFieldPid[16];
// 4E3B0: using guessed type wchar_t aEPrlFieldSrcPi[20];
// 4E3D8: using guessed type wchar_t aEPrlFieldTid[16];
// 4E3F8: using guessed type wchar_t aEPrlFieldSrcTi[20];
// 4E420: using guessed type wchar_t aEPrlFieldUserS[21];
// 4E450: using guessed type wchar_t aEPrlFieldShare[23];
// 4E480: using guessed type wchar_t aEPrlFieldAttri[23];
// 4E4B0: using guessed type wchar_t aEPrlFieldShoww[23];
// 4E4E0: using guessed type wchar_t aEPrlFieldComma[24];
// 4E510: using guessed type wchar_t aEPrlFieldTrans[27];
// 4E548: using guessed type wchar_t aEPrlFieldExten[22];
// 4E578: using guessed type wchar_t aEPrlFieldAcces[24];
// 4E5A8: using guessed type wchar_t aEPrlFieldBuffe[19];
// 4E5D0: using guessed type wchar_t aEPrlFieldBuffe_0[23];
// 4E600: using guessed type wchar_t aEPrlFieldFileo[23];
// 4E630: using guessed type wchar_t aEPrlFieldDispo[24];
// 4E660: using guessed type wchar_t aEPrlFieldPrlte[20];
// 4E688: using guessed type wchar_t aEPrlFieldSafeb[21];
// 4E6B8: using guessed type wchar_t aEPrlFieldOptio[20];
// 4E6E0: using guessed type wchar_t aEPrlFieldCreat_0[24];
// 4E710: using guessed type wchar_t aEPrlFieldCreat[27];
// 4E748: using guessed type wchar_t aEPrlFieldAlloc[28];
// 4E780: using guessed type wchar_t aEPrlFieldSourc[22];
// 4E7B0: using guessed type wchar_t aEPrlFieldDesti_2[27];
// 4E7E8: using guessed type wchar_t aEPrlFieldSourc_0[25];
// 4E820: using guessed type wchar_t aEPrlFieldDesti[29];
// 4E860: using guessed type wchar_t aEPrlFieldSourc_2[24];
// 4E890: using guessed type wchar_t aEPrlFieldDesti_1[29];
// 4E8D0: using guessed type wchar_t aEPrlFieldSourc_1[23];
// 4E900: using guessed type wchar_t aEPrlFieldDesti_0[28];
// 4E938: using guessed type wchar_t aEPrlFieldUserP[25];
// 4E970: using guessed type wchar_t aEPrlFieldIpPro[24];
// 4E9A0: using guessed type wchar_t aEPrlFieldIpPro_0[31];
// 4E9E0: using guessed type wchar_t aEPrlFieldIpPro_1[29];
// 4EA20: using guessed type wchar_t aEPrlFieldIpPro_2[29];
// 4EA60: using guessed type wchar_t aEPrlFieldIpPro_3[28];
// 4EA98: using guessed type wchar_t aEPrlFieldIpPro_4[29];
// 4EAD8: using guessed type wchar_t aEPrlFieldIpPro_5[27];
// 4EB10: using guessed type wchar_t aEPrlFieldIpPro_6[28];
// 4EB48: using guessed type wchar_t aEPrlFieldIpPro_7[28];
// 4EB80: using guessed type wchar_t aEPrlFieldIpPro_8[28];
// 4EBB8: using guessed type wchar_t aEPrlFieldIpPro_9[28];
// 4EBF0: using guessed type wchar_t aEPrlFieldIpPro_10[36];
// 4EC38: using guessed type wchar_t aEPrlFieldIpPro_11[31];
// 4EC78: using guessed type wchar_t aEPrlFieldIpPro_12[28];
// 4ECB0: using guessed type wchar_t aEPrlFieldIpPro_13[30];
// 4ECF0: using guessed type wchar_t aEPrlFieldIpPro_14[30];
// 4ED30: using guessed type wchar_t aEPrlFieldIpPro_15[29];
// 4ED70: using guessed type wchar_t aEPrlFieldIpPro_16[30];
// 4EDB0: using guessed type wchar_t aEPrlFieldIpPro_17[28];
// 4EDE8: using guessed type wchar_t aEPrlFieldIpPro_18[28];
// 4EE20: using guessed type wchar_t aEPrlFieldIpPro_19[33];
// 4EE68: using guessed type wchar_t aEPrlFieldIpPro_20[28];
// 4EEA0: using guessed type wchar_t aEPrlFieldIpPro_21[28];
// 4EEE0: using guessed type wchar_t aEPrlFieldIpPro_22[32];
// 4EF20: using guessed type wchar_t aEPrlFieldIpPro_23[32];
// 4EF60: using guessed type wchar_t aEPrlFieldIpPro_24[32];
// 4EFA0: using guessed type wchar_t aEPrlFieldIpPro_25[31];
// 4EFE0: using guessed type wchar_t aEPrlFieldIpPro_26[31];
// 4F020: using guessed type wchar_t aEPrlFieldIpPro_27[28];
// 4F058: using guessed type wchar_t aEPrlFieldIpPro_28[29];
// 4F0A0: using guessed type wchar_t aEPrlFieldIpPro_29[32];
// 4F0E0: using guessed type wchar_t aEPrlFieldIpPro_30[31];
// 4F120: using guessed type wchar_t aEPrlFieldIpPro_31[32];
// 4F160: using guessed type wchar_t aEPrlFieldIpPro_32[34];
// 4F1A8: using guessed type wchar_t aEPrlFieldIpPro_33[29];
// 4F1E8: using guessed type wchar_t aEPrlFieldIpPro_34[28];
// 4F220: using guessed type wchar_t aEPrlFieldIpPro_35[29];
// 4F260: using guessed type wchar_t aEPrlFieldIpPro_36[28];
// 4F298: using guessed type wchar_t aEPrlFieldIpPro_37[28];
// 4F2D0: using guessed type wchar_t aEPrlFieldIpPro_38[34];
// 4F320: using guessed type wchar_t aEPrlFieldIpPro_39[37];
// 4F370: using guessed type wchar_t aEPrlFieldIpPro_40[27];
// 4F3A8: using guessed type wchar_t aEPrlFieldIpPro_41[29];
// 4F3E8: using guessed type wchar_t aEPrlFieldIpPro_42[29];
// 4F430: using guessed type wchar_t aEPrlFieldIpPro_43[35];
// 4F480: using guessed type wchar_t aEPrlFieldIpPro_44[34];
// 4F4C8: using guessed type wchar_t aEPrlFieldIpPro_45[29];
// 4F508: using guessed type wchar_t aEPrlFieldIpPro_46[29];
// 4F548: using guessed type wchar_t aEPrlFieldIpPro_47[28];
// 4F580: using guessed type wchar_t aEPrlFieldIpPro_48[28];
// 4F5B8: using guessed type wchar_t aEPrlFieldIpPro_49[28];
// 4F5F0: using guessed type wchar_t aEPrlFieldIpPro_50[28];
// 4F628: using guessed type wchar_t aEPrlFieldIpPro_51[27];
// 4F660: using guessed type wchar_t aEPrlFieldIpPro_52[31];
// 4F6A0: using guessed type wchar_t aEPrlFieldIpPro_53[30];
// 4F6E0: using guessed type wchar_t aEPrlFieldIpPro_54[29];
// 4F720: using guessed type wchar_t aEPrlFieldIpPro_55[31];
// 4F760: using guessed type wchar_t aEPrlFieldIpPro_56[29];
// 4F7A0: using guessed type wchar_t aEPrlFieldIpPro_57[29];
// 4F7E0: using guessed type wchar_t aEPrlFieldIpPro_58[31];
// 4F820: using guessed type wchar_t aEPrlFieldIpPro_59[36];
// 4F870: using guessed type wchar_t aEPrlFieldIpPro_60[34];
// 4F8C0: using guessed type wchar_t aEPrlFieldIpPro_61[36];
// 4F908: using guessed type wchar_t aEPrlFieldIpPro_62[29];
// 4F950: using guessed type wchar_t aEPrlFieldIpPro_63[36];
// 4F9A0: using guessed type wchar_t aEPrlFieldIpPro_64[34];
// 4F9F0: using guessed type wchar_t aEPrlFieldIpPro_65[34];
// 4FA38: using guessed type wchar_t aEPrlFieldIpPro_66[28];
// 4FA70: using guessed type wchar_t aEPrlFieldIpPro_67[29];
// 4FAB0: using guessed type wchar_t aEPrlFieldIpPro_68[36];
// 4FB00: using guessed type wchar_t aEPrlFieldIpPro_69[32];
// 4FB40: using guessed type wchar_t aEPrlFieldIpPro_70[29];
// 4FB80: using guessed type wchar_t aEPrlFieldIpPro_71[29];
// 4FBC0: using guessed type wchar_t aEPrlFieldIpPro_72[29];
// 4FC00: using guessed type wchar_t aEPrlFieldIpPro_73[29];
// 4FC40: using guessed type wchar_t aEPrlFieldIpPro_74[28];
// 4FC78: using guessed type wchar_t aEPrlFieldIpPro_75[28];
// 4FCB0: using guessed type wchar_t aEPrlFieldIpPro_76[35];
// 4FCF8: using guessed type wchar_t aEPrlFieldIpPro_77[31];
// 4FD38: using guessed type wchar_t aEPrlFieldIpPro_78[31];
// 4FD80: using guessed type wchar_t aEPrlFieldIpPro_79[33];
// 4FDC8: using guessed type wchar_t aEPrlFieldIpPro_80[31];
// 4FE08: using guessed type wchar_t aEPrlFieldIpPro_81[29];
// 4FE50: using guessed type wchar_t aEPrlFieldIpPro_82[36];
// 4FE98: using guessed type wchar_t aEPrlFieldIpPro_83[30];
// 4FED8: using guessed type wchar_t aEPrlFieldIpPro_84[28];
// 4FF10: using guessed type wchar_t aEPrlFieldIpPro_85[35];
// 4FF58: using guessed type wchar_t aEPrlFieldIpPro_86[28];
// 4FF90: using guessed type wchar_t aEPrlFieldIpPro_87[28];
// 4FFC8: using guessed type wchar_t aEPrlFieldIpPro_88[30];
// 50010: using guessed type wchar_t aEPrlFieldIpPro_89[32];
// 50050: using guessed type wchar_t aEPrlFieldIpPro_90[35];
// 50098: using guessed type wchar_t aEPrlFieldIpPro_91[29];
// 500D8: using guessed type wchar_t aEPrlFieldIpPro_92[28];
// 50110: using guessed type wchar_t aEPrlFieldIpPro_93[30];
// 50150: using guessed type wchar_t aEPrlFieldIpPro_94[29];
// 50190: using guessed type wchar_t aEPrlFieldIpPro_95[29];
// 501D0: using guessed type wchar_t aEPrlFieldIpPro_96[31];
// 50210: using guessed type wchar_t aEPrlFieldIpPro_97[32];
// 50250: using guessed type wchar_t aEPrlFieldIpPro_98[30];
// 50290: using guessed type wchar_t aEPrlFieldIpPro_99[36];
// 502D8: using guessed type wchar_t aEPrlFieldIpPro_100[29];
// 50318: using guessed type wchar_t aEPrlFieldIpPro_101[29];
// 50358: using guessed type wchar_t aEPrlFieldIpPro_102[29];
// 50398: using guessed type wchar_t aEPrlFieldIpPro_103[28];
// 503D0: using guessed type wchar_t aEPrlFieldIpPro_104[29];
// 50410: using guessed type wchar_t aEPrlFieldIpPro_105[29];
// 50450: using guessed type wchar_t aEPrlFieldIpPro_106[28];
// 50488: using guessed type wchar_t aEPrlFieldIpPro_107[28];
// 504C0: using guessed type wchar_t aEPrlFieldIpPro_108[32];
// 50500: using guessed type wchar_t aEPrlFieldIpPro_109[28];
// 50540: using guessed type wchar_t aEPrlFieldIpPro_110[36];
// 50590: using guessed type wchar_t aEPrlFieldIpPro_111[34];
// 505D8: using guessed type wchar_t aEPrlFieldIpPro_112[29];
// 50618: using guessed type wchar_t aEPrlFieldIpPro_113[28];
// 50650: using guessed type wchar_t aEPrlFieldIpPro_114[37];
// 506A0: using guessed type wchar_t aEPrlFieldIpPro_115[29];
// 506E0: using guessed type wchar_t aEPrlFieldIpPro_116[28];
// 50718: using guessed type wchar_t aEPrlFieldIpPro_117[29];
// 50758: using guessed type wchar_t aEPrlFieldIpPro_118[28];
// 50790: using guessed type wchar_t aEPrlFieldIpPro_119[28];
// 507C8: using guessed type wchar_t aEPrlFieldIpPro_120[28];
// 50800: using guessed type wchar_t aEPrlFieldIpPro_121[28];
// 50838: using guessed type wchar_t aEPrlFieldIpPro_122[27];
// 50870: using guessed type wchar_t aEPrlFieldIpPro_123[28];
// 508B0: using guessed type wchar_t aEPrlFieldIpPro_124[39];
// 50900: using guessed type wchar_t aEPrlFieldIpPro_125[29];
// 50940: using guessed type wchar_t aEPrlFieldIpPro_126[29];
// 50980: using guessed type wchar_t aEPrlFieldIpPro_127[30];
// 509C0: using guessed type wchar_t aEPrlFieldIpPro_128[33];
// 50A08: using guessed type wchar_t aEPrlFieldIpPro_129[29];
// 50A48: using guessed type wchar_t aEPrlFieldIpPro_130[28];
// 50A80: using guessed type wchar_t aEPrlFieldIpPro_131[29];
// 50AC0: using guessed type wchar_t aEPrlFieldIpPro_132[29];
// 50B00: using guessed type wchar_t aEPrlFieldIpPro_133[27];
// 50B40: using guessed type wchar_t aEPrlFieldIpPro_134[40];
// 50B90: using guessed type wchar_t aEPrlFieldIpPro_135[40];
// 50BE0: using guessed type wchar_t aEPrlFieldIpPro_136[33];
// 50C30: using guessed type wchar_t aEPrlFieldIpPro_137[35];
// 50C78: using guessed type wchar_t aEPrlFieldIpPro_138[30];
// 50CB8: using guessed type wchar_t aEPrlFieldIpPro_139[28];
// 50CF0: using guessed type wchar_t aEPrlFieldIpPro_140[30];
// 50D30: using guessed type wchar_t aEPrlFieldIpPro_141[29];
// 50D70: using guessed type wchar_t aEPrlFieldIpPro_142[29];
// 50DB0: using guessed type wchar_t aEPrlFieldAlPro[24];
// 50DE0: using guessed type wchar_t aEPrlFieldAlPro_7[28];
// 50E18: using guessed type wchar_t aEPrlFieldAlPro_6[29];
// 50E58: using guessed type wchar_t aEPrlFieldAlPro_5[29];
// 50E98: using guessed type wchar_t aEPrlFieldAlPro_4[30];
// 50ED8: using guessed type wchar_t aEPrlFieldAlPro_3[29];
// 50F18: using guessed type wchar_t aEPrlFieldAlPro_2[28];
// 50F50: using guessed type wchar_t aEPrlFieldAlPro_1[29];
// 50F90: using guessed type wchar_t aEPrlFieldAlPro_0[31];
// 50FD0: using guessed type wchar_t aEPrlFieldActio[19];
// 50FF8: using guessed type wchar_t aEPrlFieldActio_5[25];
// 51030: using guessed type wchar_t aEPrlFieldActio_4[24];
// 51060: using guessed type wchar_t aEPrlFieldActio_3[26];
// 51098: using guessed type wchar_t aEPrlFieldActio_2[24];
// 510C8: using guessed type wchar_t aEPrlFieldActio_1[24];
// 510F8: using guessed type wchar_t aEPrlFieldActio_0[26];
// 51130: using guessed type wchar_t aEPrlFieldActio_6[25];
// 51168: using guessed type wchar_t aEPrlFieldActio_11[27];
// 511A0: using guessed type wchar_t aEPrlFieldActio_10[28];
// 511D8: using guessed type wchar_t aEPrlFieldActio_9[30];
// 51218: using guessed type wchar_t aEPrlFieldActio_8[24];
// 51248: using guessed type wchar_t aEPrlFieldActio_7[23];
// 51278: using guessed type wchar_t aEPrlFieldHeade[19];
// 512A0: using guessed type wchar_t aEPrlFieldHeade_6[28];
// 512E0: using guessed type wchar_t aEPrlFieldHeade_5[37];
// 51330: using guessed type wchar_t aEPrlFieldHeade_4[33];
// 51380: using guessed type wchar_t aEPrlFieldHeade_3[35];
// 513D0: using guessed type wchar_t aEPrlFieldHeade_2[32];
// 51410: using guessed type wchar_t aEPrlFieldHeade_1[25];
// 51450: using guessed type wchar_t aEPrlFieldHeade_0[33];
// 514A0: using guessed type wchar_t aEPrlFieldHeade_7[34];
// 514E8: using guessed type wchar_t aEPrlFieldHeade_14[27];
// 51520: using guessed type wchar_t aEPrlFieldHeade_13[31];
// 51560: using guessed type wchar_t aEPrlFieldHeade_12[24];
// 51590: using guessed type wchar_t aEPrlFieldHeade_11[28];
// 515C8: using guessed type wchar_t aEPrlFieldHeade_10[28];
// 51600: using guessed type wchar_t aEPrlFieldHeade_9[29];
// 51640: using guessed type wchar_t aEPrlFieldHeade_8[28];
// 51678: using guessed type wchar_t aEPrlFieldHeade_15[30];
// 516C0: using guessed type wchar_t aEPrlFieldHeade_22[45];
// 51720: using guessed type wchar_t aEPrlFieldHeade_21[34];
// 51770: using guessed type wchar_t aEPrlFieldHeade_20[39];
// 517C0: using guessed type wchar_t aEPrlFieldHeade_19[39];
// 51810: using guessed type wchar_t aEPrlFieldHeade_27[49];
// 51880: using guessed type wchar_t aEPrlFieldHeade_26[53];
// 518F0: using guessed type wchar_t aEPrlFieldHeade_18[44];
// 51950: using guessed type wchar_t aEPrlFieldHeade_17[45];
// 519B0: using guessed type wchar_t aEPrlFieldHeade_16[48];
// 51A10: using guessed type wchar_t aEPrlFieldHeade_23[45];
// 51A70: using guessed type wchar_t aEPrlFieldHeade_30[37];
// 51AC0: using guessed type wchar_t aEPrlFieldHeade_29[38];
// 51B10: using guessed type wchar_t aEPrlFieldHeade_28[39];
// 51B60: using guessed type wchar_t aEPrlFieldHeade_25[25];
// 51B98: using guessed type wchar_t aEPrlFieldHeade_24[30];
// 51BE0: using guessed type wchar_t aEPrlFieldHeade_31[32];
// 51C20: using guessed type wchar_t aEPrlFieldHeade_33[28];
// 51C58: using guessed type wchar_t aEPrlFieldHeade_32[24];
// 51C88: using guessed type wchar_t aEPrlFieldTarge[24];
// 51CB8: using guessed type wchar_t aEPrlFieldTarge_6[29];
// 51D00: using guessed type wchar_t aEPrlFieldTarge_5[33];
// 51D50: using guessed type wchar_t aEPrlFieldTarge_4[32];
// 51D90: using guessed type wchar_t aEPrlFieldTarge_3[39];
// 51DE0: using guessed type wchar_t aEPrlFieldTarge_2[32];
// 51E20: using guessed type wchar_t aEPrlFieldTarge_1[31];
// 51E60: using guessed type wchar_t aEPrlFieldTarge_0[28];
// 51E98: using guessed type wchar_t aEPrlFieldOpera[22];
// 51EC8: using guessed type wchar_t aEPrlFieldOpera_0[27];
// 51F00: using guessed type wchar_t aEPrlFieldOpera_1[30];
// 51F40: using guessed type wchar_t aEPrlFieldOpera_2[27];
// 51F78: using guessed type wchar_t aEPrlFieldOpera_3[27];
// 51FB0: using guessed type wchar_t aEPrlFieldOpera_4[29];
// 51FF0: using guessed type wchar_t aEPrlFieldOpera_5[29];
// 52030: using guessed type wchar_t aEPrlFieldOpera_6[29];
// 52070: using guessed type wchar_t aEPrlFieldOpera_7[28];
// 520B0: using guessed type wchar_t aEPrlFieldOpera_8[32];
// 520F0: using guessed type wchar_t aEPrlFieldOpera_9[26];
// 52130: using guessed type wchar_t aEPrlFieldOpera_10[37];
// 52180: using guessed type wchar_t aEPrlFieldOpera_11[39];
// 521D0: using guessed type wchar_t aEPrlFieldOpera_12[41];
// 52230: using guessed type wchar_t aEPrlFieldOpera_13[43];
// 52288: using guessed type wchar_t aEPrlFieldOpera_14[30];
// 522C8: using guessed type wchar_t aEPrlFieldOpera_15[27];
// 52300: using guessed type wchar_t aEPrlFieldOpera_22[28];
// 52338: using guessed type wchar_t aEPrlFieldOpera_21[28];
// 52370: using guessed type wchar_t aEPrlFieldOpera_20[34];
// 523C0: using guessed type wchar_t aEPrlFieldOpera_19[36];
// 52410: using guessed type wchar_t aEPrlFieldOpera_18[37];
// 52460: using guessed type wchar_t aEPrlFieldOpera_17[29];
// 524A0: using guessed type wchar_t aEPrlFieldOpera_16[36];
// 524F0: using guessed type wchar_t aEPrlFieldOpera_23[36];
// 52538: using guessed type wchar_t aEPrlFieldCommD_1[27];
// 52570: using guessed type wchar_t aEPrlFieldCommD_0[36];
// 525C0: using guessed type wchar_t aEPrlFieldCommD[36];
// 52608: using guessed type wchar_t aEPrlFieldEthPr_3[25];
// 52640: using guessed type wchar_t aEPrlFieldEthPr_2[30];
// 52680: using guessed type wchar_t aEPrlFieldEthPr[30];
// 526C0: using guessed type wchar_t aEPrlFieldEthPr_1[29];
// 52700: using guessed type wchar_t aEPrlFieldEthPr_0[30];
// 52740: using guessed type wchar_t aEPrlFieldIcmpT_2[22];
// 52770: using guessed type wchar_t aEPrlFieldIcmpT_1[33];
// 527C0: using guessed type wchar_t aEPrlFieldIcmpT_0[46];
// 52820: using guessed type wchar_t aEPrlFieldIcmpT[36];
// 52868: using guessed type wchar_t aEPrlFieldIcmpT_3[31];
// 528B0: using guessed type wchar_t aEPrlFieldIcmpT_10[42];
// 52910: using guessed type wchar_t aEPrlFieldIcmpT_9[35];
// 52960: using guessed type wchar_t aEPrlFieldIcmpT_8[43];
// 529C0: using guessed type wchar_t aEPrlFieldIcmpT_7[42];
// 52A20: using guessed type wchar_t aEPrlFieldIcmpT_6[36];
// 52A70: using guessed type wchar_t aEPrlFieldIcmpT_5[40];
// 52AC0: using guessed type wchar_t aEPrlFieldIcmpT_4[32];
// 52B00: using guessed type wchar_t aEPrlFieldIcmpT_11[38];
// 52B50: using guessed type wchar_t aEPrlFieldIcmpT_18[43];
// 52BB0: using guessed type wchar_t aEPrlFieldIcmpT_17[41];
// 52C10: using guessed type wchar_t aEPrlFieldIcmpT_16[33];
// 52C60: using guessed type wchar_t aEPrlFieldIcmpT_15[48];
// 52CC0: using guessed type wchar_t aEPrlFieldIcmpT_14[43];
// 52D20: using guessed type wchar_t aEPrlFieldIcmpT_13[41];
// 52D80: using guessed type wchar_t aEPrlFieldIcmpT_12[37];
// 52DD0: using guessed type wchar_t aEPrlFieldIcmpT_19[50];
// 52E40: using guessed type wchar_t aEPrlFieldIcmpT_24[48];
// 52EA0: using guessed type wchar_t aEPrlFieldIcmpT_23[42];
// 52F00: using guessed type wchar_t aEPrlFieldIcmpT_22[40];
// 52F50: using guessed type wchar_t aEPrlFieldIcmpT_21[27];
// 52F88: using guessed type wchar_t aEPrlFieldIcmpT_20[31];
// 52FC8: using guessed type wchar_t aEPrlFieldIcmpv_0[24];
// 53000: using guessed type wchar_t aEPrlFieldIcmpv[33];
// 53050: using guessed type wchar_t aEPrlFieldIcmpv_1[48];
// 530B0: using guessed type wchar_t aEPrlFieldIcmpv_8[39];
// 53100: using guessed type wchar_t aEPrlFieldIcmpv_7[38];
// 53150: using guessed type wchar_t aEPrlFieldIcmpv_6[42];
// 531B0: using guessed type wchar_t aEPrlFieldIcmpv_5[43];
// 53210: using guessed type wchar_t aEPrlFieldIcmpv_4[43];
// 53270: using guessed type wchar_t aEPrlFieldIcmpv_3[50];
// 532E0: using guessed type wchar_t aEPrlFieldIcmpv_2[50];
// 53350: using guessed type wchar_t aEPrlFieldIcmpv_9[43];
// 533B0: using guessed type wchar_t aEPrlFieldIcmpv_10[43];
// 53410: using guessed type wchar_t aEPrlFieldIcmpv_11[72];
// 534A0: using guessed type wchar_t aEPrlFieldIcmpv_12[37];
// 534F0: using guessed type wchar_t aEPrlFieldIcmpv_13[35];
// 53540: using guessed type wchar_t aEPrlFieldIcmpv_14[49];
// 535B0: using guessed type wchar_t aEPrlFieldIcmpv_15[50];
// 53620: using guessed type wchar_t aEPrlFieldIcmpv_16[48];
// 53680: using guessed type wchar_t aEPrlFieldIcmpv_17[44];
// 536E0: using guessed type wchar_t aEPrlFieldIcmpv_18[45];
// 53740: using guessed type wchar_t aEPrlFieldIcmpv_19[46];
// 537A0: using guessed type wchar_t aEPrlFieldIcmpv_20[47];
// 53800: using guessed type wchar_t aEPrlFieldIcmpv_21[41];
// 53860: using guessed type wchar_t aEPrlFieldIcmpv_22[43];
// 538C0: using guessed type wchar_t aEPrlFieldIcmpv_23[52];
// 53930: using guessed type wchar_t aEPrlFieldIcmpv_24[55];
// 539A0: using guessed type wchar_t aEPrlFieldIcmpv_25[72];
// 53A30: using guessed type wchar_t aEPrlFieldIcmpv_26[73];
// 53AD0: using guessed type wchar_t aEPrlFieldIcmpv_27[60];
// 53B50: using guessed type wchar_t aEPrlFieldIcmpv_28[69];
// 53BE0: using guessed type wchar_t aEPrlFieldIcmpv_29[67];
// 53C70: using guessed type wchar_t aEPrlFieldIcmpv_30[51];
// 53CE0: using guessed type wchar_t aEPrlFieldIcmpv_31[52];
// 53D50: using guessed type wchar_t aEPrlFieldIcmpv_32[64];
// 53DD0: using guessed type wchar_t aEPrlFieldIcmpv_33[65];
// 53E60: using guessed type wchar_t aEPrlFieldIcmpv_34[82];
// 53F10: using guessed type wchar_t aEPrlFieldIcmpv_35[55];
// 53F80: using guessed type wchar_t aEPrlFieldIcmpv_36[54];
// 53FF0: using guessed type wchar_t aEPrlFieldIcmpv_37[53];
// 54060: using guessed type wchar_t aEPrlFieldIcmpv_38[40];
// 540B0: using guessed type wchar_t aEPrlFieldIcmpv_39[44];
// 54110: using guessed type wchar_t aEPrlFieldIcmpv_40[54];
// 54180: using guessed type wchar_t aEPrlFieldIcmpv_41[50];
// 541F0: using guessed type wchar_t aEPrlFieldIcmpv_42[55];
// 54260: using guessed type wchar_t aEPrlFieldIcmpv_43[43];
// 542C0: using guessed type wchar_t aEPrlFieldIcmpv_44[43];
// 54320: using guessed type wchar_t aEPrlFieldIcmpv_49[50];
// 54390: using guessed type wchar_t aEPrlFieldIcmpv_48[50];
// 54400: using guessed type wchar_t aEPrlFieldIcmpv_47[43];
// 54460: using guessed type wchar_t aEPrlFieldIcmpv_46[43];
// 544C0: using guessed type wchar_t aEPrlFieldIcmpv_45[80];
// 54560: using guessed type wchar_t aEPrlFieldIcmpC[22];
// 54590: using guessed type wchar_t aEPrlFieldIcmpC_0[50];
// 54600: using guessed type wchar_t aEPrlFieldIcmpC_6[51];
// 54670: using guessed type wchar_t aEPrlFieldIcmpC_5[55];
// 546E0: using guessed type wchar_t aEPrlFieldIcmpC_4[51];
// 54750: using guessed type wchar_t aEPrlFieldIcmpC_3[68];
// 547E0: using guessed type wchar_t aEPrlFieldIcmpC_2[66];
// 54870: using guessed type wchar_t aEPrlFieldIcmpC_1[63];
// 548F0: using guessed type wchar_t aEPrlFieldIcmpC_7[64];
// 54970: using guessed type wchar_t aEPrlFieldIcmpC_13[67];
// 54A00: using guessed type wchar_t aEPrlFieldIcmpC_12[82];
// 54AB0: using guessed type wchar_t aEPrlFieldIcmpC_11[83];
// 54B60: using guessed type wchar_t aEPrlFieldIcmpC_10[63];
// 54BE0: using guessed type wchar_t aEPrlFieldIcmpC_9[64];
// 54C60: using guessed type wchar_t aEPrlFieldIcmpC_8[68];
// 54CF0: using guessed type wchar_t aEPrlFieldIcmpC_14[72];
// 54D80: using guessed type wchar_t aEPrlFieldIcmpC_19[71];
// 54E10: using guessed type wchar_t aEPrlFieldIcmpC_18[35];
// 54E60: using guessed type wchar_t aEPrlFieldIcmpC_17[36];
// 54EB0: using guessed type wchar_t aEPrlFieldIcmpC_16[52];
// 54F20: using guessed type wchar_t aEPrlFieldIcmpC_15[53];
// 54F90: using guessed type wchar_t aEPrlFieldIcmpC_20[56];
// 55000: using guessed type wchar_t aEPrlFieldIcmpC_26[50];
// 55070: using guessed type wchar_t aEPrlFieldIcmpC_25[62];
// 550F0: using guessed type wchar_t aEPrlFieldIcmpC_24[49];
// 55160: using guessed type wchar_t aEPrlFieldIcmpC_23[56];
// 551D0: using guessed type wchar_t aEPrlFieldIcmpC_22[48];
// 55230: using guessed type wchar_t aEPrlFieldIcmpC_21[55];
// 552A0: using guessed type wchar_t aEPrlFieldIcmpC_27[51];
// 55310: using guessed type wchar_t aEPrlFieldIcmpC_33[39];
// 55360: using guessed type wchar_t aEPrlFieldIcmpC_32[53];
// 553D0: using guessed type wchar_t aEPrlFieldIcmpC_31[52];
// 55440: using guessed type wchar_t aEPrlFieldIcmpC_30[49];
// 554B0: using guessed type wchar_t aEPrlFieldIcmpC_29[51];
// 55520: using guessed type wchar_t aEPrlFieldIcmpC_28[50];
// 55588: using guessed type wchar_t aEPrlFieldIcmpv_50[24];
// 555C0: using guessed type wchar_t aEPrlFieldIcmpv_56[72];
// 55650: using guessed type wchar_t aEPrlFieldIcmpv_55[107];
// 55730: using guessed type wchar_t aEPrlFieldIcmpv_54[79];
// 557D0: using guessed type wchar_t aEPrlFieldIcmpv_53[68];
// 55860: using guessed type wchar_t aEPrlFieldIcmpv_52[65];
// 558F0: using guessed type wchar_t aEPrlFieldIcmpv_51[92];
// 559B0: using guessed type wchar_t aEPrlFieldIcmpv_57[76];
// 55A50: using guessed type wchar_t aEPrlFieldIcmpv_62[79];
// 55AF0: using guessed type wchar_t aEPrlFieldIcmpv_61[68];
// 55B80: using guessed type wchar_t aEPrlFieldIcmpv_60[72];
// 55C10: using guessed type wchar_t aEPrlFieldIcmpv_59[77];
// 55CB0: using guessed type wchar_t aEPrlFieldIcmpv_58[84];
// 55D60: using guessed type wchar_t aEPrlFieldIcmpv_63[79];
// 55E00: using guessed type wchar_t aEPrlFieldIcmpv_69[95];
// 55EC0: using guessed type wchar_t aEPrlFieldIcmpv_68[51];
// 55F30: using guessed type wchar_t aEPrlFieldIcmpv_67[50];
// 55FA0: using guessed type wchar_t aEPrlFieldIcmpv_66[65];
// 56030: using guessed type wchar_t aEPrlFieldIcmpv_65[73];
// 560D0: using guessed type wchar_t aEPrlFieldIcmpv_64[74];
// 56170: using guessed type wchar_t aEPrlFieldIcmpv_70[73];
// 56210: using guessed type wchar_t aEPrlFieldIcmpv_73[63];
// 56290: using guessed type wchar_t aEPrlFieldIcmpv_72[63];
// 56310: using guessed type wchar_t aEPrlFieldIcmpv_71[69];
// 563A0: using guessed type wchar_t aEPrlFieldUrlCa_1[25];
// 563D8: using guessed type wchar_t aEPrlFieldUrlCa_0[28];
// 56410: using guessed type wchar_t aEPrlFieldUrlCa[30];
// 56450: using guessed type wchar_t aEPrlFieldUrlCa_2[29];
// 56490: using guessed type wchar_t aEPrlFieldUrlCa_8[25];
// 564C8: using guessed type wchar_t aEPrlFieldUrlCa_7[28];
// 56500: using guessed type wchar_t aEPrlFieldUrlCa_6[35];
// 56550: using guessed type wchar_t aEPrlFieldUrlCa_5[36];
// 565A0: using guessed type wchar_t aEPrlFieldUrlCa_4[32];
// 565E0: using guessed type wchar_t aEPrlFieldUrlCa_3[29];
// 56620: using guessed type wchar_t aEPrlFieldUrlCa_9[32];
// 56660: using guessed type wchar_t aEPrlFieldUrlCa_14[26];
// 566A0: using guessed type wchar_t aEPrlFieldUrlCa_13[42];
// 56700: using guessed type wchar_t aEPrlFieldUrlCa_12[37];
// 56750: using guessed type wchar_t aEPrlFieldUrlCa_11[35];
// 567A0: using guessed type wchar_t aEPrlFieldUrlCa_10[34];
// 567F0: using guessed type wchar_t aEPrlFieldUrlCa_15[35];
// 56840: using guessed type wchar_t aEPrlFieldUrlCa_16[38];
// 56890: using guessed type wchar_t aEPrlFieldUrlCa_17[29];
// 568D0: using guessed type wchar_t aEPrlFieldUrlCa_18[28];
// 56910: using guessed type wchar_t aEPrlFieldUrlCa_19[36];
// 56958: using guessed type wchar_t aEPrlFieldUrlCa_20[28];
// 56990: using guessed type wchar_t aEPrlFieldUrlCa_21[33];
// 569E0: using guessed type wchar_t aEPrlFieldUrlCa_22[34];
// 56A30: using guessed type wchar_t aEPrlFieldUrlCa_23[41];
// 56A90: using guessed type wchar_t aEPrlFieldUrlCa_24[35];
// 56AD8: using guessed type wchar_t aEPrlFieldUrlCa_25[31];
// 56B20: using guessed type wchar_t aEPrlFieldUrlCa_26[35];
// 56B68: using guessed type wchar_t aEPrlFieldUrlCa_27[25];
// 56BA0: using guessed type wchar_t aEPrlFieldUrlCa_28[30];
// 56BE0: using guessed type wchar_t aEPrlFieldUrlCa_29[35];
// 56C30: using guessed type wchar_t aEPrlFieldUrlCa_30[33];
// 56C78: using guessed type wchar_t aEPrlFieldUrlCa_31[29];
// 56CC0: using guessed type wchar_t aEPrlFieldUrlCa_32[39];
// 56D10: using guessed type wchar_t aEPrlFieldUrlCa_33[41];
// 56D68: using guessed type wchar_t aEPrlFieldUrlCa_34[29];
// 56DB0: using guessed type wchar_t aEPrlFieldUrlCa_35[34];
// 56DF8: using guessed type wchar_t aEPrlFieldUrlCa_36[29];
// 56E40: using guessed type wchar_t aEPrlFieldUrlCa_37[38];
// 56E90: using guessed type wchar_t aEPrlFieldUrlCa_38[40];
// 56EE0: using guessed type wchar_t aEPrlFieldUrlCa_39[31];
// 56F20: using guessed type wchar_t aEPrlFieldUrlCa_40[42];
// 56F78: using guessed type wchar_t aEPrlFieldUrlCa_41[28];
// 56FB0: using guessed type wchar_t aNoStringForThi[25];

//----- (0000000000036CB0) ----------------------------------------------------
const wchar_t *__fastcall sub_36CB0(int a1)
{
  const wchar_t *result; // rax
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  int v21; // ecx
  int v22; // ecx
  int v23; // ecx
  int v24; // ecx
  int v25; // ecx
  int v26; // ecx
  int v27; // ecx
  int v28; // ecx
  int v29; // ecx
  int v30; // ecx
  int v31; // ecx
  int v32; // ecx
  int v33; // ecx
  int v34; // ecx
  int v35; // ecx
  int v36; // ecx
  int v37; // ecx
  int v38; // ecx
  int v39; // ecx
  int v40; // ecx
  int v41; // ecx
  int v42; // ecx
  int v43; // ecx
  int v44; // ecx
  int v45; // ecx
  int v46; // ecx
  int v47; // ecx
  int v48; // ecx
  int v49; // ecx
  int v50; // ecx
  int v51; // ecx
  int v52; // ecx
  int v53; // ecx
  int v54; // ecx
  int v55; // ecx
  int v56; // ecx
  int v57; // ecx
  int v58; // ecx
  int v59; // ecx
  int v60; // ecx
  int v61; // ecx
  int v62; // ecx
  int v63; // ecx
  int v64; // ecx
  int v65; // ecx
  int v66; // ecx
  int v67; // ecx
  int v68; // ecx
  int v69; // ecx
  int v70; // ecx
  int v71; // ecx
  int v72; // ecx
  int v73; // ecx
  int v74; // ecx
  int v75; // ecx
  int v76; // ecx
  int v77; // ecx
  int v78; // ecx
  int v79; // ecx
  int v80; // ecx
  int v81; // ecx
  int v82; // ecx
  int v83; // ecx
  int v84; // ecx
  int v85; // ecx
  int v86; // ecx
  int v87; // ecx
  int v88; // ecx
  int v89; // ecx
  int v90; // ecx
  int v91; // ecx
  int v92; // ecx
  int v93; // ecx
  int v94; // ecx
  int v95; // ecx
  int v96; // ecx
  int v97; // ecx
  int v98; // ecx
  int v99; // ecx
  int v100; // ecx
  int v101; // ecx
  int v102; // ecx
  int v103; // ecx
  int v104; // ecx
  int v105; // ecx
  int v106; // ecx
  int v107; // ecx
  int v108; // ecx
  int v109; // ecx
  int v110; // ecx
  int v111; // ecx
  int v112; // ecx
  int v113; // ecx
  int v114; // ecx
  int v115; // ecx
  int v116; // ecx
  int v117; // ecx
  int v118; // ecx
  int v119; // ecx
  int v120; // ecx
  int v121; // ecx
  int v122; // ecx
  int v123; // ecx
  int v124; // ecx
  int v125; // ecx
  int v126; // ecx
  int v127; // ecx
  int v128; // ecx
  int v129; // ecx
  int v130; // ecx
  int v131; // ecx
  int v132; // ecx
  int v133; // ecx
  int v134; // ecx
  int v135; // ecx
  int v136; // ecx
  int v137; // ecx
  int v138; // ecx
  int v139; // ecx
  int v140; // ecx
  int v141; // ecx
  int v142; // ecx
  int v143; // ecx
  int v144; // ecx
  int v145; // ecx
  int v146; // ecx

  if ( a1 <= 256 )
  {
    if ( a1 == 256 )
      return L"IP_PROTOCOL";
    switch ( a1 )
    {
      case -1:
        result = L"Type unknown";
        break;
      case 0:
        result = L"UNKNOWN";
        break;
      case 1:
        result = L"PATH";
        break;
      case 2:
        result = L"SRC_PATH";
        break;
      case 3:
        result = L"PATH_HASH";
        break;
      case 4:
        result = L"APP_NAME";
        break;
      case 5:
        result = L"APP_NAME_HASH";
        break;
      case 6:
        result = L"PID";
        break;
      case 7:
        result = L"SRC_PID";
        break;
      case 8:
        result = L"TID";
        break;
      case 9:
        result = L"SRC_TID";
        break;
      case 10:
        result = L"USER_SID";
        break;
      case 11:
        result = L"SHARE_MODE";
        break;
      case 12:
        result = L"ATTRIBUTES";
        break;
      case 13:
        result = L"SHOWWINDOW";
        break;
      case 14:
        result = L"COMMANDLINE";
        break;
      case 15:
        result = L"TRANSACTION_ID";
        break;
      case 16:
        result = L"EXTENSION";
        break;
      case 17:
        result = L"ACCESS_MODE";
        break;
      case 18:
        result = L"BUFFER";
        break;
      case 19:
        result = L"BUFFERSIZE";
        break;
      case 20:
        result = L"FILEOFFSET";
        break;
      case 21:
        result = L"DISPOSITION";
        break;
      case 22:
        result = L"PRLTEXT";
        break;
      case 23:
        result = L"SAFEBOOT";
        break;
      case 24:
        result = L"OPTIONS";
        break;
      case 25:
        result = L"CREATE_MODE";
        break;
      case 26:
        result = L"CREATE_OPTIONS";
        break;
      case 27:
        result = L"ALLOCATION_SIZE";
        break;
      case 28:
        result = L"SOURCE_IP";
        break;
      case 29:
        result = L"DESTINATION_IP";
        break;
      case 30:
        result = L"SOURCE_PORT";
        break;
      case 31:
        result = L"DESTINATION_PORT";
        break;
      case 32:
        result = L"SOURCE_MAC";
        break;
      case 33:
        result = L"DESTINATION_MAC";
        break;
      case 34:
        result = L"USER_PROFILE";
        break;
      default:
        return L"NO_STRING_FOR_THIS_FIELD";
    }
    return result;
  }
  if ( a1 <= 768 )
  {
    if ( a1 == 768 )
      return L"ACTION";
    if ( a1 <= 333 )
    {
      if ( a1 == 333 )
        return L"IP_PROTOCOL_BR_SAT_MON";
      switch ( a1 )
      {
        case 257:
          result = L"IP_PROTOCOL_HOPOPT";
          break;
        case 258:
          result = L"IP_PROTOCOL_ICMP";
          break;
        case 259:
          result = L"IP_PROTOCOL_IGMP";
          break;
        case 260:
          result = L"IP_PROTOCOL_GGP";
          break;
        case 261:
          result = L"IP_PROTOCOL_IPV4";
          break;
        case 262:
          result = L"IP_PROTOCOL_ST";
          break;
        case 263:
          result = L"IP_PROTOCOL_TCP";
          break;
        case 264:
          result = L"IP_PROTOCOL_CBT";
          break;
        case 265:
          result = L"IP_PROTOCOL_EGP";
          break;
        case 266:
          result = L"IP_PROTOCOL_IGP";
          break;
        case 267:
          result = L"IP_PROTOCOL_BBN_RCC_MON";
          break;
        case 268:
          result = L"IP_PROTOCOL_NVP_II";
          break;
        case 269:
          result = L"IP_PROTOCOL_PUP";
          break;
        case 270:
          result = L"IP_PROTOCOL_ARGUS";
          break;
        case 271:
          result = L"IP_PROTOCOL_EMCON";
          break;
        case 272:
          result = L"IP_PROTOCOL_XNET";
          break;
        case 273:
          result = L"IP_PROTOCOL_CHAOS";
          break;
        case 274:
          result = L"IP_PROTOCOL_UDP";
          break;
        case 275:
          result = L"IP_PROTOCOL_MUX";
          break;
        case 276:
          result = L"IP_PROTOCOL_DCN_MEAS";
          break;
        case 277:
          result = L"IP_PROTOCOL_HMP";
          break;
        case 278:
          result = L"IP_PROTOCOL_PRM";
          break;
        case 279:
          result = L"IP_PROTOCOL_XNS_IDP";
          break;
        case 280:
          result = L"IP_PROTOCOL_TRUNK_1";
          break;
        case 281:
          result = L"IP_PROTOCOL_TRUNK_2";
          break;
        case 282:
          result = L"IP_PROTOCOL_LEAF_1";
          break;
        case 283:
          result = L"IP_PROTOCOL_LEAF_2";
          break;
        case 284:
          result = L"IP_PROTOCOL_RDP";
          break;
        case 285:
          result = L"IP_PROTOCOL_IRTP";
          break;
        case 286:
          result = L"IP_PROTOCOL_ISO_TP4";
          break;
        case 287:
          result = L"IP_PROTOCOL_NETBLT";
          break;
        case 288:
          result = L"IP_PROTOCOL_MFE_NSP";
          break;
        case 289:
          result = L"IP_PROTOCOL_MERIT_INP";
          break;
        case 290:
          result = L"IP_PROTOCOL_DCCP";
          break;
        case 291:
          result = L"IP_PROTOCOL_3PC";
          break;
        case 292:
          result = L"IP_PROTOCOL_IDPR";
          break;
        case 293:
          result = L"IP_PROTOCOL_XTP";
          break;
        case 294:
          result = L"IP_PROTOCOL_DDP";
          break;
        case 295:
          result = L"IP_PROTOCOL_IDPR_CMTP";
          break;
        case 296:
          result = L"IP_PROTOCOL_TP_PLUS_PLUS";
          break;
        case 297:
          result = L"IP_PROTOCOL_IL";
          break;
        case 298:
          result = L"IP_PROTOCOL_IPV6";
          break;
        case 299:
          result = L"IP_PROTOCOL_SDRP";
          break;
        case 300:
          result = L"IP_PROTOCOL_IPV6_ROUTE";
          break;
        case 301:
          result = L"IP_PROTOCOL_IPV6_FRAG";
          break;
        case 302:
          result = L"IP_PROTOCOL_IDRP";
          break;
        case 303:
          result = L"IP_PROTOCOL_RSVP";
          break;
        case 304:
          result = L"IP_PROTOCOL_GRE";
          break;
        case 305:
          result = L"IP_PROTOCOL_DSR";
          break;
        case 306:
          result = L"IP_PROTOCOL_BNA";
          break;
        case 307:
          result = L"IP_PROTOCOL_ESP";
          break;
        case 308:
          result = L"IP_PROTOCOL_AH";
          break;
        case 309:
          result = L"IP_PROTOCOL_I_NLSP";
          break;
        case 310:
          result = L"IP_PROTOCOL_SWIPE";
          break;
        case 311:
          result = L"IP_PROTOCOL_NARP";
          break;
        case 312:
          result = L"IP_PROTOCOL_MOBILE";
          break;
        case 313:
          result = L"IP_PROTOCOL_TLSP";
          break;
        case 314:
          result = L"IP_PROTOCOL_SKIP";
          break;
        case 315:
          result = L"IP_PROTOCOL_ICMPV6";
          break;
        case 316:
          result = L"IP_PROTOCOL_IPV6_NO_NXT";
          break;
        case 317:
          result = L"IP_PROTOCOL_IPV6_OPTS";
          break;
        case 318:
          result = L"IP_PROTOCOL_PROTOCOL_61";
          break;
        case 319:
          result = L"IP_PROTOCOL_CFTP";
          break;
        case 320:
          result = L"IP_PROTOCOL_PROTOCOL_63";
          break;
        case 321:
          result = L"IP_PROTOCOL_SAT_EXPAK";
          break;
        case 322:
          result = L"IP_PROTOCOL_KRYPTOLAN";
          break;
        case 323:
          result = L"IP_PROTOCOL_RVD";
          break;
        case 324:
          result = L"IP_PROTOCOL_IPPC";
          break;
        case 325:
          result = L"IP_PROTOCOL_PROTOCOL_68";
          break;
        case 326:
          result = L"IP_PROTOCOL_SAT_MON";
          break;
        case 327:
          result = L"IP_PROTOCOL_VISA";
          break;
        case 328:
          result = L"IP_PROTOCOL_IPCV";
          break;
        case 329:
          result = L"IP_PROTOCOL_CPNX";
          break;
        case 330:
          result = L"IP_PROTOCOL_CPHB";
          break;
        case 331:
          result = L"IP_PROTOCOL_WSN";
          break;
        case 332:
          result = L"IP_PROTOCOL_PVP";
          break;
        default:
          return L"NO_STRING_FOR_THIS_FIELD";
      }
      return result;
    }
    if ( a1 <= 371 )
    {
      if ( a1 == 371 )
        return L"IP_PROTOCOL_PROTOCOL_114";
      switch ( a1 )
      {
        case 334:
          result = L"IP_PROTOCOL_SUN_ND";
          break;
        case 335:
          result = L"IP_PROTOCOL_WB_MON";
          break;
        case 336:
          result = L"IP_PROTOCOL_WB_EXPAK";
          break;
        case 337:
          result = L"IP_PROTOCOL_ISO_IP";
          break;
        case 338:
          result = L"IP_PROTOCOL_VMTP";
          break;
        case 339:
          result = L"IP_PROTOCOL_SECURE_VMTP";
          break;
        case 340:
          result = L"IP_PROTOCOL_VINES";
          break;
        case 341:
          result = L"IP_PROTOCOL_TTP";
          break;
        case 342:
          result = L"IP_PROTOCOL_NSFNET_IGP";
          break;
        case 343:
          result = L"IP_PROTOCOL_DGP";
          break;
        case 344:
          result = L"IP_PROTOCOL_TCF";
          break;
        case 345:
          result = L"IP_PROTOCOL_EIGRP";
          break;
        case 346:
          result = L"IP_PROTOCOL_OSPFIGP";
          break;
        case 347:
          result = L"IP_PROTOCOL_SPRITE_RPC";
          break;
        case 348:
          result = L"IP_PROTOCOL_LARP";
          break;
        case 349:
          result = L"IP_PROTOCOL_MTP";
          break;
        case 350:
          result = L"IP_PROTOCOL_AX_25";
          break;
        case 351:
          result = L"IP_PROTOCOL_IPIP";
          break;
        case 352:
          result = L"IP_PROTOCOL_MICP";
          break;
        case 353:
          result = L"IP_PROTOCOL_SCC_SP";
          break;
        case 354:
          result = L"IP_PROTOCOL_ETHERIP";
          break;
        case 355:
          result = L"IP_PROTOCOL_ENCAP";
          break;
        case 356:
          result = L"IP_PROTOCOL_PROTOCOL_99";
          break;
        case 357:
          result = L"IP_PROTOCOL_GMTP";
          break;
        case 358:
          result = L"IP_PROTOCOL_IFMP";
          break;
        case 359:
          result = L"IP_PROTOCOL_PNNI";
          break;
        case 360:
          result = L"IP_PROTOCOL_PIM";
          break;
        case 361:
          result = L"IP_PROTOCOL_ARIS";
          break;
        case 362:
          result = L"IP_PROTOCOL_SCPS";
          break;
        case 363:
          result = L"IP_PROTOCOL_QNX";
          break;
        case 364:
          result = L"IP_PROTOCOL_A_N";
          break;
        case 365:
          result = L"IP_PROTOCOL_IP_COMP";
          break;
        case 366:
          result = L"IP_PROTOCOL_SNP";
          break;
        case 367:
          result = L"IP_PROTOCOL_COMPAQ_PEER";
          break;
        case 368:
          result = L"IP_PROTOCOL_IPX_IN_IP";
          break;
        case 369:
          result = L"IP_PROTOCOL_VRRP";
          break;
        case 370:
          result = L"IP_PROTOCOL_PGM";
          break;
        default:
          return L"NO_STRING_FOR_THIS_FIELD";
      }
      return result;
    }
    if ( a1 <= 512 )
    {
      if ( a1 == 512 )
        return L"AL_PROTOCOL";
      switch ( a1 )
      {
        case 372:
          result = L"IP_PROTOCOL_L2TP";
          break;
        case 373:
          result = L"IP_PROTOCOL_DDX";
          break;
        case 374:
          result = L"IP_PROTOCOL_IATP";
          break;
        case 375:
          result = L"IP_PROTOCOL_STP";
          break;
        case 376:
          result = L"IP_PROTOCOL_SRP";
          break;
        case 377:
          result = L"IP_PROTOCOL_UTI";
          break;
        case 378:
          result = L"IP_PROTOCOL_SMP";
          break;
        case 379:
          result = L"IP_PROTOCOL_SM";
          break;
        case 380:
          result = L"IP_PROTOCOL_PTP";
          break;
        case 381:
          result = L"IP_PROTOCOL_ISIS_OVER_IPV4";
          break;
        case 382:
          result = L"IP_PROTOCOL_FIRE";
          break;
        case 383:
          result = L"IP_PROTOCOL_CRTP";
          break;
        case 384:
          result = L"IP_PROTOCOL_CRUDP";
          break;
        case 385:
          result = L"IP_PROTOCOL_SSCOPMCE";
          break;
        case 386:
          result = L"IP_PROTOCOL_IPLT";
          break;
        case 387:
          result = L"IP_PROTOCOL_SPS";
          break;
        case 388:
          result = L"IP_PROTOCOL_PIPE";
          break;
        case 389:
          result = L"IP_PROTOCOL_SCTP";
          break;
        case 390:
          result = L"IP_PROTOCOL_FC";
          break;
        case 391:
          result = L"IP_PROTOCOL_RSVP_E2E_IGNORE";
          break;
        case 392:
          result = L"IP_PROTOCOL_MOBILITY_HEADER";
          break;
        case 393:
          result = L"IP_PROTOCOL_UDP_LITE";
          break;
        case 394:
          result = L"IP_PROTOCOL_MPLS_IN_IP";
          break;
        case 395:
          result = L"IP_PROTOCOL_MANET";
          break;
        case 396:
          result = L"IP_PROTOCOL_HIP";
          break;
        case 397:
          result = L"IP_PROTOCOL_SHIM6";
          break;
        case 398:
          result = L"IP_PROTOCOL_WESP";
          break;
        case 399:
          result = L"IP_PROTOCOL_ROHC";
          break;
        default:
          return L"NO_STRING_FOR_THIS_FIELD";
      }
      return result;
    }
    v2 = a1 - 513;
    if ( !v2 )
      return L"AL_PROTOCOL_DNS";
    v3 = v2 - 1;
    if ( !v3 )
      return L"AL_PROTOCOL_DHCP";
    v4 = v3 - 1;
    if ( !v4 )
      return L"AL_PROTOCOL_HTTP";
    v5 = v4 - 1;
    if ( !v5 )
      return L"AL_PROTOCOL_HTTPS";
    v6 = v5 - 1;
    if ( !v6 )
      return L"AL_PROTOCOL_SMTP";
    v7 = v6 - 1;
    if ( !v7 )
      return L"AL_PROTOCOL_FTP";
    v8 = v7 - 1;
    if ( !v8 )
      return L"AL_PROTOCOL_POP3";
    if ( v8 == 1 )
      return L"AL_PROTOCOL_DHCPV6";
    return L"NO_STRING_FOR_THIS_FIELD";
  }
  if ( a1 <= 1024 )
  {
    if ( a1 == 1024 )
      return L"HEADER";
    if ( a1 > 775 )
    {
      v14 = a1 - 776;
      if ( !v14 )
        return L"ACTION_UNGROUP";
      v15 = v14 - 1;
      if ( !v15 )
        return L"ACTION_ACTIVATE";
      v16 = v15 - 1;
      if ( !v16 )
        return L"ACTION_DEACTIVATE";
      v17 = v16 - 1;
      if ( !v17 )
        return L"ACTION_DROP";
      if ( v17 == 1 )
        return L"ACTION_ASK";
    }
    else
    {
      if ( a1 == 775 )
        return L"ACTION_GROUP";
      v9 = a1 - 769;
      if ( !v9 )
        return L"ACTION_ALLOW";
      v10 = v9 - 1;
      if ( !v10 )
        return L"ACTION_DENY";
      v11 = v10 - 1;
      if ( !v11 )
        return L"ACTION_NOTIFY";
      v12 = v11 - 1;
      if ( !v12 )
        return L"ACTION_SEND";
      v13 = v12 - 1;
      if ( !v13 )
        return L"ACTION_CALL";
      if ( v13 == 1 )
        return L"ACTION_REPORT";
    }
    return L"NO_STRING_FOR_THIS_FIELD";
  }
  if ( a1 > 51342 )
  {
    if ( a1 > 51400 )
    {
      if ( a1 <= 55309 )
      {
        if ( a1 == 55309 )
          return L"ICMPV6_CODE_PARAMETER_PROBLEM_UNRECOGNIZED_IPV6_OPTION_ENCOUNTERED";
        if ( a1 > 53269 )
        {
          if ( a1 > 55296 )
          {
            if ( a1 > 55303 )
            {
              v124 = a1 - 55304;
              if ( !v124 )
                return L"ICMPV6_CODE_DESTINATION_UNREACHABLE_ERROR_IN_SOURCE_ROUTING_HEADER";
              v125 = v124 - 1;
              if ( !v125 )
                return L"ICMPV6_CODE_TIME_EXCEEDED_HOP_LIMIT_EXCEEDED_IN_TRANSIT";
              v126 = v125 - 1;
              if ( !v126 )
                return L"ICMPV6_CODE_TIME_EXCEEDED_FRAGMENT_REASSEMBLY_TIME_EXCEEDED";
              v127 = v126 - 1;
              if ( !v127 )
                return L"ICMPV6_CODE_PARAMETER_PROBLEM_ERRONEOUS_HEADER_FIELD_ENCOUNTERED";
              if ( v127 == 1 )
                return L"ICMPV6_CODE_PARAMETER_PROBLEM_UNRECOGNIZED_NEXT_HEADER_TYPE_ENCOUNTERED";
            }
            else
            {
              if ( a1 == 55303 )
                return L"ICMPV6_CODE_DESTINATION_UNREACHABLE_REJECT_ROUTE_TO_DESTINATION";
              v119 = a1 - 55297;
              if ( !v119 )
                return L"ICMPV6_CODE_DESTINATION_UNREACHABLE_NO_ROUTE_TO_DESTINATION";
              v120 = v119 - 1;
              if ( !v120 )
                return L"ICMPV6_CODE_DESTINATION_UNREACHABLE_COMMUNICATION_WITH_DESTINATION_ADMINISTRATIVELY_PROHIBITED";
              v121 = v120 - 1;
              if ( !v121 )
                return L"ICMPV6_CODE_DESTINATION_UNREACHABLE_BEYOND_SCOPE_OF_SOURCE_ADDRESS";
              v122 = v121 - 1;
              if ( !v122 )
                return L"ICMPV6_CODE_DESTINATION_UNREACHABLE_ADDRESS_UNREACHABLE";
              v123 = v122 - 1;
              if ( !v123 )
                return L"ICMPV6_CODE_DESTINATION_UNREACHABLE_PORT_UNREACHABLE";
              if ( v123 == 1 )
                return L"ICMPV6_CODE_DESTINATION_UNREACHABLE_SOURCE_ADDRESS_FAILED_INGRESS_EGRESS_POLICY";
            }
          }
          else
          {
            if ( a1 == 55296 )
              return L"ICMPV6_CODE";
            if ( a1 > 53276 )
            {
              v114 = a1 - 53277;
              if ( !v114 )
                return L"ICMP_CODE_PHOTURIS_BAD_SPI";
              v115 = v114 - 1;
              if ( !v115 )
                return L"ICMP_CODE_PHOTURIS_AUTHENTICATION_FAILED";
              v116 = v115 - 1;
              if ( !v116 )
                return L"ICMP_CODE_PHOTURIS_DECOMPRESSION_FAILED";
              v117 = v116 - 1;
              if ( !v117 )
                return L"ICMP_CODE_PHOTURIS_DECRYPTION_FAILED";
              v118 = v117 - 1;
              if ( !v118 )
                return L"ICMP_CODE_PHOTURIS_NEED_AUTHENTICATION";
              if ( v118 == 1 )
                return L"ICMP_CODE_PHOTURIS_NEED_AUTHORIZATION";
            }
            else
            {
              if ( a1 == 53276 )
                return L"ICMP_CODE_PARAMETER_PROBLEM_BAD_LENGTH";
              v109 = a1 - 53270;
              if ( !v109 )
                return L"ICMP_CODE_ROUTER_ADVERTISEMENT_NORMAL";
              v110 = v109 - 1;
              if ( !v110 )
                return L"ICMP_CODE_ROUTER_ADVERTISEMENT_NOT_COMMON_TRAFFIC";
              v111 = v110 - 1;
              if ( !v111 )
                return L"ICMP_CODE_TIME_EXCEEDED_TIME_TO_LIVE";
              v112 = v111 - 1;
              if ( !v112 )
                return L"ICMP_CODE_TIME_EXCEEDED_FRAGMENT_REASSEMBLY";
              v113 = v112 - 1;
              if ( !v113 )
                return L"ICMP_CODE_PARAMETER_PROBLEM_POINTER";
              if ( v113 == 1 )
                return L"ICMP_CODE_PARAMETER_PROBLEM_MISSING_OPTION";
            }
          }
        }
        else
        {
          if ( a1 == 53269 )
            return L"ICMP_CODE_ALTERNATE_HOST_ADDR_ADDR_FOR_HOST";
          if ( a1 > 53256 )
          {
            if ( a1 > 53263 )
            {
              v105 = a1 - 53264;
              if ( !v105 )
                return L"ICMP_CODE_DESTINATION_UNREACHABLE_PRECEDENTE_CUTOFF_EFFECT";
              v106 = v105 - 1;
              if ( !v106 )
                return L"ICMP_CODE_REDIRECT_NET";
              v107 = v106 - 1;
              if ( !v107 )
                return L"ICMP_CODE_REDIRECT_HOST";
              v108 = v107 - 1;
              if ( !v108 )
                return L"ICMP_CODE_REDIRECT_TYPE_SERVICE_AND_NET";
              if ( v108 == 1 )
                return L"ICMP_CODE_REDIRECT_TYPE_SERVICE_AND_HOST";
            }
            else
            {
              if ( a1 == 53263 )
                return L"ICMP_CODE_DESTINATION_UNREACHABLE_HOST_PRECEDENTE_VIOLATION";
              v100 = a1 - 53257;
              if ( !v100 )
                return L"ICMP_CODE_DESTINATION_UNREACHABLE_SOURCE_HOST_ISOLATED";
              v101 = v100 - 1;
              if ( !v101 )
                return L"ICMP_CODE_DESTINATION_UNREACHABLE_COMM_WITH_DEST_NET_ADMIN_PROHIBITED";
              v102 = v101 - 1;
              if ( !v102 )
                return L"ICMP_CODE_DESTINATION_UNREACHABLE_COMM_WITH_DEST_HOST_ADMIN_PROHIBITED";
              v103 = v102 - 1;
              if ( !v103 )
                return L"ICMP_CODE_DESTINATION_UNREACHABLE_NET_SERVICE_TYPE";
              v104 = v103 - 1;
              if ( !v104 )
                return L"ICMP_CODE_DESTINATION_UNREACHABLE_HOST_SERVICE_TYPE";
              if ( v104 == 1 )
                return L"ICMP_CODE_DESTINATION_UNREACHABLE_COMM_ADMIN_PROHIBITED";
            }
          }
          else
          {
            if ( a1 == 53256 )
              return L"ICMP_CODE_DESTINATION_UNREACHABLE_DEST_HOST_UNKNOWN";
            if ( a1 > 53249 )
            {
              v95 = a1 - 53250;
              if ( !v95 )
                return L"ICMP_CODE_DESTINATION_UNREACHABLE_HOST";
              v96 = v95 - 1;
              if ( !v96 )
                return L"ICMP_CODE_DESTINATION_UNREACHABLE_PROTOCOL";
              v97 = v96 - 1;
              if ( !v97 )
                return L"ICMP_CODE_DESTINATION_UNREACHABLE_PORT";
              v98 = v97 - 1;
              if ( !v98 )
                return L"ICMP_CODE_DESTINATION_UNREACHABLE_FRAGMENTATION_NOT_SET";
              v99 = v98 - 1;
              if ( !v99 )
                return L"ICMP_CODE_DESTINATION_UNREACHABLE_SOURCE_ROUTE_FAILED";
              if ( v99 == 1 )
                return L"ICMP_CODE_DESTINATION_UNREACHABLE_DEST_NET_UNKNOWN";
            }
            else
            {
              if ( a1 == 53249 )
                return L"ICMP_CODE_DESTINATION_UNREACHABLE_NET";
              v90 = a1 - 51401;
              if ( !v90 )
                return L"ICMPV6_TYPE_PRIVATE_EXPERIMENTATION_3";
              v91 = v90 - 1;
              if ( !v91 )
                return L"ICMPV6_TYPE_PRIVATE_EXPERIMENTATION_4";
              v92 = v91 - 1;
              if ( !v92 )
                return L"ICMPV6_TYPE_UNASSIGNED_4_LOWER";
              v93 = v92 - 52;
              if ( !v93 )
                return L"ICMPV6_TYPE_UNASSIGNED_4_UPPER";
              v94 = v93 - 1;
              if ( !v94 )
                return L"ICMPV6_TYPE_RESERVED_FOR_EXPANSION_OF_ICMPV6_INFORMATIONAL_MESSAGES";
              if ( v94 == 1792 )
                return L"ICMP_CODE";
            }
          }
        }
        return L"NO_STRING_FOR_THIS_FIELD";
      }
      if ( a1 <= 57360 )
      {
        if ( a1 == 57360 )
          return L"URL_CAT_FASHION_BEAUTY";
        if ( a1 > 57347 )
        {
          if ( a1 > 57354 )
          {
            v143 = a1 - 57355;
            if ( !v143 )
              return L"URL_CAT_CULTS";
            v144 = v143 - 1;
            if ( !v144 )
              return L"URL_CAT_CHAT_INSTANTMESSAGING";
            v145 = v144 - 1;
            if ( !v145 )
              return L"URL_CAT_DATING_PERSONALS";
            v146 = v145 - 1;
            if ( !v146 )
              return L"URL_CAT_DOWNLOAD_SITES";
            if ( v146 == 1 )
              return L"URL_CAT_ENTERTAINMENT";
          }
          else
          {
            if ( a1 == 57354 )
              return L"URL_CAT_COMPROMISED";
            v138 = a1 - 57348;
            if ( !v138 )
              return L"URL_CAT_SPAM";
            v139 = v138 - 1;
            if ( !v139 )
              return L"URL_CAT_BOTNETS";
            v140 = v139 - 1;
            if ( !v140 )
              return L"URL_CAT_ADVERTISEMENTS";
            v141 = v140 - 1;
            if ( !v141 )
              return L"URL_CAT_ALCOHOL_TOBACCO";
            v142 = v141 - 1;
            if ( !v142 )
              return L"URL_CAT_ANONYMIZERS";
            if ( v142 == 1 )
              return L"URL_CAT_BUSINESS";
          }
        }
        else
        {
          if ( a1 == 57347 )
            return L"URL_CAT_PHISHING";
          if ( a1 > 55316 )
          {
            v133 = a1 - 55317;
            if ( !v133 )
              return L"ICMPV6_CODE_ICMP_NODE_INFORMATION_RESPONSE_SUCCESS";
            v134 = v133 - 1;
            if ( !v134 )
              return L"ICMPV6_CODE_ICMP_NODE_INFORMATION_RESPONSE_REFUSED";
            v135 = v134 - 1;
            if ( !v135 )
              return L"ICMPV6_CODE_ICMP_NODE_INFORMATION_RESPONSE_QTYPE_UNKNOWN";
            v136 = v135 - 2025;
            if ( !v136 )
              return L"URL_CATEGORY";
            v137 = v136 - 1;
            if ( !v137 )
              return L"URL_CAT_UNKNOWN";
            if ( v137 == 1 )
              return L"URL_CAT_MALICIOUS";
          }
          else
          {
            if ( a1 == 55316 )
              return L"ICMPV6_CODE_ICMP_NODE_INFORMATION_QUERY_IPV4_ADDRESS_SUBJECT";
            v128 = a1 - 55310;
            if ( !v128 )
              return L"ICMPV6_CODE_PARAMETER_PROBLEM_IPV6_FIRST_FRAGMENT_HAS_INCOMPLETE_IPV6_HEADER_CHAIN";
            v129 = v128 - 1;
            if ( !v129 )
              return L"ICMPV6_CODE_ROUTER_RENUMBERING_COMMAND";
            v130 = v129 - 1;
            if ( !v130 )
              return L"ICMPV6_CODE_ROUTER_RENUMBERING_RESULT";
            v131 = v130 - 1;
            if ( !v131 )
              return L"ICMPV6_CODE_ROUTER_RENUMBERING_SEQUENCE_NUMBER_RESET";
            v132 = v131 - 1;
            if ( !v132 )
              return L"ICMPV6_CODE_ICMP_NODE_INFORMATION_QUERY_IPV6_ADDRESS_SUBJECT";
            if ( v132 == 1 )
              return L"ICMPV6_CODE_ICMP_NODE_INFORMATION_QUERY_NAME_SUBJECT_OR_EMPTY";
          }
        }
        return L"NO_STRING_FOR_THIS_FIELD";
      }
      switch ( a1 )
      {
        case 57361:
          result = L"URL_CAT_FORUMS_NEWSGROUPS";
          break;
        case 57362:
          result = L"URL_CAT_GAMBLING";
          break;
        case 57363:
          result = L"URL_CAT_HACKING";
          break;
        case 57364:
          result = L"URL_CAT_HEALTH_MEDICINE";
          break;
        case 57365:
          result = L"URL_CAT_ILLEGAL";
          break;
        case 57366:
          result = L"URL_CAT_ILLEGAL_DRUG";
          break;
        case 57367:
          result = L"URL_CAT_IMAGE_SHARING";
          break;
        case 57368:
          result = L"URL_CAT_INFORMATION_SECURITY";
          break;
        case 57369:
          result = L"URL_CAT_INTERNET_TOOLS";
          break;
        case 57370:
          result = L"URL_CAT_JOB_SEARCH";
          break;
        case 57371:
          result = L"URL_CAT_NETWORK_ERRORS";
          break;
        case 57372:
          result = L"URL_CAT_NEWS";
          break;
        case 57373:
          result = L"URL_CAT_OFFENSIVE";
          break;
        case 57374:
          result = L"URL_CAT_PARKED_DOMAINS";
          break;
        case 57375:
          result = L"URL_CAT_PEER_TO_PEER";
          break;
        case 57376:
          result = L"URL_CAT_PERSONAL";
          break;
        case 57377:
          result = L"URL_CAT_PORNOGRAPHY_NUDITY";
          break;
        case 57378:
          result = L"URL_CAT_PRIVATE_IP_ADDRESSES";
          break;
        case 57379:
          result = L"URL_CAT_RELIGION";
          break;
        case 57380:
          result = L"URL_CAT_SEX_EDUCATION";
          break;
        case 57381:
          result = L"URL_CAT_SHOPPING";
          break;
        case 57382:
          result = L"URL_CAT_SOCIETY_EDUCATION";
          break;
        case 57383:
          result = L"URL_CAT_STREAMING_DOWNLOADS";
          break;
        case 57384:
          result = L"URL_CAT_TECHNOLOGY";
          break;
        case 57385:
          result = L"URL_CAT_TRANSPORTATION_TRAVEL";
          break;
        case 57386:
          result = L"URL_CAT_WEAPONS";
          break;
        default:
          return L"NO_STRING_FOR_THIS_FIELD";
      }
    }
    else if ( a1 == 51400 )
    {
      result = L"ICMPV6_TYPE_UNASSIGNED_3_UPPER";
    }
    else
    {
      switch ( a1 )
      {
        case 51343:
          result = L"ICMPV6_TYPE_INVERSE_NEIGHBOR_DISCOVERY_ADVERTISEMENT_MESSAGE";
          break;
        case 51344:
          result = L"ICMPV6_TYPE_VERSION_2_MULTICAST_LISTENER_REPORT";
          break;
        case 51345:
          result = L"ICMPV6_TYPE_HOME_AGENT_ADDRESS_DISCOVERY_REQUEST_MESSAGE";
          break;
        case 51346:
          result = L"ICMPV6_TYPE_HOME_AGENT_ADDRESS_DISCOVERY_REPLY_MESSAGE";
          break;
        case 51347:
          result = L"ICMPV6_TYPE_MOBILE_PREFIX_SOLICITATION";
          break;
        case 51348:
          result = L"ICMPV6_TYPE_MOBILE_PREFIX_ADVERTISEMENT";
          break;
        case 51349:
          result = L"ICMPV6_TYPE_CERTIFICATION_PATH_SOLICITATION_MESSAGE";
          break;
        case 51350:
          result = L"ICMPV6_TYPE_CERTIFICATION_PATH_ADVERTISEMENT_MESSAGE";
          break;
        case 51351:
          result = L"ICMPV6_TYPE_ICMP_MESSAGES_UTILIZED_BY_EXPERIMENTAL_MOBILITY_PROTOCOLS";
          break;
        case 51352:
          result = L"ICMPV6_TYPE_MULTICAST_ROUTER_ADVERTISEMENT";
          break;
        case 51353:
          result = L"ICMPV6_TYPE_MULTICAST_ROUTER_SOLICITATION";
          break;
        case 51354:
          result = L"ICMPV6_TYPE_MULTICAST_ROUTER_TERMINATION";
          break;
        case 51355:
          result = L"ICMPV6_TYPE_FMIPV6_MESSAGES";
          break;
        case 51356:
          result = L"ICMPV6_TYPE_RPL_CONTROL_MESSAGE";
          break;
        case 51357:
          result = L"ICMPV6_TYPE_ILNPV6_LOCATOR_UPDATE_MESSAGE";
          break;
        case 51358:
          result = L"ICMPV6_TYPE_DUPLICATE_ADDRESS_REQUEST";
          break;
        case 51359:
          result = L"ICMPV6_TYPE_DUPLICATE_ADDRESS_CONFIRMATION";
          break;
        case 51360:
          result = L"ICMPV6_TYPE_UNASSIGNED_3_LOWER";
          break;
        default:
          return L"NO_STRING_FOR_THIS_FIELD";
      }
    }
  }
  else
  {
    if ( a1 == 51342 )
      return L"ICMPV6_TYPE_INVERSE_NEIGHBOR_DISCOVERY_SOLICITATION_MESSAGE";
    if ( a1 > 40976 )
    {
      if ( a1 <= 49188 )
      {
        if ( a1 == 49188 )
          return L"ICMP_TYPE_MOBILE_REGISTRATION_REQUEST";
        if ( a1 > 49158 )
        {
          if ( a1 > 49167 )
          {
            v72 = a1 - 49170;
            if ( !v72 )
              return L"ICMP_TYPE_ADDRESS_MASK_REQUEST";
            v73 = v72 - 1;
            if ( !v73 )
              return L"ICMP_TYPE_ADDRESS_MASK_REPLY";
            v74 = v73 - 12;
            if ( !v74 )
              return L"ICMP_TYPE_TRACEROUTE";
            v75 = v74 - 1;
            if ( !v75 )
              return L"ICMP_TYPE_DATAGRAM_CONVERSION_ERROR";
            v76 = v75 - 1;
            if ( !v76 )
              return L"ICMP_TYPE_MOBILE_HOST_REDIRECT";
            v77 = v76 - 1;
            if ( !v77 )
              return L"ICMP_TYPE_IPV6_WHERE_ARE_YOU";
            if ( v77 == 1 )
              return L"ICMP_TYPE_IPV6_I_AM_HERE";
          }
          else
          {
            if ( a1 == 49167 )
              return L"ICMP_TYPE_TIMESTAMP_REPLY";
            v66 = a1 - 49159;
            if ( !v66 )
              return L"ICMP_TYPE_ALTERNATE_HOST_ADDR";
            v67 = v66 - 2;
            if ( !v67 )
              return L"ICMP_TYPE_ECHO_REQUEST";
            v68 = v67 - 1;
            if ( !v68 )
              return L"ICMP_TYPE_ROUTER_ADVERTISEMENT";
            v69 = v68 - 1;
            if ( !v69 )
              return L"ICMP_TYPE_ROUTER_SOLICITATION";
            v70 = v69 - 1;
            if ( !v70 )
              return L"ICMP_TYPE_TIME_EXCEEDED";
            v71 = v70 - 1;
            if ( !v71 )
              return L"ICMP_TYPE_PARAMETER_PROBLEM";
            if ( v71 == 1 )
              return L"ICMP_TYPE_TIMESTAMP";
          }
        }
        else
        {
          if ( a1 == 49158 )
            return L"ICMP_TYPE_REDIRECT";
          if ( a1 > 40984 )
          {
            v60 = a1 - 45056;
            if ( !v60 )
              return L"COMM_DIRECTION";
            v61 = v60 - 1;
            if ( !v61 )
              return L"COMM_DIRECTION_INCOMING";
            v62 = v61 - 1;
            if ( !v62 )
              return L"COMM_DIRECTION_OUTGOING";
            v63 = v62 - 4094;
            if ( !v63 )
              return L"ICMP_TYPE";
            v64 = v63 - 1;
            if ( !v64 )
              return L"ICMP_TYPE_ECHO_REPLY";
            v65 = v64 - 3;
            if ( !v65 )
              return L"ICMP_TYPE_DESTINATION_UNREACHABLE";
            if ( v65 == 1 )
              return L"ICMP_TYPE_SOURCE_QUENCH";
          }
          else
          {
            if ( a1 == 40984 )
              return L"OPERATION_MODESUPERSEDE";
            v54 = a1 - 40977;
            if ( !v54 )
              return L"OPERATION_WRITE";
            v55 = v54 - 1;
            if ( !v55 )
              return L"OPERATION_CLOSE";
            v56 = v55 - 1;
            if ( !v56 )
              return L"OPERATION_VOLUMEMOUNT";
            v57 = v56 - 1;
            if ( !v57 )
              return L"OPERATION_VOLUMEUNMOUNT";
            v58 = v57 - 1;
            if ( !v58 )
              return L"OPERATION_SET_ATTRIBUTES";
            v59 = v58 - 1;
            if ( !v59 )
              return L"OPERATION_CREATE";
            if ( v59 == 1 )
              return L"OPERATION_MODEOVERWRITE";
          }
        }
        return L"NO_STRING_FOR_THIS_FIELD";
      }
      if ( a1 <= 51303 )
      {
        if ( a1 == 51303 )
          return L"ICMPV6_TYPE_UNASSIGNED_2_LOWER";
        if ( a1 > 51202 )
        {
          v84 = a1 - 51203;
          if ( !v84 )
            return L"ICMPV6_TYPE_PACKET_TOO_BIG";
          v85 = v84 - 1;
          if ( !v85 )
            return L"ICMPV6_TYPE_TIME_EXCEEDED";
          v86 = v85 - 1;
          if ( !v86 )
            return L"ICMPV6_TYPE_PARAMETER_PROBLEM";
          v87 = v86 - 1;
          if ( !v87 )
            return L"ICMPV6_TYPE_UNASSIGNED_1_LOWER";
          v88 = v87 - 94;
          if ( !v88 )
            return L"ICMPV6_TYPE_UNASSIGNED_1_UPPER";
          v89 = v88 - 1;
          if ( !v89 )
            return L"ICMPV6_TYPE_PRIVATE_EXPERIMENTATION_1";
          if ( v89 == 1 )
            return L"ICMPV6_TYPE_PRIVATE_EXPERIMENTATION_2";
        }
        else
        {
          if ( a1 == 51202 )
            return L"ICMPV6_TYPE_DESTINATION_UNREACHABLE";
          v78 = a1 - 49189;
          if ( !v78 )
            return L"ICMP_TYPE_MOBILE_REGISTRATION_REPLY";
          v79 = v78 - 1;
          if ( !v79 )
            return L"ICMP_TYPE_DOMAIN_NAME_REQUEST";
          v80 = v79 - 1;
          if ( !v80 )
            return L"ICMP_TYPE_DOMAIN_NAME_REPLY";
          v81 = v80 - 1;
          if ( !v81 )
            return L"ICMP_TYPE_SKIP";
          v82 = v81 - 1;
          if ( !v82 )
            return L"ICMP_TYPE_PHOTURIS";
          v83 = v82 - 2007;
          if ( !v83 )
            return L"ICMPV6_TYPE";
          if ( v83 == 1 )
            return L"ICMPV6_TYPE_RESERVED";
        }
        return L"NO_STRING_FOR_THIS_FIELD";
      }
      switch ( a1 )
      {
        case 51327:
          result = L"ICMPV6_TYPE_UNASSIGNED_2_UPPER";
          break;
        case 51328:
          result = L"ICMPV6_TYPE_RESERVED_FOR_EXPANSION_OF_ICMPV6_ERROR_MESSAGES";
          break;
        case 51329:
          result = L"ICMPV6_TYPE_ECHO_REQUEST";
          break;
        case 51330:
          result = L"ICMPV6_TYPE_ECHO_REPLY";
          break;
        case 51331:
          result = L"ICMPV6_TYPE_MULTICAST_LISTENER_QUERY";
          break;
        case 51332:
          result = L"ICMPV6_TYPE_MULTICAST_LISTENER_REPORT";
          break;
        case 51333:
          result = L"ICMPV6_TYPE_MULTICAST_LISTENER_DONE";
          break;
        case 51334:
          result = L"ICMPV6_TYPE_ROUTER_SOLICITATION";
          break;
        case 51335:
          result = L"ICMPV6_TYPE_ROUTER_ADVERTISEMENT";
          break;
        case 51336:
          result = L"ICMPV6_TYPE_NEIGHBOR_SOLICITATION";
          break;
        case 51337:
          result = L"ICMPV6_TYPE_NEIGHBOR_ADVERTISEMENT";
          break;
        case 51338:
          result = L"ICMPV6_TYPE_REDIRECT_MESSAGE";
          break;
        case 51339:
          result = L"ICMPV6_TYPE_ROUTER_RENUMBERING";
          break;
        case 51340:
          result = L"ICMPV6_TYPE_ICMP_NODE_INFORMATION_QUERY";
          break;
        case 51341:
          result = L"ICMPV6_TYPE_ICMP_NODE_INFORMATION_RESPONSE";
          break;
        default:
          return L"NO_STRING_FOR_THIS_FIELD";
      }
    }
    else
    {
      if ( a1 == 40976 )
        return L"OPERATION_LOAD";
      if ( a1 <= 1106 )
      {
        if ( a1 == 1106 )
          return L"HEADER_STAGE_NORMAL";
        if ( a1 > 1084 )
        {
          if ( a1 > 1092 )
          {
            v36 = a1 - 1093;
            if ( !v36 )
              return L"HEADER_CATEGORIES_KERNEL";
            v37 = v36 - 1;
            if ( !v37 )
              return L"HEADER_CATEGORIES_PROTEUS";
            v38 = v37 - 1;
            if ( !v38 )
              return L"HEADER_CATEGORIES_SECURITY";
            v39 = v38 - 4;
            if ( !v39 )
              return L"HEADER_CATEGORIES_FIREWALL_ISOLATION";
            v40 = v39 - 1;
            if ( !v40 )
              return L"HEADER_CATEGORIES_FIREWALL_ISOLATION_AUX";
            v41 = v40 - 4;
            if ( !v41 )
              return L"HEADER_STAGE";
            if ( v41 == 1 )
              return L"HEADER_STAGE_BOOT";
          }
          else
          {
            if ( a1 == 1092 )
              return L"HEADER_CATEGORIES_FIREWALL_ADMIN";
            v30 = a1 - 1085;
            if ( !v30 )
              return L"HEADER_CATEGORIES_SELFPROTECTION";
            v31 = v30 - 1;
            if ( !v31 )
              return L"HEADER_CATEGORIES_KRE";
            v32 = v31 - 1;
            if ( !v32 )
              return L"HEADER_CATEGORIES_NETVIRUS";
            v33 = v32 - 1;
            if ( !v33 )
              return L"HEADER_CATEGORIES_FIREWALL";
            v34 = v33 - 1;
            if ( !v34 )
              return L"HEADER_CATEGORIES_FIREWALL_USER";
            v35 = v34 - 1;
            if ( !v35 )
              return L"HEADER_CATEGORIES_FIREWALL_PANDA";
            if ( v35 == 1 )
              return L"HEADER_CATEGORIES_FIREWALL_SAFEBOOT";
          }
        }
        else
        {
          if ( a1 == 1084 )
            return L"HEADER_CATEGORIES";
          if ( a1 > 1046 )
          {
            v24 = a1 - 1064;
            if ( !v24 )
              return L"HEADER_VERSION";
            v25 = v24 - 1;
            if ( !v25 )
              return L"HEADER_DESCRIPTION";
            v26 = v25 - 1;
            if ( !v26 )
              return L"HEADER_GUID";
            v27 = v26 - 1;
            if ( !v27 )
              return L"HEADER_GROUP_ID";
            v28 = v27 - 1;
            if ( !v28 )
              return L"HEADER_PRIORITY";
            v29 = v28 - 1;
            if ( !v29 )
              return L"HEADER_FOOTPRINT";
            if ( v29 == 1 )
              return L"HEADER_SNORT_ID";
          }
          else
          {
            if ( a1 == 1046 )
              return L"HEADER_STATE_DISABLED";
            v18 = a1 - 1025;
            if ( !v18 )
              return L"HEADER_SEVERITY";
            v19 = v18 - 1;
            if ( !v19 )
              return L"HEADER_SEVERITY_CRITICAL";
            v20 = v19 - 1;
            if ( !v20 )
              return L"HEADER_SEVERITY_HIGH";
            v21 = v20 - 1;
            if ( !v21 )
              return L"HEADER_SEVERITY_MEDIUM";
            v22 = v21 - 1;
            if ( !v22 )
              return L"HEADER_SEVERITY_LOW";
            v23 = v22 - 15;
            if ( !v23 )
              return L"HEADER_STATE";
            if ( v23 == 1 )
              return L"HEADER_STATE_ENABLED";
          }
        }
        return L"NO_STRING_FOR_THIS_FIELD";
      }
      if ( a1 <= 40960 )
      {
        if ( a1 == 40960 )
          return L"OPERATION";
        if ( a1 > 36864 )
        {
          v48 = a1 - 36865;
          if ( !v48 )
            return L"TARGET_INFO_FILE";
          v49 = v48 - 1;
          if ( !v49 )
            return L"TARGET_INFO_REGISTRY";
          v50 = v49 - 1;
          if ( !v50 )
            return L"TARGET_INFO_SERVICE";
          v51 = v50 - 1;
          if ( !v51 )
            return L"TARGET_INFO_NETWORK_PACKET";
          v52 = v51 - 1;
          if ( !v52 )
            return L"TARGET_INFO_PROCESS";
          v53 = v52 - 1;
          if ( !v53 )
            return L"TARGET_INFO_THREAD";
          if ( v53 == 1 )
            return L"TARGET_INFO_URL";
        }
        else
        {
          if ( a1 == 36864 )
            return L"TARGET_INFO";
          v42 = a1 - 1124;
          if ( !v42 )
            return L"HEADER_STATEFUL";
          v43 = v42 - 1;
          if ( !v43 )
            return L"HEADER_ZONE";
          v44 = v43 - 922;
          if ( !v44 )
            return L"ETH_PROTOCOL";
          v45 = v44 - 1;
          if ( !v45 )
            return L"ETH_PROTOCOL_IPV4";
          v46 = v45 - 6;
          if ( !v46 )
            return L"ETH_PROTOCOL_ARP";
          v47 = v46 - 30767;
          if ( !v47 )
            return L"ETH_PROTOCOL_RARP";
          if ( v47 == 1704 )
            return L"ETH_PROTOCOL_IPV6";
        }
        return L"NO_STRING_FOR_THIS_FIELD";
      }
      switch ( a1 )
      {
        case 40961:
          result = L"OPERATION_NONE";
          break;
        case 40962:
          result = L"OPERATION_ALL_OPS";
          break;
        case 40963:
          result = L"OPERATION_READ";
          break;
        case 40964:
          result = L"OPERATION_OPEN";
          break;
        case 40965:
          result = L"OPERATION_RENAME";
          break;
        case 40966:
          result = L"OPERATION_MODIFY";
          break;
        case 40967:
          result = L"OPERATION_DELETE";
          break;
        case 40968:
          result = L"OPERATION_QUERY";
          break;
        case 40969:
          result = L"OPERATION_TERMINATE";
          break;
        case 40970:
          result = L"OPERATION_END";
          break;
        case 40971:
          result = L"OPERATION_SET_ALLOC_SIZE";
          break;
        case 40972:
          result = L"OPERATION_CREATE_HARD_LINK";
          break;
        case 40973:
          result = L"OPERATION_TRANSACTION_COMMIT";
          break;
        case 40974:
          result = L"OPERATION_TRANSACTION_ROLLBACK";
          break;
        case 40975:
          result = L"OPERATION_EXECUTE";
          break;
        default:
          return L"NO_STRING_FOR_THIS_FIELD";
      }
    }
  }
  return result;
}
// 4E258: using guessed type wchar_t aTypeUnknown[13];
// 56FB0: using guessed type wchar_t aNoStringForThi[25];
// 56FE8: using guessed type wchar_t aUnknown_0[8];
// 56FF8: using guessed type wchar_t aPath[5];
// 57008: using guessed type wchar_t aSrcPath[9];
// 57020: using guessed type wchar_t aPathHash[10];
// 57038: using guessed type wchar_t aAppName[9];
// 57050: using guessed type wchar_t aAppNameHash[14];
// 57070: using guessed type wchar_t aPid[4];
// 57078: using guessed type wchar_t aSrcPid[8];
// 57088: using guessed type wchar_t aTid[4];
// 57090: using guessed type wchar_t aSrcTid[8];
// 570A0: using guessed type wchar_t aUserSid[9];
// 570B8: using guessed type wchar_t aShareMode[11];
// 570D0: using guessed type wchar_t aAttributes[11];
// 570E8: using guessed type wchar_t aShowwindow[11];
// 57100: using guessed type wchar_t aCommandline[12];
// 57118: using guessed type wchar_t aTransactionId[15];
// 57138: using guessed type wchar_t aExtension[10];
// 57150: using guessed type wchar_t aAccessMode[12];
// 57168: using guessed type wchar_t aBuffer[7];
// 57178: using guessed type wchar_t aBuffersize[11];
// 57190: using guessed type wchar_t aFileoffset[11];
// 571A8: using guessed type wchar_t aDisposition[12];
// 571C0: using guessed type wchar_t aPrltext[8];
// 571D0: using guessed type wchar_t aSafeboot[9];
// 571E8: using guessed type wchar_t aOptions[8];
// 571F8: using guessed type wchar_t aCreateMode[12];
// 57210: using guessed type wchar_t aCreateOptions[15];
// 57230: using guessed type wchar_t aAllocationSize[16];
// 57250: using guessed type wchar_t aSourceIp[10];
// 57268: using guessed type wchar_t aDestinationIp[15];
// 57288: using guessed type wchar_t aSourcePort[12];
// 572A0: using guessed type wchar_t aDestinationPor[17];
// 572C8: using guessed type wchar_t aSourceMac[11];
// 572E0: using guessed type wchar_t aDestinationMac[16];
// 57300: using guessed type wchar_t aUserProfile[13];
// 57320: using guessed type wchar_t aIpProtocol[12];
// 57338: using guessed type wchar_t aIpProtocolHopo[19];
// 57360: using guessed type wchar_t aIpProtocolIcmp[17];
// 57388: using guessed type wchar_t aIpProtocolIgmp[17];
// 573B0: using guessed type wchar_t aIpProtocolGgp[16];
// 573D0: using guessed type wchar_t aIpProtocolIpv4[17];
// 573F8: using guessed type wchar_t aIpProtocolSt[15];
// 57418: using guessed type wchar_t aIpProtocolTcp[16];
// 57438: using guessed type wchar_t aIpProtocolCbt[16];
// 57458: using guessed type wchar_t aIpProtocolEgp[16];
// 57478: using guessed type wchar_t aIpProtocolIgp[16];
// 57498: using guessed type wchar_t aIpProtocolBbnR[24];
// 574C8: using guessed type wchar_t aIpProtocolNvpI[19];
// 574F0: using guessed type wchar_t aIpProtocolPup[16];
// 57510: using guessed type wchar_t aIpProtocolArgu[18];
// 57538: using guessed type wchar_t aIpProtocolEmco[18];
// 57560: using guessed type wchar_t aIpProtocolXnet[17];
// 57588: using guessed type wchar_t aIpProtocolChao[18];
// 575B0: using guessed type wchar_t aIpProtocolUdp[16];
// 575D0: using guessed type wchar_t aIpProtocolMux[16];
// 575F0: using guessed type wchar_t aIpProtocolDcnM[21];
// 57620: using guessed type wchar_t aIpProtocolHmp[16];
// 57640: using guessed type wchar_t aIpProtocolPrm[16];
// 57660: using guessed type wchar_t aIpProtocolXnsI[20];
// 57688: using guessed type wchar_t aIpProtocolTrun[20];
// 576B0: using guessed type wchar_t aIpProtocolTrun_0[20];
// 576D8: using guessed type wchar_t aIpProtocolLeaf[19];
// 57700: using guessed type wchar_t aIpProtocolLeaf_0[19];
// 57728: using guessed type wchar_t aIpProtocolRdp[16];
// 57748: using guessed type wchar_t aIpProtocolIrtp[17];
// 57770: using guessed type wchar_t aIpProtocolIsoT[20];
// 57798: using guessed type wchar_t aIpProtocolNetb[19];
// 577C0: using guessed type wchar_t aIpProtocolMfeN[20];
// 577E8: using guessed type wchar_t aIpProtocolMeri[22];
// 57818: using guessed type wchar_t aIpProtocolDccp[17];
// 57840: using guessed type wchar_t aIpProtocol3pc[16];
// 57860: using guessed type wchar_t aIpProtocolIdpr[17];
// 57888: using guessed type wchar_t aIpProtocolXtp[16];
// 578A8: using guessed type wchar_t aIpProtocolDdp[16];
// 578C8: using guessed type wchar_t aIpProtocolIdpr_0[22];
// 578F8: using guessed type wchar_t aIpProtocolTpPl[25];
// 57930: using guessed type wchar_t aIpProtocolIl[15];
// 57950: using guessed type wchar_t aIpProtocolIpv6[17];
// 57978: using guessed type wchar_t aIpProtocolSdrp[17];
// 579A0: using guessed type wchar_t aIpProtocolIpv6_0[23];
// 579D0: using guessed type wchar_t aIpProtocolIpv6_1[22];
// 57A00: using guessed type wchar_t aIpProtocolIdrp[17];
// 57A28: using guessed type wchar_t aIpProtocolRsvp[17];
// 57A50: using guessed type wchar_t aIpProtocolGre[16];
// 57A70: using guessed type wchar_t aIpProtocolDsr[16];
// 57A90: using guessed type wchar_t aIpProtocolBna[16];
// 57AB0: using guessed type wchar_t aIpProtocolEsp[16];
// 57AD0: using guessed type wchar_t aIpProtocolAh[15];
// 57AF0: using guessed type wchar_t aIpProtocolINls[19];
// 57B18: using guessed type wchar_t aIpProtocolSwip[18];
// 57B40: using guessed type wchar_t aIpProtocolNarp[17];
// 57B68: using guessed type wchar_t aIpProtocolMobi[19];
// 57B90: using guessed type wchar_t aIpProtocolTlsp[17];
// 57BB8: using guessed type wchar_t aIpProtocolSkip[17];
// 57BE0: using guessed type wchar_t aIpProtocolIcmp_0[19];
// 57C08: using guessed type wchar_t aIpProtocolIpv6_2[24];
// 57C38: using guessed type wchar_t aIpProtocolIpv6_3[22];
// 57C68: using guessed type wchar_t aIpProtocolProt[24];
// 57C98: using guessed type wchar_t aIpProtocolCftp[17];
// 57CC0: using guessed type wchar_t aIpProtocolProt_0[24];
// 57CF0: using guessed type wchar_t aIpProtocolSatE[22];
// 57D20: using guessed type wchar_t aIpProtocolKryp[22];
// 57D50: using guessed type wchar_t aIpProtocolRvd[16];
// 57D70: using guessed type wchar_t aIpProtocolIppc[17];
// 57D98: using guessed type wchar_t aIpProtocolProt_1[24];
// 57DC8: using guessed type wchar_t aIpProtocolSatM[20];
// 57DF0: using guessed type wchar_t aIpProtocolVisa[17];
// 57E18: using guessed type wchar_t aIpProtocolIpcv[17];
// 57E40: using guessed type wchar_t aIpProtocolCpnx[17];
// 57E68: using guessed type wchar_t aIpProtocolCphb[17];
// 57E90: using guessed type wchar_t aIpProtocolWsn[16];
// 57EB0: using guessed type wchar_t aIpProtocolPvp[16];
// 57ED0: using guessed type wchar_t aIpProtocolBrSa[23];
// 57F00: using guessed type wchar_t aIpProtocolSunN[19];
// 57F28: using guessed type wchar_t aIpProtocolWbMo[19];
// 57F50: using guessed type wchar_t aIpProtocolWbEx[21];
// 57F80: using guessed type wchar_t aIpProtocolIsoI[19];
// 57FA8: using guessed type wchar_t aIpProtocolVmtp[17];
// 57FD0: using guessed type wchar_t aIpProtocolSecu[24];
// 58000: using guessed type wchar_t aIpProtocolVine[18];
// 58028: using guessed type wchar_t aIpProtocolTtp[16];
// 58048: using guessed type wchar_t aIpProtocolNsfn[23];
// 58078: using guessed type wchar_t aIpProtocolDgp[16];
// 58098: using guessed type wchar_t aIpProtocolTcf[16];
// 580B8: using guessed type wchar_t aIpProtocolEigr[18];
// 580E0: using guessed type wchar_t aIpProtocolOspf[20];
// 58108: using guessed type wchar_t aIpProtocolSpri[23];
// 58138: using guessed type wchar_t aIpProtocolLarp[17];
// 58160: using guessed type wchar_t aIpProtocolMtp[16];
// 58180: using guessed type wchar_t aIpProtocolAx25[18];
// 581A8: using guessed type wchar_t aIpProtocolIpip[17];
// 581D0: using guessed type wchar_t aIpProtocolMicp[17];
// 581F8: using guessed type wchar_t aIpProtocolSccS[19];
// 58220: using guessed type wchar_t aIpProtocolEthe[20];
// 58248: using guessed type wchar_t aIpProtocolEnca[18];
// 58270: using guessed type wchar_t aIpProtocolProt_2[24];
// 582A0: using guessed type wchar_t aIpProtocolGmtp[17];
// 582C8: using guessed type wchar_t aIpProtocolIfmp[17];
// 582F0: using guessed type wchar_t aIpProtocolPnni[17];
// 58318: using guessed type wchar_t aIpProtocolPim[16];
// 58338: using guessed type wchar_t aIpProtocolAris[17];
// 58360: using guessed type wchar_t aIpProtocolScps[17];
// 58388: using guessed type wchar_t aIpProtocolQnx[16];
// 583A8: using guessed type wchar_t aIpProtocolAN[16];
// 583C8: using guessed type wchar_t aIpProtocolIpCo[20];
// 583F0: using guessed type wchar_t aIpProtocolSnp[16];
// 58410: using guessed type wchar_t aIpProtocolComp[24];
// 58440: using guessed type wchar_t aIpProtocolIpxI[22];
// 58470: using guessed type wchar_t aIpProtocolVrrp[17];
// 58498: using guessed type wchar_t aIpProtocolPgm[16];
// 584B8: using guessed type wchar_t aIpProtocolProt_3[25];
// 584F0: using guessed type wchar_t aIpProtocolL2tp[17];
// 58518: using guessed type wchar_t aIpProtocolDdx[16];
// 58538: using guessed type wchar_t aIpProtocolIatp[17];
// 58560: using guessed type wchar_t aIpProtocolStp[16];
// 58580: using guessed type wchar_t aIpProtocolSrp[16];
// 585A0: using guessed type wchar_t aIpProtocolUti[16];
// 585C0: using guessed type wchar_t aIpProtocolSmp[16];
// 585E0: using guessed type wchar_t aIpProtocolSm[15];
// 58600: using guessed type wchar_t aIpProtocolPtp[16];
// 58620: using guessed type wchar_t aIpProtocolIsis[27];
// 58658: using guessed type wchar_t aIpProtocolFire[17];
// 58680: using guessed type wchar_t aIpProtocolCrtp[17];
// 586A8: using guessed type wchar_t aIpProtocolCrud[18];
// 586D0: using guessed type wchar_t aIpProtocolSsco[21];
// 58700: using guessed type wchar_t aIpProtocolIplt[17];
// 58728: using guessed type wchar_t aIpProtocolSps[16];
// 58748: using guessed type wchar_t aIpProtocolPipe[17];
// 58770: using guessed type wchar_t aIpProtocolSctp[17];
// 58798: using guessed type wchar_t aIpProtocolFc[15];
// 587B8: using guessed type wchar_t aIpProtocolRsvp_0[28];
// 587F0: using guessed type wchar_t aIpProtocolMobi_0[28];
// 58828: using guessed type wchar_t aIpProtocolUdpL[21];
// 58858: using guessed type wchar_t aIpProtocolMpls[23];
// 58888: using guessed type wchar_t aIpProtocolMane[18];
// 588B0: using guessed type wchar_t aIpProtocolHip[16];
// 588D0: using guessed type wchar_t aIpProtocolShim[18];
// 588F8: using guessed type wchar_t aIpProtocolWesp[17];
// 58920: using guessed type wchar_t aIpProtocolRohc[17];
// 58948: using guessed type wchar_t aAlProtocol[12];
// 58960: using guessed type wchar_t aAlProtocolDns[16];
// 58980: using guessed type wchar_t aAlProtocolDhcp_0[17];
// 589A8: using guessed type wchar_t aAlProtocolHttp_0[17];
// 589D0: using guessed type wchar_t aAlProtocolHttp[18];
// 589F8: using guessed type wchar_t aAlProtocolSmtp[17];
// 58A20: using guessed type wchar_t aAlProtocolFtp[16];
// 58A40: using guessed type wchar_t aAlProtocolPop3[17];
// 58A68: using guessed type wchar_t aAlProtocolDhcp[19];
// 58A90: using guessed type wchar_t aAction[7];
// 58AA0: using guessed type wchar_t aActionAllow[13];
// 58AC0: using guessed type wchar_t aActionDeny[12];
// 58AD8: using guessed type wchar_t aActionNotify[14];
// 58AF8: using guessed type wchar_t aActionSend[12];
// 58B10: using guessed type wchar_t aActionCall[12];
// 58B28: using guessed type wchar_t aActionReport[14];
// 58B48: using guessed type wchar_t aActionGroup[13];
// 58B68: using guessed type wchar_t aActionUngroup[15];
// 58B88: using guessed type wchar_t aActionActivate[16];
// 58BA8: using guessed type wchar_t aActionDeactiva[18];
// 58BD0: using guessed type wchar_t aActionDrop[12];
// 58BE8: using guessed type wchar_t aActionAsk[11];
// 58C00: using guessed type wchar_t aHeader[7];
// 58C10: using guessed type wchar_t aHeaderSeverity_3[16];
// 58C30: using guessed type wchar_t aHeaderSeverity_2[25];
// 58C68: using guessed type wchar_t aHeaderSeverity_1[21];
// 58C98: using guessed type wchar_t aHeaderSeverity_0[23];
// 58CC8: using guessed type wchar_t aHeaderSeverity[20];
// 58CF0: using guessed type wchar_t aHeaderState[13];
// 58D10: using guessed type wchar_t aHeaderStateEna[21];
// 58D40: using guessed type wchar_t aHeaderStateDis[22];
// 58D70: using guessed type wchar_t aHeaderVersion[15];
// 58D90: using guessed type wchar_t aHeaderDescript[19];
// 58DB8: using guessed type wchar_t aHeaderGuid[12];
// 58DD0: using guessed type wchar_t aHeaderGroupId[16];
// 58DF0: using guessed type wchar_t aHeaderPriority[16];
// 58E10: using guessed type wchar_t aHeaderFootprin[17];
// 58E38: using guessed type wchar_t aHeaderSnortId[16];
// 58E58: using guessed type wchar_t aHeaderCategori[18];
// 58E80: using guessed type wchar_t aHeaderCategori_6[33];
// 58EC8: using guessed type wchar_t aHeaderCategori_5[22];
// 58EF8: using guessed type wchar_t aHeaderCategori_4[27];
// 58F30: using guessed type wchar_t aHeaderCategori_3[27];
// 58F70: using guessed type wchar_t aHeaderCategori_9[37];
// 58FC0: using guessed type wchar_t aHeaderCategori_8[41];
// 59020: using guessed type wchar_t aHeaderCategori_2[32];
// 59060: using guessed type wchar_t aHeaderCategori_1[33];
// 590B0: using guessed type wchar_t aHeaderCategori_0[36];
// 59100: using guessed type wchar_t aHeaderCategori_7[33];
// 59148: using guessed type wchar_t aHeaderCategori_12[25];
// 59180: using guessed type wchar_t aHeaderCategori_11[26];
// 591B8: using guessed type wchar_t aHeaderCategori_10[27];
// 591F0: using guessed type wchar_t aHeaderStage[13];
// 59210: using guessed type wchar_t aHeaderStageBoo[18];
// 59238: using guessed type wchar_t aHeaderStageNor[20];
// 59260: using guessed type wchar_t aHeaderStateful[16];
// 59280: using guessed type wchar_t aHeaderZone[12];
// 59298: using guessed type wchar_t aTargetInfo[12];
// 592B0: using guessed type wchar_t aTargetInfoFile[17];
// 592D8: using guessed type wchar_t aTargetInfoRegi[21];
// 59308: using guessed type wchar_t aTargetInfoServ[20];
// 59330: using guessed type wchar_t aTargetInfoNetw[27];
// 59368: using guessed type wchar_t aTargetInfoProc[20];
// 59390: using guessed type wchar_t aTargetInfoThre[19];
// 593B8: using guessed type wchar_t aTargetInfoUrl[16];
// 593D8: using guessed type wchar_t aOperation[10];
// 593F0: using guessed type wchar_t aOperationNone[15];
// 59410: using guessed type wchar_t aOperationAllOp[18];
// 59438: using guessed type wchar_t aOperationRead[15];
// 59458: using guessed type wchar_t aOperationOpen[15];
// 59478: using guessed type wchar_t aOperationRenam[17];
// 594A0: using guessed type wchar_t aOperationModif[17];
// 594C8: using guessed type wchar_t aOperationDelet[17];
// 594F0: using guessed type wchar_t aOperationQuery[16];
// 59510: using guessed type wchar_t aOperationTermi[20];
// 59538: using guessed type wchar_t aOperationEnd[14];
// 59558: using guessed type wchar_t aOperationSetAl[25];
// 59590: using guessed type wchar_t aOperationCreat[27];
// 595C8: using guessed type wchar_t aOperationTrans[29];
// 59608: using guessed type wchar_t aOperationTrans_0[31];
// 59648: using guessed type wchar_t aOperationExecu[18];
// 59670: using guessed type wchar_t aOperationLoad[15];
// 59690: using guessed type wchar_t aOperationWrite[16];
// 596B0: using guessed type wchar_t aOperationClose[16];
// 596D0: using guessed type wchar_t aOperationVolum_0[22];
// 59700: using guessed type wchar_t aOperationVolum[24];
// 59730: using guessed type wchar_t aOperationSetAt[25];
// 59768: using guessed type wchar_t aOperationCreat_0[17];
// 59790: using guessed type wchar_t aOperationModeo[24];
// 597C0: using guessed type wchar_t aOperationModes[24];
// 597F0: using guessed type wchar_t aCommDirection[15];
// 59810: using guessed type wchar_t aCommDirectionI[24];
// 59840: using guessed type wchar_t aCommDirectionO[24];
// 59870: using guessed type wchar_t aEthProtocol[13];
// 59890: using guessed type wchar_t aEthProtocolIpv_0[18];
// 598B8: using guessed type wchar_t aEthProtocolIpv[18];
// 598E0: using guessed type wchar_t aEthProtocolArp[17];
// 59908: using guessed type wchar_t aEthProtocolRar[18];
// 59930: using guessed type wchar_t aIcmpType[10];
// 59948: using guessed type wchar_t aIcmpTypeEchoRe[21];
// 59980: using guessed type wchar_t aIcmpTypeDestin[34];
// 599C8: using guessed type wchar_t aIcmpTypeSource[24];
// 599F8: using guessed type wchar_t aIcmpTypeRedire[19];
// 59A20: using guessed type wchar_t aIcmpTypeAltern[30];
// 59A60: using guessed type wchar_t aIcmpTypeEchoRe_0[23];
// 59A90: using guessed type wchar_t aIcmpTypeRouter_0[31];
// 59AD0: using guessed type wchar_t aIcmpTypeRouter[30];
// 59B10: using guessed type wchar_t aIcmpTypeTimeEx[24];
// 59B40: using guessed type wchar_t aIcmpTypeParame[28];
// 59B78: using guessed type wchar_t aIcmpTypeTimest[20];
// 59BA0: using guessed type wchar_t aIcmpTypeTimest_0[26];
// 59BD8: using guessed type wchar_t aIcmpTypeAddres_0[31];
// 59C18: using guessed type wchar_t aIcmpTypeAddres[29];
// 59C58: using guessed type wchar_t aIcmpTypeTracer[21];
// 59C90: using guessed type wchar_t aIcmpTypeDatagr[36];
// 59CD8: using guessed type wchar_t aIcmpTypeMobile[31];
// 59D18: using guessed type wchar_t aIcmpTypeIpv6Wh[29];
// 59D58: using guessed type wchar_t aIcmpTypeIpv6IA[25];
// 59D90: using guessed type wchar_t aIcmpTypeMobile_0[38];
// 59DE0: using guessed type wchar_t aIcmpTypeMobile_1[36];
// 59E28: using guessed type wchar_t aIcmpTypeDomain_0[30];
// 59E68: using guessed type wchar_t aIcmpTypeDomain[28];
// 59EA0: using guessed type wchar_t aIcmpTypeSkip[15];
// 59EC0: using guessed type wchar_t aIcmpTypePhotur[19];
// 59EE8: using guessed type wchar_t aIcmpv6Type[12];
// 59F00: using guessed type wchar_t aIcmpv6TypeRese[21];
// 59F30: using guessed type wchar_t aIcmpv6TypeDest[36];
// 59F78: using guessed type wchar_t aIcmpv6TypePack[27];
// 59FB0: using guessed type wchar_t aIcmpv6TypeTime[26];
// 59FE8: using guessed type wchar_t aIcmpv6TypePara[30];
// 5A028: using guessed type wchar_t aIcmpv6TypeUnas_0[31];
// 5A068: using guessed type wchar_t aIcmpv6TypeUnas[31];
// 5A0B0: using guessed type wchar_t aIcmpv6TypePriv_0[38];
// 5A100: using guessed type wchar_t aIcmpv6TypePriv[38];
// 5A150: using guessed type wchar_t aIcmpv6TypeUnas_1[31];
// 5A190: using guessed type wchar_t aIcmpv6TypeUnas_2[31];
// 5A1D0: using guessed type wchar_t aIcmpv6TypeRese_0[60];
// 5A248: using guessed type wchar_t aIcmpv6TypeEcho[25];
// 5A280: using guessed type wchar_t aIcmpv6TypeEcho_0[23];
// 5A2B0: using guessed type wchar_t aIcmpv6TypeMult[37];
// 5A300: using guessed type wchar_t aIcmpv6TypeMult_0[38];
// 5A350: using guessed type wchar_t aIcmpv6TypeMult_1[36];
// 5A3A0: using guessed type wchar_t aIcmpv6TypeRout[32];
// 5A3E0: using guessed type wchar_t aIcmpv6TypeRout_0[33];
// 5A430: using guessed type wchar_t aIcmpv6TypeNeig[34];
// 5A480: using guessed type wchar_t aIcmpv6TypeNeig_0[35];
// 5A4C8: using guessed type wchar_t aIcmpv6TypeRedi[29];
// 5A508: using guessed type wchar_t aIcmpv6TypeRout_1[31];
// 5A550: using guessed type wchar_t aIcmpv6TypeIcmp[40];
// 5A5A0: using guessed type wchar_t aIcmpv6TypeIcmp_0[43];
// 5A600: using guessed type wchar_t aIcmpv6TypeInve[60];
// 5A680: using guessed type wchar_t aIcmpv6TypeInve_0[61];
// 5A700: using guessed type wchar_t aIcmpv6TypeVers[48];
// 5A760: using guessed type wchar_t aIcmpv6TypeHome[57];
// 5A7E0: using guessed type wchar_t aIcmpv6TypeHome_0[55];
// 5A850: using guessed type wchar_t aIcmpv6TypeMobi[39];
// 5A8A0: using guessed type wchar_t aIcmpv6TypeMobi_0[40];
// 5A8F0: using guessed type wchar_t aIcmpv6TypeCert[52];
// 5A960: using guessed type wchar_t aIcmpv6TypeCert_0[53];
// 5A9D0: using guessed type wchar_t aIcmpv6TypeIcmp_1[70];
// 5AA60: using guessed type wchar_t aIcmpv6TypeMult_2[43];
// 5AAC0: using guessed type wchar_t aIcmpv6TypeMult_3[42];
// 5AB20: using guessed type wchar_t aIcmpv6TypeMult_4[41];
// 5AB78: using guessed type wchar_t aIcmpv6TypeFmip[28];
// 5ABB0: using guessed type wchar_t aIcmpv6TypeRplC[32];
// 5ABF0: using guessed type wchar_t aIcmpv6TypeIlnp[42];
// 5AC50: using guessed type wchar_t aIcmpv6TypeDupl[38];
// 5ACA0: using guessed type wchar_t aIcmpv6TypeDupl_0[43];
// 5ACF8: using guessed type wchar_t aIcmpv6TypeUnas_3[31];
// 5AD38: using guessed type wchar_t aIcmpv6TypeUnas_4[31];
// 5AD80: using guessed type wchar_t aIcmpv6TypePriv_2[38];
// 5ADD0: using guessed type wchar_t aIcmpv6TypePriv_1[38];
// 5AE20: using guessed type wchar_t aIcmpv6TypeUnas_6[31];
// 5AE60: using guessed type wchar_t aIcmpv6TypeUnas_5[31];
// 5AEA0: using guessed type wchar_t aIcmpv6TypeRese_1[68];
// 5AF28: using guessed type wchar_t aIcmpCode[10];
// 5AF40: using guessed type wchar_t aIcmpCodeDestin[38];
// 5AF90: using guessed type wchar_t aIcmpCodeDestin_5[39];
// 5AFE0: using guessed type wchar_t aIcmpCodeDestin_4[43];
// 5B040: using guessed type wchar_t aIcmpCodeDestin_3[39];
// 5B090: using guessed type wchar_t aIcmpCodeDestin_2[56];
// 5B100: using guessed type wchar_t aIcmpCodeDestin_1[54];
// 5B170: using guessed type wchar_t aIcmpCodeDestin_0[51];
// 5B1E0: using guessed type wchar_t aIcmpCodeDestin_6[52];
// 5B250: using guessed type wchar_t aIcmpCodeDestin_12[55];
// 5B2C0: using guessed type wchar_t aIcmpCodeDestin_11[70];
// 5B350: using guessed type wchar_t aIcmpCodeDestin_10[71];
// 5B3E0: using guessed type wchar_t aIcmpCodeDestin_9[51];
// 5B450: using guessed type wchar_t aIcmpCodeDestin_8[52];
// 5B4C0: using guessed type wchar_t aIcmpCodeDestin_7[56];
// 5B530: using guessed type wchar_t aIcmpCodeDestin_13[60];
// 5B5B0: using guessed type wchar_t aIcmpCodeDestin_14[59];
// 5B628: using guessed type wchar_t aIcmpCodeRedire_2[23];
// 5B658: using guessed type wchar_t aIcmpCodeRedire_1[24];
// 5B690: using guessed type wchar_t aIcmpCodeRedire_0[40];
// 5B6E0: using guessed type wchar_t aIcmpCodeRedire[41];
// 5B740: using guessed type wchar_t aIcmpCodeAltern[44];
// 5B7A0: using guessed type wchar_t aIcmpCodeRouter_0[38];
// 5B7F0: using guessed type wchar_t aIcmpCodeRouter[50];
// 5B860: using guessed type wchar_t aIcmpCodeTimeEx_0[37];
// 5B8B0: using guessed type wchar_t aIcmpCodeTimeEx[44];
// 5B910: using guessed type wchar_t aIcmpCodeParame_0[36];
// 5B960: using guessed type wchar_t aIcmpCodeParame[43];
// 5B9C0: using guessed type wchar_t aIcmpCodeParame_1[39];
// 5BA10: using guessed type wchar_t aIcmpCodePhotur_4[27];
// 5BA50: using guessed type wchar_t aIcmpCodePhotur_3[41];
// 5BAB0: using guessed type wchar_t aIcmpCodePhotur_2[40];
// 5BB00: using guessed type wchar_t aIcmpCodePhotur_1[37];
// 5BB50: using guessed type wchar_t aIcmpCodePhotur_0[39];
// 5BBA0: using guessed type wchar_t aIcmpCodePhotur[38];
// 5BBF0: using guessed type wchar_t aIcmpv6Code[12];
// 5BC10: using guessed type wchar_t aIcmpv6CodeDest_4[60];
// 5BC90: using guessed type wchar_t aIcmpv6CodeDest_3[95];
// 5BD50: using guessed type wchar_t aIcmpv6CodeDest_2[67];
// 5BDE0: using guessed type wchar_t aIcmpv6CodeDest_1[56];
// 5BE50: using guessed type wchar_t aIcmpv6CodeDest_0[53];
// 5BEC0: using guessed type wchar_t aIcmpv6CodeDest[80];
// 5BF60: using guessed type wchar_t aIcmpv6CodeDest_5[64];
// 5BFE0: using guessed type wchar_t aIcmpv6CodeDest_6[67];
// 5C070: using guessed type wchar_t aIcmpv6CodeTime_0[56];
// 5C0E0: using guessed type wchar_t aIcmpv6CodeTime[60];
// 5C160: using guessed type wchar_t aIcmpv6CodePara_0[65];
// 5C1F0: using guessed type wchar_t aIcmpv6CodePara[72];
// 5C280: using guessed type wchar_t aIcmpv6CodePara_1[67];
// 5C310: using guessed type wchar_t aIcmpv6CodePara_2[83];
// 5C3C0: using guessed type wchar_t aIcmpv6CodeRout_1[39];
// 5C410: using guessed type wchar_t aIcmpv6CodeRout_0[38];
// 5C460: using guessed type wchar_t aIcmpv6CodeRout[53];
// 5C4D0: using guessed type wchar_t aIcmpv6CodeIcmp_0[61];
// 5C550: using guessed type wchar_t aIcmpv6CodeIcmp[62];
// 5C5D0: using guessed type wchar_t aIcmpv6CodeIcmp_1[61];
// 5C650: using guessed type wchar_t aIcmpv6CodeIcmp_4[51];
// 5C6C0: using guessed type wchar_t aIcmpv6CodeIcmp_3[51];
// 5C730: using guessed type wchar_t aIcmpv6CodeIcmp_2[57];
// 5C7A8: using guessed type wchar_t aUrlCategory[13];
// 5C7C8: using guessed type wchar_t aUrlCatUnknown[16];
// 5C7E8: using guessed type wchar_t aUrlCatMaliciou[18];
// 5C810: using guessed type wchar_t aUrlCatPhishing[17];
// 5C838: using guessed type wchar_t aUrlCatSpam[13];
// 5C858: using guessed type wchar_t aUrlCatBotnets[16];
// 5C878: using guessed type wchar_t aUrlCatAdvertis[23];
// 5C8A8: using guessed type wchar_t aUrlCatAlcoholT[24];
// 5C8D8: using guessed type wchar_t aUrlCatAnonymiz[20];
// 5C900: using guessed type wchar_t aUrlCatBusiness[17];
// 5C928: using guessed type wchar_t aUrlCatCompromi[20];
// 5C950: using guessed type wchar_t aUrlCatCults[14];
// 5C970: using guessed type wchar_t aUrlCatChatInst[30];
// 5C9B0: using guessed type wchar_t aUrlCatDatingPe[25];
// 5C9E8: using guessed type wchar_t aUrlCatDownload[23];
// 5CA18: using guessed type wchar_t aUrlCatEntertai[22];
// 5CA48: using guessed type wchar_t aUrlCatFashionB[23];
// 5CA78: using guessed type wchar_t aUrlCatForumsNe[26];
// 5CAB0: using guessed type wchar_t aUrlCatGambling[17];
// 5CAD8: using guessed type wchar_t aUrlCatHacking[16];
// 5CAF8: using guessed type wchar_t aUrlCatHealthMe[24];
// 5CB28: using guessed type wchar_t aUrlCatIllegal[16];
// 5CB48: using guessed type wchar_t aUrlCatIllegalD[21];
// 5CB78: using guessed type wchar_t aUrlCatImageSha[22];
// 5CBA8: using guessed type wchar_t aUrlCatInformat[29];
// 5CBE8: using guessed type wchar_t aUrlCatInternet[23];
// 5CC18: using guessed type wchar_t aUrlCatJobSearc[19];
// 5CC40: using guessed type wchar_t aUrlCatNetworkE[23];
// 5CC70: using guessed type wchar_t aUrlCatNews[13];
// 5CC90: using guessed type wchar_t aUrlCatOffensiv[18];
// 5CCB8: using guessed type wchar_t aUrlCatParkedDo[23];
// 5CCE8: using guessed type wchar_t aUrlCatPeerToPe[21];
// 5CD18: using guessed type wchar_t aUrlCatPersonal[17];
// 5CD40: using guessed type wchar_t aUrlCatPornogra[27];
// 5CD78: using guessed type wchar_t aUrlCatPrivateI[29];
// 5CDB8: using guessed type wchar_t aUrlCatReligion[17];
// 5CDE0: using guessed type wchar_t aUrlCatSexEduca[22];
// 5CE10: using guessed type wchar_t aUrlCatShopping[17];
// 5CE38: using guessed type wchar_t aUrlCatSocietyE[26];
// 5CE70: using guessed type wchar_t aUrlCatStreamin[28];
// 5CEA8: using guessed type wchar_t aUrlCatTechnolo[19];
// 5CED0: using guessed type wchar_t aUrlCatTranspor[30];
// 5CF10: using guessed type wchar_t aUrlCatWeapons[16];

//----- (0000000000038664) ----------------------------------------------------
const wchar_t *__fastcall sub_38664(int a1)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx

  if ( a1 <= 7 )
  {
    if ( a1 == 7 )
      return L"E_NNS_VALUE_TYPE_MULTIBYTE_STRING";
    if ( !a1 )
      return L"E_NNS_VALUE_TYPE_UNKNOWN";
    v1 = a1 - 1;
    if ( !v1 )
      return L"E_NNS_VALUE_TYPE_BOOL";
    v2 = v1 - 1;
    if ( !v2 )
      return L"E_NNS_VALUE_TYPE_CHAR";
    v3 = v2 - 1;
    if ( !v3 )
      return L"E_NNS_VALUE_TYPE_LONG";
    v4 = v3 - 1;
    if ( !v4 )
      return L"E_NNS_VALUE_TYPE_ULONG64";
    v5 = v4 - 1;
    if ( !v5 )
      return L"E_NNS_VALUE_TYPE_DOUBLE";
    if ( v5 == 1 )
      return L"E_NNS_VALUE_TYPE_STRING";
    return L"Unknown E_NNS_VALUE_TYPE";
  }
  v7 = a1 - 8;
  if ( !v7 )
    return L"E_NNS_VALUE_TYPE_FIELD";
  v8 = v7 - 1;
  if ( !v8 )
    return L"E_NNS_VALUE_TYPE_RANGE";
  v9 = v8 - 1;
  if ( !v9 )
    return L"E_NNS_VALUE_TYPE_LIST";
  v10 = v9 - 1;
  if ( !v10 )
    return L"E_NNS_VALUE_TYPE_BUFFER";
  v11 = v10 - 1;
  if ( !v11 )
    return L"E_NNS_VALUE_TYPE_IPV4";
  v12 = v11 - 1;
  if ( !v12 )
    return L"E_NNS_VALUE_TYPE_MAC";
  if ( v12 != 1 )
    return L"Unknown E_NNS_VALUE_TYPE";
  return L"E_NNS_VALUE_TYPE_IPV6";
}
// 5CF30: using guessed type wchar_t aENnsValueTypeU_0[25];
// 5CF68: using guessed type wchar_t aENnsValueTypeB[22];
// 5CF98: using guessed type wchar_t aENnsValueTypeC[22];
// 5CFC8: using guessed type wchar_t aENnsValueTypeL[22];
// 5CFF8: using guessed type wchar_t aENnsValueTypeU[25];
// 5D030: using guessed type wchar_t aENnsValueTypeD[24];
// 5D060: using guessed type wchar_t aENnsValueTypeS[24];
// 5D090: using guessed type wchar_t aENnsValueTypeM[34];
// 5D0D8: using guessed type wchar_t aENnsValueTypeF[23];
// 5D108: using guessed type wchar_t aENnsValueTypeR[23];
// 5D138: using guessed type wchar_t aENnsValueTypeL_0[22];
// 5D168: using guessed type wchar_t aENnsValueTypeB_0[24];
// 5D198: using guessed type wchar_t aENnsValueTypeI_0[22];
// 5D1C8: using guessed type wchar_t aENnsValueTypeI[22];
// 5D1F8: using guessed type wchar_t aENnsValueTypeM_0[21];
// 5D228: using guessed type wchar_t aUnknownENnsVal[25];

//----- (0000000000038734) ----------------------------------------------------
__int64 __fastcall sub_38734(__int64 a1, _BYTE *a2)
{
  unsigned int v4; // ebx
  void **v5; // rcx
  __int64 v6; // rax
  _BYTE *v7; // rdx
  __int64 v8; // r9
  unsigned __int8 v9; // al
  __int64 result; // rax

  v4 = 7;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x16u, (__int64)&unk_4DBD8);
    v5 = (void **)off_5F148;
  }
  v6 = 0i64;
  if ( a1 && a2 )
  {
    v7 = a2;
    v8 = a1 - (_QWORD)a2;
    do
    {
      if ( v7[v8] > *v7 )
        goto LABEL_16;
      if ( v7[v8] < *v7 )
      {
        v4 = 5;
        goto LABEL_17;
      }
      ++v6;
      ++v7;
    }
    while ( v6 < 4 );
    v9 = a2[4];
    if ( *(_BYTE *)(a1 + 4) > v9 )
    {
LABEL_16:
      v4 = 6;
      goto LABEL_17;
    }
    if ( *(_BYTE *)(a1 + 4) < v9 )
      v4 = 5;
LABEL_17:
    if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 172) & 2) != 0 && *((_BYTE *)v5 + 169) >= 5u )
      sub_1102C((__int64)v5[19], 0x18u, (__int64)&unk_4DBD8, v4);
    result = v4;
  }
  else
  {
    if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 172) & 2) != 0 && *((_BYTE *)v5 + 169) >= 2u )
      sub_11008((__int64)v5[19], 0x17u, (__int64)&unk_4DBD8);
    result = 1i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000038870) ----------------------------------------------------
__int64 __fastcall sub_38870(__int64 a1, _BYTE *a2)
{
  unsigned int v4; // ebx
  void **v5; // rcx
  __int64 v6; // rax
  _BYTE *v7; // rdx
  __int64 v8; // r9
  unsigned __int8 v9; // al
  __int64 result; // rax

  v4 = 7;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x19u, (__int64)&unk_4DBD8);
    v5 = (void **)off_5F148;
  }
  v6 = 0i64;
  if ( a1 && a2 )
  {
    v7 = a2;
    v8 = a1 - (_QWORD)a2;
    do
    {
      if ( v7[v8] > *v7 )
        goto LABEL_16;
      if ( v7[v8] < *v7 )
      {
        v4 = 5;
        goto LABEL_17;
      }
      ++v6;
      ++v7;
    }
    while ( v6 < 16 );
    v9 = a2[16];
    if ( *(_BYTE *)(a1 + 16) > v9 )
    {
LABEL_16:
      v4 = 6;
      goto LABEL_17;
    }
    if ( *(_BYTE *)(a1 + 16) < v9 )
      v4 = 5;
LABEL_17:
    if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 172) & 2) != 0 && *((_BYTE *)v5 + 169) >= 5u )
      sub_1102C((__int64)v5[19], 0x1Bu, (__int64)&unk_4DBD8, v4);
    result = v4;
  }
  else
  {
    if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 172) & 2) != 0 && *((_BYTE *)v5 + 169) >= 2u )
      sub_11008((__int64)v5[19], 0x1Au, (__int64)&unk_4DBD8);
    result = 1i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000389AC) ----------------------------------------------------
void **__fastcall sub_389AC(unsigned __int8 *a1)
{
  void **result; // rax

  if ( a1 )
  {
    result = &off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
      result = (void **)sub_34F10(*((_QWORD *)off_5F148 + 19), 35i64, (__int64)&unk_4DBD8, *a1);
  }
  else
  {
    result = &off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      result = (void **)sub_11008(*((_QWORD *)off_5F148 + 19), 0x22u, (__int64)&unk_4DBD8);
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000038A78) ----------------------------------------------------
void **__fastcall sub_38A78(_WORD *a1)
{
  void **result; // rax

  if ( a1 )
  {
    result = &off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      result = (void **)sub_34A5C(
                          *((_QWORD *)off_5F148 + 19),
                          0x25u,
                          (__int64)&unk_4DBD8,
                          (unsigned __int8)HIBYTE(*a1) | (unsigned int)(unsigned __int16)((unsigned __int8)*a1 << 8));
  }
  else
  {
    result = &off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      result = (void **)sub_11008(*((_QWORD *)off_5F148 + 19), 0x24u, (__int64)&unk_4DBD8);
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000038C6C) ----------------------------------------------------
__int64 __fastcall sub_38C6C(__int64 a1, _BYTE *a2)
{
  unsigned int v4; // ebx
  void **v5; // rcx
  __int64 v6; // rax
  __int64 v7; // rsi

  v4 = 7;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x26u, (__int64)&unk_4DBD8);
    v5 = (void **)off_5F148;
  }
  v6 = 0i64;
  v7 = a1 - (_QWORD)a2;
  while ( a2[v7] <= *a2 )
  {
    if ( a2[v7] < *a2 )
    {
      v4 = 5;
      goto LABEL_12;
    }
    ++v6;
    ++a2;
    if ( v6 >= 6 )
      goto LABEL_12;
  }
  v4 = 6;
LABEL_12:
  if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 172) & 2) != 0 && *((_BYTE *)v5 + 169) >= 5u )
    sub_1102C((__int64)v5[19], 0x27u, (__int64)&unk_4DBD8, v4);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000038D44) ----------------------------------------------------
void **__fastcall sub_38D44(unsigned __int8 *a1)
{
  void **result; // rax

  if ( a1 )
  {
    result = &off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
      result = (void **)sub_34930(*((_QWORD *)off_5F148 + 19), 44i64, (__int64)&unk_4DBD8, *a1);
  }
  else
  {
    result = &off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      result = (void **)sub_11008(*((_QWORD *)off_5F148 + 19), 0x2Bu, (__int64)&unk_4DBD8);
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000038E18) ----------------------------------------------------
__int64 __fastcall sub_38E18(__int64 *a1)
{
  void **v2; // rcx
  _DWORD *v4; // rax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x2Du, (__int64)&unk_4DBD8);
    v2 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x2Eu, (__int64)&unk_4DBD8);
    return 4i64;
  }
  if ( *a1 )
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 5u )
      sub_11008((__int64)v2[19], 0x2Fu, (__int64)&unk_4DBD8);
    sub_3AF94(*a1);
    goto LABEL_17;
  }
  v4 = sub_26948((__int64)qword_62078);
  *a1 = (__int64)v4;
  if ( v4 )
  {
LABEL_17:
    *(_DWORD *)*a1 = 0;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x31u, (__int64)&unk_4DBD8);
    return 0i64;
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x30u, (__int64)&unk_4DBD8);
  return 3i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000038F84) ----------------------------------------------------
__int64 __fastcall sub_38F84(__int64 *a1, char a2)
{
  const char *v4; // r9
  int v5; // eax
  unsigned int v6; // ebx
  __int64 result; // rax

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    v4 = "value";
    if ( a2 )
      v4 = "true";
    sub_13618(*((_QWORD *)off_5F148 + 19), 0x32u, (__int64)&unk_4DBD8, v4);
  }
  v5 = sub_38E18(a1);
  v6 = v5;
  if ( v5 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x33u, (__int64)&unk_4DBD8, v5);
    result = v6;
  }
  else
  {
    *(_DWORD *)*a1 = 1;
    *(_BYTE *)(*a1 + 4) = a2;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x34u, (__int64)&unk_4DBD8);
    result = 0i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000390A0) ----------------------------------------------------
__int64 __fastcall sub_390A0(__int64 *a1, char a2)
{
  int v4; // eax
  unsigned int v5; // ebx
  __int64 result; // rax

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_34EC8(*((_QWORD *)off_5F148 + 19), 53i64, (__int64)&unk_4DBD8, a2);
  v4 = sub_38E18(a1);
  v5 = v4;
  if ( v4 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x36u, (__int64)&unk_4DBD8, v4);
    result = v5;
  }
  else
  {
    *(_DWORD *)*a1 = 2;
    *(_BYTE *)(*a1 + 4) = a2;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x37u, (__int64)&unk_4DBD8);
    result = 0i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000391AC) ----------------------------------------------------
__int64 __fastcall sub_391AC(__int64 *a1, int a2)
{
  int v4; // eax
  unsigned int v5; // ebx
  __int64 result; // rax

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x38u, (__int64)&unk_4DBD8, a2);
  v4 = sub_38E18(a1);
  v5 = v4;
  if ( v4 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x39u, (__int64)&unk_4DBD8, v4);
    result = v5;
  }
  else
  {
    *(_DWORD *)*a1 = 3;
    *(_DWORD *)(*a1 + 4) = a2;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x3Au, (__int64)&unk_4DBD8);
    result = 0i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000392B4) ----------------------------------------------------
__int64 __fastcall sub_392B4(__int64 *a1, __int64 a2)
{
  int v4; // eax
  unsigned int v5; // ebx
  __int64 result; // rax

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x3Bu, (__int64)&unk_4DBD8, a2);
  v4 = sub_38E18(a1);
  v5 = v4;
  if ( v4 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x3Cu, (__int64)&unk_4DBD8, v4);
    result = v5;
  }
  else
  {
    *(_DWORD *)*a1 = 4;
    *(_QWORD *)(*a1 + 4) = a2;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x3Du, (__int64)&unk_4DBD8);
    result = 0i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000393C0) ----------------------------------------------------
__int64 __fastcall sub_393C0(__int64 *a1, const char *a2)
{
  void **v4; // rcx
  __int64 result; // rax
  int v6; // eax
  unsigned int v7; // edi
  void *v8; // rcx

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_13618(*((_QWORD *)off_5F148 + 19), 0x41u, (__int64)&unk_4DBD8, a2);
    v4 = (void **)off_5F148;
  }
  if ( a2 )
  {
    v6 = sub_38E18(a1);
    v7 = v6;
    if ( v6 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x43u, (__int64)&unk_4DBD8, v6);
      result = v7;
    }
    else
    {
      *(_DWORD *)*a1 = 6;
      *(_DWORD *)(*a1 + 12) = strlen(a2);
      *(_QWORD *)(*a1 + 4) = sub_26404(1, *(_DWORD *)(*a1 + 12) + 1, 0x6E656753u);
      v8 = *(void **)(*a1 + 4);
      if ( v8 )
      {
        memmove(v8, a2, (unsigned int)(*(_DWORD *)(*a1 + 12) + 1));
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
          sub_11008(*((_QWORD *)off_5F148 + 19), 0x45u, (__int64)&unk_4DBD8);
        result = 0i64;
      }
      else
      {
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
          sub_11008(*((_QWORD *)off_5F148 + 19), 0x44u, (__int64)&unk_4DBD8);
        sub_3B0E0(a1);
        result = 3i64;
      }
    }
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x42u, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000395A8) ----------------------------------------------------
__int64 __fastcall sub_395A8(__int64 *a1, const wchar_t *a2)
{
  int v4; // eax
  unsigned int v5; // edi
  __int64 result; // rax
  __int64 v7; // rcx
  const wchar_t *v8; // rdi
  bool v9; // zf
  void *v10; // rcx

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_17860(*((_QWORD *)off_5F148 + 19), 0x46u, (__int64)&unk_4DBD8, a2);
  v4 = sub_38E18(a1);
  v5 = v4;
  if ( v4 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x47u, (__int64)&unk_4DBD8, v4);
    result = v5;
  }
  else
  {
    *(_DWORD *)*a1 = 7;
    v7 = -1i64;
    v8 = a2;
    do
    {
      if ( !v7 )
        break;
      v9 = *v8++ == 0;
      --v7;
    }
    while ( !v9 );
    *(_DWORD *)(*a1 + 12) = -(int)v7 - 2;
    *(_QWORD *)(*a1 + 4) = sub_26404(1, 2 * *(_DWORD *)(*a1 + 12) + 2, 0x6E656753u);
    v10 = *(void **)(*a1 + 4);
    if ( v10 )
    {
      memmove(v10, a2, 2i64 * (unsigned int)(*(_DWORD *)(*a1 + 12) + 1));
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x49u, (__int64)&unk_4DBD8);
      result = 0i64;
    }
    else
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x48u, (__int64)&unk_4DBD8);
      sub_3B0E0(a1);
      result = 3i64;
    }
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000039758) ----------------------------------------------------
__int64 __fastcall sub_39758(__int64 *a1, const void *a2, int a3)
{
  int v6; // eax
  unsigned int v7; // ebx
  __int64 result; // rax
  void *v9; // rcx

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x4Au, (__int64)&unk_4DBD8, a2);
  v6 = sub_38E18(a1);
  v7 = v6;
  if ( v6 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x4Bu, (__int64)&unk_4DBD8, v6);
    result = v7;
  }
  else
  {
    *(_DWORD *)*a1 = 11;
    *(_DWORD *)(*a1 + 12) = a3;
    *(_QWORD *)(*a1 + 4) = sub_26404(1, *(_DWORD *)(*a1 + 12), 0x6E656753u);
    v9 = *(void **)(*a1 + 4);
    if ( v9 )
    {
      memmove(v9, a2, *(unsigned int *)(*a1 + 12));
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x4Du, (__int64)&unk_4DBD8);
      result = 0i64;
    }
    else
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x4Cu, (__int64)&unk_4DBD8);
      sub_3B0E0(a1);
      result = 3i64;
    }
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000398F8) ----------------------------------------------------
__int64 __fastcall sub_398F8(__int64 *a1, int a2)
{
  const wchar_t *v4; // rax
  __int64 v5; // r10
  int v6; // eax
  unsigned int v7; // ebx
  __int64 result; // rax

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    v4 = sub_352B8(a2);
    sub_17860(*(_QWORD *)(v5 + 152), 0x4Eu, (__int64)&unk_4DBD8, v4);
  }
  v6 = sub_38E18(a1);
  v7 = v6;
  if ( v6 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x4Fu, (__int64)&unk_4DBD8, v6);
    result = v7;
  }
  else
  {
    *(_DWORD *)*a1 = 8;
    *(_DWORD *)(*a1 + 4) = a2;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x50u, (__int64)&unk_4DBD8);
    result = 0i64;
  }
  return result;
}
// 39940: variable 'v5' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (0000000000039A0C) ----------------------------------------------------
__int64 __fastcall sub_39A0C(__int64 *a1, const void *a2, const void *a3, int a4)
{
  void **v8; // rcx
  int v9; // eax
  unsigned int v10; // edi
  int v12; // ebx
  int v13; // ebx
  size_t v14; // rbx
  void **v15; // rcx
  unsigned __int16 v16; // dx
  void *v17; // rcx
  void *v18; // rcx

  v8 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x51u, (__int64)&unk_4DBD8, a2, a3);
    v8 = (void **)off_5F148;
  }
  if ( a2 && a3 )
  {
    v9 = sub_38E18(a1);
    v10 = v9;
    if ( v9 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x53u, (__int64)&unk_4DBD8, v9);
      return v10;
    }
    *(_DWORD *)*a1 = 9;
    *(_DWORD *)(*a1 + 4) = a4;
    *(_QWORD *)(*a1 + 8) = 0i64;
    *(_QWORD *)(*a1 + 16) = 0i64;
    v12 = a4 - 512;
    if ( v12 )
    {
      v13 = v12 - 1;
      if ( v13 )
      {
        if ( v13 == 11 )
          v14 = 17i64;
        else
          v14 = 4i64;
      }
      else
      {
        v14 = 6i64;
      }
    }
    else
    {
      v14 = 5i64;
    }
    *(_QWORD *)(*a1 + 8) = sub_26404(1, v14, 0x6E656753u);
    if ( *(_QWORD *)(*a1 + 8) )
    {
      *(_QWORD *)(*a1 + 16) = sub_26404(1, v14, 0x6E656753u);
      if ( *(_QWORD *)(*a1 + 16) )
      {
        memmove(*(void **)(*a1 + 8), a2, v14);
        memmove(*(void **)(*a1 + 16), a3, v14);
        goto LABEL_38;
      }
      v15 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
      {
LABEL_31:
        v10 = 3;
        if ( !*a1 )
          goto LABEL_39;
        v17 = *(void **)(*a1 + 8);
        if ( v17 )
          sub_26488(v17, 0x6E656753u);
        v18 = *(void **)(*a1 + 16);
        if ( v18 )
          sub_26488(v18, 0x6E656753u);
        sub_3B0E0(a1);
LABEL_38:
        v15 = (void **)off_5F148;
LABEL_39:
        if ( v15 != &off_5F148 && (*((_BYTE *)v15 + 172) & 2) != 0 && *((_BYTE *)v15 + 169) >= 5u )
          sub_1102C((__int64)v15[19], 0x56u, (__int64)&unk_4DBD8, v10);
        return 0i64;
      }
      v16 = 85;
    }
    else
    {
      v15 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        goto LABEL_31;
      v16 = 84;
    }
    sub_11008((__int64)v15[19], v16, (__int64)&unk_4DBD8);
    v15 = (void **)off_5F148;
    goto LABEL_31;
  }
  if ( v8 != &off_5F148 && (*((_BYTE *)v8 + 172) & 2) != 0 && *((_BYTE *)v8 + 169) >= 2u )
    sub_11008((__int64)v8[19], 0x52u, (__int64)&unk_4DBD8);
  return 4i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000039CFC) ----------------------------------------------------
__int64 __fastcall sub_39CFC(__int64 *a1, __int64 a2, char a3)
{
  __int64 *v5; // rax
  void **v6; // rcx
  __int64 v7; // rbx
  int v9; // eax
  __int64 v10; // r8
  unsigned int v11; // edi
  void **v12; // rcx
  unsigned __int16 v13; // dx
  int v14; // er9
  __int64 v15; // r9
  __int64 v16; // rdx
  char v17; // al
  int v18; // ebp
  int v19; // eax
  __int64 v20; // r8
  int v21; // eax
  _QWORD *v22; // rcx
  unsigned __int16 v23; // dx
  __int64 v24; // r8
  __int64 v25; // r9
  __int64 v26; // rdx
  __int64 v27; // [rsp+20h] [rbp-38h] BYREF
  __int64 v28[6]; // [rsp+28h] [rbp-30h] BYREF
  __int64 *v29; // [rsp+60h] [rbp+8h]
  __int64 v30; // [rsp+68h] [rbp+10h]
  char v31; // [rsp+70h] [rbp+18h]
  int v32; // [rsp+78h] [rbp+20h]

  v31 = a3;
  v30 = a2;
  v29 = a1;
  v5 = a1;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x57u, (__int64)&unk_4DBD8);
    v6 = (void **)off_5F148;
    v5 = v29;
  }
  v7 = 0i64;
  if ( !a2 )
  {
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 2) != 0 && *((_BYTE *)v6 + 169) >= 2u )
      sub_11008((__int64)v6[19], 0x58u, (__int64)&unk_4DBD8);
    return 4i64;
  }
  v9 = sub_38E18(v5);
  v11 = v9;
  if ( v9 )
  {
    v12 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
      return v11;
    v13 = 89;
    v14 = v9;
LABEL_55:
    sub_1102C((__int64)v12[19], v13, (__int64)&unk_4DBD8, v14);
    return v11;
  }
  if ( a3 != 32 )
  {
    LOBYTE(v10) = 32;
    v27 = 0i64;
    v28[0] = 0i64;
    HIBYTE(v18) = 0;
    v32 = 0;
    v19 = sub_39CFC(&v27, v30, v10);
    v11 = v19;
    if ( v19 )
    {
      v12 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        goto LABEL_46;
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x5Bu, (__int64)&unk_4DBD8, v19);
LABEL_45:
      v12 = (void **)off_5F148;
LABEL_46:
      if ( v27 )
      {
        sub_3B0E0(&v27);
        v12 = (void **)off_5F148;
      }
      if ( !v28[0] )
        goto LABEL_51;
      sub_3B0E0(v28);
LABEL_50:
      v12 = (void **)off_5F148;
LABEL_51:
      if ( v12 == &off_5F148 || (*((_BYTE *)v12 + 172) & 2) == 0 || *((_BYTE *)v12 + 169) < 5u )
        return v11;
      v13 = 94;
      v14 = v11;
      goto LABEL_55;
    }
    LOBYTE(v20) = 32;
    v21 = sub_39CFC(v28, v30, v20);
    v11 = v21;
    if ( v21 )
    {
      v22 = off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        goto LABEL_44;
      v23 = 92;
    }
    else
    {
      if ( v31 )
      {
        v18 = -1 << (32 - v31);
        v32 = v18;
      }
      v24 = 0i64;
      v25 = 0i64;
      BYTE3(v30) = ~HIBYTE(v18);
      v26 = 4i64;
      do
      {
        *(_BYTE *)(++v24 + v27 + 3) &= *((_BYTE *)&v32 + v25 + 3);
        *(_BYTE *)(v24 + v28[0] + 3) |= *((_BYTE *)&v30 + v25-- + 3);
        --v26;
      }
      while ( v26 );
      v21 = sub_39A0C(v29, (const void *)(v27 + 4), (const void *)(v28[0] + 4), 512);
      v11 = v21;
      if ( !v21 )
        goto LABEL_50;
      v22 = off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        goto LABEL_44;
      v23 = 93;
    }
    sub_1102C(v22[19], v23, (__int64)&unk_4DBD8, v21);
LABEL_44:
    sub_3B0E0(&v27);
    goto LABEL_45;
  }
  v15 = v30;
  v16 = 4i64;
  do
  {
    v17 = *(_BYTE *)(v7 + v15);
    ++v7;
    --v16;
    *(_BYTE *)(v7 + *v29 + 3) = v17;
  }
  while ( v16 );
  *(_DWORD *)*v29 = 12;
  *(_BYTE *)(*v29 + 8) = 32;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x5Au, (__int64)&unk_4DBD8);
  return 0i64;
}
// 39E95: variable 'v10' is possibly undefined
// 39EFE: variable 'v20' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000003A090) ----------------------------------------------------
__int64 __fastcall sub_3A090(__int64 *a1, unsigned __int16 *a2, unsigned __int8 a3)
{
  __int64 *v4; // rax
  void **v5; // rcx
  __int64 v6; // rbp
  unsigned int v8; // eax
  __int64 v9; // r8
  unsigned int v10; // ebx
  void **v11; // rcx
  unsigned __int16 v12; // dx
  int v13; // er9
  __int64 *v14; // r10
  __int64 v15; // rbx
  char v16; // al
  void **v17; // rsi
  __int64 v18; // r8
  _QWORD *v19; // rcx
  unsigned __int16 v20; // dx
  __int64 v21; // rbx
  unsigned __int8 *v22; // rax
  __int64 v23; // r8
  int v24; // esi
  char v25; // r8
  char *v26; // rax
  __int64 v27; // rcx
  __int64 v28; // rcx
  char v29; // al
  __int64 v30; // rdx
  __int64 v31; // r8
  char v32; // al
  void **v33; // rsi
  void **v34; // rax
  __int64 v36; // [rsp+68h] [rbp-70h] BYREF
  __int64 v37; // [rsp+70h] [rbp-68h] BYREF
  __int64 *v38; // [rsp+78h] [rbp-60h]
  int v39; // [rsp+80h] [rbp-58h]
  int v40; // [rsp+84h] [rbp-54h]
  unsigned __int16 *v41; // [rsp+88h] [rbp-50h]
  unsigned __int8 v42; // [rsp+90h] [rbp-48h] BYREF
  __int64 v43; // [rsp+91h] [rbp-47h]
  int v44; // [rsp+99h] [rbp-3Fh]
  __int16 v45; // [rsp+9Dh] [rbp-3Bh]
  char v46; // [rsp+9Fh] [rbp-39h] BYREF
  unsigned __int8 v47; // [rsp+A0h] [rbp-38h]
  __int64 v48; // [rsp+A1h] [rbp-37h]
  int v49; // [rsp+A9h] [rbp-2Fh]
  __int16 v50; // [rsp+ADh] [rbp-2Bh]
  char v51; // [rsp+AFh] [rbp-29h]

  v41 = a2;
  v4 = a1;
  v38 = a1;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x5Fu, (__int64)&unk_4DBD8);
    v5 = (void **)off_5F148;
    v4 = v38;
  }
  v6 = 0i64;
  if ( !a2 )
  {
    if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 172) & 2) != 0 && *((_BYTE *)v5 + 169) >= 2u )
      sub_11008((__int64)v5[19], 0x60u, (__int64)&unk_4DBD8);
    return 4i64;
  }
  v8 = sub_38E18(v4);
  v10 = v8;
  if ( v8 )
  {
    v11 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
      return v10;
    v12 = 97;
    v13 = v8;
LABEL_99:
    sub_1102C((__int64)v11[19], v12, (__int64)&unk_4DBD8, v13);
    return v10;
  }
  if ( a3 != 0x80 )
  {
    LOBYTE(v9) = 0x80;
    v36 = 0i64;
    v37 = 0i64;
    v42 = 0;
    v43 = 0i64;
    v44 = 0;
    v45 = 0;
    v46 = 0;
    v47 = 0;
    v48 = 0i64;
    v49 = 0;
    v50 = 0;
    v51 = 0;
    v10 = sub_3A090(&v36, a2, v9);
    if ( v10 )
    {
      v11 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        goto LABEL_90;
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x65u, (__int64)&unk_4DBD8, v10);
LABEL_89:
      v11 = (void **)off_5F148;
LABEL_90:
      if ( v36 )
      {
        sub_3B0E0(&v36);
        v11 = (void **)off_5F148;
      }
      if ( !v37 )
        goto LABEL_95;
      sub_3B0E0(&v37);
LABEL_94:
      v11 = (void **)off_5F148;
LABEL_95:
      if ( v11 == &off_5F148 || (*((_BYTE *)v11 + 172) & 2) == 0 || *((_BYTE *)v11 + 169) < 5u )
        return v10;
      v12 = 111;
      v13 = v10;
      goto LABEL_99;
    }
    LOBYTE(v18) = 0x80;
    v10 = sub_3A090(&v37, a2, v18);
    if ( v10 )
    {
      v19 = off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        goto LABEL_88;
      v20 = 102;
    }
    else
    {
      v21 = 16i64;
      if ( a3 )
      {
        v22 = &v42;
        v23 = 16i64;
        do
        {
          *v22 = ~*v22;
          ++v22;
          --v23;
        }
        while ( v23 );
      }
      v39 = a3;
      v24 = (128 - a3) / 8;
      v25 = (128 - a3) % 8;
      v40 = (128 - a3) % 8;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      {
        sub_127D0(*((_QWORD *)off_5F148 + 19), 0x67u, (__int64)&unk_4DBD8, (unsigned __int8)v24);
        v25 = v40;
      }
      if ( (_BYTE)v24 )
      {
        v26 = &v46;
        v27 = (unsigned __int8)v24;
        do
        {
          *v26-- = 0;
          --v27;
        }
        while ( v27 );
      }
      if ( v25 )
        *(&v46 - (unsigned __int8)v24) &= -1 << v25;
      v28 = 0i64;
      do
      {
        v29 = *(&v42 + v28++);
        --v21;
        *(&v46 + v28) = ~v29;
      }
      while ( v21 );
      v30 = 0i64;
      v31 = 8i64;
      do
      {
        v32 = *((_BYTE *)&v43 + v30);
        v30 += 2i64;
        *(_BYTE *)(v30 + v36 + 2) &= v32;
        *(_BYTE *)(v30 + v37 + 2) |= *(&v46 + v30);
        *(_BYTE *)(v30 + v36 + 3) &= *((_BYTE *)&v41 + v30 + 6);
        *(_BYTE *)(v30 + v37 + 3) |= *((_BYTE *)&v45 + v30 + 1);
        --v31;
      }
      while ( v31 );
      v33 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 )
      {
        if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
        {
          sub_11008(*((_QWORD *)off_5F148 + 19), 0x68u, (__int64)&unk_4DBD8);
          v33 = (void **)off_5F148;
        }
        if ( v33 != &off_5F148 )
        {
          if ( (*((_BYTE *)v33 + 172) & 2) != 0 && *((_BYTE *)v33 + 169) >= 4u )
          {
            sub_34A5C(*((_QWORD *)off_5F148 + 19), 0x69u, (__int64)&unk_4DBD8, *v41);
            v33 = (void **)off_5F148;
          }
          if ( v33 != &off_5F148 && (*((_BYTE *)v33 + 172) & 2) != 0 && *((_BYTE *)v33 + 169) >= 4u )
            sub_11008((__int64)v33[19], 0x6Au, (__int64)&unk_4DBD8);
        }
      }
      sub_38A78((_WORD *)(v36 + 4));
      v34 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 )
      {
        if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
        {
          sub_349BC(
            *((_QWORD *)off_5F148 + 19),
            0x6Bu,
            (__int64)&unk_4DBD8,
            (unsigned __int8)v43 | (unsigned __int16)(v42 << 8));
          v34 = (void **)off_5F148;
        }
        if ( v34 != &off_5F148 && (*((_BYTE *)v34 + 172) & 2) != 0 && *((_BYTE *)v34 + 169) >= 4u )
          sub_11008((__int64)v34[19], 0x6Cu, (__int64)&unk_4DBD8);
      }
      sub_38A78((_WORD *)(v37 + 4));
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
        sub_349BC(
          *((_QWORD *)off_5F148 + 19),
          0x6Du,
          (__int64)&unk_4DBD8,
          (unsigned __int8)v48 | (unsigned __int16)(v47 << 8));
      v10 = sub_39A0C(v38, (const void *)(v36 + 4), (const void *)(v37 + 4), 524);
      if ( !v10 )
        goto LABEL_94;
      v19 = off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        goto LABEL_88;
      v20 = 110;
    }
    sub_1102C(v19[19], v20, (__int64)&unk_4DBD8, v10);
LABEL_88:
    sub_3B0E0(&v36);
    goto LABEL_89;
  }
  v14 = v38;
  v15 = 16i64;
  do
  {
    v16 = *((_BYTE *)a2 + v6++);
    --v15;
    *(_BYTE *)(*v14 + v6 + 3) = v16;
  }
  while ( v15 );
  *(_DWORD *)*v14 = 14;
  *(_BYTE *)(*v14 + 20) = 0x80;
  v17 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x62u, (__int64)&unk_4DBD8);
      v17 = (void **)off_5F148;
    }
    if ( v17 != &off_5F148 )
    {
      if ( (*((_BYTE *)v17 + 172) & 2) != 0 && *((_BYTE *)v17 + 169) >= 4u )
      {
        sub_34A5C((__int64)v17[19], 0x63u, (__int64)&unk_4DBD8, *v41);
        v17 = (void **)off_5F148;
      }
      if ( v17 != &off_5F148 && (*((_BYTE *)v17 + 172) & 2) != 0 && *((_BYTE *)v17 + 169) >= 5u )
        sub_11008((__int64)v17[19], 0x64u, (__int64)&unk_4DBD8);
    }
  }
  return 0i64;
}
// 3A33B: variable 'v9' is possibly undefined
// 3A3A2: variable 'v18' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000003AA24) ----------------------------------------------------
__int64 __fastcall sub_3AA24(__int64 *a1, __int64 a2)
{
  void **v4; // rcx
  __int64 v5; // rdi
  __int64 result; // rax
  int v7; // eax
  unsigned int v8; // ebx
  __int64 v9; // rdx
  char v10; // al

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x7Eu, (__int64)&unk_4DBD8);
    v4 = (void **)off_5F148;
  }
  v5 = 0i64;
  if ( a2 )
  {
    v7 = sub_38E18(a1);
    v8 = v7;
    if ( v7 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x80u, (__int64)&unk_4DBD8, v7);
      result = v8;
    }
    else
    {
      v9 = 6i64;
      do
      {
        v10 = *(_BYTE *)(v5 + a2);
        ++v5;
        --v9;
        *(_BYTE *)(v5 + *a1 + 3) = v10;
      }
      while ( v9 );
      *(_DWORD *)*a1 = 13;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x81u, (__int64)&unk_4DBD8);
      result = 0i64;
    }
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x7Fu, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003AB8C) ----------------------------------------------------
__int64 __fastcall sub_3AB8C(__int64 *a1)
{
  int v2; // eax
  unsigned int v3; // ebx

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x82u, (__int64)&unk_4DBD8);
  v2 = sub_38E18(a1);
  v3 = v2;
  if ( v2 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x83u, (__int64)&unk_4DBD8, v2);
    return v3;
  }
  *(_DWORD *)*a1 = 10;
  *(_QWORD *)(*a1 + 4) = 0i64;
  v3 = sub_42500(0x564C6547u, (__int64 *)(*a1 + 4), 0, (void (__fastcall *)(__int64 *))sub_3B0E0);
  if ( v3 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x84u, (__int64)&unk_4DBD8);
    sub_3B0E0(a1);
    return v3;
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x85u, (__int64)&unk_4DBD8);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003ACEC) ----------------------------------------------------
__int64 __fastcall sub_3ACEC(__int64 *a1, __int64 a2)
{
  void **v4; // rcx
  int v5; // er9
  __int64 result; // rax
  int v7; // eax
  unsigned int v8; // esi

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x8Eu, (__int64)&unk_4DBD8);
    v4 = (void **)off_5F148;
  }
  if ( a2 && a1 )
  {
    v5 = *(_DWORD *)a2;
    if ( *(int *)a2 <= 8 )
    {
      switch ( v5 )
      {
        case 8:
          return sub_398F8(a1, *(_DWORD *)(a2 + 4));
        case 1:
          return sub_38F84(a1, *(_BYTE *)(a2 + 4));
        case 2:
          return sub_390A0(a1, *(_BYTE *)(a2 + 4));
        case 3:
          return sub_391AC(a1, *(_DWORD *)(a2 + 4));
        case 4:
          return sub_392B4(a1, *(_QWORD *)(a2 + 4));
        case 6:
          return sub_393C0(a1, *(const char **)(a2 + 4));
        case 7:
          return sub_395A8(a1, *(const wchar_t **)(a2 + 4));
      }
LABEL_28:
      if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 2u )
        sub_127D0((__int64)v4[19], 0x91u, (__int64)&unk_4DBD8, v5);
      return 18i64;
    }
    if ( v5 == 9 )
      return sub_39A0C(a1, *(const void **)(a2 + 8), *(const void **)(a2 + 16), *(_DWORD *)(a2 + 4));
    if ( v5 != 10 )
    {
      switch ( v5 )
      {
        case 11:
          return sub_39758(a1, *(const void **)(a2 + 4), *(_DWORD *)(a2 + 12));
        case 12:
          return sub_39CFC(a1, a2 + 4, *(_BYTE *)(a2 + 8));
        case 13:
          return sub_3AA24(a1, a2 + 4);
        case 14:
          return sub_3A090(a1, (unsigned __int16 *)(a2 + 4), *(_BYTE *)(a2 + 20));
      }
      goto LABEL_28;
    }
    v7 = sub_3AB8C(a1);
    v8 = v7;
    if ( v7 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x90u, (__int64)&unk_4DBD8, v7);
      result = v8;
    }
    else
    {
      result = sub_426B4(
                 (__int64 *)(*a1 + 4),
                 *(_QWORD *)(a2 + 4),
                 (__int64 (__fastcall *)(__int64 *, _QWORD))sub_3ACEC,
                 (void (__fastcall *)(__int64 *))sub_3B0E0);
    }
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x8Fu, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003AF94) ----------------------------------------------------
__int64 __fastcall sub_3AF94(__int64 a1)
{
  void **v2; // rcx
  void *v4; // rcx
  void *v5; // rcx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x93u, (__int64)&unk_4DBD8);
    v2 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x94u, (__int64)&unk_4DBD8);
    return 4i64;
  }
  if ( *(int *)a1 >= 6 )
  {
    if ( *(int *)a1 <= 7 )
    {
LABEL_16:
      v4 = *(void **)(a1 + 4);
LABEL_17:
      if ( v4 )
        sub_26488(v4, 0x6E656753u);
      goto LABEL_19;
    }
    switch ( *(_DWORD *)a1 )
    {
      case 9:
        v5 = *(void **)(a1 + 8);
        if ( v5 )
          sub_26488(v5, 0x6E656753u);
        v4 = *(void **)(a1 + 16);
        goto LABEL_17;
      case 0xA:
        sub_42938((__int64 *)(a1 + 4), (void (__fastcall *)(__int64 *))sub_3B0E0);
        break;
      case 0xB:
        goto LABEL_16;
    }
  }
LABEL_19:
  *(_DWORD *)a1 = 0;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x95u, (__int64)&unk_4DBD8);
  return 0i64;
}
// 3B0E0: using guessed type __int64 __fastcall sub_3B0E0();
// 5F148: using guessed type void *off_5F148;

//----- (000000000003B0E0) ----------------------------------------------------
__int64 __fastcall sub_3B0E0(__int64 *a1)
{
  void **v2; // rcx
  int v3; // eax
  __int64 result; // rax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x96u, (__int64)&unk_4DBD8, a1);
    v2 = (void **)off_5F148;
  }
  if ( a1 && *a1 )
  {
    v3 = sub_3AF94(*a1);
    if ( v3 && off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x98u, (__int64)&unk_4DBD8, v3);
    sub_269B0((__int64)qword_62078, *a1);
    *a1 = 0i64;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x99u, (__int64)&unk_4DBD8);
    result = 0i64;
  }
  else
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x97u, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003B22C) ----------------------------------------------------
void __fastcall sub_3B22C(__int64 a1)
{
  void **v2; // r10
  unsigned __int64 v3; // rsi
  unsigned __int16 v4; // dx
  int v5; // er8
  const wchar_t *v6; // rax
  __int64 v7; // r10
  _WORD *v8; // r11
  unsigned __int16 v9; // dx
  __int64 v10; // r10
  const wchar_t *v11; // rax
  __int64 v12; // r10
  const char *v13; // r11
  unsigned __int16 v14; // dx
  __int64 v15; // r10
  const wchar_t *v16; // rax
  __int64 v17; // r10
  const wchar_t *v18; // rax
  __int64 v19; // r10
  unsigned __int16 v20; // dx
  const wchar_t *v21; // r9
  const wchar_t *v22; // rax
  __int64 v23; // r10
  const char *v24; // rdi
  const wchar_t *v25; // rax
  const wchar_t *v26; // rax
  __int64 v27; // r10
  wchar_t *v28; // rdi
  int v29; // er8
  const wchar_t *v30; // rax
  const wchar_t *v31; // rax
  _WORD *v32; // rcx
  unsigned __int8 *v33; // rcx
  unsigned __int8 *v34; // rcx
  const wchar_t *v35; // rax
  __int64 v36; // r10
  const wchar_t *v37; // rax
  __int64 v38; // r10

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x9Au, (__int64)&unk_4DBD8, a1);
    v2 = (void **)off_5F148;
  }
  v3 = 0i64;
  if ( !a1 )
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 2u )
    {
      v4 = 155;
LABEL_113:
      sub_11008((__int64)v2[19], v4, (__int64)&unk_4DBD8);
      return;
    }
    return;
  }
  v5 = *(_DWORD *)a1;
  if ( *(int *)a1 > 8 )
  {
    switch ( v5 )
    {
      case 9:
        if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
        {
          v37 = sub_38664(9);
          sub_17860(*(_QWORD *)(v38 + 152), 0xA9u, (__int64)&unk_4DBD8, v37);
          v2 = (void **)off_5F148;
        }
        if ( *(_DWORD *)(a1 + 4) != 12 )
        {
          if ( *(_DWORD *)(a1 + 4) != 13 )
          {
            if ( *(_DWORD *)(a1 + 4) != 14 )
            {
              if ( v2 == &off_5F148 )
                return;
              if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
              {
                sub_127D0((__int64)v2[19], 0xAAu, (__int64)&unk_4DBD8, **(_DWORD **)(a1 + 8));
                goto LABEL_108;
              }
              goto LABEL_109;
            }
            sub_38A78(*(_WORD **)(a1 + 8));
            v32 = *(_WORD **)(a1 + 16);
            goto LABEL_77;
          }
          sub_38D44(*(unsigned __int8 **)(a1 + 8));
          v33 = *(unsigned __int8 **)(a1 + 16);
LABEL_79:
          sub_38D44(v33);
          goto LABEL_108;
        }
        sub_389AC(*(unsigned __int8 **)(a1 + 8));
        v34 = *(unsigned __int8 **)(a1 + 16);
        break;
      case 10:
        sub_42B90(*(_QWORD **)(a1 + 4), (void (__fastcall *)(_QWORD))sub_3B22C);
        goto LABEL_108;
      case 11:
        if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
        {
          v35 = sub_38664(v5);
          sub_17860(*(_QWORD *)(v36 + 152), 0xA6u, (__int64)&unk_4DBD8, v35);
          v2 = (void **)off_5F148;
        }
        if ( *(_DWORD *)(a1 + 12) )
        {
          do
          {
            if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 5u )
            {
              sub_1102C((__int64)v2[19], 0xA7u, (__int64)&unk_4DBD8, *(char *)(*(_QWORD *)(a1 + 4) + v3));
              v2 = (void **)off_5F148;
            }
            v3 += 10i64;
          }
          while ( v3 < *(unsigned int *)(a1 + 12) );
        }
        goto LABEL_109;
      case 12:
        v34 = (unsigned __int8 *)(a1 + 4);
        break;
      case 13:
        v33 = (unsigned __int8 *)(a1 + 4);
        goto LABEL_79;
      case 14:
        v32 = (_WORD *)(a1 + 4);
LABEL_77:
        sub_38A78(v32);
        goto LABEL_108;
      default:
        goto LABEL_72;
    }
    sub_389AC(v34);
    goto LABEL_108;
  }
  switch ( v5 )
  {
    case 8:
      if ( v2 == &off_5F148 )
        return;
      if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
      {
        v28 = (wchar_t *)sub_352B8(*(_DWORD *)(a1 + 4));
        v30 = sub_38664(v29);
        sub_34B0C(*(_QWORD *)(v10 + 152), 0xA8u, (__int64)&unk_4DBD8, v30, v28);
        goto LABEL_108;
      }
      goto LABEL_109;
    case 0:
      if ( v2 == &off_5F148 )
        return;
      if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
      {
        v26 = sub_38664(0);
        sub_17860(*(_QWORD *)(v27 + 152), 0x9Cu, (__int64)&unk_4DBD8, v26);
        goto LABEL_108;
      }
      goto LABEL_109;
    case 1:
      if ( v2 == &off_5F148 )
        return;
      if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
      {
        v24 = "FALSE";
        if ( *(_BYTE *)(a1 + 4) )
          v24 = "TRUE";
        v25 = sub_38664(v5);
        sub_34DF4(*(_QWORD *)(v15 + 152), 0x9Du, (__int64)&unk_4DBD8, v25, v24);
        goto LABEL_108;
      }
      goto LABEL_109;
    case 2:
      if ( v2 == &off_5F148 )
        return;
      if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
      {
        v22 = sub_38664(v5);
        sub_34C0C(*(_QWORD *)(v23 + 152), 158i64, (__int64)&unk_4DBD8, v22);
        goto LABEL_108;
      }
      goto LABEL_109;
    case 3:
      if ( v2 == &off_5F148 )
        return;
      if ( (*((_BYTE *)v2 + 172) & 4) == 0 || *((_BYTE *)v2 + 169) < 4u )
        goto LABEL_109;
      v18 = sub_38664(v5);
      v20 = 159;
      v21 = v18;
      goto LABEL_47;
    case 4:
      if ( v2 == &off_5F148 )
        return;
      if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
      {
        v16 = sub_38664(v5);
        sub_34D50(*(_QWORD *)(v17 + 152), 160i64, (__int64)&unk_4DBD8, v16);
        goto LABEL_108;
      }
      goto LABEL_109;
    case 6:
      if ( strlen(*(const char **)(a1 + 4)) <= 0x50 )
      {
        if ( v2 == &off_5F148 )
          return;
        if ( (*((_BYTE *)v2 + 172) & 4) == 0 || *((_BYTE *)v2 + 169) < 4u )
          goto LABEL_109;
        v11 = sub_38664(v5);
        v14 = 163;
      }
      else
      {
        if ( v2 == &off_5F148 )
          return;
        if ( (*((_BYTE *)v2 + 172) & 4) == 0 || *((_BYTE *)v2 + 169) < 4u )
          goto LABEL_109;
        v11 = sub_38664(v5);
        v14 = 162;
      }
      sub_34DF4(*(_QWORD *)(v12 + 152), v14, (__int64)&unk_4DBD8, v11, v13);
      goto LABEL_108;
  }
  if ( v5 != 7 )
  {
LABEL_72:
    if ( v2 == &off_5F148 )
      return;
    if ( (*((_BYTE *)v2 + 172) & 4) == 0 || *((_BYTE *)v2 + 169) < 4u )
      goto LABEL_109;
    v31 = sub_38664(v5);
    v20 = 171;
    v21 = v31;
LABEL_47:
    sub_34CB0(*(_QWORD *)(v19 + 152), v20, (__int64)&unk_4DBD8, v21);
    goto LABEL_108;
  }
  if ( strlen(*(const char **)(a1 + 4)) <= 0x50 )
  {
    if ( v2 == &off_5F148 )
      return;
    if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
    {
      v6 = sub_38664(v5);
      v9 = 165;
      goto LABEL_24;
    }
  }
  else
  {
    if ( v2 == &off_5F148 )
      return;
    if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
    {
      v6 = sub_38664(v5);
      v9 = 164;
LABEL_24:
      sub_34B0C(*(_QWORD *)(v7 + 152), v9, (__int64)&unk_4DBD8, v6, v8);
LABEL_108:
      v2 = (void **)off_5F148;
      goto LABEL_109;
    }
  }
LABEL_109:
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 5u )
  {
    v4 = 172;
    goto LABEL_113;
  }
}
// 3B36F: variable 'v7' is possibly undefined
// 3B37C: variable 'v8' is possibly undefined
// 3B408: variable 'v12' is possibly undefined
// 3B415: variable 'v13' is possibly undefined
// 3B47C: variable 'v17' is possibly undefined
// 3B4DB: variable 'v19' is possibly undefined
// 3B51A: variable 'v23' is possibly undefined
// 3B408: variable 'v15' is possibly undefined
// 3B5B5: variable 'v27' is possibly undefined
// 3B602: variable 'v29' is possibly undefined
// 3B36F: variable 'v10' is possibly undefined
// 3B6C0: variable 'v36' is possibly undefined
// 3B768: variable 'v38' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000003B864) ----------------------------------------------------
__int64 __fastcall sub_3B864(const void **a1, __int64 a2, unsigned int a3, unsigned int a4, unsigned int *a5, _DWORD *a6)
{
  __int64 v6; // rsi
  unsigned __int64 v7; // rbp
  _QWORD *v10; // rdi
  void **v11; // rcx
  __int64 v13; // rbx
  unsigned int v14; // esi
  void **v15; // rcx
  unsigned int v16; // er9
  int v17; // eax
  unsigned int v18; // esi
  __int64 v19; // rbx

  v6 = a4;
  v7 = a3;
  v10 = 0i64;
  v11 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xB3u, (__int64)&unk_4DBD8);
    v11 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v11 != &off_5F148 && (*((_BYTE *)v11 + 172) & 2) != 0 && *((_BYTE *)v11 + 169) >= 2u )
      sub_11008((__int64)v11[19], 0xB4u, (__int64)&unk_4DBD8);
    return 4i64;
  }
  sub_351D0(a2, v7, a1, 0x18u, v6, a5, a6);
  v13 = *a5;
  if ( a2 )
    v10 = (_QWORD *)(a2 + v6);
  v14 = 6;
  switch ( *(_DWORD *)a1 )
  {
    case 6:
      v16 = *((_DWORD *)a1 + 3) + 1;
      goto LABEL_43;
    case 7:
      v16 = 2 * *((_DWORD *)a1 + 3) + 2;
LABEL_43:
      sub_351D0(a2, v7, *(const void **)((char *)a1 + 4), v16, v13, a5, a6);
      goto LABEL_44;
    case 9:
      if ( *((_DWORD *)a1 + 1) == 512 )
      {
        v14 = 5;
      }
      else if ( *((_DWORD *)a1 + 1) != 513 )
      {
        if ( *((_DWORD *)a1 + 1) == 524 )
          v14 = 17;
        else
          v14 = 4;
      }
      sub_351D0(a2, v7, a1[1], v14, v13, a5, a6);
      if ( v10 && v13 + 8 <= v7 )
        v10[1] = v13;
      v19 = *a5;
      sub_351D0(a2, v7, a1[2], v14, *a5, a5, a6);
      if ( v10 && v19 + 8 <= v7 )
        v10[2] = v19;
      goto LABEL_47;
  }
  if ( *(_DWORD *)a1 != 10 )
  {
    if ( *(_DWORD *)a1 != 11 )
    {
      v15 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return 0i64;
      if ( (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 5u )
      {
LABEL_48:
        if ( v15 != &off_5F148 && (*((_BYTE *)v15 + 172) & 2) != 0 && *((_BYTE *)v15 + 169) >= 5u )
          sub_1102C((__int64)v15[19], 0xB7u, (__int64)&unk_4DBD8, 0);
        return 0i64;
      }
      sub_11008(*((_QWORD *)off_5F148 + 19), 0xB6u, (__int64)&unk_4DBD8);
LABEL_47:
      v15 = (void **)off_5F148;
      goto LABEL_48;
    }
    v16 = *((_DWORD *)a1 + 3);
    goto LABEL_43;
  }
  v17 = sub_434BC(
          *(const void **)((char *)a1 + 4),
          a2,
          v7,
          v13,
          a5,
          (void (__fastcall *)(_QWORD, __int64, _QWORD, _QWORD, _DWORD *, _DWORD *))sub_3B864,
          a6);
  v18 = v17;
  if ( !v17 )
  {
LABEL_44:
    if ( v10 && v13 + 8 <= v7 )
      *(_QWORD *)((char *)v10 + 4) = v13;
    goto LABEL_47;
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0xB5u, (__int64)&unk_4DBD8, v17);
  return v18;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003BB90) ----------------------------------------------------
__int64 __fastcall sub_3BB90(__int64 *a1, __int64 a2, unsigned int a3)
{
  __int64 v5; // rdi
  void **v6; // rcx
  unsigned int v7; // eax
  unsigned int v8; // ebx
  void **v9; // rcx
  unsigned __int16 v10; // dx
  int v11; // er9
  _QWORD *v13; // rcx
  unsigned int v14; // ebp
  void *v15; // rcx
  void **v16; // rcx
  unsigned __int16 v17; // dx
  void *v18; // rcx
  __int64 v19; // rdx
  size_t v20; // r8
  unsigned int v21; // ebp

  v5 = a2 + a3;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xB8u, (__int64)&unk_4DBD8);
    v6 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    v7 = sub_38F84(a1, 0);
    v8 = v7;
    if ( v7 )
    {
      v9 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        return v8;
      v10 = 186;
      goto LABEL_12;
    }
    v13 = (_QWORD *)*a1;
    v14 = 6;
    *v13 = *(_QWORD *)v5;
    v13[1] = *(_QWORD *)(v5 + 8);
    v13[2] = *(_QWORD *)(v5 + 16);
    if ( *(int *)v5 < 6 )
      goto LABEL_20;
    if ( *(int *)v5 > 7 )
    {
      if ( *(_DWORD *)v5 == 9 )
      {
        if ( *(_DWORD *)(v5 + 4) == 512 )
        {
          v14 = 5;
        }
        else if ( *(_DWORD *)(v5 + 4) != 513 )
        {
          if ( *(_DWORD *)(v5 + 4) == 524 )
            v14 = 17;
          else
            v14 = 4;
        }
        *(_QWORD *)(*a1 + 8) = sub_26404(1, v14, 0x6E656753u);
        v15 = *(void **)(*a1 + 8);
        if ( !v15 )
        {
          v16 = (void **)off_5F148;
          if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
            goto LABEL_70;
          v17 = 190;
          goto LABEL_69;
        }
        memmove(v15, (const void *)(a2 + *(unsigned int *)(v5 + 8)), v14);
        *(_QWORD *)(*a1 + 16) = sub_26404(1, v14, 0x6E656753u);
        v18 = *(void **)(*a1 + 16);
        if ( !v18 )
        {
          if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
            sub_11008(*((_QWORD *)off_5F148 + 19), 0xBFu, (__int64)&unk_4DBD8);
          v8 = 3;
          sub_26488(*(PVOID *)(*a1 + 8), 0x6E656753u);
          v16 = (void **)off_5F148;
          goto LABEL_71;
        }
        v19 = *(unsigned int *)(v5 + 16);
        v20 = v14;
LABEL_57:
        memmove(v18, (const void *)(a2 + v19), v20);
        goto LABEL_24;
      }
      if ( *(_DWORD *)v5 == 10 )
      {
        *(_QWORD *)(*a1 + 4) = 0i64;
        v7 = sub_42500(0x564C6547u, (__int64 *)(*a1 + 4), 0, (void (__fastcall *)(__int64 *))sub_3B0E0);
        v8 = v7;
        if ( v7 )
        {
          v9 = (void **)off_5F148;
          if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
            return v8;
          v10 = 188;
        }
        else
        {
          v7 = sub_43718(
                 *(__int64 **)(*a1 + 4),
                 a2,
                 *(_DWORD *)(v5 + 4),
                 (__int64 (__fastcall *)(__int64 *, __int64, _QWORD))sub_3BB90,
                 (void (__fastcall *)(__int64 *))sub_3B0E0);
          v8 = v7;
          if ( !v7 )
            goto LABEL_24;
          v9 = (void **)off_5F148;
          if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
            return v8;
          v10 = 189;
        }
LABEL_12:
        v11 = v7;
LABEL_13:
        sub_1102C((__int64)v9[19], v10, (__int64)&unk_4DBD8, v11);
        return v8;
      }
      if ( *(_DWORD *)v5 != 11 )
      {
LABEL_20:
        v9 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 )
          return v8;
        if ( (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 5u )
          goto LABEL_25;
        sub_11008(*((_QWORD *)off_5F148 + 19), 0xC0u, (__int64)&unk_4DBD8);
LABEL_24:
        v9 = (void **)off_5F148;
LABEL_25:
        if ( v9 == &off_5F148 || (*((_BYTE *)v9 + 172) & 2) == 0 || *((_BYTE *)v9 + 169) < 5u )
          return v8;
        v10 = 194;
        v11 = v8;
        goto LABEL_13;
      }
    }
    if ( *(_DWORD *)v5 == 6 )
    {
      v21 = *(_DWORD *)(v5 + 12) + 1;
    }
    else if ( *(_DWORD *)v5 == 7 )
    {
      v21 = 2 * *(_DWORD *)(v5 + 12) + 2;
    }
    else
    {
      v21 = *(_DWORD *)(v5 + 12);
    }
    *(_QWORD *)(*a1 + 4) = sub_26404(1, v21, 0x6E656753u);
    v18 = *(void **)(*a1 + 4);
    if ( !v18 )
    {
      v16 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        goto LABEL_70;
      v17 = 187;
LABEL_69:
      sub_11008((__int64)v16[19], v17, (__int64)&unk_4DBD8);
      v16 = (void **)off_5F148;
LABEL_70:
      v8 = 3;
LABEL_71:
      if ( v16 != &off_5F148 && (*((_BYTE *)v16 + 172) & 2) != 0 && *((_BYTE *)v16 + 169) >= 4u )
        sub_11008((__int64)v16[19], 0xC1u, (__int64)&unk_4DBD8);
      sub_3B0E0(a1);
      goto LABEL_24;
    }
    v19 = *(unsigned int *)(v5 + 4);
    v20 = v21;
    goto LABEL_57;
  }
  if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 2) != 0 && *((_BYTE *)v6 + 169) >= 2u )
    sub_11008((__int64)v6[19], 0xB9u, (__int64)&unk_4DBD8);
  return 4i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003C074) ----------------------------------------------------
__int64 __fastcall sub_3C074(_DWORD *a1, __int64 a2)
{
  unsigned int v2; // esi
  _DWORD *v4; // rbx
  unsigned int v5; // edi
  void **v6; // r10
  int v8; // ecx
  unsigned __int16 v9; // dx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  const wchar_t *v15; // rcx
  int v16; // eax
  bool v17; // zf
  bool v18; // sf
  bool v19; // of
  const char *v20; // rcx
  unsigned __int64 v21; // rax
  int v22; // eax
  char v23; // al
  int v24; // ecx
  int v25; // ecx
  int v26; // ecx
  int v27; // ecx
  int v28; // ecx
  unsigned int v29; // eax
  __int64 v30; // r9
  __int64 v31; // r11
  unsigned int v32; // ecx
  char v33; // r8
  int v34; // ebx
  const char *v35; // rax
  __int64 v36; // r10
  bool i; // al
  __int64 v38; // rax
  unsigned int v39; // eax
  _QWORD *v40; // rcx
  unsigned __int16 v41; // dx
  int v42; // ecx
  int v43; // edi
  int v44; // eax
  __int64 v45; // [rsp+30h] [rbp-28h]
  _DWORD *v46; // [rsp+60h] [rbp+8h]
  _QWORD *v47; // [rsp+70h] [rbp+18h] BYREF
  __int64 v48; // [rsp+78h] [rbp+20h] BYREF

  v46 = a1;
  v2 = 0;
  v4 = a1;
  v5 = 0;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0xC3u, (__int64)&unk_4DBD8, a1, a2);
    v6 = (void **)off_5F148;
  }
  if ( !v4 || !a2 )
  {
    if ( v6 == &off_5F148 || (*((_BYTE *)v6 + 172) & 2) == 0 || *((_BYTE *)v6 + 169) < 5u )
      return 1i64;
    v9 = 196;
    goto LABEL_125;
  }
  if ( *v4 == 10 && *(_DWORD *)a2 != 10 )
  {
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 2) != 0 && *((_BYTE *)v6 + 169) >= 5u )
      sub_11008((__int64)v6[19], 0xC5u, (__int64)&unk_4DBD8);
    return 8i64;
  }
  v8 = *(_DWORD *)a2;
  if ( *v4 != *(_DWORD *)a2 && v8 != 9 && v8 != 10 )
  {
    if ( v6 == &off_5F148 || (*((_BYTE *)v6 + 172) & 2) == 0 || *((_BYTE *)v6 + 169) < 5u )
      return 1i64;
    v9 = 198;
LABEL_125:
    sub_11008((__int64)v6[19], v9, (__int64)&unk_4DBD8);
    return 1i64;
  }
  if ( v8 <= 8 )
  {
    if ( v8 != 8 )
    {
      v10 = v8 - 1;
      if ( !v10 )
      {
        LOBYTE(v5) = *((_BYTE *)v4 + 4) != *(_BYTE *)(a2 + 4);
        v5 += 7;
        goto LABEL_69;
      }
      v11 = v10 - 1;
      if ( !v11 )
      {
        v23 = *((_BYTE *)v4 + 4);
        v19 = __OFSUB__(v23, *(_BYTE *)(a2 + 4));
        v17 = v23 == *(_BYTE *)(a2 + 4);
        v18 = (char)(v23 - *(_BYTE *)(a2 + 4)) < 0;
        if ( v23 != *(_BYTE *)(a2 + 4) )
        {
LABEL_43:
          LOBYTE(v5) = !(v18 ^ v19 | v17);
          goto LABEL_44;
        }
        goto LABEL_64;
      }
      v12 = v11 - 1;
      if ( v12 )
      {
        v13 = v12 - 1;
        if ( v13 )
        {
          v14 = v13 - 2;
          if ( v14 )
          {
            if ( v14 == 1 )
            {
              v15 = *(const wchar_t **)(v4 + 1);
              if ( v15 )
              {
                if ( *(_QWORD *)(a2 + 4) )
                {
                  v16 = wcsicmp(v15, *(const wchar_t **)(a2 + 4));
LABEL_32:
                  v6 = (void **)off_5F148;
                  v19 = 0;
                  v17 = v16 == 0;
                  v18 = v16 < 0;
                  goto LABEL_33;
                }
              }
            }
          }
          else
          {
            v20 = *(const char **)(v4 + 1);
            if ( v20 && *(_QWORD *)(a2 + 4) )
            {
              v16 = stricmp(v20, *(const char **)(a2 + 4));
              goto LABEL_32;
            }
          }
LABEL_38:
          v5 = 1;
          goto LABEL_69;
        }
        v21 = *(_QWORD *)(v4 + 1);
        if ( *(_QWORD *)(a2 + 4) != v21 )
        {
          v5 = *(_QWORD *)(a2 + 4) < v21;
LABEL_44:
          v5 += 5;
          goto LABEL_69;
        }
LABEL_64:
        v5 = 7;
        goto LABEL_69;
      }
    }
    v22 = v4[1];
    v19 = __OFSUB__(v22, *(_DWORD *)(a2 + 4));
    v17 = v22 == *(_DWORD *)(a2 + 4);
    v18 = v22 - *(_DWORD *)(a2 + 4) < 0;
LABEL_33:
    if ( v17 )
      goto LABEL_64;
    goto LABEL_43;
  }
  v24 = v8 - 9;
  if ( !v24 )
  {
    switch ( *v4 )
    {
      case 9:
        goto LABEL_68;
      case 0xC:
        v43 = sub_38734((__int64)(v4 + 1), *(_BYTE **)(a2 + 8));
        v44 = sub_38734((__int64)(v4 + 1), *(_BYTE **)(a2 + 16));
        break;
      case 0xE:
        goto LABEL_113;
      case 0xD:
        if ( *v4 == 14 )
        {
LABEL_113:
          v43 = sub_38870((__int64)(v4 + 1), *(_BYTE **)(a2 + 8));
          v44 = sub_38870((__int64)(v4 + 1), *(_BYTE **)(a2 + 16));
        }
        else
        {
          v43 = sub_38C6C((__int64)(v4 + 1), *(_BYTE **)(a2 + 8));
          v44 = sub_38C6C((__int64)(v4 + 1), *(_BYTE **)(a2 + 16));
        }
        break;
      default:
        v42 = v4[1];
        if ( v42 >= **(_DWORD **)(a2 + 8) && v42 <= **(_DWORD **)(a2 + 16) )
        {
          v5 = 3;
          goto LABEL_69;
        }
        goto LABEL_68;
    }
    if ( (v43 == 6 || v43 == 7) && (v44 == 5 || v44 == 7) )
    {
      v5 = 3;
      goto LABEL_56;
    }
LABEL_67:
    v6 = (void **)off_5F148;
LABEL_68:
    v5 = 8;
    goto LABEL_69;
  }
  v25 = v24 - 1;
  if ( v25 )
  {
    v26 = v25 - 1;
    if ( !v26 )
    {
      v30 = *(_QWORD *)(v4 + 1);
      if ( v30 )
      {
        v31 = *(_QWORD *)(a2 + 4);
        if ( v31 )
        {
          v32 = v4[3];
          if ( v32 == *(_DWORD *)(a2 + 12) )
          {
            if ( v32 )
            {
              do
              {
                v33 = *(_BYTE *)(v2 + v31);
                if ( *(char *)(v2 + v30) > v33 )
                  break;
                if ( *(char *)(v2 + v30) < v33 )
                  break;
                ++v2;
              }
              while ( v2 < v32 );
            }
            goto LABEL_64;
          }
        }
      }
      goto LABEL_38;
    }
    v27 = v26 - 1;
    if ( v27 )
    {
      v28 = v27 - 1;
      if ( v28 )
      {
        if ( v28 != 1 )
          goto LABEL_38;
        v29 = sub_38870((__int64)(v4 + 1), (_BYTE *)(a2 + 4));
      }
      else
      {
        v29 = sub_38C6C((__int64)(v4 + 1), (_BYTE *)(a2 + 4));
      }
    }
    else
    {
      v29 = sub_38734((__int64)(v4 + 1), (_BYTE *)(a2 + 4));
    }
    v5 = v29;
LABEL_56:
    v6 = (void **)off_5F148;
    goto LABEL_69;
  }
  v17 = *v4 == 10;
  v48 = 0i64;
  v47 = 0i64;
  if ( v17 )
  {
    v34 = sub_433EC(*(_QWORD *)(v4 + 1));
    if ( v34 != (unsigned int)sub_433EC(*(_QWORD *)(a2 + 4)) )
      goto LABEL_67;
    v4 = v46;
  }
  v45 = (__int64)v4;
  sub_439A0(*(_QWORD *)(a2 + 4), (__int64)&v47);
  if ( *v4 == 10 )
    sub_439A0(*(_QWORD *)(v4 + 1), (__int64)&v48);
  for ( i = sub_43C74(v47); !i; i = sub_43C74(v47) )
  {
    if ( *v46 == 10 )
      v45 = sub_43E74(v48);
    v38 = sub_43E74((__int64)v47);
    v39 = sub_3C074(v45, v38);
    if ( *v46 == 10 )
    {
      if ( v39 != 7 )
      {
        v5 = v39;
        break;
      }
LABEL_87:
      sub_43D50(v48);
      goto LABEL_88;
    }
    if ( v39 == 7 )
    {
      v40 = off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      {
        v41 = 199;
LABEL_97:
        sub_11008(v40[19], v41, (__int64)&unk_4DBD8);
      }
LABEL_98:
      v5 = 3;
      break;
    }
    if ( v39 == 3 )
    {
      v40 = off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      {
        v41 = 200;
        goto LABEL_97;
      }
      goto LABEL_98;
    }
    if ( *v46 == 10 )
      goto LABEL_87;
LABEL_88:
    sub_43D50((__int64)v47);
  }
  if ( *v46 == 10 )
    sub_43B64(&v48);
  sub_43B64((__int64 *)&v47);
  v6 = (void **)off_5F148;
  if ( !v5 )
  {
    v5 = 4;
    if ( *v46 == 10 )
      v5 = 7;
  }
LABEL_69:
  if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 2) != 0 && *((_BYTE *)v6 + 169) >= 5u )
  {
    v35 = sub_345E4(v5);
    sub_13618(*(_QWORD *)(v36 + 152), 0xC9u, (__int64)&unk_4DBD8, v35);
  }
  return v5;
}
// 3C337: variable 'v36' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000003C5C4) ----------------------------------------------------
__int64 __fastcall sub_3C5C4(PVOID *a1, const void *a2, unsigned int a3)
{
  size_t v3; // rsi
  void **v6; // rcx
  _QWORD *v7; // rax
  void *v9; // rcx
  void **v10; // rcx
  unsigned int v11; // ebx

  v3 = a3;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_34F90(*((_QWORD *)off_5F148 + 19), 0xCAu, (__int64)&unk_4DBD8, a1, a2, a3);
    v6 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    if ( *a1 )
    {
      if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 2) != 0 && *((_BYTE *)v6 + 169) >= 5u )
        sub_11008((__int64)v6[19], 0xCCu, (__int64)&unk_4DBD8);
      sub_3C894(a1);
    }
    v7 = sub_26404(1, 0x18u, 0x6E656753u);
    *a1 = v7;
    if ( !v7 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0xCDu, (__int64)&unk_4DBD8);
      return 3i64;
    }
    *v7 = 0i64;
    v7[1] = 0i64;
    v7[2] = 0i64;
    *(_DWORD *)*a1 = 0;
    *(_QWORD *)((char *)*a1 + 4) = sub_26404(1, v3, 0x6E656753u);
    v9 = *(void **)((char *)*a1 + 4);
    if ( v9 )
    {
      memmove(v9, a2, v3);
      *((_DWORD *)*a1 + 3) = v3;
      v11 = sub_42500(0x524C6547u, (__int64 *)*a1 + 2, 0, (void (__fastcall *)(__int64 *))sub_3DA00);
      if ( !v11 )
        goto LABEL_35;
      v10 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
      {
LABEL_34:
        sub_3C894(a1);
LABEL_35:
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
          sub_1102C(*((_QWORD *)off_5F148 + 19), 0xD1u, (__int64)&unk_4DBD8, v11);
        return v11;
      }
      if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 19), 0xCFu, (__int64)&unk_4DBD8);
        v10 = (void **)off_5F148;
      }
    }
    else
    {
      v10 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 19), 0xCEu, (__int64)&unk_4DBD8);
        v10 = (void **)off_5F148;
      }
      v11 = 3;
    }
    if ( v10 != &off_5F148 && (*((_BYTE *)v10 + 172) & 2) != 0 && *((_BYTE *)v10 + 169) >= 4u )
      sub_11008((__int64)v10[19], 0xD0u, (__int64)&unk_4DBD8);
    goto LABEL_34;
  }
  if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 2) != 0 && *((_BYTE *)v6 + 169) >= 2u )
    sub_11008((__int64)v6[19], 0xCBu, (__int64)&unk_4DBD8);
  return 4i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003C894) ----------------------------------------------------
__int64 __fastcall sub_3C894(PVOID *a1)
{
  void **v2; // rcx
  void *v3; // rcx
  __int64 result; // rax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xDAu, (__int64)&unk_4DBD8);
    v2 = (void **)off_5F148;
  }
  if ( a1 && *a1 )
  {
    sub_42938((__int64 *)*a1 + 2, (void (__fastcall *)(__int64 *))sub_3DA00);
    v3 = *(void **)((char *)*a1 + 4);
    if ( v3 )
      sub_26488(v3, 0x6E656753u);
    sub_26488(*a1, 0x6E656753u);
    *a1 = 0i64;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0xDCu, (__int64)&unk_4DBD8);
    result = 0i64;
  }
  else
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0xDBu, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003C9C8) ----------------------------------------------------
__int64 __fastcall sub_3C9C8(__int64 a1)
{
  void **v2; // rcx
  __int64 result; // rax
  __int64 v4; // rcx
  const char *v5; // r9

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      result = sub_11008(*((_QWORD *)off_5F148 + 19), 0xDDu, (__int64)&unk_4DBD8);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 )
    {
      if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
      {
        result = sub_11008((__int64)v2[19], 0xDEu, (__int64)&unk_4DBD8);
        v2 = (void **)off_5F148;
      }
      if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
      {
        result = sub_11008((__int64)v2[19], 0xDFu, (__int64)&unk_4DBD8);
        v2 = (void **)off_5F148;
      }
    }
  }
  if ( a1 )
  {
    if ( v2 != &off_5F148 )
    {
      if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
      {
        sub_11008((__int64)v2[19], 0xE1u, (__int64)&unk_4DBD8);
        v2 = (void **)off_5F148;
      }
      if ( v2 != &off_5F148 )
      {
        if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
        {
          v4 = (__int64)v2[19];
          v5 = "Cannot get version\n";
          if ( *(_QWORD *)(a1 + 4) )
            v5 = *(const char **)(a1 + 4);
          sub_13618(v4, 0xE2u, (__int64)&unk_4DBD8, v5);
          v2 = (void **)off_5F148;
        }
        if ( v2 != &off_5F148 )
        {
          if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
          {
            sub_11008((__int64)v2[19], 0xE3u, (__int64)&unk_4DBD8);
            v2 = (void **)off_5F148;
          }
          if ( v2 != &off_5F148 )
          {
            if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
            {
              sub_11008((__int64)v2[19], 0xE4u, (__int64)&unk_4DBD8);
              v2 = (void **)off_5F148;
            }
            if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
              sub_11008((__int64)v2[19], 0xE5u, (__int64)&unk_4DBD8);
          }
        }
      }
    }
    result = sub_42B90(*(_QWORD **)(a1 + 16), (void (__fastcall *)(_QWORD))sub_3DE0C);
    goto LABEL_41;
  }
  if ( v2 == &off_5F148 )
    return result;
  if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 2u )
  {
    result = sub_11008((__int64)v2[19], 0xE0u, (__int64)&unk_4DBD8);
LABEL_41:
    v2 = (void **)off_5F148;
  }
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 5u )
    result = sub_11008((__int64)v2[19], 0xE6u, (__int64)&unk_4DBD8);
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003CC40) ----------------------------------------------------
__int64 __fastcall sub_3CC40(__int64 a1, _QWORD *a2, unsigned int *a3)
{
  void **v6; // rcx
  unsigned __int64 v7; // rsi
  __int64 v8; // rbp
  __int64 v9; // rbp
  __int64 result; // rax
  unsigned int v11; // [rsp+60h] [rbp+8h] BYREF

  v11 = 0;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_143EC(*((_QWORD *)off_5F148 + 19), 0xE7u, (__int64)&unk_4DBD8, a1, a2, a3);
    v6 = (void **)off_5F148;
  }
  if ( a1 && a3 )
  {
    v7 = *a3;
    *a3 = 0;
    if ( a2 )
      memset(a2, 0, v7);
    sub_351D0((__int64)a2, v7, (const void *)a1, 0x18u, 0, &v11, a3);
    v8 = v11;
    sub_351D0((__int64)a2, v7, *(const void **)(a1 + 4), *(_DWORD *)(a1 + 12), v11, &v11, a3);
    if ( a2 && v8 + 8 <= v7 )
      *(_QWORD *)((char *)a2 + 4) = v8;
    v9 = v11;
    sub_434BC(
      *(_QWORD **)(a1 + 16),
      (__int64)a2,
      v7,
      v11,
      &v11,
      (void (__fastcall *)(_QWORD, __int64, _QWORD, _QWORD, _DWORD *, _DWORD *))sub_3E4EC,
      a3);
    if ( a2 && v9 + 8 <= v7 )
      a2[2] = v9;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0xE9u, (__int64)&unk_4DBD8);
    result = 0i64;
  }
  else
  {
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 2) != 0 && *((_BYTE *)v6 + 169) >= 2u )
      sub_11008((__int64)v6[19], 0xE8u, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003CE18) ----------------------------------------------------
__int64 __fastcall sub_3CE18(PVOID *a1, const char *a2)
{
  void **v4; // rcx
  __int64 result; // rax
  int v6; // eax
  unsigned int v7; // edi
  int v8; // eax
  unsigned int v9; // ebx

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_28DD0(*((_QWORD *)off_5F148 + 19), 0xEAu, (__int64)&unk_4DBD8, a1, a2, 0, "1.0.0.5");
    v4 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    if ( !stricmp(&a2[*((unsigned int *)a2 + 1)], "1.0.0.5") )
    {
      v6 = sub_3C5C4(a1, &a2[*((unsigned int *)a2 + 1)], *((_DWORD *)a2 + 3));
      v7 = v6;
      if ( v6 )
      {
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
          sub_1102C(*((_QWORD *)off_5F148 + 19), 0xEDu, (__int64)&unk_4DBD8, v6);
        result = v7;
      }
      else
      {
        *(_DWORD *)*a1 = *(_DWORD *)a2;
        v8 = sub_43718(
               *((__int64 **)*a1 + 2),
               (__int64)a2,
               *((_DWORD *)a2 + 4),
               (__int64 (__fastcall *)(__int64 *, __int64, _QWORD))sub_3E80C,
               (void (__fastcall *)(__int64 *))sub_3DA00);
        v9 = v8;
        if ( v8 )
        {
          if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
            sub_1102C(*((_QWORD *)off_5F148 + 19), 0xEEu, (__int64)&unk_4DBD8, v8);
          result = v9;
        }
        else
        {
          if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
            sub_11008(*((_QWORD *)off_5F148 + 19), 0xEFu, (__int64)&unk_4DBD8);
          result = 0i64;
        }
      }
    }
    else
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_17C08(*((_QWORD *)off_5F148 + 19), 0xECu, (__int64)&unk_4DBD8, "1.0.0.5", &a2[*((unsigned int *)a2 + 1)]);
      result = 6i64;
    }
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0xEBu, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003D04C) ----------------------------------------------------
__int64 __fastcall sub_3D04C(PVOID *a1)
{
  void **v2; // rcx
  _DWORD *v4; // rax
  void **v5; // rcx
  unsigned int v6; // ebx
  unsigned __int16 v7; // dx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x101u, (__int64)&unk_4DBD8);
    v2 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x102u, (__int64)&unk_4DBD8);
    return 4i64;
  }
  if ( *a1 )
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 5u )
      sub_11008((__int64)v2[19], 0x103u, (__int64)&unk_4DBD8);
    sub_3DA00(a1);
  }
  v4 = sub_26404(1, 0x5Cu, 0x75526547u);
  *a1 = v4;
  if ( !v4 )
  {
    v5 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x104u, (__int64)&unk_4DBD8);
      v5 = (void **)off_5F148;
    }
    v6 = 3;
    goto LABEL_69;
  }
  *v4 = 0;
  memset(*a1, 0, 0x5Cui64);
  v6 = sub_398F8((__int64 *)((char *)*a1 + 4), 1045);
  if ( v6 )
  {
    v5 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 )
    {
      if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      {
        v7 = 261;
LABEL_68:
        sub_11008((__int64)v5[19], v7, (__int64)&unk_4DBD8);
        v5 = (void **)off_5F148;
        goto LABEL_69;
      }
      goto LABEL_69;
    }
  }
  else
  {
    v6 = sub_38F84((__int64 *)((char *)*a1 + 20), 0);
    if ( v6 )
    {
      v5 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 )
      {
        if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        {
          v7 = 262;
          goto LABEL_68;
        }
LABEL_69:
        if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 172) & 2) != 0 && *((_BYTE *)v5 + 169) >= 4u )
          sub_11008((__int64)v5[19], 0x10Eu, (__int64)&unk_4DBD8);
        goto LABEL_73;
      }
    }
    else
    {
      v6 = sub_38F84((__int64 *)((char *)*a1 + 28), 0);
      if ( v6 )
      {
        v5 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 )
        {
          if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
          {
            v7 = 263;
            goto LABEL_68;
          }
          goto LABEL_69;
        }
      }
      else
      {
        v6 = sub_391AC((__int64 *)((char *)*a1 + 44), 0);
        if ( v6 )
        {
          v5 = (void **)off_5F148;
          if ( off_5F148 != &off_5F148 )
          {
            if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
            {
              v7 = 264;
              goto LABEL_68;
            }
            goto LABEL_69;
          }
        }
        else
        {
          v6 = sub_395A8((__int64 *)((char *)*a1 + 52), L"No GUID");
          if ( v6 )
          {
            v5 = (void **)off_5F148;
            if ( off_5F148 != &off_5F148 )
            {
              if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
              {
                v7 = 265;
                goto LABEL_68;
              }
              goto LABEL_69;
            }
          }
          else
          {
            v6 = sub_395A8((__int64 *)((char *)*a1 + 60), L"No Prl text");
            if ( v6 )
            {
              v5 = (void **)off_5F148;
              if ( off_5F148 != &off_5F148 )
              {
                if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
                {
                  v7 = 266;
                  goto LABEL_68;
                }
                goto LABEL_69;
              }
            }
            else
            {
              v6 = sub_3F7B4((__int64 *)((char *)*a1 + 68));
              if ( v6 )
              {
                v5 = (void **)off_5F148;
                if ( off_5F148 != &off_5F148 )
                {
                  if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
                  {
                    v7 = 267;
                    goto LABEL_68;
                  }
                  goto LABEL_69;
                }
              }
              else
              {
                v6 = sub_3FE74((__int64 **)((char *)*a1 + 76));
                if ( v6 )
                {
                  v5 = (void **)off_5F148;
                  if ( off_5F148 != &off_5F148 )
                  {
                    if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
                    {
                      v7 = 268;
                      goto LABEL_68;
                    }
                    goto LABEL_69;
                  }
                }
                else
                {
                  v6 = sub_42500(
                         0x414C6547u,
                         (__int64 *)((char *)*a1 + 84),
                         0,
                         (void (__fastcall *)(__int64 *))sub_41AAC);
                  if ( !v6 )
                    goto LABEL_74;
                  v5 = (void **)off_5F148;
                  if ( off_5F148 != &off_5F148 )
                  {
                    if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
                    {
                      v7 = 269;
                      goto LABEL_68;
                    }
                    goto LABEL_69;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_73:
  sub_3DA00(a1);
LABEL_74:
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x10Fu, (__int64)&unk_4DBD8, v6);
  return v6;
}
// 5D298: using guessed type wchar_t aNoGuid[8];
// 5D2A8: using guessed type wchar_t aNoPrlText[12];
// 5F148: using guessed type void *off_5F148;

//----- (000000000003D4C4) ----------------------------------------------------
__int64 __fastcall sub_3D4C4(PVOID *a1, __int64 a2)
{
  void **v4; // rcx
  PVOID v5; // rax
  void **v6; // rcx
  unsigned int v7; // ebx
  unsigned __int16 v8; // dx
  __int64 v9; // rdx

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x110u, (__int64)&unk_4DBD8);
    v4 = (void **)off_5F148;
  }
  if ( a2 && a1 )
  {
    if ( *a1 )
    {
      if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 5u )
        sub_11008((__int64)v4[19], 0x112u, (__int64)&unk_4DBD8);
      sub_3DA00(a1);
    }
    v5 = sub_26404(1, 0x5Cu, 0x75526547u);
    *a1 = v5;
    if ( !v5 )
    {
      v6 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x113u, (__int64)&unk_4DBD8);
        v6 = (void **)off_5F148;
      }
      v7 = 3;
      goto LABEL_71;
    }
    sub_4B4A8(v5, 0x5Cui64, (const void *)a2, 0x5Cui64);
    *(_QWORD *)((char *)*a1 + 4) = 0i64;
    *(_QWORD *)((char *)*a1 + 20) = 0i64;
    *(_QWORD *)((char *)*a1 + 28) = 0i64;
    *(_QWORD *)((char *)*a1 + 36) = 0i64;
    *(_QWORD *)((char *)*a1 + 44) = 0i64;
    *(_QWORD *)((char *)*a1 + 68) = 0i64;
    *(_QWORD *)((char *)*a1 + 76) = 0i64;
    *(_QWORD *)((char *)*a1 + 84) = 0i64;
    *(_QWORD *)((char *)*a1 + 60) = 0i64;
    *(_QWORD *)((char *)*a1 + 52) = 0i64;
    v7 = sub_3ACEC((__int64 *)((char *)*a1 + 4), *(_QWORD *)(a2 + 4));
    if ( v7 )
    {
      v6 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 )
      {
        if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        {
          v8 = 276;
LABEL_70:
          sub_11008((__int64)v6[19], v8, (__int64)&unk_4DBD8);
          v6 = (void **)off_5F148;
          goto LABEL_71;
        }
        goto LABEL_71;
      }
    }
    else
    {
      v7 = sub_3ACEC((__int64 *)((char *)*a1 + 20), *(_QWORD *)(a2 + 20));
      if ( v7 )
      {
        v6 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 )
        {
          if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
          {
            v8 = 277;
            goto LABEL_70;
          }
LABEL_71:
          if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 2) != 0 && *((_BYTE *)v6 + 169) >= 4u )
            sub_11008((__int64)v6[19], 0x11Eu, (__int64)&unk_4DBD8);
          goto LABEL_75;
        }
      }
      else
      {
        v7 = sub_3ACEC((__int64 *)((char *)*a1 + 28), *(_QWORD *)(a2 + 28));
        if ( v7 )
        {
          v6 = (void **)off_5F148;
          if ( off_5F148 != &off_5F148 )
          {
            if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
            {
              v8 = 278;
              goto LABEL_70;
            }
            goto LABEL_71;
          }
        }
        else
        {
          v9 = *(_QWORD *)(a2 + 36);
          if ( v9 && (v7 = sub_3ACEC((__int64 *)((char *)*a1 + 36), v9)) != 0 )
          {
            v6 = (void **)off_5F148;
            if ( off_5F148 != &off_5F148 )
            {
              if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
              {
                v8 = 279;
                goto LABEL_70;
              }
              goto LABEL_71;
            }
          }
          else
          {
            v7 = sub_3ACEC((__int64 *)((char *)*a1 + 44), *(_QWORD *)(a2 + 44));
            if ( v7 )
            {
              v6 = (void **)off_5F148;
              if ( off_5F148 != &off_5F148 )
              {
                if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
                {
                  v8 = 280;
                  goto LABEL_70;
                }
                goto LABEL_71;
              }
            }
            else
            {
              v7 = sub_3ACEC((__int64 *)((char *)*a1 + 52), *(_QWORD *)(a2 + 52));
              if ( v7 )
              {
                v6 = (void **)off_5F148;
                if ( off_5F148 != &off_5F148 )
                {
                  if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
                  {
                    v8 = 281;
                    goto LABEL_70;
                  }
                  goto LABEL_71;
                }
              }
              else
              {
                v7 = sub_3ACEC((__int64 *)((char *)*a1 + 60), *(_QWORD *)(a2 + 60));
                if ( v7 )
                {
                  v6 = (void **)off_5F148;
                  if ( off_5F148 != &off_5F148 )
                  {
                    if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
                    {
                      v8 = 282;
                      goto LABEL_70;
                    }
                    goto LABEL_71;
                  }
                }
                else
                {
                  v7 = sub_3F8E4((__int64 *)((char *)*a1 + 68), *(_QWORD *)(a2 + 68));
                  if ( v7 )
                  {
                    v6 = (void **)off_5F148;
                    if ( off_5F148 != &off_5F148 )
                    {
                      if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
                      {
                        v8 = 283;
                        goto LABEL_70;
                      }
                      goto LABEL_71;
                    }
                  }
                  else
                  {
                    v7 = sub_400E8((__int64 **)((char *)*a1 + 76), *(__int64 **)(a2 + 76));
                    if ( v7 )
                    {
                      v6 = (void **)off_5F148;
                      if ( off_5F148 != &off_5F148 )
                      {
                        if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
                        {
                          v8 = 284;
                          goto LABEL_70;
                        }
                        goto LABEL_71;
                      }
                    }
                    else
                    {
                      v7 = sub_426B4(
                             (__int64 *)((char *)*a1 + 84),
                             *(_QWORD *)(a2 + 84),
                             (__int64 (__fastcall *)(__int64 *, _QWORD))sub_418BC,
                             (void (__fastcall *)(__int64 *))sub_41AAC);
                      if ( !v7 )
                        goto LABEL_76;
                      v6 = (void **)off_5F148;
                      if ( off_5F148 != &off_5F148 )
                      {
                        if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
                        {
                          v8 = 285;
                          goto LABEL_70;
                        }
                        goto LABEL_71;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_75:
    sub_3DA00(a1);
LABEL_76:
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x11Fu, (__int64)&unk_4DBD8, v7);
    return v7;
  }
  if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 2u )
    sub_11008((__int64)v4[19], 0x111u, (__int64)&unk_4DBD8);
  return 4i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003DA00) ----------------------------------------------------
__int64 __fastcall sub_3DA00(PVOID *a1)
{
  unsigned int v2; // ebx
  void **v3; // rcx
  int v4; // eax
  int v5; // edi
  int v6; // eax
  int v7; // edi
  int v8; // eax
  int v9; // edi
  int v10; // eax
  int v11; // edi
  int v12; // eax
  int v13; // edi
  __int64 *v14; // rcx
  int v15; // eax
  int v16; // edi
  int v17; // eax
  int v18; // edi
  int v19; // eax
  int v20; // edi
  int v21; // eax
  int v22; // edi
  int v23; // eax
  int v24; // edi
  __int64 result; // rax

  v2 = 0;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x120u, (__int64)&unk_4DBD8);
    v3 = (void **)off_5F148;
  }
  if ( a1 && *a1 )
  {
    v4 = sub_42938((__int64 *)((char *)*a1 + 84), (void (__fastcall *)(__int64 *))sub_41AAC);
    v5 = v4;
    if ( v4 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x122u, (__int64)&unk_4DBD8, v4);
      v2 = v5;
    }
    v6 = sub_40368((__int64 **)((char *)*a1 + 76));
    v7 = v6;
    if ( v6 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x123u, (__int64)&unk_4DBD8, v6);
      v2 = v7;
    }
    v8 = sub_42938((__int64 *)((char *)*a1 + 68), (void (__fastcall *)(__int64 *))sub_40F90);
    v9 = v8;
    if ( v8 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x124u, (__int64)&unk_4DBD8, v8);
      v2 = v9;
    }
    v10 = sub_3B0E0((__int64 *)((char *)*a1 + 4));
    v11 = v10;
    if ( v10 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x125u, (__int64)&unk_4DBD8, v10);
      v2 = v11;
    }
    v12 = sub_3B0E0((__int64 *)((char *)*a1 + 20));
    v13 = v12;
    if ( v12 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x126u, (__int64)&unk_4DBD8, v12);
      v2 = v13;
    }
    v14 = (__int64 *)((char *)*a1 + 36);
    if ( *v14 )
    {
      v15 = sub_3B0E0(v14);
      v16 = v15;
      if ( v15 )
      {
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
          sub_1102C(*((_QWORD *)off_5F148 + 19), 0x127u, (__int64)&unk_4DBD8, v15);
        v2 = v16;
      }
    }
    v17 = sub_3B0E0((__int64 *)((char *)*a1 + 28));
    v18 = v17;
    if ( v17 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x128u, (__int64)&unk_4DBD8, v17);
      v2 = v18;
    }
    v19 = sub_3B0E0((__int64 *)((char *)*a1 + 44));
    v20 = v19;
    if ( v19 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x129u, (__int64)&unk_4DBD8, v19);
      v2 = v20;
    }
    v21 = sub_3B0E0((__int64 *)((char *)*a1 + 52));
    v22 = v21;
    if ( v21 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x12Au, (__int64)&unk_4DBD8, v21);
      v2 = v22;
    }
    v23 = sub_3B0E0((__int64 *)((char *)*a1 + 60));
    v24 = v23;
    if ( v23 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x12Bu, (__int64)&unk_4DBD8, v23);
      v2 = v24;
    }
    sub_26488(*a1, 0x75526547u);
    *a1 = 0i64;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x12Cu, (__int64)&unk_4DBD8, v2);
    result = v2;
  }
  else
  {
    if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 172) & 2) != 0 && *((_BYTE *)v3 + 169) >= 2u )
      sub_11008((__int64)v3[19], 0x121u, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003DE0C) ----------------------------------------------------
__int64 __fastcall sub_3DE0C(__int64 a1)
{
  void **v2; // rcx
  __int64 result; // rax
  unsigned __int16 v4; // dx
  void **v5; // rcx
  void **v6; // rcx
  void **v7; // rcx
  void **v8; // rcx
  void **v9; // rcx
  void **v10; // rcx
  void **v11; // rcx
  void **v12; // rcx
  void **v13; // rcx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    result = sub_11008(*((_QWORD *)off_5F148 + 19), 0x12Du, (__int64)&unk_4DBD8);
    v2 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v2 == &off_5F148 )
      return result;
    if ( (*((_BYTE *)v2 + 172) & 4) == 0 || *((_BYTE *)v2 + 169) < 2u )
      goto LABEL_126;
    v4 = 302;
    goto LABEL_125;
  }
  if ( v2 != &off_5F148 )
  {
    if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
    {
      sub_11008((__int64)v2[19], 0x12Fu, (__int64)&unk_4DBD8);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 )
    {
      if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
      {
        sub_11008((__int64)v2[19], 0x130u, (__int64)&unk_4DBD8);
        v2 = (void **)off_5F148;
      }
      if ( v2 != &off_5F148 )
      {
        if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
        {
          sub_11008((__int64)v2[19], 0x131u, (__int64)&unk_4DBD8);
          v2 = (void **)off_5F148;
        }
        if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
          sub_11008((__int64)v2[19], 0x132u, (__int64)&unk_4DBD8);
      }
    }
  }
  sub_3B22C(*(_QWORD *)(a1 + 4));
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x133u, (__int64)&unk_4DBD8);
      v5 = (void **)off_5F148;
    }
    if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 172) & 4) != 0 && *((_BYTE *)v5 + 169) >= 4u )
      sub_11008((__int64)v5[19], 0x134u, (__int64)&unk_4DBD8);
  }
  sub_3B22C(*(_QWORD *)(a1 + 12));
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x135u, (__int64)&unk_4DBD8);
      v6 = (void **)off_5F148;
    }
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 4) != 0 && *((_BYTE *)v6 + 169) >= 4u )
      sub_11008((__int64)v6[19], 0x136u, (__int64)&unk_4DBD8);
  }
  sub_3B22C(*(_QWORD *)(a1 + 20));
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x137u, (__int64)&unk_4DBD8);
      v7 = (void **)off_5F148;
    }
    if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 172) & 4) != 0 && *((_BYTE *)v7 + 169) >= 4u )
      sub_11008((__int64)v7[19], 0x138u, (__int64)&unk_4DBD8);
  }
  sub_3B22C(*(_QWORD *)(a1 + 28));
  v8 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x139u, (__int64)&unk_4DBD8);
      v8 = (void **)off_5F148;
    }
    if ( v8 != &off_5F148 && (*((_BYTE *)v8 + 172) & 4) != 0 && *((_BYTE *)v8 + 169) >= 4u )
    {
      sub_11008((__int64)v8[19], 0x13Au, (__int64)&unk_4DBD8);
      v8 = (void **)off_5F148;
    }
  }
  if ( *(_QWORD *)(a1 + 36) )
  {
    sub_3B22C(*(_QWORD *)(a1 + 36));
LABEL_64:
    v8 = (void **)off_5F148;
    goto LABEL_65;
  }
  if ( v8 == &off_5F148 )
    goto LABEL_73;
  if ( (*((_BYTE *)v8 + 172) & 4) != 0 && *((_BYTE *)v8 + 169) >= 4u )
  {
    sub_11008((__int64)v8[19], 0x13Bu, (__int64)&unk_4DBD8);
    goto LABEL_64;
  }
LABEL_65:
  if ( v8 != &off_5F148 )
  {
    if ( (*((_BYTE *)v8 + 172) & 4) != 0 && *((_BYTE *)v8 + 169) >= 4u )
    {
      sub_11008((__int64)v8[19], 0x13Cu, (__int64)&unk_4DBD8);
      v8 = (void **)off_5F148;
    }
    if ( v8 != &off_5F148 && (*((_BYTE *)v8 + 172) & 4) != 0 && *((_BYTE *)v8 + 169) >= 4u )
      sub_11008((__int64)v8[19], 0x13Du, (__int64)&unk_4DBD8);
  }
LABEL_73:
  sub_3B22C(*(_QWORD *)(a1 + 44));
  v9 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x13Eu, (__int64)&unk_4DBD8);
      v9 = (void **)off_5F148;
    }
    if ( v9 != &off_5F148 && (*((_BYTE *)v9 + 172) & 4) != 0 && *((_BYTE *)v9 + 169) >= 4u )
      sub_11008((__int64)v9[19], 0x13Fu, (__int64)&unk_4DBD8);
  }
  sub_3B22C(*(_QWORD *)(a1 + 52));
  v10 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x140u, (__int64)&unk_4DBD8);
      v10 = (void **)off_5F148;
    }
    if ( v10 != &off_5F148 && (*((_BYTE *)v10 + 172) & 4) != 0 && *((_BYTE *)v10 + 169) >= 4u )
      sub_11008((__int64)v10[19], 0x141u, (__int64)&unk_4DBD8);
  }
  sub_3B22C(*(_QWORD *)(a1 + 60));
  v11 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x142u, (__int64)&unk_4DBD8);
      v11 = (void **)off_5F148;
    }
    if ( v11 != &off_5F148 && (*((_BYTE *)v11 + 172) & 4) != 0 && *((_BYTE *)v11 + 169) >= 4u )
      sub_11008((__int64)v11[19], 0x143u, (__int64)&unk_4DBD8);
  }
  sub_42B90(*(_QWORD **)(a1 + 68), sub_41094);
  v12 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x144u, (__int64)&unk_4DBD8);
      v12 = (void **)off_5F148;
    }
    if ( v12 != &off_5F148 )
    {
      if ( (*((_BYTE *)v12 + 172) & 4) != 0 && *((_BYTE *)v12 + 169) >= 4u )
      {
        sub_11008((__int64)v12[19], 0x145u, (__int64)&unk_4DBD8);
        v12 = (void **)off_5F148;
      }
      if ( v12 != &off_5F148 && (*((_BYTE *)v12 + 172) & 4) != 0 && *((_BYTE *)v12 + 169) >= 4u )
        sub_11008((__int64)v12[19], 0x146u, (__int64)&unk_4DBD8);
    }
  }
  sub_40484(*(_QWORD ***)(a1 + 76));
  v13 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x147u, (__int64)&unk_4DBD8);
      v13 = (void **)off_5F148;
    }
    if ( v13 != &off_5F148 )
    {
      if ( (*((_BYTE *)v13 + 172) & 4) != 0 && *((_BYTE *)v13 + 169) >= 4u )
      {
        sub_11008((__int64)v13[19], 0x148u, (__int64)&unk_4DBD8);
        v13 = (void **)off_5F148;
      }
      if ( v13 != &off_5F148 && (*((_BYTE *)v13 + 172) & 4) != 0 && *((_BYTE *)v13 + 169) >= 4u )
        sub_11008((__int64)v13[19], 0x149u, (__int64)&unk_4DBD8);
    }
  }
  result = sub_42B90(*(_QWORD **)(a1 + 84), (void (__fastcall *)(_QWORD))sub_41BF0);
  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 4) == 0 || *((_BYTE *)off_5F148 + 169) < 4u )
    {
LABEL_126:
      if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 5u )
        result = sub_11008((__int64)v2[19], 0x14Bu, (__int64)&unk_4DBD8);
      return result;
    }
    v4 = 330;
LABEL_125:
    result = sub_11008((__int64)v2[19], v4, (__int64)&unk_4DBD8);
    v2 = (void **)off_5F148;
    goto LABEL_126;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003E4EC) ----------------------------------------------------
__int64 __fastcall sub_3E4EC(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, unsigned int *a5, _DWORD *a6)
{
  unsigned __int64 v7; // r12
  __int64 v9; // rdi
  void **v11; // rcx
  __int64 v12; // r15
  __int64 v13; // r15
  const void **v14; // rcx
  __int64 v15; // r15
  __int64 v16; // r15
  __int64 v17; // r15
  __int64 v18; // r15
  __int64 v19; // r15
  __int64 v20; // r15
  __int64 v21; // r15
  __int64 v22; // r15
  __int64 result; // rax

  v7 = a3;
  v9 = a2 + a4;
  v11 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x156u, (__int64)&unk_4DBD8);
    v11 = (void **)off_5F148;
  }
  if ( a1 && a5 )
  {
    sub_351D0(a2, v7, (const void *)a1, 0x5Cu, a4, a5, a6);
    v12 = *a5;
    sub_3B864(*(const void ***)(a1 + 4), a2, v7, *a5, a5, a6);
    if ( v12 + 8 <= v7 )
      *(_QWORD *)(v9 + 4) = v12;
    v13 = *a5;
    sub_3B864(*(const void ***)(a1 + 20), a2, v7, *a5, a5, a6);
    if ( v13 + 8 <= v7 )
      *(_QWORD *)(v9 + 20) = v13;
    v14 = *(const void ***)(a1 + 36);
    if ( v14 )
    {
      v15 = *a5;
      sub_3B864(v14, a2, v7, *a5, a5, a6);
      if ( v15 + 8 <= v7 )
        *(_QWORD *)(v9 + 36) = v15;
    }
    v16 = *a5;
    sub_3B864(*(const void ***)(a1 + 28), a2, v7, *a5, a5, a6);
    if ( v16 + 8 <= v7 )
      *(_QWORD *)(v9 + 28) = v16;
    v17 = *a5;
    sub_3B864(*(const void ***)(a1 + 44), a2, v7, *a5, a5, a6);
    if ( v17 + 8 <= v7 )
      *(_QWORD *)(v9 + 44) = v17;
    v18 = *a5;
    sub_3B864(*(const void ***)(a1 + 52), a2, v7, *a5, a5, a6);
    if ( v18 + 8 <= v7 )
      *(_QWORD *)(v9 + 52) = v18;
    v19 = *a5;
    sub_3B864(*(const void ***)(a1 + 60), a2, v7, *a5, a5, a6);
    if ( v19 + 8 <= v7 )
      *(_QWORD *)(v9 + 60) = v19;
    v20 = *a5;
    sub_3FB0C(*(_QWORD **)(a1 + 68), a2, v7, *a5, a5, a6);
    if ( v20 + 8 <= v7 )
      *(_QWORD *)(v9 + 68) = v20;
    v21 = *a5;
    sub_4064C(*(_QWORD ***)(a1 + 76), a2, v7, *a5, a5, a6);
    if ( v21 + 8 <= v7 )
      *(_QWORD *)(v9 + 76) = v21;
    v22 = *a5;
    sub_434BC(
      *(_QWORD **)(a1 + 84),
      a2,
      v7,
      *a5,
      a5,
      (void (__fastcall *)(_QWORD, __int64, _QWORD, _QWORD, _DWORD *, _DWORD *))sub_41CFC,
      a6);
    if ( v22 + 8 <= v7 )
      *(_QWORD *)(v9 + 84) = v22;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x158u, (__int64)&unk_4DBD8);
    result = 0i64;
  }
  else
  {
    if ( v11 != &off_5F148 && (*((_BYTE *)v11 + 172) & 2) != 0 && *((_BYTE *)v11 + 169) >= 2u )
      sub_11008((__int64)v11[19], 0x157u, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003E80C) ----------------------------------------------------
__int64 __fastcall sub_3E80C(PVOID *a1, __int64 a2, unsigned int a3)
{
  unsigned int *v5; // rsi
  void **v6; // rcx
  int v7; // eax
  unsigned int v8; // ebx
  void **v9; // rcx
  unsigned __int16 v10; // dx
  int v11; // er9
  int v13; // eax
  unsigned __int16 v14; // dx

  v5 = (unsigned int *)(a2 + a3);
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x159u, (__int64)&unk_4DBD8);
    v6 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    v7 = sub_3D04C(a1);
    v8 = v7;
    if ( v7 )
    {
      v9 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        return v8;
      v10 = 347;
      v11 = v7;
      goto LABEL_12;
    }
    v13 = sub_3BB90((__int64 *)((char *)*a1 + 4), a2, v5[1]);
    v8 = v13;
    if ( v13 )
    {
      v9 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v8;
      if ( (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        goto LABEL_67;
      v14 = 348;
    }
    else
    {
      v13 = sub_3BB90((__int64 *)((char *)*a1 + 20), a2, v5[5]);
      v8 = v13;
      if ( v13 )
      {
        v9 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 )
          return v8;
        if ( (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
          goto LABEL_67;
        v14 = 349;
      }
      else if ( *(_QWORD *)(v5 + 9) && (v13 = sub_3BB90((__int64 *)((char *)*a1 + 36), a2, v5[9]), (v8 = v13) != 0) )
      {
        v9 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 )
          return v8;
        if ( (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
          goto LABEL_67;
        v14 = 350;
      }
      else
      {
        v13 = sub_3BB90((__int64 *)((char *)*a1 + 28), a2, v5[7]);
        v8 = v13;
        if ( v13 )
        {
          v9 = (void **)off_5F148;
          if ( off_5F148 == &off_5F148 )
            return v8;
          if ( (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
            goto LABEL_67;
          v14 = 351;
        }
        else
        {
          v13 = sub_3BB90((__int64 *)((char *)*a1 + 44), a2, v5[11]);
          v8 = v13;
          if ( v13 )
          {
            v9 = (void **)off_5F148;
            if ( off_5F148 == &off_5F148 )
              return v8;
            if ( (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
              goto LABEL_67;
            v14 = 352;
          }
          else
          {
            v13 = sub_3BB90((__int64 *)((char *)*a1 + 52), a2, v5[13]);
            v8 = v13;
            if ( v13 )
            {
              v9 = (void **)off_5F148;
              if ( off_5F148 == &off_5F148 )
                return v8;
              if ( (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
                goto LABEL_67;
              v14 = 353;
            }
            else
            {
              v13 = sub_3BB90((__int64 *)((char *)*a1 + 60), a2, v5[15]);
              v8 = v13;
              if ( v13 )
              {
                v9 = (void **)off_5F148;
                if ( off_5F148 == &off_5F148 )
                  return v8;
                if ( (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
                  goto LABEL_67;
                v14 = 354;
              }
              else
              {
                v13 = sub_3FC44((__int64 **)((char *)*a1 + 68), a2, v5[17]);
                v8 = v13;
                if ( v13 )
                {
                  v9 = (void **)off_5F148;
                  if ( off_5F148 == &off_5F148 )
                    return v8;
                  if ( (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
                    goto LABEL_67;
                  v14 = 355;
                }
                else
                {
                  v13 = sub_40810((__int64 **)((char *)*a1 + 76), a2, v5[19]);
                  v8 = v13;
                  if ( v13 )
                  {
                    v9 = (void **)off_5F148;
                    if ( off_5F148 == &off_5F148 )
                      return v8;
                    if ( (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
                      goto LABEL_67;
                    v14 = 356;
                  }
                  else
                  {
                    v13 = sub_43718(
                            *(__int64 **)((char *)*a1 + 84),
                            a2,
                            v5[21],
                            (__int64 (__fastcall *)(__int64 *, __int64, _QWORD))sub_41E74,
                            (void (__fastcall *)(__int64 *))sub_41AAC);
                    v8 = v13;
                    if ( !v13 )
                    {
LABEL_66:
                      v9 = (void **)off_5F148;
LABEL_67:
                      if ( v9 == &off_5F148 || (*((_BYTE *)v9 + 172) & 2) == 0 || *((_BYTE *)v9 + 169) < 5u )
                        return v8;
                      v10 = 358;
                      v11 = v8;
LABEL_12:
                      sub_1102C((__int64)v9[19], v10, (__int64)&unk_4DBD8, v11);
                      return v8;
                    }
                    v9 = (void **)off_5F148;
                    if ( off_5F148 == &off_5F148 )
                      return v8;
                    if ( (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
                      goto LABEL_67;
                    v14 = 357;
                  }
                }
              }
            }
          }
        }
      }
    }
    sub_1102C((__int64)v9[19], v14, (__int64)&unk_4DBD8, v13);
    goto LABEL_66;
  }
  if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 2) != 0 && *((_BYTE *)v6 + 169) >= 2u )
    sub_11008((__int64)v6[19], 0x15Au, (__int64)&unk_4DBD8);
  return 4i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003EC78) ----------------------------------------------------
__int64 __fastcall sub_3EC78(__int64 a1)
{
  void **v2; // rcx
  unsigned __int16 v4; // dx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x16Au, (__int64)&unk_4DBD8);
    v2 = (void **)off_5F148;
  }
  if ( a1 )
  {
    if ( **(_QWORD **)(a1 + 76) )
    {
      if ( v2 == &off_5F148 || (*((_BYTE *)v2 + 172) & 2) == 0 || *((_BYTE *)v2 + 169) < 5u )
        return **(_QWORD **)(a1 + 76);
      v4 = 364;
    }
    else
    {
      if ( v2 == &off_5F148 || (*((_BYTE *)v2 + 172) & 2) == 0 || *((_BYTE *)v2 + 169) < 2u )
        return **(_QWORD **)(a1 + 76);
      v4 = 365;
    }
    sub_11008((__int64)v2[19], v4, (__int64)&unk_4DBD8);
    return **(_QWORD **)(a1 + 76);
  }
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 2u )
    sub_11008((__int64)v2[19], 0x16Bu, (__int64)&unk_4DBD8);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003ED70) ----------------------------------------------------
__int64 __fastcall sub_3ED70(__int64 a1, int a2, _QWORD *a3)
{
  unsigned int v3; // ebp
  void **v7; // r10
  const wchar_t *v8; // rax
  __int64 v9; // r10
  __int64 *v11; // rdi
  __int64 v12; // rax
  const char *v13; // r9
  int v14; // [rsp+40h] [rbp+8h] BYREF
  _QWORD *v15; // [rsp+58h] [rbp+20h] BYREF

  v3 = 0;
  v15 = 0i64;
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    v8 = sub_352B8(a2);
    sub_17860(*(_QWORD *)(v9 + 152), 0x175u, (__int64)&unk_4DBD8, v8);
    v7 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 172) & 2) != 0 && *((_BYTE *)v7 + 169) >= 5u )
      sub_11008((__int64)v7[19], 0x176u, (__int64)&unk_4DBD8);
    return 4i64;
  }
  if ( a3 )
    *a3 = 0i64;
  switch ( a2 )
  {
    case 22:
      if ( !a3 )
        goto LABEL_51;
      v12 = *(_QWORD *)(a1 + 60);
      goto LABEL_50;
    case 23:
      if ( !a3 )
        goto LABEL_51;
      v12 = *(_QWORD *)(a1 + 20);
      goto LABEL_50;
    case 1044:
      if ( !a3 )
        goto LABEL_51;
      v12 = *(_QWORD *)(a1 + 4);
      goto LABEL_50;
    case 1066:
      if ( !a3 )
        goto LABEL_51;
      v12 = *(_QWORD *)(a1 + 52);
      goto LABEL_50;
    case 1068:
      if ( !a3 )
        goto LABEL_51;
      v12 = *(_QWORD *)(a1 + 44);
      goto LABEL_50;
    case 1124:
      if ( !a3 )
        goto LABEL_51;
      v12 = *(_QWORD *)(a1 + 28);
      goto LABEL_50;
  }
  if ( a2 != 1125 )
  {
    if ( !(unsigned int)sub_3FDA8(*(_QWORD *)(a1 + 68), a2, a3)
      || !(unsigned int)sub_40A10(*(__int64 **)(a1 + 76), a2, a3)
      || !(unsigned int)sub_415C0(*(_QWORD *)(*(_QWORD *)(a1 + 76) + 8i64), a2, a3) )
    {
      goto LABEL_51;
    }
    sub_439A0(*(_QWORD *)(a1 + 84), (__int64)&v15);
    while ( !sub_43C74(v15) )
    {
      v11 = (__int64 *)sub_43E74((__int64)v15);
      sub_41FFC((__int64)v11, &v14);
      if ( v14 == a2 )
      {
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
          sub_11008(*((_QWORD *)off_5F148 + 19), 0x177u, (__int64)&unk_4DBD8);
        if ( a3 )
        {
          v12 = *v11;
          goto LABEL_50;
        }
        goto LABEL_51;
      }
      sub_43D50((__int64)v15);
    }
    goto LABEL_35;
  }
  v12 = *(_QWORD *)(a1 + 36);
  if ( !v12 )
  {
LABEL_35:
    v3 = 5;
    goto LABEL_51;
  }
  if ( a3 )
LABEL_50:
    *a3 = v12;
LABEL_51:
  sub_43B64((__int64 *)&v15);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    v13 = "not found";
    if ( !v3 )
      v13 = "found";
    sub_13618(*((_QWORD *)off_5F148 + 19), 0x178u, (__int64)&unk_4DBD8, v13);
  }
  return v3;
}
// 3EDBF: variable 'v9' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000003F008) ----------------------------------------------------
__int64 __fastcall sub_3F008(__int64 a1, _BYTE *a2)
{
  void **v4; // rcx
  __int64 result; // rax
  unsigned int v6; // ebx
  const char *v7; // rax

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x179u, (__int64)&unk_4DBD8, a1, a2);
    v4 = (void **)off_5F148;
  }
  if ( a2 )
  {
    *a2 = 1;
    v6 = sub_3ED70(a1, 1125, 0i64);
    if ( v6 == 5 )
    {
      *a2 = 0;
      v6 = 0;
    }
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      v7 = "not";
      if ( *a2 )
        v7 = (const char *)&unk_4DD7A;
      sub_20144(*((_QWORD *)off_5F148 + 19), 0x17Bu, (__int64)&unk_4DBD8, v6, v7);
    }
    result = v6;
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 5u )
      sub_11008((__int64)v4[19], 0x17Au, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003F130) ----------------------------------------------------
__int64 __fastcall sub_3F130(__int64 a1, _BYTE *a2)
{
  void **v4; // rcx
  __int64 result; // rax
  unsigned int v6; // ebx
  const char *v7; // rax

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x17Cu, (__int64)&unk_4DBD8, a1, a2);
    v4 = (void **)off_5F148;
  }
  if ( a2 )
  {
    *a2 = 0;
    v6 = sub_3ED70(a1, 3, 0i64);
    if ( v6 == 5 )
    {
      v6 = sub_3ED70(a1, 5, 0i64);
      if ( v6 == 5 )
      {
        *a2 = 1;
        v6 = 0;
      }
    }
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      v7 = "not";
      if ( *a2 )
        v7 = (const char *)&unk_4DD7A;
      sub_20144(*((_QWORD *)off_5F148 + 19), 0x17Eu, (__int64)&unk_4DBD8, v6, v7);
    }
    result = v6;
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 5u )
      sub_11008((__int64)v4[19], 0x17Du, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003F278) ----------------------------------------------------
__int64 __fastcall sub_3F278(__int64 a1, bool *a2)
{
  void **v4; // rcx
  unsigned int v5; // ebx
  const char *v6; // rax
  __int64 result; // rax
  __int64 v8; // [rsp+48h] [rbp+10h] BYREF

  v8 = 0i64;
  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x17Fu, (__int64)&unk_4DBD8);
    v4 = (void **)off_5F148;
  }
  if ( a2 && a1 )
  {
    *a2 = 0;
    v5 = sub_3ED70(a1, 1044, &v8);
    if ( !v5 )
      *a2 = *(_DWORD *)(v8 + 4) == 1045;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      v6 = "not";
      if ( *a2 )
        v6 = (const char *)&unk_4DD7A;
      sub_20144(*((_QWORD *)off_5F148 + 19), 0x181u, (__int64)&unk_4DBD8, v5, v6);
    }
    result = v5;
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x180u, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003F3B8) ----------------------------------------------------
__int64 __fastcall sub_3F3B8(__int64 a1, __int64 a2)
{
  unsigned int v4; // ebx
  void **v5; // rcx
  int v6; // eax
  _QWORD *v7; // rcx
  unsigned __int16 v8; // dx
  unsigned int v9; // edi
  const char *v10; // rax
  __int64 v11; // r10
  __int64 v13; // [rsp+50h] [rbp+8h] BYREF

  v13 = 0i64;
  v4 = 7;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x182u, (__int64)&unk_4DBD8, a1, a2);
    v5 = (void **)off_5F148;
  }
  if ( !a1 || !a2 )
  {
    if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 172) & 2) != 0 && *((_BYTE *)v5 + 169) >= 5u )
      sub_11008((__int64)v5[19], 0x183u, (__int64)&unk_4DBD8);
    return 1i64;
  }
  v6 = sub_3ED70(a1, 1068, &v13);
  if ( v6 )
  {
    v7 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 5u )
      return 1i64;
    v8 = 388;
LABEL_12:
    sub_1102C(v7[19], v8, (__int64)&unk_4DBD8, v6);
    return 1i64;
  }
  v9 = *(_DWORD *)(v13 + 4);
  v6 = sub_3ED70(a2, 1068, &v13);
  if ( v6 )
  {
    v7 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 5u )
      return 1i64;
    v8 = 389;
    goto LABEL_12;
  }
  if ( v9 <= *(_DWORD *)(v13 + 4) )
  {
    if ( v9 < *(_DWORD *)(v13 + 4) )
      v4 = 5;
  }
  else
  {
    v4 = 6;
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    v10 = sub_345E4(v4);
    sub_13618(*(_QWORD *)(v11 + 152), 0x186u, (__int64)&unk_4DBD8, v10);
  }
  return v4;
}
// 3F528: variable 'v11' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000003F594) ----------------------------------------------------
__int64 __fastcall sub_3F594(__int64 a1, __int64 a2)
{
  unsigned int v4; // ebx
  void **v5; // rcx
  int v6; // eax
  _QWORD *v7; // rcx
  unsigned __int16 v8; // dx
  int v9; // eax
  const char *v10; // rax
  __int64 v11; // r10
  __int64 v13; // [rsp+60h] [rbp+8h] BYREF
  __int64 v14; // [rsp+70h] [rbp+18h] BYREF

  v14 = 0i64;
  v13 = 0i64;
  v4 = 7;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x187u, (__int64)&unk_4DBD8, a1, a2);
    v5 = (void **)off_5F148;
  }
  if ( !a1 || !a2 )
  {
    if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 172) & 2) != 0 && *((_BYTE *)v5 + 169) >= 5u )
      sub_11008((__int64)v5[19], 0x188u, (__int64)&unk_4DBD8);
    return 1i64;
  }
  v6 = sub_3ED70(a1, 1066, &v14);
  if ( v6 )
  {
    v7 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 5u )
      return 1i64;
    v8 = 393;
LABEL_12:
    sub_1102C(v7[19], v8, (__int64)&unk_4DBD8, v6);
    return 1i64;
  }
  v6 = sub_3ED70(a2, 1066, &v13);
  if ( v6 )
  {
    v7 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 5u )
      return 1i64;
    v8 = 394;
    goto LABEL_12;
  }
  if ( !v14 || !v13 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_143A4(*((_QWORD *)off_5F148 + 19), 0x18Bu, (__int64)&unk_4DBD8);
    return 1i64;
  }
  v9 = wcsicmp(*(const wchar_t **)(v14 + 4), *(const wchar_t **)(v13 + 4));
  if ( v9 <= 0 )
  {
    if ( v9 < 0 )
      v4 = 5;
  }
  else
  {
    v4 = 6;
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    v10 = sub_345E4(v4);
    sub_13618(*(_QWORD *)(v11 + 152), 0x18Cu, (__int64)&unk_4DBD8, v10);
  }
  return v4;
}
// 3F716: variable 'v11' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000003F7B4) ----------------------------------------------------
__int64 __fastcall sub_3F7B4(__int64 *a1)
{
  void **v2; // rcx
  __int64 result; // rax
  unsigned int v4; // ebx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x18Du, (__int64)&unk_4DBD8);
    v2 = (void **)off_5F148;
  }
  if ( a1 )
  {
    if ( *a1 )
    {
      if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 5u )
        sub_11008((__int64)v2[19], 0x18Fu, (__int64)&unk_4DBD8);
      sub_3FA68(a1);
    }
    v4 = sub_42500(0x484C6547u, a1, 0, (void (__fastcall *)(__int64 *))sub_40F90);
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x190u, (__int64)&unk_4DBD8);
    result = v4;
  }
  else
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x18Eu, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003F8E4) ----------------------------------------------------
__int64 __fastcall sub_3F8E4(__int64 *a1, __int64 a2)
{
  void **v4; // rcx
  unsigned int v5; // ebx
  void **v6; // rcx

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x191u, (__int64)&unk_4DBD8);
    v4 = (void **)off_5F148;
  }
  if ( a2 && a1 )
  {
    if ( *a1 )
    {
      if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 5u )
        sub_11008((__int64)v4[19], 0x193u, (__int64)&unk_4DBD8);
      sub_3FA68(a1);
    }
    v5 = sub_426B4(
           a1,
           a2,
           (__int64 (__fastcall *)(__int64 *, _QWORD))sub_40D54,
           (void (__fastcall *)(__int64 *))sub_40F90);
    if ( v5 )
    {
      v6 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 )
        return v5;
      if ( (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
      {
LABEL_19:
        if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 2) != 0 && *((_BYTE *)v6 + 169) >= 5u )
          sub_1102C((__int64)v6[19], 0x195u, (__int64)&unk_4DBD8, v5);
        return v5;
      }
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x194u, (__int64)&unk_4DBD8);
    }
    v6 = (void **)off_5F148;
    goto LABEL_19;
  }
  if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 2u )
    sub_11008((__int64)v4[19], 0x192u, (__int64)&unk_4DBD8);
  return 4i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003FA68) ----------------------------------------------------
__int64 __fastcall sub_3FA68(__int64 *a1)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x196u, (__int64)&unk_4DBD8);
  sub_42938(a1, (void (__fastcall *)(__int64 *))sub_40F90);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x197u, (__int64)&unk_4DBD8);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003FB0C) ----------------------------------------------------
__int64 __fastcall sub_3FB0C(_QWORD *a1, __int64 a2, unsigned int a3, unsigned int a4, _DWORD *a5, _DWORD *a6)
{
  void **v10; // rcx
  unsigned int v11; // ebx
  __int64 result; // rax

  v10 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x19Cu, (__int64)&unk_4DBD8);
    v10 = (void **)off_5F148;
  }
  if ( a1 && a5 )
  {
    v11 = sub_434BC(
            a1,
            a2,
            a3,
            a4,
            a5,
            (void (__fastcall *)(_QWORD, __int64, _QWORD, _QWORD, _DWORD *, _DWORD *))sub_412B4,
            a6);
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x19Eu, (__int64)&unk_4DBD8);
    result = v11;
  }
  else
  {
    if ( v10 != &off_5F148 && (*((_BYTE *)v10 + 172) & 2) != 0 && *((_BYTE *)v10 + 169) >= 2u )
      sub_11008((__int64)v10[19], 0x19Du, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003FC44) ----------------------------------------------------
__int64 __fastcall sub_3FC44(__int64 **a1, __int64 a2, unsigned int a3)
{
  void **v6; // rcx
  int v7; // eax
  unsigned int v8; // ebx
  __int64 result; // rax

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x19Fu, (__int64)&unk_4DBD8);
    v6 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    v7 = sub_43718(
           *a1,
           a2,
           a3,
           (__int64 (__fastcall *)(__int64 *, __int64, _QWORD))sub_4142C,
           (void (__fastcall *)(__int64 *))sub_40F90);
    v8 = v7;
    if ( v7 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x1A1u, (__int64)&unk_4DBD8, v7);
      result = v8;
    }
    else
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x1A2u, (__int64)&unk_4DBD8);
      result = 0i64;
    }
  }
  else
  {
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 2) != 0 && *((_BYTE *)v6 + 169) >= 2u )
      sub_11008((__int64)v6[19], 0x1A0u, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000003FDA8) ----------------------------------------------------
__int64 __fastcall sub_3FDA8(__int64 a1, int a2, _QWORD *a3)
{
  const wchar_t *v6; // rax
  __int64 v7; // r10
  int v8; // eax
  unsigned int v9; // ebx

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    v6 = sub_352B8(a2);
    sub_17860(*(_QWORD *)(v7 + 152), 0x1A3u, (__int64)&unk_4DBD8, v6);
  }
  v8 = sub_415C0(a1, a2, a3);
  v9 = v8;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x1A4u, (__int64)&unk_4DBD8, v8);
  return v9;
}
// 3FDF2: variable 'v7' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000003FE74) ----------------------------------------------------
__int64 __fastcall sub_3FE74(__int64 **a1)
{
  void **v2; // rcx
  __int64 *v4; // rax
  unsigned int v5; // edi
  void **v6; // rcx
  unsigned __int16 v7; // dx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1A5u, (__int64)&unk_4DBD8);
    v2 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x1A6u, (__int64)&unk_4DBD8);
    return 4i64;
  }
  if ( *a1 )
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 5u )
      sub_11008((__int64)v2[19], 0x1A7u, (__int64)&unk_4DBD8);
    sub_40368(a1);
  }
  v4 = (__int64 *)sub_26404(1, 0x10u, 0x6B436547u);
  *a1 = v4;
  if ( !v4 )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x1A8u, (__int64)&unk_4DBD8);
    return 3i64;
  }
  *v4 = 0i64;
  v4[1] = 0i64;
  v5 = sub_42500(0x434C6547u, *a1, 0, (void (__fastcall *)(__int64 *))sub_40F90);
  if ( v5 )
  {
    v6 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 )
    {
      if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      {
        v7 = 425;
LABEL_33:
        sub_11008((__int64)v6[19], v7, (__int64)&unk_4DBD8);
        v6 = (void **)off_5F148;
        goto LABEL_34;
      }
      goto LABEL_34;
    }
  }
  else
  {
    v5 = sub_42500(0x434C6547u, *a1 + 1, 0, (void (__fastcall *)(__int64 *))sub_40F90);
    if ( !v5 )
      goto LABEL_39;
    v6 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 )
    {
      if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      {
        v7 = 426;
        goto LABEL_33;
      }
LABEL_34:
      if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 2) != 0 && *((_BYTE *)v6 + 169) >= 4u )
        sub_11008((__int64)v6[19], 0x1ABu, (__int64)&unk_4DBD8);
      goto LABEL_38;
    }
  }
LABEL_38:
  sub_40368(a1);
LABEL_39:
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x1ACu, (__int64)&unk_4DBD8, v5);
  return v5;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000400E8) ----------------------------------------------------
__int64 __fastcall sub_400E8(__int64 **a1, __int64 *a2)
{
  void **v4; // rcx
  __int64 *v5; // rax
  unsigned int v7; // edi
  void **v8; // rcx
  unsigned __int16 v9; // dx

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1ADu, (__int64)&unk_4DBD8);
    v4 = (void **)off_5F148;
  }
  if ( a2 && a1 )
  {
    if ( *a1 )
    {
      if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 5u )
        sub_11008((__int64)v4[19], 0x1AFu, (__int64)&unk_4DBD8);
      sub_40368(a1);
    }
    v5 = (__int64 *)sub_26404(1, 0x10u, 0x6B436547u);
    *a1 = v5;
    if ( !v5 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x1B0u, (__int64)&unk_4DBD8);
      return 3i64;
    }
    *v5 = 0i64;
    v5[1] = 0i64;
    v7 = sub_426B4(
           *a1,
           *a2,
           (__int64 (__fastcall *)(__int64 *, _QWORD))sub_40D54,
           (void (__fastcall *)(__int64 *))sub_40F90);
    if ( v7 )
    {
      v8 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 )
      {
        if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        {
          v9 = 433;
LABEL_29:
          sub_11008((__int64)v8[19], v9, (__int64)&unk_4DBD8);
          v8 = (void **)off_5F148;
          goto LABEL_30;
        }
        goto LABEL_30;
      }
    }
    else
    {
      v7 = sub_426B4(
             *a1 + 1,
             a2[1],
             (__int64 (__fastcall *)(__int64 *, _QWORD))sub_40D54,
             (void (__fastcall *)(__int64 *))sub_40F90);
      if ( !v7 )
        goto LABEL_35;
      v8 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 )
      {
        if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        {
          v9 = 434;
          goto LABEL_29;
        }
LABEL_30:
        if ( v8 != &off_5F148 && (*((_BYTE *)v8 + 172) & 2) != 0 && *((_BYTE *)v8 + 169) >= 4u )
          sub_11008((__int64)v8[19], 0x1B3u, (__int64)&unk_4DBD8);
        goto LABEL_34;
      }
    }
LABEL_34:
    sub_40368(a1);
LABEL_35:
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x1B4u, (__int64)&unk_4DBD8, v7);
    return v7;
  }
  if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 2u )
    sub_11008((__int64)v4[19], 0x1AEu, (__int64)&unk_4DBD8);
  return 4i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000040368) ----------------------------------------------------
__int64 __fastcall sub_40368(__int64 **a1)
{
  void **v2; // rcx
  __int64 result; // rax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1B5u, (__int64)&unk_4DBD8);
    v2 = (void **)off_5F148;
  }
  if ( a1 && *a1 )
  {
    sub_42938(*a1, (void (__fastcall *)(__int64 *))sub_40F90);
    sub_42938(*a1 + 1, (void (__fastcall *)(__int64 *))sub_40F90);
    sub_26488(*a1, 0x6B436547u);
    *a1 = 0i64;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x1B7u, (__int64)&unk_4DBD8);
    result = 0i64;
  }
  else
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x1B6u, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000040484) ----------------------------------------------------
__int64 __fastcall sub_40484(_QWORD **a1)
{
  void **v2; // rcx
  __int64 result; // rax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    result = sub_11008(*((_QWORD *)off_5F148 + 19), 0x1B8u, (__int64)&unk_4DBD8);
    v2 = (void **)off_5F148;
  }
  if ( a1 )
  {
    if ( v2 != &off_5F148 )
    {
      if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
      {
        sub_11008((__int64)v2[19], 0x1BAu, (__int64)&unk_4DBD8);
        v2 = (void **)off_5F148;
      }
      if ( v2 != &off_5F148 )
      {
        if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
        {
          sub_11008((__int64)v2[19], 0x1BBu, (__int64)&unk_4DBD8);
          v2 = (void **)off_5F148;
        }
        if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
          sub_11008((__int64)v2[19], 0x1BCu, (__int64)&unk_4DBD8);
      }
    }
    sub_42B90(*a1, sub_41094);
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x1BDu, (__int64)&unk_4DBD8);
    result = sub_42B90(a1[1], sub_41094);
    goto LABEL_27;
  }
  if ( v2 == &off_5F148 )
    return result;
  if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 2u )
  {
    result = sub_11008((__int64)v2[19], 0x1B9u, (__int64)&unk_4DBD8);
LABEL_27:
    v2 = (void **)off_5F148;
  }
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 5u )
    result = sub_11008((__int64)v2[19], 0x1BEu, (__int64)&unk_4DBD8);
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000004064C) ----------------------------------------------------
__int64 __fastcall sub_4064C(_QWORD **a1, __int64 a2, unsigned int a3, unsigned int a4, unsigned int *a5, _DWORD *a6)
{
  unsigned __int64 v7; // r13
  __int64 v10; // rbx
  void **v11; // rcx
  __int64 v12; // rsi
  __int64 v13; // rsi
  __int64 result; // rax

  v7 = a3;
  v10 = a4;
  v11 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1C3u, (__int64)&unk_4DBD8);
    v11 = (void **)off_5F148;
  }
  if ( a1 && a5 )
  {
    sub_351D0(a2, v7, a1, 0x10u, a4, a5, a6);
    v12 = *a5;
    sub_434BC(
      *a1,
      a2,
      v7,
      *a5,
      a5,
      (void (__fastcall *)(_QWORD, __int64, _QWORD, _QWORD, _DWORD *, _DWORD *))sub_412B4,
      a6);
    if ( v12 + 8 <= v7 )
      *(_QWORD *)(v10 + a2) = v12;
    v13 = *a5;
    sub_434BC(
      a1[1],
      a2,
      v7,
      *a5,
      a5,
      (void (__fastcall *)(_QWORD, __int64, _QWORD, _QWORD, _DWORD *, _DWORD *))sub_412B4,
      a6);
    if ( v13 + 8 <= v7 )
      *(_QWORD *)(v10 + a2 + 8) = v13;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x1C5u, (__int64)&unk_4DBD8);
    result = 0i64;
  }
  else
  {
    if ( v11 != &off_5F148 && (*((_BYTE *)v11 + 172) & 2) != 0 && *((_BYTE *)v11 + 169) >= 2u )
      sub_11008((__int64)v11[19], 0x1C4u, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000040810) ----------------------------------------------------
__int64 __fastcall sub_40810(__int64 **a1, __int64 a2, unsigned int a3)
{
  __int64 v5; // rbp
  void **v6; // rcx
  int v7; // eax
  unsigned int v8; // ebx
  _QWORD *v9; // rcx
  unsigned __int16 v10; // dx
  __int64 result; // rax

  v5 = a3;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1C6u, (__int64)&unk_4DBD8);
    v6 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    v7 = sub_3FE74(a1);
    v8 = v7;
    if ( v7 )
    {
      v9 = off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        return v8;
      v10 = 456;
LABEL_12:
      sub_1102C(v9[19], v10, (__int64)&unk_4DBD8, v7);
      return v8;
    }
    v7 = sub_43718(
           (__int64 *)**a1,
           a2,
           *(_DWORD *)(v5 + a2),
           (__int64 (__fastcall *)(__int64 *, __int64, _QWORD))sub_4142C,
           (void (__fastcall *)(__int64 *))sub_40F90);
    v8 = v7;
    if ( v7 )
    {
      v9 = off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        return v8;
      v10 = 457;
      goto LABEL_12;
    }
    v7 = sub_43718(
           (__int64 *)(*a1)[1],
           a2,
           *(_DWORD *)(v5 + a2 + 8),
           (__int64 (__fastcall *)(__int64 *, __int64, _QWORD))sub_4142C,
           (void (__fastcall *)(__int64 *))sub_40F90);
    v8 = v7;
    if ( v7 )
    {
      v9 = off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        return v8;
      v10 = 458;
      goto LABEL_12;
    }
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x1CBu, (__int64)&unk_4DBD8);
    result = 0i64;
  }
  else
  {
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 2) != 0 && *((_BYTE *)v6 + 169) >= 2u )
      sub_11008((__int64)v6[19], 0x1C7u, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000040A10) ----------------------------------------------------
__int64 __fastcall sub_40A10(__int64 *a1, int a2, _QWORD *a3)
{
  void **v6; // r10
  const wchar_t *v7; // rax
  __int64 v8; // r10
  _QWORD *v10; // rcx
  unsigned __int16 v11; // dx

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    v7 = sub_352B8(a2);
    sub_17860(*(_QWORD *)(v8 + 152), 0x1CCu, (__int64)&unk_4DBD8, v7);
    v6 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 2) != 0 && *((_BYTE *)v6 + 169) >= 5u )
      sub_11008((__int64)v6[19], 0x1CDu, (__int64)&unk_4DBD8);
    return 4i64;
  }
  if ( !(unsigned int)sub_415C0(*a1, a2, a3) )
  {
    v10 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 5u )
      return 0i64;
    v11 = 462;
LABEL_16:
    sub_11008(v10[19], v11, (__int64)&unk_4DBD8);
    return 0i64;
  }
  if ( !(unsigned int)sub_415C0(a1[1], a2, a3) )
  {
    v10 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 5u )
      return 0i64;
    v11 = 463;
    goto LABEL_16;
  }
  if ( a3 )
    *a3 = 0i64;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1D0u, (__int64)&unk_4DBD8);
  return 5i64;
}
// 40A66: variable 'v8' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (0000000000040BA0) ----------------------------------------------------
__int64 __fastcall sub_40BA0(__int64 **a1, int a2, int a3, int a4)
{
  void **v8; // rcx
  __int64 result; // rax
  __int64 *v10; // rax

  v8 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1D1u, (__int64)&unk_4DBD8);
    v8 = (void **)off_5F148;
  }
  if ( a1 )
  {
    if ( *a1 )
    {
      if ( v8 != &off_5F148 && (*((_BYTE *)v8 + 172) & 2) != 0 && *((_BYTE *)v8 + 169) >= 5u )
        sub_11008((__int64)v8[19], 0x1D3u, (__int64)&unk_4DBD8);
      sub_40F90(a1);
    }
    v10 = (__int64 *)sub_26404(1, 0x14u, 0x78456547u);
    *a1 = v10;
    if ( v10 )
    {
      *v10 = 0i64;
      v10[1] = 0i64;
      *((_DWORD *)v10 + 4) = 0;
      *((_DWORD *)*a1 + 2) = a2;
      *((_DWORD *)*a1 + 3) = a3;
      *((_DWORD *)*a1 + 4) = a4;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x1D5u, (__int64)&unk_4DBD8, 0);
      result = 0i64;
    }
    else
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x1D4u, (__int64)&unk_4DBD8);
      result = 3i64;
    }
  }
  else
  {
    if ( v8 != &off_5F148 && (*((_BYTE *)v8 + 172) & 2) != 0 && *((_BYTE *)v8 + 169) >= 2u )
      sub_11008((__int64)v8[19], 0x1D2u, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000040D54) ----------------------------------------------------
__int64 __fastcall sub_40D54(__int64 **a1, __int64 a2)
{
  void **v4; // rcx
  __int64 *v5; // rax
  __int64 result; // rax
  unsigned int v7; // edi
  void **v8; // rcx

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1D6u, (__int64)&unk_4DBD8);
    v4 = (void **)off_5F148;
  }
  if ( a2 && a1 )
  {
    if ( *a1 )
    {
      if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 5u )
        sub_11008((__int64)v4[19], 0x1D8u, (__int64)&unk_4DBD8);
      sub_40F90(a1);
    }
    v5 = (__int64 *)sub_26404(1, 0x14u, 0x78456547u);
    *a1 = v5;
    if ( v5 )
    {
      *v5 = 0i64;
      v5[1] = 0i64;
      *((_DWORD *)v5 + 4) = 0;
      *((_DWORD *)*a1 + 2) = *(_DWORD *)(a2 + 8);
      *((_DWORD *)*a1 + 3) = *(_DWORD *)(a2 + 12);
      *((_DWORD *)*a1 + 4) = *(_DWORD *)(a2 + 16);
      v7 = sub_3ACEC(*a1, *(_QWORD *)a2);
      if ( v7 )
      {
        v8 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 )
        {
          if ( (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
          {
            sub_11008(*((_QWORD *)off_5F148 + 19), 0x1DAu, (__int64)&unk_4DBD8);
            v8 = (void **)off_5F148;
          }
          if ( v8 != &off_5F148 && (*((_BYTE *)v8 + 172) & 2) != 0 && *((_BYTE *)v8 + 169) >= 4u )
            sub_11008((__int64)v8[19], 0x1DBu, (__int64)&unk_4DBD8);
        }
        sub_40F90(a1);
      }
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x1DCu, (__int64)&unk_4DBD8, v7);
      result = v7;
    }
    else
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x1D9u, (__int64)&unk_4DBD8);
      result = 3i64;
    }
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x1D7u, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000040F90) ----------------------------------------------------
__int64 __fastcall sub_40F90(__int64 **a1)
{
  void **v2; // rcx
  __int64 result; // rax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x1DDu, (__int64)&unk_4DBD8, a1);
    v2 = (void **)off_5F148;
  }
  if ( a1 && *a1 )
  {
    sub_3B0E0(*a1);
    sub_26488(*a1, 0x78456547u);
    *a1 = 0i64;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x1DFu, (__int64)&unk_4DBD8);
    result = 0i64;
  }
  else
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x1DEu, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000041094) ----------------------------------------------------
void __fastcall sub_41094(__int64 a1)
{
  void **v2; // r10
  const wchar_t *v3; // rax
  __int64 v4; // r10
  const wchar_t *v5; // rax
  __int64 v6; // r10
  const wchar_t *v7; // rax
  __int64 v8; // r10

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x1E0u, (__int64)&unk_4DBD8, a1);
    v2 = (void **)off_5F148;
  }
  if ( a1 )
  {
    if ( v2 != &off_5F148 )
    {
      if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
      {
        sub_11008((__int64)v2[19], 0x1E2u, (__int64)&unk_4DBD8);
        v2 = (void **)off_5F148;
      }
      if ( v2 != &off_5F148 )
      {
        if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
        {
          v3 = sub_352B8(*(_DWORD *)(a1 + 8));
          sub_17860(*(_QWORD *)(v4 + 152), 0x1E3u, (__int64)&unk_4DBD8, v3);
          v2 = (void **)off_5F148;
        }
        if ( v2 != &off_5F148 )
        {
          if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
          {
            v5 = sub_35224(*(_DWORD *)(a1 + 12));
            sub_17860(*(_QWORD *)(v6 + 152), 0x1E4u, (__int64)&unk_4DBD8, v5);
            v2 = (void **)off_5F148;
          }
          if ( v2 != &off_5F148 )
          {
            if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
            {
              v7 = sub_35224(*(_DWORD *)(a1 + 16));
              sub_17860(*(_QWORD *)(v8 + 152), 0x1E5u, (__int64)&unk_4DBD8, v7);
              v2 = (void **)off_5F148;
            }
            if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
              sub_11008((__int64)v2[19], 0x1E6u, (__int64)&unk_4DBD8);
          }
        }
      }
    }
    sub_3B22C(*(_QWORD *)a1);
    goto LABEL_31;
  }
  if ( v2 == &off_5F148 )
    return;
  if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 2u )
  {
    sub_11008((__int64)v2[19], 0x1E1u, (__int64)&unk_4DBD8);
LABEL_31:
    v2 = (void **)off_5F148;
  }
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 5u )
    sub_11008((__int64)v2[19], 0x1E7u, (__int64)&unk_4DBD8);
}
// 41194: variable 'v4' is possibly undefined
// 411D5: variable 'v6' is possibly undefined
// 41212: variable 'v8' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (00000000000412B4) ----------------------------------------------------
__int64 __fastcall sub_412B4(const void ***a1, __int64 a2, unsigned int a3, unsigned int a4, unsigned int *a5, _DWORD *a6)
{
  unsigned __int64 v7; // r14
  __int64 v10; // rsi
  void **v11; // rcx
  __int64 result; // rax
  __int64 v13; // rbp

  v7 = a3;
  v10 = a4;
  v11 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1EBu, (__int64)&unk_4DBD8);
    v11 = (void **)off_5F148;
  }
  if ( a1 )
  {
    sub_351D0(a2, v7, a1, 0x14u, a4, a5, a6);
    v13 = *a5;
    sub_3B864(*a1, a2, v7, *a5, a5, a6);
    if ( v13 + 8 <= v7 )
      *(_QWORD *)(v10 + a2) = v13;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x1EDu, (__int64)&unk_4DBD8);
    result = 0i64;
  }
  else
  {
    if ( v11 != &off_5F148 && (*((_BYTE *)v11 + 172) & 2) != 0 && *((_BYTE *)v11 + 169) >= 2u )
      sub_11008((__int64)v11[19], 0x1ECu, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000004142C) ----------------------------------------------------
__int64 __fastcall sub_4142C(__int64 **a1, __int64 a2, unsigned int a3)
{
  __int64 v5; // rbp
  void **v6; // rcx
  int v7; // eax
  unsigned int v8; // ebx
  _QWORD *v9; // rcx
  unsigned __int16 v10; // dx
  __int64 result; // rax

  v5 = a2 + a3;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1EEu, (__int64)&unk_4DBD8);
    v6 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    v7 = sub_40BA0(a1, *(_DWORD *)(v5 + 8), *(_DWORD *)(v5 + 12), *(_DWORD *)(v5 + 16));
    v8 = v7;
    if ( v7 )
    {
      v9 = off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        return v8;
      v10 = 496;
LABEL_12:
      sub_1102C(v9[19], v10, (__int64)&unk_4DBD8, v7);
      return v8;
    }
    v7 = sub_3BB90(*a1, a2, *(_DWORD *)v5);
    v8 = v7;
    if ( v7 )
    {
      v9 = off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        return v8;
      v10 = 497;
      goto LABEL_12;
    }
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x1F2u, (__int64)&unk_4DBD8);
    result = 0i64;
  }
  else
  {
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 2) != 0 && *((_BYTE *)v6 + 169) >= 2u )
      sub_11008((__int64)v6[19], 0x1EFu, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000415C0) ----------------------------------------------------
__int64 __fastcall sub_415C0(__int64 a1, int a2, _QWORD *a3)
{
  unsigned int v6; // edi
  const wchar_t *v7; // rax
  __int64 v8; // r10
  __int64 v9; // rax
  const char *v10; // r9
  _QWORD *v12; // [rsp+58h] [rbp+20h] BYREF

  v12 = 0i64;
  v6 = 5;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    v7 = sub_352B8(a2);
    sub_17860(*(_QWORD *)(v8 + 152), 0x1F3u, (__int64)&unk_4DBD8, v7);
  }
  sub_439A0(a1, (__int64)&v12);
  while ( !sub_43C74(v12) )
  {
    v9 = sub_43E74((__int64)v12);
    if ( *(_DWORD *)(v9 + 8) == a2 )
    {
      if ( a3 )
        *a3 = *(_QWORD *)v9;
      v6 = 0;
      break;
    }
    sub_43D50((__int64)v12);
  }
  sub_43B64((__int64 *)&v12);
  if ( v6 && a3 )
    *a3 = 0i64;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    v10 = "not found";
    if ( !v6 )
      v10 = "found";
    sub_13618(*((_QWORD *)off_5F148 + 19), 0x1F4u, (__int64)&unk_4DBD8, v10);
  }
  return v6;
}
// 41612: variable 'v8' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (00000000000416F0) ----------------------------------------------------
__int64 __fastcall sub_416F0(__int64 **a1)
{
  void **v2; // rcx
  __int64 result; // rax
  __int64 *v4; // rax
  int v5; // eax
  unsigned int v6; // ebx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1F5u, (__int64)&unk_4DBD8);
    v2 = (void **)off_5F148;
  }
  if ( a1 )
  {
    if ( *a1 )
    {
      if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 5u )
        sub_11008((__int64)v2[19], 0x1F7u, (__int64)&unk_4DBD8);
      sub_41AAC(a1);
    }
    v4 = (__int64 *)sub_26404(1, 8u, 0x63416547u);
    *a1 = v4;
    if ( v4 )
    {
      *v4 = 0i64;
      v5 = sub_398F8(*a1, 0);
      v6 = v5;
      if ( v5 )
      {
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
          sub_1102C(*((_QWORD *)off_5F148 + 19), 0x1F9u, (__int64)&unk_4DBD8, v5);
        result = v6;
      }
      else
      {
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
          sub_1102C(*((_QWORD *)off_5F148 + 19), 0x1FAu, (__int64)&unk_4DBD8, 0);
        result = 0i64;
      }
    }
    else
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x1F8u, (__int64)&unk_4DBD8);
      result = 3i64;
    }
  }
  else
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x1F6u, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000418BC) ----------------------------------------------------
__int64 __fastcall sub_418BC(__int64 **a1, __int64 *a2)
{
  void **v4; // rcx
  __int64 *v5; // rax
  __int64 result; // rax
  unsigned int v7; // edi

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1FBu, (__int64)&unk_4DBD8);
    v4 = (void **)off_5F148;
  }
  if ( a2 && a1 )
  {
    if ( *a1 )
    {
      if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 5u )
        sub_11008((__int64)v4[19], 0x1FDu, (__int64)&unk_4DBD8);
      sub_41AAC(a1);
    }
    v5 = (__int64 *)sub_26404(1, 8u, 0x63416547u);
    *a1 = v5;
    if ( v5 )
    {
      *v5 = 0i64;
      v7 = sub_3ACEC(*a1, *a2);
      if ( v7 )
      {
        sub_41AAC(a1);
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
          sub_1102C(*((_QWORD *)off_5F148 + 19), 0x1FFu, (__int64)&unk_4DBD8, v7);
        result = v7;
      }
      else
      {
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
          sub_1102C(*((_QWORD *)off_5F148 + 19), 0x200u, (__int64)&unk_4DBD8, 0);
        result = 0i64;
      }
    }
    else
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x1FEu, (__int64)&unk_4DBD8);
      result = 3i64;
    }
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x1FCu, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000041AAC) ----------------------------------------------------
__int64 __fastcall sub_41AAC(__int64 **a1)
{
  void **v2; // rcx
  int v3; // eax
  __int64 result; // rax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x201u, (__int64)&unk_4DBD8);
    v2 = (void **)off_5F148;
  }
  if ( a1 && *a1 )
  {
    v3 = sub_3B0E0(*a1);
    if ( v3 && off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x203u, (__int64)&unk_4DBD8, v3);
    sub_26488(*a1, 0x63416547u);
    *a1 = 0i64;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x204u, (__int64)&unk_4DBD8);
    result = 0i64;
  }
  else
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 2) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x202u, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000041BF0) ----------------------------------------------------
void __fastcall sub_41BF0(__int64 *a1)
{
  void **v2; // rcx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 4) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x205u, (__int64)&unk_4DBD8);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 4u )
    {
      sub_11008((__int64)v2[19], 0x206u, (__int64)&unk_4DBD8);
      v2 = (void **)off_5F148;
    }
  }
  if ( a1 )
  {
    sub_3B22C(*a1);
    goto LABEL_15;
  }
  if ( v2 == &off_5F148 )
    return;
  if ( (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 2u )
  {
    sub_11008((__int64)v2[19], 0x207u, (__int64)&unk_4DBD8);
LABEL_15:
    v2 = (void **)off_5F148;
  }
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 4) != 0 && *((_BYTE *)v2 + 169) >= 5u )
    sub_11008((__int64)v2[19], 0x208u, (__int64)&unk_4DBD8);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000041CFC) ----------------------------------------------------
__int64 __fastcall sub_41CFC(const void ***a1, __int64 a2, unsigned int a3, unsigned int a4, unsigned int *a5, _DWORD *a6)
{
  unsigned __int64 v7; // r14
  __int64 v10; // rsi
  void **v11; // rcx
  __int64 result; // rax
  __int64 v13; // rbp

  v7 = a3;
  v10 = a4;
  v11 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x20Cu, (__int64)&unk_4DBD8);
    v11 = (void **)off_5F148;
  }
  if ( a1 )
  {
    sub_351D0(a2, v7, a1, 8u, a4, a5, a6);
    v13 = *a5;
    sub_3B864(*a1, a2, v7, *a5, a5, a6);
    if ( v13 + 8 <= v7 )
      *(_QWORD *)(v10 + a2) = v13;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x20Eu, (__int64)&unk_4DBD8);
    result = 0i64;
  }
  else
  {
    if ( v11 != &off_5F148 && (*((_BYTE *)v11 + 172) & 2) != 0 && *((_BYTE *)v11 + 169) >= 2u )
      sub_11008((__int64)v11[19], 0x20Du, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000041E74) ----------------------------------------------------
__int64 __fastcall sub_41E74(__int64 **a1, __int64 a2, unsigned int a3)
{
  __int64 v5; // rbp
  void **v6; // rcx
  int v7; // eax
  unsigned int v8; // ebx
  _QWORD *v9; // rcx
  unsigned __int16 v10; // dx
  __int64 result; // rax

  v5 = a3;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x20Fu, (__int64)&unk_4DBD8);
    v6 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    v7 = sub_416F0(a1);
    v8 = v7;
    if ( v7 )
    {
      v9 = off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        return v8;
      v10 = 529;
LABEL_12:
      sub_1102C(v9[19], v10, (__int64)&unk_4DBD8, v7);
      return v8;
    }
    v7 = sub_3BB90(*a1, a2, *(_DWORD *)(v5 + a2));
    v8 = v7;
    if ( v7 )
    {
      v9 = off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 2) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        return v8;
      v10 = 530;
      goto LABEL_12;
    }
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x213u, (__int64)&unk_4DBD8);
    result = 0i64;
  }
  else
  {
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 2) != 0 && *((_BYTE *)v6 + 169) >= 2u )
      sub_11008((__int64)v6[19], 0x210u, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000041FFC) ----------------------------------------------------
__int64 __fastcall sub_41FFC(__int64 a1, _DWORD *a2)
{
  void **v4; // rcx
  __int64 result; // rax

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x214u, (__int64)&unk_4DBD8);
    v4 = (void **)off_5F148;
  }
  if ( a2 )
  {
    *a2 = *(_DWORD *)(*(_QWORD *)a1 + 4i64);
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x216u, (__int64)&unk_4DBD8, 0);
    result = 0i64;
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 2) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x215u, (__int64)&unk_4DBD8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000420EC) ----------------------------------------------------
__int64 __fastcall sub_420EC(__int64 a1, unsigned __int8 (__fastcall *a2)(_QWORD, __int64, __int64), __int64 a3, _BYTE *a4)
{
  unsigned int v4; // edi
  void **v9; // rcx
  __int64 v10; // rsi
  __int64 v12[5]; // [rsp+20h] [rbp-28h] BYREF
  _QWORD *v13; // [rsp+50h] [rbp+8h] BYREF

  v4 = 0;
  v13 = 0i64;
  v9 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 2) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x217u, (__int64)&unk_4DBD8);
    v9 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    if ( a4 )
      *a4 = 0;
    sub_439A0(*(_QWORD *)(a1 + 16), (__int64)&v13);
    while ( !sub_43C74(v13) )
    {
      v12[0] = 0i64;
      v10 = sub_43E74((__int64)v13);
      sub_43D50((__int64)v13);
      v4 = sub_3ED70(v10, 1066, v12);
      if ( v4 )
        break;
      if ( !a2(*(_QWORD *)(v12[0] + 4), v10, a3) )
      {
        if ( a4 )
          *a4 = 1;
        break;
      }
    }
    sub_43B64((__int64 *)&v13);
    v9 = (void **)off_5F148;
  }
  else
  {
    v4 = 4;
  }
  if ( v9 != &off_5F148 && (*((_BYTE *)v9 + 172) & 2) != 0 && *((_BYTE *)v9 + 169) >= 5u )
    sub_1102C((__int64)v9[19], 0x218u, (__int64)&unk_4DBD8, v4);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000042254) ----------------------------------------------------
__int64 sub_42254()
{
  unsigned int v0; // ebx
  char *v1; // r11
  void **v2; // rcx
  char *v3; // rax

  v0 = 0;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xAu, (__int64)&unk_4DBC8);
  v1 = sub_26670(1i64, 0x10u, 0x4E4C6547u);
  qword_62080 = v1;
  if ( v1 )
  {
    v3 = sub_26670(1i64, 0x10u, 0x494C6547u);
    qword_62088 = v3;
    if ( v3 )
    {
LABEL_21:
      v2 = (void **)off_5F148;
      goto LABEL_22;
    }
    v2 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0xCu, (__int64)&unk_4DBC8);
      v2 = (void **)off_5F148;
      v3 = (char *)qword_62088;
    }
    v1 = (char *)qword_62080;
  }
  else
  {
    v2 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0xBu, (__int64)&unk_4DBC8);
      v2 = (void **)off_5F148;
      v1 = (char *)qword_62080;
    }
    v3 = (char *)qword_62088;
  }
  v0 = 3;
  if ( v1 )
  {
    sub_26828(v1);
    qword_62080 = 0i64;
    v2 = (void **)off_5F148;
    v3 = (char *)qword_62088;
  }
  if ( v3 )
  {
    sub_26828(v3);
    qword_62088 = 0i64;
    goto LABEL_21;
  }
LABEL_22:
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 8) != 0 && *((_BYTE *)v2 + 169) >= 5u )
    sub_1102C((__int64)v2[19], 0xDu, (__int64)&unk_4DBC8, v0);
  return v0;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000042424) ----------------------------------------------------
void sub_42424()
{
  void **v0; // rcx

  v0 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xEu, (__int64)&unk_4DBC8);
    v0 = (void **)off_5F148;
  }
  if ( qword_62080 )
  {
    sub_26828(qword_62080);
    qword_62080 = 0i64;
    v0 = (void **)off_5F148;
  }
  if ( qword_62088 )
  {
    sub_26828(qword_62088);
    qword_62088 = 0i64;
    v0 = (void **)off_5F148;
  }
  if ( v0 != &off_5F148 && (*((_BYTE *)v0 + 172) & 8) != 0 && *((_BYTE *)v0 + 169) >= 5u )
    sub_11008((__int64)v0[19], 0xFu, (__int64)&unk_4DBC8);
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000042500) ----------------------------------------------------
__int64 __fastcall sub_42500(ULONG a1, __int64 *a2, int a3, void (__fastcall *a4)(__int64 *))
{
  void **v8; // rcx
  __int64 result; // rax
  _QWORD *v10; // rax
  _QWORD *v11; // rdi

  v8 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x10u, (__int64)&unk_4DBC8);
    v8 = (void **)off_5F148;
  }
  if ( a2 )
  {
    if ( *a2 )
    {
      if ( v8 != &off_5F148 && (*((_BYTE *)v8 + 172) & 8) != 0 && *((_BYTE *)v8 + 169) >= 5u )
        sub_11008((__int64)v8[19], 0x12u, (__int64)&unk_4DBC8);
      sub_42938(a2, a4);
    }
    v10 = sub_26404(1, 0x20u, a1);
    v11 = v10;
    *a2 = (__int64)v10;
    if ( v10 )
    {
      memset(v10, 0, 0x20ui64);
      v11[1] = 0i64;
      v11[2] = 0i64;
      *((_DWORD *)v11 + 6) = 0;
      *(_DWORD *)v11 = a3;
      *((_DWORD *)v11 + 7) = a1;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x14u, (__int64)&unk_4DBC8);
      result = 0i64;
    }
    else
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x13u, (__int64)&unk_4DBC8);
      result = 3i64;
    }
  }
  else
  {
    if ( v8 != &off_5F148 && (*((_BYTE *)v8 + 172) & 8) != 0 && *((_BYTE *)v8 + 169) >= 2u )
      sub_11008((__int64)v8[19], 0x11u, (__int64)&unk_4DBC8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000426B4) ----------------------------------------------------
__int64 __fastcall sub_426B4(__int64 *a1, __int64 a2, __int64 (__fastcall *a3)(__int64 *, _QWORD), void (__fastcall *a4)(__int64 *))
{
  void **v8; // rcx
  int v9; // eax
  unsigned int v10; // ebx
  void **v11; // rcx
  unsigned __int16 v12; // dx
  _QWORD *i; // rdi
  int v14; // eax
  __int64 result; // rax
  __int64 v16; // [rsp+58h] [rbp+10h] BYREF

  v16 = 0i64;
  v8 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_143EC(*((_QWORD *)off_5F148 + 19), 0x15u, (__int64)&unk_4DBC8, a2, a1, a3);
    v8 = (void **)off_5F148;
  }
  if ( a2 && a1 && a3 )
  {
    v9 = sub_42500(*(_DWORD *)(a2 + 28), a1, *(_DWORD *)a2, a4);
    v10 = v9;
    if ( v9 )
    {
      v11 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      {
        v12 = 23;
LABEL_13:
        sub_1102C((__int64)v11[19], v12, (__int64)&unk_4DBC8, v9);
LABEL_20:
        v11 = (void **)off_5F148;
      }
    }
    else
    {
      *(_DWORD *)*a1 = 0;
      for ( i = *(_QWORD **)(a2 + 8); ; i = (_QWORD *)i[1] )
      {
        if ( !i )
        {
          *(_DWORD *)*a1 = *(_DWORD *)a2;
          goto LABEL_20;
        }
        v16 = 0i64;
        v9 = a3(&v16, *i);
        v10 = v9;
        if ( v9 )
          break;
        v14 = sub_42D48((int *)*a1, v16, 0i64);
        v10 = v14;
        if ( v14 )
        {
          v11 = (void **)off_5F148;
          if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
          {
            sub_1102C(*((_QWORD *)off_5F148 + 19), 0x19u, (__int64)&unk_4DBC8, v14);
            v11 = (void **)off_5F148;
          }
          if ( a4 )
          {
            a4(&v16);
            goto LABEL_20;
          }
          goto LABEL_21;
        }
      }
      v11 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      {
        v12 = 24;
        goto LABEL_13;
      }
    }
LABEL_21:
    if ( v10 )
    {
      sub_42938(a1, a4);
      v11 = (void **)off_5F148;
    }
    if ( v11 != &off_5F148 && (*((_BYTE *)v11 + 172) & 8) != 0 && *((_BYTE *)v11 + 169) >= 5u )
      sub_1102C((__int64)v11[19], 0x1Au, (__int64)&unk_4DBC8, v10);
    result = v10;
  }
  else
  {
    if ( v8 != &off_5F148 && (*((_BYTE *)v8 + 172) & 8) != 0 && *((_BYTE *)v8 + 169) >= 2u )
      sub_11008((__int64)v8[19], 0x16u, (__int64)&unk_4DBC8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000042938) ----------------------------------------------------
__int64 __fastcall sub_42938(__int64 *a1, void (__fastcall *a2)(__int64 *))
{
  void **v4; // rcx
  unsigned int v5; // edi
  __int64 result; // rax

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1Bu, (__int64)&unk_4DBC8);
    v4 = (void **)off_5F148;
  }
  if ( a1 && *a1 )
  {
    v5 = sub_42A4C(*a1, a2);
    sub_26488((PVOID)*a1, *(_DWORD *)(*a1 + 28));
    *a1 = 0i64;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x1Du, (__int64)&unk_4DBC8);
    result = v5;
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 8) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x1Cu, (__int64)&unk_4DBC8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000042A4C) ----------------------------------------------------
__int64 __fastcall sub_42A4C(__int64 a1, void (__fastcall *a2)(__int64 *))
{
  void **v4; // rcx
  __int64 result; // rax
  __int64 *v6; // rdi
  __int64 v7; // [rsp+40h] [rbp+8h] BYREF

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1Eu, (__int64)&unk_4DBC8);
    v4 = (void **)off_5F148;
  }
  if ( a1 )
  {
    while ( *(_QWORD *)(a1 + 8) )
    {
      v6 = *(__int64 **)(a1 + 8);
      if ( a2 )
      {
        v7 = *v6;
        a2(&v7);
      }
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8i64);
      sub_269B0((__int64)qword_62080, (__int64)v6);
    }
    *(_QWORD *)(a1 + 8) = 0i64;
    *(_QWORD *)(a1 + 16) = 0i64;
    *(_DWORD *)(a1 + 24) = 0;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x20u, (__int64)&unk_4DBC8);
    result = 0i64;
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 8) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x1Fu, (__int64)&unk_4DBC8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000042B90) ----------------------------------------------------
__int64 __fastcall sub_42B90(_QWORD *a1, void (__fastcall *a2)(_QWORD))
{
  void **v4; // rcx
  __int64 result; // rax

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x21u, (__int64)&unk_4DBC8, a1, a2);
    v4 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 8) != 0 && *((_BYTE *)v4 + 169) >= 5u )
    {
      sub_1102C((__int64)v4[19], 0x23u, (__int64)&unk_4DBC8, *((_DWORD *)a1 + 6));
LABEL_19:
      v4 = (void **)off_5F148;
    }
    while ( 1 )
    {
      a1 = (_QWORD *)a1[1];
      if ( !a1 )
        break;
      if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 8) != 0 && *((_BYTE *)v4 + 169) >= 4u )
        sub_143A4((__int64)v4[19], 0x24u, (__int64)&unk_4DBC8, a1, *a1);
      a2(*a1);
      v4 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x25u, (__int64)&unk_4DBC8);
        goto LABEL_19;
      }
    }
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 8) != 0 && *((_BYTE *)v4 + 169) >= 5u )
      sub_11008((__int64)v4[19], 0x26u, (__int64)&unk_4DBC8);
    result = 0i64;
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 8) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_143A4((__int64)v4[19], 0x22u, (__int64)&unk_4DBC8, a1, a2);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000042D48) ----------------------------------------------------
__int64 __fastcall sub_42D48(int *a1, __int64 a2, __int64 (__fastcall *a3)(_QWORD, _QWORD))
{
  _QWORD *v6; // rsi
  void **v7; // rcx
  _QWORD *v9; // rax
  _QWORD *v10; // rdi
  int v11; // eax
  _QWORD *v12; // rbp
  int v13; // eax
  __int64 v14; // rax

  v6 = 0i64;
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_143EC(*((_QWORD *)off_5F148 + 19), 0x27u, (__int64)&unk_4DBC8, a1, a2, a3);
    v7 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    if ( (*a1 == 2 || *a1 == 3) && !a3 )
    {
      if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 172) & 8) != 0 && *((_BYTE *)v7 + 169) >= 2u )
        sub_11008((__int64)v7[19], 0x29u, (__int64)&unk_4DBC8);
      return 6i64;
    }
    v9 = sub_26948((__int64)qword_62080);
    v10 = v9;
    if ( !v9 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x2Au, (__int64)&unk_4DBC8);
      return 3i64;
    }
    v9[1] = 0i64;
    *v9 = a2;
    v11 = *a1;
    if ( *a1 )
    {
      if ( v11 == 1 )
        goto LABEL_33;
      if ( (unsigned int)(v11 - 2) > 1 )
        goto LABEL_33;
      v12 = (_QWORD *)*((_QWORD *)a1 + 1);
      if ( !v12 )
        goto LABEL_33;
      do
      {
        v13 = a3(*v10, *v12);
        if ( *a1 == 2 && v13 == 5 )
          break;
        if ( *a1 == 3 && v13 == 6 )
          break;
        v6 = v12;
        v12 = (_QWORD *)v12[1];
      }
      while ( v12 );
    }
    else
    {
      v6 = (_QWORD *)*((_QWORD *)a1 + 2);
    }
    if ( v6 )
    {
      if ( !v6[1] )
        *((_QWORD *)a1 + 2) = v10;
      v10[1] = v6[1];
      v6[1] = v10;
      goto LABEL_40;
    }
LABEL_33:
    v14 = *((_QWORD *)a1 + 1);
    if ( v14 )
      v10[1] = v14;
    else
      *((_QWORD *)a1 + 2) = v10;
    *((_QWORD *)a1 + 1) = v10;
LABEL_40:
    ++a1[6];
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x2Bu, (__int64)&unk_4DBC8, a1[6]);
    return 0i64;
  }
  if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 172) & 8) != 0 && *((_BYTE *)v7 + 169) >= 2u )
    sub_143A4((__int64)v7[19], 0x28u, (__int64)&unk_4DBC8, a1, a2);
  return 4i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000042F90) ----------------------------------------------------
__int64 __fastcall sub_42F90(int *a1, __int64 a2, __int64 (__fastcall *a3)(_QWORD, __int64), void (__fastcall *a4)(_QWORD *), char a5)
{
  char v9; // r15
  _QWORD *v10; // rbp
  void **v11; // rcx
  int v12; // esi
  _QWORD *v13; // rdi
  int v14; // eax
  __int64 result; // rax
  _QWORD *v16; // rax

  v9 = 1;
  v10 = 0i64;
  v11 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_12818(*((_QWORD *)off_5F148 + 19), 0x2Cu, (__int64)&unk_4DBC8, a1, a2, a3, a4);
    v11 = (void **)off_5F148;
  }
  if ( a1 && a2 && a3 )
  {
    v12 = *a1;
    if ( *a1 == 2 || v12 == 3 )
      v12 = a5 != 0 ? v12 : 0;
    v13 = (_QWORD *)*((_QWORD *)a1 + 1);
    if ( v13 )
    {
      while ( 1 )
      {
        if ( !v9 )
        {
LABEL_21:
          v11 = (void **)off_5F148;
          goto LABEL_22;
        }
        v14 = a3(*v13, a2);
        if ( v14 == 7 )
          break;
        if ( v12 == 2 )
        {
          if ( v14 == 6 )
            v9 = 0;
        }
        else if ( v12 == 3 && v14 == 5 )
        {
          v9 = 0;
        }
        v10 = v13;
        v13 = (_QWORD *)v13[1];
        if ( !v13 )
          goto LABEL_21;
      }
      if ( a4 )
        a4(v13);
      if ( *((_QWORD **)a1 + 2) == v13 )
        *((_QWORD *)a1 + 2) = v10;
      v16 = (_QWORD *)*((_QWORD *)a1 + 1);
      if ( v16 == v13 )
        *((_QWORD *)a1 + 1) = v16[1];
      if ( v10 )
        v10[1] = v13[1];
      sub_269B0((__int64)qword_62080, (__int64)v13);
      --a1[6];
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x2Eu, (__int64)&unk_4DBC8, a1[6]);
      result = 0i64;
    }
    else
    {
LABEL_22:
      if ( v11 != &off_5F148 && (*((_BYTE *)v11 + 172) & 8) != 0 && *((_BYTE *)v11 + 169) >= 5u )
        sub_1102C((__int64)v11[19], 0x2Fu, (__int64)&unk_4DBC8, a1[6]);
      result = 5i64;
    }
  }
  else
  {
    if ( v11 != &off_5F148 && (*((_BYTE *)v11 + 172) & 8) != 0 && *((_BYTE *)v11 + 169) >= 2u )
      sub_143EC((__int64)v11[19], 0x2Du, (__int64)&unk_4DBC8, a1, a2, a3);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000431EC) ----------------------------------------------------
__int64 __fastcall sub_431EC(int *a1, __int64 a2, _QWORD *a3, __int64 (__fastcall *a4)(_QWORD, __int64), char a5)
{
  unsigned int v9; // esi
  void **v10; // rcx
  int v11; // edi
  _QWORD *v12; // rbx
  int v13; // eax
  bool v14; // zf
  __int64 result; // rax

  v9 = 5;
  v10 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_12818(*((_QWORD *)off_5F148 + 19), 0x30u, (__int64)&unk_4DBC8, a1, a2, a3, a4);
    v10 = (void **)off_5F148;
  }
  if ( a1 && a2 && a4 )
  {
    if ( a3 )
    {
      *a3 = 0i64;
      v10 = (void **)off_5F148;
    }
    v11 = *a1;
    if ( *a1 == 2 || v11 == 3 )
      v11 = a5 != 0 ? v11 : 0;
    v12 = (_QWORD *)*((_QWORD *)a1 + 1);
    if ( v12 )
    {
      while ( 1 )
      {
        v13 = a4(*v12, a2);
        if ( v13 == 7 )
        {
          v10 = (void **)off_5F148;
          if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
          {
            sub_11008(*((_QWORD *)off_5F148 + 19), 0x32u, (__int64)&unk_4DBC8);
            v10 = (void **)off_5F148;
          }
          if ( a3 )
          {
            *a3 = *v12;
            v10 = (void **)off_5F148;
          }
          v9 = 0;
          goto LABEL_22;
        }
        if ( v11 == 2 )
          break;
        if ( v11 == 3 )
        {
          v14 = v13 == 5;
          goto LABEL_19;
        }
LABEL_20:
        v12 = (_QWORD *)v12[1];
        if ( !v12 )
        {
LABEL_21:
          v10 = (void **)off_5F148;
          goto LABEL_22;
        }
      }
      v14 = v13 == 6;
LABEL_19:
      if ( v14 )
        goto LABEL_21;
      goto LABEL_20;
    }
LABEL_22:
    if ( v10 != &off_5F148 && (*((_BYTE *)v10 + 172) & 8) != 0 && *((_BYTE *)v10 + 169) >= 5u )
      sub_1102C((__int64)v10[19], 0x33u, (__int64)&unk_4DBC8, v9);
    result = v9;
  }
  else
  {
    if ( v10 != &off_5F148 && (*((_BYTE *)v10 + 172) & 8) != 0 && *((_BYTE *)v10 + 169) >= 2u )
      sub_143EC((__int64)v10[19], 0x31u, (__int64)&unk_4DBC8, a1, a2, a4);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000433EC) ----------------------------------------------------
__int64 __fastcall sub_433EC(__int64 a1)
{
  void **v2; // rcx
  __int64 result; // rax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x34u, (__int64)&unk_4DBC8);
    v2 = (void **)off_5F148;
  }
  if ( a1 )
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 8) != 0 && *((_BYTE *)v2 + 169) >= 5u )
      sub_1102C((__int64)v2[19], 0x36u, (__int64)&unk_4DBC8, *(_DWORD *)(a1 + 24));
    result = *(unsigned int *)(a1 + 24);
  }
  else
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 8) != 0 && *((_BYTE *)v2 + 169) >= 3u )
      sub_11008((__int64)v2[19], 0x35u, (__int64)&unk_4DBC8);
    result = 0xFFFFFFFFi64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000434BC) ----------------------------------------------------
__int64 __fastcall sub_434BC(_QWORD *a1, __int64 a2, unsigned int a3, unsigned int a4, _DWORD *a5, void (__fastcall *a6)(_QWORD, __int64, _QWORD, _QWORD, _DWORD *, _DWORD *), _DWORD *a7)
{
  __int64 v7; // r14
  unsigned __int64 v8; // r15
  _QWORD *v11; // rsi
  void **v12; // rcx
  _QWORD *v13; // rbp
  _QWORD *v14; // rcx
  unsigned __int16 v15; // dx
  __int64 v17; // rax

  v7 = a4;
  v8 = a3;
  v11 = 0i64;
  v12 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x37u, (__int64)&unk_4DBC8);
    v12 = (void **)off_5F148;
  }
  if ( a1 && a6 )
  {
    sub_351D0(a2, v8, a1, 0x20u, v7, a5, a7);
    v13 = (_QWORD *)a1[1];
    if ( v13 )
    {
      if ( (unsigned __int64)(unsigned int)*a5 + 8 <= v8 )
        *(_QWORD *)(v7 + a2 + 8) = *(_QWORD *)a5;
      do
      {
        v17 = (unsigned int)*a5;
        if ( (unsigned int)v17 < (unsigned int)v8 )
          v11 = (_QWORD *)(a2 + v17);
        sub_351D0(a2, v8, v13, 0x10u, v17, a5, a7);
        if ( *a5 < (unsigned int)v8 && (unsigned __int64)(unsigned int)*a5 + 8 <= v8 )
          *v11 = *(_QWORD *)a5;
        a6(*v13, a2, (unsigned int)v8, (unsigned int)*a5, a5, a7);
        if ( *a5 < (unsigned int)v8 && (unsigned __int64)(unsigned int)*a5 + 8 <= v8 )
          v11[1] = *(_QWORD *)a5;
        v13 = (_QWORD *)v13[1];
      }
      while ( v13 );
      if ( v8 >= 8 )
        v11[1] = 0i64;
      v14 = off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 8) == 0 || *((_BYTE *)off_5F148 + 169) < 5u )
        return 0i64;
      v15 = 58;
    }
    else
    {
      v14 = off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 8) == 0 || *((_BYTE *)off_5F148 + 169) < 5u )
        return 0i64;
      v15 = 57;
    }
    sub_11008(v14[19], v15, (__int64)&unk_4DBC8);
    return 0i64;
  }
  if ( v12 != &off_5F148 && (*((_BYTE *)v12 + 172) & 8) != 0 && *((_BYTE *)v12 + 169) >= 2u )
    sub_12818((__int64)v12[19], 0x38u, (__int64)&unk_4DBC8, a1, a2, a5, a6);
  return 4i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000043718) ----------------------------------------------------
__int64 __fastcall sub_43718(__int64 *a1, __int64 a2, unsigned int a3, __int64 (__fastcall *a4)(__int64 *, __int64, _QWORD), void (__fastcall *a5)(__int64 *))
{
  unsigned int v5; // ebx
  _DWORD *v9; // rdi
  void **v10; // rcx
  unsigned int v11; // eax
  int v12; // esi
  __int64 v13; // rbp
  int v14; // eax
  unsigned __int16 v15; // dx
  __int64 v17; // [rsp+60h] [rbp+8h] BYREF

  v5 = 0;
  v9 = (_DWORD *)(a2 + a3);
  v10 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x3Bu, (__int64)&unk_4DBC8);
    v10 = (void **)off_5F148;
  }
  if ( !a1 || !a2 || !a4 )
  {
    if ( v10 != &off_5F148 && (*((_BYTE *)v10 + 172) & 8) != 0 && *((_BYTE *)v10 + 169) >= 2u )
    {
      sub_143EC((__int64)v10[19], 0x3Cu, (__int64)&unk_4DBC8, a1, a2, a4);
      v10 = (void **)off_5F148;
    }
    v5 = 4;
LABEL_32:
    if ( v5 )
    {
      if ( v10 != &off_5F148 && (*((_BYTE *)v10 + 172) & 8) != 0 && *((_BYTE *)v10 + 169) >= 5u )
        sub_1102C((__int64)v10[19], 0x40u, (__int64)&unk_4DBC8, v5);
      sub_42938(a1, a5);
      goto LABEL_38;
    }
    goto LABEL_39;
  }
  if ( *((_QWORD *)v9 + 1) )
  {
    v11 = v9[2];
    v12 = *v9;
    *v9 = 0;
    if ( !v11 )
    {
LABEL_17:
      *v9 = v12;
      goto LABEL_38;
    }
    while ( 1 )
    {
      v17 = 0i64;
      v13 = v11;
      v14 = a4(&v17, a2, *(unsigned int *)(v11 + a2));
      v5 = v14;
      if ( v14 )
        break;
      v14 = sub_42D48((int *)a1, v17, 0i64);
      v5 = v14;
      if ( v14 )
      {
        v10 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        {
          v15 = 63;
LABEL_26:
          sub_1102C((__int64)v10[19], v15, (__int64)&unk_4DBC8, v14);
          v10 = (void **)off_5F148;
          goto LABEL_32;
        }
        goto LABEL_32;
      }
      v11 = *(_DWORD *)(v13 + a2 + 8);
      if ( !v11 )
        goto LABEL_17;
    }
    v10 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 8) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
    {
      v15 = 62;
      goto LABEL_26;
    }
    goto LABEL_32;
  }
  if ( v10 == &off_5F148 )
    return v5;
  if ( (*((_BYTE *)v10 + 172) & 8) != 0 && *((_BYTE *)v10 + 169) >= 5u )
  {
    sub_11008((__int64)v10[19], 0x3Du, (__int64)&unk_4DBC8);
LABEL_38:
    v10 = (void **)off_5F148;
  }
LABEL_39:
  if ( v10 != &off_5F148 && (*((_BYTE *)v10 + 172) & 8) != 0 && *((_BYTE *)v10 + 169) >= 5u )
    sub_1102C((__int64)v10[19], 0x41u, (__int64)&unk_4DBC8, v5);
  return v5;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000439A0) ----------------------------------------------------
__int64 __fastcall sub_439A0(__int64 a1, __int64 a2)
{
  void **v4; // rcx
  __int64 v5; // rax
  _QWORD *v6; // rax
  __int64 result; // rax

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x10) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    if ( a2 )
      v5 = 0i64;
    else
      v5 = MEMORY[0];
    sub_143EC(*((_QWORD *)off_5F148 + 19), 0x42u, (__int64)&unk_4DBC8, a1, a2, v5);
    v4 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    if ( *(_QWORD *)(a1 + 8) )
    {
      v6 = sub_26948((__int64)qword_62088);
      *(_QWORD *)a2 = v6;
      if ( v6 )
      {
        *v6 = 0i64;
        v6[1] = 0i64;
        *(_QWORD *)(*(_QWORD *)a2 + 8i64) = a1;
        **(_QWORD **)a2 = *(_QWORD *)(a1 + 8);
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x10) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
          sub_11008(*((_QWORD *)off_5F148 + 19), 0x46u, (__int64)&unk_4DBC8);
        result = 0i64;
      }
      else
      {
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x10) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
          sub_11008(*((_QWORD *)off_5F148 + 19), 0x44u, (__int64)&unk_4DBC8);
        result = 3i64;
      }
    }
    else
    {
      if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 0x10) != 0 && *((_BYTE *)v4 + 169) >= 4u )
        sub_11008((__int64)v4[19], 0x45u, (__int64)&unk_4DBC8);
      result = 5i64;
    }
  }
  else
  {
    if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 0x10) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_143A4((__int64)v4[19], 0x43u, (__int64)&unk_4DBC8, a1, a2);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000043B64) ----------------------------------------------------
__int64 __fastcall sub_43B64(__int64 *a1)
{
  void **v2; // rcx
  __int64 v3; // rax
  __int64 result; // rax

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x10) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    if ( a1 )
      v3 = 0i64;
    else
      v3 = MEMORY[0];
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x47u, (__int64)&unk_4DBC8, a1, v3);
    v2 = (void **)off_5F148;
  }
  if ( a1 && *a1 )
  {
    sub_269B0((__int64)qword_62088, *a1);
    *a1 = 0i64;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x10) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x49u, (__int64)&unk_4DBC8);
    result = 0i64;
  }
  else
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 0x10) != 0 && *((_BYTE *)v2 + 169) >= 5u )
      sub_11008((__int64)v2[19], 0x48u, (__int64)&unk_4DBC8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000043C74) ----------------------------------------------------
bool __fastcall sub_43C74(_QWORD *a1)
{
  void **v2; // rcx
  bool result; // al

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x10) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x4Au, (__int64)&unk_4DBC8, a1);
    v2 = (void **)off_5F148;
  }
  if ( a1 )
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 0x10) != 0 && *((_BYTE *)v2 + 169) >= 5u )
      sub_11008((__int64)v2[19], 0x4Cu, (__int64)&unk_4DBC8);
    result = *a1 == 0i64;
  }
  else
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 0x10) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x4Bu, (__int64)&unk_4DBC8);
    result = 1;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000043D50) ----------------------------------------------------
__int64 __fastcall sub_43D50(__int64 a1)
{
  void **v2; // rcx
  __int64 result; // rax
  __int64 v4; // rcx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x10) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x4Du, (__int64)&unk_4DBC8);
    v2 = (void **)off_5F148;
  }
  if ( a1 )
  {
    v4 = *(_QWORD *)(*(_QWORD *)a1 + 8i64);
    *(_QWORD *)a1 = v4;
    if ( v4 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x10) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x50u, (__int64)&unk_4DBC8);
      result = 0i64;
    }
    else
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x10) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x4Fu, (__int64)&unk_4DBC8);
      result = 5i64;
    }
  }
  else
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 0x10) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x4Eu, (__int64)&unk_4DBC8);
    result = 4i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000043E74) ----------------------------------------------------
__int64 __fastcall sub_43E74(__int64 a1)
{
  void **v2; // rcx
  unsigned __int16 v3; // dx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x10) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x51u, (__int64)&unk_4DBC8);
    v2 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v2 == &off_5F148 || (*((_BYTE *)v2 + 172) & 0x10) == 0 || *((_BYTE *)v2 + 169) < 2u )
      return 0i64;
    v3 = 82;
LABEL_10:
    sub_11008((__int64)v2[19], v3, (__int64)&unk_4DBC8);
    return 0i64;
  }
  if ( !*(_QWORD *)a1 )
  {
    if ( v2 == &off_5F148 || (*((_BYTE *)v2 + 172) & 0x10) == 0 || *((_BYTE *)v2 + 169) < 2u )
      return 0i64;
    v3 = 83;
    goto LABEL_10;
  }
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 0x10) != 0 && *((_BYTE *)v2 + 169) >= 5u )
    sub_11008((__int64)v2[19], 0x54u, (__int64)&unk_4DBC8);
  return **(_QWORD **)a1;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000043F68) ----------------------------------------------------
__int64 sub_43F68(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, &unk_4DB40, a2, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000043FB8) ----------------------------------------------------
__int64 sub_43FB8(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+88h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, &unk_4DB40, 103i64, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000004401C) ----------------------------------------------------
__int64 __fastcall sub_4401C(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+88h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DB40, a2, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000044078) ----------------------------------------------------
__int64 __fastcall sub_44078(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+98h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DB40, 189i64, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000440E8) ----------------------------------------------------
__int64 sub_440E8(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_5F3B8(a1, 43i64, &unk_4DB40, 298i64, (__int64 *)va);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000044130) ----------------------------------------------------
__int64 __fastcall sub_44130(int a1, _QWORD *a2)
{
  void **v4; // rcx
  int v6; // ebx

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xAu, (__int64)&unk_4DB40);
    v4 = (void **)off_5F148;
  }
  if ( a2 )
  {
    if ( a1 )
    {
      v6 = a1 - 1;
      if ( !v6 )
      {
        if ( v4 != &off_5F148 )
        {
          if ( *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
          {
            sub_11008((__int64)v4[19], 0xDu, (__int64)&unk_4DB40);
            v4 = (void **)off_5F148;
          }
          if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 108) & 0x20) != 0 && *((_BYTE *)v4 + 105) >= 4u )
            sub_26384((__int64)v4[11], 0x1Au);
        }
        sub_27A44(a2);
        goto LABEL_32;
      }
      if ( v6 == 1 )
      {
        if ( v4 != &off_5F148 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
          sub_11008((__int64)v4[19], 0xEu, (__int64)&unk_4DB40);
        sub_27120((__int64)a2);
        goto LABEL_32;
      }
    }
    else
    {
      if ( v4 == &off_5F148 )
        return 0i64;
      if ( *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
      {
        sub_11008((__int64)v4[19], 0xCu, (__int64)&unk_4DB40);
LABEL_32:
        v4 = (void **)off_5F148;
        goto LABEL_33;
      }
    }
LABEL_33:
    if ( v4 != &off_5F148 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
      sub_11008((__int64)v4[19], 0xFu, (__int64)&unk_4DB40);
    return 0i64;
  }
  if ( v4 != &off_5F148 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 2u )
    sub_11008((__int64)v4[19], 0xBu, (__int64)&unk_4DB40);
  return 3i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000044314) ----------------------------------------------------
__int64 __fastcall sub_44314(int a1, __int64 a2)
{
  void **v4; // rcx
  int v6; // ebx
  unsigned __int16 v7; // dx

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x10u, (__int64)&unk_4DB40);
    v4 = (void **)off_5F148;
  }
  if ( a2 )
  {
    if ( a1 )
    {
      v6 = a1 - 1;
      if ( v6 )
      {
        if ( v6 != 1 )
          goto LABEL_27;
        if ( v4 != &off_5F148 )
        {
          if ( *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
          {
            v7 = 20;
LABEL_26:
            sub_11008((__int64)v4[19], v7, (__int64)&unk_4DB40);
            v4 = (void **)off_5F148;
            goto LABEL_27;
          }
          goto LABEL_27;
        }
      }
      else if ( v4 != &off_5F148 )
      {
        if ( *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
        {
          v7 = 19;
          goto LABEL_26;
        }
LABEL_27:
        if ( v4 != &off_5F148 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
          sub_11008((__int64)v4[19], 0x15u, (__int64)&unk_4DB40);
        return 0i64;
      }
    }
    else if ( v4 != &off_5F148 )
    {
      if ( *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
      {
        v7 = 18;
        goto LABEL_26;
      }
      goto LABEL_27;
    }
    return 0i64;
  }
  if ( v4 != &off_5F148 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 2u )
    sub_11008((__int64)v4[19], 0x11u, (__int64)&unk_4DB40);
  return 3i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000044474) ----------------------------------------------------
__int64 __fastcall sub_44474(int a1, struct _FAST_MUTEX *a2, KIRQL *a3)
{
  _QWORD *v3; // rcx
  unsigned __int16 v4; // dx
  int v6; // ecx

  if ( !a2 )
  {
    v3 = off_5F148;
    if ( off_5F148 == &off_5F148 || *((char *)off_5F148 + 172) >= 0 || *((_BYTE *)off_5F148 + 169) < 2u )
      return 3i64;
    v4 = 22;
LABEL_6:
    sub_11008(v3[19], v4, (__int64)&unk_4DB40);
    return 3i64;
  }
  if ( !a3 )
  {
    v3 = off_5F148;
    if ( off_5F148 == &off_5F148 || *((char *)off_5F148 + 172) >= 0 || *((_BYTE *)off_5F148 + 169) < 2u )
      return 3i64;
    v4 = 23;
    goto LABEL_6;
  }
  v6 = a1 - 1;
  if ( v6 )
  {
    if ( v6 == 1 )
      sub_27200(a2);
  }
  else
  {
    sub_26F00((PKSPIN_LOCK)a2, a3);
  }
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000044538) ----------------------------------------------------
__int64 __fastcall sub_44538(int a1, struct _FAST_MUTEX *a2, KIRQL a3)
{
  __int64 result; // rax
  int v4; // ecx

  if ( a2 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
        sub_272CC(a2);
    }
    else
    {
      sub_26F78((PKSPIN_LOCK)a2, a3);
    }
    result = 0i64;
  }
  else
  {
    if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x18u, (__int64)&unk_4DB40);
    result = 3i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000445CC) ----------------------------------------------------
__int64 __fastcall sub_445CC(__int64 a1, __int64 a2, char a3)
{
  void **v6; // rcx
  unsigned __int16 v7; // dx

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x19u, (__int64)&unk_4DB40);
    v6 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v6 == &off_5F148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 26;
LABEL_10:
    sub_11008((__int64)v6[19], v7, (__int64)&unk_4DB40);
    return 3i64;
  }
  if ( !a2 )
  {
    if ( v6 == &off_5F148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 27;
    goto LABEL_10;
  }
  *(_DWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 8) = a2;
  *(_QWORD *)a2 = a2;
  if ( a3 )
    sub_44130(*(_DWORD *)(a1 + 24), (_QWORD *)(a2 + 24));
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1Cu, (__int64)&unk_4DB40);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000446F8) ----------------------------------------------------
__int64 __fastcall sub_446F8(__int64 a1, __int64 a2, char a3)
{
  void **v6; // rcx
  unsigned __int16 v7; // dx

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x1Du, (__int64)&unk_4DB40);
    v6 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v6 == &off_5F148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 30;
LABEL_10:
    sub_11008((__int64)v6[19], v7, (__int64)&unk_4DB40);
    return 3i64;
  }
  if ( !a2 )
  {
    if ( v6 == &off_5F148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 31;
    goto LABEL_10;
  }
  if ( a3 )
  {
    sub_44314(*(_DWORD *)(a1 + 24), a2 + 24);
    v6 = (void **)off_5F148;
  }
  if ( v6 != &off_5F148 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_11008((__int64)v6[19], 0x20u, (__int64)&unk_4DB40);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000004481C) ----------------------------------------------------
_DWORD *__fastcall sub_4481C(unsigned __int8 a1, __int64 a2, __int64 a3, ULONG a4, __int64 a5, int a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, _DWORD *a11)
{
  void **v13; // rcx
  int v15; // ebx
  int v16; // eax
  int v17; // ebp
  _DWORD *v18; // rbx
  char *v19; // rax
  __int64 v20; // rdi
  void **v21; // rcx

  v13 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x21u, (__int64)&unk_4DB40);
    v13 = (void **)off_5F148;
  }
  *a11 = 0;
  if ( a1 > 0x1Eu )
  {
    if ( v13 != &off_5F148 && *((char *)v13 + 172) < 0 && *((_BYTE *)v13 + 169) >= 2u )
      sub_127D0((__int64)v13[19], 0x22u, (__int64)&unk_4DB40, a1);
LABEL_10:
    *a11 = 3;
    return 0i64;
  }
  v15 = 1 << a1;
  v16 = sub_47450(v15);
  v17 = v16;
  if ( !v16 )
  {
    if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x23u, (__int64)&unk_4DB40, v15);
    goto LABEL_10;
  }
  if ( a6 && a6 != 2 )
  {
    if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_127D0(*((_QWORD *)off_5F148 + 19), 0x24u, (__int64)&unk_4DB40, 1);
    goto LABEL_10;
  }
  v18 = sub_26404(2, 16 * (5 * v16 + 5), a4);
  if ( !v18 )
  {
    if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x25u, (__int64)&unk_4DB40);
LABEL_28:
    *a11 = 2;
    return 0i64;
  }
  v19 = sub_26670(1i64, 0x38u, a4);
  *((_QWORD *)v18 + 9) = v19;
  if ( !v19 )
  {
    if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x26u, (__int64)&unk_4DB40);
    sub_26488(v18, a4);
    goto LABEL_28;
  }
  *((_QWORD *)v18 + 2) = 0i64;
  *v18 = 0;
  v18[2] = 0;
  v20 = 0i64;
  v18[3] = a4;
  v18[1] = v17;
  for ( v18[6] = a6; (unsigned int)v20 < v18[1]; v20 = (unsigned int)(v20 + 1) )
    sub_445CC((__int64)v18, (__int64)&v18[20 * v20 + 20], 1);
  *((_QWORD *)v18 + 5) = 0i64;
  *((_QWORD *)v18 + 6) = 0i64;
  *((_QWORD *)v18 + 7) = a9;
  *((_QWORD *)v18 + 8) = a10;
  v21 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      sub_4401C(*((_QWORD *)off_5F148 + 19), 0x27u, (__int64)&unk_4DB40, v18[1]);
      v21 = (void **)off_5F148;
    }
    if ( v21 != &off_5F148 && *((char *)v21 + 172) < 0 && *((_BYTE *)v21 + 169) >= 5u )
      sub_11008((__int64)v21[19], 0x28u, (__int64)&unk_4DB40);
  }
  return v18;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000044B4C) ----------------------------------------------------
__int64 __fastcall sub_44B4C(ULONG_PTR BugCheckParameter2)
{
  void **v2; // rcx
  __int64 v4; // rsi
  _QWORD **v5; // r12
  int v6; // ecx
  struct _FAST_MUTEX *v7; // r14
  _QWORD *v8; // rbp
  ULONG_PTR v9; // r13
  void **v10; // rcx
  ULONG_PTR v11; // rbx
  int v12; // eax
  int i; // ebx
  __int64 j; // rbx
  void **v15; // rcx
  __int64 v16; // [rsp+20h] [rbp-98h]
  __int64 v17; // [rsp+30h] [rbp-88h] BYREF
  _BYTE v18[72]; // [rsp+38h] [rbp-80h] BYREF
  KIRQL v19; // [rsp+C0h] [rbp+8h] BYREF
  unsigned int v20; // [rsp+D0h] [rbp+18h] BYREF
  union _LARGE_INTEGER Interval; // [rsp+D8h] [rbp+20h] BYREF

  v20 = 0;
  v17 = 0i64;
  memset(v18, 0, sizeof(v18));
  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x80) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x36u, (__int64)&unk_4DB40);
    v2 = (void **)off_5F148;
  }
  if ( !BugCheckParameter2 )
  {
    if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 0x80) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x37u, (__int64)&unk_4DB40);
    return 3i64;
  }
  if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 0x80) != 0 && *((_BYTE *)v2 + 169) >= 4u )
    sub_4401C((__int64)v2[19], 0x38u, (__int64)&unk_4DB40, *(_DWORD *)(BugCheckParameter2 + 4));
  _InterlockedAdd((volatile signed __int32 *)(BugCheckParameter2 + 28), 1u);
  v4 = 0i64;
  if ( !*(_DWORD *)(BugCheckParameter2 + 4) )
    goto LABEL_38;
  v5 = (_QWORD **)(BugCheckParameter2 + 80);
  do
  {
    v6 = *(_DWORD *)(BugCheckParameter2 + 24);
    v7 = (struct _FAST_MUTEX *)(BugCheckParameter2 + 80 * v4 + 104);
    Interval.QuadPart = (LONGLONG)v7;
    sub_44474(v6, v7, &v19);
    v8 = *v5;
    v9 = BugCheckParameter2 + 80 * v4 + 80;
    if ( *v5 == (_QWORD *)v9 )
      goto LABEL_37;
    v10 = (void **)off_5F148;
    do
    {
      v11 = (ULONG_PTR)v8;
      v8 = (_QWORD *)*v8;
      if ( *(_BYTE *)(v11 + 44) )
      {
        if ( v10 != &off_5F148 && *((char *)v10 + 172) < 0 && *((_BYTE *)v10 + 169) >= 4u )
        {
          LODWORD(v16) = *(_DWORD *)(v11 + 40);
          sub_17814((__int64)v10[19], 0x39u, (__int64)&unk_4DB40, *(_QWORD *)(v11 + 16), v16);
LABEL_34:
          v10 = (void **)off_5F148;
          continue;
        }
      }
      else
      {
        if ( !sub_47118((_BYTE *)BugCheckParameter2, &v20) )
          v20 = sub_46E50(BugCheckParameter2, v11, 1);
        if ( *(_DWORD *)(v11 + 40) )
        {
          *(_BYTE *)(v11 + 44) = 1;
          goto LABEL_34;
        }
        v20 = sub_4553C(BugCheckParameter2, v4, (__int64 *)v11);
        if ( !v20 )
        {
          sub_45738(BugCheckParameter2, (__int64)&v17, v11);
          goto LABEL_34;
        }
        v10 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 3u )
        {
          sub_11008(*((_QWORD *)off_5F148 + 19), 0x3Au, (__int64)&unk_4DB40);
          goto LABEL_34;
        }
      }
    }
    while ( v8 != (_QWORD *)v9 );
    v7 = (struct _FAST_MUTEX *)Interval.QuadPart;
LABEL_37:
    sub_44538(*(_DWORD *)(BugCheckParameter2 + 24), v7, v19);
    v4 = (unsigned int)(v4 + 1);
    v5 += 10;
  }
  while ( (unsigned int)v4 < *(_DWORD *)(BugCheckParameter2 + 4) );
LABEL_38:
  sub_458B8(BugCheckParameter2, (__int64)&v17, 1);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x80) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x3Bu, (__int64)&unk_4DB40);
  v12 = sub_45B04(BugCheckParameter2, &v20);
  if ( v12 )
  {
    Interval.QuadPart = -5000000i64;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x80) != 0 && *((_BYTE *)off_5F148 + 169) >= 3u )
      sub_1102C(*((_QWORD *)off_5F148 + 19), 0x3Cu, (__int64)&unk_4DB40, v12);
    for ( i = 0; i < 10; ++i )
    {
      if ( !(unsigned int)sub_45B04(BugCheckParameter2, &v20) )
        break;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x80) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x3Du, (__int64)&unk_4DB40, i);
      KeDelayExecutionThread(0, 0, &Interval);
    }
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x80) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x3Eu, (__int64)&unk_4DB40);
  for ( j = 0i64; (unsigned int)j < *(_DWORD *)(BugCheckParameter2 + 4); j = (unsigned int)(j + 1) )
    sub_446F8(BugCheckParameter2, BugCheckParameter2 + 16 * (5 * j + 5), 1);
  sub_26828(*(PVOID *)(BugCheckParameter2 + 72));
  sub_26488((PVOID)BugCheckParameter2, *(_DWORD *)(BugCheckParameter2 + 12));
  v15 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 0x80) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x3Fu, (__int64)&unk_4DB40);
      v15 = (void **)off_5F148;
    }
    if ( v15 != &off_5F148 && (*((_BYTE *)v15 + 172) & 0x80) != 0 && *((_BYTE *)v15 + 169) >= 5u )
      sub_11008((__int64)v15[19], 0x40u, (__int64)&unk_4DB40);
  }
  return v20;
}
// 44CE6: variable 'v16' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (0000000000044FD8) ----------------------------------------------------
__int64 __fastcall sub_44FD8(ULONG_PTR BugCheckParameter2)
{
  unsigned int v1; // esi
  void **v3; // rcx
  __int64 result; // rax
  __int64 v5; // rbp
  _QWORD **v6; // r13
  int v7; // ecx
  struct _FAST_MUTEX *v8; // r15
  _QWORD *v9; // r12
  ULONG_PTR v10; // r14
  ULONG_PTR v11; // rbx
  void **v12; // rcx
  __int64 v13; // [rsp+20h] [rbp-98h]
  __int64 v14; // [rsp+30h] [rbp-88h] BYREF
  _BYTE v15[72]; // [rsp+38h] [rbp-80h] BYREF
  KIRQL v16; // [rsp+C0h] [rbp+8h] BYREF
  unsigned int v17; // [rsp+D0h] [rbp+18h] BYREF
  struct _FAST_MUTEX *v18; // [rsp+D8h] [rbp+20h]

  v1 = 0;
  v14 = 0i64;
  v17 = 0;
  memset(v15, 0, sizeof(v15));
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x80) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x4Bu, (__int64)&unk_4DB40);
    v3 = (void **)off_5F148;
  }
  if ( BugCheckParameter2 )
  {
    if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 172) & 0x80) != 0 && *((_BYTE *)v3 + 169) >= 4u )
      sub_4401C((__int64)v3[19], 0x4Du, (__int64)&unk_4DB40, *(_DWORD *)(BugCheckParameter2 + 4));
    v5 = 0i64;
    if ( *(_DWORD *)(BugCheckParameter2 + 4) )
    {
      v6 = (_QWORD **)(BugCheckParameter2 + 80);
      do
      {
        v7 = *(_DWORD *)(BugCheckParameter2 + 24);
        v8 = (struct _FAST_MUTEX *)(80 * v5 + BugCheckParameter2 + 104);
        v18 = v8;
        sub_44474(v7, v8, &v16);
        v9 = *v6;
        v10 = 80 * v5 + BugCheckParameter2 + 80;
        if ( *v6 != (_QWORD *)v10 )
        {
          do
          {
            v11 = (ULONG_PTR)v9;
            v9 = (_QWORD *)*v9;
            if ( *(_BYTE *)(v11 + 44) )
            {
              if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
              {
                LODWORD(v13) = *(_DWORD *)(v11 + 40);
                sub_17814(*((_QWORD *)off_5F148 + 19), 0x4Eu, (__int64)&unk_4DB40, *(_QWORD *)(v11 + 16), v13);
              }
            }
            else
            {
              if ( sub_47118((_BYTE *)BugCheckParameter2, &v17) )
              {
                v1 = v17;
              }
              else
              {
                v1 = sub_46E50(BugCheckParameter2, v11, 1);
                v17 = v1;
              }
              if ( *(_DWORD *)(v11 + 40) )
              {
                *(_BYTE *)(v11 + 44) = 1;
              }
              else
              {
                v1 = sub_4553C(BugCheckParameter2, v5, (__int64 *)v11);
                v17 = v1;
                if ( !v1 )
                  sub_45738(BugCheckParameter2, (__int64)&v14, v11);
              }
            }
          }
          while ( v9 != (_QWORD *)v10 );
          v8 = v18;
        }
        sub_44538(*(_DWORD *)(BugCheckParameter2 + 24), v8, v16);
        v5 = (unsigned int)(v5 + 1);
        v6 += 10;
      }
      while ( (unsigned int)v5 < *(_DWORD *)(BugCheckParameter2 + 4) );
    }
    sub_458B8(BugCheckParameter2, (__int64)&v14, 1);
    v12 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 )
    {
      if ( (*((_BYTE *)off_5F148 + 172) & 0x80) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x4Fu, (__int64)&unk_4DB40);
        v12 = (void **)off_5F148;
      }
      if ( v12 != &off_5F148 && (*((_BYTE *)v12 + 172) & 0x80) != 0 && *((_BYTE *)v12 + 169) >= 5u )
        sub_11008((__int64)v12[19], 0x50u, (__int64)&unk_4DB40);
    }
    result = v1;
  }
  else
  {
    if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 172) & 0x80) != 0 && *((_BYTE *)v3 + 169) >= 2u )
      sub_11008((__int64)v3[19], 0x4Cu, (__int64)&unk_4DB40);
    result = 3i64;
  }
  return result;
}
// 4516B: variable 'v13' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (00000000000452B8) ----------------------------------------------------
unsigned __int64 __fastcall sub_452B8(__int64 a1, unsigned __int64 a2, _DWORD *a3)
{
  void **v6; // rcx
  unsigned __int64 result; // rax

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x5Au, (__int64)&unk_4DB40);
    v6 = (void **)off_5F148;
  }
  *a3 = 0;
  if ( a1 )
  {
    if ( v6 != &off_5F148 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 5u )
      sub_11008((__int64)v6[19], 0x5Cu, (__int64)&unk_4DB40);
    result = a2 % *(unsigned int *)(a1 + 4);
  }
  else
  {
    if ( v6 != &off_5F148 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 2u )
      sub_11008((__int64)v6[19], 0x5Bu, (__int64)&unk_4DB40);
    *a3 = 3;
    result = 0xFFFFFFFFi64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000453B4) ----------------------------------------------------
_DWORD *__fastcall sub_453B4(__int64 a1, __int64 a2, _DWORD *a3)
{
  void **v6; // rcx
  unsigned __int16 v7; // dx
  _DWORD *v9; // rax
  _DWORD *v10; // rdi
  __int64 v11; // r11

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x5Du, (__int64)&unk_4DB40);
    v6 = (void **)off_5F148;
  }
  *a3 = 0;
  if ( !a1 )
  {
    if ( v6 == &off_5F148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_11;
    v7 = 94;
LABEL_10:
    sub_11008((__int64)v6[19], v7, (__int64)&unk_4DB40);
LABEL_11:
    *a3 = 3;
    return 0i64;
  }
  if ( !a2 )
  {
    if ( v6 == &off_5F148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_11;
    v7 = 95;
    goto LABEL_10;
  }
  v9 = sub_26948(*(_QWORD *)(a1 + 72));
  v10 = v9;
  if ( !v9 )
  {
    if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x60u, (__int64)&unk_4DB40);
    *a3 = 2;
    return 0i64;
  }
  memset(v9, 0, 0x38ui64);
  v11 = *(_QWORD *)(a1 + 16);
  *((_QWORD *)v10 + 4) = a2;
  *((_QWORD *)v10 + 3) = v11;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x61u, (__int64)&unk_4DB40);
  return v10;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000004553C) ----------------------------------------------------
__int64 __fastcall sub_4553C(__int64 a1, unsigned int a2, __int64 *a3)
{
  __int64 v4; // rsi
  void **v6; // rcx
  unsigned __int16 v7; // dx
  __int64 result; // rax
  _QWORD *v9; // rax
  __int64 v10; // rcx
  signed __int32 v11; // eax
  void **v12; // rcx
  __int64 v13; // [rsp+20h] [rbp-28h]
  unsigned int v14; // [rsp+50h] [rbp+8h] BYREF

  v14 = 0;
  v4 = a2;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x62u, (__int64)&unk_4DB40);
    v6 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v6 == &off_5F148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 99;
LABEL_10:
    sub_11008((__int64)v6[19], v7, (__int64)&unk_4DB40);
    return 3i64;
  }
  if ( !a3 )
  {
    if ( v6 == &off_5F148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 100;
    goto LABEL_10;
  }
  if ( v6 != &off_5F148 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_17814((__int64)v6[19], 0x65u, (__int64)&unk_4DB40, a3[2], *((_DWORD *)a3 + 10));
  if ( sub_47264((_BYTE *)a1, &v14) )
  {
    if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x66u, (__int64)&unk_4DB40);
    result = 12i64;
  }
  else
  {
    v9 = (_QWORD *)a3[1];
    v10 = *a3;
    *v9 = *a3;
    *(_QWORD *)(v10 + 8) = v9;
    --*(_DWORD *)(a1 + 80 * v4 + 96);
    v11 = _InterlockedDecrement((volatile signed __int32 *)(a1 + 8));
    v12 = (void **)off_5F148;
    if ( off_5F148 != &off_5F148 )
    {
      if ( *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
      {
        LODWORD(v13) = *(_DWORD *)(a1 + 80 * v4 + 96);
        sub_43FB8(*((_QWORD *)off_5F148 + 19), 103i64, (__int64)&unk_4DB40, a3[2], v13, v11);
        v12 = (void **)off_5F148;
      }
      if ( v12 != &off_5F148 && *((char *)v12 + 172) < 0 && *((_BYTE *)v12 + 169) >= 5u )
        sub_11008((__int64)v12[19], 0x68u, (__int64)&unk_4DB40);
    }
    result = v14;
  }
  return result;
}
// 456E1: variable 'v13' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (0000000000045738) ----------------------------------------------------
__int64 __fastcall sub_45738(__int64 a1, __int64 a2, __int64 a3)
{
  void **v6; // rcx
  __int64 *v7; // rax
  __int64 result; // rax
  int v9; // [rsp+20h] [rbp-18h]

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x69u, (__int64)&unk_4DB40);
    v6 = (void **)off_5F148;
  }
  if ( a1 && a2 && a3 )
  {
    if ( !*(_DWORD *)(a2 + 16) )
    {
      sub_445CC(a1, a2, 0);
      v6 = (void **)off_5F148;
    }
    if ( v6 != &off_5F148 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 5u )
    {
      v9 = *(_DWORD *)(a3 + 40);
      sub_17814((__int64)v6[19], 0x6Bu, (__int64)&unk_4DB40, *(_QWORD *)(a3 + 16), v9);
    }
    v7 = *(__int64 **)(a2 + 8);
    *(_QWORD *)a3 = a2;
    *(_QWORD *)(a3 + 8) = v7;
    *v7 = a3;
    ++*(_DWORD *)(a2 + 16);
    *(_QWORD *)(a2 + 8) = a3;
    if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x6Cu, (__int64)&unk_4DB40);
    result = 0i64;
  }
  else
  {
    if ( v6 != &off_5F148 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 2u )
      sub_143EC((__int64)v6[19], 0x6Au, (__int64)&unk_4DB40, a1, a2, a3);
    result = 3i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000458B8) ----------------------------------------------------
__int64 __fastcall sub_458B8(__int64 a1, __int64 a2, char a3)
{
  unsigned int v6; // edi
  void **v7; // rcx
  __int64 *v8; // r12
  __int64 *v9; // rsi
  __int64 *v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rcx
  void (__fastcall *v13)(__int64); // rax

  v6 = 0;
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x6Du, (__int64)&unk_4DB40);
    v7 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    if ( !*(_DWORD *)(a2 + 16) )
    {
      v6 = 4;
      goto LABEL_30;
    }
    v8 = *(__int64 **)a2;
    if ( *(_QWORD *)a2 == a2 )
    {
LABEL_30:
      sub_446F8(a1, a2, 0);
      if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x72u, (__int64)&unk_4DB40);
      return v6;
    }
    while ( 1 )
    {
      v9 = v8;
      v8 = (__int64 *)*v8;
      v10 = (__int64 *)v9[1];
      v11 = *v9;
      *v10 = *v9;
      *(_QWORD *)(v11 + 8) = v10;
      --*(_DWORD *)(a2 + 16);
      if ( !a3 )
        goto LABEL_24;
      v12 = v9[4];
      if ( v12 )
      {
        v13 = *(void (__fastcall **)(__int64))(a1 + 56);
        if ( v13 )
        {
          v13(v12);
LABEL_24:
          if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
            sub_17984(*((_QWORD *)off_5F148 + 19), 0x71u, (__int64)&unk_4DB40, v9[2]);
          sub_269B0(*(_QWORD *)(a1 + 72), (__int64)v9);
          goto LABEL_29;
        }
        if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
          sub_11008(*((_QWORD *)off_5F148 + 19), 0x70u, (__int64)&unk_4DB40);
        v6 = 5;
      }
      else
      {
        if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
          sub_11008(*((_QWORD *)off_5F148 + 19), 0x6Fu, (__int64)&unk_4DB40);
        v6 = 6;
      }
LABEL_29:
      if ( *(_QWORD *)a2 == a2 )
        goto LABEL_30;
    }
  }
  if ( v7 != &off_5F148 && *((char *)v7 + 172) < 0 && *((_BYTE *)v7 + 169) >= 2u )
    sub_143A4((__int64)v7[19], 0x6Eu, (__int64)&unk_4DB40, a1, a2);
  return 3i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000045B04) ----------------------------------------------------
__int64 __fastcall sub_45B04(__int64 a1, _DWORD *a2)
{
  void **v4; // rcx
  __int64 result; // rax
  unsigned __int32 v6; // ebx

  v4 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x73u, (__int64)&unk_4DB40);
    v4 = (void **)off_5F148;
  }
  *a2 = 0;
  if ( a1 )
  {
    v6 = _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 8), 0);
    if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x75u, (__int64)&unk_4DB40);
    result = v6;
  }
  else
  {
    if ( v4 != &off_5F148 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x74u, (__int64)&unk_4DB40);
    *a2 = 3;
    result = 0i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000045BFC) ----------------------------------------------------
__int64 __fastcall sub_45BFC(ULONG_PTR BugCheckParameter2, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  void **v7; // rcx
  unsigned __int16 v8; // dx
  __int64 result; // rax
  ULONG_PTR v10; // rax
  void **v11; // rcx
  unsigned int v12; // ebx
  __int64 v13; // [rsp+68h] [rbp+20h] BYREF

  HIDWORD(v13) = HIDWORD(a4);
  LODWORD(v13) = 0;
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x86u, (__int64)&unk_4DB40);
    v7 = (void **)off_5F148;
  }
  if ( !BugCheckParameter2 )
  {
    if ( v7 == &off_5F148 || *((char *)v7 + 172) >= 0 || *((_BYTE *)v7 + 169) < 2u )
      return 3i64;
    v8 = 135;
LABEL_10:
    sub_11008((__int64)v7[19], v8, (__int64)&unk_4DB40);
    return 3i64;
  }
  if ( !a3 )
  {
    if ( v7 == &off_5F148 || *((char *)v7 + 172) >= 0 || *((_BYTE *)v7 + 169) < 2u )
      return 3i64;
    v8 = 136;
    goto LABEL_10;
  }
  if ( _InterlockedCompareExchange((volatile signed __int32 *)(BugCheckParameter2 + 28), 0, 0) )
  {
    if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x89u, (__int64)&unk_4DB40);
    result = 9i64;
  }
  else
  {
    v10 = sub_4642C(BugCheckParameter2, a2, a3, 0i64, (__int64)&v13);
    if ( v10 )
    {
      if ( v10 == a3 )
      {
        v12 = v13;
        v11 = (void **)off_5F148;
      }
      else
      {
        v11 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        {
          sub_17984(*((_QWORD *)off_5F148 + 19), 0x8Bu, (__int64)&unk_4DB40, a2);
          v11 = (void **)off_5F148;
        }
        v12 = 7;
      }
      if ( v11 != &off_5F148 && *((char *)v11 + 172) < 0 && *((_BYTE *)v11 + 169) >= 5u )
        sub_11008((__int64)v11[19], 0x8Cu, (__int64)&unk_4DB40);
      result = v12;
    }
    else
    {
      if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x8Au, (__int64)&unk_4DB40, v13);
      result = (unsigned int)v13;
    }
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000045E1C) ----------------------------------------------------
__int64 __fastcall sub_45E1C(ULONG_PTR BugCheckParameter2, unsigned __int64 a2, __int64 a3, _DWORD *a4)
{
  __int64 v4; // rbp
  void **v8; // rcx
  __int64 v10; // r14
  struct _FAST_MUTEX *v11; // r13
  _QWORD *v12; // rax
  __int64 v13; // rsi
  int v14; // eax
  __int64 v15; // [rsp+20h] [rbp-78h] BYREF
  _BYTE v16[72]; // [rsp+28h] [rbp-70h] BYREF
  KIRQL v17; // [rsp+A0h] [rbp+8h] BYREF

  v4 = 0i64;
  v15 = 0i64;
  memset(v16, 0, sizeof(v16));
  v8 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x80) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x93u, (__int64)&unk_4DB40);
    v8 = (void **)off_5F148;
  }
  *a4 = 0;
  if ( !BugCheckParameter2 )
  {
    if ( v8 != &off_5F148 && (*((_BYTE *)v8 + 172) & 0x80) != 0 && *((_BYTE *)v8 + 169) >= 2u )
      sub_11008((__int64)v8[19], 0x94u, (__int64)&unk_4DB40);
    *a4 = 3;
    return 0i64;
  }
  if ( sub_47118((_BYTE *)BugCheckParameter2, a4) )
  {
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x80) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x95u, (__int64)&unk_4DB40);
    *a4 = 10;
    return 0i64;
  }
  v10 = (unsigned int)sub_452B8(BugCheckParameter2, a2, a4);
  v11 = (struct _FAST_MUTEX *)(BugCheckParameter2 + 80 * v10 + 104);
  sub_44474(*(_DWORD *)(BugCheckParameter2 + 24), v11, &v17);
  v12 = sub_4626C(BugCheckParameter2, v10, a2, a4);
  v13 = (__int64)v12;
  if ( v12 )
  {
    if ( *a4 == 8 )
    {
      sub_44538(*(_DWORD *)(BugCheckParameter2 + 24), v11, v17);
      if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 3u )
        sub_17984(*((_QWORD *)off_5F148 + 19), 0x96u, (__int64)&unk_4DB40, a2, v15);
      return 0i64;
    }
    sub_46E50(BugCheckParameter2, (ULONG_PTR)v12, 0);
    v4 = *(_QWORD *)(v13 + 32);
    if ( *(_DWORD *)(v13 + 40) )
    {
      *(_BYTE *)(v13 + 44) = 1;
    }
    else
    {
      v14 = sub_4553C(BugCheckParameter2, v10, (__int64 *)v13);
      *a4 = v14;
      if ( !v14 )
        sub_45738(BugCheckParameter2, (__int64)&v15, v13);
    }
  }
  sub_44538(*(_DWORD *)(BugCheckParameter2 + 24), v11, v17);
  sub_458B8(BugCheckParameter2, (__int64)&v15, 1);
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x97u, (__int64)&unk_4DB40);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000460A0) ----------------------------------------------------
__int64 __fastcall sub_460A0(__int64 a1, unsigned __int64 a2, __int64 a3, _DWORD *a4)
{
  __int64 v7; // rsi
  void **v8; // rcx
  __int64 v10; // rbx
  struct _FAST_MUTEX *v11; // r12
  _QWORD *v12; // rax
  __int64 v13; // [rsp+50h] [rbp+18h] BYREF

  v13 = a3;
  v7 = 0i64;
  v8 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xACu, (__int64)&unk_4DB40);
    v8 = (void **)off_5F148;
  }
  *a4 = 4;
  if ( !a1 )
  {
    if ( v8 != &off_5F148 && *((char *)v8 + 172) < 0 && *((_BYTE *)v8 + 169) >= 2u )
      sub_11008((__int64)v8[19], 0xADu, (__int64)&unk_4DB40);
    *a4 = 3;
    return 0i64;
  }
  v10 = (unsigned int)sub_452B8(a1, a2, a4);
  v11 = (struct _FAST_MUTEX *)(a1 + 80 * v10 + 104);
  sub_44474(*(_DWORD *)(a1 + 24), v11, (KIRQL *)&v13);
  v12 = sub_4626C(a1, v10, a2, a4);
  if ( v12 )
  {
    if ( *a4 == 8 )
    {
      sub_44538(*(_DWORD *)(a1 + 24), v11, v13);
      if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 3u )
        sub_17984(*((_QWORD *)off_5F148 + 19), 0xAEu, (__int64)&unk_4DB40, a2);
      return 0i64;
    }
    v7 = v12[4];
  }
  sub_44538(*(_DWORD *)(a1 + 24), v11, v13);
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xAFu, (__int64)&unk_4DB40);
  return v7;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000004626C) ----------------------------------------------------
_QWORD *__fastcall sub_4626C(__int64 a1, unsigned int a2, __int64 a3, _DWORD *a4)
{
  __int64 v6; // r12
  _QWORD *v8; // rsi
  void **v9; // rcx
  _QWORD *result; // rax
  _QWORD *v11; // rdx
  _QWORD *v12; // rbx

  v6 = a2;
  v8 = 0i64;
  v9 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xB0u, (__int64)&unk_4DB40);
    v9 = (void **)off_5F148;
  }
  *a4 = 4;
  if ( a1 )
  {
    v11 = (_QWORD *)(a1 + 16 * (5 * v6 + 5));
    if ( (_QWORD *)*v11 != v11 )
    {
      v12 = (_QWORD *)*v11;
      while ( v12 != v11 )
      {
        v8 = v12;
        if ( v12[2] == a3 )
        {
          if ( v9 != &off_5F148 && *((char *)v9 + 172) < 0 && *((_BYTE *)v9 + 169) >= 4u )
          {
            sub_28CB4((__int64)v9[19], 0xB2u, (__int64)&unk_4DB40, v6);
            v9 = (void **)off_5F148;
          }
          if ( *((_BYTE *)v12 + 44) )
          {
            if ( v9 != &off_5F148 && *((char *)v9 + 172) < 0 && *((_BYTE *)v9 + 169) >= 4u )
            {
              sub_17984((__int64)v9[19], 0xB3u, (__int64)&unk_4DB40, v12[2]);
              v9 = (void **)off_5F148;
            }
            *a4 = 8;
          }
          else
          {
            *a4 = 0;
          }
          break;
        }
        v12 = (_QWORD *)*v12;
        v8 = 0i64;
      }
    }
    if ( v9 != &off_5F148 && *((char *)v9 + 172) < 0 && *((_BYTE *)v9 + 169) >= 5u )
      sub_11008((__int64)v9[19], 0xB4u, (__int64)&unk_4DB40);
    result = v8;
  }
  else
  {
    if ( v9 != &off_5F148 && *((char *)v9 + 172) < 0 && *((_BYTE *)v9 + 169) >= 2u )
      sub_11008((__int64)v9[19], 0xB1u, (__int64)&unk_4DB40);
    *a4 = 3;
    result = 0i64;
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000004642C) ----------------------------------------------------
ULONG_PTR __fastcall sub_4642C(ULONG_PTR BugCheckParameter2, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  ULONG_PTR v5; // rdi
  __int64 v8; // r15
  void **v10; // rcx
  _DWORD *v11; // r12
  int v13; // ebx
  ULONG_PTR *v14; // rax
  ULONG_PTR *v15; // rbp
  ULONG_PTR *v16; // rax
  ULONG_PTR v17; // rcx
  ULONG_PTR **v18; // rax
  ULONG_PTR v19; // [rsp+20h] [rbp-48h]
  int v20; // [rsp+70h] [rbp+8h] BYREF

  v5 = 0i64;
  v20 = 0;
  LODWORD(v8) = 0;
  v10 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xB5u, (__int64)&unk_4DB40);
    v10 = (void **)off_5F148;
  }
  v11 = (_DWORD *)a5;
  if ( !a5 )
  {
    if ( v10 != &off_5F148 && *((char *)v10 + 172) < 0 && *((_BYTE *)v10 + 169) >= 2u )
      sub_11008((__int64)v10[19], 0xB6u, (__int64)&unk_4DB40);
    return 0i64;
  }
  if ( !BugCheckParameter2 )
  {
    if ( v10 != &off_5F148 && *((char *)v10 + 172) < 0 && *((_BYTE *)v10 + 169) >= 2u )
      sub_11008((__int64)v10[19], 0xB7u, (__int64)&unk_4DB40);
    *v11 = 3;
    return 0i64;
  }
  if ( a3 )
  {
    if ( _InterlockedCompareExchange((volatile signed __int32 *)(BugCheckParameter2 + 28), 0, 0) )
    {
      if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0xB9u, (__int64)&unk_4DB40);
      *v11 = 9;
      return 0i64;
    }
    v8 = (unsigned int)sub_452B8(BugCheckParameter2, a2, &v20);
    sub_44474(
      *(_DWORD *)(BugCheckParameter2 + 24),
      (struct _FAST_MUTEX *)(BugCheckParameter2 + 80 * v8 + 104),
      (KIRQL *)&a5);
    if ( sub_46FCC((_BYTE *)BugCheckParameter2, &v20)
      || (v14 = sub_4626C(BugCheckParameter2, v8, a2, &v20), (v15 = v14) == 0i64) )
    {
      v16 = (ULONG_PTR *)sub_453B4(BugCheckParameter2, a3, &v20);
      v15 = v16;
      if ( !v16 )
      {
        v13 = 2;
        if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
          sub_11008(*((_QWORD *)off_5F148 + 19), 0xBCu, (__int64)&unk_4DB40);
        goto LABEL_53;
      }
      v16[2] = a2;
      if ( !sub_47118((_BYTE *)BugCheckParameter2, &v20) )
        sub_46D0C(BugCheckParameter2, (ULONG_PTR)v15, 1);
      v17 = BugCheckParameter2 + 80 * v8 + 80;
      v18 = *(ULONG_PTR ***)(BugCheckParameter2 + 80 * v8 + 88);
      *v15 = v17;
      v15[1] = (ULONG_PTR)v18;
      *v18 = v15;
      *(_QWORD *)(v17 + 8) = v15;
      ++*(_DWORD *)(BugCheckParameter2 + 80 * v8 + 96);
      _InterlockedIncrement((volatile signed __int32 *)(BugCheckParameter2 + 8));
      if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
      {
        v19 = v15[2];
        sub_44078(*((_QWORD *)off_5F148 + 19), 189i64, (__int64)&unk_4DB40, v8);
      }
      v13 = v20;
    }
    else
    {
      sub_47F64(BugCheckParameter2, (ULONG_PTR)v14);
      v13 = v20;
      if ( v20 == 8 )
      {
        if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 3u )
          sub_17984(*((_QWORD *)off_5F148 + 19), 0xBAu, (__int64)&unk_4DB40, a2);
        goto LABEL_53;
      }
      if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
      {
        v19 = v15[2];
        sub_28CB4(*((_QWORD *)off_5F148 + 19), 0xBBu, (__int64)&unk_4DB40, v8);
      }
    }
    v5 = v15[4];
  }
  else
  {
    if ( v10 != &off_5F148 && *((char *)v10 + 172) < 0 && *((_BYTE *)v10 + 169) >= 2u )
      sub_11008((__int64)v10[19], 0xB8u, (__int64)&unk_4DB40);
    v13 = 3;
  }
LABEL_53:
  sub_44538(
    *(_DWORD *)(BugCheckParameter2 + 24),
    (struct _FAST_MUTEX *)(BugCheckParameter2 + 80i64 * (unsigned int)v8 + 104),
    a5);
  *v11 = v13;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    LODWORD(v19) = v13;
    sub_17814(*((_QWORD *)off_5F148 + 19), 0xBEu, (__int64)&unk_4DB40, v5, v19);
  }
  return v5;
}
// 4685F: variable 'v19' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000004688C) ----------------------------------------------------
__int64 __fastcall sub_4688C(ULONG_PTR BugCheckParameter2, ULONG_PTR *a2, _DWORD *a3)
{
  __int64 v6; // rdi
  void **v7; // rcx
  unsigned __int16 v8; // dx
  unsigned int v10; // ebp
  _QWORD **v11; // r13
  _QWORD *v12; // r11
  ULONG_PTR v13; // rbx
  KIRQL v14; // [rsp+50h] [rbp+8h] BYREF

  v6 = 0i64;
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xBFu, (__int64)&unk_4DB40);
    v7 = (void **)off_5F148;
  }
  *a3 = 0;
  if ( !BugCheckParameter2 )
  {
    if ( v7 == &off_5F148 || *((char *)v7 + 172) >= 0 || *((_BYTE *)v7 + 169) < 2u )
      goto LABEL_11;
    v8 = 192;
LABEL_10:
    sub_11008((__int64)v7[19], v8, (__int64)&unk_4DB40);
LABEL_11:
    *a3 = 3;
    return 0i64;
  }
  if ( !a2 )
  {
    if ( v7 == &off_5F148 || *((char *)v7 + 172) >= 0 || *((_BYTE *)v7 + 169) < 2u )
      goto LABEL_11;
    v8 = 193;
    goto LABEL_10;
  }
  *a2 = 0i64;
  v10 = 0;
  if ( *(_DWORD *)(BugCheckParameter2 + 4) )
  {
    v11 = (_QWORD **)(BugCheckParameter2 + 80);
LABEL_19:
    sub_44474(
      *(_DWORD *)(BugCheckParameter2 + 24),
      (struct _FAST_MUTEX *)(BugCheckParameter2 + 80i64 * v10 + 104),
      &v14);
    v12 = *v11;
    do
    {
      if ( v12 == (_QWORD *)(BugCheckParameter2 + 80i64 * v10 + 80) )
      {
        sub_44538(
          *(_DWORD *)(BugCheckParameter2 + 24),
          (struct _FAST_MUTEX *)(BugCheckParameter2 + 80i64 * v10++ + 104),
          v14);
        v11 += 10;
        if ( v10 >= *(_DWORD *)(BugCheckParameter2 + 4) )
          goto LABEL_25;
        goto LABEL_19;
      }
      v13 = (ULONG_PTR)v12;
      v12 = (_QWORD *)*v12;
    }
    while ( *(_BYTE *)(v13 + 44) );
    *a2 = v13;
    sub_46D0C(BugCheckParameter2, v13, 1);
    v6 = *(_QWORD *)(v13 + 32);
    sub_44538(*(_DWORD *)(BugCheckParameter2 + 24), (struct _FAST_MUTEX *)(BugCheckParameter2 + 80i64 * v10 + 104), v14);
LABEL_25:
    v7 = (void **)off_5F148;
  }
  if ( v7 != &off_5F148 && *((char *)v7 + 172) < 0 && *((_BYTE *)v7 + 169) >= 5u )
    sub_11008((__int64)v7[19], 0xC2u, (__int64)&unk_4DB40);
  return v6;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000046A58) ----------------------------------------------------
__int64 __fastcall sub_46A58(ULONG_PTR BugCheckParameter2, ULONG_PTR *a2, __int64 a3, _DWORD *a4)
{
  ULONG_PTR v4; // r14
  __int64 v5; // rdi
  void **v8; // rcx
  unsigned __int16 v9; // dx
  __int64 v11; // r12
  ULONG_PTR v12; // rsi
  struct _FAST_MUTEX *v13; // r15
  _QWORD *v14; // r13
  int v15; // eax
  int v16; // eax
  ULONG_PTR v17; // rbp
  ULONG_PTR v18; // r14
  __int64 v19; // [rsp+20h] [rbp-88h] BYREF
  char Dst[72]; // [rsp+28h] [rbp-80h] BYREF
  KIRQL v21; // [rsp+B0h] [rbp+8h] BYREF
  ULONG_PTR *v22; // [rsp+B8h] [rbp+10h]

  v22 = a2;
  v4 = *a2;
  v5 = 0i64;
  v19 = 0i64;
  memset(Dst, 0, sizeof(Dst));
  v8 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xC3u, (__int64)&unk_4DB40);
    v8 = (void **)off_5F148;
  }
  *a4 = 0;
  if ( !BugCheckParameter2 )
  {
    if ( v8 == &off_5F148 || *((char *)v8 + 172) >= 0 || *((_BYTE *)v8 + 169) < 2u )
      goto LABEL_11;
    v9 = 196;
LABEL_10:
    sub_11008((__int64)v8[19], v9, (__int64)&unk_4DB40);
LABEL_11:
    *a4 = 3;
    return 0i64;
  }
  if ( !v4 )
  {
    if ( v8 == &off_5F148 || *((char *)v8 + 172) >= 0 || *((_BYTE *)v8 + 169) < 2u )
      goto LABEL_11;
    v9 = 197;
    goto LABEL_10;
  }
  LODWORD(v11) = sub_452B8(BugCheckParameter2, *(_QWORD *)(v4 + 16), a4);
  v12 = BugCheckParameter2 + 16 * (5i64 * (unsigned int)v11 + 5);
  v13 = (struct _FAST_MUTEX *)(v12 + 24);
  sub_44474(*(_DWORD *)(BugCheckParameter2 + 24), (struct _FAST_MUTEX *)(v12 + 24), &v21);
  v14 = *(_QWORD **)v4;
  v15 = sub_46E50(BugCheckParameter2, v4, 1);
  *a4 = v15;
  if ( !v15 && !*(_DWORD *)(v4 + 40) )
  {
    v16 = sub_4553C(BugCheckParameter2, v11, (__int64 *)v4);
    *a4 = v16;
    if ( !v16 )
      sub_45738(BugCheckParameter2, (__int64)&v19, v4);
  }
  if ( v14 != (_QWORD *)v12 )
    goto LABEL_24;
  sub_44538(*(_DWORD *)(BugCheckParameter2 + 24), (struct _FAST_MUTEX *)(v12 + 24), v21);
  v11 = (unsigned int)(v11 + 1);
  if ( (unsigned int)v11 < *(_DWORD *)(BugCheckParameter2 + 4) )
  {
    v12 = BugCheckParameter2 + 16 * (5 * v11 + 5);
    v13 = (struct _FAST_MUTEX *)(v12 + 24);
    sub_44474(*(_DWORD *)(BugCheckParameter2 + 24), (struct _FAST_MUTEX *)(v12 + 24), &v21);
    v14 = *(_QWORD **)v12;
LABEL_24:
    v17 = BugCheckParameter2 + 16 * (5i64 * (int)v11 + 5);
    do
    {
      while ( v14 == (_QWORD *)v12 )
      {
        sub_44538(*(_DWORD *)(BugCheckParameter2 + 24), v13, v21);
        LODWORD(v11) = v11 + 1;
        v17 += 80i64;
        if ( (unsigned int)v11 >= *(_DWORD *)(BugCheckParameter2 + 4) )
          goto LABEL_30;
        v13 = (struct _FAST_MUTEX *)(v17 + 24);
        v12 = v17;
        sub_44474(*(_DWORD *)(BugCheckParameter2 + 24), (struct _FAST_MUTEX *)(v17 + 24), &v21);
        v14 = *(_QWORD **)v17;
      }
      v18 = (ULONG_PTR)v14;
      v14 = (_QWORD *)*v14;
    }
    while ( *(_BYTE *)(v18 + 44) );
    *v22 = v18;
    sub_46D0C(BugCheckParameter2, v18, 1);
    v5 = *(_QWORD *)(v18 + 32);
    sub_44538(*(_DWORD *)(BugCheckParameter2 + 24), (struct _FAST_MUTEX *)(v12 + 24), v21);
  }
LABEL_30:
  sub_458B8(BugCheckParameter2, (__int64)&v19, 0);
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xC6u, (__int64)&unk_4DB40);
  return v5;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000046D0C) ----------------------------------------------------
__int64 __fastcall sub_46D0C(ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter1, char a3)
{
  void **v6; // rcx
  unsigned __int16 v7; // dx

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xD6u, (__int64)&unk_4DB40);
    v6 = (void **)off_5F148;
  }
  if ( !BugCheckParameter2 )
  {
    if ( v6 == &off_5F148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 215;
LABEL_10:
    sub_11008((__int64)v6[19], v7, (__int64)&unk_4DB40);
    return 3i64;
  }
  if ( !BugCheckParameter1 )
  {
    if ( v6 == &off_5F148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 216;
    goto LABEL_10;
  }
  if ( !a3 )
  {
    sub_47F64(BugCheckParameter2, BugCheckParameter1);
    v6 = (void **)off_5F148;
  }
  if ( !*(_BYTE *)(BugCheckParameter1 + 45) )
  {
    ++*(_DWORD *)(BugCheckParameter1 + 40);
    v6 = (void **)off_5F148;
  }
  if ( v6 != &off_5F148 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_28CB4((__int64)v6[19], 0xD9u, (__int64)&unk_4DB40, *(_DWORD *)(BugCheckParameter1 + 40));
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000046E50) ----------------------------------------------------
__int64 __fastcall sub_46E50(ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter1, char a3)
{
  void **v6; // rcx
  unsigned __int16 v7; // dx
  int v9; // eax
  __int64 v10; // rax
  int v11; // [rsp+40h] [rbp+8h] BYREF

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_17984(*((_QWORD *)off_5F148 + 19), 0xDAu, (__int64)&unk_4DB40, *(_QWORD *)(BugCheckParameter1 + 16));
    v6 = (void **)off_5F148;
  }
  if ( !BugCheckParameter2 )
  {
    if ( v6 == &off_5F148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 219;
LABEL_10:
    sub_11008((__int64)v6[19], v7, (__int64)&unk_4DB40);
    return 3i64;
  }
  if ( !BugCheckParameter1 )
  {
    if ( v6 == &off_5F148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 220;
    goto LABEL_10;
  }
  if ( !a3 )
    sub_47F64(BugCheckParameter2, BugCheckParameter1);
  v9 = *(_DWORD *)(BugCheckParameter1 + 40);
  if ( v9 )
    *(_DWORD *)(BugCheckParameter1 + 40) = v9 - 1;
  v11 = 0;
  if ( sub_47264((_BYTE *)BugCheckParameter2, &v11)
    && !*(_DWORD *)(BugCheckParameter1 + 40)
    && !*(_BYTE *)(BugCheckParameter1 + 45) )
  {
    v10 = MEMORY[0xFFFFF78000000014];
    *(_BYTE *)(BugCheckParameter1 + 45) = 1;
    *(_QWORD *)(BugCheckParameter1 + 48) = v10;
    ++*(_QWORD *)(BugCheckParameter2 + 32);
  }
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_28CB4(*((_QWORD *)off_5F148 + 19), 0xDDu, (__int64)&unk_4DB40, *(_DWORD *)(BugCheckParameter1 + 40));
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000046FCC) ----------------------------------------------------
char __fastcall sub_46FCC(_BYTE *a1, _DWORD *a2)
{
  char v4; // bl
  void **v5; // rcx
  unsigned __int16 v7; // dx

  v4 = 0;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xDEu, (__int64)&unk_4DB40);
    v5 = (void **)off_5F148;
  }
  *a2 = 0;
  if ( a1 )
  {
    if ( (*a1 & 1) != 0 )
    {
      v4 = 1;
      if ( v5 != &off_5F148 )
      {
        if ( *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 4u )
        {
          v7 = 224;
LABEL_20:
          sub_11008((__int64)v5[19], v7, (__int64)&unk_4DB40);
          v5 = (void **)off_5F148;
          goto LABEL_21;
        }
        goto LABEL_21;
      }
    }
    else if ( v5 != &off_5F148 )
    {
      if ( *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 4u )
      {
        v7 = 225;
        goto LABEL_20;
      }
LABEL_21:
      if ( v5 != &off_5F148 && *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 5u )
        sub_11008((__int64)v5[19], 0xE2u, (__int64)&unk_4DB40);
      return v4;
    }
    return v4;
  }
  if ( v5 != &off_5F148 && *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 2u )
    sub_11008((__int64)v5[19], 0xDFu, (__int64)&unk_4DB40);
  *a2 = 3;
  return 0;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000047118) ----------------------------------------------------
char __fastcall sub_47118(_BYTE *a1, _DWORD *a2)
{
  char v4; // bl
  void **v5; // rcx
  unsigned __int16 v7; // dx

  v4 = 0;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xE3u, (__int64)&unk_4DB40);
    v5 = (void **)off_5F148;
  }
  *a2 = 0;
  if ( a1 )
  {
    if ( (*a1 & 2) != 0 )
    {
      v4 = 1;
      if ( v5 != &off_5F148 )
      {
        if ( *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 4u )
        {
          v7 = 229;
LABEL_20:
          sub_11008((__int64)v5[19], v7, (__int64)&unk_4DB40);
          v5 = (void **)off_5F148;
          goto LABEL_21;
        }
        goto LABEL_21;
      }
    }
    else if ( v5 != &off_5F148 )
    {
      if ( *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 4u )
      {
        v7 = 230;
        goto LABEL_20;
      }
LABEL_21:
      if ( v5 != &off_5F148 && *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 5u )
        sub_11008((__int64)v5[19], 0xE7u, (__int64)&unk_4DB40);
      return v4;
    }
    return v4;
  }
  if ( v5 != &off_5F148 && *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 2u )
    sub_11008((__int64)v5[19], 0xE4u, (__int64)&unk_4DB40);
  *a2 = 3;
  return 0;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000047264) ----------------------------------------------------
char __fastcall sub_47264(_BYTE *a1, _DWORD *a2)
{
  char v4; // bl
  void **v5; // rcx
  unsigned __int16 v7; // dx

  v4 = 0;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xE8u, (__int64)&unk_4DB40);
    v5 = (void **)off_5F148;
  }
  *a2 = 0;
  if ( a1 )
  {
    if ( (*a1 & 4) != 0 )
    {
      v4 = 1;
      if ( v5 != &off_5F148 )
      {
        if ( *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 4u )
        {
          v7 = 234;
LABEL_20:
          sub_11008((__int64)v5[19], v7, (__int64)&unk_4DB40);
          v5 = (void **)off_5F148;
          goto LABEL_21;
        }
        goto LABEL_21;
      }
    }
    else if ( v5 != &off_5F148 )
    {
      if ( *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 4u )
      {
        v7 = 235;
        goto LABEL_20;
      }
LABEL_21:
      if ( v5 != &off_5F148 && *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 5u )
        sub_11008((__int64)v5[19], 0xECu, (__int64)&unk_4DB40);
      return v4;
    }
    return v4;
  }
  if ( v5 != &off_5F148 && *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 2u )
    sub_11008((__int64)v5[19], 0xE9u, (__int64)&unk_4DB40);
  *a2 = 3;
  return 0;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000473B0) ----------------------------------------------------
__int64 __fastcall sub_473B0(int a1)
{
  __int64 result; // rax
  int v3; // ebx
  int v4; // ebx
  int v5; // ebx
  int v6; // ebx
  int v7; // ebx
  int v8; // ebx
  int v9; // ebx

  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x108u, (__int64)&unk_4DB40);
  if ( !a1 )
    return 0i64;
  result = 1i64;
  v3 = a1 - 1;
  if ( v3 )
  {
    v4 = v3 - 1;
    if ( v4 )
    {
      v5 = v4 - 1;
      if ( v5 )
      {
        v6 = v5 - 1;
        if ( v6 )
        {
          v7 = v6 - 1;
          if ( v7 )
          {
            v8 = v7 - 1;
            if ( !v8 || (v9 = v8 - 1) == 0 || v9 == 1 )
              result = 19i64;
          }
          else
          {
            result = 6i64;
          }
        }
        else
        {
          result = 5i64;
        }
      }
      else
      {
        result = 4i64;
      }
    }
    else
    {
      result = 3i64;
    }
  }
  return result;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000047450) ----------------------------------------------------
__int64 __fastcall sub_47450(unsigned int a1)
{
  void **v2; // rcx
  unsigned int v3; // ebx
  unsigned int *v4; // rax
  unsigned int v5; // edx

  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && *((char *)off_5F148 + 172) < 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x10Au, (__int64)&unk_4DB40);
    v2 = (void **)off_5F148;
  }
  v3 = 0;
  v4 = dword_4DB50;
  v5 = 0;
  while ( *v4 < a1 )
  {
    ++v5;
    ++v4;
    if ( v5 >= 0x1D )
    {
      if ( v2 == &off_5F148 )
        return v3;
      if ( *((char *)v2 + 172) < 0 && *((_BYTE *)v2 + 169) >= 2u )
      {
        sub_11008((__int64)v2[19], 0x10Bu, (__int64)&unk_4DB40);
LABEL_16:
        v2 = (void **)off_5F148;
        goto LABEL_17;
      }
      goto LABEL_17;
    }
  }
  v3 = dword_4DB50[v5];
  if ( v2 == &off_5F148 )
    return v3;
  if ( *((char *)v2 + 172) < 0 && *((_BYTE *)v2 + 169) >= 4u )
  {
    sub_1102C((__int64)v2[19], 0x10Cu, (__int64)&unk_4DB40, v3);
    goto LABEL_16;
  }
LABEL_17:
  if ( v2 != &off_5F148 && *((char *)v2 + 172) < 0 && *((_BYTE *)v2 + 169) >= 5u )
    sub_11008((__int64)v2[19], 0x10Du, (__int64)&unk_4DB40);
  return v3;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000047580) ----------------------------------------------------
__int64 __fastcall sub_47580(__int64 a1)
{
  void **v2; // rcx
  unsigned __int16 v3; // dx
  _QWORD *v5; // rcx
  unsigned __int16 v6; // dx
  _QWORD *v7; // rcx
  unsigned __int16 v8; // dx
  void **v9; // rcx
  unsigned __int16 v10; // dx
  int v11; // edx
  int v12; // edx
  const char *v13; // r9
  __int64 v14; // rsi
  unsigned int *v15; // rbp
  __int64 v16; // r13
  __int64 v17; // r13
  __int64 **v18; // r12
  int v19; // ecx
  struct _FAST_MUTEX *v20; // r15
  __int64 v21; // rbx
  void **v22; // rcx
  __int64 *v23; // rbx
  __int64 v24; // rsi
  unsigned int v25; // ebp
  __int64 v26; // rcx
  const char *v27; // r9
  KIRQL v28; // [rsp+70h] [rbp+8h] BYREF
  unsigned int v29; // [rsp+80h] [rbp+18h] BYREF
  struct _FAST_MUTEX *v30; // [rsp+88h] [rbp+20h]

  v29 = 0;
  v2 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x80) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x10Eu, (__int64)&unk_4DB40);
    v2 = (void **)off_5F148;
  }
  if ( !a1 )
  {
    if ( v2 == &off_5F148 || (*((_BYTE *)v2 + 172) & 0x80) == 0 || *((_BYTE *)v2 + 169) < 2u )
      return 3i64;
    v3 = 271;
LABEL_10:
    sub_11008((__int64)v2[19], v3, (__int64)&unk_4DB40);
    return 3i64;
  }
  if ( !*(_QWORD *)(a1 + 64) )
  {
    if ( v2 == &off_5F148 || (*((_BYTE *)v2 + 172) & 0x80) == 0 || *((_BYTE *)v2 + 169) < 2u )
      return 3i64;
    v3 = 272;
    goto LABEL_10;
  }
  if ( v2 != &off_5F148 )
  {
    if ( (*((_BYTE *)v2 + 172) & 0x80) != 0 && *((_BYTE *)v2 + 169) >= 4u )
    {
      sub_11008((__int64)v2[19], 0x111u, (__int64)&unk_4DB40);
      v2 = (void **)off_5F148;
    }
    if ( v2 != &off_5F148 )
    {
      if ( (*((_BYTE *)v2 + 172) & 0x80) != 0 && *((_BYTE *)v2 + 169) >= 4u )
      {
        sub_11008((__int64)v2[19], 0x112u, (__int64)&unk_4DB40);
        v2 = (void **)off_5F148;
      }
      if ( v2 != &off_5F148 )
      {
        if ( (*((_BYTE *)v2 + 172) & 0x80) != 0 && *((_BYTE *)v2 + 169) >= 4u )
        {
          sub_11008((__int64)v2[19], 0x113u, (__int64)&unk_4DB40);
          v2 = (void **)off_5F148;
        }
        if ( v2 != &off_5F148 )
        {
          if ( (*((_BYTE *)v2 + 172) & 0x80) != 0 && *((_BYTE *)v2 + 169) >= 4u )
          {
            sub_11008((__int64)v2[19], 0x114u, (__int64)&unk_4DB40);
            v2 = (void **)off_5F148;
          }
          if ( v2 != &off_5F148 )
          {
            if ( (*((_BYTE *)v2 + 172) & 0x80) != 0 && *((_BYTE *)v2 + 169) >= 4u )
            {
              sub_11008((__int64)v2[19], 0x115u, (__int64)&unk_4DB40);
              v2 = (void **)off_5F148;
            }
            if ( v2 != &off_5F148 && (*((_BYTE *)v2 + 172) & 0x80) != 0 && *((_BYTE *)v2 + 169) >= 4u )
              sub_11008((__int64)v2[19], 0x116u, (__int64)&unk_4DB40);
          }
        }
      }
    }
  }
  if ( sub_46FCC((_BYTE *)a1, &v29) )
  {
    v5 = off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x80) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      v6 = 279;
LABEL_50:
      sub_11008(v5[19], v6, (__int64)&unk_4DB40);
      goto LABEL_51;
    }
  }
  else
  {
    v5 = off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x80) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      v6 = 280;
      goto LABEL_50;
    }
  }
LABEL_51:
  if ( sub_47118((_BYTE *)a1, &v29) )
  {
    v7 = off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x80) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      v8 = 281;
LABEL_60:
      sub_11008(v7[19], v8, (__int64)&unk_4DB40);
      goto LABEL_61;
    }
  }
  else
  {
    v7 = off_5F148;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x80) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
    {
      v8 = 282;
      goto LABEL_60;
    }
  }
LABEL_61:
  if ( sub_47264((_BYTE *)a1, &v29) )
  {
    v9 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148 )
      goto LABEL_110;
    if ( (*((_BYTE *)off_5F148 + 172) & 0x80) == 0 || *((_BYTE *)off_5F148 + 169) < 4u )
      goto LABEL_71;
    v10 = 283;
    goto LABEL_70;
  }
  v9 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    goto LABEL_110;
  if ( (*((_BYTE *)off_5F148 + 172) & 0x80) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
  {
    v10 = 284;
LABEL_70:
    sub_11008((__int64)v9[19], v10, (__int64)&unk_4DB40);
    v9 = (void **)off_5F148;
  }
LABEL_71:
  if ( v9 != &off_5F148 )
  {
    if ( (*((_BYTE *)v9 + 172) & 0x80) != 0 && *((_BYTE *)v9 + 169) >= 4u )
    {
      sub_11008((__int64)v9[19], 0x11Du, (__int64)&unk_4DB40);
      v9 = (void **)off_5F148;
    }
    if ( v9 != &off_5F148 )
    {
      if ( (*((_BYTE *)v9 + 172) & 0x80) != 0 && *((_BYTE *)v9 + 169) >= 4u )
      {
        sub_1102C((__int64)v9[19], 0x11Eu, (__int64)&unk_4DB40, *(_DWORD *)(a1 + 4));
        v9 = (void **)off_5F148;
      }
      if ( v9 != &off_5F148 )
      {
        if ( (*((_BYTE *)v9 + 172) & 0x80) != 0 && *((_BYTE *)v9 + 169) >= 4u )
        {
          sub_17984((__int64)v9[19], 0x11Fu, (__int64)&unk_4DB40, *(unsigned int *)(a1 + 8));
          v9 = (void **)off_5F148;
        }
        if ( v9 != &off_5F148 )
        {
          if ( (*((_BYTE *)v9 + 172) & 0x80) != 0 && *((_BYTE *)v9 + 169) >= 4u )
          {
            sub_17984((__int64)v9[19], 0x120u, (__int64)&unk_4DB40, *(_QWORD *)(a1 + 16));
            v9 = (void **)off_5F148;
          }
          if ( v9 != &off_5F148 )
          {
            if ( (*((_BYTE *)v9 + 172) & 0x80) != 0 && *((_BYTE *)v9 + 169) >= 4u )
            {
              v11 = *(_DWORD *)(a1 + 24);
              if ( v11 )
              {
                v12 = v11 - 1;
                if ( v12 )
                {
                  if ( v12 == 1 )
                    v13 = "E_NNS_HT_SYNCHRONIZER_TYPE_FAST_MUTEX";
                  else
                    v13 = "NO_STRING_FOR_THIS_SYNCHRONIZER_TYPE";
                }
                else
                {
                  v13 = "E_NNS_HT_SYNCHRONIZER_TYPE_SPINLOCK";
                }
              }
              else
              {
                v13 = "E_NNS_HT_SYNCHRONIZER_TYPE_NONE";
              }
              sub_13618((__int64)v9[19], 0x121u, (__int64)&unk_4DB40, v13);
              v9 = (void **)off_5F148;
            }
            if ( v9 != &off_5F148 )
            {
              if ( (*((_BYTE *)v9 + 172) & 0x80) != 0 && *((_BYTE *)v9 + 169) >= 4u )
              {
                sub_11008((__int64)v9[19], 0x122u, (__int64)&unk_4DB40);
                v9 = (void **)off_5F148;
              }
              if ( v9 != &off_5F148 )
              {
                if ( (*((_BYTE *)v9 + 172) & 0x80) != 0 && *((_BYTE *)v9 + 169) >= 4u )
                {
                  sub_11008((__int64)v9[19], 0x123u, (__int64)&unk_4DB40);
                  v9 = (void **)off_5F148;
                }
                if ( v9 != &off_5F148 && (*((_BYTE *)v9 + 172) & 0x80) != 0 && *((_BYTE *)v9 + 169) >= 4u )
                {
                  sub_11008((__int64)v9[19], 0x124u, (__int64)&unk_4DB40);
                  v9 = (void **)off_5F148;
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_110:
  v14 = 0i64;
  if ( *(_DWORD *)(a1 + 4) )
  {
    v15 = (unsigned int *)(a1 + 96);
    do
    {
      sub_44474(*(_DWORD *)(a1 + 24), (struct _FAST_MUTEX *)(a1 + 80 * v14 + 104), &v28);
      v16 = *v15;
      sub_44538(*(_DWORD *)(a1 + 24), (struct _FAST_MUTEX *)(a1 + 80 * v14 + 104), v28);
      if ( v16 )
      {
        v9 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 || *((char *)off_5F148 + 172) >= 0 || *((_BYTE *)off_5F148 + 169) < 4u )
          goto LABEL_118;
        sub_43F68(*((_QWORD *)off_5F148 + 19), 0x125u, (__int64)&unk_4DB40, (unsigned int)v14, v16);
      }
      v9 = (void **)off_5F148;
LABEL_118:
      v14 = (unsigned int)(v14 + 1);
      v15 += 20;
    }
    while ( (unsigned int)v14 < *(_DWORD *)(a1 + 4) );
  }
  v17 = 0i64;
  if ( *(_DWORD *)(a1 + 4) )
  {
    v18 = (__int64 **)(a1 + 80);
    do
    {
      v19 = *(_DWORD *)(a1 + 24);
      v20 = (struct _FAST_MUTEX *)(a1 + 80 * v17 + 104);
      v30 = v20;
      sub_44474(v19, v20, &v28);
      v21 = *((unsigned int *)v18 + 4);
      if ( *((_DWORD *)v18 + 4) )
      {
        v22 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 )
        {
          if ( (*((_BYTE *)off_5F148 + 172) & 0x80) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
          {
            sub_11008(*((_QWORD *)off_5F148 + 19), 0x126u, (__int64)&unk_4DB40);
            v22 = (void **)off_5F148;
          }
          if ( v22 != &off_5F148 )
          {
            if ( (*((_BYTE *)v22 + 172) & 0x80) != 0 && *((_BYTE *)v22 + 169) >= 4u )
            {
              sub_17984((__int64)v22[19], 0x127u, (__int64)&unk_4DB40, (unsigned int)v17);
              v22 = (void **)off_5F148;
            }
            if ( v22 != &off_5F148 && (*((_BYTE *)v22 + 172) & 0x80) != 0 && *((_BYTE *)v22 + 169) >= 4u )
            {
              sub_17984((__int64)v22[19], 0x128u, (__int64)&unk_4DB40, v21);
              v22 = (void **)off_5F148;
            }
          }
        }
        v23 = *v18;
        if ( *v18 != (__int64 *)v18 )
        {
          v24 = a1 + 80 * v17 + 80;
          v25 = 0;
          if ( v23 != (__int64 *)v24 )
          {
            while ( 1 )
            {
              ++v25;
              if ( v22 != &off_5F148 )
              {
                if ( *((char *)v22 + 172) < 0 && *((_BYTE *)v22 + 169) >= 4u )
                {
                  sub_43F68((__int64)v22[19], 0x129u, (__int64)&unk_4DB40, (unsigned int)v17, v25);
                  v22 = (void **)off_5F148;
                }
                if ( v22 != &off_5F148 )
                {
                  if ( *((char *)v22 + 172) < 0 && *((_BYTE *)v22 + 169) >= 4u )
                  {
                    sub_440E8((__int64)v22[19], 298i64, (__int64)&unk_4DB40, v23[2]);
                    v22 = (void **)off_5F148;
                  }
                  if ( v22 != &off_5F148 )
                  {
                    if ( *((char *)v22 + 172) < 0 && *((_BYTE *)v22 + 169) >= 4u )
                    {
                      sub_1102C((__int64)v22[19], 0x12Bu, (__int64)&unk_4DB40, *((_DWORD *)v23 + 10));
                      v22 = (void **)off_5F148;
                    }
                    if ( v22 != &off_5F148 )
                    {
                      if ( *((char *)v22 + 172) < 0 && *((_BYTE *)v22 + 169) >= 4u )
                      {
                        sub_17984((__int64)v22[19], 0x12Cu, (__int64)&unk_4DB40, v23[3]);
                        v22 = (void **)off_5F148;
                      }
                      if ( v22 != &off_5F148 )
                      {
                        if ( *((char *)v22 + 172) < 0 && *((_BYTE *)v22 + 169) >= 4u )
                        {
                          sub_1102C((__int64)v22[19], 0x12Du, (__int64)&unk_4DB40, *((unsigned __int8 *)v23 + 44));
                          v22 = (void **)off_5F148;
                        }
                        if ( v22 != &off_5F148 )
                        {
                          if ( *((char *)v22 + 172) < 0 && *((_BYTE *)v22 + 169) >= 4u )
                          {
                            sub_17984((__int64)v22[19], 0x12Eu, (__int64)&unk_4DB40, v23[4]);
                            v22 = (void **)off_5F148;
                          }
                          if ( v22 != &off_5F148 )
                          {
                            if ( *((char *)v22 + 172) < 0 && *((_BYTE *)v22 + 169) >= 4u )
                            {
                              v26 = (__int64)v22[19];
                              v27 = "FALSE";
                              if ( *((_BYTE *)v23 + 45) )
                                v27 = "TRUE";
                              sub_13618(v26, 0x12Fu, (__int64)&unk_4DB40, v27);
                              v22 = (void **)off_5F148;
                            }
                            if ( v22 != &off_5F148 )
                            {
                              if ( *((char *)v22 + 172) < 0 && *((_BYTE *)v22 + 169) >= 4u )
                              {
                                sub_17984((__int64)v22[19], 0x130u, (__int64)&unk_4DB40, v23[6]);
                                v22 = (void **)off_5F148;
                              }
                              if ( v22 != &off_5F148 && *((char *)v22 + 172) < 0 && *((_BYTE *)v22 + 169) >= 4u )
                                sub_11008((__int64)v22[19], 0x131u, (__int64)&unk_4DB40);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              (*(void (__fastcall **)(__int64))(a1 + 64))(v23[4]);
              v23 = (__int64 *)*v23;
              if ( v23 == (__int64 *)v24 )
                break;
              v22 = (void **)off_5F148;
            }
            v20 = v30;
          }
        }
      }
      sub_44538(*(_DWORD *)(a1 + 24), v20, v28);
      v17 = (unsigned int)(v17 + 1);
      v18 += 10;
    }
    while ( (unsigned int)v17 < *(_DWORD *)(a1 + 4) );
    v9 = (void **)off_5F148;
  }
  if ( v9 != &off_5F148 && *((char *)v9 + 172) < 0 && *((_BYTE *)v9 + 169) >= 5u )
    sub_11008((__int64)v9[19], 0x133u, (__int64)&unk_4DB40);
  return v29;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000047F64) ----------------------------------------------------
char __fastcall sub_47F64(ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter1)
{
  char result; // al
  int v5; // [rsp+50h] [rbp+18h] BYREF

  v5 = 0;
  result = sub_47264((_BYTE *)BugCheckParameter2, &v5);
  if ( result )
  {
    if ( *(_BYTE *)(BugCheckParameter1 + 45) )
      KeBugCheckEx(0xDEFECAu, BugCheckParameter1, BugCheckParameter2, 0i64, 0i64);
  }
  return result;
}

//----- (0000000000047FBC) ----------------------------------------------------
__int64 __fastcall sub_47FBC(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+168h] [rbp+20h] BYREF

  v5 = a4;
  return qword_5F3B8(a1, 43i64, &unk_4DB30, 119i64, &v5);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000048100) ----------------------------------------------------
__int64 __fastcall sub_48100(__int64 a1, __int64 a2, __int64 a3, int a4, const char *a5, const char *a6)
{
  int v8; // [rsp+88h] [rbp+20h] BYREF

  v8 = a4;
  if ( a6 )
    strlen(a6);
  if ( a5 )
    strlen(a5);
  return qword_5F3B8(a1, 43i64, &unk_4DB30, 336i64, &v8);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000481C8) ----------------------------------------------------
__int64 __fastcall sub_481C8(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, const char *a5)
{
  int v7; // [rsp+78h] [rbp+20h] BYREF

  v7 = a4;
  if ( a5 )
    strlen(a5);
  return qword_5F3B8(a1, 43i64, &unk_4DB30, a2, &v7);
}
// 5F3B8: using guessed type __int64 (__fastcall *qword_5F3B8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000048250) ----------------------------------------------------
_BYTE *__fastcall sub_48250(_BYTE *a1, int a2)
{
  __int64 v2; // rbx
  void **v5; // rcx
  unsigned __int16 v6; // dx
  unsigned __int16 v8; // dx
  void **v9; // rcx
  unsigned __int16 v10; // dx
  int v11; // eax
  unsigned __int8 v12; // al
  __int64 v13; // rbx
  unsigned __int16 v14; // dx
  __int64 v15; // [rsp+30h] [rbp-78h] BYREF
  unsigned __int64 v16; // [rsp+38h] [rbp-70h] BYREF
  char Dst[40]; // [rsp+40h] [rbp-68h] BYREF
  unsigned __int8 v18; // [rsp+B8h] [rbp+10h] BYREF
  char v19; // [rsp+C0h] [rbp+18h] BYREF
  unsigned __int16 v20; // [rsp+C8h] [rbp+20h] BYREF

  v2 = 0i64;
  v19 = 0;
  v15 = 0i64;
  v18 = -1;
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_2A274(*((_QWORD *)off_5F148 + 19), 10i64, (__int64)&unk_4DB30, a2);
    v5 = (void **)off_5F148;
  }
  if ( !a2 )
  {
    if ( v5 == &off_5F148 || (*((_BYTE *)v5 + 172) & 0x20) == 0 || *((_BYTE *)v5 + 169) < 5u )
      return a1;
    v6 = 11;
LABEL_10:
    sub_11008((__int64)v5[19], v6, (__int64)&unk_4DB30);
    return a1;
  }
  sub_48908((__int64)a1, &v20);
  v8 = v20;
  a1 += 14;
  if ( v20 == 2048 || v20 == 0x86DD )
  {
    sub_489CC(a1, &v19);
    v8 = v20;
    if ( v20 == 2048 && v19 != 4 || v20 == 0x86DD && v19 != 6 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 3u )
        sub_127D0(*((_QWORD *)off_5F148 + 19), 0xDu, (__int64)&unk_4DB30, v20);
      return 0i64;
    }
LABEL_27:
    if ( a2 == 1 )
    {
      if ( v8 == 2048 )
      {
        v5 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 0x20) == 0 || *((_BYTE *)off_5F148 + 169) < 5u )
          return a1;
        v6 = 14;
        goto LABEL_10;
      }
      v9 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 0x20) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        return 0i64;
      v10 = 15;
      goto LABEL_114;
    }
    if ( a2 == 2 )
    {
      if ( v8 == 0x86DD )
      {
        v5 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 0x20) == 0 || *((_BYTE *)off_5F148 + 169) < 5u )
          return a1;
        v6 = 16;
        goto LABEL_10;
      }
      v9 = (void **)off_5F148;
      if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 0x20) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
        return 0i64;
      v10 = 17;
      goto LABEL_114;
    }
    if ( v8 == 2048 )
    {
      if ( sub_49E6C((__int64)a1) )
      {
        v9 = (void **)off_5F148;
        if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 0x20) == 0 || *((_BYTE *)off_5F148 + 169) < 3u )
          return 0i64;
        v10 = 20;
        goto LABEL_114;
      }
      v13 = 4 * (*a1 & 0xF);
      v12 = a1[9];
      v18 = v12;
      v2 = (__int64)&a1[v13];
    }
    else
    {
      if ( v8 == 34525 )
      {
        v16 = 0i64;
        memset(Dst, 0, sizeof(Dst));
        if ( !(unsigned int)sub_4A548((__int64)a1, 0x2Cu, &v16) )
        {
          v9 = (void **)off_5F148;
          if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 0x20) == 0 || *((_BYTE *)off_5F148 + 169) < 3u )
            return 0i64;
          v10 = 21;
          goto LABEL_114;
        }
        v11 = sub_48E1C((__int64)a1, &v18, &v15);
        if ( v11 )
        {
          v9 = (void **)off_5F148;
          if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 0x20) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
          {
            v2 = v15;
            v12 = v18;
LABEL_69:
            if ( v12 != 6 && v12 != 17 && v12 != 1 && v12 != 58 )
            {
              if ( v9 == &off_5F148 || (*((_BYTE *)v9 + 172) & 0x20) == 0 || *((_BYTE *)v9 + 169) < 2u )
                return 0i64;
              v10 = 23;
              goto LABEL_114;
            }
            switch ( a2 )
            {
              case 3:
                if ( v12 != 6 )
                {
                  if ( v9 == &off_5F148 || (*((_BYTE *)v9 + 172) & 0x20) == 0 || *((_BYTE *)v9 + 169) < 2u )
                    return 0i64;
                  v10 = 25;
                  goto LABEL_114;
                }
                if ( v9 != &off_5F148 && (*((_BYTE *)v9 + 172) & 0x20) != 0 && *((_BYTE *)v9 + 169) >= 5u )
                {
                  v14 = 24;
LABEL_83:
                  sub_11008((__int64)v9[19], v14, (__int64)&unk_4DB30);
                  return (_BYTE *)v2;
                }
                break;
              case 4:
                if ( v12 != 17 )
                {
                  if ( v9 == &off_5F148 || (*((_BYTE *)v9 + 172) & 0x20) == 0 || *((_BYTE *)v9 + 169) < 2u )
                    return 0i64;
                  v10 = 27;
                  goto LABEL_114;
                }
                if ( v9 != &off_5F148 && (*((_BYTE *)v9 + 172) & 0x20) != 0 && *((_BYTE *)v9 + 169) >= 5u )
                {
                  v14 = 26;
                  goto LABEL_83;
                }
                break;
              case 6:
                if ( v12 != 1 && v12 != 58 )
                {
                  if ( v9 == &off_5F148 || (*((_BYTE *)v9 + 172) & 0x20) == 0 || *((_BYTE *)v9 + 169) < 2u )
                    return 0i64;
                  v10 = 29;
                  goto LABEL_114;
                }
                if ( v9 != &off_5F148 && (*((_BYTE *)v9 + 172) & 0x20) != 0 && *((_BYTE *)v9 + 169) >= 5u )
                {
                  v14 = 28;
                  goto LABEL_83;
                }
                break;
              default:
                if ( v9 == &off_5F148 || (*((_BYTE *)v9 + 172) & 0x20) == 0 || *((_BYTE *)v9 + 169) < 2u )
                  return 0i64;
                v10 = 31;
                goto LABEL_114;
            }
            return (_BYTE *)v2;
          }
          sub_1102C(*((_QWORD *)off_5F148 + 19), 0x16u, (__int64)&unk_4DB30, v11);
        }
        v2 = v15;
      }
      v12 = v18;
    }
    v9 = (void **)off_5F148;
    goto LABEL_69;
  }
  if ( v20 == 2054 )
    goto LABEL_27;
  v9 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 0x20) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
    return 0i64;
  v10 = 12;
LABEL_114:
  sub_11008((__int64)v9[19], v10, (__int64)&unk_4DB30);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000004879C) ----------------------------------------------------
__int64 __fastcall sub_4879C(__int64 a1, __int64 a2)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x31u, (__int64)&unk_4DB30, a1, a2);
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 6);
  *(_WORD *)(a2 + 4) = *(_WORD *)(a1 + 10);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x32u, (__int64)&unk_4DB30);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000048854) ----------------------------------------------------
__int64 __fastcall sub_48854(__int64 a1, __int64 a2)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x33u, (__int64)&unk_4DB30, a1, a2);
  *(_DWORD *)a2 = *(_DWORD *)a1;
  *(_WORD *)(a2 + 4) = *(_WORD *)(a1 + 4);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x34u, (__int64)&unk_4DB30);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000048908) ----------------------------------------------------
__int64 __fastcall sub_48908(__int64 a1, _WORD *a2)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x35u, (__int64)&unk_4DB30, a1, a2);
  *a2 = (unsigned __int8)HIBYTE(*(_WORD *)(a1 + 12)) | ((unsigned __int8)*(_WORD *)(a1 + 12) << 8);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x36u, (__int64)&unk_4DB30);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000489CC) ----------------------------------------------------
__int64 __fastcall sub_489CC(_BYTE *a1, _BYTE *a2)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x37u, (__int64)&unk_4DB30, a1, a2);
  *a2 = *a1 >> 4;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x38u, (__int64)&unk_4DB30);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000048A7C) ----------------------------------------------------
__int64 __fastcall sub_48A7C(__int64 a1, _BYTE *a2)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x41u, (__int64)&unk_4DB30, a1, a2);
  *a2 = *(_BYTE *)(a1 + 6) >> 5;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x42u, (__int64)&unk_4DB30);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000048B2C) ----------------------------------------------------
__int64 __fastcall sub_48B2C(__int64 a1, _WORD *a2)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x43u, (__int64)&unk_4DB30, a1, a2);
  *a2 = _byteswap_ushort(*(_WORD *)(a1 + 6)) & 0x1FFF;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x44u, (__int64)&unk_4DB30);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000048BF8) ----------------------------------------------------
__int64 __fastcall sub_48BF8(__int64 a1, _DWORD *a2)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x4Bu, (__int64)&unk_4DB30, a1, a2);
  *a2 = *(_DWORD *)(a1 + 12);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x4Cu, (__int64)&unk_4DB30);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000048CA8) ----------------------------------------------------
__int64 __fastcall sub_48CA8(__int64 a1, _DWORD *a2)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x4Du, (__int64)&unk_4DB30, a1, a2);
  *a2 = *(_DWORD *)(a1 + 16);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x4Eu, (__int64)&unk_4DB30);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000048D58) ----------------------------------------------------
__int64 __fastcall sub_48D58(__int64 a1, _DWORD *a2)
{
  unsigned __int16 v5; // [rsp+38h] [rbp+10h] BYREF

  v5 = 0;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_17984(*((_QWORD *)off_5F148 + 19), 0x51u, (__int64)&unk_4DB30, a1);
  sub_492B4(a1, &v5);
  *a2 = v5 + 40;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x52u, (__int64)&unk_4DB30);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000048E1C) ----------------------------------------------------
__int64 __fastcall sub_48E1C(__int64 a1, unsigned __int8 *a2, _QWORD *a3)
{
  void **v6; // rcx
  unsigned int v7; // ebx
  unsigned __int8 v8; // si
  unsigned __int8 v9; // di
  unsigned __int64 v11; // [rsp+30h] [rbp-48h] BYREF
  _BYTE v12[40]; // [rsp+38h] [rbp-40h] BYREF
  char v13; // [rsp+80h] [rbp+8h]
  char v14; // [rsp+81h] [rbp+9h]
  char v15; // [rsp+82h] [rbp+Ah]

  v11 = 0i64;
  memset(v12, 0, sizeof(v12));
  v13 = 6;
  v14 = 17;
  v15 = 58;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x53u, (__int64)&unk_4DB30);
    v6 = (void **)off_5F148;
  }
  if ( a1 && a2 )
  {
    *a2 = 0;
    if ( a3 )
      *a3 = 0i64;
    if ( sub_490E0(a1) )
    {
      v6 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 3u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x55u, (__int64)&unk_4DB30);
        v6 = (void **)off_5F148;
      }
      v7 = 18;
    }
    else
    {
      v6 = (void **)off_5F148;
      v8 = 0;
      while ( 1 )
      {
        v9 = *(&v13 + v8);
        if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 5u )
          sub_1102C((__int64)v6[19], 0x56u, (__int64)&unk_4DB30, v9);
        v7 = sub_4A548(a1, v9, &v11);
        if ( !v7 )
          break;
        v6 = (void **)off_5F148;
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        {
          sub_1102C(*((_QWORD *)off_5F148 + 19), 0x58u, (__int64)&unk_4DB30, v7);
          v6 = (void **)off_5F148;
        }
        if ( ++v8 >= 3u )
          goto LABEL_39;
      }
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x57u, (__int64)&unk_4DB30, v9);
      *a2 = v9;
      if ( a3 )
        *a3 = v11;
      v6 = (void **)off_5F148;
    }
  }
  else
  {
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 2u )
    {
      sub_143EC((__int64)v6[19], 0x54u, (__int64)&unk_4DB30, a1, a2, 0i64);
      v6 = (void **)off_5F148;
    }
    v7 = 4;
  }
LABEL_39:
  if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_11008((__int64)v6[19], 0x59u, (__int64)&unk_4DB30);
  return v7;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000490E0) ----------------------------------------------------
char __fastcall sub_490E0(__int64 a1)
{
  char v1; // bl
  void **v3; // rcx
  unsigned __int64 v5; // [rsp+20h] [rbp-38h] BYREF
  _BYTE v6[40]; // [rsp+28h] [rbp-30h] BYREF
  unsigned __int16 v7; // [rsp+60h] [rbp+8h] BYREF

  v1 = 0;
  v5 = 0i64;
  memset(v6, 0, sizeof(v6));
  v7 = 0;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x5Au, (__int64)&unk_4DB30);
    v3 = (void **)off_5F148;
  }
  if ( a1 )
  {
    sub_492B4(a1, &v7);
    if ( !(unsigned int)sub_4A548(a1, 0, &v5) )
    {
      v3 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x5Cu, (__int64)&unk_4DB30);
        v3 = (void **)off_5F148;
      }
      if ( !v7 )
      {
        if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 172) & 0x20) != 0 && *((_BYTE *)v3 + 169) >= 3u )
        {
          sub_11008((__int64)v3[19], 0x5Du, (__int64)&unk_4DB30);
          v3 = (void **)off_5F148;
        }
        v1 = 1;
      }
      goto LABEL_26;
    }
    v3 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148 )
      return v1;
    if ( (*((_BYTE *)off_5F148 + 172) & 0x20) == 0 || *((_BYTE *)off_5F148 + 169) < 5u )
      goto LABEL_26;
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x5Eu, (__int64)&unk_4DB30);
    goto LABEL_25;
  }
  if ( v3 == &off_5F148 )
    return v1;
  if ( (*((_BYTE *)v3 + 172) & 0x20) != 0 && *((_BYTE *)v3 + 169) >= 2u )
  {
    sub_17984((__int64)v3[19], 0x5Bu, (__int64)&unk_4DB30, 0i64, v5);
LABEL_25:
    v3 = (void **)off_5F148;
  }
LABEL_26:
  if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 172) & 0x20) != 0 && *((_BYTE *)v3 + 169) >= 5u )
    sub_11008((__int64)v3[19], 0x5Fu, (__int64)&unk_4DB30);
  return v1;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000492B4) ----------------------------------------------------
__int64 __fastcall sub_492B4(__int64 a1, unsigned __int16 *a2)
{
  unsigned __int16 v4; // dx

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x68u, (__int64)&unk_4DB30, a1, a2);
  v4 = (unsigned __int8)HIBYTE(*(_WORD *)(a1 + 4)) | ((unsigned __int8)*(_WORD *)(a1 + 4) << 8);
  *a2 = v4;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x69u, (__int64)&unk_4DB30, v4);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000004937C) ----------------------------------------------------
__int64 __fastcall sub_4937C(__int64 a1, unsigned __int8 *a2)
{
  unsigned __int8 v4; // al

  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x6Au, (__int64)&unk_4DB30, a1, a2);
  v4 = *(_BYTE *)(a1 + 6);
  *a2 = v4;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x6Bu, (__int64)&unk_4DB30, v4);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000049430) ----------------------------------------------------
__int64 __fastcall sub_49430(__int64 a1, __m128i *a2)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x6Eu, (__int64)&unk_4DB30, a1, a2);
  *a2 = _mm_loadu_si128((const __m128i *)(a1 + 8));
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x6Fu, (__int64)&unk_4DB30);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (00000000000494E4) ----------------------------------------------------
__int64 __fastcall sub_494E4(__int64 a1, __m128i *a2)
{
  int v4; // eax
  void **v5; // rcx
  unsigned __int64 v7; // [rsp+30h] [rbp-38h] BYREF
  _BYTE v8[40]; // [rsp+38h] [rbp-30h] BYREF

  v7 = 0i64;
  memset(v8, 0, sizeof(v8));
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x70u, (__int64)&unk_4DB30, a1, a2);
  if ( (unsigned int)sub_4A548(a1, 0x2Bu, &v7) )
    goto LABEL_11;
  v4 = sub_49640(&v7, a2);
  if ( v4 )
  {
    v5 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148 )
    {
LABEL_16:
      *a2 = _mm_loadu_si128((const __m128i *)(a1 + 24));
      goto LABEL_17;
    }
    if ( (*((_BYTE *)off_5F148 + 172) & 0x20) == 0 || *((_BYTE *)off_5F148 + 169) < 5u )
    {
LABEL_12:
      if ( v5 != &off_5F148 && (*((_BYTE *)v5 + 172) & 0x20) != 0 && *((_BYTE *)v5 + 169) >= 5u )
        sub_11008((__int64)v5[19], 0x72u, (__int64)&unk_4DB30);
      goto LABEL_16;
    }
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0x71u, (__int64)&unk_4DB30, v4);
LABEL_11:
    v5 = (void **)off_5F148;
    goto LABEL_12;
  }
LABEL_17:
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x73u, (__int64)&unk_4DB30);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000049640) ----------------------------------------------------
__int64 __fastcall sub_49640(_BYTE *a1, __m128i *a2)
{
  __m128i *v2; // r12
  const __m128i *v4; // r15
  unsigned __int8 v5; // di
  void **v6; // rcx
  bool v7; // bp
  const char *v8; // r8
  __int64 v9; // rcx
  const char *v10; // rax
  unsigned int v11; // ebx
  unsigned __int8 v12; // di
  __int64 v13; // rax
  unsigned __int16 v14; // r9
  unsigned __int16 v15; // ax
  unsigned __int16 v17; // [rsp+F0h] [rbp+8h]
  __m128i *v18; // [rsp+F8h] [rbp+10h]
  const __m128i *v19; // [rsp+108h] [rbp+20h]

  v18 = a2;
  v2 = a2;
  v4 = 0i64;
  v19 = 0i64;
  v5 = -1;
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x74u, (__int64)&unk_4DB30);
    v6 = (void **)off_5F148;
  }
  v7 = 0;
  if ( *(_QWORD *)a1 )
  {
    v5 = *(_BYTE *)(*(_QWORD *)a1 + 2i64);
    if ( !v5 || v5 > 1u && v5 <= 3u )
      v7 = 1;
  }
  if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 5u )
  {
    if ( v5 )
    {
      switch ( v5 )
      {
        case 1u:
          v8 = "NIMROD";
          break;
        case 2u:
          v8 = "MOBILITY";
          break;
        case 3u:
          v8 = "RPL";
          break;
        case 4u:
          v8 = "SEGMENT";
          break;
        case 0xFDu:
          v8 = "EXP_1";
          break;
        case 0xFEu:
          v8 = "EXP_2";
          break;
        default:
          v8 = "UNKNOWN";
          break;
      }
    }
    else
    {
      v8 = "SOURCE_ROUTE";
    }
    v9 = (__int64)v6[19];
    v10 = "NOT";
    if ( v7 )
      v10 = (const char *)&unk_4DD7A;
    sub_48100(v9, 336i64, (__int64)&unk_4DB30, v5, v8, v10);
    v6 = (void **)off_5F148;
  }
  if ( v7 )
  {
    if ( *(_QWORD *)a1 && *(_BYTE *)(*(_QWORD *)a1 + 3i64) )
    {
      v12 = (unsigned __int8)(a1[24] - 8) >> 4;
      if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 5u )
      {
        sub_11008((__int64)v6[19], 0x76u, (__int64)&unk_4DB30);
        v6 = (void **)off_5F148;
      }
      v13 = *(_QWORD *)a1;
      if ( *(_QWORD *)a1 )
      {
        v4 = (const __m128i *)(v13 + 8);
        v19 = (const __m128i *)(v13 + 8);
      }
      v14 = 0;
      v17 = 0;
      if ( v12 )
      {
        do
        {
          if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 5u )
          {
            v4 = v19;
            sub_47FBC(*((_QWORD *)off_5F148 + 19), 119i64, (__int64)&unk_4DB30, v17);
            v6 = (void **)off_5F148;
            v14 = v17;
            v2 = v18;
          }
          ++v14;
          v15 = v12;
          v17 = v14;
          if ( v14 == v12 )
          {
            if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 5u )
            {
              sub_11008((__int64)v6[19], 0x78u, (__int64)&unk_4DB30);
              v14 = v17;
              v15 = v12;
            }
            *v2 = _mm_loadu_si128(v4);
          }
          else
          {
            v19 = ++v4;
          }
          v6 = (void **)off_5F148;
        }
        while ( v14 < v15 );
      }
      v11 = 0;
      *v2 = _mm_loadu_si128(v4);
    }
    else
    {
      if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 5u )
        sub_11008((__int64)v6[19], 0x75u, (__int64)&unk_4DB30);
      v11 = 6;
    }
  }
  else
  {
    v11 = 18;
  }
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x79u, (__int64)&unk_4DB30);
  return v11;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000049AAC) ----------------------------------------------------
__int64 __fastcall sub_49AAC(_WORD *a1, _WORD *a2)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x7Au, (__int64)&unk_4DB30, a1, a2);
  *a2 = (unsigned __int8)HIBYTE(*a1) | ((unsigned __int8)*a1 << 8);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x7Bu, (__int64)&unk_4DB30);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000049B70) ----------------------------------------------------
__int64 __fastcall sub_49B70(__int64 a1, _WORD *a2)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x7Cu, (__int64)&unk_4DB30, a1, a2);
  *a2 = (unsigned __int8)HIBYTE(*(_WORD *)(a1 + 2)) | ((unsigned __int8)*(_WORD *)(a1 + 2) << 8);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x7Du, (__int64)&unk_4DB30);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000049C34) ----------------------------------------------------
__int64 __fastcall sub_49C34(__int64 a1, _BYTE *a2)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0x86u, (__int64)&unk_4DB30, a1, a2);
  *a2 = *(_BYTE *)(a1 + 13);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x87u, (__int64)&unk_4DB30);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000049CE4) ----------------------------------------------------
__int64 __fastcall sub_49CE4(_WORD *a1, _WORD *a2)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0xB3u, (__int64)&unk_4DB30, a1, a2);
  *a2 = (unsigned __int8)HIBYTE(*a1) | ((unsigned __int8)*a1 << 8);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xB4u, (__int64)&unk_4DB30);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000049DA8) ----------------------------------------------------
__int64 __fastcall sub_49DA8(__int64 a1, _WORD *a2)
{
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_143A4(*((_QWORD *)off_5F148 + 19), 0xB5u, (__int64)&unk_4DB30, a1, a2);
  *a2 = (unsigned __int8)HIBYTE(*(_WORD *)(a1 + 2)) | ((unsigned __int8)*(_WORD *)(a1 + 2) << 8);
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0xB6u, (__int64)&unk_4DB30);
  return 0i64;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000049E6C) ----------------------------------------------------
char __fastcall sub_49E6C(__int64 a1)
{
  _QWORD *v2; // rcx
  unsigned __int16 v3; // dx
  char v5; // [rsp+38h] [rbp+10h] BYREF
  __int16 v6; // [rsp+40h] [rbp+18h] BYREF

  v5 = 0;
  v6 = 0;
  sub_48A7C(a1, &v5);
  if ( (v5 & 1) != 0 )
  {
    v2 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 0x20) == 0 || *((_BYTE *)off_5F148 + 169) < 5u )
      return 1;
    v3 = 276;
LABEL_6:
    sub_11008(v2[19], v3, (__int64)&unk_4DB30);
    return 1;
  }
  sub_48B2C(a1, &v6);
  if ( v6 )
  {
    v2 = off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 0x20) == 0 || *((_BYTE *)off_5F148 + 169) < 5u )
      return 1;
    v3 = 277;
    goto LABEL_6;
  }
  return 0;
}
// 5F148: using guessed type void *off_5F148;

//----- (0000000000049F2C) ----------------------------------------------------
__int64 __fastcall sub_49F2C(__int64 a1, int a2, __int64 a3)
{
  void **v6; // rcx
  int v7; // eax
  unsigned int v8; // edi
  __int64 v9; // rax
  int v11; // [rsp+28h] [rbp-10h]

  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x116u, (__int64)&unk_4DB30);
    v6 = (void **)off_5F148;
  }
  if ( a1 && a3 && a2 )
  {
    *(_QWORD *)a3 = a1 + 40;
    sub_4937C(a1, (unsigned __int8 *)(a3 + 8));
    v7 = sub_4A2D8(a1, a2, a3);
    v8 = v7;
    if ( v7 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 2u )
        sub_1102C(*((_QWORD *)off_5F148 + 19), 0x118u, (__int64)&unk_4DB30, v7);
      v8 = 0;
    }
    v9 = *(_QWORD *)a3;
    *(_QWORD *)(a3 + 32) = a1;
    *(_BYTE *)(a3 + 40) = -1;
    *(_QWORD *)(a3 + 16) = v9 + 2;
    sub_4A8A8(a3);
    v6 = (void **)off_5F148;
  }
  else
  {
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 2u )
    {
      v11 = a2;
      sub_34F90((__int64)v6[19], 0x117u, (__int64)&unk_4DB30, a1, a3, v11);
      v6 = (void **)off_5F148;
    }
    v8 = 4;
  }
  if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_11008((__int64)v6[19], 0x119u, (__int64)&unk_4DB30);
  return v8;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000004A0C0) ----------------------------------------------------
__int64 __fastcall sub_4A0C0(__int64 a1, unsigned int a2, unsigned __int16 *a3)
{
  __int64 v3; // rbx
  void **v6; // r10
  unsigned int v7; // ebx
  char v8; // al
  int v9; // eax
  int v11; // [rsp+28h] [rbp-40h]
  __int64 Src; // [rsp+30h] [rbp-38h] BYREF
  __int64 v13[5]; // [rsp+38h] [rbp-30h] BYREF

  Src = 0i64;
  v3 = a2;
  memset(v13, 0, sizeof(v13));
  v6 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x11Au, (__int64)&unk_4DB30);
    v6 = (void **)off_5F148;
  }
  if ( a1 && a3 && (_DWORD)v3 )
  {
    if ( *(_QWORD *)a3 + (unsigned __int64)a3[12] < v3 + a1 - 1 )
    {
      v8 = **(_BYTE **)a3;
      Src = *(_QWORD *)a3 + a3[12];
      LOBYTE(v13[0]) = v8;
      v9 = sub_4A2D8(a1, v3, (__int64)&Src);
      v7 = v9;
      if ( v9 )
      {
        if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 3u )
          sub_1102C(*((_QWORD *)off_5F148 + 19), 0x11Du, (__int64)&unk_4DB30, v9);
        v7 = 0;
      }
      v13[1] = Src + 2;
      v13[3] = *(_QWORD *)a3;
      LOBYTE(v13[4]) = *((_BYTE *)a3 + 8);
      memmove(a3, &Src, 0x30ui64);
      sub_4A8A8((__int64)a3);
      v6 = (void **)off_5F148;
    }
    else
    {
      if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 3u )
      {
        sub_11008((__int64)v6[19], 0x11Cu, (__int64)&unk_4DB30);
        v6 = (void **)off_5F148;
      }
      v7 = 10;
    }
  }
  else
  {
    if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 2u )
    {
      v11 = v3;
      sub_34F90((__int64)v6[19], 0x11Bu, (__int64)&unk_4DB30, a1, a3, v11, Src);
      v6 = (void **)off_5F148;
    }
    v7 = 4;
  }
  if ( v6 != &off_5F148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_11008((__int64)v6[19], 0x11Eu, (__int64)&unk_4DB30);
  return v7;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000004A2D8) ----------------------------------------------------
__int64 __fastcall sub_4A2D8(__int64 a1, int a2, __int64 a3)
{
  unsigned int v5; // esi
  void **v7; // rcx
  __int16 v8; // cx

  v5 = 0;
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x11Fu, (__int64)&unk_4DB30);
    v7 = (void **)off_5F148;
  }
  if ( !a1 || !a3 || !a2 )
  {
    if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 172) & 0x20) != 0 && *((_BYTE *)v7 + 169) >= 2u )
    {
      sub_34F90((__int64)v7[19], 0x120u, (__int64)&unk_4DB30, a1, a3, a2);
      v7 = (void **)off_5F148;
    }
    v5 = 4;
    goto LABEL_39;
  }
  if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 172) & 0x20) != 0 && *((_BYTE *)v7 + 169) >= 5u )
  {
    sub_1102C((__int64)v7[19], 0x121u, (__int64)&unk_4DB30, *(unsigned __int8 *)(a3 + 8));
    v7 = (void **)off_5F148;
  }
  switch ( *(_BYTE *)(a3 + 8) )
  {
    case 0:
      goto LABEL_28;
    case 6:
    case 0x11:
LABEL_27:
      *(_WORD *)(a3 + 24) = a1 + a2 - *(_WORD *)a3;
      goto LABEL_30;
    case 0x2B:
LABEL_28:
      v8 = 8 * (*(unsigned __int8 *)(*(_QWORD *)a3 + 1i64) + 1);
      goto LABEL_29;
  }
  if ( *(_BYTE *)(a3 + 8) != 44 )
  {
    if ( *(_BYTE *)(a3 + 8) == 51 )
    {
      v8 = 4 * *(unsigned __int8 *)(*(_QWORD *)a3 + 1i64) + 2;
LABEL_29:
      *(_WORD *)(a3 + 24) = v8;
      goto LABEL_30;
    }
    if ( *(_BYTE *)(a3 + 8) != 58 )
    {
      if ( *(_BYTE *)(a3 + 8) != 60 )
      {
        if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 172) & 0x20) != 0 && *((_BYTE *)v7 + 169) >= 5u )
          sub_1102C((__int64)v7[19], 0x122u, (__int64)&unk_4DB30, *(unsigned __int8 *)(a3 + 8));
        v5 = 5;
        *(_WORD *)(a3 + 24) = 0;
        goto LABEL_30;
      }
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  *(_WORD *)(a3 + 24) = 8;
LABEL_30:
  *(_WORD *)(a3 + 26) = *(_WORD *)a3 - a1;
  v7 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return v5;
  if ( (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_127D0(*((_QWORD *)off_5F148 + 19), 0x123u, (__int64)&unk_4DB30, *(unsigned __int16 *)(a3 + 24));
    v7 = (void **)off_5F148;
  }
LABEL_39:
  if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 172) & 0x20) != 0 && *((_BYTE *)v7 + 169) >= 5u )
    sub_11008((__int64)v7[19], 0x124u, (__int64)&unk_4DB30);
  return v5;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000004A548) ----------------------------------------------------
__int64 __fastcall sub_4A548(__int64 a1, unsigned __int8 a2, unsigned __int64 *a3)
{
  unsigned int v3; // ebx
  void **v7; // r10
  const char *v8; // rax
  __int64 v9; // r10
  int v10; // eax
  unsigned __int16 v11; // dx
  unsigned __int8 v12; // cl
  unsigned __int64 v13; // rsi
  unsigned __int16 v14; // dx
  __int64 Src; // [rsp+30h] [rbp-48h] BYREF
  char v17[40]; // [rsp+38h] [rbp-40h] BYREF
  unsigned int v18; // [rsp+80h] [rbp+8h] BYREF

  v3 = 0;
  Src = 0i64;
  memset(v17, 0, sizeof(v17));
  v18 = 0;
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x125u, (__int64)&unk_4DB30);
    v7 = (void **)off_5F148;
  }
  if ( !a1 || !a3 )
  {
    if ( v7 == &off_5F148 || (*((_BYTE *)v7 + 172) & 0x20) == 0 || *((_BYTE *)v7 + 169) < 2u )
      goto LABEL_57;
    sub_143A4((__int64)v7[19], 0x126u, (__int64)&unk_4DB30, a1, a3);
    goto LABEL_56;
  }
  if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 172) & 0x20) != 0 && *((_BYTE *)v7 + 169) >= 4u )
  {
    v8 = sub_4ABEC(a2);
    sub_481C8(*(_QWORD *)(v9 + 152), 0x127u, (__int64)&unk_4DB30, a2, v8);
  }
  sub_48D58(a1, &v18);
  v10 = sub_49F2C(a1, v18, (__int64)&Src);
  if ( v10 )
  {
    v7 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148 || (*((_BYTE *)off_5F148 + 172) & 0x20) == 0 || *((_BYTE *)off_5F148 + 169) < 2u )
      goto LABEL_57;
    v11 = 296;
LABEL_16:
    sub_1102C((__int64)v7[19], v11, (__int64)&unk_4DB30, v10);
    goto LABEL_56;
  }
  v12 = v17[0];
  if ( v17[0] == 59 )
  {
LABEL_56:
    v7 = (void **)off_5F148;
    goto LABEL_57;
  }
  v13 = v18 + a1 - 1;
  while ( 1 )
  {
    if ( *a3 >= v13 )
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 3u )
      {
        v14 = 297;
        goto LABEL_38;
      }
      goto LABEL_57;
    }
    if ( a2 == v12 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x12Au, (__int64)&unk_4DB30);
      memmove(a3, &Src, 0x30ui64);
      v7 = (void **)off_5F148;
      goto LABEL_58;
    }
    if ( (v12 > 0x3Cu || v12 != 60 && v12 && (v12 <= 0x2Au || v12 > 0x2Cu && (v12 == 50 || v12 != 51)))
      && v12 != 6
      && v12 != 17
      && v12 != 58 )
    {
      v7 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 3u )
      {
        v14 = 299;
LABEL_38:
        sub_11008((__int64)v7[19], v14, (__int64)&unk_4DB30);
        goto LABEL_56;
      }
      goto LABEL_57;
    }
    v10 = sub_4A0C0(a1, v18, (unsigned __int16 *)&Src);
    if ( v10 )
      break;
    v12 = v17[0];
    if ( v17[0] == 59 )
      goto LABEL_56;
  }
  v7 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
  {
    v11 = 300;
    goto LABEL_16;
  }
LABEL_57:
  v3 = 5;
LABEL_58:
  if ( v7 != &off_5F148 && (*((_BYTE *)v7 + 172) & 0x20) != 0 && *((_BYTE *)v7 + 169) >= 5u )
    sub_11008((__int64)v7[19], 0x12Du, (__int64)&unk_4DB30);
  return v3;
}
// 4A601: variable 'v9' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000004A8A8) ----------------------------------------------------
__int64 __fastcall sub_4A8A8(__int64 a1)
{
  unsigned int v1; // edi
  void **v3; // r10
  const char *v4; // rax
  __int64 v5; // r10
  int v6; // er9

  v1 = 0;
  if ( !a1 )
    return 4;
  v3 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148 )
  {
    if ( (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    {
      sub_11008(*((_QWORD *)off_5F148 + 19), 0x136u, (__int64)&unk_4DB30);
      v3 = (void **)off_5F148;
    }
    if ( v3 != &off_5F148 )
    {
      if ( (*((_BYTE *)v3 + 172) & 0x20) != 0 && *((_BYTE *)v3 + 169) >= 5u )
      {
        sub_17984((__int64)v3[19], 0x137u, (__int64)&unk_4DB30, *(_QWORD *)a1);
        v3 = (void **)off_5F148;
      }
      if ( v3 != &off_5F148 )
      {
        if ( (*((_BYTE *)v3 + 172) & 0x20) != 0 && *((_BYTE *)v3 + 169) >= 5u )
        {
          v4 = sub_4ABEC(*(_BYTE *)(a1 + 8));
          sub_481C8(*(_QWORD *)(v5 + 152), 0x138u, (__int64)&unk_4DB30, v6, v4);
          v3 = (void **)off_5F148;
        }
        if ( v3 != &off_5F148 )
        {
          if ( (*((_BYTE *)v3 + 172) & 0x20) != 0 && *((_BYTE *)v3 + 169) >= 5u )
          {
            sub_1102C((__int64)v3[19], 0x139u, (__int64)&unk_4DB30, *(unsigned __int16 *)(a1 + 24));
            v3 = (void **)off_5F148;
          }
          if ( v3 != &off_5F148 )
          {
            if ( (*((_BYTE *)v3 + 172) & 0x20) != 0 && *((_BYTE *)v3 + 169) >= 5u )
            {
              sub_1102C((__int64)v3[19], 0x13Au, (__int64)&unk_4DB30, *(unsigned __int16 *)(a1 + 26));
              v3 = (void **)off_5F148;
            }
            if ( v3 != &off_5F148 )
            {
              if ( (*((_BYTE *)v3 + 172) & 0x20) != 0 && *((_BYTE *)v3 + 169) >= 5u )
              {
                sub_17984((__int64)v3[19], 0x13Bu, (__int64)&unk_4DB30, *(_QWORD *)(a1 + 32));
                v3 = (void **)off_5F148;
              }
              if ( v3 != &off_5F148 && (*((_BYTE *)v3 + 172) & 0x20) != 0 && *((_BYTE *)v3 + 169) >= 5u )
                sub_1102C((__int64)v3[19], 0x13Cu, (__int64)&unk_4DB30, *(unsigned __int8 *)(a1 + 40));
            }
          }
        }
      }
    }
  }
  return v1;
}
// 4A97D: variable 'v5' is possibly undefined
// 4A991: variable 'v6' is possibly undefined
// 5F148: using guessed type void *off_5F148;

//----- (000000000004AAA8) ----------------------------------------------------
char __fastcall sub_4AAA8(_BYTE *a1)
{
  char v2; // bl
  _BYTE *v3; // rax
  void **v4; // rcx
  char v6; // [rsp+38h] [rbp+10h] BYREF

  v2 = 0;
  if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x19Au, (__int64)&unk_4DB30);
  v3 = sub_48250(a1, 3);
  if ( v3 )
  {
    sub_49C34((__int64)v3, &v6);
    if ( (v6 & 2) != 0 && (v6 & 0x10) == 0 )
    {
      v4 = (void **)off_5F148;
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
      {
        sub_11008(*((_QWORD *)off_5F148 + 19), 0x19Bu, (__int64)&unk_4DB30);
        v4 = (void **)off_5F148;
      }
      v2 = 1;
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  v4 = (void **)off_5F148;
  if ( off_5F148 == &off_5F148 )
    return v2;
  if ( (*((_BYTE *)off_5F148 + 172) & 0x20) != 0 && *((_BYTE *)off_5F148 + 169) >= 4u )
  {
    sub_11008(*((_QWORD *)off_5F148 + 19), 0x19Cu, (__int64)&unk_4DB30);
LABEL_17:
    v4 = (void **)off_5F148;
  }
LABEL_18:
  if ( v4 != &off_5F148 && (*((_BYTE *)v4 + 172) & 0x20) != 0 && *((_BYTE *)v4 + 169) >= 5u )
    sub_11008((__int64)v4[19], 0x19Du, (__int64)&unk_4DB30);
  return v2;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000004ABEC) ----------------------------------------------------
const char *__fastcall sub_4ABEC(unsigned __int8 a1)
{
  if ( a1 <= 0x3Au )
  {
    switch ( a1 )
    {
      case 0x3Au:
        return "IPv6_ICMPV6_HEADER";
      case 0u:
        return "IPv6_HOP_BY_HOP_HEADER";
      case 4u:
        return "IPv6_IPV4_OVER_IPV6";
      case 6u:
        return "IPv6_TCP_HEADER";
      case 0x11u:
        return "IPv6_UDP_HEADER";
      case 0x2Bu:
        return "IPv6_ROUTING_HEADER";
      case 0x2Cu:
        return "IPv6_FRAGMENT_HEADER";
      case 0x32u:
        return "IPv6_IPSEC_ESP_HEADER";
      case 0x33u:
        return "IPv6_AH_HEADER";
    }
    return "UNKNOWN";
  }
  switch ( a1 )
  {
    case 0x3Bu:
      return "IPv6_NO_NEXT_HEADER";
    case 0x3Cu:
      return "IPv6_DESTINATION_OPTIONS_HEADER";
    case 0x87u:
      return "IPv6_MOBILITY_HEADER";
    case 0x8Bu:
      return "IPv6_HOST_IDENTITY_HEADER";
    case 0x8Cu:
      return "IPv6_SHIM6_HEADER";
    case 0xFDu:
      return "IPv6_EXPERIMENT_TESTING_1";
    case 0xFEu:
      return "IPv6_EXPERIMENT_TESTING_2";
  }
  if ( a1 != 255 )
    return "UNKNOWN";
  return "IPv6_HEADER";
}

//----- (000000000004ACDC) ----------------------------------------------------
__int64 __fastcall sub_4ACDC(WCHAR *a1, __int16 a2, __int64 a3, ULONG *a4)
{
  unsigned int v4; // ebx
  void **v5; // rcx
  unsigned __int16 v6; // dx
  int v7; // eax
  int v8; // edi
  UNICODE_STRING String; // [rsp+20h] [rbp-18h] BYREF

  v4 = 0;
  if ( !a1 )
  {
    v5 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 43, 0x10u)
      || *((_BYTE *)off_5F148 + 169) < 2u )
    {
      goto LABEL_12;
    }
    v6 = 12;
    goto LABEL_11;
  }
  if ( !a4 )
  {
    v5 = (void **)off_5F148;
    if ( off_5F148 == &off_5F148
      || !_bittest((const signed __int32 *)off_5F148 + 43, 0x10u)
      || *((_BYTE *)off_5F148 + 169) < 2u )
    {
      goto LABEL_12;
    }
    v6 = 13;
LABEL_11:
    sub_11008((__int64)v5[19], v6, (__int64)&unk_4DB20);
    v5 = (void **)off_5F148;
    goto LABEL_12;
  }
  String.Buffer = a1;
  String.MaximumLength = 2 * a2;
  String.Length = 2 * a2;
  *(_QWORD *)a4 = 0i64;
  v7 = RtlHashUnicodeString(&String, 1u, 0, a4);
  v8 = v7;
  if ( v7 >= 0 )
  {
    v5 = (void **)off_5F148;
    goto LABEL_32;
  }
  v5 = (void **)off_5F148;
  if ( off_5F148 != &off_5F148
    && _bittest((const signed __int32 *)off_5F148 + 43, 0x10u)
    && *((_BYTE *)off_5F148 + 169) >= 2u )
  {
    sub_1102C(*((_QWORD *)off_5F148 + 19), 0xEu, (__int64)&unk_4DB20, v7);
    v5 = (void **)off_5F148;
  }
  if ( _bittest(&v8, 0x1Du) )
  {
    v4 = (unsigned __int16)v8;
    goto LABEL_32;
  }
  if ( (v8 & 0xC0000000) == 0 )
    goto LABEL_32;
  if ( v8 != -1073741811 )
  {
    if ( v8 != -1073741801 )
    {
      if ( v8 == -1073741776 )
        goto LABEL_12;
      if ( v8 != -1073741670 )
      {
        if ( v8 > -1073741586 )
        {
          if ( v8 <= -1073741574 )
            goto LABEL_12;
          if ( v8 == -1073741275 )
          {
            v4 = 5;
            goto LABEL_32;
          }
        }
        v4 = 1;
        goto LABEL_32;
      }
    }
    v4 = 3;
    goto LABEL_32;
  }
LABEL_12:
  v4 = 4;
LABEL_32:
  if ( v5 != &off_5F148 && _bittest((const signed __int32 *)v5 + 43, 0x10u) && *((_BYTE *)v5 + 169) >= 5u )
    sub_1102C((__int64)v5[19], 0xFu, (__int64)&unk_4DB20, v4);
  return v4;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000004AE98) ----------------------------------------------------
void __fastcall sub_4AE98(__int64 a1)
{
  void *v1; // rbx

  if ( a1 )
  {
    v1 = *(void **)(a1 + 56);
    *(_DWORD *)(a1 + 68) = 0;
    if ( v1 )
    {
      if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 0x20) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
        sub_26384(*((_QWORD *)off_5F148 + 11), 0x1Eu);
      sub_27D0C(v1);
    }
  }
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000004AF10) ----------------------------------------------------
char __fastcall sub_4AF10(PFAST_MUTEX FastMutex)
{
  void *v3; // rbx

  if ( !FastMutex )
    return 0;
  if ( LOBYTE(FastMutex[1].Contention) )
  {
    sub_27200(FastMutex);
    LOBYTE(FastMutex[1].Contention) = 0;
    sub_272CC(FastMutex);
    v3 = *(void **)&FastMutex[1].Count;
    if ( off_5F148 != &off_5F148 && (*((_BYTE *)off_5F148 + 108) & 0x20) != 0 && *((_BYTE *)off_5F148 + 105) >= 4u )
      sub_26384(*((_QWORD *)off_5F148 + 11), 0x32u);
    sub_28B00(v3);
  }
  return 1;
}
// 5F148: using guessed type void *off_5F148;

//----- (000000000004AFB8) ----------------------------------------------------
char __fastcall sub_4AFB8(PFAST_MUTEX FastMutex)
{
  char v1; // di
  struct _KEVENT *v4; // rcx

  v1 = 0;
  if ( !FastMutex )
    return 0;
  sub_27200(FastMutex);
  if ( LOBYTE(FastMutex[1].Contention) )
  {
    v4 = *(struct _KEVENT **)&FastMutex[1].Count;
    ++LODWORD(FastMutex[1].Owner);
    sub_27054(v4);
    v1 = 1;
  }
  sub_272CC(FastMutex);
  return v1;
}

//----- (000000000004B020) ----------------------------------------------------
char __fastcall sub_4B020(PFAST_MUTEX FastMutex)
{
  if ( !FastMutex || !*(_QWORD *)&FastMutex[1].Count || !LODWORD(FastMutex[1].Owner) )
    return 0;
  sub_27200(FastMutex);
  if ( LODWORD(FastMutex[1].Owner)-- == 1 )
    sub_26FEC(*(PRKEVENT *)&FastMutex[1].Count);
  sub_272CC(FastMutex);
  return 1;
}

//----- (000000000004B084) ----------------------------------------------------
__int64 __fastcall sub_4B084(_QWORD *a1, _QWORD *a2)
{
  char *v4; // rbx
  NTSTATUS v6; // edi
  IRP *v7; // rax
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+50h] [rbp-58h] BYREF
  _UNICODE_STRING DestinationString; // [rsp+60h] [rbp-48h] BYREF
  struct _KEVENT Event; // [rsp+70h] [rbp-38h] BYREF

  IoStatusBlock.Pointer = 0i64;
  Event.Header.Type = 0;
  IoStatusBlock.Information = 0i64;
  *(_OWORD *)((char *)&Event.Header.Lock + 1) = 0ui64;
  *(_DWORD *)((char *)&Event.Header.WaitListHead.Blink + 1) = 0;
  *(_WORD *)((char *)&Event.Header.WaitListHead.Blink + 5) = 0;
  HIBYTE(Event.Header.WaitListHead.Blink) = 0;
  v4 = (char *)sub_26404(2, 0x18u, 0x41434E50u);
  if ( !v4 )
    return 1793i64;
  *(_QWORD *)v4 = 0i64;
  *((_QWORD *)v4 + 1) = 0i64;
  *((_QWORD *)v4 + 2) = 0i64;
  KeInitializeEvent(&Event, SynchronizationEvent, 0);
  RtlInitUnicodeString(&DestinationString, L"\\Device\\NANO\\KNC");
  v6 = IoGetDeviceObjectPointer(&DestinationString, 0x10000000u, (PFILE_OBJECT *)v4, (PDEVICE_OBJECT *)v4 + 1);
  if ( v6
    || (v7 = IoBuildDeviceIoControlRequest(
               0x8BC82004,
               *((PDEVICE_OBJECT *)v4 + 1),
               0i64,
               0,
               v4 + 16,
               8u,
               0,
               &Event,
               &IoStatusBlock),
        (v6 = IofCallDriver(*((PDEVICE_OBJECT *)v4 + 1), v7)) != 0) )
  {
    if ( *(_QWORD *)v4 )
      ObfDereferenceObject(*(PVOID *)v4);
    sub_26488(v4, 0x41434E50u);
    v4 = 0i64;
  }
  else
  {
    *a2 = *((_QWORD *)v4 + 2);
  }
  KeClearEvent(&Event);
  *a1 = v4;
  return v6 != 0 ? 0xE8700002 : 0;
}

//----- (000000000004B208) ----------------------------------------------------
void __fastcall sub_4B208(PVOID P)
{
  PVOID *v1; // rdi

  if ( P )
  {
    v1 = (PVOID *)*((_QWORD *)P + 6);
    *(_BYTE *)P = 0;
    if ( v1 )
    {
      if ( *v1 )
        ObfDereferenceObject(*v1);
      sub_26488(v1, 0x41434E50u);
    }
    sub_26488(P, 0x41434E50u);
  }
}

//----- (000000000004B278) ----------------------------------------------------
__int64 __fastcall sub_4B278(__int64 a1, __int64 a2)
{
  if ( !a1 )
    return 1799i64;
  if ( a2 )
    return (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD, char, _QWORD))(*(_QWORD *)(a1 + 24) + 16i64))(
             **(_QWORD **)(a1 + 24),
             a2,
             0i64,
             0i64,
             1,
             0i64);
  return 1796i64;
}

//----- (000000000004B2BC) ----------------------------------------------------
__int64 __fastcall sub_4B2BC(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, void *Src)
{
  size_t v5; // rbx
  unsigned int v6; // er12
  PVOID v10; // rax
  void *v11; // r13
  unsigned int v12; // ebx

  v5 = a4;
  v6 = a3;
  if ( !a1 )
    return 1799i64;
  if ( !a2 )
    return 1796i64;
  if ( !a4 || !Src )
    return (unsigned int)(*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD, _QWORD))(*(_QWORD *)(a1 + 24)
                                                                                             + 24i64))(
                           **(_QWORD **)(a1 + 24),
                           a2,
                           a3,
                           0i64,
                           0i64);
  v10 = sub_26404(2, a4, 0x41434E50u);
  v11 = v10;
  if ( !v10 )
    return 1793;
  memmove(v10, Src, v5);
  v12 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD, void *, _DWORD))(*(_QWORD *)(a1 + 24) + 24i64))(
          **(_QWORD **)(a1 + 24),
          a2,
          v6,
          (unsigned int)v5,
          v11,
          0);
  sub_26488(v11, 0x41434E50u);
  return v12;
}

//----- (000000000004B434) ----------------------------------------------------
__int64 __fastcall sub_4B434(char *a1, unsigned __int64 a2, CHAR *a3, __int64 a4)
{
  __int64 result; // rax

  if ( !a1 || !a2 || !a3 )
    goto LABEL_6;
  result = sub_4BFC0(a1, a2, a3, a4);
  if ( (int)result >= 0 )
    return result;
  *a1 = 0;
  if ( (_DWORD)result == -2 )
LABEL_6:
    nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
  return 0xFFFFFFFFi64;
}
// 4C12C: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000004B484) ----------------------------------------------------
__int64 sub_4B484(char *a1, unsigned __int64 a2, CHAR *a3, ...)
{
  va_list va; // [rsp+48h] [rbp+20h] BYREF

  va_start(va, a3);
  return sub_4B434(a1, a2, a3, (__int64)va);
}

//----- (000000000004B4A8) ----------------------------------------------------
__int64 __fastcall sub_4B4A8(void *a1, size_t a2, const void *a3, size_t a4)
{
  unsigned int v8; // ebx

  if ( !a4 )
    return 0i64;
  if ( !a1 )
  {
    nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
    return 22i64;
  }
  if ( a3 && a2 >= a4 )
  {
    memmove(a1, a3, a4);
    return 0i64;
  }
  memset(a1, 0, a2);
  if ( a3 )
  {
    if ( a2 >= a4 )
      return 22i64;
    v8 = 34;
  }
  else
  {
    v8 = 22;
  }
  nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
  return v8;
}
// 4C12C: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000004B54C) ----------------------------------------------------
__int64 __fastcall sub_4B54C(_WORD *a1, __int64 a2, __int16 *a3)
{
  _WORD *v3; // r9
  unsigned int v4; // ebx
  __int16 v5; // ax
  __int64 result; // rax

  v3 = a1;
  if ( a1 && a2 )
  {
    if ( !a3 )
    {
      v4 = 22;
LABEL_9:
      *v3 = 0;
      nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
      return v4;
    }
    do
    {
      v5 = *a3++;
      *a1++ = v5;
      if ( !v5 )
        break;
      --a2;
    }
    while ( a2 );
    if ( !a2 )
    {
      v4 = 34;
      goto LABEL_9;
    }
    result = 0i64;
  }
  else
  {
    nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
    result = 22i64;
  }
  return result;
}
// 4C12C: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000004B680) ----------------------------------------------------
__int64 __fastcall sub_4B680(_BYTE *a1, int a2, __int64 a3, _DWORD *a4)
{
  int v6; // ebx
  _BYTE *v7; // rbp
  __int64 result; // rax

  v6 = a2;
  v7 = a1;
  if ( (*(_BYTE *)(a3 + 24) & 0x40) == 0 || *(_QWORD *)(a3 + 16) )
  {
    if ( a2 > 0 )
    {
      do
      {
        LOBYTE(a1) = *v7;
        --v6;
        result = write_char(a1, a3, a4);
        ++v7;
      }
      while ( *a4 != -1 && v6 > 0 );
    }
  }
  else
  {
    *a4 += a2;
  }
  return result;
}
// 4B6C1: variable 'a1' is possibly undefined
// 4B5D8: using guessed type __int64 __fastcall write_char(_QWORD, _QWORD, _QWORD);

//----- (000000000004B6F0) ----------------------------------------------------
__int64 __fastcall sub_4B6F0(__int64 a1, CHAR *a2, __int64 a3)
{
  int *v3; // r9
  __int64 v5; // r13
  int v6; // esi
  int v7; // er11
  int v8; // edx
  int v9; // er10
  int v10; // er8
  CHAR v12; // di
  int v13; // er14
  int v14; // er12
  CHAR *v15; // rbx
  int v16; // ecx
  __int64 v17; // rcx
  int v18; // eax
  char *i; // rcx
  __int64 v20; // r9
  int v21; // er8
  int v22; // eax
  _BYTE *j; // rcx
  __int64 v24; // rdi
  __int64 v25; // r9
  unsigned int v26; // er15
  char v27; // r13
  CHAR *v28; // rbx
  unsigned __int64 v29; // rdx
  CHAR v30; // al
  int v31; // esp
  int v32; // eax
  __int64 v33; // rdi
  unsigned int v34; // er13
  __int64 v35; // rcx
  WCHAR *v36; // rbp
  int v37; // er12
  int v38; // edi
  __int64 v39; // rcx
  int v40; // eax
  CHAR v41; // al
  __int64 v42; // rcx
  int v43; // [rsp+30h] [rbp-298h]
  unsigned int v44; // [rsp+34h] [rbp-294h] BYREF
  char v45[4]; // [rsp+38h] [rbp-290h] BYREF
  int v46; // [rsp+3Ch] [rbp-28Ch]
  int v47; // [rsp+40h] [rbp-288h]
  int v48; // [rsp+44h] [rbp-284h]
  WCHAR UnicodeString; // [rsp+48h] [rbp-280h] BYREF
  int v50; // [rsp+50h] [rbp-278h]
  int *v51; // [rsp+58h] [rbp-270h]
  __int64 v52; // [rsp+60h] [rbp-268h]
  int v53; // [rsp+68h] [rbp-260h]
  int v54; // [rsp+6Ch] [rbp-25Ch]
  ULONG BytesInMultiByteString; // [rsp+70h] [rbp-258h] BYREF
  ULONG v56; // [rsp+74h] [rbp-254h] BYREF
  CHAR *v57; // [rsp+78h] [rbp-250h]
  CHAR MultiByteString[512]; // [rsp+80h] [rbp-248h] BYREF
  CHAR v59[4]; // [rsp+280h] [rbp-48h] BYREF
  __int16 v60; // [rsp+284h] [rbp-44h]

  v3 = (int *)a3;
  v51 = (int *)a3;
  v5 = a1;
  v52 = a1;
  v53 = 0;
  v6 = 0;
  v7 = 0;
  v47 = 0;
  v8 = 0;
  v43 = 0;
  v9 = 0;
  v46 = 0;
  v10 = 0;
  v48 = 0;
  v50 = 0;
  if ( !a1 || !a2 )
  {
    nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
    return 0xFFFFFFFFi64;
  }
  v12 = *a2;
  v44 = 0;
  v13 = 0;
  v14 = 0;
  if ( !v12 )
    return v44;
  v15 = v57;
  while ( 1 )
  {
    v57 = ++a2;
    if ( (v44 & 0x80000000) != 0 )
      break;
    if ( (unsigned __int8)(v12 - 32) > 0x58u )
      v16 = 0;
    else
      v16 = byte_4D200[v12 - 32] & 0xF;
    v14 = byte_4D200[9 * v16 + v14] >> 4;
    v54 = v14;
    switch ( v14 )
    {
      case 8:
        goto LABEL_192;
      case 0:
        v42 = 0i64;
        goto LABEL_187;
      case 1:
        v8 = -1;
        v10 = 0;
        v48 = 0;
        v7 = 0;
        v47 = 0;
        v9 = 0;
        v46 = 0;
        v6 = 0;
        v43 = -1;
        v50 = 0;
        break;
      case 2:
        switch ( v12 )
        {
          case ' ':
            v6 |= 2u;
            break;
          case '#':
            v6 |= 0x80u;
            break;
          case '+':
            v6 |= 1u;
            break;
          case '-':
            v6 |= 4u;
            break;
          case '0':
            v6 |= 8u;
            break;
        }
        break;
      case 3:
        if ( v12 == 42 )
        {
          v7 = *v3;
          v51 = v3 + 2;
          v47 = v7;
          if ( v7 >= 0 )
            break;
          v6 |= 4u;
          v7 = -v7;
        }
        else
        {
          v7 = v12 + 10 * v7 - 48;
        }
        v47 = v7;
        break;
      case 4:
        v8 = 0;
LABEL_169:
        v43 = v8;
        break;
      case 5:
        if ( v12 == 42 )
        {
          v8 = *v3;
          v51 = v3 + 2;
          v43 = v8;
          if ( v8 >= 0 )
            break;
          v8 = -1;
        }
        else
        {
          v8 = v12 + 10 * v8 - 48;
        }
        goto LABEL_169;
      case 6:
        switch ( v12 )
        {
          case 'I':
            v41 = *a2;
            v6 |= 0x8000u;
            if ( *a2 == 54 && a2[1] == 52 )
            {
              a2 += 2;
              v6 |= 0x8000u;
              goto LABEL_190;
            }
            if ( v41 == 51 && a2[1] == 50 )
            {
              a2 += 2;
              v6 &= 0xFFFF7FFF;
              goto LABEL_190;
            }
            if ( v41 != 100 && v41 != 105 && v41 != 111 && v41 != 117 && v41 != 120 && v41 != 88 )
            {
              v42 = 0i64;
              v14 = 0;
LABEL_187:
              v50 = 0;
              LOBYTE(v42) = v12;
              write_char(v42, v5, &v44);
              goto LABEL_188;
            }
            break;
          case 'h':
            v6 |= 0x20u;
            break;
          case 'l':
            if ( *a2 == 108 )
            {
              ++a2;
              v6 |= 0x1000u;
            }
            else
            {
              v6 |= 0x10u;
            }
            break;
          case 'w':
            v6 |= 0x800u;
            break;
        }
        break;
      case 7:
        if ( v12 > 105 )
        {
          switch ( v12 )
          {
            case 'n':
              goto LABEL_192;
            case 'o':
              v21 = 8;
              if ( (v6 & 0x80u) != 0 )
                v6 |= 0x200u;
              goto LABEL_83;
            case 'p':
              v43 = 16;
              v6 |= 0x8000u;
              goto LABEL_78;
          }
          if ( v12 != 115 )
          {
            v17 = (unsigned int)(v12 - 117);
            if ( v12 == 117 )
              goto LABEL_57;
            if ( v12 != 120 )
              goto LABEL_27;
            v22 = 39;
            goto LABEL_79;
          }
        }
        else
        {
          if ( v12 == 105 )
            goto LABEL_56;
          v17 = (unsigned int)(v12 - 67);
          if ( v12 == 67 )
          {
            if ( (v6 & 0x830) == 0 )
              v6 |= 0x800u;
            goto LABEL_50;
          }
          if ( v12 != 83 )
          {
            if ( v12 != 88 )
            {
              if ( v12 == 90 )
              {
                v17 = *(_QWORD *)v3;
                v51 = v3 + 2;
                if ( v17 && (v15 = *(CHAR **)(v17 + 8)) != 0i64 )
                {
                  if ( *(_WORD *)(v17 + 2) < *(_WORD *)v17 )
                    goto LABEL_192;
                  v13 = *(unsigned __int16 *)v17;
                  if ( _bittest(&v6, 0xBu) )
                  {
                    if ( (v13 & 1) != 0 || ((unsigned __int8)v15 & 1) != 0 )
                      goto LABEL_192;
                    v13 = *(unsigned __int16 *)v17 >> 1;
                    v50 = 1;
                  }
                  else
                  {
                    v50 = 0;
                  }
                }
                else
                {
                  v15 = off_5F110;
                  v17 = strlen(off_5F110) + 1;
                  v13 = v17 - 1;
                }
                goto LABEL_27;
              }
              v17 = (unsigned int)(v12 - 99);
              if ( v12 != 99 )
              {
                if ( v12 != 100 )
                  goto LABEL_27;
LABEL_56:
                v6 |= 0x40u;
LABEL_57:
                v21 = 10;
LABEL_83:
                if ( _bittest(&v6, 0xFu) || _bittest(&v6, 0xCu) )
                {
                  v24 = *(_QWORD *)v3;
                  v25 = (__int64)(v3 + 2);
                }
                else
                {
                  v25 = (__int64)(v3 + 2);
                  if ( (v6 & 0x20) != 0 )
                  {
                    v51 = (int *)v25;
                    if ( (v6 & 0x40) != 0 )
                      v24 = *(__int16 *)(v25 - 8);
                    else
                      v24 = *(unsigned __int16 *)(v25 - 8);
LABEL_94:
                    if ( (v6 & 0x40) != 0 && v24 < 0 )
                    {
                      v24 = -v24;
                      v6 |= 0x100u;
                    }
                    if ( !_bittest(&v6, 0xFu) && !_bittest(&v6, 0xCu) )
                      v24 = (unsigned int)v24;
                    v26 = v43;
                    if ( v43 >= 0 )
                    {
                      v6 &= 0xFFFFFFF7;
                      if ( v43 > 512 )
                        v26 = 512;
                    }
                    else
                    {
                      v26 = 1;
                    }
                    v27 = v53;
                    v28 = &MultiByteString[511];
                    v9 &= -(v24 != 0);
                    v46 = v9;
                    while ( 1 )
                    {
                      v17 = v26--;
                      if ( (int)v17 <= 0 && !v24 )
                        break;
                      v29 = v24 % (unsigned __int64)v21;
                      v24 /= (unsigned __int64)v21;
                      v30 = v29 + 48;
                      if ( (int)v29 + 48 > 57 )
                        v30 += v27;
                      *v28-- = v30;
                    }
                    v5 = v52;
                    v43 = v26;
                    v32 = v31 + 639 - (_DWORD)v28;
                    v15 = v28 + 1;
                    v13 = v32;
                    if ( _bittest(&v6, 9u) && (!v32 || *v15 != 48) )
                    {
                      --v15;
                      v13 = v32 + 1;
                      *v15 = 48;
                    }
                    v10 = v48;
LABEL_27:
                    if ( !v10 )
                    {
                      if ( (v6 & 0x40) != 0 )
                      {
                        if ( _bittest(&v6, 8u) )
                        {
                          v45[0] = 45;
                          goto LABEL_119;
                        }
                        if ( (v6 & 1) != 0 )
                        {
                          v45[0] = 43;
                          goto LABEL_119;
                        }
                        if ( (v6 & 2) != 0 )
                        {
                          v45[0] = 32;
LABEL_119:
                          v9 = 1;
                          v46 = 1;
                        }
                      }
                      v33 = v52;
                      v34 = v7 - v13 - v9;
                      if ( (v6 & 0xC) == 0 )
                      {
                        LOBYTE(v17) = 32;
                        write_multi_char(v17, v34, v52, &v44);
                        v9 = v46;
                      }
                      sub_4B680(v45, v9, v33, &v44);
                      if ( (v6 & 8) != 0 && (v6 & 4) == 0 )
                      {
                        LOBYTE(v35) = 48;
                        write_multi_char(v35, v34, v33, &v44);
                      }
                      if ( v50 && v13 > 0 )
                      {
                        v36 = (WCHAR *)v15;
                        v37 = v13;
                        while ( 1 )
                        {
                          --v37;
                          UnicodeString = *v36;
                          v38 = -1;
                          if ( RtlUnicodeToMultiByteN(v59, 6u, &v56, &UnicodeString, 2u) >= 0 )
                          {
                            v38 = v56;
                            v40 = 0;
                          }
                          else
                          {
                            *(_DWORD *)v59 = 0;
                            v60 = 0;
                            v40 = 42;
                          }
                          ++v36;
                          if ( v40 || !v38 )
                            break;
                          sub_4B680(v59, v38, v52, &v44);
                          if ( !v37 )
                            goto LABEL_136;
                        }
                        v44 = -1;
LABEL_136:
                        a2 = v57;
                        v14 = v54;
                        v33 = v52;
                      }
                      else
                      {
                        sub_4B680(v15, v13, v33, &v44);
                      }
                      if ( (v44 & 0x80000000) == 0 && (v6 & 4) != 0 )
                      {
                        LOBYTE(v39) = 32;
                        write_multi_char(v39, v34, v33, &v44);
                      }
                      v5 = v52;
LABEL_188:
                      v10 = v48;
                      v7 = v47;
                      v9 = v46;
                    }
                    v8 = v43;
                    break;
                  }
                  if ( (v6 & 0x40) != 0 )
                    v24 = *(int *)(v25 - 8);
                  else
                    v24 = *(unsigned int *)(v25 - 8);
                }
                v51 = (int *)v25;
                goto LABEL_94;
              }
LABEL_50:
              v20 = (__int64)(v3 + 2);
              v51 = (int *)v20;
              if ( (v6 & 0x810) != 0 )
              {
                UnicodeString = *(_WORD *)(v20 - 8);
                v13 = -1;
                if ( RtlUnicodeToMultiByteN(MultiByteString, 0x200u, &BytesInMultiByteString, &UnicodeString, 2u) >= 0 )
                {
                  v13 = BytesInMultiByteString;
                  v9 = v46;
                  v7 = v47;
                  v10 = v48;
                }
                else
                {
                  memset(MultiByteString, 0, sizeof(MultiByteString));
                  v9 = v46;
                  v7 = v47;
                  v10 = 1;
                  v48 = 1;
                }
              }
              else
              {
                v13 = 1;
                MultiByteString[0] = *(_BYTE *)(v20 - 8);
              }
              v15 = MultiByteString;
              goto LABEL_27;
            }
LABEL_78:
            v22 = 7;
LABEL_79:
            v53 = v22;
            v21 = 16;
            if ( (v6 & 0x80u) != 0 )
            {
              v45[0] = 48;
              v9 = 2;
              v45[1] = v22 + 81;
            }
            goto LABEL_83;
          }
          if ( (v6 & 0x830) == 0 )
            v6 |= 0x800u;
        }
        v15 = *(CHAR **)v3;
        v18 = v8;
        if ( v8 == -1 )
          v18 = 0x7FFFFFFF;
        v51 = v3 + 2;
        if ( (v6 & 0x810) != 0 )
        {
          v50 = 1;
          if ( !v15 )
            v15 = (CHAR *)off_5F118;
          for ( i = v15; v18; i += 2 )
          {
            --v18;
            if ( !*(_WORD *)i )
              break;
          }
          v17 = (i - v15) >> 1;
        }
        else
        {
          if ( !v15 )
            v15 = off_5F110;
          for ( j = v15; v18; ++j )
          {
            --v18;
            if ( !*j )
              break;
          }
          v17 = (unsigned int)((_DWORD)j - (_DWORD)v15);
        }
        v13 = v17;
        goto LABEL_27;
      default:
        break;
    }
LABEL_190:
    v12 = *a2;
    if ( !*a2 )
      break;
    v3 = v51;
  }
  if ( v14 && v14 != 7 )
  {
LABEL_192:
    nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
    return 0xFFFFFFFFi64;
  }
  return v44;
}
// 4BBD1: variable 'v31' is possibly undefined
// 4BC53: variable 'v17' is possibly undefined
// 4BC8B: variable 'v35' is possibly undefined
// 4BD76: variable 'v39' is possibly undefined
// 4B5D8: using guessed type __int64 __fastcall write_char(_QWORD, _QWORD, _QWORD);
// 4B628: using guessed type __int64 __fastcall write_multi_char(_QWORD, _QWORD, _QWORD, _QWORD);
// 4C12C: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 5F110: using guessed type char *off_5F110;
// 5F118: using guessed type wchar_t *off_5F118;

//----- (000000000004BFC0) ----------------------------------------------------
__int64 __fastcall sub_4BFC0(char *a1, unsigned __int64 a2, CHAR *a3, __int64 a4)
{
  __int64 result; // rax
  unsigned int v7; // edi
  FILE File; // [rsp+30h] [rbp-38h] BYREF

  if ( a2 == -1i64 )
  {
    File._cnt = 0x7FFFFFFF;
  }
  else
  {
    if ( a2 > 0x7FFFFFFF )
    {
      nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
      return 0xFFFFFFFFi64;
    }
    File._cnt = a2;
  }
  File._base = a1;
  File._ptr = a1;
  File._flag = 66;
  result = sub_4B6F0((__int64)&File, a3, a4);
  v7 = result;
  a1[a2 - 1] = 0;
  if ( (int)result >= 0 )
  {
    if ( --File._cnt < 0 )
    {
      if ( flsbuf(0, &File) == -1 )
        return 4294967294i64;
    }
    else
    {
      *File._ptr = 0;
    }
    return v7;
  }
  if ( File._cnt < 0 )
    return 4294967294i64;
  if ( a1 )
  {
    if ( a2 )
      *a1 = 0;
  }
  return result;
}
// 4C12C: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000065008) ----------------------------------------------------
__int64 __fastcall sub_65008(unsigned __int8 a1, __int64 a2, unsigned int a3, unsigned int *a4, __int64 a5, unsigned int *a6)
{
  unsigned int *v6; // r13
  unsigned int v7; // er10
  __int64 v10; // rbp
  unsigned int v11; // ebx
  __int64 v12; // rax
  unsigned int v13; // ecx
  unsigned int v14; // eax
  const void **v15; // r14
  unsigned int v16; // er12
  unsigned int v17; // esi
  _WORD *v18; // rcx
  __m128i *v19; // rdi
  __int64 v20; // rcx
  __m128i v21; // xmm0
  __int64 v22; // rbx
  bool v23; // zf
  __int64 v25; // [rsp+30h] [rbp-38h]
  char v26; // [rsp+70h] [rbp+8h] BYREF

  v6 = a6;
  v7 = 0;
  *a6 = 0;
  if ( a1 <= 3u )
    return (unsigned int)-1073741808;
  if ( a1 <= 5u )
  {
    v22 = a5;
    if ( a5 )
    {
      if ( a3 < 0x30 )
        return (unsigned int)-1073741811;
      do
      {
        if ( RtlCompareMemory(*(const void **)(v22 + 8), a4 + 6, 0x10ui64) == 16 )
          break;
        v22 = *(_QWORD *)(v22 + 16);
      }
      while ( v22 );
      if ( v22 )
      {
        v7 = 0;
        if ( a1 == 5 )
        {
          *(_DWORD *)(v22 + 44) = 0;
          *(_QWORD *)(v22 + 24) = 0i64;
          *(_BYTE *)(v22 + 41) = 0;
        }
        else
        {
          v23 = dword_5F3D8 == 2;
          v25 = *((_QWORD *)a4 + 1);
          *(_QWORD *)(v22 + 24) = v25;
          if ( v23 )
          {
            if ( !(unsigned int)qword_5F3B0(3i64, &v26, 4i64, &a6, a4) )
              *(_BYTE *)(v22 + 41) = v26;
            v7 = qword_5F3B0(2i64, v22 + 44, 4i64, &a6, a4);
          }
          else
          {
            *(_DWORD *)(v22 + 44) = HIDWORD(v25);
            *(_BYTE *)(v22 + 41) = BYTE2(v25);
          }
        }
        return v7;
      }
    }
    return (unsigned int)-1073741163;
  }
  if ( a1 <= 7u )
    return v7;
  if ( a1 != 8 )
    return (unsigned int)-1073741808;
  v10 = a5;
  v11 = 0;
  v12 = a5;
  if ( dword_5F3D8 == 1 )
  {
    v13 = a4[4];
    if ( v13 > 1 )
    {
      v14 = 32 * v13 + 24;
      if ( v14 <= a3 )
      {
        *(__m128i *)&a4[8 * v13 - 2] = _mm_loadu_si128((const __m128i *)*(_QWORD *)(a5 + 8));
        a4[8 * a4[4] + 2] = 528384;
        *(_DWORD *)(v10 + 44) = 0;
        *(_BYTE *)(v10 + 41) = 0;
        return v7;
      }
      v7 = -1073741789;
      if ( a3 >= 4 )
      {
        *a4 = v14;
LABEL_10:
        *v6 = 4;
        return v7;
      }
      return v7;
    }
  }
  v15 = *(const void ***)(a5 + 32);
  do
  {
    v12 = *(_QWORD *)(v12 + 16);
    ++v11;
  }
  while ( v12 );
  if ( v11 > 0x3F )
    return (unsigned int)-1073741811;
  if ( v15 )
  {
    v16 = 32 * v11 + 24;
    v17 = *(unsigned __int16 *)v15 + v16 + 2;
  }
  else
  {
    v16 = 0;
    v17 = 32 * v11 + 24;
  }
  if ( v17 > a3 )
  {
    v7 = -1073741789;
    if ( a3 < 4 )
      return v7;
    *a4 = v17;
    goto LABEL_10;
  }
  memset(a4, 0, a3);
  *a4 = v17;
  a4[2] = v16;
  a4[4] = v11;
  if ( v15 )
  {
    v18 = (_WORD *)((char *)a4 + v16);
    *v18 = *(_WORD *)v15;
    memmove(v18 + 1, v15[1], *(unsigned __int16 *)v15);
  }
  if ( v11 )
  {
    v19 = (__m128i *)(a4 + 10);
    v20 = v11;
    do
    {
      v21 = _mm_loadu_si128((const __m128i *)*(_QWORD *)(v10 + 8));
      v19->m128i_i32[0] = 528384;
      v19 += 2;
      v19[-3] = v21;
      *(_DWORD *)(v10 + 44) = 0;
      --v20;
      *(_BYTE *)(v10 + 41) = 0;
      v10 = *(_QWORD *)(v10 + 16);
    }
    while ( v20 );
  }
  v7 = 0;
  *v6 = v17;
  return v7;
}
// 5F3B0: using guessed type __int64 (__fastcall *qword_5F3B0)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 5F3D8: using guessed type int dword_5F3D8;

// nfuncs=558 queued=541 decompiled=541 lumina nreq=0 worse=0 better=0
// ALL OK, 541 function(s) have been successfully decompiled
