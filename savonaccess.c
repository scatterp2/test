/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 sub_140001000();
__int64 sub_140001050();
__int64 sub_1400010A0();
__int64 sub_1400010C0();
__int64 sub_140001110();
__int64 sub_140001160();
void sub_1400011B0();
__int64 sub_1400011D0();
void sub_140001220();
void sub_140001240();
__int64 sub_140001260();
__int64 sub_140001290();
__int64 sub_1400012E0();
__int64 sub_140001300();
__int64 sub_140001350();
__int64 sub_140001370();
__int64 sub_1400013C0();
__int64 sub_140001410();
__int64 sub_140001430();
__int64 sub_140001480();
__int64 sub_1400014D0();
__int64 sub_140001530();
__int64 sub_140001580();
__int64 sub_1400015A0();
void sub_1400015D0();
__int64 sub_1400015F0();
__int64 sub_140001640();
__int64 sub_140001690();
__int64 sub_1400016C0();
__int64 sub_1400016F0();
__int64 sub_140001720();
__int64 sub_140001750();
char sub_1400017A0();
__int64 sub_1400017D0();
__int64 sub_140001820();
__int64 sub_140001830();
__int64 sub_140001850();
__int64 sub_1400018A0();
__int64 sub_140001900();
__int64 sub_140001910();
void sub_140001930();
void sub_140001950();
__int64 sub_140001970();
void sub_1400019C0();
_QWORD *__fastcall sub_1400019E0(__int64 a1);
__int64 __fastcall sub_140001A20(__int64 a1, int a2);
__int64 __fastcall sub_140001AEC(__int64 a1);
_QWORD *__fastcall sub_140001AF8(_QWORD *a1, void *a2, __m128i *a3, __int64 a4, __m128i *a5);
void __fastcall sub_140001B98(__int64 a1);
void __fastcall sub_140001C08(__int64 a1);
_QWORD *__fastcall sub_140001C3C(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_140001CEC(__int64 a1, __int64 a2, __int64 a3);
_QWORD *__fastcall sub_140001DC0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
void __fastcall sub_140001E70(__int64 a1);
bool __fastcall sub_140001F64(__int64 a1, __int64 a2, const UNICODE_STRING *a3, __int64 a4, __int64 *a5);
__int64 **__fastcall sub_140001FF4(__int64 a1, unsigned int a2);
void __fastcall sub_140002124(struct _FAST_MUTEX **a1, __int64 a2, int a3, unsigned __int64 a4);
void __fastcall sub_1400021FC(__int64 a1, void *a2, __m128i *a3, __int64 a4, __m128i *a5);
char __fastcall sub_1400022DC(__int64 a1, __int64 a2, unsigned __int64 a3);
void __fastcall sub_1400023A8(__int64 a1, char a2, __int64 a3, struct _FILE_OBJECT *a4, __int64 a5);
void __fastcall sub_14000247C(PFAST_MUTEX *a1, __int64 a2, __m128i *a3, char a4);
char __fastcall sub_1400025E0(PFAST_MUTEX *a1, struct _FILE_OBJECT *a2, __int64 a3);
char __fastcall sub_14000273C(__int64 a1, __int64 a2, const UNICODE_STRING *a3, __int64 a4, __int64 *a5);
void __fastcall sub_140002824(struct _FAST_MUTEX **a1, __int64 a2, int a3, unsigned __int64 a4);
LONG sub_1400028C0();
void __fastcall sub_140002920(__int64 a1);
signed __int64 __fastcall sub_140002990(__int64 a1);
__int64 sub_140002A18();
__int64 sub_140002A68();
void __fastcall sub_140002AB8(PSLIST_ENTRY ListEntry);
void __fastcall sub_140002B1C(PSLIST_ENTRY ListEntry);
void __fastcall sub_140002B80(__int64 a1, int a2, const UNICODE_STRING *a3);
__int64 __fastcall sub_140002C3C(__int64 *a1, _WORD *a2);
_QWORD *__fastcall sub_140002CC0(__int64 a1);
signed __int64 __fastcall sub_140002D20(_WORD *a1, _QWORD **a2);
signed __int64 __fastcall sub_140002DE8(__int64 a1, _QWORD *a2, char a3);
signed __int64 __fastcall sub_140002EAC(__int64 a1, __int64 *a2, char a3);
signed __int64 __fastcall sub_140002F9C(__int64 a1, unsigned __int64 a2);
void **__fastcall sub_14000303C(void **a1, __int64 a2);
void __fastcall sub_1400030CC(__int64 a1, _QWORD *a2, __int64 a3);
void __fastcall sub_140003138(__int64 a1, __int64 *a2, __int64 *a3);
__int64 __fastcall sub_1400031E0(__int64 a1, __int64 a2);
__int64 __fastcall nullsub_1(_QWORD, _QWORD); // weak
void __fastcall sub_140003224(unsigned __int64 a1);
__int64 __fastcall sub_1400032BC(__int64 a1, UNICODE_STRING *a2);
signed __int64 __fastcall sub_14000336C(__int64 a1);
void sub_140003388();
void __fastcall sub_1400033D0(__int64 a1);
void sub_140003434();
void sub_14000347C();
void sub_1400034FC();
__int64 __fastcall sub_140003504(__int64 a1, _WORD *a2);
void __fastcall sub_14000362C(_BYTE *a1);
_QWORD *__fastcall sub_14000366C(__int64 a1);
void __fastcall sub_140003684(__int64 a1);
char __fastcall sub_1400036C0(__int64 a1, __int64 a2, _QWORD *a3);
void __fastcall sub_14000374C(__int64 a1);
void __fastcall sub_14000379C(__int64 a1, unsigned __int64 a2, __int64 a3);
void __fastcall sub_1400038AC(__int64 a1);
void __fastcall sub_1400038F4(__int64 a1, int a2, const UNICODE_STRING *a3);
void __fastcall sub_14000399C(__int64 a1, _WORD *a2);
__int64 __fastcall sub_140003A58(__int64 a1, signed int a2);
char __fastcall sub_140003A74(__int64 a1, unsigned int a2, unsigned int *a3, _DWORD *a4, unsigned int *a5, _DWORD *a6);
__int64 __fastcall sub_140003BE8(_WORD *a1, unsigned __int64 a2, _QWORD *a3);
void __fastcall sub_140003C58(_OWORD *a1, __int64 a2);
void __fastcall sub_140003D28(__int64 a1);
__int64 __fastcall sub_140003D5C(__int64 a1);
char __fastcall sub_140003D6C(__int64 a1, __int64 a2, unsigned int a3);
signed __int64 __fastcall sub_140003E84(_BYTE *a1, __int64 a2, __int64 a3, char a4, __int16 a5, char a6);
unsigned __int64 __fastcall sub_140003F48(__int64 a1, __int64 a2);
void __fastcall sub_140003FFC(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_140004060(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_140004084(UNICODE_STRING *a1, _BYTE *a2, _BYTE *a3, char a4, char a5);
signed __int64 __fastcall sub_1400041D4(__int64 a1, UNICODE_STRING *a2, __int64 a3, __int64 a4, struct _FILE_OBJECT *a5, __int64 a6, char a7, __int64 a8, char a9);
bool sub_1400044D8();
void sub_1400044E8();
char sub_140004500();
LONG __fastcall sub_140004528(char a1);
LONG sub_14000461C();
_QWORD *__fastcall sub_140004650(__int64 a1);
__int64 sub_1400046B4();
void __fastcall sub_140004704(PSLIST_ENTRY ListEntry);
signed __int64 __fastcall sub_140004768(__int64 *a1, __int64 a2);
_QWORD *__fastcall sub_140004810(_QWORD **a1);
_QWORD *__fastcall sub_140004874(__int64 a1, __int64 a2);
char __fastcall sub_1400048EC(__int64 a1);
_QWORD *__fastcall sub_14000495C(__int64 a1, __int64 a2);
void __fastcall sub_1400049CC(_QWORD **a1, _QWORD *a2, __int64 a3, __int64 a4, int a5, int a6);
signed __int64 __fastcall sub_140004A58(__int64 a1);
_QWORD *__fastcall sub_140004A68(__int64 a1);
char sub_140004A78();
_QWORD *__fastcall sub_140004A84(__int64 a1);
__int64 __fastcall sub_140004A94(__int64 a1, __int64 a2, __int64 a3, int a4, char a5);
__int64 sub_140004AD0();
void __fastcall sub_140004B20(PSLIST_ENTRY ListEntry);
PSLIST_ENTRY __fastcall sub_140004B90(PSLIST_ENTRY ListEntry, char a2);
char __fastcall sub_140004BF4(__int64 a1);
char __fastcall sub_140004CF0(_DWORD *a1);
bool __fastcall sub_140004D4C(__int64 a1);
__int64 __fastcall sub_140004DF4(__int64 a1);
_QWORD *__fastcall sub_140004E24(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_140004E44(__int64 a1, _QWORD *a2, __int64 (*a3)(void));
_QWORD *__fastcall sub_140004F54(__int64 a1, _QWORD *a2);
char __fastcall sub_140004F74(_DWORD *a1, int a2);
__int64 __fastcall sub_140004FB8(__int64 a1, __int64 a2, _DWORD *a3);
void __fastcall sub_1400050A8(__int64 a1, __int64 a2, int a3);
char __fastcall sub_140005188(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_1400051C0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400052C8(__int64 a1, __int64 a2, _BYTE *a3, __int64 a4, int a5, _BYTE *a6, char *a7);
LONG __fastcall sub_140005424(unsigned __int8 a1);
void __fastcall sub_1400054F8(__int64 a1, _DWORD *a2, char a3, __int64 a4, __int64 a5, __int64 a6);
char sub_140005550();
__int64 __fastcall sub_140005558(unsigned __int16 *a1, __int64 a2, _DWORD *a3);
__int64 __fastcall sub_1400055E4(int a1, unsigned __int16 *a2, __int64 a3);
char __fastcall sub_14000566C(__int64 a1, int a2, _BYTE *a3, char a4);
int sub_1400056B4();
LONG sub_14000572C();
__m128i *__fastcall sub_14000576C(__m128i *a1);
void __fastcall sub_14000577C(__int64 a1);
__int64 __fastcall sub_1400057A0(PUNICODE_STRING Destination, unsigned __int16 *a2, const WCHAR *a3);
UNICODE_STRING *sub_14000589C();
__int64 __fastcall sub_1400058A4(unsigned __int16 *a1);
PVOID __fastcall sub_1400058C0(__int64 a1, unsigned int a2);
__int64 __fastcall sub_1400058E0(__int64 a1, _QWORD *a2, _QWORD *a3);
void __fastcall sub_140005900(__int64 a1, void *a2);
PVOID __fastcall sub_140005920(__int64 a1, unsigned int a2);
char __fastcall sub_140005940(__int64 a1, unsigned __int64 *a2, __int64 a3);
void __fastcall sub_140005970(__int64 a1, void *a2);
__int64 __fastcall sub_140005984(__int64 a1);
__int64 sub_1400059DC();
signed __int64 __fastcall sub_140005A14(__m128i *a1, __int64 a2, __int64 a3, __int64 *a4, _QWORD *a5);
__int64 __fastcall sub_140005BB8(__m128i *a1, __int64 a2);
signed __int64 __fastcall sub_140005C64(__int16 a1, struct _FILE_OBJECT *a2, __int64 a3, char a4, char a5);
char sub_140005F18();
// void __usercall sub_140005F58(ULONG_PTR BugCheckParameter1@<rcx>, ULONG_PTR BugCheckParameter2@<rdx>, ULONG a3@<r8d>, int a4@<r9d>, __int64 a5, __int64 a6, __int64 a7);
void __fastcall sub_140006084(ULONG_PTR BugCheckParameter1, ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter3, unsigned __int16 *a4, __int64 a5);
// int __usercall sub_140006248@<eax>(ULONG_PTR BugCheckParameter1@<rcx>, ULONG_PTR BugCheckParameter2@<rdx>, ULONG a3@<r8d>, int a4@<r9d>, __int64 a5, __int64 a6, __int64 a7);
__int64 sub_140006350(wchar_t *Dest, __int64 a2, const wchar_t *a3, ...);
void __fastcall sub_1400063C8(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_140006568(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400065D4(__int64 a1);
char __fastcall sub_140006650(__int64 a1);
char __fastcall sub_1400066CC(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_140006784(__int64 a1, __int64 a2, __int64 a3);
PEPROCESS sub_14000682C();
__int64 sub_1400068A4();
char __fastcall sub_1400068EC(__int64 a1, __int64 a2);
void sub_140006968();
__int64 sub_140006B5C();
__int64 sub_140006BAC();
// LONG __usercall sub_140006BB4@<eax>(ULONG_PTR BugCheckParameter1@<rcx>, ULONG_PTR BugCheckParameter2@<rdx>, void *a3@<r8>, ULONG a4@<r9d>, ULONG_PTR BugCheckParameter3, char a6);
signed __int32 __fastcall sub_140006E04(__int64 (*a1)(void));
char sub_140006E84();
char __fastcall sub_140006F08(__m128 *a1, unsigned int a2, const WCHAR *a3);
__int64 __fastcall sub_140007050(__int64 a1, PVOID *a2);
__int64 __fastcall sub_1400071D0(__int64 a1);
__int64 __fastcall sub_140007260(__int64 a1, __int64 a2);
void sub_1400073D8();
void sub_140007468();
char __fastcall sub_14000747C(unsigned __int64 a1);
__int64 __fastcall sub_140007518(unsigned __int64 a1);
void __fastcall sub_14000762C(PSLIST_ENTRY ListEntry);
__int64 __fastcall sub_1400076DC(PUNICODE_STRING Destination, __int64 a2, _QWORD *a3);
char sub_140007A14();
LONG sub_140007A38(__int64 a1, ...);
char sub_140007AF8();
char __fastcall sub_140007B54(__int64 a1, __int64 a2);
char __fastcall sub_140007C84(__int64 a1, __int64 a2);
void __fastcall sub_140007D18(__int64 a1, __int64 a2);
void sub_140007D7C();
NTSTATUS sub_140007E00();
void __fastcall sub_140007FA0(__int64 a1);
__int16 __fastcall sub_1400080E4(struct _DEVICE_OBJECT *a1);
signed __int64 sub_140008290();
char sub_1400083D4();
char sub_14000849C();
BOOLEAN sub_1400084B4();
signed __int64 __fastcall sub_140008610(int a1, _QWORD *a2);
signed __int64 __fastcall sub_1400086E8(const WCHAR *a1, __m128i **a2);
NTSTATUS sub_1400087C0();
void __fastcall sub_140008A38(int a1);
char sub_140008A68();
LONG sub_140008AB8();
bool __fastcall sub_140008B24(__int16 *a1);
signed __int64 __fastcall sub_140008B80(void *a1, __int64 a2);
char __fastcall sub_140008C24(__int64 a1, unsigned int a2, __m128i **a3, _DWORD *a4);
bool __fastcall sub_140008CCC(__int64 a1, unsigned int a2);
bool sub_140008D18();
_BOOL8 __fastcall sub_140008D4C(const UNICODE_STRING *a1);
char __fastcall sub_140008D74(PDEVICE_OBJECT DeviceObject, _DWORD *a2);
char __fastcall sub_140008E54(_QWORD *a1, _QWORD *a2);
char __fastcall sub_140008F5C(void **a1, PVOID *Object);
char __fastcall sub_140008FA0(PDEVICE_OBJECT DeviceObject, _DWORD *a2);
char sub_140009094();
__int64 sub_140009258(void); // weak
char sub_140009260();
char __fastcall sub_1400092F4(unsigned int a1, __m128i *a2, unsigned int a3, _QWORD *a4);
char __fastcall sub_140009418(UNICODE_STRING *a1, const WCHAR *a2, __m128i *a3, unsigned int *a4);
char __fastcall sub_1400095B8(UNICODE_STRING *a1, const WCHAR *a2, _DWORD *a3);
char __fastcall sub_14000972C(UNICODE_STRING *a1, const WCHAR *a2, __int64 a3);
__int64 __fastcall sub_1400098C0(__int64 a1);
__int64 __fastcall sub_140009904(__int64 *a1, _BYTE *a2);
void sub_140009970();
__int64 __fastcall sub_1400099C4(ULONG Count, PVOID Object[], LARGE_INTEGER *a3);
NTSTATUS __fastcall sub_140009B44(PVOID Object);
bool __fastcall sub_140009B74(UNICODE_STRING *a1, const WCHAR *a2, int a3);
__int64 sub_140009C2C();
void __fastcall sub_140009C7C(PSLIST_ENTRY ListEntry);
LONG __fastcall sub_140009CE0(__int64 a1, __int64 a2);
char __fastcall sub_140009D54(__int64 a1, unsigned int a2);
NTSTATUS __fastcall sub_140009EA8(__int64 *a1);
void __fastcall sub_140009F88(__int64 a1);
__int64 __fastcall sub_14000A010(); // weak
char __fastcall sub_14000A018(__int64 a1, __int64 a2);
char sub_14000A064();
char __fastcall sub_14000A06C(unsigned int a1);
void sub_14000A0E4();
__int64 sub_14000A124();
__int64 (*sub_14000A154())(void);
__int64 __fastcall sub_14000A1C4(__int64 a1);
signed __int64 __fastcall sub_14000A1E8(__int64 a1, __m128i *a2, __int64 a3);
void __fastcall sub_14000A248(void **a1);
char __fastcall sub_14000A2A4(_QWORD *a1, WCHAR *a2);
__int64 __fastcall sub_14000A2F0(_WORD *a1, volatile signed __int32 **a2);
void __fastcall sub_14000A43C(HANDLE *a1);
char __fastcall sub_14000A480(__int64 a1);
bool __fastcall sub_14000A524(__int64 a1, _DWORD *a2);
void sub_14000A5A4();
signed __int64 __fastcall sub_14000A5EC(__int64 a1, UNICODE_STRING *a2, _QWORD *a3);
HANDLE *sub_14000A930();
__int64 __fastcall sub_14000AA10(__int64 a1);
bool __fastcall sub_14000AA8C(__int64 a1, int a2);
PVOID __fastcall sub_14000AB04(SIZE_T a1, POOL_TYPE a2);
void __fastcall sub_14000AB20(void *a1);
char *sub_14000AB40();
__int64 __fastcall sub_14000ABA0(int a1, __int64 a2);
int __fastcall sub_14000AC40(int a1, __int64 a2);
__int64 __fastcall sub_14000ACC4(__int64 a1, __int64 a2);
struct _KEVENT *sub_14000AD94();
char sub_14000AD9C();
void sub_14000ADA4();
__int64 __fastcall sub_14000ADBC(char a1);
void __fastcall sub_14000B028(__int64 a1, unsigned int a2);
void __fastcall sub_14000B0FC(__int64 a1);
__int64 __fastcall sub_14000B190(__int64 a1, __int64 a2);
PVOID *__fastcall sub_14000B2FC(PVOID *Object, HANDLE Handle);
LONG_PTR __fastcall sub_14000B368(void **a1);
__int64 __fastcall sub_14000B388(__int64 a1);
void __fastcall sub_14000B480(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14000B81C(__int64 a1);
__int64 __fastcall sub_14000B86C(__int64 a1, __int64 a2, __int64 *a3);
__int64 sub_14000B8C8();
void __fastcall sub_14000B918(PSLIST_ENTRY ListEntry);
__int64 __fastcall sub_14000B97C(__int64 a1, __int64 a2);
void __fastcall sub_14000BA40(__int64 a1, struct _SLIST_ENTRY *a2);
void __fastcall sub_14000BAD8(__int64 **a1, __int64 a2);
void __fastcall sub_14000BB5C(__int64 **a1);
void sub_14000BBAC();
__int64 __fastcall sub_14000BBB4(__int64 a1);
void sub_14000BBD0();
void __fastcall sub_14000BBE4(struct _SLIST_ENTRY *a1);
__int64 __fastcall sub_14000BBF4(__int64 a1);
char __fastcall sub_14000BC00(__int64 a1);
void __fastcall sub_14000BC10(__int64 a1);
__int64 __fastcall sub_14000BC20(__int64 a1);
__int64 __fastcall sub_14000BC90(__int64 a1);
__int64 __fastcall sub_14000BDA0(_QWORD); // weak
__int64 __fastcall sub_14000BDA8(unsigned __int16 *a1, unsigned __int16 *a2, char a3, unsigned int a4);
signed __int64 __fastcall sub_14000C0A4(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_14000C25C(__int64 a1, unsigned int a2);
// __int64 __usercall sub_14000C358@<rax>(unsigned __int16 *a1@<rdx>, unsigned __int16 *a2@<rcx>, unsigned int a3@<r8d>, unsigned int a4@<r9d>, __int64 a5, int a6);
signed __int64 __fastcall sub_14000C598(__int64 a1, unsigned __int16 *a2, __int64 a3, unsigned int a4, void *Address, unsigned int Length, int a7);
__int64 __fastcall sub_14000C794(__int64 a1, __int64 a2, int a3);
__int64 sub_14000C870();
void __fastcall sub_14000C8C0(PSLIST_ENTRY ListEntry);
__int64 sub_14000C924();
void sub_14000C930();
void __fastcall sub_14000C938(__int64 a1, _DWORD *a2);
void __fastcall sub_14000CB40(PSLIST_ENTRY ListEntry);
__int64 __fastcall sub_14000CC3C(__int64 a1, __int64 a2);
char __fastcall sub_14000CCB4(__int64 a1, __int64 a2, _BYTE *a3);
void __fastcall sub_14000CD4C(PSLIST_ENTRY ListEntry);
__int64 __fastcall sub_14000CDB0(struct _SLIST_ENTRY **a1);
_QWORD *__fastcall sub_14000CDE8(struct _SLIST_ENTRY **a1);
__int64 __fastcall sub_14000CE5C(__int64 a1, __int64 a2, _BYTE *a3);
void __fastcall sub_14000CEC0(__int64 a1, __int64 a2, char a3);
__int64 __fastcall sub_14000CFB4(__int64 a1, __int64 a2);
void __fastcall sub_14000CFF4(__int64 a1, PSLIST_ENTRY *a2);
int __fastcall sub_14000D080(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_14000D0CC(__int64 a1, _DWORD *a2, _BYTE *a3, signed __int64 *a4);
__int64 sub_14000D20C();
__int64 __fastcall sub_14000D254(__int64 a1, __int64 a2);
char __fastcall sub_14000D29C(__int64 a1);
__int64 __fastcall sub_14000D340(int a1, int a2);
NTSTATUS __fastcall sub_14000D454(ULONG IoControlCode, PDEVICE_OBJECT DeviceObject, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);
// __int64 __usercall sub_14000D540@<rax>(ULONG IoControlCode@<ecx>, const WCHAR *a2@<rdx>, unsigned int a3@<r8d>, ULONG a4@<r9d>, PVOID InputBuffer, ULONG InputBufferLength, __int64 a7, PVOID a8, __int64 a9);
__int64 __fastcall sub_14000D680(HANDLE *a1, UNICODE_STRING *a2);
signed __int64 __fastcall sub_14000D884(__int64 a1, __int64 a2, _QWORD *a3);
char __fastcall sub_14000D9D0(PCUNICODE_STRING String1, WCHAR *a2);
__int64 __fastcall sub_14000DB1C(_WORD *a1, _QWORD *a2);
void __fastcall sub_14000DF38(_QWORD *a1);
_QWORD *__fastcall sub_14000DFBC(_QWORD *a1, __int64 *a2);
void **__fastcall sub_14000DFF8(void **a1, __int64 a2);
_QWORD *__fastcall sub_14000E024(_QWORD *a1);
void __fastcall sub_14000E034(void **a1);
__int64 *__fastcall sub_14000E054(__int64 *a1, __int64 *a2);
char __fastcall sub_14000E09C(__int64 *a1, __int64 *a2);
__int64 __fastcall sub_14000E0E8(_QWORD *a1);
void *__fastcall sub_14000E138(__int64 a1);
bool __fastcall sub_14000E1E0(_QWORD *a1);
void __fastcall sub_14000E1E8(HANDLE *a1);
PVOID __fastcall sub_14000E268(SIZE_T a1);
char __fastcall sub_14000E284(HANDLE *a1, void (__stdcall *a2)(PVOID StartContext), void *a3);
__int64 __fastcall sub_14000E308(int a1, __int64 a2);
int *sub_14000E3B0();
int __fastcall sub_14000E410(int a1);
__int64 sub_14000E494();
bool sub_14000E4A4();
NTSTATUS sub_14000E4D0();
// char __usercall sub_14000E514@<al>(ULONG Tag@<ecx>, PUNICODE_STRING DestinationString@<rdx>, unsigned __int16 *a3@<r8>, unsigned int a4@<r9d>, ULONG_PTR BugCheckParameter2);
void __fastcall sub_14000E5E8(ULONG Tag, __int64 a2);
bool __fastcall sub_14000E620(__m128i *a1, USHORT *a2, BOOLEAN a3);
__int64 sub_14000E660();
void __fastcall sub_14000E6B0(PSLIST_ENTRY ListEntry);
struct _SLIST_ENTRY *__fastcall sub_14000E720(PSLIST_ENTRY ListEntry, char a2);
__int64 __fastcall sub_14000E770(__int64 a1, __int64 a2, _QWORD *a3);
__int64 __fastcall sub_14000E7D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14000E850(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14000E9D0(__int64 a1, __int64 a2, __int64 a3, __m128i *a4);
__int64 __fastcall sub_14000EDB0(__int64 a1, __int64 a2, _QWORD *a3);
__int64 __fastcall sub_14000EDE0(__int64 a1, __int64 a2, _QWORD *a3);
__int64 __fastcall sub_14000EE10(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14000EE90(__int64 a1, __int64 a2, _QWORD *a3, __int64 (***a4)(void));
__int64 __fastcall sub_14000EF50(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4);
__int64 __fastcall sub_14000F030(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_14000F250(__int64 a1, __int64 a2, _QWORD *a3, __m128i **a4);
signed __int64 __fastcall sub_14000F550(__int64 a1, __int64 a2, __int64 a3, __int64 *a4);
__int64 __fastcall sub_14000F670(__int64 a1, __int64 a2, __int64 *a3);
__int64 __fastcall sub_14000FC90(__int64 a1, __int64 a2, _QWORD *a3);
signed __int64 __fastcall sub_14000FCC0(__int64 a1, __int64 a2, __int64 a3, __int64 (****a4)(void));
signed __int64 __fastcall sub_14000FF40(__int64 a1, __int64 a2, _QWORD *a3);
__int64 __fastcall sub_14000FF70(__int64 a1, __int64 a2, _QWORD *a3, __int64 **a4);
signed __int64 __fastcall sub_140010270(__int64 a1, __int64 a2, _QWORD *a3, __int64 (****a4)(void));
__int64 __fastcall sub_140010438(PVOID Object); // idb
__int64 __fastcall sub_1400107E0(const void *a1, SIZE_T a2);
char sub_14001082C();
void sub_140010978();
__int64 __fastcall sub_1400109C8(__int64 a1);
char __fastcall sub_140010A04(__int64 a1, __int64 a2);
__int64 *__fastcall sub_140010A8C(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_140010B54(_QWORD *a1);
void __fastcall sub_140010B74(__int64 *a1, char a2);
void __fastcall sub_140010B98(char a1);
void __fastcall sub_140010BA0(__int64 *a1);
bool __fastcall sub_140010BF4(__int64 *a1, __int64 a2);
__int64 __fastcall sub_140010CD0(__int64 *a1, __int64 a2, _QWORD *a3);
void __fastcall sub_140010DA8(_DWORD **a1);
char __fastcall sub_140010DDC(__int64 *a1);
__int64 __fastcall sub_140010DEC(_DWORD *a1);
char __fastcall sub_140010E14(__int64 *a1, int a2, __int64 a3);
char __fastcall sub_140010EF0(__int64 *a1, char *a2);
void __fastcall sub_140010F14(__int64 *a1, __m128i *a2, __int64 a3);
void __fastcall sub_140010F2C(__int64 *a1);
void __fastcall sub_140011040(_DWORD **a1);
void __fastcall sub_140011064(__int64 a1);
void __fastcall sub_1400110DC(__int64 *a1, char a2);
void __fastcall sub_1400110F4(__int64 *a1);
void __fastcall sub_140011118(__int64 *a1);
void __fastcall sub_14001113C(_DWORD **a1);
__int64 __fastcall sub_140011160(_QWORD); // weak
__int64 __fastcall sub_140011168(__int64 a1, _DWORD *a2);
void __fastcall sub_1400111B4(__int64 a1);
void __fastcall sub_140011210(__int64 a1);
char __fastcall sub_140011260(__int64 a1, __int64 a2);
__int64 __fastcall sub_140011338(__int64 a1, __int64 a2);
__int64 __fastcall sub_140011378(__int64 a1, __int64 a2, _BYTE *a3);
char __fastcall sub_1400114F4(__int64 a1, __int64 a2, char a3, _WORD *a4);
void __fastcall sub_1400115C0(char a1);
char __fastcall sub_1400115D0(__int64 a1, _QWORD *a2, unsigned int a3, __int64 a4, __int64 a5, void *a6, __m128i *a7);
char __fastcall sub_1400116B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7);
// __int64 __fastcall unknown_libname_1(_QWORD); weak
void __fastcall sub_1400116CC(PDEVICE_OBJECT *a1);
bool sub_140011718();
__int64 __fastcall sub_140011728(PDEVICE_OBJECT *DeviceObject, PDRIVER_OBJECT DriverObject); // idb
__int64 __fastcall sub_140011860(__int64 a1, struct _IRP *a2);
__int64 __fastcall sub_1400118B0(__int64 a1, struct _IRP *a2);
__int64 __fastcall sub_140011920(__int64 a1, struct _IRP *a2);
__int64 __fastcall sub_140011A10(__int64 a1, struct _IRP *a2);
bool __fastcall sub_140011A90(__int64 a1, __int64 a2);
char __fastcall sub_140011ADC(__int64 a1);
_QWORD *__fastcall sub_140011C84(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_140011D14(struct _FILE_OBJECT *a1, __m128 *a2, __m128i *a3);
void __fastcall sub_140011F10(struct _FILE_OBJECT *a1, __int64 a2, int a3, __m128i *a4);
void __fastcall sub_1400120E0(struct _FILE_OBJECT *a1, __m128 *a2, __m128i *a3);
void __fastcall sub_1400121E8(struct _FILE_OBJECT *a1, _QWORD *a2, __m128i *a3);
PVOID sub_140012400();
signed __int64 __fastcall CompletionRoutine(PDEVICE_OBJECT DeviceObject, PIRP Irp, PVOID Context);
void __fastcall sub_1400124CC(struct _FILE_OBJECT *a1, _QWORD *a2, unsigned int a3, void *a4, __m128i *a5, char a6);
void __fastcall sub_140012660(__int64 a1);
LONG __fastcall sub_140012694(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, char a6);
void __fastcall sub_140012740(__int64 a1, __int64 a2, _QWORD *a3, unsigned int a4, PVOID Address, __m128i *a6, char a7, char a8);
void __fastcall sub_140012984(__int64 a1, __int64 a2, _QWORD *a3, int a4, __int64 a5, __m128i *a6, char a7, char a8, char a9);
char __fastcall sub_140012B50(__int64 a1);
bool __fastcall sub_140012B7C(__int64 a1, __int64 *a2);
bool __fastcall sub_140012CF8(__int64 a1, __int16 *a2, unsigned __int64 a3);
bool __fastcall sub_140012F00(__int64 a1, __int16 *a2, unsigned __int64 a3);
_DWORD *__fastcall sub_140012F40(_BYTE *a1, _DWORD **a2, int a3, __int16 a4);
_DWORD *__fastcall sub_140012FF4(_BYTE *a1, _DWORD **a2, __int16 *a3, unsigned __int64 a4);
_DWORD *__fastcall sub_140013160(_BYTE *a1, _DWORD **a2, __int16 *a3, unsigned __int64 a4);
char __fastcall sub_1400131C8(__int64 a1, __int16 a2);
bool __fastcall sub_1400131F4(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_140013224(__int64 a1, __int16 a2);
signed __int64 __fastcall sub_1400133FC(__int64 a1);
__int64 __fastcall sub_140013490(__int64 a1);
__int64 __fastcall sub_1400134EC(__int128 *a1, __int128 *a2);
__int64 sub_140013548();
__int64 sub_140013598();
void __fastcall sub_1400135E8(PSLIST_ENTRY ListEntry);
void __fastcall sub_14001364C(PSLIST_ENTRY ListEntry);
LONG __fastcall sub_1400136B0(__int64 a1);
__int16 __fastcall sub_1400136D4(__int16 a1);
bool __fastcall sub_1400136E4(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400138A0(__int64 a1, _WORD *a2);
bool __fastcall sub_140013910(__int16 a1);
bool __fastcall sub_140013954(_WORD *a1);
bool __fastcall sub_1400139C0(unsigned __int16 *a1);
bool __fastcall sub_140013A0C(unsigned __int16 *a1);
__int64 __fastcall sub_140013A58(_WORD *a1, unsigned __int64 a2, _DWORD *a3);
bool __fastcall sub_140013C44(unsigned __int16 *a1);
__int64 __fastcall sub_140013C98(wchar_t *Str1, unsigned __int64 a2);
__int64 __fastcall sub_140013DFC(_QWORD *a1, __int64 *a2, char a3, _OWORD *a4, char a5);
__int64 __fastcall sub_140013F8C(_QWORD *a1, __int64 a2, __int64 a3, char a4);
void **__fastcall sub_14001405C(_QWORD *a1);
__int64 sub_140014138();
void __fastcall sub_140014188(PSLIST_ENTRY ListEntry);
struct _SLIST_ENTRY *__fastcall sub_1400141F0(PSLIST_ENTRY ListEntry, char a2);
LONG __fastcall sub_140014234(__int64 a1, unsigned int a2);
__int64 __fastcall sub_14001425C(__int64 a1, _QWORD *a2, char a3);
bool __fastcall sub_140014470(__int64 a1);
signed __int64 __fastcall sub_1400144E0(__m128i *a1, __int64 a2, __int64 a3, char a4);
signed __int64 __fastcall sub_1400148C0(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, char a6, char a7);
signed __int64 __fastcall sub_140014C28(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_140014E6C(__int64 a1, __int64 a2, struct _FILE_OBJECT *a3);
void __fastcall sub_140014EA0(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_140014ED4(__int64 a1, _QWORD *a2, __int64 a3);
char __fastcall sub_140015028(__int64 a1, _QWORD *a2, __m128i *a3);
PVOID __fastcall sub_140015158(__int64 a1);
UNICODE_STRING *__fastcall sub_1400151C8(__int64 a1, __int64 a2);
const wchar_t *__fastcall sub_1400152F8(signed int a1);
__int64 __fastcall sub_1400153D4(__int64 a1);
char __fastcall sub_14001544C(__int64 a1, __int64 a2, int a3, __int64 a4, char a5);
char __fastcall sub_14001548C(__int64 a1, int a2, unsigned int a3);
char __fastcall sub_1400154CC(__int64 a1, char a2);
bool __fastcall sub_140015540(__int64 a1, unsigned __int16 a2, __int64 a3);
char __fastcall sub_140015648(__int64 a1, __int64 a2);
LONG __fastcall sub_1400156B4(__int64 a1, _WORD *a2);
void __fastcall sub_14001573C(__int64 a1);
void __fastcall sub_14001576C(__int64 a1, __int64 a2, __int64 *a3, __int64 *a4, char a5, _BYTE *a6, __int64 a7, unsigned int a8);
signed __int64 __fastcall sub_14001599C(__int64 a1, __int64 a2, __int64 *a3, __int64 *a4);
__int64 __fastcall sub_140015E68(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140015F64(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
LONG __fastcall sub_140016134(__int64 a1, __int64 a2);
char __fastcall sub_1400161A4(__int64 a1, __int64 *a2, __int64 a3, unsigned int a4);
char __fastcall sub_1400162C0(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_140016340(__int64 a1, __int64 *a2, __int64 a3, unsigned int a4);
char __fastcall sub_140016430(__int64 a1, __int64 a2, int a3, __int64 a4);
void __fastcall sub_1400164CC(__int64 a1, __int64 a2, __int16 a3);
int __fastcall sub_140016534(__int64 a1, const UNICODE_STRING *a2);
unsigned __int8 __fastcall sub_140016594(__int64 a1, char a2);
__int64 __fastcall sub_140016610(__int64 a1);
bool sub_140016628();
__int64 sub_14001663C();
void __fastcall sub_14001668C(PSLIST_ENTRY ListEntry);
__int64 __fastcall sub_1400166F0(__m128i *a1, __m128i **a2);
__int64 __fastcall sub_1400167E4(__m128i **a1);
char sub_1400167F4();
signed __int64 __fastcall sub_1400167F8(unsigned __int16 a1, unsigned int a2, __int64 a3);
signed __int64 __fastcall sub_140016900(struct _FILE_OBJECT *a1, __int64 a2, _BYTE *a3);
bool __fastcall sub_1400169E0(const UNICODE_STRING *a1);
bool __fastcall sub_1400169F0(const UNICODE_STRING *a1, char a2, const UNICODE_STRING *a3);
bool __fastcall sub_140016A90(const UNICODE_STRING *a1);
signed __int64 __fastcall sub_140016A9C(struct _FILE_OBJECT *a1, _DWORD *a2, __int64 a3, _BYTE *a4);
signed __int64 __fastcall sub_140016BA0(struct _FILE_OBJECT *a1, _BYTE *a2);
char sub_140016C60();
char __fastcall sub_140016CD4(__int16 *a1);
char __fastcall sub_140016E2C(__int16 a1);
bool __fastcall sub_140017014(__m128i *a1);
__int64 __fastcall sub_1400170A8(__int64 a1, PVOID Object, __int64 a3, int a4, _QWORD *a5, PVOID Objecta, __int64 a7, int a8);
void sub_1400171DC();
signed __int64 __fastcall sub_1400171F0(struct _FILE_OBJECT *a1);
__int64 __fastcall sub_140017408(__int64 a1);
__int64 __fastcall sub_140017428(__int64 a1);
__int64 sub_140017448();
char sub_140017454();
__int64 __fastcall sub_14001749C(__int64 a1);
__int64 __fastcall sub_1400174DC(_WORD *a1, unsigned __int64 a2);
__int64 __fastcall sub_1400174E8(int a1);
unsigned __int64 __fastcall sub_140017524(int a1, __int64 a2, _WORD *a3, char a4, _DWORD *a5, __m128i *a6);
bool __fastcall sub_14001763C(__int64 a1, int a2, int a3);
// __int64 __usercall sub_140017650@<rax>(PIRP Irp@<rcx>, int a2@<edx>, _DWORD *a3@<r8>, __int64 a4@<r9>, char a5, __int64 a6);
void __fastcall sub_1400178D0(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_1400179B0(__int64 a1, __int64 a2);
PLIST_ENTRY sub_140018FC4();
__int64 __fastcall sub_14001907C(__int64 a1);
__int64 __fastcall sub_1400190CC(__int64 a1);
signed __int64 __fastcall sub_140019130(PLIST_ENTRY *a1);
__int64 sub_140019200();
char sub_140019208();
bool sub_1400192EC();
LONG sub_14001931C();
void __fastcall sub_140019458(__int64 a1, char a2);
signed __int64 __fastcall sub_1400194E0(__int64 a1, __int16 a2, __int64 a3, _DWORD *a4);
signed __int64 __fastcall sub_140019618(int a1, int a2, _WORD *a3, __int64 a4, __m128i *a5);
signed __int64 __fastcall sub_140019788(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, __int64 a5);
signed __int64 __fastcall sub_1400198DC(int a1, unsigned __int16 *a2, __int64 a3, _DWORD *a4);
signed __int64 __fastcall sub_140019A20(int a1, int a2, unsigned __int16 *a3, __int64 a4);
__int64 __fastcall sub_140019B6C(unsigned int a1, unsigned __int64 a2, unsigned int a3);
signed __int64 __fastcall sub_140019C14(int a1, unsigned __int16 a2, _QWORD *a3);
signed __int64 __fastcall sub_140019D00(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4, _QWORD *a5);
signed __int64 __fastcall sub_140019D34(__int64 a1, unsigned __int64 a2, unsigned int a3, __int64 a4);
signed __int64 __fastcall sub_140019E80(int a1);
void __fastcall sub_140019F50(__int64 a1, int a2);
char sub_140019F9C();
PLIST_ENTRY sub_140019FF8();
LONG sub_14001A05C();
void sub_14001A0A4();
signed __int64 __fastcall sub_14001A0AC(int a1);
signed __int64 __fastcall sub_14001A170(unsigned __int16 a1);
__int64 __fastcall sub_14001A1F8(PCUNICODE_STRING SourceString, __int16 a2);
unsigned __int64 __fastcall sub_14001A2AC(_WORD *a1, __int16 a2, unsigned __int16 *a3);
__int64 __fastcall sub_14001A30C(const UNICODE_STRING *a1);
signed __int16 __fastcall sub_14001A3A0(__int64 a1, _WORD *a2, signed __int16 *a3);
void __fastcall sub_14001A454(__int64 a1);
__int64 __fastcall sub_14001A4D8(_QWORD); // weak
__int64 __fastcall sub_14001A4E0(__int64 a1);
__int64 __fastcall sub_14001A520(__int64 a1, __int64 a2);
__int64 __fastcall sub_14001A79C(PCUNICODE_STRING Source, const UNICODE_STRING *a2, const UNICODE_STRING *a3, UNICODE_STRING *a4);
signed __int64 __fastcall sub_14001A88C(__int16 a1, const UNICODE_STRING *a2, struct _FILE_OBJECT *a3, const UNICODE_STRING *a4, int a5);
__int64 __fastcall sub_14001ACF0(__int64 a1, __int64 a2);
UNICODE_STRING *__fastcall sub_14001AD10(__int64 a1, const UNICODE_STRING *a2, __int64 a3);
char __fastcall sub_14001AF30(__int16 a1, const UNICODE_STRING *a2, _WORD *a3, char a4, WCHAR *a5, USHORT a6, _WORD *a7);
signed __int64 __fastcall sub_14001B244(_WORD *a1, _WORD *a2, UNICODE_STRING *a3, char a4);
__int64 __fastcall sub_14001B3B0(__int16 a1, unsigned __int16 *a2);
bool __fastcall sub_14001B3C4(__int64 a1);
__int64 sub_14001B3D0();
__int64 __fastcall sub_14001B448(PCUNICODE_STRING SourceString, char a2);
char __fastcall sub_14001B660(__int64 a1);
char __fastcall sub_14001B664(__int64 a1);
_DWORD *__fastcall sub_14001B668(struct _FILE_OBJECT *a1, __int64 a2);
void __fastcall sub_14001B77C(__int64 a1);
void sub_14001B784();
__int64 __fastcall sub_14001B7C4(__int64 a1, const UNICODE_STRING *a2, UNICODE_STRING *a3, __int64 a4, __int64 a5, int a6, _OWORD *a7);
void __fastcall sub_14001BA90(__int64 a1);
__int64 __fastcall sub_14001BACC(__int64 a1, __int64 a2, int a3, _OWORD *a4);
__m128i *__fastcall sub_14001BCA8(__int64 a1);
__int64 __fastcall sub_14001BD68(__int64 a1);
UNICODE_STRING *__fastcall sub_14001BD8C(PCUNICODE_STRING Source);
void *__fastcall sub_14001BE0C(__int64 a1);
void *__fastcall sub_14001BE94(__int64 a1);
bool __fastcall sub_14001BF00(__int64 a1);
__int64 __fastcall sub_14001BF38(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5);
int __fastcall sub_14001BFAC(__int64 a1);
void __fastcall sub_14001BFDC(_BYTE *a1);
int __fastcall sub_14001BFE0(__int64 a1);
signed __int64 __fastcall sub_14001C010(char a1);
__int64 __fastcall sub_14001C080(__int64 a1, __int64 a2);
__int64 __fastcall sub_14001C140(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4);
__int64 __fastcall sub_14001C230(__int64 a1, __int64 a2);
__int64 __fastcall sub_14001C2F0(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4);
__int64 __fastcall sub_14001C370(__int64 a1, __int64 a2);
__int64 __fastcall sub_14001C430(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4);
__int64 __fastcall sub_14001C4B0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14001C570(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4);
__int64 __fastcall sub_14001C5F0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14001C6B0(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4);
__int64 __fastcall sub_14001C730(__int64 a1, __int64 a2);
__int64 __fastcall sub_14001C7F0(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4);
__int64 __fastcall sub_14001C870(__int64 a1, __int64 a2);
__int64 __fastcall sub_14001C930(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4);
__int64 __fastcall sub_14001CA20(__int64 a1, __int64 a2, __int64 a3, char a4);
__int64 __fastcall sub_14001CAE0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14001CBA0(__int64 a1, __int64 a2, __int64 a3, char a4);
__int64 __fastcall sub_14001CC00(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_14001CCB0(__int64 a1, __int64 a2, _QWORD *a3);
__int64 __fastcall sub_14001CD00(__int64 a1, __int64 a2, void *a3);
signed __int64 __fastcall sub_14001CD50(__int64 a1, __int64 a2, __int64 a3, int a4);
void **__fastcall sub_14001CE9C(_QWORD *a1);
char __fastcall sub_14001CEA8(PCUNICODE_STRING String1, _QWORD *a2);
__int64 __fastcall sub_14001CF30(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4);
__int64 __fastcall sub_14001D020(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4);
__int64 __fastcall sub_14001D110(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4);
__int64 __fastcall sub_14001D200(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4);
__int64 __fastcall sub_14001D2F0(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4);
__int64 __fastcall sub_14001D3E0(__int64 a1, __int64 a2, __int64 a3, char a4);
char __fastcall sub_14001D4A0(_OWORD *a1, const UNICODE_STRING *a2);
__int64 __fastcall sub_14001D5EC(__int64 a1);
__int64 sub_14001D65C();
char __fastcall sub_14001D67C(__int64 a1, __int64 a2, _QWORD *a3);
void __fastcall sub_14001D718(PSLIST_ENTRY ListEntry);
signed __int64 __fastcall sub_14001D77C(__int64 a1, unsigned __int16 a2);
__int64 __fastcall sub_14001D7F0(struct _SLIST_ENTRY **a1);
_QWORD *__fastcall sub_14001D828(struct _SLIST_ENTRY **a1);
__int64 __fastcall sub_14001D8D4(PUNICODE_STRING DestinationString, PCUNICODE_STRING SourceString); // idb
__int64 __fastcall sub_14001D94C(__int64 a1);
__int64 __fastcall sub_14001DA7C(__int64 a1, __int64 a2, const UNICODE_STRING *a3);
__int64 __fastcall sub_14001DAD4(__int64 a1, __int64 a2);
void __fastcall sub_14001DB14(__int64 a1, PSLIST_ENTRY *a2);
signed __int64 __fastcall sub_14001DBD0(__int64 a1, UNICODE_STRING *a2);
__int64 __fastcall sub_14001DF90(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14001DFAC(__int64 a1, _DWORD *a2, const UNICODE_STRING *a3, signed __int64 *a4);
__int64 __fastcall sub_14001E178(__int64 a1);
__int64 sub_14001E1F8();
__int64 sub_14001E218();
bool __fastcall sub_14001E298(__int64 a1);
bool __fastcall sub_14001E300(__int64 a1);
__int64 __fastcall sub_14001E364(__int64 a1, __int64 a2);
__int64 __fastcall sub_14001E390(unsigned __int16 *a1, __int64 a2, _DWORD *a3);
__int64 __fastcall sub_14001E3B8(unsigned __int16 *a1, unsigned int a2);
__int64 sub_14001E550();
__int64 sub_14001E5AC();
__int64 sub_14001E600();
void sub_14001E680();
__int64 __fastcall sub_14001E6B0(PUNICODE_STRING Destination); // idb
char __fastcall sub_14001E910(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, char a5, char *a6, bool *a7, bool *a8);
char __fastcall sub_14001EAF4(__int64 a1, char *a2);
char __fastcall sub_14001EB34(char a1, __int64 a2);
// void __usercall sub_14001EBC0(__int64 *a1@<rdx>, unsigned __int16 *a2@<rcx>, __int64 a3@<r8>, char a4@<r9b>, char a5);
char sub_14001EDAC();
__int64 __fastcall sub_14001EDB4(__int64 a1, __int64 a2, __int64 a3, __m128i *a4, __int64 a5, __int64 *a6);
__int64 __fastcall sub_14001F05C(PUNICODE_STRING Destination, PCUNICODE_STRING SourceString); // idb
char __fastcall sub_14001F148(__int64 a1, __m128i *a2, const UNICODE_STRING *a3);
__int64 __fastcall sub_14001F280(__int64 a1, int a2, __int64 a3);
__int64 sub_14001F430();
__int64 sub_14001F4DC();
signed __int64 sub_14001F530();
__int64 __fastcall sub_14001F588(PVOID Object, unsigned __int16 *a2);
__int64 __fastcall sub_14001F6B8(__int64 a1);
void __fastcall sub_14001F70C(_QWORD *a1);
void __fastcall sub_14001F79C(__int64 a1, char a2);
void __fastcall sub_14001F7F8(__int64 a1, __int64 a2);
void __fastcall sub_14001F880(__int64 a1, char a2);
__int64 __fastcall sub_14001F918(_QWORD *a1, __int64 *a2);
void __fastcall sub_14001F9C0(__int64 a1, unsigned __int64 a2, __int64 a3);
bool __fastcall sub_14001FA1C(__int64 a1, __int64 a2, _QWORD *a3, char *a4);
void __fastcall sub_14001FAB8(_DWORD *a1, int a2);
char __fastcall sub_14001FB04(__int64 a1);
__int64 __fastcall sub_14001FB40(__int64 a1, __int64 a2, _BYTE *a3);
__int64 sub_14001FB7C();
char __fastcall sub_14001FB84(__int64 a1, int a2, _DWORD *a3, _BYTE *a4);
char __fastcall sub_14001FC48(__int64 a1);
char __fastcall sub_14001FC84(__m128i *a1, __int64 a2, int a3, char *a4, bool *a5);
void __fastcall sub_14001FD1C(__int64 a1, __m128i *a2, __int64 a3);
void __fastcall sub_14001FD78(__int64 a1);
void __fastcall sub_14001FDB0(_DWORD *a1);
void __fastcall sub_14001FE1C(_DWORD *a1);
void __fastcall sub_14001FE58(__int64 a1, char a2);
void __fastcall sub_14001FE9C(__int64 a1, _BYTE **a2);
void __fastcall sub_14001FF74(__int64 a1);
void __fastcall sub_14001FFCC(__int64 a1);
void __fastcall sub_140020028(_DWORD *a1);
__int64 __fastcall sub_140020094(__int64 a1);
char __fastcall sub_140020218(__m128i *a1, __int64 a2, int a3, bool *a4, bool *a5);
_QWORD *__fastcall sub_140020270(_QWORD *a1, __int64 a2, void *a3, _WORD *a4, __int64 *a5, __int64 a6, int a7, _WORD *a8);
void **__fastcall sub_140020324(_QWORD *a1);
void *__fastcall sub_1400203C0(_QWORD *a1, char a2);
__int64 __fastcall sub_1400203F4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, void *a5, _WORD *a6, __int64 *a7, __int64 a8, unsigned int a9, _WORD *a10, _QWORD *a11);
char __fastcall sub_140020520(__int64 a1);
__int64 __fastcall sub_140020530(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_140020554(__int64 a1, _QWORD *a2);
void __fastcall sub_1400205B4(__int64 a1, __int64 a2);
void __fastcall sub_140020630(__int64 a1, signed int a2);
char __fastcall sub_140020688(__int64 a1);
__int64 __fastcall sub_1400206A0(__int64 **a1);
__int64 sub_1400206B0();
char sub_1400206DC();
__int64 __fastcall sub_140020700(__int64 a1);
void **__fastcall sub_140020724(__int64 a1);
_QWORD *__fastcall sub_140020770(_QWORD *a1, char a2);
void *__fastcall sub_1400207A0(__int64 a1, char a2);
void __fastcall sub_1400207D4(__int64 a1, const UNICODE_STRING *a2);
void __fastcall sub_140020880(__int64 a1);
void __fastcall sub_14002088C(__int64 a1);
char __fastcall sub_1400208E0(__int64 a1);
char __fastcall sub_140020904(__int64 a1);
bool __fastcall sub_140020990(__int64 a1);
__int64 __fastcall sub_1400209C8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5, char a6);
signed __int64 __fastcall sub_140020A18(__int64 a1);
__int64 sub_140020A64();
void __fastcall sub_140020AB4(PSLIST_ENTRY ListEntry);
__int64 sub_140020B18();
__int64 __fastcall sub_140020B50(const UNICODE_STRING *a1, char a2, char a3);
void __fastcall sub_140020D08(__int64 a1, __int64 a2);
void __fastcall sub_140020DB0(__int64 a1, __int64 a2, char a3);
void sub_140020DC4();
void **__fastcall sub_140020DF4(void *a1, void *a2);
char __fastcall sub_140020E24(PCUNICODE_STRING String2, char a2, _BYTE *a3, _BYTE *a4);
signed __int64 __fastcall sub_140020F14(_QWORD *a1, int a2, __int64 a3);
__int64 __fastcall sub_140021010(); // weak
void __fastcall sub_140021018(__int64 a1);
NTSTATUS __fastcall sub_14002108C(__int64 a1);
__int64 __fastcall sub_140021110(__int64 a1, __int64 *a2);
__int64 __fastcall sub_140021200(__int64 a1, __int64 a2);
void __fastcall sub_140021230(__int64 a1);
__int64 __fastcall sub_140021250(__int64 a1, __int64 a2, char a3);
char __fastcall sub_140021278(const char *a1, unsigned __int64 a2);
char __fastcall sub_140021380(const wchar_t *a1, unsigned __int64 a2);
bool __fastcall sub_14002148C(__int64 a1, unsigned __int64 a2);
// __int64 __fastcall FltInitializePushLock(_QWORD); weak
// __int64 __fastcall FltDeletePushLock(_QWORD); weak
// __int64 __fastcall FltAcquirePushLockExclusive(_QWORD); weak
// __int64 __fastcall FltAcquirePushLockShared(_QWORD); weak
// __int64 __fastcall FltReleasePushLock(_QWORD); weak
// __int64 __fastcall FltSetCallbackDataDirty(_QWORD); weak
// __int64 __fastcall FltDeleteContext(_QWORD); weak
// __int64 __fastcall FltReferenceContext(_QWORD); weak
// __int64 __fastcall FltReleaseContext(_QWORD); weak
// __int64 __fastcall FltCreateFile(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltClose(_QWORD); weak
// __int64 __fastcall FltRollbackEnlistment(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltCancelFileOpen(_QWORD, _QWORD); weak
// __int64 __fastcall FltSetCancelCompletion(_QWORD, _QWORD); weak
// __int64 __fastcall FltClearCancelCompletion(_QWORD); weak
// __int64 __fastcall FltAllocateExtraCreateParameterList(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltAllocateExtraCreateParameter(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltInsertExtraCreateParameter(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltFindExtraCreateParameter(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltRemoveExtraCreateParameter(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltFreeExtraCreateParameterList(_QWORD, _QWORD); weak
// __int64 __fastcall FltFreeExtraCreateParameter(_QWORD, _QWORD); weak
// __int64 __fastcall FltGetEcpListFromCallbackData(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltSetEcpListIntoCallbackData(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltGetDiskDeviceObject(_QWORD, _QWORD); weak
// __int64 __fastcall FltCreateFileEx(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltFsControlFile(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltIsEcpFromUserMode(_QWORD, _QWORD); weak
// __int64 __fastcall FltGetVolumeName(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltAllocateContext(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltSetInstanceContext(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD); weak
// __int64 __fastcall FltGetVolumeFromInstance(_QWORD, _QWORD); weak
// __int64 __fastcall FltGetVolumeProperties(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltGetVolumeGuidName(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltQueryVolumeInformation(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 FltObjectDereference(void); weak
// __int64 __cdecl FltDoCompletionProcessingWhenSafe(_QWORD, _QWORD); weak
// __int64 __fastcall FltRegisterFilter(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltUnregisterFilter(_QWORD); weak
// __int64 __fastcall FltStartFiltering(_QWORD); weak
// __int64 __fastcall FltGetInstanceInformation(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltGetVolumeFromFileObject(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltSupportsStreamContexts(_QWORD); weak
// __int64 __fastcall FltSetStreamContext(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltGetStreamContext(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltGetVolumeInstanceFromName(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltSupportsStreamHandleContexts(_QWORD); weak
// __int64 __fastcall FltSetStreamHandleContext(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltGetStreamHandleContext(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltSetTransactionContext(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltGetTransactionContext(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FltEnlistInTransaction(_QWORD, _QWORD, _QWORD, _QWORD); weak
void __fastcall __noreturn sub_1400217B0(ULONG_PTR BugCheckParameter1); // idb
__int64 __fastcall sub_140021800(unsigned __int64 a1, __int64 a2, _DWORD *a3);
__int64 __fastcall sub_140021880(unsigned __int64 *a1, __int64 a2, unsigned __int64 a3);
// int __cdecl vsnwprintf(wchar_t *Dest, size_t Count, const wchar_t *Format, va_list Args);
// ULONG DbgPrint(PCH Format, ...);
// wchar_t *__cdecl wcschr(const wchar_t *Str, wchar_t Ch);
// int __cdecl wcscmp(const wchar_t *Str1, const wchar_t *Str2);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// int __cdecl wcsncmp(const wchar_t *Str1, const wchar_t *Str2, size_t MaxCount);
// __int64 __usercall sub_140021A40@<rax>(__int64 (*a1)(void)@<rax>);
__m128i *__fastcall sub_140021A80(__m128i *_RCX, unsigned __int64 a2, unsigned __int64 a3);
__m128 *__fastcall sub_140021DC0(__m128 *a1, unsigned __int8 a2, unsigned __int64 a3);
void sub_1400277F0();
void sub_140027810();
__int64 **sub_140027830();
void sub_140027840();
void sub_140027860();
void sub_140027880();
void sub_140027890();
_QWORD *sub_1400278E0();
void sub_140027940();
_QWORD *sub_140027960();
void sub_140027970();
void sub_140027990();
void sub_1400279A0();
void sub_1400279C0();
__int64 sub_1400279E0();
void sub_140027A10();
void sub_140027A30();
_QWORD *sub_140027A50();
void sub_140027A70();
void **sub_140027A90();
void sub_140027AA0();
void sub_140027AE0();
void sub_140027B00();
__int64 sub_140027B20();
__int64 sub_140027B30();
__int64 sub_140027B40();
__int64 sub_140027B50();
void sub_140027B60();
void sub_140027B80();
void sub_140027BA0();
__int64 sub_140027BE0();
void sub_140027BF0();
_QWORD *sub_140027C10();
void sub_140027C30();
void sub_140027C70();
void sub_140027C80();
// void __stdcall KeInitializeEvent(PRKEVENT Event, EVENT_TYPE Type, BOOLEAN State);
// NTSTATUS __stdcall KeWaitForSingleObject(PVOID Object, KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
// PIRP __stdcall IoBuildDeviceIoControlRequest(ULONG IoControlCode, PDEVICE_OBJECT DeviceObject, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, BOOLEAN InternalDeviceIoControl, PKEVENT Event, PIO_STATUS_BLOCK IoStatusBlock);
// NTSTATUS __stdcall IofCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp);
// PDEVICE_OBJECT __stdcall IoGetAttachedDeviceReference(PDEVICE_OBJECT DeviceObject);
// NTSTATUS __stdcall ObReferenceObjectByHandle(HANDLE Handle, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PVOID *Object, POBJECT_HANDLE_INFORMATION HandleInformation);
// LONG_PTR __stdcall ObfDereferenceObject(PVOID Object);
// NTSTATUS __stdcall ZwCreateFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);
// void __stdcall RtlInitUnicodeString(PUNICODE_STRING DestinationString, PCWSTR SourceString);
// LONG __stdcall RtlCompareUnicodeString(PCUNICODE_STRING String1, PCUNICODE_STRING String2, BOOLEAN CaseInSensitive);
// void __stdcall ExAcquireFastMutex(PFAST_MUTEX FastMutex);
// void __stdcall ExReleaseFastMutex(PFAST_MUTEX FastMutex);
// USHORT __stdcall ExQueryDepthSList(PSLIST_HEADER SListHead);
// PSLIST_ENTRY __stdcall ExpInterlockedPopEntrySList(PSLIST_HEADER ListHead);
// PSLIST_ENTRY __stdcall ExpInterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry);
// void __stdcall ExInitializeNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside, PALLOCATE_FUNCTION Allocate, PFREE_FUNCTION Free, ULONG Flags, SIZE_T Size, ULONG Tag, USHORT Depth);
// void __stdcall ExDeleteNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside);
// void __stdcall ExInitializePagedLookasideList(PPAGED_LOOKASIDE_LIST Lookaside, PALLOCATE_FUNCTION Allocate, PFREE_FUNCTION Free, ULONG Flags, SIZE_T Size, ULONG Tag, USHORT Depth);
// void __stdcall ExDeletePagedLookasideList(PPAGED_LOOKASIDE_LIST Lookaside);
// LONG_PTR __stdcall ObfReferenceObject(PVOID Object);
// __int64 __fastcall FsRtlDissectName(_QWORD, _QWORD, _QWORD); weak
// void __stdcall RtlCopyUnicodeString(PUNICODE_STRING DestinationString, PCUNICODE_STRING SourceString);
// PVOID __stdcall ExAllocatePoolWithTag(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag);
// void __stdcall ExFreePoolWithTag(PVOID P, ULONG Tag);
// __int64 __fastcall RtlValidSid(_QWORD); weak
// __int64 __fastcall SeQueryInformationToken(_QWORD, _QWORD, _QWORD); weak
// __int64 __cdecl PsGetCurrentProcessId(_QWORD); weak
// void __stdcall KeInitializeMutex(PRKMUTEX Mutex, ULONG Level);
// LONG __stdcall KeReleaseMutex(PRKMUTEX Mutex, BOOLEAN Wait);
// NTSTATUS __stdcall ZwQueryInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);
// NTSTATUS __stdcall ZwClose(HANDLE Handle);
// ULONG KeQueryTimeIncrement(void);
// void __stdcall IofCompleteRequest(PIRP Irp, CCHAR PriorityBoost);
// __int64 __fastcall IoGetAttachedDevice(_QWORD); weak
// NTSTATUS __stdcall RtlAppendUnicodeStringToString(PUNICODE_STRING Destination, PCUNICODE_STRING Source);
// __int64 __fastcall RtlInitializeGenericTableAvl(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall RtlInsertElementGenericTableAvl(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall RtlDeleteElementGenericTableAvl(_QWORD, _QWORD); weak
// __int64 __fastcall RtlLookupElementGenericTableAvl(_QWORD, _QWORD); weak
// __int64 __fastcall RtlIsGenericTableEmptyAvl(_QWORD); weak
// __int64 __fastcall ObOpenObjectByPointer(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// KIRQL __stdcall KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock);
// void __stdcall KeReleaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL NewIrql);
// NTSTATUS __stdcall RtlIntegerToUnicodeString(ULONG Value, ULONG Base, PUNICODE_STRING String);
// NTSTATUS __stdcall RtlUnicodeStringToAnsiString(PANSI_STRING DestinationString, PCUNICODE_STRING SourceString, BOOLEAN AllocateDestinationString);
// __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD, _QWORD); weak
// __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD); weak
// PEPROCESS IoGetCurrentProcess(void);
// void __stdcall __noreturn KeBugCheckEx(ULONG BugCheckCode, ULONG_PTR BugCheckParameter1, ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter3, ULONG_PTR BugCheckParameter4);
// PVOID __stdcall IoAllocateErrorLogEntry(PVOID IoObject, UCHAR EntrySize);
// void __stdcall IoWriteErrorLogEntry(PVOID ElEntry);
// __int64 __fastcall ZwSetInformationThread(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall ZwOpenProcessTokenEx(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall ZwOpenThreadTokenEx(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall ZwDuplicateToken(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// NTSTATUS __stdcall RtlInt64ToUnicodeString(ULONGLONG Value, ULONG Base, PUNICODE_STRING String);
// __int64 __fastcall PsLookupProcessByProcessId(_QWORD, _QWORD); weak
// NTSTATUS __stdcall RtlAppendUnicodeToString(PUNICODE_STRING Destination, PCWSTR Source);
// LONG __stdcall KeSetEvent(PRKEVENT Event, KPRIORITY Increment, BOOLEAN Wait);
// NTSTATUS __stdcall KeDelayExecutionThread(KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Interval);
// KPRIORITY __stdcall KeSetPriorityThread(PKTHREAD Thread, KPRIORITY Priority);
// NTSTATUS __stdcall PsCreateSystemThread(PHANDLE ThreadHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PKSTART_ROUTINE StartRoutine, PVOID StartContext);
// NTSTATUS __stdcall PsTerminateSystemThread(NTSTATUS ExitStatus);
// NTSTATUS __stdcall IoGetDeviceObjectPointer(PUNICODE_STRING ObjectName, ACCESS_MASK DesiredAccess, PFILE_OBJECT *FileObject, PDEVICE_OBJECT *DeviceObject);
// __int64 __fastcall IoSetThreadHardErrorMode(_QWORD); weak
// __int64 __fastcall PsIsThreadTerminating(_QWORD); weak
// __int64 __fastcall IoAcquireVpbSpinLock(_QWORD); weak
// __int64 __fastcall IoReleaseVpbSpinLock(_QWORD); weak
// __int64 __fastcall ZwWaitForSingleObject(_QWORD, _QWORD, _QWORD); weak
// NTSTATUS __stdcall RtlCreateSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Revision);
// NTSTATUS __stdcall RtlSetDaclSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor, BOOLEAN DaclPresent, PACL Dacl, BOOLEAN DaclDefaulted);
// __int64 __fastcall SeCaptureSubjectContext(_QWORD); weak
// __int64 __fastcall SeReleaseSubjectContext(_QWORD); weak
// BOOLEAN __stdcall SeAccessCheck(PSECURITY_DESCRIPTOR SecurityDescriptor, PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext, BOOLEAN SubjectContextLocked, ACCESS_MASK DesiredAccess, ACCESS_MASK PreviouslyGrantedAccess, PPRIVILEGE_SET *Privileges, PGENERIC_MAPPING GenericMapping, KPROCESSOR_MODE AccessMode, PACCESS_MASK GrantedAccess, PNTSTATUS AccessStatus);
// __int64 IoGetFileObjectGenericMapping(void); weak
// __int64 __fastcall RtlLengthRequiredSid(_QWORD); weak
// __int64 __fastcall RtlInitializeSid(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall RtlSubAuthoritySid(_QWORD, _QWORD); weak
// __int64 __fastcall RtlLengthSid(_QWORD); weak
// __int64 __fastcall RtlCreateAcl(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall RtlAddAccessAllowedAce(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall SeTokenIsAdmin(_QWORD); weak
// __int64 __fastcall RtlGetVersion(_QWORD); weak
// SIZE_T __stdcall RtlCompareMemory(const void *Source1, const void *Source2, SIZE_T Length);
// NTSTATUS __stdcall KeWaitForMultipleObjects(ULONG Count, PVOID Object[], WAIT_TYPE WaitType, KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PKWAIT_BLOCK WaitBlockArray);
// NTSTATUS __stdcall ZwOpenKey(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
// NTSTATUS __stdcall ZwQueryValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);
// NTSTATUS __stdcall ZwSetValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);
// NTSTATUS __stdcall ZwOpenSymbolicLinkObject(PHANDLE LinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
// NTSTATUS __stdcall ZwQuerySymbolicLinkObject(HANDLE LinkHandle, PUNICODE_STRING LinkTarget, PULONG ReturnedLength);
// __int64 __fastcall ObQueryNameString(_QWORD, _QWORD, _QWORD, _QWORD); weak
// void __stdcall KeInitializeSemaphore(PRKSEMAPHORE Semaphore, LONG Count, LONG Limit);
// LONG __stdcall KeReleaseSemaphore(PRKSEMAPHORE Semaphore, KPRIORITY Increment, LONG Adjustment, BOOLEAN Wait);
// __int64 __fastcall PsSetCreateProcessNotifyRoutineEx(_QWORD, _QWORD); weak
// void __stdcall KeClearEvent(PRKEVENT Event);
// PVOID __stdcall MmGetSystemRoutineAddress(PUNICODE_STRING SystemRoutineName);
// __int64 __fastcall ZwOpenProcess(_QWORD, _QWORD, _QWORD, _QWORD); weak
// KPROCESSOR_MODE ExGetPreviousMode(void);
// __int64 __fastcall PsGetCurrentThreadId(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall ZwTerminateProcess(_QWORD, _QWORD); weak
// void __stdcall ProbeForRead(const void *Address, SIZE_T Length, ULONG Alignment);
// __int64 __fastcall PsGetProcessId(_QWORD); weak
// BOOLEAN __stdcall RtlEqualUnicodeString(PCUNICODE_STRING String1, PCUNICODE_STRING String2, BOOLEAN CaseInSensitive);
// __int64 __fastcall ZwQueryDirectoryFile(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall RtlEqualSid(_QWORD, _QWORD); weak
// __int64 __fastcall RtlCopySid(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall PsSetCreateThreadNotifyRoutine(_QWORD); weak
// __int64 __fastcall PsRemoveCreateThreadNotifyRoutine(_QWORD); weak
// LONG __stdcall KeReadStateEvent(PRKEVENT Event);
// __int64 IoGetTopLevelIrp(void); weak
// NTSTATUS __stdcall IoCreateDevice(PDRIVER_OBJECT DriverObject, ULONG DeviceExtensionSize, PUNICODE_STRING DeviceName, ULONG DeviceType, ULONG DeviceCharacteristics, BOOLEAN Exclusive, PDEVICE_OBJECT *DeviceObject);
// NTSTATUS __stdcall IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName, PUNICODE_STRING DeviceName);
// void __stdcall IoDeleteDevice(PDEVICE_OBJECT DeviceObject);
// NTSTATUS __stdcall IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName);
// void KeEnterCriticalRegion(void);
// void KeLeaveCriticalRegion(void);
// void __stdcall ProbeForWrite(PVOID Address, SIZE_T Length, ULONG Alignment);
// void __stdcall MmUnlockPages(PMDL MemoryDescriptorList);
// PIRP __stdcall IoAllocateIrp(CCHAR StackSize, BOOLEAN ChargeQuota);
// void __stdcall IoFreeIrp(PIRP Irp);
// void __stdcall IoFreeMdl(PMDL Mdl);
// PDEVICE_OBJECT __stdcall IoGetRelatedDeviceObject(PFILE_OBJECT FileObject);
// NTSTATUS __stdcall IoSetCompletionRoutineEx(PDEVICE_OBJECT DeviceObject, PIRP Irp, PIO_COMPLETION_ROUTINE CompletionRoutine, PVOID Context, BOOLEAN InvokeOnSuccess, BOOLEAN InvokeOnError, BOOLEAN InvokeOnCancel);
// __int64 __fastcall KeExpandKernelStackAndCalloutEx(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FsRtlAcquireFileExclusive(_QWORD); weak
// __int64 __fastcall FsRtlReleaseFile(_QWORD); weak
// __int64 __fastcall CcFlushCache(_QWORD, _QWORD, _QWORD, _QWORD); weak
// void __stdcall IoGetStackLimits(PULONG_PTR LowLimit, PULONG_PTR HighLimit);
// __int64 __fastcall TmGetTransactionId(_QWORD, _QWORD); weak
// PIRP __stdcall IoBuildSynchronousFsdRequest(ULONG MajorFunction, PDEVICE_OBJECT DeviceObject, PVOID Buffer, ULONG Length, PLARGE_INTEGER StartingOffset, PKEVENT Event, PIO_STATUS_BLOCK IoStatusBlock);
// PLIST_ENTRY __stdcall ExInterlockedInsertTailList(PLIST_ENTRY ListHead, PLIST_ENTRY ListEntry, PKSPIN_LOCK Lock);
// PLIST_ENTRY __stdcall ExInterlockedRemoveHeadList(PLIST_ENTRY ListHead, PKSPIN_LOCK Lock);
// void __stdcall IoAcquireCancelSpinLock(PKIRQL Irql);
// void __stdcall IoReleaseCancelSpinLock(KIRQL Irql);
// __int64 __fastcall ObIsKernelHandle(_QWORD, _QWORD, _QWORD, _QWORD); weak
// NTSTATUS __stdcall RtlGUIDFromString(PUNICODE_STRING GuidString, GUID *Guid);
// __int64 __fastcall IoQueryFileDosDeviceName(_QWORD, _QWORD); weak
// __int64 __fastcall PsSetLoadImageNotifyRoutine(_QWORD); weak
// __int64 __fastcall PsRemoveLoadImageNotifyRoutine(_QWORD); weak
// NTSTATUS __stdcall CmUnRegisterCallback(LARGE_INTEGER Cookie);
// __int64 __fastcall CmRegisterCallbackEx(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall MmCanFileBeTruncated(_QWORD, _QWORD); weak
char __fastcall sub_14003C000(void *a1);
NTSTATUS __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
// __int64 _security_init_cookie(void); weak

//-------------------------------------------------------------------------
// Data declarations

__int128 xmmword_140022340 = 0x5C006500630069007600650044005Ci64; // weak
char aSystem[7] = "System"; // weak
__int128 xmmword_140022E30 = 0x690076006500440073006F0044005Ci64; // weak
__int128 xmmword_140025180 = 0x610063006F006C006C0041006F0049i64; // weak
__int128 xmmword_140025190 = 0x78004500700072004900650074i64; // weak
const WCHAR word_140026510 = 92u; // idb
__int128 xmmword_140026840 = 0x5C006500630069007600650044005Ci64; // weak
// extern POBJECT_TYPE *IoFileObjectType;
// extern _UNKNOWN MmSystemRangeStart; weak
// extern _UNKNOWN PsInitialSystemProcess; weak
_UNKNOWN unk_140028690; // weak
_UNKNOWN unk_1400287F8; // weak
_UNKNOWN unk_1400287FF; // weak
void *off_140028B50 = &purecall; // weak
__int64 (__fastcall *off_140028B58)(PSLIST_ENTRY ListEntry) = &sub_140004B90; // weak
__int128 xmmword_140028B60 = 0i64; // weak
_UNKNOWN unk_140028B70; // weak
__int128 xmmword_140028BA0 = 0i64; // weak
char byte_140028BB0 = '\x02'; // idb
const UNICODE_STRING stru_140028BD0 = { 16u, 16u, L"\\??\\UNC\\" }; // idb
__int64 (__fastcall *off_140028C10)(PSLIST_ENTRY ListEntry) = &sub_14000E720; // weak
_UNKNOWN unk_140028C18; // weak
_UNKNOWN unk_140028C28; // weak
_UNKNOWN unk_140028C38; // weak
__int64 (__fastcall *off_140028C48)(PSLIST_ENTRY ListEntry) = &sub_1400141F0; // weak
__int128 xmmword_140028C50 = 0i64; // weak
char byte_140028CD0 = '\x16'; // idb
_BYTE byte_140028D00[16] = { 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0 }; // idb
const UNICODE_STRING stru_140028D10 = { 22u, 22u, L"\\Device\\Mup" }; // idb
__int128 xmmword_140029010 = 0i64; // weak
_UNKNOWN unk_140029020; // weak
_UNKNOWN unk_140029048; // weak
__int64 (__fastcall *off_140029050)() = &sub_1400203C0; // weak
void *off_140029160 = &purecall; // weak
__int64 (__fastcall *off_140029170[2])() = { &sub_1400208E0, &sub_1400207A0 }; // weak
char byte_14002B040 = '\x01'; // weak
int dword_14002B044 = 4294967288; // weak
struct _FAST_MUTEX stru_14002B048 = { 1, NULL, 0u, { { { { 0u, 0u, 0u, { 0u } } }, 0, { NULL, NULL } } }, 0u }; // idb
struct _FAST_MUTEX stru_14002B080 = { 1, NULL, 0u, { { { { 0u, 0u, 0u, { 0u } } }, 0, { NULL, NULL } } }, 0u }; // idb
struct _FAST_MUTEX FastMutex = { 1, NULL, 0u, { { { { 0u, 0u, 0u, { 0u } } }, 0, { NULL, NULL } } }, 0u }; // idb
int dword_14002B0F0 = 60; // weak
int dword_14002B0F4 = 5; // weak
char byte_14002B0F8 = '\x01'; // weak
int dword_14002B0FC = 4294967295; // weak
LARGE_INTEGER Interval = { { 4284967296u, 4294967295 } }; // idb
const UNICODE_STRING String2 = { 32u, 34u, L"\\FileSystem\\Ntfs" }; // idb
int dword_14002B140 = 120; // weak
LARGE_INTEGER Timeout = { { 4284967296u, 4294967295 } }; // idb
unsigned int dword_14002B150[2] = { 8192u, 0u }; // idb
wchar_t asc_14002B158[3] = L"(*"; // weak
char byte_14002B168 = '\x01'; // weak
struct _FAST_MUTEX stru_14002B170 = { 1, NULL, 0u, { { { { 0u, 0u, 0u, { 0u } } }, 0, { NULL, NULL } } }, 0u }; // idb
char byte_14002B1A8 = '\x01'; // weak
_UNKNOWN unk_14002B1B0; // weak
const UNICODE_STRING stru_14002B290 = { 10u, 10u, L"\\Read" }; // idb
wchar_t asc_14002B2A0[8] = L"*/\\:<>|."; // weak
char byte_14002B2B0 = '\x01'; // weak
void *off_14002B2C0 = &unk_140028AD0; // weak
int dword_14002B300[] = { 128 }; // weak
struct _PAGED_LOOKASIDE_LIST stru_14002B340 =
{
  {
    { 0ui64, 0ui64 },
    0u,
    0u,
    0u,
    { 0u },
    0u,
    { 0u },
    NonPagedPool,
    0u,
    0u,
    NULL,
    NULL,
    { NULL, NULL },
    0u,
    { 0u },
    { 0u, 0u }
  }
}; // idb
int dword_14002B540 = 1024; // weak
const UNICODE_STRING stru_14002B600 = { 6u, 6u, L"\\.\\" }; // idb
const UNICODE_STRING stru_14002B610 = { 20u, 20u, L"GLOBALROOT" }; // idb
const UNICODE_STRING stru_14002B620 = { 40u, 42u, L"SAVOnAccess Instance" }; // idb
const UNICODE_STRING stru_14002B630 = { 42u, 44u, L"SAVOnAccess Instance2" }; // idb
_UNKNOWN unk_14002B640; // weak
int dword_14002B644 = 0; // weak
struct _FAST_MUTEX stru_14002B6A8 = { 1, NULL, 0u, { { { { 0u, 0u, 0u, { 0u } } }, 0, { NULL, NULL } } }, 0u }; // idb
struct _FAST_MUTEX stru_14002B6E0 = { 1, NULL, 0u, { { { { 0u, 0u, 0u, { 0u } } }, 0, { NULL, NULL } } }, 0u }; // idb
wchar_t aAa[3] = L""; // weak
wchar_t *off_14002B730 = L"Protected"; // weak
void *off_14002B738 = &off_14002B738; // weak
struct _FAST_MUTEX stru_14002B748 = { 1, NULL, 0u, { { { { 0u, 0u, 0u, { 0u } } }, 0, { NULL, NULL } } }, 0u }; // idb
ULONG_PTR _security_cookie = 47936899621426ui64; // idb
ULONG_PTR BugCheckParameter3 = 18446696136809930189ui64; // idb
ULONG PoolType = 0u; // idb
int dword_14002B7C4 = 0; // weak
struct _NPAGED_LOOKASIDE_LIST ListHead; // idb
_UNKNOWN unk_14002B880; // weak
struct _PAGED_LOOKASIDE_LIST SListHead; // idb
struct _PAGED_LOOKASIDE_LIST stru_14002B980; // idb
_UNKNOWN unk_14002BA00; // weak
_UNKNOWN unk_14002CA10; // weak
_UNKNOWN unk_14002CA28; // weak
_UNKNOWN unk_14002CA30; // weak
__int64 qword_14002F7D8; // weak
_UNKNOWN unk_14002F7E0; // weak
_UNKNOWN unk_14002F7F0; // weak
_UNKNOWN unk_14002F7F8; // weak
__int64 qword_140030460; // weak
int dword_140030468; // weak
struct _PAGED_LOOKASIDE_LIST stru_140030480; // idb
int dword_140030500; // weak
char byte_140030504; // weak
struct _KMUTANT Mutex; // idb
struct _PAGED_LOOKASIDE_LIST stru_140030540; // idb
_UNKNOWN unk_1400305C0; // weak
struct _PAGED_LOOKASIDE_LIST stru_140030640; // idb
char byte_1400306C0; // weak
int dword_1400306C4; // weak
UNICODE_STRING Destination; // idb
_UNKNOWN unk_1400306E0; // weak
KSPIN_LOCK SpinLock; // idb
int dword_140030750; // weak
char byte_140030754; // weak
char byte_140030755; // weak
int dword_140030758; // weak
__int64 qword_140030760; // weak
__int64 qword_140030768; // weak
__int64 qword_140030770; // weak
_UNKNOWN unk_140030780; // weak
_UNKNOWN unk_140030F80; // weak
PVOID IoObject; // idb
__int64 qword_140031088; // weak
int dword_140031090; // weak
int dword_140031094; // weak
struct _KMUTANT Object; // idb
_UNKNOWN unk_1400310D0; // weak
__m128 stru_140031120; // idb
struct _FAST_MUTEX stru_140031180; // idb
_UNKNOWN unk_1400311C0; // weak
_UNKNOWN unk_1400350D0; // weak
struct _NPAGED_LOOKASIDE_LIST Lookaside; // idb
int dword_140035180; // weak
_UNKNOWN unk_140035190; // weak
struct _KMUTANT stru_140035990; // idb
PVOID qword_1400359D0; // idb
struct _KEVENT stru_1400359D8; // idb
char byte_1400359F0; // weak
char byte_1400359F1; // weak
__int64 qword_1400359F8; // weak
__int64 qword_140035A00; // weak
struct _FAST_MUTEX stru_140035A08; // idb
_UNKNOWN unk_140035A40; // weak
__int64 qword_140036388; // weak
_UNKNOWN unk_1400363A0; // weak
PSECURITY_DESCRIPTOR SecurityDescriptor; // idb
PVOID P; // idb
struct _KMUTANT stru_1400363D8; // idb
int dword_140036410; // weak
int dword_140036414; // weak
PVOID qword_140036418; // idb
char byte_140036420; // weak
char byte_140036421; // weak
struct _KEVENT stru_140036440; // idb
_UNKNOWN unk_140036460; // weak
struct _SLIST_HEADER stru_1400364C0; // idb
__int16 word_1400364D0; // weak
int dword_1400364D4; // weak
int dword_1400364D8; // weak
int dword_1400364DC; // weak
int dword_1400364E0; // weak
__int64 qword_1400364F0; // weak
__int64 qword_1400364F8; // weak
_QWORD qword_140036540[128]; // idb
int dword_140036940; // weak
__int64 qword_140036948; // weak
__int64 qword_140036950; // weak
struct _FAST_MUTEX stru_140036958; // idb
char byte_140036990; // weak
_QWORD qword_140036998[5]; // idb
char byte_1400369C0; // weak
__int64 qword_1400369C8; // weak
struct _KEVENT stru_1400369D0; // idb
struct _PAGED_LOOKASIDE_LIST stru_140036A00; // idb
__int64 qword_140036A80; // weak
struct _PAGED_LOOKASIDE_LIST stru_140036AC0; // idb
__int64 qword_140036B40; // weak
__int64 qword_140036B48; // weak
char byte_140036BA0; // weak
struct _PAGED_LOOKASIDE_LIST stru_140036BC0; // idb
char byte_140036C40; // weak
_UNKNOWN unk_140036C50; // weak
__int64 qword_140037C60; // weak
__int64 qword_140037C68; // weak
_UNKNOWN unk_140037C70; // weak
char byte_140037C78; // weak
char byte_140037C79; // weak
struct _PAGED_LOOKASIDE_LIST stru_140037C80; // idb
char byte_140037D00; // weak
_QWORD qword_140037D08[2]; // idb
int dword_140037D18; // weak
_UNKNOWN unk_140037D40; // weak
char byte_140037D48; // weak
__int64 qword_140037D50; // weak
struct _KEVENT Event; // idb
_UNKNOWN unk_140037D80; // weak
char byte_140037DA8; // weak
struct _NPAGED_LOOKASIDE_LIST stru_140037DC0; // idb
char byte_140037E40; // weak
char byte_140037E41; // weak
int dword_140037E44; // weak
int dword_140037E48; // weak
int dword_140037E50; // weak
char byte_140037E58; // weak
__int64 qword_140037E60; // weak
struct _PAGED_LOOKASIDE_LIST stru_140037E80; // idb
struct _PAGED_LOOKASIDE_LIST stru_140037F00; // idb
_UNKNOWN unk_140037F80; // weak
__int64 qword_140037F98; // weak
__int64 qword_140037FA0; // weak
__int64 qword_140037FA8; // weak
__int16 word_140037FB0; // weak
_UNKNOWN unk_140037FB8; // weak
__int64 qword_140037FD0; // weak
__int64 qword_140037FD8; // weak
__int64 qword_140037FE0; // weak
__int16 word_140037FE8; // weak
_UNKNOWN unk_140037FF0; // weak
__int64 qword_140038008; // weak
__int64 qword_140038010; // weak
__int64 qword_140038018; // weak
__int16 word_140038020; // weak
_UNKNOWN unk_140038028; // weak
__int64 qword_140038040; // weak
__int64 qword_140038048; // weak
__int64 qword_140038050; // weak
__int16 word_140038058; // weak
char byte_140038060; // weak
__int64 qword_140038080; // weak
int dword_140038088; // weak
int dword_14003808C; // weak
char byte_140038090; // weak
struct _NPAGED_LOOKASIDE_LIST stru_1400380C0; // idb
struct _NPAGED_LOOKASIDE_LIST stru_140038140; // idb
_UNKNOWN unk_1400381C0; // weak
PVOID qword_1400381C8; // idb
struct _PAGED_LOOKASIDE_LIST stru_140038200; // idb
char byte_140038280; // weak
_UNKNOWN unk_140038288; // weak
__int64 qword_140038290; // weak
int dword_140038298; // weak
char byte_1400382A0; // weak
char byte_1400382A1; // weak
__int64 qword_1400382A8; // weak
struct _LIST_ENTRY stru_1400382B0; // idb
KSPIN_LOCK Lock; // idb
struct _FAST_MUTEX unk_1400382C8; // idb
_UNKNOWN unk_1400382D0; // weak
_UNKNOWN unk_1400382D8; // weak
struct _KEVENT stru_1400382E0; // idb
__int64 qword_140038300; // weak
__int64 qword_140038308; // weak
char byte_140038310; // weak
char byte_140038311; // weak
char byte_140038312; // weak
int dword_140038314; // weak
int dword_140038318; // weak
int dword_14003831C; // weak
struct _KEVENT stru_140038320; // idb
__int64 qword_140038338; // weak
int dword_140038340; // weak
_OWORD xmmword_140038350[9]; // idb
_OWORD xmmword_1400383E0[9]; // idb
char byte_140038470; // weak
char byte_140038471; // weak
__int64 qword_140038478; // weak
char byte_140038480; // weak
_UNKNOWN unk_140038490; // weak
__int64 qword_1400394A0; // weak
__int64 qword_1400394A8; // weak
_UNKNOWN unk_1400394B0; // weak
char byte_1400394B8; // weak
char byte_1400394B9; // weak
struct _PAGED_LOOKASIDE_LIST stru_1400394C0; // idb
char byte_140039540; // weak
char byte_140039548; // weak
const UNICODE_STRING stru_140039550; // idb
const UNICODE_STRING String1; // idb
char byte_140039570; // weak
LARGE_INTEGER Cookie; // idb
char byte_140039580; // weak
__int64 qword_140039588; // weak
struct _KEVENT stru_140039590; // idb
PDEVICE_OBJECT DeviceObject; // idb
int dword_1400395B0; // weak
struct _PAGED_LOOKASIDE_LIST stru_1400395C0; // idb
char byte_140039640; // weak
char byte_140039641; // weak
LARGE_INTEGER stru_140039648; // idb
struct _KMUTANT stru_140039660; // idb
int dword_140039698; // weak
__int64 qword_1400396A0; // weak


//----- (0000000140001000) ----------------------------------------------------
__int64 sub_140001000()
{
  ExInitializePagedLookasideList(&SListHead, 0i64, 0i64, 0, 0x20ui64, 0x61664349u, 0);
  return sub_14000A1C4((__int64)sub_1400277F0);
}

//----- (0000000140001050) ----------------------------------------------------
__int64 sub_140001050()
{
  ExInitializeNPagedLookasideList(&ListHead, 0i64, 0i64, PoolType, 0x38ui64, 0x616D4349u, 0);
  return sub_14000A1C4((__int64)sub_140027810);
}

//----- (00000001400010A0) ----------------------------------------------------
__int64 sub_1400010A0()
{
  sub_1400019E0((__int64)&unk_14002B880);
  return sub_14000A1C4((__int64)sub_140027830);
}

//----- (00000001400010C0) ----------------------------------------------------
__int64 sub_1400010C0()
{
  ExInitializePagedLookasideList(&stru_140030480, 0i64, 0i64, 0, 0x30ui64, 0x65644349u, 0);
  return sub_14000A1C4((__int64)sub_140027840);
}

//----- (0000000140001110) ----------------------------------------------------
__int64 sub_140001110()
{
  ExInitializePagedLookasideList(&stru_14002B980, 0i64, 0i64, 0, 0x28ui64, 0x65704349u, 0);
  return sub_14000A1C4((__int64)sub_140027860);
}

//----- (0000000140001160) ----------------------------------------------------
__int64 sub_140001160()
{
  signed __int64 v0; // rdi
  _QWORD *v1; // rbx

  v0 = 100i64;
  v1 = &unk_14002F7F8;
  do
  {
    sub_14000E024(v1 - 3);
    *(v1 - 1) = 0i64;
    *v1 = 0i64;
    v1 += 4;
    --v0;
  }
  while ( v0 );
  qword_140030460 = 0i64;
  return sub_14000A1C4((__int64)sub_140027880);
}
// 140030460: using guessed type __int64 qword_140030460;

//----- (00000001400011B0) ----------------------------------------------------
void sub_1400011B0()
{
  KeInitializeEvent(&stru_14002B048.Event, SynchronizationEvent, 0);
}

//----- (00000001400011D0) ----------------------------------------------------
__int64 sub_1400011D0()
{
  signed __int64 v0; // rcx
  _QWORD *v1; // rax

  v0 = 293i64;
  v1 = &unk_14002CA28;
  do
  {
    *(v1 - 3) = 0i64;
    *((_DWORD *)v1 - 4) = 2147483648;
    *(v1 - 1) = 0i64;
    *v1 = 0i64;
    v1[1] = 0i64;
    v1 += 5;
    --v0;
  }
  while ( v0 );
  qword_14002F7D8 = 0i64;
  return sub_14000A1C4((__int64)sub_140027890);
}
// 14002F7D8: using guessed type __int64 qword_14002F7D8;

//----- (0000000140001220) ----------------------------------------------------
void sub_140001220()
{
  KeInitializeEvent(&stru_14002B080.Event, SynchronizationEvent, 0);
}

//----- (0000000140001240) ----------------------------------------------------
void sub_140001240()
{
  KeInitializeEvent(&FastMutex.Event, SynchronizationEvent, 0);
}

//----- (0000000140001260) ----------------------------------------------------
__int64 sub_140001260()
{
  _QWORD *v0; // rax
  signed __int64 v1; // rcx

  v0 = &unk_14002BA00;
  v1 = 257i64;
  do
  {
    v0[1] = v0;
    *v0 = v0;
    v0 += 2;
    --v1;
  }
  while ( v1 );
  return sub_14000A1C4((__int64)sub_1400278E0);
}

//----- (0000000140001290) ----------------------------------------------------
__int64 sub_140001290()
{
  ExInitializePagedLookasideList(&stru_140030540, 0i64, 0i64, 0, 0x30ui64, 0x65644349u, 0);
  return sub_14000A1C4((__int64)sub_140027940);
}

//----- (00000001400012E0) ----------------------------------------------------
__int64 sub_1400012E0()
{
  sub_1400019E0((__int64)&unk_1400305C0);
  return sub_14000A1C4((__int64)sub_140027960);
}

//----- (0000000140001300) ----------------------------------------------------
__int64 sub_140001300()
{
  ExInitializePagedLookasideList(&stru_140030640, 0i64, 0i64, 0, 0x40ui64, 0x63664349u, 0);
  return sub_14000A1C4((__int64)sub_140027970);
}

//----- (0000000140001350) ----------------------------------------------------
__int64 sub_140001350()
{
  sub_14000576C((__m128i *)&Destination);
  return sub_14000A1C4((__int64)sub_140027990);
}

//----- (0000000140001370) ----------------------------------------------------
__int64 sub_140001370()
{
  ExInitializePagedLookasideList(&stru_140036A00, 0i64, 0i64, 0, 0x400ui64, 0x616C5352u, 0);
  return sub_14000A1C4((__int64)sub_1400279A0);
}

//----- (00000001400013C0) ----------------------------------------------------
__int64 sub_1400013C0()
{
  ExInitializePagedLookasideList(&stru_140036AC0, 0i64, 0i64, 0, 0x20ui64, 0x6C705352u, 0);
  return sub_14000A1C4((__int64)sub_1400279C0);
}

//----- (0000000140001410) ----------------------------------------------------
__int64 sub_140001410()
{
  sub_14000B81C((__int64)&qword_140036B40);
  return sub_14000A1C4((__int64)sub_1400279E0);
}
// 140036B40: using guessed type __int64 qword_140036B40;

//----- (0000000140001430) ----------------------------------------------------
__int64 sub_140001430()
{
  ExInitializePagedLookasideList(&stru_140036BC0, 0i64, 0i64, 0, 0x28ui64, 0x70695352u, 0);
  return sub_14000A1C4((__int64)sub_140027A10);
}

//----- (0000000140001480) ----------------------------------------------------
__int64 sub_140001480()
{
  ExInitializePagedLookasideList(&stru_140037C80, 0i64, 0i64, 0, 0x30ui64, 0x63705352u, 0);
  return sub_14000A1C4((__int64)sub_140027A30);
}

//----- (00000001400014D0) ----------------------------------------------------
__int64 sub_1400014D0()
{
  _QWORD *v0; // rax
  signed __int64 v1; // rcx

  v0 = &unk_140036C50;
  v1 = 257i64;
  do
  {
    v0[1] = v0;
    *v0 = v0;
    v0 += 2;
    --v1;
  }
  while ( v1 );
  qword_140037C68 = (__int64)&qword_140037C60;
  qword_140037C60 = (__int64)&qword_140037C60;
  FltInitializePushLock(&unk_140037C70);
  return sub_14000A1C4((__int64)sub_140027A50);
}
// 1400214F6: using guessed type __int64 __fastcall FltInitializePushLock(_QWORD);
// 140037C60: using guessed type __int64 qword_140037C60;
// 140037C68: using guessed type __int64 qword_140037C68;

//----- (0000000140001530) ----------------------------------------------------
__int64 sub_140001530()
{
  ExInitializeNPagedLookasideList(&stru_140037DC0, 0i64, 0i64, PoolType, 0x10ui64, 0x63724349u, 0);
  return sub_14000A1C4((__int64)sub_140027A70);
}

//----- (0000000140001580) ----------------------------------------------------
__int64 sub_140001580()
{
  sub_140020700((__int64)&unk_140037D80);
  return sub_14000A1C4((__int64)sub_140027A90);
}

//----- (00000001400015A0) ----------------------------------------------------
__int64 sub_1400015A0()
{
  KeInitializeEvent(&Event, 0, 0);
  return sub_14000A1C4((__int64)sub_140027AA0);
}

//----- (00000001400015D0) ----------------------------------------------------
void sub_1400015D0()
{
  KeInitializeEvent(&stru_14002B170.Event, SynchronizationEvent, 0);
}

//----- (00000001400015F0) ----------------------------------------------------
__int64 sub_1400015F0()
{
  ExInitializePagedLookasideList(&stru_140037E80, 0i64, 0i64, 0, 0x668ui64, 0x4D784349u, 0);
  return sub_14000A1C4((__int64)sub_140027AE0);
}

//----- (0000000140001640) ----------------------------------------------------
__int64 sub_140001640()
{
  ExInitializePagedLookasideList(&stru_140037F00, 0i64, 0i64, 0, 0x18ui64, 0x4E784349u, 0);
  return sub_14000A1C4((__int64)sub_140027B00);
}

//----- (0000000140001690) ----------------------------------------------------
__int64 sub_140001690()
{
  qword_140037F98 = 0i64;
  qword_140037FA0 = 0i64;
  qword_140037FA8 = 0i64;
  word_140037FB0 = 0;
  return sub_14000A1C4((__int64)sub_140027B20);
}
// 140037F98: using guessed type __int64 qword_140037F98;
// 140037FA0: using guessed type __int64 qword_140037FA0;
// 140037FA8: using guessed type __int64 qword_140037FA8;
// 140037FB0: using guessed type __int16 word_140037FB0;

//----- (00000001400016C0) ----------------------------------------------------
__int64 sub_1400016C0()
{
  qword_140038008 = 0i64;
  qword_140038010 = 0i64;
  qword_140038018 = 0i64;
  word_140038020 = 0;
  return sub_14000A1C4((__int64)sub_140027B30);
}
// 140038008: using guessed type __int64 qword_140038008;
// 140038010: using guessed type __int64 qword_140038010;
// 140038018: using guessed type __int64 qword_140038018;
// 140038020: using guessed type __int16 word_140038020;

//----- (00000001400016F0) ----------------------------------------------------
__int64 sub_1400016F0()
{
  qword_140037FD0 = 0i64;
  qword_140037FD8 = 0i64;
  qword_140037FE0 = 0i64;
  word_140037FE8 = 0;
  return sub_14000A1C4((__int64)sub_140027B40);
}
// 140037FD0: using guessed type __int64 qword_140037FD0;
// 140037FD8: using guessed type __int64 qword_140037FD8;
// 140037FE0: using guessed type __int64 qword_140037FE0;
// 140037FE8: using guessed type __int16 word_140037FE8;

//----- (0000000140001720) ----------------------------------------------------
__int64 sub_140001720()
{
  qword_140038040 = 0i64;
  qword_140038048 = 0i64;
  qword_140038050 = 0i64;
  word_140038058 = 0;
  return sub_14000A1C4((__int64)sub_140027B50);
}
// 140038040: using guessed type __int64 qword_140038040;
// 140038048: using guessed type __int64 qword_140038048;
// 140038050: using guessed type __int64 qword_140038050;
// 140038058: using guessed type __int16 word_140038058;

//----- (0000000140001750) ----------------------------------------------------
__int64 sub_140001750()
{
  ExInitializeNPagedLookasideList(&stru_1400380C0, 0i64, 0i64, PoolType, 0x108ui64, 0x63664349u, 0);
  return sub_14000A1C4((__int64)sub_140027B60);
}

//----- (00000001400017A0) ----------------------------------------------------
char sub_1400017A0()
{
  UNICODE_STRING *v0; // rax
  char result; // al
  int v2; // [rsp+30h] [rbp+8h]

  v0 = sub_14000589C();
  result = sub_1400095B8(v0, L"HighPriorityPostpone", &v2);
  if ( result )
  {
    result = v2;
    dword_14003808C = v2;
  }
  return result;
}
// 1400254B0: using guessed type wchar_t aHighprioritypo[21];
// 14003808C: using guessed type int dword_14003808C;

//----- (00000001400017D0) ----------------------------------------------------
__int64 sub_1400017D0()
{
  ExInitializeNPagedLookasideList(&stru_140038140, 0i64, 0i64, PoolType, 0x10ui64, 0x70664349u, 0);
  return sub_14000A1C4((__int64)sub_140027B80);
}

//----- (0000000140001820) ----------------------------------------------------
__int64 sub_140001820()
{
  return sub_14000A1C4((__int64)sub_140027BA0);
}

//----- (0000000140001830) ----------------------------------------------------
__int64 sub_140001830()
{
  FltInitializePushLock(&unk_140038288);
  return sub_14000A1C4((__int64)sub_140027BE0);
}
// 1400214F6: using guessed type __int64 __fastcall FltInitializePushLock(_QWORD);

//----- (0000000140001850) ----------------------------------------------------
__int64 sub_140001850()
{
  ExInitializePagedLookasideList(&stru_1400394C0, 0i64, 0i64, 0, 0x40ui64, 0x63704349u, 0);
  return sub_14000A1C4((__int64)sub_140027BF0);
}

//----- (00000001400018A0) ----------------------------------------------------
__int64 sub_1400018A0()
{
  _QWORD *v0; // rax
  signed __int64 v1; // rcx

  v0 = &unk_140038490;
  v1 = 257i64;
  do
  {
    v0[1] = v0;
    *v0 = v0;
    v0 += 2;
    --v1;
  }
  while ( v1 );
  qword_1400394A8 = (__int64)&qword_1400394A0;
  qword_1400394A0 = (__int64)&qword_1400394A0;
  FltInitializePushLock(&unk_1400394B0);
  return sub_14000A1C4((__int64)sub_140027C10);
}
// 1400214F6: using guessed type __int64 __fastcall FltInitializePushLock(_QWORD);
// 1400394A0: using guessed type __int64 qword_1400394A0;
// 1400394A8: using guessed type __int64 qword_1400394A8;

//----- (0000000140001900) ----------------------------------------------------
__int64 sub_140001900()
{
  return sub_14000A1C4((__int64)sub_140027C30);
}

//----- (0000000140001910) ----------------------------------------------------
__int64 sub_140001910()
{
  unknown_libname_1(&DeviceObject);
  return sub_14000A1C4((__int64)sub_140027C70);
}
// 1400116C4: using guessed type __int64 __fastcall unknown_libname_1(_QWORD);

//----- (0000000140001930) ----------------------------------------------------
void sub_140001930()
{
  KeInitializeEvent(&stru_14002B6A8.Event, SynchronizationEvent, 0);
}

//----- (0000000140001950) ----------------------------------------------------
void sub_140001950()
{
  KeInitializeEvent(&stru_14002B6E0.Event, SynchronizationEvent, 0);
}

//----- (0000000140001970) ----------------------------------------------------
__int64 sub_140001970()
{
  ExInitializePagedLookasideList(&stru_1400395C0, 0i64, 0i64, 0, 0x30ui64, 0x63745352u, 0);
  return sub_14000A1C4((__int64)sub_140027C80);
}

//----- (00000001400019C0) ----------------------------------------------------
void sub_1400019C0()
{
  KeInitializeEvent(&stru_14002B748.Event, SynchronizationEvent, 0);
}

//----- (00000001400019E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400019E0(__int64 a1)
{
  _QWORD *v1; // rbx
  _QWORD *result; // rax

  *(_QWORD *)(a1 + 24) = 0i64;
  *(_DWORD *)(a1 + 32) = 0;
  v1 = (_QWORD *)a1;
  *(_DWORD *)(a1 + 16) = 1;
  KeInitializeEvent((PRKEVENT)(a1 + 40), SynchronizationEvent, 0);
  result = v1;
  v1[1] = v1;
  *v1 = v1;
  return result;
}

//----- (0000000140001A20) ----------------------------------------------------
__int64 __fastcall sub_140001A20(__int64 a1, int a2)
{
  __int64 v2; // rbx
  int v3; // edi
  __int64 v4; // rax
  _QWORD *v5; // rax

  ++ListHead.L.TotalAllocates;
  v2 = a1;
  v3 = a2;
  v4 = (__int64)ExpInterlockedPopEntrySList(&ListHead.L.ListHead);
  if ( !v4 )
  {
    ++ListHead.L.AllocateMisses;
    v4 = sub_140021A40((__int64 (*)(void))ListHead.L.Allocate);
  }
  *(_QWORD *)v2 = v4;
  if ( v4 )
  {
    *(_QWORD *)(v4 + 8) = 0i64;
    *(_DWORD *)(v4 + 16) = 0;
    *(_DWORD *)v4 = 1;
    KeInitializeEvent((PRKEVENT)(v4 + 24), SynchronizationEvent, 0);
  }
  *(_QWORD *)(v2 + 16) = 0i64;
  *(_DWORD *)(v2 + 8) = v3;
  RtlInitUnicodeString((PUNICODE_STRING)(v2 + 24), 0i64);
  *(_QWORD *)(v2 + 40) = 0i64;
  v5 = (_QWORD *)(v2 + 72);
  *(_QWORD *)(v2 + 48) = 0i64;
  *(_DWORD *)(v2 + 56) = 0;
  *(_QWORD *)(v2 + 64) = 0i64;
  *(_DWORD *)(v2 + 12) = 0;
  v5[1] = v5;
  *v5 = v5;
  return v2;
}

//----- (0000000140001AEC) ----------------------------------------------------
__int64 __fastcall sub_140001AEC(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)a1 = 0i64;
  result = a1;
  *(_BYTE *)(a1 + 8) &= 0xF8u;
  return result;
}

//----- (0000000140001AF8) ----------------------------------------------------
_QWORD *__fastcall sub_140001AF8(_QWORD *a1, void *a2, __m128i *a3, __int64 a4, __m128i *a5)
{
  _QWORD *v5; // rsi
  __int64 v6; // rdi
  __m128i *v7; // rbx
  _QWORD *result; // rax
  __m128i v9; // [rsp+20h] [rbp-18h]

  a1[1] = a1;
  v5 = a1;
  *a1 = a1;
  v6 = a4;
  a1[2] = a2;
  v7 = a3;
  ObfReferenceObject(a2);
  _mm_storeu_si128((__m128i *)(v5 + 3), *v7);
  RtlInitUnicodeString((PUNICODE_STRING)v7, 0i64);
  v5[5] = v6;
  _mm_storeu_si128((__m128i *)v5 + 3, *a5);
  v9.m128i_i32[2] = _InterlockedIncrement(&dword_14002B044);
  v9.m128i_i64[0] = MEMORY[0xFFFFF78000000014];
  result = v5;
  _mm_storeu_si128((__m128i *)v5 + 4, v9);
  return result;
}
// 14002B044: using guessed type int dword_14002B044;

//----- (0000000140001B98) ----------------------------------------------------
void __fastcall sub_140001B98(__int64 a1)
{
  struct _SLIST_ENTRY **v1; // rbx
  struct _SLIST_ENTRY *v2; // rbx

  v1 = (struct _SLIST_ENTRY **)a1;
  sub_140001E70(a1);
  v2 = *v1;
  if ( v2 )
  {
    ++ListHead.L.TotalFrees;
    if ( ExQueryDepthSList(&ListHead.L.ListHead) < ListHead.L.Depth )
    {
      ExpInterlockedPushEntrySList(&ListHead.L.ListHead, v2);
    }
    else
    {
      ++ListHead.L.FreeMisses;
      sub_140021A40((__int64 (*)(void))ListHead.L.Free);
    }
  }
}

//----- (0000000140001C08) ----------------------------------------------------
void __fastcall sub_140001C08(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rcx

  v1 = a1;
  sub_14000E5E8(0x6E634349u, a1 + 24);
  v2 = *(void **)(v1 + 16);
  if ( v2 )
    ObfDereferenceObject(v2);
}

//----- (0000000140001C3C) ----------------------------------------------------
_QWORD *__fastcall sub_140001C3C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rdi
  __int64 v5; // r14
  __int64 v6; // r15
  __int64 v7; // rbp
  __int64 v8; // rbx
  struct _FAST_MUTEX *v9; // rsi
  int v10; // eax
  __int64 v11; // rcx
  _QWORD *v12; // rbp

  v4 = 0i64;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  if ( *(_DWORD *)(a1 + 8) )
  {
    v9 = *(struct _FAST_MUTEX **)a1;
    if ( *(_QWORD *)a1 )
    {
      ExAcquireFastMutex(*(PFAST_MUTEX *)a1);
      v10 = *(_DWORD *)(v8 + 12);
      if ( v10 == 1 )
      {
        v11 = v8;
        if ( v7 == *(_QWORD *)(v8 + 16) )
        {
          v12 = sub_140001CEC(v8, v6, v5);
          if ( !v12 )
            sub_140001E70(v8);
          v4 = v12;
          goto LABEL_11;
        }
      }
      else
      {
        if ( !v10 )
        {
LABEL_11:
          ExReleaseFastMutex(v9);
          return v4;
        }
        v11 = v8;
      }
      sub_140001E70(v11);
      goto LABEL_11;
    }
  }
  return 0i64;
}

//----- (0000000140001CEC) ----------------------------------------------------
_QWORD *__fastcall sub_140001CEC(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rbx
  _QWORD *result; // rax
  _QWORD *v7; // rdx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a2 != *(_QWORD *)(a1 + 64) )
    return 0i64;
  ++SListHead.L.TotalAllocates;
  result = ExpInterlockedPopEntrySList(&SListHead.L.ListHead);
  if ( !result )
  {
    ++SListHead.L.AllocateMisses;
    result = (_QWORD *)sub_140021A40((__int64 (*)(void))SListHead.L.Allocate);
    if ( !result )
    {
      LODWORD(BugCheckParameter3) = -1073741670;
      sub_140006BB4(0x29Aui64, 0x3CAui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
      return 0i64;
    }
  }
  result[2] = v4;
  result[3] = v3;
  v7 = *(_QWORD **)(v5 + 80);
  if ( *v7 != v5 + 72 )
    __fastfail(3u);
  *result = v5 + 72;
  result[1] = v7;
  *v7 = result;
  *(_QWORD *)(v5 + 80) = result;
  *(_QWORD *)(v5 + 64) += v3;
  return result;
}

//----- (0000000140001DC0) ----------------------------------------------------
_QWORD *__fastcall sub_140001DC0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rdi
  __int64 v5; // r14
  __int64 v6; // r15
  __int64 v7; // rbp
  __int64 v8; // rbx
  struct _FAST_MUTEX *v9; // rsi
  int v10; // eax
  __int64 v11; // rcx
  _QWORD *v12; // rbp

  v4 = 0i64;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  if ( *(_DWORD *)(a1 + 8) )
  {
    v9 = *(struct _FAST_MUTEX **)a1;
    if ( *(_QWORD *)a1 )
    {
      ExAcquireFastMutex(*(PFAST_MUTEX *)a1);
      v10 = *(_DWORD *)(v8 + 12);
      if ( v10 == 2 )
      {
        v11 = v8;
        if ( v7 == *(_QWORD *)(v8 + 16) )
        {
          v12 = sub_140001CEC(v8, v6, v5);
          if ( !v12 )
            sub_140001E70(v8);
          v4 = v12;
          goto LABEL_11;
        }
      }
      else
      {
        if ( !v10 )
        {
LABEL_11:
          ExReleaseFastMutex(v9);
          return v4;
        }
        v11 = v8;
      }
      sub_140001E70(v11);
      goto LABEL_11;
    }
  }
  return 0i64;
}

//----- (0000000140001E70) ----------------------------------------------------
void __fastcall sub_140001E70(__int64 a1)
{
  __int64 v1; // rbx
  struct _SLIST_ENTRY **v2; // rsi
  PSLIST_ENTRY v3; // rax
  struct _SLIST_ENTRY **v4; // rcx
  struct _SLIST_ENTRY *v5; // rdi
  void *v6; // rcx

  v1 = a1;
  if ( *(_DWORD *)(a1 + 12) != 3 )
  {
    *(_DWORD *)(a1 + 12) = 3;
    v2 = (struct _SLIST_ENTRY **)(a1 + 72);
    while ( 1 )
    {
      v5 = *v2;
      if ( *v2 == (struct _SLIST_ENTRY *)v2 )
        break;
      v3 = v5->Next;
      if ( *(&v5->Next->Next + 1) != v5 || (v4 = (struct _SLIST_ENTRY **)*((_QWORD *)&v5->Next + 1), *v4 != v5) )
        __fastfail(3u);
      *v4 = v3;
      *((_QWORD *)&v3->Next + 1) = v4;
      ++SListHead.L.TotalFrees;
      if ( ExQueryDepthSList(&SListHead.L.ListHead) < SListHead.L.Depth )
      {
        ExpInterlockedPushEntrySList(&SListHead.L.ListHead, v5);
      }
      else
      {
        ++SListHead.L.FreeMisses;
        sub_140021A40((__int64 (*)(void))SListHead.L.Free);
      }
    }
    v6 = *(void **)(v1 + 16);
    if ( v6 )
    {
      ObfDereferenceObject(v6);
      *(_QWORD *)(v1 + 16) = 0i64;
    }
    sub_14000E5E8(0x6E634349u, v1 + 24);
    *(_QWORD *)(v1 + 40) = 0i64;
    *(_QWORD *)(v1 + 48) = 0i64;
    *(_DWORD *)(v1 + 56) = 0;
    *(_QWORD *)(v1 + 64) = 0i64;
  }
}

//----- (0000000140001F64) ----------------------------------------------------
bool __fastcall sub_140001F64(__int64 a1, __int64 a2, const UNICODE_STRING *a3, __int64 a4, __int64 *a5)
{
  __int64 v5; // r10
  __int64 v6; // r11
  __int64 v7; // rdx
  __int64 v8; // rcx
  bool result; // al

  v5 = a1;
  result = 0;
  if ( *(_QWORD *)(a1 + 16) == a2 )
  {
    v6 = *(_QWORD *)(a1 + 48);
    v7 = *a5;
    if ( (*(_QWORD *)(a1 + 48) - *a5 < 0 || v6 == v7 && *(_DWORD *)(a1 + 56) - *((_DWORD *)a5 + 2) < 0)
      && v7 - v6 <= 10000000 )
    {
      v8 = *(_QWORD *)(a1 + 64);
      if ( (v7 - v8 < 0 || v7 == v8 && *((_DWORD *)a5 + 2) - *(_DWORD *)(v5 + 72) < 0)
        && a4 == *(_QWORD *)(v5 + 40)
        && !RtlCompareUnicodeString(a3, (PCUNICODE_STRING)(v5 + 24), 1u) )
      {
        result = 1;
      }
    }
  }
  return result;
}

//----- (0000000140001FF4) ----------------------------------------------------
__int64 **__fastcall sub_140001FF4(__int64 a1, unsigned int a2)
{
  unsigned int v2; // esi
  __int64 v3; // rdi
  signed __int64 v4; // r15
  __int64 v5; // r14
  __int64 *v6; // rdx
  __int64 **v7; // rcx
  __int64 ***v8; // rax
  __int64 **v9; // rax
  __int64 v10; // rax
  __int64 *v11; // rbx
  __int64 **result; // rax
  __int64 *v13; // [rsp+20h] [rbp-10h]
  __int64 **v14; // [rsp+28h] [rbp-8h]

  v2 = a2;
  v14 = &v13;
  v3 = a1;
  v13 = (__int64 *)&v13;
  _InterlockedIncrement(&dword_14002B044);
  v4 = 10000i64 * a2;
  v5 = MEMORY[0xFFFFF78000000014];
  ExAcquireFastMutex((PFAST_MUTEX)(a1 + 16));
  v6 = *(__int64 **)v3;
  while ( v6 != (__int64 *)v3 )
  {
    v7 = (__int64 **)v6;
    v6 = (__int64 *)*v6;
    if ( !v2 || v5 - (signed __int64)v7[8] > v4 )
    {
      if ( (__int64 **)v6[1] != v7
        || (v8 = (__int64 ***)v7[1], *v8 != v7)
        || (*v8 = (__int64 **)v6, v6[1] = (__int64)v8, v9 = v14, *v14 != (__int64 *)&v13) )
      {
LABEL_15:
        __fastfail(3u);
      }
      v7[1] = (__int64 *)v14;
      *v7 = (__int64 *)&v13;
      *v9 = (__int64 *)v7;
      v14 = v7;
    }
  }
  ExReleaseFastMutex((PFAST_MUTEX)(v3 + 16));
  while ( 1 )
  {
    v11 = v13;
    result = &v13;
    if ( v13 == (__int64 *)&v13 )
      return result;
    if ( (__int64 **)v13[1] != &v13 )
      goto LABEL_15;
    v10 = *v13;
    if ( *(__int64 **)(*v13 + 8) != v13 )
      goto LABEL_15;
    v13 = (__int64 *)*v13;
    *(_QWORD *)(v10 + 8) = &v13;
    sub_140001C08((__int64)v11);
    sub_14000AB20(v11);
  }
}
// 14002B044: using guessed type int dword_14002B044;

//----- (0000000140002124) ----------------------------------------------------
void __fastcall sub_140002124(struct _FAST_MUTEX **a1, __int64 a2, int a3, unsigned __int64 a4)
{
  struct _FAST_MUTEX *v4; // rdi
  unsigned __int64 v5; // r14
  int v6; // esi
  __int64 v7; // rbp
  __int64 v8; // rbx
  char v9; // al
  unsigned __int64 v10; // r8
  __int64 v11; // r9

  if ( a2 )
  {
    v4 = *a1;
    v5 = a4;
    v6 = a3;
    v7 = a2;
    v8 = (__int64)a1;
    if ( *a1 )
    {
      ExAcquireFastMutex(v4);
      v9 = 0;
      if ( v6 >= 0 )
      {
        v10 = v5;
      }
      else
      {
        if ( v6 != -1073741807 && v6 != -1071906812 )
        {
LABEL_9:
          if ( v9 )
          {
            v11 = *(_QWORD *)(v8 + 40);
            if ( *(_QWORD *)(v8 + 64) != v11 || *(_QWORD *)(v8 + 72) != v8 + 72 )
              goto LABEL_14;
            sub_1400021FC((__int64)&unk_14002B880, *(void **)(v8 + 16), (__m128i *)(v8 + 24), v11, (__m128i *)(v8 + 48));
          }
          sub_140001E70(v8);
LABEL_14:
          ExReleaseFastMutex(v4);
          return;
        }
        v10 = 0i64;
      }
      v9 = sub_1400022DC(v8, v7, v10);
      goto LABEL_9;
    }
  }
}

//----- (00000001400021FC) ----------------------------------------------------
void __fastcall sub_1400021FC(__int64 a1, void *a2, __m128i *a3, __int64 a4, __m128i *a5)
{
  void *v5; // rbp
  __int64 v6; // rbx
  __m128i *v7; // rdi
  __int64 v8; // rsi
  _QWORD *v9; // rax
  _QWORD *v10; // rdi
  __int64 v11; // rax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]

  v5 = a2;
  v6 = a4;
  v7 = a3;
  v8 = a1;
  sub_140001FF4(a1, 0x1388u);
  v9 = sub_14000AB04(0x50ui64, PagedPool);
  if ( v9 )
    v10 = sub_140001AF8(v9, v5, v7, v6, a5);
  else
    v10 = 0i64;
  if ( v10 )
  {
    ExAcquireFastMutex((PFAST_MUTEX)(v8 + 16));
    v11 = *(_QWORD *)v8;
    if ( *(_QWORD *)(*(_QWORD *)v8 + 8i64) != v8 )
      __fastfail(3u);
    *v10 = v11;
    v10[1] = v8;
    *(_QWORD *)(v11 + 8) = v10;
    *(_QWORD *)v8 = v10;
    ExReleaseFastMutex((PFAST_MUTEX)(v8 + 16));
  }
  else
  {
    LODWORD(BugCheckParameter3) = -1073741670;
    sub_140006BB4(0x29Aui64, 0x12Fui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
  }
}

//----- (00000001400022DC) ----------------------------------------------------
char __fastcall sub_1400022DC(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  struct _SLIST_ENTRY *v3; // rbx
  unsigned __int64 v4; // rax
  char v5; // di
  __int64 v6; // rdx
  PSLIST_ENTRY v7; // rax
  struct _SLIST_ENTRY **v8; // rcx

  v3 = (struct _SLIST_ENTRY *)a2;
  if ( !a2 || *(_DWORD *)(a1 + 12) == 3 )
    return 0;
  v4 = *(_QWORD *)(a2 + 24);
  v5 = 1;
  if ( v4 < a3 )
    goto LABEL_18;
  if ( v4 <= a3 )
    goto LABEL_8;
  v6 = *(_QWORD *)(a2 + 16);
  if ( v6 + v4 != *(_QWORD *)(a1 + 64) )
LABEL_18:
    v5 = 0;
  else
    *(_QWORD *)(a1 + 64) = v6 + a3;
LABEL_8:
  v7 = v3->Next;
  if ( *(&v3->Next->Next + 1) != v3 || (v8 = (struct _SLIST_ENTRY **)*((_QWORD *)&v3->Next + 1), *v8 != v3) )
    __fastfail(3u);
  *v8 = v7;
  *((_QWORD *)&v7->Next + 1) = v8;
  ++SListHead.L.TotalFrees;
  if ( ExQueryDepthSList(&SListHead.L.ListHead) < SListHead.L.Depth )
  {
    ExpInterlockedPushEntrySList(&SListHead.L.ListHead, v3);
  }
  else
  {
    ++SListHead.L.FreeMisses;
    sub_140021A40((__int64 (*)(void))SListHead.L.Free);
  }
  return v5;
}

//----- (00000001400023A8) ----------------------------------------------------
void __fastcall sub_1400023A8(__int64 a1, char a2, __int64 a3, struct _FILE_OBJECT *a4, __int64 a5)
{
  char v5; // bl
  __int64 v6; // r15
  __int64 v7; // rax
  char v8; // si
  int v9; // ebp
  char v10; // r14
  char v11; // di
  __int64 v12; // rax

  if ( a4 )
  {
    v5 = 0;
    v6 = a1;
    if ( byte_14002B040 )
    {
      v7 = *(_QWORD *)(a3 + 8);
      v8 = 1;
      v9 = a2 & 6;
      v10 = a2 & 1;
      if ( v7 & 0xFFFFFFFFFFFFFFFCui64 || (v11 = 1, v7 == 1) )
        v11 = 0;
      if ( !v10 && !(a2 & 6) )
        goto LABEL_21;
      if ( !v11 )
      {
        if ( (signed int)sub_140016BA0(a4, (_BYTE *)a5) < 0 )
          return;
        v12 = *(_QWORD *)(a5 + 8);
        *(_QWORD *)v6 = v12;
        if ( !v12 )
          v11 = 1;
      }
      if ( !v10 || v11 )
LABEL_21:
        v8 = 0;
      if ( v9 )
      {
        if ( v11 )
          v5 = 2;
      }
      *(_BYTE *)(v6 + 8) = v5 | (v8 | *(_BYTE *)(v6 + 8) & 0xFE) & 0xFD;
    }
  }
}
// 14002B040: using guessed type char byte_14002B040;

//----- (000000014000247C) ----------------------------------------------------
void __fastcall sub_14000247C(PFAST_MUTEX *a1, __int64 a2, __m128i *a3, char a4)
{
  struct _FAST_MUTEX *v4; // rbx
  char v5; // r14
  __m128i *v6; // r15
  __int64 v7; // r12
  __int64 v8; // rdi
  signed int v9; // esi
  __m128i v10; // xmm0
  void *v11; // rcx
  __m128i v12; // xmm0
  ULONG_PTR BugCheckParameter2; // [rsp+20h] [rbp-50h]
  __m128i i; // [rsp+30h] [rbp-40h]
  __m128i v15; // [rsp+40h] [rbp-30h]
  __int128 v16; // [rsp+50h] [rbp-20h]
  char v17; // [rsp+60h] [rbp-10h]

  v4 = *a1;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = (__int64)a1;
  if ( *a1 )
  {
    ExAcquireFastMutex(*a1);
    if ( (*(_BYTE *)(v7 + 8) & 5) == 5 )
    {
      v9 = 1;
    }
    else
    {
      v9 = 2;
      if ( !(*(_BYTE *)(v7 + 8) & 2) || !v5 )
        goto LABEL_12;
    }
    if ( !*(_DWORD *)(v8 + 12) )
    {
      v10 = *v6;
      for ( i = *v6; ; v10 = i )
      {
        _mm_store_si128((__m128i *)&v16, v10);
        FsRtlDissectName(&v16, &v17, &i);
        if ( !i.m128i_i16[0] )
          break;
      }
      LODWORD(BugCheckParameter2) = 593;
      if ( sub_14000E514(0x6E634349u, (PUNICODE_STRING)(v8 + 24), (unsigned __int16 *)&v17, 0x29Au, BugCheckParameter2) )
      {
        *(_QWORD *)(v8 + 40) = *(_QWORD *)v7;
        v11 = (void *)__readgsqword(0x188u);
        *(_QWORD *)(v8 + 16) = v11;
        ObfReferenceObject(v11);
        v15.m128i_i32[2] = _InterlockedIncrement(&dword_14002B044);
        v15.m128i_i64[0] = MEMORY[0xFFFFF78000000014];
        v12 = v15;
        *(_DWORD *)(v8 + 12) = v9;
        _mm_storeu_si128((__m128i *)(v8 + 48), v12);
LABEL_13:
        ExReleaseFastMutex(v4);
        return;
      }
    }
LABEL_12:
    sub_140001E70(v8);
    goto LABEL_13;
  }
}
// 140028258: using guessed type __int64 __fastcall FsRtlDissectName(_QWORD, _QWORD, _QWORD);
// 14002B044: using guessed type int dword_14002B044;

//----- (00000001400025E0) ----------------------------------------------------
char __fastcall sub_1400025E0(PFAST_MUTEX *a1, struct _FILE_OBJECT *a2, __int64 a3)
{
  struct _FAST_MUTEX *v3; // rsi
  char v4; // di
  __int64 v5; // rbp
  struct _FILE_OBJECT *v6; // r14
  __int64 v7; // rbx
  int v8; // ecx
  void *v9; // rdx
  int v10; // ecx
  __int64 v11; // rsi
  struct _FAST_MUTEX *v12; // rbp
  __int64 v14; // r9

  v3 = *a1;
  v4 = 0;
  v5 = a3;
  v6 = a2;
  v7 = (__int64)a1;
  if ( !*a1 )
    return 0;
  ExAcquireFastMutex(*a1);
  v8 = *(_DWORD *)(v7 + 12);
  if ( v8 == 3 )
  {
LABEL_18:
    ExReleaseFastMutex(v3);
    return 0;
  }
  v9 = (void *)__readgsqword(0x188u);
  if ( v9 != *(void **)(v7 + 16) )
    goto LABEL_17;
  v10 = v8 - 1;
  if ( !v10 )
  {
    v14 = *(_QWORD *)(v7 + 40);
    if ( *(_DWORD *)(v7 + 8) != 1 || *(_QWORD *)(v7 + 64) == v14 )
      sub_1400021FC((__int64)&unk_14002B880, v9, (__m128i *)(v7 + 24), v14, (__m128i *)(v7 + 48));
    goto LABEL_17;
  }
  if ( v10 != 1 )
  {
LABEL_17:
    sub_140001E70(v7);
    goto LABEL_18;
  }
  ExReleaseFastMutex(v3);
  v11 = 0i64;
  if ( (signed int)sub_140016BA0(v6, (_BYTE *)v5) >= 0 )
    v11 = *(_QWORD *)(v5 + 8);
  v12 = *(struct _FAST_MUTEX **)v7;
  ExAcquireFastMutex(*(PFAST_MUTEX *)v7);
  if ( *(_DWORD *)(v7 + 12) == 2 && v11 && (*(_DWORD *)(v7 + 8) != 1 || *(_QWORD *)(v7 + 64) >= v11) )
    v4 = sub_14000273C(
           (__int64)&unk_14002B880,
           *(_QWORD *)(v7 + 16),
           (const UNICODE_STRING *)(v7 + 24),
           v11,
           (__int64 *)(v7 + 48));
  sub_140001E70(v7);
  ExReleaseFastMutex(v12);
  return v4;
}

//----- (000000014000273C) ----------------------------------------------------
char __fastcall sub_14000273C(__int64 a1, __int64 a2, const UNICODE_STRING *a3, __int64 a4, __int64 *a5)
{
  __int64 v5; // r13
  __int64 v6; // r15
  const UNICODE_STRING *v7; // r12
  __int64 v8; // r14
  void *v9; // rsi
  _QWORD *v10; // rdi
  bool v11; // al
  _QWORD *v12; // rcx
  _QWORD *v14; // rax

  v5 = a2;
  v6 = a4;
  v7 = a3;
  v8 = a1;
  sub_140001FF4(a1, 0x1388u);
  v9 = 0i64;
  ExAcquireFastMutex((PFAST_MUTEX)(v8 + 16));
  v10 = *(_QWORD **)v8;
  if ( *(_QWORD *)v8 != v8 )
  {
    while ( 1 )
    {
      v11 = sub_140001F64((__int64)v10, v5, v7, v6, a5);
      v12 = (_QWORD *)*v10;
      if ( v11 )
        break;
      v10 = (_QWORD *)*v10;
      if ( v12 == (_QWORD *)v8 )
        goto LABEL_4;
    }
    v9 = v10;
    if ( (_QWORD *)v12[1] != v10 || (v14 = (_QWORD *)v10[1], (_QWORD *)*v14 != v10) )
      __fastfail(3u);
    *v14 = v12;
    v12[1] = v14;
  }
LABEL_4:
  ExReleaseFastMutex((PFAST_MUTEX)(v8 + 16));
  if ( !v9 )
    return 0;
  sub_140001C08((__int64)v9);
  sub_14000AB20(v9);
  return 1;
}

//----- (0000000140002824) ----------------------------------------------------
void __fastcall sub_140002824(struct _FAST_MUTEX **a1, __int64 a2, int a3, unsigned __int64 a4)
{
  struct _FAST_MUTEX *v4; // rdi
  unsigned __int64 v5; // r14
  int v6; // esi
  __int64 v7; // rbp
  __int64 v8; // rbx
  char v9; // al
  unsigned __int64 v10; // r8

  if ( !a2 )
    return;
  v4 = *a1;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = (__int64)a1;
  if ( !*a1 )
    return;
  ExAcquireFastMutex(v4);
  v9 = 0;
  if ( v6 >= 0 )
  {
    v10 = v5;
    goto LABEL_7;
  }
  if ( v6 == -1071906812 )
  {
    v10 = 0i64;
LABEL_7:
    v9 = sub_1400022DC(v8, v7, v10);
  }
  if ( !v9 )
    sub_140001E70(v8);
  ExReleaseFastMutex(v4);
}

//----- (00000001400028C0) ----------------------------------------------------
LONG sub_1400028C0()
{
  UNICODE_STRING *v0; // rax
  bool v1; // zf
  signed int v2; // ecx
  LONG result; // eax
  const wchar_t *v4; // rcx
  int v5; // [rsp+30h] [rbp+8h]

  v0 = sub_14000589C();
  v1 = sub_1400095B8(v0, L"CopyDetect", &v5) == 0;
  v2 = 1;
  result = dword_140035180;
  if ( !v1 )
    v2 = v5;
  byte_14002B040 = v2 != 0;
  if ( v2 )
  {
    if ( !(dword_140035180 & 1) )
      return result;
    v4 = L"Copy detection enabled.";
  }
  else
  {
    if ( !(dword_140035180 & 1) )
      return result;
    v4 = L"Copy detection disabled.";
  }
  return sub_140007A38((__int64)v4);
}
// 140021F00: using guessed type wchar_t aCopydetect[11];
// 140021F20: using guessed type wchar_t aCopyDetectionD[25];
// 140021F60: using guessed type wchar_t aCopyDetectionE[24];
// 14002B040: using guessed type char byte_14002B040;
// 140035180: using guessed type int dword_140035180;

//----- (0000000140002920) ----------------------------------------------------
void __fastcall sub_140002920(__int64 a1)
{
  signed __int64 v1; // rsi
  void **v2; // rdi
  __int64 v3; // rbx

  v1 = 100i64;
  v2 = (void **)(a1 + 3200);
  do
  {
    v3 = (__int64)*(v2 - 2);
    v2 -= 4;
    --v1;
    if ( v3 && _InterlockedExchangeAdd((volatile signed __int32 *)(v3 + 16), 0xFFFFFFFF) == 1 )
    {
      if ( v3 )
      {
        sub_14000A248((void **)v3);
        sub_14000AB20((void *)v3);
      }
    }
    sub_14000E034(v2);
  }
  while ( v1 );
}

//----- (0000000140002990) ----------------------------------------------------
signed __int64 __fastcall sub_140002990(__int64 a1)
{
  __int64 v1; // rdi
  _QWORD **v2; // rbx
  _QWORD *v3; // rcx
  struct _SLIST_ENTRY *v4; // rcx
  _QWORD *v5; // rax
  __int64 v6; // r8
  _QWORD *v7; // rdx
  _QWORD *v8; // rax
  signed __int64 result; // rax
  __int64 v10; // rdx
  _QWORD *v11; // rcx

  v1 = a1;
  v2 = (_QWORD **)(a1 + 8);
  while ( 1 )
  {
    v8 = *v2;
    if ( *v2 == v2 )
      break;
    if ( (_QWORD **)v8[1] != v2 )
      goto LABEL_11;
    v3 = (_QWORD *)*v8;
    if ( *(_QWORD **)(*v8 + 8i64) != v8 )
      goto LABEL_11;
    *v2 = v3;
    v3[1] = v2;
    v4 = (struct _SLIST_ENTRY *)(v8 - 4);
    v5 = v8 - 2;
    v6 = *v5;
    if ( *(_QWORD **)(*v5 + 8i64) != v5 )
      goto LABEL_11;
    v7 = (_QWORD *)v5[1];
    if ( (_QWORD *)*v7 != v5 )
      goto LABEL_11;
    *v7 = v6;
    *(_QWORD *)(v6 + 8) = v7;
    sub_140002AB8(v4);
  }
  result = v1 + 24;
  v10 = *(_QWORD *)(v1 + 24);
  if ( *(_QWORD *)(v10 + 8) != v1 + 24 || (v11 = *(_QWORD **)(v1 + 32), *v11 != result) )
LABEL_11:
    __fastfail(3u);
  *v11 = v10;
  *(_QWORD *)(v10 + 8) = v11;
  return result;
}

//----- (0000000140002A18) ----------------------------------------------------
__int64 sub_140002A18()
{
  __int64 result; // rax

  ++stru_140030480.L.TotalAllocates;
  result = (__int64)ExpInterlockedPopEntrySList(&stru_140030480.L.ListHead);
  if ( !result )
  {
    ++stru_140030480.L.AllocateMisses;
    result = sub_140021A40((__int64 (*)(void))stru_140030480.L.Allocate);
  }
  return result;
}

//----- (0000000140002A68) ----------------------------------------------------
__int64 sub_140002A68()
{
  __int64 result; // rax

  ++stru_14002B980.L.TotalAllocates;
  result = (__int64)ExpInterlockedPopEntrySList(&stru_14002B980.L.ListHead);
  if ( !result )
  {
    ++stru_14002B980.L.AllocateMisses;
    result = sub_140021A40((__int64 (*)(void))stru_14002B980.L.Allocate);
  }
  return result;
}

//----- (0000000140002AB8) ----------------------------------------------------
void __fastcall sub_140002AB8(PSLIST_ENTRY ListEntry)
{
  struct _SLIST_ENTRY *v1; // rbx

  if ( ListEntry )
  {
    ++stru_140030480.L.TotalFrees;
    v1 = ListEntry;
    if ( ExQueryDepthSList(&stru_140030480.L.ListHead) < stru_140030480.L.Depth )
    {
      ExpInterlockedPushEntrySList(&stru_140030480.L.ListHead, v1);
    }
    else
    {
      ++stru_140030480.L.FreeMisses;
      sub_140021A40((__int64 (*)(void))stru_140030480.L.Free);
    }
  }
}

//----- (0000000140002B1C) ----------------------------------------------------
void __fastcall sub_140002B1C(PSLIST_ENTRY ListEntry)
{
  struct _SLIST_ENTRY *v1; // rbx

  if ( ListEntry )
  {
    ++stru_14002B980.L.TotalFrees;
    v1 = ListEntry;
    if ( ExQueryDepthSList(&stru_14002B980.L.ListHead) < stru_14002B980.L.Depth )
    {
      ExpInterlockedPushEntrySList(&stru_14002B980.L.ListHead, v1);
    }
    else
    {
      ++stru_14002B980.L.FreeMisses;
      sub_140021A40((__int64 (*)(void))stru_14002B980.L.Free);
    }
  }
}

//----- (0000000140002B80) ----------------------------------------------------
void __fastcall sub_140002B80(__int64 a1, int a2, const UNICODE_STRING *a3)
{
  USHORT v3; // ax
  const UNICODE_STRING *v4; // rdi
  int v5; // esi
  __int64 v6; // rbx
  void *v7; // rcx
  PVOID v8; // rax
  UNICODE_STRING *v9; // rcx
  PVOID v10; // rdx
  USHORT v11; // ax

  v3 = a3->Length;
  v4 = a3;
  v5 = a2;
  v6 = a1;
  if ( a3->Length <= *(_WORD *)(a1 + 10) )
  {
    v9 = (UNICODE_STRING *)(a1 + 8);
  }
  else
  {
    v7 = *(void **)(a1 + 16);
    if ( v7 )
    {
      ExFreePoolWithTag(v7, 0x65634349u);
      v3 = v4->Length;
    }
    v8 = ExAllocatePoolWithTag(PagedPool, v3, 0x65634349u);
    v9 = (UNICODE_STRING *)(v6 + 8);
    v10 = v8;
    if ( !v8 )
    {
      *(_QWORD *)&v9->Length = 0i64;
      *(_WORD *)(v6 + 10) = 0;
      *(_QWORD *)(v6 + 16) = 0i64;
      *(_DWORD *)v6 = 2147483648;
      return;
    }
    v11 = v4->Length;
    *(_QWORD *)&v9->Length = 0i64;
    *(_WORD *)(v6 + 10) = v11;
    *(_QWORD *)(v6 + 16) = v10;
  }
  *(_DWORD *)v6 = v5;
  RtlCopyUnicodeString(v9, v4);
}

//----- (0000000140002C3C) ----------------------------------------------------
__int64 __fastcall sub_140002C3C(__int64 *a1, _WORD *a2)
{
  __int64 *v2; // rsi
  unsigned int v3; // edi
  __int64 v4; // rbx
  __int64 v6; // [rsp+40h] [rbp+18h]

  v6 = 0i64;
  v2 = a1;
  v3 = sub_14000A2F0(a2, (volatile signed __int32 **)&v6);
  if ( (v3 & 0x80000000) == 0 )
  {
    v4 = *v2;
    v3 = 0;
    *v2 = v6;
    v6 = v4;
  }
  else
  {
    v4 = v6;
  }
  if ( v4 && _InterlockedExchangeAdd((volatile signed __int32 *)(v4 + 16), 0xFFFFFFFF) == 1 && v4 )
  {
    sub_14000A248((void **)v4);
    sub_14000AB20((void *)v4);
  }
  return v3;
}

//----- (0000000140002CC0) ----------------------------------------------------
_QWORD *__fastcall sub_140002CC0(__int64 a1)
{
  _QWORD **v1; // rbx
  _QWORD *v2; // rcx
  struct _SLIST_ENTRY *v3; // rcx
  _QWORD *v4; // rax
  __int64 v5; // r8
  _QWORD *v6; // rdx
  _QWORD *result; // rax

  v1 = (_QWORD **)(a1 + 8);
  while ( 1 )
  {
    result = *v1;
    if ( *v1 == v1 )
      break;
    if ( (_QWORD **)result[1] != v1
      || (v2 = (_QWORD *)*result, *(_QWORD **)(*result + 8i64) != result)
      || (*v1 = v2,
          v2[1] = v1,
          v3 = (struct _SLIST_ENTRY *)(result - 2),
          v4 = result + 2,
          v5 = *v4,
          *(_QWORD **)(*v4 + 8i64) != v4)
      || (v6 = (_QWORD *)v4[1], (_QWORD *)*v6 != v4) )
    {
      __fastfail(3u);
    }
    *v6 = v5;
    *(_QWORD *)(v5 + 8) = v6;
    sub_140002AB8(v3);
  }
  return result;
}

//----- (0000000140002D20) ----------------------------------------------------
signed __int64 __fastcall sub_140002D20(_WORD *a1, _QWORD **a2)
{
  _QWORD **v2; // rsi
  unsigned int v3; // eax
  WCHAR *v4; // rax
  unsigned __int8 v5; // bl
  WCHAR *v6; // rdi
  signed __int64 result; // rax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]
  UNICODE_STRING v9; // [rsp+30h] [rbp-18h]
  __int16 v10; // [rsp+60h] [rbp+18h]

  v2 = a2;
  sub_14001B244(a1, &v10, &v9, 0);
  v3 = sub_14001B3B0(v10, &v9.Length);
  v4 = (WCHAR *)ExAllocatePoolWithTag(PagedPool, v3, 0x6E664349u);
  v5 = 0;
  v6 = v4;
  if ( v4 )
  {
    sub_14001A2AC(v4, v10, &v9.Length);
    if ( *v2 )
      v5 = sub_14000A2A4(*v2, v6);
    ExFreePoolWithTag(v6, 0);
    result = v5;
  }
  else
  {
    LODWORD(BugCheckParameter3) = -1073741670;
    sub_140006BB4(0x25Aui64, 0x79ui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
    result = 0x80000000i64;
  }
  return result;
}

//----- (0000000140002DE8) ----------------------------------------------------
signed __int64 __fastcall sub_140002DE8(__int64 a1, _QWORD *a2, char a3)
{
  signed __int64 v3; // r9
  __int64 v4; // rdi
  char v5; // bp
  signed __int64 v6; // rbx
  unsigned __int64 v7; // r10
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r8
  signed __int64 v10; // rax
  signed __int64 v11; // rcx

  v3 = 293i64;
  v4 = a1;
  v5 = a3;
  v6 = 293i64;
  v7 = -1i64;
  v8 = *(unsigned int *)a2
     - 293 * ((unsigned __int64)(*(unsigned int *)a2 * (unsigned __int128)0x6FD60FBA1A362BBui64 >> 64) >> 3);
  while ( 1 )
  {
    v9 = *(_QWORD *)(v4 + 40 * v8 + 32);
    if ( v9 && *a2 == *(_QWORD *)(v4 + 40 * v8) )
      return v8;
    v10 = v8;
    v11 = v8 + 1;
    if ( v9 >= v7 )
      v10 = v6;
    v6 = v10;
    v8 = v11 - 293 * ((unsigned __int64)((unsigned __int64)v11 * (unsigned __int128)0x6FD60FBA1A362BBui64 >> 64) >> 3);
    if ( v8 == *(unsigned int *)a2
             - 293 * ((unsigned __int64)(*(unsigned int *)a2 * (unsigned __int128)0x6FD60FBA1A362BBui64 >> 64) >> 3) )
      break;
    if ( v9 >= v7 )
      v9 = v7;
    v7 = v9;
  }
  if ( v5 )
    v3 = v10;
  return v3;
}

//----- (0000000140002EAC) ----------------------------------------------------
signed __int64 __fastcall sub_140002EAC(__int64 a1, __int64 *a2, char a3)
{
  __int64 *v3; // r13
  char v4; // r12
  unsigned __int64 v5; // r14
  unsigned __int64 v6; // rbp
  unsigned __int64 v7; // rsi
  signed __int64 v8; // rdi
  signed __int64 v9; // r15
  __int64 *v10; // rcx
  unsigned __int64 v11; // rbx
  signed __int64 v12; // rax
  signed __int64 v13; // rsi
  __int64 v15; // [rsp+50h] [rbp+8h]

  v15 = a1;
  v3 = a2;
  v4 = a3;
  v5 = a2[1]
     - 100
     * ((unsigned __int64)(((unsigned __int64)a2[1] * (unsigned __int128)0x47AE147AE147AE15ui64 >> 64)
                         + ((unsigned __int64)(a2[1]
                                             - ((unsigned __int64)a2[1] * (unsigned __int128)0x47AE147AE147AE15ui64 >> 64)) >> 1)) >> 6);
  v6 = -1i64;
  v7 = a2[1]
     - 100
     * ((unsigned __int64)(((unsigned __int64)a2[1] * (unsigned __int128)0x47AE147AE147AE15ui64 >> 64)
                         + ((unsigned __int64)(a2[1]
                                             - ((unsigned __int64)a2[1] * (unsigned __int128)0x47AE147AE147AE15ui64 >> 64)) >> 1)) >> 6);
  v8 = 100i64;
  v9 = 100i64;
  while ( 1 )
  {
    v10 = (__int64 *)(32 * v7 + a1);
    v11 = v10[3];
    if ( v11 && sub_14000E09C(v10, v3) )
      return v7;
    v12 = v7;
    v13 = v7 + 1;
    if ( v11 >= v6 )
      v12 = v9;
    v9 = v12;
    v7 = v13
       - 100
       * ((unsigned __int64)(((unsigned __int64)v13 * (unsigned __int128)0x47AE147AE147AE15ui64 >> 64)
                           + ((unsigned __int64)(v13
                                               - ((unsigned __int64)v13 * (unsigned __int128)0x47AE147AE147AE15ui64 >> 64)) >> 1)) >> 6);
    if ( v7 == v5 )
      break;
    a1 = v15;
    if ( v11 >= v6 )
      v11 = v6;
    v6 = v11;
  }
  if ( v4 )
    v8 = v12;
  return v8;
}

//----- (0000000140002F9C) ----------------------------------------------------
signed __int64 __fastcall sub_140002F9C(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rdi
  signed __int64 v3; // rbx
  _QWORD *i; // rax
  signed __int64 v5; // rcx
  _QWORD *v6; // rax
  _QWORD *v7; // rax
  signed __int64 *v8; // rax
  signed __int64 **v9; // rdx

  v2 = a2;
  v3 = a1
     + 16i64
     * ((unsigned int)a2
      - 257 * (unsigned int)((unsigned __int64)(a2 * (unsigned __int128)0xFF00FF00FF00FF01ui64 >> 64) >> 8));
  for ( i = *(_QWORD **)v3; i != (_QWORD *)v3; i = (_QWORD *)*i )
  {
    v5 = (signed __int64)(i - 3);
    if ( *(i - 3) == a2 )
      goto LABEL_6;
  }
  v5 = 0i64;
LABEL_6:
  if ( !v5 )
  {
    v6 = (_QWORD *)sub_140002A68();
    v5 = (signed __int64)v6;
    if ( v6 )
    {
      *v6 = v2;
      v7 = v6 + 1;
      v7[1] = v7;
      *v7 = v7;
      v8 = (signed __int64 *)(v5 + 24);
      v9 = *(signed __int64 ***)(v3 + 8);
      if ( *v9 != (signed __int64 *)v3 )
        __fastfail(3u);
      *v8 = v3;
      *(_QWORD *)(v5 + 32) = v9;
      *v9 = v8;
      *(_QWORD *)(v3 + 8) = v8;
    }
    else
    {
      v5 = 0i64;
    }
  }
  return v5;
}

//----- (000000014000303C) ----------------------------------------------------
void **__fastcall sub_14000303C(void **a1, __int64 a2)
{
  void **v2; // rbx
  __int64 *v3; // rax
  __int64 *v4; // rdi
  __int64 v5; // rsi
  __int64 *v7; // [rsp+38h] [rbp+10h]

  v2 = a1;
  if ( a2 && (v3 = (__int64 *)sub_1400031E0(a2, (__int64)&v7), v7 = v3, (v4 = v3) != 0i64) )
  {
    v5 = *v3;
    if ( (unsigned __int8)RtlValidSid(*v3) )
      sub_14000DFF8(v2, v5);
    else
      sub_14000E024(v2);
    if ( v4 )
      ExFreePoolWithTag(v4, 0);
  }
  else
  {
    sub_14000E024(v2);
  }
  return v2;
}
// 140028278: using guessed type __int64 __fastcall RtlValidSid(_QWORD);

//----- (00000001400030CC) ----------------------------------------------------
void __fastcall sub_1400030CC(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rsi
  _QWORD *v4; // rbx
  __int64 v5; // rdi
  signed __int64 v6; // rax
  signed __int64 v7; // r9
  signed __int64 v8; // rdx
  __int64 v9; // rcx

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = sub_140002DE8(a1, a2, 1);
  v7 = *(_QWORD *)(v5 + 11720) + 1i64;
  *(_QWORD *)(v5 + 11720) = v7;
  v8 = 5 * v6;
  *(_QWORD *)(v5 + 8 * v8 + 32) = v7;
  v9 = v5 + 8 + 40 * v6;
  *(_QWORD *)(v5 + 8 * v8) = *v4;
  if ( v3 != v9 )
    sub_140002B80(v9, *(_DWORD *)v3, (const UNICODE_STRING *)(v3 + 8));
}

//----- (0000000140003138) ----------------------------------------------------
void __fastcall sub_140003138(__int64 a1, __int64 *a2, __int64 *a3)
{
  __int64 *v3; // r14
  __int64 *v4; // rsi
  __int64 v5; // rdi
  signed __int64 v6; // rax
  signed __int64 v7; // r9
  __int64 *v8; // rbx
  __int64 *v9; // rcx
  __int64 v10; // rax
  __int64 v11; // rbx

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = sub_140002EAC(a1, a2, 1);
  v7 = *(_QWORD *)(v5 + 3200) + 1i64;
  v8 = (__int64 *)(v5 + 32 * v6);
  *(_QWORD *)(v5 + 3200) = v7;
  v8[3] = v7;
  sub_14000E054(v8, v4);
  v9 = v8 + 2;
  if ( v8 + 2 != v3 )
  {
    v10 = *v3;
    if ( *v3 )
      _InterlockedIncrement((volatile signed __int32 *)(v10 + 16));
    v11 = *v9;
    *v9 = v10;
    if ( v11 )
    {
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v11 + 16), 0xFFFFFFFF) == 1 )
      {
        sub_14000A248((void **)v11);
        sub_14000AB20((void *)v11);
      }
    }
  }
}

//----- (00000001400031E0) ----------------------------------------------------
__int64 __fastcall sub_1400031E0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  int v3; // eax
  __int64 v4; // rcx

  v2 = a2;
  v3 = SeQueryInformationToken(a1, 1i64, a2);
  v4 = 0i64;
  if ( v3 >= 0 )
    return *(_QWORD *)v2;
  *(_QWORD *)v2 = 0i64;
  return v4;
}
// 140028280: using guessed type __int64 __fastcall SeQueryInformationToken(_QWORD, _QWORD, _QWORD);

//----- (0000000140003224) ----------------------------------------------------
void __fastcall sub_140003224(unsigned __int64 a1)
{
  unsigned __int64 v1; // rdi
  _QWORD **v2; // r8
  _QWORD *i; // rax
  struct _SLIST_ENTRY *v4; // rbx

  v1 = a1;
  ExAcquireFastMutex(&FastMutex);
  v2 = (_QWORD **)((char *)&unk_14002BA00
                 + 16
                 * ((unsigned int)v1
                  - 257 * (unsigned int)((unsigned __int64)(v1 * (unsigned __int128)0xFF00FF00FF00FF01ui64 >> 64) >> 8)));
  for ( i = *v2; i != v2; i = (_QWORD *)*i )
  {
    v4 = (struct _SLIST_ENTRY *)(i - 3);
    if ( *(i - 3) == v1 )
      goto LABEL_6;
  }
  v4 = 0i64;
LABEL_6:
  if ( v4 )
  {
    sub_140002990((__int64)v4);
    sub_140002B1C(v4);
  }
  ExReleaseFastMutex(&FastMutex);
}

//----- (00000001400032BC) ----------------------------------------------------
__int64 __fastcall sub_1400032BC(__int64 a1, UNICODE_STRING *a2)
{
  __int64 v2; // rbx
  UNICODE_STRING *v3; // rdi
  unsigned __int64 v4; // rax
  signed __int64 v5; // rax
  char *v6; // rbx
  unsigned int v7; // ebx
  __int64 v9; // [rsp+30h] [rbp+8h]

  v2 = a1;
  v3 = a2;
  ExAcquireFastMutex(&stru_14002B080);
  v9 = v2;
  v4 = sub_140002DE8((__int64)&unk_14002CA10, &v9, 0);
  if ( v4 >= 0x125 )
  {
    v6 = 0i64;
  }
  else
  {
    v5 = 5 * v4;
    *((_QWORD *)&unk_14002CA10 + v5 + 4) = ++qword_14002F7D8;
    v6 = (char *)&unk_14002CA10 + 8 * v5 + 8;
  }
  if ( v6 )
  {
    RtlCopyUnicodeString(v3, (PCUNICODE_STRING)(v6 + 8));
    v7 = *(_DWORD *)v6;
  }
  else
  {
    v7 = 2147483648;
  }
  ExReleaseFastMutex(&stru_14002B080);
  return v7;
}
// 14002F7D8: using guessed type __int64 qword_14002F7D8;

//----- (000000014000336C) ----------------------------------------------------
signed __int64 __fastcall sub_14000336C(__int64 a1)
{
  signed __int64 result; // rax

  result = 0x80000000i64;
  if ( *(_DWORD *)(a1 + 1072) == dword_140030468 )
    result = *(unsigned int *)(a1 + 1068);
  return result;
}
// 140030468: using guessed type int dword_140030468;

//----- (0000000140003388) ----------------------------------------------------
void sub_140003388()
{
  unsigned __int64 v0; // rax

  ExAcquireFastMutex(&stru_14002B080);
  v0 = 0i64;
  do
  {
    *(_QWORD *)((char *)&unk_14002CA30 + v0) = 0i64;
    v0 += 40i64;
  }
  while ( v0 < 0x2DC8 );
  ExReleaseFastMutex(&stru_14002B080);
}

//----- (00000001400033D0) ----------------------------------------------------
void __fastcall sub_1400033D0(__int64 a1)
{
  __int64 v1; // rbx
  unsigned __int64 v2; // rax
  __int64 v3; // [rsp+30h] [rbp+8h]

  v1 = a1;
  ExAcquireFastMutex(&stru_14002B080);
  v3 = v1;
  v2 = sub_140002DE8((__int64)&unk_14002CA10, &v3, 0);
  if ( v2 < 0x125 )
    *((_QWORD *)&unk_14002CA10 + 5 * v2 + 4) = 0i64;
  ExReleaseFastMutex(&stru_14002B080);
}

//----- (0000000140003434) ----------------------------------------------------
void sub_140003434()
{
  unsigned __int64 v0; // rax

  ExAcquireFastMutex(&stru_14002B048);
  v0 = 0i64;
  do
  {
    *(_QWORD *)((char *)&unk_14002F7F8 + v0) = 0i64;
    v0 += 32i64;
  }
  while ( v0 < 0xC80 );
  ExReleaseFastMutex(&stru_14002B048);
}

//----- (000000014000347C) ----------------------------------------------------
void sub_14000347C()
{
  _QWORD *v0; // rbx
  signed __int64 v1; // rsi
  struct _SLIST_ENTRY *v2; // rdi
  _QWORD *v3; // rax

  ExAcquireFastMutex(&FastMutex);
  v0 = &unk_14002BA00;
  v1 = 257i64;
  do
  {
    while ( 1 )
    {
      v3 = (_QWORD *)*v0;
      if ( (_QWORD *)*v0 == v0 )
        break;
      v2 = (struct _SLIST_ENTRY *)(v3 - 3);
      if ( v3 != (_QWORD *)24 )
      {
        sub_140002990((__int64)(v3 - 3));
        sub_140002B1C(v2);
      }
    }
    v0 += 2;
    --v1;
  }
  while ( v1 );
  ExReleaseFastMutex(&FastMutex);
}

//----- (00000001400034FC) ----------------------------------------------------
void sub_1400034FC()
{
  ++dword_140030468;
}
// 140030468: using guessed type int dword_140030468;

//----- (0000000140003504) ----------------------------------------------------
__int64 __fastcall sub_140003504(__int64 a1, _WORD *a2)
{
  _WORD *v2; // rdi
  unsigned int v3; // edi
  unsigned __int64 v4; // rax
  signed __int64 v5; // rax
  __int64 *v6; // rax
  void **v7; // rbx
  void *v9[3]; // [rsp+20h] [rbp-18h]
  void **v10; // [rsp+50h] [rbp+18h]

  v2 = a2;
  sub_14000303C(v9, a1);
  if ( !sub_14000E1E0(v9) )
    goto LABEL_2;
  v10 = 0i64;
  ExAcquireFastMutex(&stru_14002B048);
  v4 = sub_140002EAC((__int64)&unk_14002F7E0, (__int64 *)v9, 0);
  if ( v4 >= 0x64 )
  {
    v6 = 0i64;
  }
  else
  {
    v5 = 32 * v4;
    *(_QWORD *)((char *)&unk_14002F7E0 + v5 + 24) = ++qword_140030460;
    v6 = (__int64 *)((char *)&unk_14002F7E0 + v5 + 16);
  }
  if ( !v6 )
  {
    ExReleaseFastMutex(&stru_14002B048);
LABEL_2:
    v3 = 2147483648;
    goto LABEL_15;
  }
  v7 = 0i64;
  if ( &v10 != (void ***)v6 )
  {
    v7 = (void **)*v6;
    if ( *v6 )
      _InterlockedIncrement((volatile signed __int32 *)v7 + 4);
    v10 = v7;
  }
  ExReleaseFastMutex(&stru_14002B048);
  v3 = sub_140002D20(v2, &v10);
  if ( v7 && _InterlockedExchangeAdd((volatile signed __int32 *)v7 + 4, 0xFFFFFFFF) == 1 )
  {
    sub_14000A248(v10);
    sub_14000AB20(v10);
  }
LABEL_15:
  sub_14000E034(v9);
  return v3;
}
// 140030460: using guessed type __int64 qword_140030460;
// 140030468: using guessed type int dword_140030468;

//----- (000000014000362C) ----------------------------------------------------
void __fastcall sub_14000362C(_BYTE *a1)
{
  _BYTE *v1; // rbx

  v1 = a1;
  ExAcquireFastMutex(&FastMutex);
  sub_140002CC0((__int64)v1);
  *v1 = 1;
  ExReleaseFastMutex(&FastMutex);
}

//----- (000000014000366C) ----------------------------------------------------
_QWORD *__fastcall sub_14000366C(__int64 a1)
{
  _QWORD *result; // rax

  result = (_QWORD *)(a1 + 8);
  *(_BYTE *)a1 = 0;
  result[1] = result;
  *result = result;
  *(_QWORD *)(a1 + 24) = 1i64;
  return result;
}

//----- (0000000140003684) ----------------------------------------------------
void __fastcall sub_140003684(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  ExAcquireFastMutex(&FastMutex);
  sub_140002CC0(v1);
  ExReleaseFastMutex(&FastMutex);
}

//----- (00000001400036C0) ----------------------------------------------------
char __fastcall sub_1400036C0(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v3; // rdi
  _QWORD *v4; // rsi
  __int64 v5; // rbp
  char v6; // bl
  _QWORD *i; // rcx

  v3 = a1;
  v4 = a3;
  v5 = a2;
  ExAcquireFastMutex(&FastMutex);
  v6 = 0;
  if ( *(_BYTE *)v3 )
  {
    *v4 = 0i64;
  }
  else
  {
    for ( i = *(_QWORD **)(v3 + 8); ; i = (_QWORD *)*i )
    {
      if ( i == (_QWORD *)(v3 + 8) )
      {
        *v4 = *(_QWORD *)(v3 + 24);
        goto LABEL_8;
      }
      if ( *(_QWORD *)*(i - 1) == v5 )
        break;
    }
    v6 = 1;
  }
LABEL_8:
  ExReleaseFastMutex(&FastMutex);
  return v6;
}

//----- (000000014000374C) ----------------------------------------------------
void __fastcall sub_14000374C(__int64 a1)
{
  __int64 v1; // rbx
  bool v2; // zf

  v1 = a1;
  ExAcquireFastMutex(&FastMutex);
  if ( !*(_BYTE *)v1 )
  {
    sub_140002CC0(v1);
    v2 = (*(_QWORD *)(v1 + 24))++ == -1i64;
    if ( v2 )
      *(_QWORD *)(v1 + 24) = 1i64;
  }
  ExReleaseFastMutex(&FastMutex);
}

//----- (000000014000379C) ----------------------------------------------------
void __fastcall sub_14000379C(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  unsigned __int64 v5; // rsi
  signed __int64 v6; // rbx
  _QWORD *i; // r8
  signed __int64 v8; // rsi
  ULONG_PTR v9; // rdx
  _QWORD *v10; // rax
  signed __int64 *v11; // rcx
  signed __int64 **v12; // rdx
  _QWORD *v13; // rcx
  _QWORD *v14; // r8
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]

  v3 = a1;
  v4 = a3;
  v5 = a2;
  ExAcquireFastMutex(&FastMutex);
  if ( !*(_BYTE *)v3 && *(_QWORD *)(v3 + 24) == v4 )
  {
    v6 = v3 + 8;
    for ( i = *(_QWORD **)(v3 + 8); i != (_QWORD *)v6; i = (_QWORD *)*i )
    {
      if ( *(_QWORD *)*(i - 1) == v5 )
        goto LABEL_12;
    }
    v8 = sub_140002F9C((__int64)&unk_14002BA00, v5);
    if ( !v8 )
    {
      v9 = 802i64;
LABEL_11:
      LODWORD(BugCheckParameter3) = -1073741670;
      sub_140006BB4(0x25Aui64, v9, 0i64, 0xE03D000B, BugCheckParameter3, 0);
      goto LABEL_12;
    }
    v10 = (_QWORD *)sub_140002A18();
    if ( !v10 )
    {
      v9 = 813i64;
      goto LABEL_11;
    }
    *v10 = v3;
    v11 = v10 + 2;
    v12 = *(signed __int64 ***)(v3 + 16);
    if ( *v12 != (signed __int64 *)v6
      || (v10[3] = v12,
          *v11 = v6,
          *v12 = v11,
          *(_QWORD *)(v3 + 16) = v11,
          v13 = v10 + 4,
          v14 = *(_QWORD **)(v8 + 16),
          *v14 != v8 + 8) )
    {
      __fastfail(3u);
    }
    *v13 = v8 + 8;
    v10[5] = v14;
    *v14 = v13;
    *(_QWORD *)(v8 + 16) = v13;
    v10[1] = v8;
  }
LABEL_12:
  ExReleaseFastMutex(&FastMutex);
}

//----- (00000001400038AC) ----------------------------------------------------
void __fastcall sub_1400038AC(__int64 a1)
{
  __int64 v1; // rbx
  bool v2; // zf

  v1 = a1;
  ExAcquireFastMutex(&FastMutex);
  v2 = (*(_QWORD *)(v1 + 24))++ == -1i64;
  if ( v2 )
    *(_QWORD *)(v1 + 24) = 1i64;
  *(_BYTE *)v1 = 0;
  ExReleaseFastMutex(&FastMutex);
}

//----- (00000001400038F4) ----------------------------------------------------
void __fastcall sub_1400038F4(__int64 a1, int a2, const UNICODE_STRING *a3)
{
  __int64 v3; // rbx
  const UNICODE_STRING *v4; // rdi
  int v5; // esi
  int v6; // [rsp+20h] [rbp-28h]
  __int64 v7; // [rsp+28h] [rbp-20h]
  PVOID P; // [rsp+30h] [rbp-18h]
  __int64 v9; // [rsp+50h] [rbp+8h]

  v3 = a1;
  v4 = a3;
  v5 = a2;
  ExAcquireFastMutex(&stru_14002B080);
  v9 = v3;
  v7 = 0i64;
  WORD1(v7) = 0;
  v6 = v5;
  P = 0i64;
  sub_140002B80((__int64)&v6, v5, v4);
  sub_1400030CC((__int64)&unk_14002CA10, &v9, (__int64)&v6);
  if ( P )
    ExFreePoolWithTag(P, 0x65634349u);
  ExReleaseFastMutex(&stru_14002B080);
}

//----- (000000014000399C) ----------------------------------------------------
void __fastcall sub_14000399C(__int64 a1, _WORD *a2)
{
  _WORD *v2; // rbx
  void *v3[3]; // [rsp+20h] [rbp-18h]
  __int64 v4; // [rsp+50h] [rbp+18h]

  v2 = a2;
  sub_14000303C(v3, a1);
  if ( sub_14000E1E0(v3) )
  {
    v4 = 0i64;
    if ( (signed int)sub_140002C3C(&v4, v2) >= 0 )
    {
      ExAcquireFastMutex(&stru_14002B048);
      sub_140003138((__int64)&unk_14002F7E0, (__int64 *)v3, &v4);
      ExReleaseFastMutex(&stru_14002B048);
    }
    if ( v4 && _InterlockedExchangeAdd((volatile signed __int32 *)(v4 + 16), 0xFFFFFFFF) == 1 )
    {
      sub_14000A248((void **)v4);
      sub_14000AB20((void *)v4);
    }
  }
  sub_14000E034(v3);
}

//----- (0000000140003A58) ----------------------------------------------------
__int64 __fastcall sub_140003A58(__int64 a1, signed int a2)
{
  __int64 result; // rax

  if ( a2 >= -2147483646 )
  {
    result = (unsigned int)dword_140030468;
    *(_DWORD *)(a1 + 1072) = dword_140030468;
    *(_DWORD *)(a1 + 1068) = a2;
  }
  return result;
}
// 140030468: using guessed type int dword_140030468;

//----- (0000000140003A74) ----------------------------------------------------
char __fastcall sub_140003A74(__int64 a1, unsigned int a2, unsigned int *a3, _DWORD *a4, unsigned int *a5, _DWORD *a6)
{
  _DWORD *v6; // r15
  unsigned int *v7; // r12
  unsigned int v8; // edi
  __int64 v9; // rsi
  __int64 v10; // r10
  char v11; // bl
  int v12; // eax
  __int64 v13; // rax
  __int64 v14; // r8
  int v15; // er13
  unsigned int v16; // ebp
  int v17; // esi
  unsigned int v18; // ecx
  unsigned int v19; // edx
  bool v20; // zf
  __int64 v22; // [rsp+20h] [rbp-38h]
  __int64 v23; // [rsp+28h] [rbp-30h]

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( a2 >= 0x18 )
  {
    v10 = *(unsigned int *)(a1 + 8);
    v11 = 1;
    if ( !(_DWORD)v10 )
    {
      *a3 = a2;
      v12 = 0;
LABEL_9:
      *v6 = v12;
      v13 = *(unsigned int *)(v9 + 12);
      if ( (_DWORD)v13 )
      {
        *a5 = v13;
        if ( (unsigned int)v13 >= 0x18 && (unsigned int)v13 < v8 && !(v13 & 1) )
        {
          v14 = v9 + v13;
          v15 = v8 - v13;
          v23 = v9 + v13;
          v16 = 0;
          v17 = 0;
          while ( 1 )
          {
            v22 = 0i64;
            if ( (signed int)sub_140003BE8((_WORD *)(v14 + v16), v15 - v16, &v22) < 0 )
              break;
            v17 += v22 + 2;
            if ( (_DWORD)v22 == 0 )
            {
              *a6 = v17;
              goto LABEL_19;
            }
            v14 = v23;
            v16 += v22 + 2;
          }
        }
        return 0;
      }
      *a5 = v8;
      *a6 = 0;
      v17 = 0;
LABEL_19:
      v18 = *v7;
      v19 = *a5;
      if ( *v7 > *a5 )
      {
        if ( v19 != 24 || v17 + 24 != v18 )
          return 0;
        v20 = *v6 + v18 == v8;
      }
      else
      {
        if ( v18 != 24 || *v6 + 24 != v19 )
          return 0;
        v20 = v19 + v17 == v8;
      }
      if ( v20 )
        return v11;
      return 0;
    }
    *a3 = v10;
    if ( (unsigned int)v10 >= 0x18 && (unsigned int)v10 < a2 && !(v10 & 1) )
    {
      v22 = 0i64;
      if ( (signed int)sub_140003BE8((_WORD *)(v10 + a1), a2 - (unsigned int)v10, &v22) >= 0 )
      {
        v12 = v22 + 2;
        goto LABEL_9;
      }
    }
  }
  return 0;
}

//----- (0000000140003BE8) ----------------------------------------------------
__int64 __fastcall sub_140003BE8(_WORD *a1, unsigned __int64 a2, _QWORD *a3)
{
  unsigned __int64 v3; // rdx
  _QWORD *v4; // r9
  unsigned __int64 v5; // rax
  unsigned __int64 i; // r8
  int v7; // ecx

  v3 = a2 >> 1;
  v4 = a3;
  v5 = 0i64;
  if ( a1 && v3 <= 0x7FFFFFFF )
  {
    for ( i = v3; i; --i )
    {
      if ( !*a1 )
        break;
      ++a1;
    }
    v7 = i == 0 ? 0xC000000D : 0;
    if ( i )
      v5 = v3 - i;
    else
      v5 = 0i64;
  }
  else
  {
    v7 = -1073741811;
  }
  if ( v4 )
  {
    if ( v7 < 0 )
      *v4 = 0i64;
    else
      *v4 = 2 * v5;
  }
  return (unsigned int)v7;
}

//----- (0000000140003C58) ----------------------------------------------------
void __fastcall sub_140003C58(_OWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  const UNICODE_STRING *v3; // rdx
  _OWORD *v4; // rax
  _OWORD *v5; // r8
  __int128 v6; // xmm0
  signed __int64 v7; // rcx
  __int64 v8; // rcx

  v2 = a2;
  v3 = (const UNICODE_STRING *)(a1 + 3);
  *(_OWORD *)v2 = *a1;
  v4 = a1 + 8;
  v5 = (_OWORD *)(v2 + 128);
  *(_OWORD *)(v2 + 16) = a1[1];
  *(_OWORD *)(v2 + 32) = a1[2];
  *(_OWORD *)(v2 + 48) = a1[3];
  *(_OWORD *)(v2 + 64) = a1[4];
  *(_OWORD *)(v2 + 80) = a1[5];
  *(_OWORD *)(v2 + 96) = a1[6];
  v6 = a1[7];
  v7 = v2 + 48;
  *(v5 - 1) = v6;
  *v5 = *v4;
  v5[1] = v4[1];
  v5[2] = v4[2];
  v5[3] = v4[3];
  v5[4] = v4[4];
  *(_QWORD *)v7 = 0i64;
  *(_QWORD *)(v7 + 8) = v2 + 64;
  *(_WORD *)(v7 + 2) = 128;
  RtlCopyUnicodeString((PUNICODE_STRING)(v2 + 48), v3);
  v8 = *(_QWORD *)(v2 + 32);
  if ( v8 )
    sub_14001B77C(v8);
  *(_QWORD *)(v2 + 200) = 0i64;
  *(_DWORD *)(v2 + 192) = 2147483648;
}

//----- (0000000140003D28) ----------------------------------------------------
void __fastcall sub_140003D28(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rcx

  v1 = a1;
  sub_14001A4D8(*(_QWORD *)(a1 + 32));
  v2 = *(void **)(v1 + 200);
  if ( v2 )
    ExFreePoolWithTag(v2, 0);
}
// 14001A4D8: using guessed type __int64 __fastcall sub_14001A4D8(_QWORD);

//----- (0000000140003D5C) ----------------------------------------------------
__int64 __fastcall sub_140003D5C(__int64 a1)
{
  return (unsigned int)*(unsigned __int16 *)(a1 + 48) + *(_DWORD *)(a1 + 40) + 38;
}

//----- (0000000140003D6C) ----------------------------------------------------
char __fastcall sub_140003D6C(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // rbx
  unsigned int *v4; // rdi
  char result; // al
  unsigned __int64 v6; // rsi
  _WORD *v7; // rax
  __int64 v8; // rdx
  unsigned int v9; // ecx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-38h]
  unsigned int v11; // [rsp+30h] [rbp-28h]
  int v12; // [rsp+34h] [rbp-24h]
  __int64 v13; // [rsp+38h] [rbp-20h]
  UNICODE_STRING DestinationString; // [rsp+40h] [rbp-18h]
  SIZE_T NumberOfBytes; // [rsp+78h] [rbp+20h]

  v3 = a1;
  v4 = (unsigned int *)a2;
  result = sub_140003A74(a2, a3, (unsigned int *)&v13, &v12, &v11, &NumberOfBytes);
  if ( result )
  {
    *(_DWORD *)(v3 + 192) = v4[4];
    if ( (_DWORD)NumberOfBytes )
    {
      v6 = (unsigned int)NumberOfBytes;
      v7 = ExAllocatePoolWithTag(PagedPool, (unsigned int)NumberOfBytes, 0x414D4349u);
      *(_QWORD *)(v3 + 200) = v7;
      if ( v7 )
      {
        v8 = v11;
        *v7 = 0;
        sub_140021A80(*(__m128i **)(v3 + 200), (unsigned __int64)v4 + v8, v6);
      }
      else
      {
        LODWORD(BugCheckParameter3) = -1073741670;
        sub_140006BB4(0x259ui64, 0x198ui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
      }
    }
    v9 = v4[5];
    *(_DWORD *)(v3 + 196) = v9;
    if ( v9 != *(_DWORD *)(v3 + 44) )
    {
      RtlInitUnicodeString(&DestinationString, (PCWSTR)((char *)v4 + v4[2]));
      RtlCopyUnicodeString((PUNICODE_STRING)(v3 + 48), &DestinationString);
    }
    *(_BYTE *)v3 = 1;
    result = 1;
  }
  return result;
}

//----- (0000000140003E84) ----------------------------------------------------
signed __int64 __fastcall sub_140003E84(_BYTE *a1, __int64 a2, __int64 a3, char a4, __int16 a5, char a6)
{
  __int64 v6; // rbx
  __int64 v7; // rdi
  _BYTE *v8; // rsi
  __int64 v9; // rax
  int v10; // eax
  signed __int64 result; // rax
  UNICODE_STRING v12; // [rsp+20h] [rbp-18h]

  v6 = a3;
  a1[2] = a5;
  v7 = a2;
  v8 = a1;
  a1[3] = a6;
  *a1 = 0;
  a1[1] = a4;
  v9 = PsGetCurrentProcessId(a1);
  *((_QWORD *)v8 + 2) = v6;
  *((_QWORD *)v8 + 1) = v9;
  *((_QWORD *)v8 + 4) = v7;
  sub_14001B77C(v7);
  *((_DWORD *)v8 + 6) = -2147483647;
  *((_DWORD *)v8 + 7) = -2147483647;
  *((_DWORD *)v8 + 11) = -2147483647;
  *((_QWORD *)v8 + 6) = 0i64;
  *((_WORD *)v8 + 25) = 128;
  *((_QWORD *)v8 + 7) = v8 + 64;
  sub_14001B244(*((_WORD **)v8 + 4), &a5, &v12, 1);
  v10 = sub_14001B3B0(a5, &v12.Length);
  *((_QWORD *)v8 + 25) = 0i64;
  *((_DWORD *)v8 + 10) = v10;
  result = 0x80000000i64;
  *((_DWORD *)v8 + 48) = 2147483648;
  *((_DWORD *)v8 + 49) = 2147483648;
  return result;
}
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);

//----- (0000000140003F48) ----------------------------------------------------
unsigned __int64 __fastcall sub_140003F48(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rbx
  unsigned __int64 result; // rax
  UNICODE_STRING v6; // [rsp+20h] [rbp-18h]
  __int16 v7; // [rsp+40h] [rbp+8h]

  *(_QWORD *)a2 = *(_QWORD *)(a1 + 16);
  v2 = a2;
  *(_DWORD *)(a2 + 8) = 36;
  v3 = a1;
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 40) + 36;
  *(_BYTE *)(a2 + 16) = *(_BYTE *)(a1 + 1);
  *(_BYTE *)(a2 + 17) = *(_BYTE *)(a1 + 2);
  *(_BYTE *)(a2 + 18) = *(_BYTE *)(a1 + 3);
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 28);
  sub_14001B244(*(_WORD **)(a1 + 32), &v7, &v6, 1);
  sub_14001A2AC((_WORD *)(v2 + *(unsigned int *)(v2 + 8)), v7, &v6.Length);
  v4 = v2 + *(unsigned int *)(v2 + 12);
  sub_140021A80((__m128i *)(v2 + *(unsigned int *)(v2 + 12)), *(_QWORD *)(v3 + 56), *(unsigned __int16 *)(v3 + 48));
  result = (unsigned __int64)*(unsigned __int16 *)(v3 + 48) >> 1;
  *(_WORD *)(v4 + 2 * result) = 0;
  return result;
}

//----- (0000000140003FFC) ----------------------------------------------------
void __fastcall sub_140003FFC(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  int v5; // edx
  _WORD *v6; // rdx

  v3 = a3;
  v4 = a1;
  if ( *(_BYTE *)a1 )
  {
    sub_140003A58(a2, *(_DWORD *)(a1 + 192));
    v5 = *(_DWORD *)(v4 + 196);
    if ( v5 != *(_DWORD *)(v4 + 44) )
      sub_1400038F4(*(_QWORD *)(v4 + 8), v5, (const UNICODE_STRING *)(v4 + 48));
    v6 = *(_WORD **)(v4 + 200);
    if ( v6 )
      sub_14000399C(v3, v6);
  }
}

//----- (0000000140004060) ----------------------------------------------------
void __fastcall sub_140004060(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // rbx

  if ( !a3 )
  {
    v3 = a2;
    sub_1400033D0(a2);
    sub_140003224(v3);
  }
}

//----- (0000000140004084) ----------------------------------------------------
void __fastcall sub_140004084(UNICODE_STRING *a1, _BYTE *a2, _BYTE *a3, char a4, char a5)
{
  _BYTE *v5; // rbx
  char v6; // si
  _BYTE *v7; // rdi
  HANDLE v8; // rcx
  bool v9; // zf
  HANDLE FileHandle; // [rsp+60h] [rbp-51h]
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+68h] [rbp-49h]
  OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+78h] [rbp-39h]
  char FileInformation; // [rsp+A8h] [rbp-9h]
  char v14; // [rsp+C8h] [rbp+17h]
  char v15; // [rsp+D8h] [rbp+27h]

  if ( a2 )
  {
    v5 = a3;
    v6 = a4;
    v7 = a2;
    if ( a3 )
    {
      FileHandle = 0i64;
      ObjectAttributes.RootDirectory = 0i64;
      *a3 = 0;
      *a2 = 0;
      ObjectAttributes.ObjectName = a1;
      ObjectAttributes.Length = 48;
      ObjectAttributes.Attributes = 576;
      _mm_storeu_si128((__m128i *)&ObjectAttributes.SecurityDescriptor, (__m128i)0i64);
      if ( ZwCreateFile(&FileHandle, 0x80u, &ObjectAttributes, &IoStatusBlock, 0i64, 0, 7u, 1u, 0x100u, 0i64, 0) < 0 )
      {
        v9 = (a5 & 2) == 0;
      }
      else
      {
        v8 = FileHandle;
        *v7 = 1;
        if ( v6 )
        {
          if ( ZwQueryInformationFile(v8, &IoStatusBlock, &FileInformation, 0x38u, (FILE_INFORMATION_CLASS)34) >= 0 )
          {
            v9 = (v15 & 2) == 0;
            goto LABEL_10;
          }
LABEL_12:
          ZwClose(FileHandle);
          return;
        }
        if ( ZwQueryInformationFile(v8, &IoStatusBlock, &FileInformation, 0x28u, FileBasicInformation) < 0 )
          goto LABEL_12;
        v9 = (v14 & 2) == 0;
      }
LABEL_10:
      if ( !v9 )
        *v5 = 1;
      goto LABEL_12;
    }
  }
}

//----- (00000001400041D4) ----------------------------------------------------
signed __int64 __fastcall sub_1400041D4(__int64 a1, UNICODE_STRING *a2, __int64 a3, __int64 a4, struct _FILE_OBJECT *a5, __int64 a6, char a7, __int64 a8, char a9)
{
  signed int v9; // er14
  __int64 v10; // r13
  __int64 v11; // r15
  __int64 v12; // rdi
  UNICODE_STRING *v13; // rbx
  signed int v14; // er12
  __int64 v15; // rsi
  signed int v16; // eax
  __int64 v18; // rax
  unsigned int v19; // eax
  __int16 v20; // ST20_2
  const wchar_t *v21; // rcx
  char v22; // [rsp+30h] [rbp-D0h]
  char v23; // [rsp+31h] [rbp-CFh]
  unsigned int v24; // [rsp+34h] [rbp-CCh]
  int v25; // [rsp+38h] [rbp-C8h]
  UNICODE_STRING SourceString; // [rsp+40h] [rbp-C0h]
  struct _FILE_OBJECT *v27; // [rsp+50h] [rbp-B0h]
  __int64 v28; // [rsp+58h] [rbp-A8h]
  __int64 v29; // [rsp+60h] [rbp-A0h]
  char v30; // [rsp+70h] [rbp-90h]
  int v31; // [rsp+88h] [rbp-78h]
  int v32; // [rsp+8Ch] [rbp-74h]
  int v33; // [rsp+9Ch] [rbp-64h]
  UNICODE_STRING DestinationString; // [rsp+A0h] [rbp-60h]
  char v35; // [rsp+140h] [rbp+40h]

  v9 = -2147483647;
  v27 = a5;
  v10 = a1;
  v11 = a4;
  v29 = a6;
  v12 = a3;
  v13 = a2;
  v28 = a8;
  v14 = -2147483647;
  v25 = -2147483647;
  v23 = 0;
  v22 = 0;
  if ( *(_BYTE *)a3 )
    v15 = *(_QWORD *)(a3 + 8);
  else
    v15 = 0i64;
  *(_QWORD *)&SourceString.Length = 0i64;
  SourceString.MaximumLength = 256;
  SourceString.Buffer = (PWSTR)&v35;
  if ( a7 )
  {
    if ( a1 )
    {
      v9 = sub_14000336C(a1);
      if ( v11 )
      {
        v16 = sub_140003504(v11, v13);
        v14 = v16;
        if ( v9 == -1 && !v16 )
        {
          if ( dword_140035180 & 0x20 )
            sub_140007A38((__int64)L"DataControl check for %Z: exempt (outside monitored areas)", v13);
          return 7i64;
        }
LABEL_26:
        sub_140004084(v13, &v23, &v22, *(_BYTE *)(v10 + 1062) == 0, a9);
        LOBYTE(v20) = v23;
        sub_140003E84(&v30, (__int64)v13, v15, a7, v20, v22);
        if ( a7 )
        {
          v31 = v9;
          v32 = v14;
        }
        else
        {
          v33 = v25;
          RtlCopyUnicodeString(&DestinationString, &SourceString);
        }
        v24 = 2;
        sub_140019788((__int64)&v30, v11, v29, &v24, v28);
        switch ( v24 )
        {
          case 2u:
            if ( dword_140035180 & 0x20 )
            {
              v21 = L"DataControl check for %Z: error";
              goto LABEL_43;
            }
            break;
          case 0xEu:
            if ( dword_140035180 & 0x20 )
            {
              v21 = L"DataControl check for %Z: block";
              goto LABEL_43;
            }
            break;
          case 0xFu:
            if ( dword_140035180 & 0x20 )
            {
              v21 = L"DataControl check for %Z: allow once";
              goto LABEL_43;
            }
            break;
          case 0x10u:
            if ( dword_140035180 & 0x20 )
            {
              v21 = L"DataControl check for %Z: allow";
LABEL_43:
              sub_140007A38((__int64)v21, v13);
              break;
            }
            break;
          default:
            if ( dword_140035180 & 0x20 )
              sub_140007A38((__int64)L"DataControl check for %Z: %d", v13);
            break;
        }
        sub_140003FFC((__int64)&v30, v10, v11);
        sub_140003D28((__int64)&v30);
        return v24;
      }
    }
    return 2i64;
  }
  v18 = PsGetCurrentProcessId(0i64);
  v25 = sub_1400032BC(v18, &SourceString);
  if ( v25 == -1 )
    return 1i64;
  v19 = sub_140016BA0(v27, (_BYTE *)v12);
  if ( v19 )
  {
    if ( dword_140035180 & 0x20 )
      sub_140007A38((__int64)L"DataControl check for %Z: failed to get file size/attributes (%x)", v13, v19);
    return 2i64;
  }
  v15 = *(_QWORD *)(v12 + 8);
  if ( !v15 )
  {
    if ( dword_140035180 & 0x20 )
      sub_140007A38((__int64)L"DataControl check for %Z: file size is 0", v13);
    return 1i64;
  }
  if ( !(*(_DWORD *)(v12 + 16) & 0x10) )
    goto LABEL_26;
  if ( dword_140035180 & 0x20 )
    sub_140007A38((__int64)L"DataControl check for %Z: directory attribute", v13);
  return 5i64;
}
// 140022020: using guessed type wchar_t aDatacontrolChe[59];
// 1400220A0: using guessed type wchar_t aDatacontrolChe_5[66];
// 140022130: using guessed type wchar_t aDatacontrolChe_6[41];
// 140022190: using guessed type wchar_t aDatacontrolChe_7[46];
// 1400221F0: using guessed type wchar_t aDatacontrolChe_3[32];
// 140022230: using guessed type wchar_t aDatacontrolChe_2[32];
// 140022270: using guessed type wchar_t aDatacontrolChe_1[37];
// 1400222C0: using guessed type wchar_t aDatacontrolChe_8[32];
// 140022300: using guessed type wchar_t aDatacontrolChe_0[29];
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 140035180: using guessed type int dword_140035180;

//----- (00000001400044D8) ----------------------------------------------------
bool sub_1400044D8()
{
  return _InterlockedCompareExchange(&dword_140030500, 0, 0) != 0;
}
// 140030500: using guessed type int dword_140030500;

//----- (00000001400044E8) ----------------------------------------------------
void sub_1400044E8()
{
  KeInitializeMutex(&Mutex, 0);
}

//----- (0000000140004500) ----------------------------------------------------
char sub_140004500()
{
  char v0; // bl

  v0 = 0;
  if ( !_InterlockedCompareExchange(&dword_140030500, 0, 0) || sub_140004A78() )
    v0 = 1;
  return v0;
}
// 140030500: using guessed type int dword_140030500;

//----- (0000000140004528) ----------------------------------------------------
LONG __fastcall sub_140004528(char a1)
{
  char v1; // di
  __int64 v2; // rdx
  signed __int32 v3; // eax
  LONG result; // eax
  const wchar_t *v5; // rdx

  v1 = a1;
  KeWaitForSingleObject(&Mutex, 0, 0, 0, 0i64);
  v3 = _InterlockedCompareExchange(&dword_140030500, 0, 0);
  if ( v1 )
  {
    if ( !v3 )
    {
      sub_1400034FC();
      sub_140003388();
      sub_140003434();
      sub_14000347C();
      byte_140030504 = (signed int)sub_14000ABA0(1, (__int64)sub_140004060) >= 0;
      _InterlockedExchange(&dword_140030500, 1);
    }
  }
  else if ( v3 )
  {
    _InterlockedExchange(&dword_140030500, 0);
    if ( byte_140030504 )
    {
      sub_14000AC40(1, v2);
      byte_140030504 = 0;
    }
  }
  KeReleaseMutex(&Mutex, 0);
  result = dword_140035180;
  if ( dword_140035180 & 0x10 )
  {
    v5 = L"disabled";
    if ( v1 )
      v5 = L"enabled";
    result = sub_140007A38((__int64)L"DataControl %s", v5);
  }
  return result;
}
// 140021F90: using guessed type wchar_t aEnabled[8];
// 140021FA0: using guessed type wchar_t aDisabled[9];
// 140021FC0: using guessed type wchar_t aDatacontrolS[15];
// 140030500: using guessed type int dword_140030500;
// 140030504: using guessed type char byte_140030504;
// 140035180: using guessed type int dword_140035180;

//----- (000000014000461C) ----------------------------------------------------
LONG sub_14000461C()
{
  LONG result; // eax

  sub_1400034FC();
  sub_140003388();
  sub_140003434();
  sub_14000347C();
  result = dword_140035180;
  if ( dword_140035180 & 0x10 )
    result = sub_140007A38((__int64)L"DataControl cache invalidated");
  return result;
}
// 140021FE0: using guessed type wchar_t aDatacontrolCac[30];
// 140035180: using guessed type int dword_140035180;

//----- (0000000140004650) ----------------------------------------------------
_QWORD *__fastcall sub_140004650(__int64 a1)
{
  __int64 v1; // rdi
  _QWORD *v3[3]; // [rsp+30h] [rbp-18h]

  v1 = a1;
  ExAcquireFastMutex((PFAST_MUTEX)(a1 + 16));
  sub_1400049CC((_QWORD **)v1, v3, 0i64, 0i64, 1, 1);
  ExReleaseFastMutex((PFAST_MUTEX)(v1 + 16));
  return sub_140004810(v3);
}

//----- (00000001400046B4) ----------------------------------------------------
__int64 sub_1400046B4()
{
  __int64 result; // rax

  ++stru_140030540.L.TotalAllocates;
  result = (__int64)ExpInterlockedPopEntrySList(&stru_140030540.L.ListHead);
  if ( !result )
  {
    ++stru_140030540.L.AllocateMisses;
    result = sub_140021A40((__int64 (*)(void))stru_140030540.L.Allocate);
  }
  return result;
}

//----- (0000000140004704) ----------------------------------------------------
void __fastcall sub_140004704(PSLIST_ENTRY ListEntry)
{
  struct _SLIST_ENTRY *v1; // rbx

  if ( ListEntry )
  {
    ++stru_140030540.L.TotalFrees;
    v1 = ListEntry;
    if ( ExQueryDepthSList(&stru_140030540.L.ListHead) < stru_140030540.L.Depth )
    {
      ExpInterlockedPushEntrySList(&stru_140030540.L.ListHead, v1);
    }
    else
    {
      ++stru_140030540.L.FreeMisses;
      sub_140021A40((__int64 (*)(void))stru_140030540.L.Free);
    }
  }
}

//----- (0000000140004768) ----------------------------------------------------
signed __int64 __fastcall sub_140004768(__int64 *a1, __int64 a2)
{
  void *v2; // rbx
  __int64 *v3; // rsi
  __int64 v4; // rbp
  __int64 v5; // rax
  _QWORD *v6; // rdi
  __int64 v8; // rax

  v2 = (void *)__readgsqword(0x188u);
  v3 = a1;
  v4 = a2;
  v5 = sub_1400046B4();
  v6 = (_QWORD *)v5;
  if ( !v5 )
    return 3221225626i64;
  *(_QWORD *)(v5 + 24) = v4;
  *(_QWORD *)(v5 + 16) = v2;
  ObfReferenceObject(v2);
  ExAcquireFastMutex((PFAST_MUTEX)(v3 + 2));
  v8 = *v3;
  if ( *(__int64 **)(*v3 + 8) != v3 )
    __fastfail(3u);
  *v6 = v8;
  v6[1] = v3;
  *(_QWORD *)(v8 + 8) = v6;
  *v3 = (__int64)v6;
  ExReleaseFastMutex((PFAST_MUTEX)(v3 + 2));
  return 0i64;
}

//----- (0000000140004810) ----------------------------------------------------
_QWORD *__fastcall sub_140004810(_QWORD **a1)
{
  _QWORD *result; // rax
  _QWORD **i; // rdi
  _QWORD *v3; // rcx
  struct _SLIST_ENTRY *v4; // rbx

  result = *a1;
  for ( i = a1; *i != i; result = *i )
  {
    if ( (_QWORD **)result[1] != i || (v3 = (_QWORD *)*result, *(_QWORD **)(*result + 8i64) != result) )
      __fastfail(3u);
    *i = v3;
    v4 = (struct _SLIST_ENTRY *)(result - 4);
    v3[1] = i;
    ObfDereferenceObject((PVOID)*(result - 2));
    sub_140004704(v4);
  }
  return result;
}

//----- (0000000140004874) ----------------------------------------------------
_QWORD *__fastcall sub_140004874(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdi
  _QWORD *v5[3]; // [rsp+30h] [rbp-18h]

  v2 = a1;
  v3 = a2;
  ExAcquireFastMutex((PFAST_MUTEX)(a1 + 16));
  sub_1400049CC((_QWORD **)v2, v5, __readgsqword(0x188u), v3, 0, 1);
  ExReleaseFastMutex((PFAST_MUTEX)(v2 + 16));
  return sub_140004810(v5);
}

//----- (00000001400048EC) ----------------------------------------------------
char __fastcall sub_1400048EC(__int64 a1)
{
  struct _FAST_MUTEX *v1; // rbx
  _QWORD **v2; // rdi
  __int64 v4; // [rsp+30h] [rbp-18h]

  v1 = (struct _FAST_MUTEX *)(a1 + 16);
  v2 = (_QWORD **)a1;
  ExAcquireFastMutex((PFAST_MUTEX)(a1 + 16));
  sub_1400049CC(v2, &v4, __readgsqword(0x188u), 0i64, 0, 0);
  LOBYTE(v2) = v4 != (_QWORD)&v4;
  ExReleaseFastMutex(v1);
  return (char)v2;
}

//----- (000000014000495C) ----------------------------------------------------
_QWORD *__fastcall sub_14000495C(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdi
  _QWORD *v5[3]; // [rsp+30h] [rbp-18h]

  v2 = a1;
  v3 = a2;
  ExAcquireFastMutex((PFAST_MUTEX)(a1 + 16));
  sub_1400049CC((_QWORD **)v2, v5, 0i64, v3, 1, 1);
  ExReleaseFastMutex((PFAST_MUTEX)(v2 + 16));
  return sub_140004810(v5);
}

//----- (00000001400049CC) ----------------------------------------------------
void __fastcall sub_1400049CC(_QWORD **a1, _QWORD *a2, __int64 a3, __int64 a4, int a5, int a6)
{
  __int64 v6; // rbx
  _QWORD *v7; // r11
  _QWORD *v8; // r10
  _QWORD *v9; // rax
  _QWORD *v10; // r8
  _QWORD *v11; // rcx
  __int64 v12; // rcx
  _QWORD *v13; // r8

  a2[1] = a2;
  v6 = a3;
  *a2 = a2;
  v7 = a1;
  v8 = *a1;
  while ( v8 != v7 )
  {
    v9 = v8;
    v8 = (_QWORD *)*v8;
    if ( (!v6 || v6 == v9[2]) && (!a4 || a4 == v9[3]) )
    {
      v10 = (_QWORD *)a2[1];
      v11 = v9 + 4;
      if ( (_QWORD *)*v10 != a2 )
        goto LABEL_14;
      *v11 = a2;
      v9[5] = v10;
      *v10 = v11;
      a2[1] = v11;
      if ( a6 == 1 )
      {
        v12 = *v9;
        if ( *(_QWORD **)(*v9 + 8i64) != v9 || (v13 = (_QWORD *)v9[1], (_QWORD *)*v13 != v9) )
LABEL_14:
          __fastfail(3u);
        *v13 = v12;
        *(_QWORD *)(v12 + 8) = v13;
      }
      if ( !a5 )
        break;
    }
  }
}

//----- (0000000140004A58) ----------------------------------------------------
signed __int64 __fastcall sub_140004A58(__int64 a1)
{
  return sub_140004768((__int64 *)&unk_1400305C0, a1);
}

//----- (0000000140004A68) ----------------------------------------------------
_QWORD *__fastcall sub_140004A68(__int64 a1)
{
  return sub_140004874((__int64)&unk_1400305C0, a1);
}

//----- (0000000140004A78) ----------------------------------------------------
char sub_140004A78()
{
  return sub_1400048EC((__int64)&unk_1400305C0);
}

//----- (0000000140004A84) ----------------------------------------------------
_QWORD *__fastcall sub_140004A84(__int64 a1)
{
  return sub_14000495C((__int64)&unk_1400305C0, a1);
}

//----- (0000000140004A94) ----------------------------------------------------
__int64 __fastcall sub_140004A94(__int64 a1, __int64 a2, __int64 a3, int a4, char a5)
{
  __int64 result; // rax

  *(_BYTE *)(a1 + 36) = a5;
  *(_QWORD *)a1 = 0i64;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 24) = a3;
  *(_DWORD *)(a1 + 32) = a4;
  *(_WORD *)(a1 + 37) = 0;
  *(_WORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = &off_140028B58;
  result = a1;
  *(_QWORD *)(a1 + 56) = 0i64;
  return result;
}
// 140028B58: using guessed type __int64 (__fastcall *off_140028B58)(PSLIST_ENTRY ListEntry);

//----- (0000000140004AD0) ----------------------------------------------------
__int64 sub_140004AD0()
{
  __int64 result; // rax

  ++stru_140030640.L.TotalAllocates;
  result = (__int64)ExpInterlockedPopEntrySList(&stru_140030640.L.ListHead);
  if ( !result )
  {
    ++stru_140030640.L.AllocateMisses;
    result = sub_140021A40((__int64 (*)(void))stru_140030640.L.Allocate);
  }
  return result;
}

//----- (0000000140004B20) ----------------------------------------------------
void __fastcall sub_140004B20(PSLIST_ENTRY ListEntry)
{
  struct _SLIST_ENTRY *v1; // rbx

  if ( ListEntry )
  {
    ++stru_140030640.L.TotalFrees;
    v1 = ListEntry;
    if ( ExQueryDepthSList(&stru_140030640.L.ListHead) < stru_140030640.L.Depth )
    {
      ExpInterlockedPushEntrySList(&stru_140030640.L.ListHead, v1);
    }
    else
    {
      ++stru_140030640.L.FreeMisses;
      sub_140021A40((__int64 (*)(void))stru_140030640.L.Free);
    }
  }
}

//----- (0000000140004B90) ----------------------------------------------------
PSLIST_ENTRY __fastcall sub_140004B90(PSLIST_ENTRY ListEntry, char a2)
{
  PSLIST_ENTRY v2; // rbx
  char v3; // di
  __int64 v4; // rcx

  v2 = ListEntry;
  ListEntry->Next = (PSLIST_ENTRY)&off_140028B58;
  v3 = a2;
  v4 = *((_QWORD *)&ListEntry->Next + 1);
  if ( v4 )
  {
    sub_14001A4D8(v4);
    *((_QWORD *)&v2->Next + 1) = 0i64;
  }
  sub_14001CE9C(v2);
  if ( v3 & 1 )
  {
    if ( v3 & 4 )
      nullsub_1(v2, 16i64);
    else
      sub_14001668C(v2);
  }
  return v2;
}
// 140003220: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);
// 14001A4D8: using guessed type __int64 __fastcall sub_14001A4D8(_QWORD);
// 140028B58: using guessed type __int64 (__fastcall *off_140028B58)(PSLIST_ENTRY ListEntry);

//----- (0000000140004BF4) ----------------------------------------------------
char __fastcall sub_140004BF4(__int64 a1)
{
  __int64 v1; // rdi
  unsigned __int8 v2; // bl
  __int64 v3; // rcx
  int v4; // edx
  char result; // al
  int v6; // eax
  UNICODE_STRING String2; // [rsp+20h] [rbp-48h]
  __int128 v8; // [rsp+30h] [rbp-38h]
  __int64 v9; // [rsp+40h] [rbp-28h]
  __int16 v10; // [rsp+48h] [rbp-20h]

  v1 = a1;
  v2 = 0;
  v3 = *(_QWORD *)(a1 + 24);
  if ( !v3 )
    return 0;
  v4 = *(_DWORD *)(v1 + 8);
  if ( v4 )
  {
    if ( v4 != 1 )
      return 1;
    return 0;
  }
  v6 = *(_DWORD *)(v1 + 32);
  if ( v6 )
  {
    if ( v6 & 2 && !*(_BYTE *)(v3 + 1062)
      || v6 & 4 && *(_BYTE *)(v3 + 1064)
      || v6 & 8 && *(_BYTE *)(v3 + 1062) && !*(_BYTE *)(v3 + 1063)
      || v6 & 0x10
      && (v10 = 0,
          String2.Buffer = (PWSTR)&v8,
          v8 = xmmword_140022340,
          *(_DWORD *)&String2.Length = 1703960,
          v9 = 32370060416122989i64,
          !RtlCompareUnicodeString((PCUNICODE_STRING)(v3 + 512), &String2, 1u)) )
    {
      v2 = 1;
    }
  }
  result = v2;
  *(_DWORD *)(v1 + 8) = v2 + 1;
  return result;
}
// 140022340: using guessed type __int128 xmmword_140022340;

//----- (0000000140004CF0) ----------------------------------------------------
char __fastcall sub_140004CF0(_DWORD *a1)
{
  _DWORD *v1; // rbx
  __int16 v3; // ax

  v1 = a1;
  if ( *a1 )
  {
    if ( *a1 == 1 )
      return 0;
  }
  else
  {
    if ( !sub_140004BF4((__int64)a1) )
    {
      v3 = sub_140004DF4((__int64)v1);
      if ( !v3 || !sub_140013910(v3) )
      {
        *v1 = 1;
        return 0;
      }
    }
    *v1 = 2;
  }
  return 1;
}

//----- (0000000140004D4C) ----------------------------------------------------
bool __fastcall sub_140004D4C(__int64 a1)
{
  int v1; // edx
  __int64 v2; // rdi
  _WORD *v4; // rcx
  int v5; // edx
  bool v6; // al
  char v7; // bl
  __int64 (__fastcall **v8)(PSLIST_ENTRY); // [rsp+20h] [rbp-18h]
  _WORD *v9; // [rsp+28h] [rbp-10h]

  v1 = *(_DWORD *)(a1 + 4);
  v2 = a1;
  if ( v1 )
    return v1 != 1;
  sub_140004E44(a1, &v8, (__int64 (*)(void))sub_1400169E0);
  v4 = v9;
  if ( v9 )
  {
    v6 = sub_140013954(v9);
    v4 = v9;
    if ( !v6 )
    {
      v7 = 0;
      *(_DWORD *)(v2 + 4) = 1;
      goto LABEL_9;
    }
    v5 = 2;
  }
  else
  {
    v5 = *(_BYTE *)(v2 + 38) != 0 ? 2 : 0;
  }
  *(_DWORD *)(v2 + 4) = v5;
  v7 = 1;
LABEL_9:
  v8 = &off_140028B58;
  if ( v4 )
  {
    sub_14001A4D8(v4);
    v9 = 0i64;
  }
  sub_14001CE9C(&v8);
  return v7;
}
// 14001A4D8: using guessed type __int64 __fastcall sub_14001A4D8(_QWORD);
// 140028B58: using guessed type __int64 (__fastcall *off_140028B58)(PSLIST_ENTRY ListEntry);

//----- (0000000140004DF4) ----------------------------------------------------
__int64 __fastcall sub_140004DF4(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  if ( !*(_BYTE *)(a1 + 37) )
  {
    *(_WORD *)(a1 + 40) = sub_14001A520(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
    *(_BYTE *)(v1 + 37) = 1;
  }
  return *(unsigned __int16 *)(v1 + 40);
}

//----- (0000000140004E24) ----------------------------------------------------
_QWORD *__fastcall sub_140004E24(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  v2 = a2;
  sub_140004E44(a1, a2, (__int64 (*)(void))sub_1400169E0);
  return v2;
}

//----- (0000000140004E44) ----------------------------------------------------
_QWORD *__fastcall sub_140004E44(__int64 a1, _QWORD *a2, __int64 (*a3)(void))
{
  __int64 (*v3)(void); // rbp
  _QWORD *v4; // rdi
  __int64 v5; // rbx
  __int16 v6; // ax
  signed __int64 v7; // rax
  __int64 v8; // rcx
  signed __int64 v9; // rsi
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // rcx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !*(_BYTE *)(a1 + 38) )
  {
    v6 = sub_140004DF4(a1);
    v7 = sub_140005C64(
           v6,
           *(struct _FILE_OBJECT **)(v5 + 16),
           *(_QWORD *)(v5 + 24),
           *(_DWORD *)(v5 + 32),
           *(_BYTE *)(v5 + 36));
    v8 = *(_QWORD *)(v5 + 56);
    v9 = v7;
    if ( v8 )
      sub_14001A4D8(v8);
    *(_QWORD *)(v5 + 56) = v9;
    if ( v9 )
    {
      *(_BYTE *)(v5 + 38) = 1;
      if ( !(unsigned __int8)sub_140021A40(v3) )
      {
        *(_BYTE *)(v5 + 38) = 0;
        v10 = *(_QWORD *)(v5 + 56);
        if ( v10 )
          sub_14001A4D8(v10);
        *(_QWORD *)(v5 + 56) = 0i64;
      }
    }
    else if ( !*(_BYTE *)(v5 + 36) )
    {
      LODWORD(BugCheckParameter3) = -1073741823;
      sub_140006BB4(0x14Bui64, 0x177ui64, 0i64, 0xE03D0056, BugCheckParameter3, 0);
      v11 = *(_QWORD *)(v5 + 16);
      if ( v11 )
      {
        if ( dword_140035180 & 1 )
          sub_140007A38((__int64)L"The on-access driver failed to determine the name for file %Z", v11 + 88);
      }
    }
  }
  v12 = *(_QWORD *)(v5 + 56);
  *v4 = &off_140028B58;
  v4[1] = v12;
  if ( v12 )
    sub_14001B77C(v12);
  return v4;
}
// 14001A4D8: using guessed type __int64 __fastcall sub_14001A4D8(_QWORD);
// 140022360: using guessed type wchar_t aTheOnAccessDri[62];
// 140028B58: using guessed type __int64 (__fastcall *off_140028B58)(PSLIST_ENTRY ListEntry);
// 140035180: using guessed type int dword_140035180;

//----- (0000000140004F54) ----------------------------------------------------
_QWORD *__fastcall sub_140004F54(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  v2 = a2;
  sub_140004E44(a1, a2, (__int64 (*)(void))sub_140016A90);
  return v2;
}

//----- (0000000140004F74) ----------------------------------------------------
char __fastcall sub_140004F74(_DWORD *a1, int a2)
{
  _DWORD *v2; // rbx
  int v3; // edx

  v2 = a1;
  if ( a2 )
  {
    v3 = a2 - 1;
    if ( !v3 )
      return sub_140004CF0(a1);
    if ( v3 != 1 )
      return 1;
  }
  else
  {
    if ( sub_140004CF0(a1) )
      return 1;
    a1 = v2;
  }
  return sub_140004D4C((__int64)a1);
}

//----- (0000000140004FB8) ----------------------------------------------------
__int64 __fastcall sub_140004FB8(__int64 a1, __int64 a2, _DWORD *a3)
{
  int v3; // esi
  struct _FAST_MUTEX *v4; // rdi
  __int64 v5; // rbx
  _DWORD *v6; // r14
  __int64 v7; // rbp
  __int64 result; // rax
  int v9; // eax
  int v10; // [rsp+40h] [rbp+8h]

  v3 = dword_1400306C4;
  v4 = (struct _FAST_MUTEX *)(a1 + 1096);
  v5 = a1;
  v6 = a3;
  v7 = a2;
  ExAcquireFastMutex((PFAST_MUTEX)(a1 + 1096));
  if ( *(_DWORD *)(v5 + 1172) == v3 )
  {
    *v6 = *(_DWORD *)(v5 + 1168);
    ExReleaseFastMutex(v4);
  }
  else
  {
    ExReleaseFastMutex(v4);
    v10 = 0;
    result = sub_140005558((unsigned __int16 *)(v5 + 512), v7, &v10);
    if ( (_DWORD)result )
      return result;
    if ( v10 >= 0 )
      return 3221225473i64;
    ExAcquireFastMutex(v4);
    if ( v3 == dword_1400306C4 )
    {
      v9 = v10;
      *(_QWORD *)(v5 + 1176) = 0i64;
      *(_DWORD *)(v5 + 1168) = v9;
      *(_DWORD *)(v5 + 1172) = v3;
    }
    ExReleaseFastMutex(v4);
    *v6 = v10;
  }
  return 0i64;
}
// 1400306C4: using guessed type int dword_1400306C4;

//----- (00000001400050A8) ----------------------------------------------------
void __fastcall sub_1400050A8(__int64 a1, __int64 a2, int a3)
{
  struct _FAST_MUTEX *v3; // rdi
  __int64 v4; // rsi
  int v5; // ebp
  __int64 v6; // r14
  signed __int64 v7; // rbx
  ULONG v8; // eax
  struct _FAST_MUTEX *v9; // rcx
  struct _FAST_MUTEX *FastMutex; // [rsp+40h] [rbp+8h]

  v3 = (struct _FAST_MUTEX *)(a1 + 1096);
  v4 = a1;
  FastMutex = (struct _FAST_MUTEX *)(a1 + 1096);
  v5 = a3;
  v6 = a2;
  ExAcquireFastMutex((PFAST_MUTEX)(a1 + 1096));
  v7 = MEMORY[0xFFFFF78000000320] - *(_QWORD *)(v4 + 1176);
  v8 = KeQueryTimeIncrement();
  v9 = FastMutex;
  if ( v7 >= (signed __int64)(10000000 * (unsigned __int64)(unsigned int)dword_14002B0F4 / v8) )
  {
    ExReleaseFastMutex(FastMutex);
    if ( (unsigned int)sub_1400055E4(v5, (unsigned __int16 *)(v4 + 512), v6) )
      return;
    ExAcquireFastMutex(v3);
    v9 = v3;
    *(_QWORD *)(v4 + 1176) = MEMORY[0xFFFFF78000000320];
  }
  ExReleaseFastMutex(v9);
}
// 14002B0F4: using guessed type int dword_14002B0F4;

//----- (0000000140005188) ----------------------------------------------------
char __fastcall sub_140005188(__int64 a1, _DWORD *a2)
{
  _DWORD *v2; // rbx
  struct _DEVICE_OBJECT *v3; // rax
  char result; // al

  v2 = a2;
  v3 = (struct _DEVICE_OBJECT *)IoGetAttachedDevice(a1);
  result = sub_140008D74(v3, v2);
  if ( !result || *v2 != -1073741805 )
    *v2 = -1073741790;
  return result;
}
// 1400282C8: using guessed type __int64 __fastcall IoGetAttachedDevice(_QWORD);

//----- (00000001400051C0) ----------------------------------------------------
__int64 __fastcall sub_1400051C0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  int v4; // eax
  unsigned int v5; // ebx
  const wchar_t *v6; // rcx
  unsigned int v7; // eax
  signed int v8; // ecx
  int v10; // [rsp+38h] [rbp+10h]

  v2 = *(_QWORD *)(a2 + 184);
  v3 = a2;
  v4 = *(_DWORD *)(v2 + 24);
  if ( v4 == -2019347441 )
  {
    if ( !sub_14001763C(v2, 16, 4) )
    {
      v5 = -1073741811;
      if ( (dword_140035180 & 0x80u) == 0 )
        goto LABEL_17;
      v6 = L"DispatchInternalDIOC: Invalid buffer size in ID_IOCTL_INTERNAL_DC_QueryDevicePolicy";
LABEL_11:
      sub_140007A38((__int64)v6);
      goto LABEL_17;
    }
    if ( byte_1400306C0 )
    {
      v7 = sub_140005558(*(unsigned __int16 **)(v2 + 32), 0i64, &v10);
      v8 = v10;
      v5 = v7;
    }
    else
    {
      v8 = -2147483645;
      v5 = 0;
    }
    if ( !v5 )
    {
      **(_DWORD **)(v3 + 112) = v8;
      *(_QWORD *)(v3 + 56) = 4i64;
    }
  }
  else
  {
    if ( v4 != -2019347437 )
    {
      v5 = -1073741808;
      goto LABEL_17;
    }
    if ( sub_14001763C(*(_QWORD *)(a2 + 184), 20, 0) )
    {
      v5 = sub_1400055E4(*(_DWORD *)(*(_QWORD *)(v2 + 32) + 16i64) != 0 ? 6 : 2, *(unsigned __int16 **)(v2 + 32), 0i64);
      goto LABEL_17;
    }
    v5 = -1073741811;
    if ( (dword_140035180 & 0x80u) != 0 )
    {
      v6 = L"DispatchInternalDIOC: Invalid buffer size in ID_IOCTL_INTERNAL_DC_AlertOnAccess";
      goto LABEL_11;
    }
  }
LABEL_17:
  *(_DWORD *)(v3 + 48) = v5;
  IofCompleteRequest((PIRP)v3, 0);
  return v5;
}
// 140022660: using guessed type wchar_t aDispatchintern_1[84];
// 140022710: using guessed type wchar_t aDispatchintern_0[80];
// 1400306C0: using guessed type char byte_1400306C0;
// 140035180: using guessed type int dword_140035180;

//----- (00000001400052C8) ----------------------------------------------------
__int64 __fastcall sub_1400052C8(__int64 a1, __int64 a2, _BYTE *a3, __int64 a4, int a5, _BYTE *a6, char *a7)
{
  bool v7; // zf
  __int64 v8; // r12
  _BYTE *v9; // r14
  char *v10; // rdi
  __int64 v11; // rbp
  __int64 v12; // rsi
  unsigned int v13; // ebx
  char v14; // al
  char v16; // cl
  int v17; // er8
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-38h]

  v7 = byte_1400306C0 == 0;
  v8 = a4;
  v9 = a3;
  v10 = a7;
  v11 = a2;
  v12 = a1;
  *a6 = 0;
  *v10 = 0;
  *a3 = 1;
  if ( v7 )
    return 0i64;
  LODWORD(a7) = 0;
  v13 = sub_140004FB8(a1, a2, &a7);
  v14 = (char)a7;
  if ( (signed int)a7 >= 0 && v13 != -1073741248 && v13 != -1073741749 && v13 != -1073741536 )
    v13 = -1073741823;
  if ( !v13 )
  {
    v16 = ((unsigned int)a7 >> 2) & 1;
    *v10 = v16;
    if ( !(v14 & 1) )
    {
      v17 = (a5 & 0x20D0156) != 0 ? 3 : 1;
LABEL_18:
      if ( v16 )
        v17 |= 4u;
      else
        *v9 = 0;
      sub_1400050A8(v12, v11, v17);
      return 0i64;
    }
    if ( !(v14 & 2) && sub_14000566C(v8, a5, a6, v16) )
    {
      v16 = *v10;
      v17 = 2;
      goto LABEL_18;
    }
    return 0i64;
  }
  if ( v13 != -1073741248 && v13 != -1073741749 && v13 != -1073741536 )
  {
    LODWORD(BugCheckParameter3) = v13;
    sub_140006BB4(0x276ui64, 0x159ui64, 0i64, 0xE03D0301, BugCheckParameter3, v12);
  }
  return v13;
}
// 1400306C0: using guessed type char byte_1400306C0;

//----- (0000000140005424) ----------------------------------------------------
LONG __fastcall sub_140005424(unsigned __int8 a1)
{
  unsigned __int8 v1; // di
  unsigned int v2; // ebx
  UNICODE_STRING *v3; // rax
  unsigned int v4; // ebx
  UNICODE_STRING *v5; // rax
  LONG result; // eax
  unsigned int v7; // [rsp+30h] [rbp+8h]

  v1 = a1;
  if ( a1 )
  {
    v2 = 60;
    v3 = sub_14000589C();
    if ( sub_1400095B8(v3, L"DCTimeout", &v7) )
      v2 = v7;
    dword_14002B0F0 = v2;
    if ( (dword_140035180 & 0x80u) != 0 )
      sub_140007A38((__int64)L"Device control event processing timeout will be %d seconds", v2);
    v4 = 5;
    v5 = sub_14000589C();
    if ( sub_1400095B8(v5, L"DeviceControlReportInterval", &v7) )
      v4 = v7;
    dword_14002B0F4 = v4;
    if ( (dword_140035180 & 0x80u) != 0 )
      sub_140007A38((__int64)L"Device control report interval timeout will be %d seconds", v4);
  }
  sub_14000572C();
  byte_1400306C0 = v1;
  sub_1400056B4();
  result = dword_140035180;
  if ( (dword_140035180 & 0x80u) != 0 )
    result = sub_140007A38((__int64)L"EnableDeviceControl: Device Control enabled status set to %d", v1);
  return result;
}
// 1400223E0: using guessed type wchar_t aDctimeout[10];
// 140022400: using guessed type wchar_t aDeviceControlE[59];
// 140022480: using guessed type wchar_t aDevicecontrolr[28];
// 1400224C0: using guessed type wchar_t aDeviceControlR[58];
// 140022540: using guessed type wchar_t aEnabledeviceco[61];
// 14002B0F0: using guessed type int dword_14002B0F0;
// 14002B0F4: using guessed type int dword_14002B0F4;
// 1400306C0: using guessed type char byte_1400306C0;
// 140035180: using guessed type int dword_140035180;

//----- (00000001400054F8) ----------------------------------------------------
void __fastcall sub_1400054F8(__int64 a1, _DWORD *a2, char a3, __int64 a4, __int64 a5, __int64 a6)
{
  signed int v6; // eax
  bool v7; // cl

  v6 = 0;
  if ( a3 )
  {
    v6 = 4;
    v7 = a4 == 2;
    if ( a4 != 2 )
      v6 = 0;
  }
  else
  {
    *(_BYTE *)(a1 + 3) = 0;
    *(_DWORD *)a1 |= 0x3000000u;
    if ( *a2 != -1073741772 )
      return;
    *a2 = -1073741790;
    v7 = 1;
  }
  if ( v7 )
    sub_1400050A8(a5, a6, v6 | 2);
}

//----- (0000000140005550) ----------------------------------------------------
char sub_140005550()
{
  return byte_1400306C0;
}
// 1400306C0: using guessed type char byte_1400306C0;

//----- (0000000140005558) ----------------------------------------------------
__int64 __fastcall sub_140005558(unsigned __int16 *a1, __int64 a2, _DWORD *a3)
{
  unsigned __int16 *v3; // rbx
  _DWORD *v4; // rdi
  int v5; // eax
  unsigned int v6; // ebx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]
  PVOID Object; // [rsp+68h] [rbp+20h]

  Object = 0i64;
  v3 = a1;
  v4 = a3;
  v5 = sub_140007050(a2, &Object);
  if ( v5 < 0 )
  {
    LODWORD(BugCheckParameter3) = v5;
    sub_140006BB4(0x276ui64, 0x8Aui64, 0i64, 0xE03D0300, BugCheckParameter3, (char)v3);
  }
  v6 = sub_1400198DC(dword_14002B0F0, v3, (__int64)Object, v4);
  if ( Object )
    ObfDereferenceObject(Object);
  return v6;
}
// 14002B0F0: using guessed type int dword_14002B0F0;

//----- (00000001400055E4) ----------------------------------------------------
__int64 __fastcall sub_1400055E4(int a1, unsigned __int16 *a2, __int64 a3)
{
  unsigned __int16 *v3; // rbx
  int v4; // edi
  int v5; // eax
  unsigned int v6; // ebx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]
  PVOID Object; // [rsp+68h] [rbp+20h]

  Object = 0i64;
  v3 = a2;
  v4 = a1;
  v5 = sub_140007050(a3, &Object);
  if ( v5 < 0 )
  {
    LODWORD(BugCheckParameter3) = v5;
    sub_140006BB4(0x276ui64, 0xDCui64, 0i64, 0xE03D0300, BugCheckParameter3, (char)v3);
  }
  v6 = sub_140019A20(dword_14002B0F0, v4, v3, (__int64)Object);
  if ( Object )
    ObfDereferenceObject(Object);
  return v6;
}
// 14002B0F0: using guessed type int dword_14002B0F0;

//----- (000000014000566C) ----------------------------------------------------
char __fastcall sub_14000566C(__int64 a1, int a2, _BYTE *a3, char a4)
{
  int v4; // eax

  *a3 = 0;
  v4 = *(unsigned __int8 *)(a1 + 3);
  if ( !*(_BYTE *)(a1 + 3) )
    goto LABEL_6;
  switch ( v4 )
  {
    case 1:
LABEL_10:
      if ( a2 & 0x20D0156 )
        goto LABEL_6;
      return 0;
    case 2:
LABEL_6:
      *a3 = 0;
      return 1;
    case 3:
      if ( !a4 )
      {
        *(_BYTE *)(a1 + 3) = 0;
        *(_DWORD *)a1 |= 0x1000000u;
      }
      *a3 = 1;
      goto LABEL_10;
  }
  if ( (unsigned int)(v4 - 4) <= 1 )
    goto LABEL_6;
  return 0;
}

//----- (00000001400056B4) ----------------------------------------------------
int sub_1400056B4()
{
  int result; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-38h]
  void *v2[4]; // [rsp+38h] [rbp-20h]
  ULONG_PTR v3; // [rsp+60h] [rbp+8h]

  LODWORD(v3) = 0;
  LODWORD(v2[0]) = 0;
  result = sub_14000D540(0x8B172007, L"\\Device\\SDCFilter", 1u, 0x8B172003, 0i64, 0, 0i64, v2[0], (__int64)&v3);
  if ( result & 0xFFFFFFFD )
  {
    LODWORD(BugCheckParameter3) = v3;
    result = sub_140006BB4(0x276ui64, 0x7Aui64, 0i64, 0xE03D0306, BugCheckParameter3, 0);
  }
  return result;
}
// 140022630: using guessed type wchar_t aDeviceSdcfilte[18];

//----- (000000014000572C) ----------------------------------------------------
LONG sub_14000572C()
{
  LONG result; // eax

  _InterlockedIncrement(&dword_1400306C4);
  if ( dword_1400306C4 == -1 )
    _InterlockedIncrement(&dword_1400306C4);
  result = dword_140035180;
  if ( (dword_140035180 & 0x80u) != 0 )
    result = sub_140007A38((__int64)L"SignalDCConfigChange: Device Control config change %d");
  return result;
}
// 1400225C0: using guessed type wchar_t aSignaldcconfig[54];
// 1400306C4: using guessed type int dword_1400306C4;
// 140035180: using guessed type int dword_140035180;

//----- (000000014000576C) ----------------------------------------------------
__m128i *__fastcall sub_14000576C(__m128i *a1)
{
  __m128i *result; // rax

  result = a1;
  _mm_storeu_si128(a1, (__m128i)xmmword_140028B60);
  return result;
}
// 140028B60: using guessed type __int128 xmmword_140028B60;

//----- (000000014000577C) ----------------------------------------------------
void __fastcall sub_14000577C(__int64 a1)
{
  void *v1; // rcx

  v1 = *(void **)(a1 + 8);
  if ( v1 )
    ExFreePoolWithTag(v1, 0x6B724349u);
}

//----- (00000001400057A0) ----------------------------------------------------
__int64 __fastcall sub_1400057A0(PUNICODE_STRING Destination, unsigned __int16 *a2, const WCHAR *a3)
{
  unsigned __int16 *v3; // rbx
  PUNICODE_STRING v4; // rdi
  unsigned int v6; // esi
  __m128i *v7; // rax
  __m128i *v8; // rbp
  bool v9; // zf
  UNICODE_STRING DestinationString; // [rsp+20h] [rbp-18h]

  v3 = a2;
  v4 = Destination;
  if ( !a2 || !*((_QWORD *)a2 + 1) )
    return 3221225485i64;
  if ( Destination->Buffer )
    return 0i64;
  v6 = *a2;
  _mm_storeu_si128((__m128i *)&DestinationString, (__m128i)xmmword_140028B60);
  if ( a3 )
  {
    RtlInitUnicodeString(&DestinationString, a3);
    v6 += DestinationString.Length;
    if ( v6 > 0xFFFF )
      return 3221225485i64;
  }
  v7 = (__m128i *)ExAllocatePoolWithTag(PagedPool, v6, 0x6B724349u);
  v8 = v7;
  if ( v7 )
  {
    sub_140021A80(v7, *((_QWORD *)v3 + 1), *v3);
    v9 = DestinationString.Buffer == 0i64;
    v4->Buffer = (PWSTR)v8;
    v4->MaximumLength = v6;
    v4->Length = *v3;
    if ( !v9 )
      RtlAppendUnicodeStringToString(v4, &DestinationString);
    return 0i64;
  }
  return 3221225626i64;
}
// 140028B60: using guessed type __int128 xmmword_140028B60;

//----- (000000014000589C) ----------------------------------------------------
UNICODE_STRING *sub_14000589C()
{
  return &Destination;
}

//----- (00000001400058A4) ----------------------------------------------------
__int64 __fastcall sub_1400058A4(unsigned __int16 *a1)
{
  return sub_1400057A0(&Destination, a1, 0i64);
}

//----- (00000001400058C0) ----------------------------------------------------
PVOID __fastcall sub_1400058C0(__int64 a1, unsigned int a2)
{
  return ExAllocatePoolWithTag(PagedPool, a2, 0x74664349u);
}

//----- (00000001400058E0) ----------------------------------------------------
__int64 __fastcall sub_1400058E0(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  __int64 result; // rax

  if ( *a3 <= *a2 )
    result = 2 - (unsigned int)(*a3 < *a2);
  else
    result = 0i64;
  return result;
}

//----- (0000000140005900) ----------------------------------------------------
void __fastcall sub_140005900(__int64 a1, void *a2)
{
  ExFreePoolWithTag(a2, 0x74664349u);
}

//----- (0000000140005920) ----------------------------------------------------
PVOID __fastcall sub_140005920(__int64 a1, unsigned int a2)
{
  return ExAllocatePoolWithTag(PagedPool, a2, 0x74674349u);
}

//----- (0000000140005940) ----------------------------------------------------
char __fastcall sub_140005940(__int64 a1, unsigned __int64 *a2, __int64 a3)
{
  int v3; // ecx
  char result; // al

  v3 = sub_140021880(a2, a3, 0x10ui64);
  if ( v3 )
    result = v3 >= 0;
  else
    result = 2;
  return result;
}

//----- (0000000140005970) ----------------------------------------------------
void __fastcall sub_140005970(__int64 a1, void *a2)
{
  ExFreePoolWithTag(a2, 0x74674349u);
}

//----- (0000000140005984) ----------------------------------------------------
__int64 __fastcall sub_140005984(__int64 a1)
{
  __int64 v1; // rdi
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 16);
  RtlDeleteElementGenericTableAvl(v1 + 16, a1);
  result = RtlIsGenericTableEmptyAvl(v1 + 16);
  if ( (_BYTE)result )
    result = RtlDeleteElementGenericTableAvl(&unk_1400306E0, v1);
  return result;
}
// 1400282E8: using guessed type __int64 __fastcall RtlDeleteElementGenericTableAvl(_QWORD, _QWORD);
// 1400282F8: using guessed type __int64 __fastcall RtlIsGenericTableEmptyAvl(_QWORD);

//----- (00000001400059DC) ----------------------------------------------------
__int64 sub_1400059DC()
{
  return RtlInitializeGenericTableAvl(&unk_1400306E0, sub_140005940, sub_140005920, sub_140005970, 0i64);
}
// 1400282D8: using guessed type __int64 __fastcall RtlInitializeGenericTableAvl(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140005A14) ----------------------------------------------------
signed __int64 __fastcall sub_140005A14(__m128i *a1, __int64 a2, __int64 a3, __int64 *a4, _QWORD *a5)
{
  __int64 v5; // rdi
  __int64 v6; // r14
  __m128i *v7; // rbx
  __int64 *v8; // r15
  __int64 v9; // rbx
  __int64 v10; // rax
  ULONG_PTR v11; // rdx
  __int64 v13; // rax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-A1h]
  char v15; // [rsp+30h] [rbp-91h]
  char v16; // [rsp+31h] [rbp-90h]
  __int64 v17; // [rsp+38h] [rbp-89h]
  __int64 v18; // [rsp+40h] [rbp-81h]
  __int64 v19; // [rsp+48h] [rbp-79h]
  __int128 v20; // [rsp+50h] [rbp-71h]
  char v21; // [rsp+60h] [rbp-61h]

  v5 = a2;
  v6 = a3;
  v7 = a1;
  v8 = a4;
  sub_140021DC0((__m128 *)&v21, 0, 0x68ui64);
  _mm_storeu_si128((__m128i *)&v20, *v7);
  v9 = RtlLookupElementGenericTableAvl(&unk_1400306E0, &v20);
  if ( !v9 )
  {
    v10 = RtlInsertElementGenericTableAvl(&unk_1400306E0, &v20, 120i64, &v15);
    v9 = v10;
    if ( !v10 )
    {
      v11 = 157i64;
LABEL_4:
      LODWORD(BugCheckParameter3) = -1073741670;
      sub_140006BB4(0x277ui64, v11, 0i64, 0xE03D000B, BugCheckParameter3, 0);
      return 3221225626i64;
    }
    RtlInitializeGenericTableAvl(v10 + 16, sub_1400058E0, sub_1400058C0, sub_140005900, 0i64);
  }
  v17 = v5;
  v18 = v6;
  v19 = v9;
  v13 = RtlLookupElementGenericTableAvl(v9 + 16, &v17);
  if ( v13 )
  {
    *a5 = *(_QWORD *)(v13 + 8);
    *(_QWORD *)(v13 + 8) = v6;
  }
  else
  {
    v13 = RtlInsertElementGenericTableAvl(v9 + 16, &v17, 24i64, &v16);
    if ( !v13 )
    {
      if ( (unsigned __int8)RtlIsGenericTableEmptyAvl(v9 + 16) )
        RtlDeleteElementGenericTableAvl(&unk_1400306E0, v9);
      v11 = 203i64;
      goto LABEL_4;
    }
    *a5 = 0i64;
  }
  *v8 = v13;
  return 0i64;
}
// 1400282D8: using guessed type __int64 __fastcall RtlInitializeGenericTableAvl(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400282E0: using guessed type __int64 __fastcall RtlInsertElementGenericTableAvl(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400282E8: using guessed type __int64 __fastcall RtlDeleteElementGenericTableAvl(_QWORD, _QWORD);
// 1400282F0: using guessed type __int64 __fastcall RtlLookupElementGenericTableAvl(_QWORD, _QWORD);
// 1400282F8: using guessed type __int64 __fastcall RtlIsGenericTableEmptyAvl(_QWORD);

//----- (0000000140005BB8) ----------------------------------------------------
__int64 __fastcall sub_140005BB8(__m128i *a1, __int64 a2)
{
  __int64 v2; // rdi
  __m128i *v3; // rbx
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 result; // rax
  __int64 v7; // [rsp+20h] [rbp-B8h]
  __int128 v8; // [rsp+28h] [rbp-B0h]
  __int128 v9; // [rsp+40h] [rbp-98h]
  char v10; // [rsp+50h] [rbp-88h]

  v2 = a2;
  v3 = a1;
  sub_140021DC0((__m128 *)&v10, 0, 0x68ui64);
  _mm_storeu_si128((__m128i *)&v9, *v3);
  v4 = RtlLookupElementGenericTableAvl(&unk_1400306E0, &v9);
  if ( v4
    && (v7 = v2,
        _mm_storeu_si128((__m128i *)&v8, (__m128i)0i64),
        (v5 = RtlLookupElementGenericTableAvl(v4 + 16, &v7)) != 0) )
  {
    result = *(_QWORD *)(v5 + 8);
  }
  else
  {
    result = 0i64;
  }
  return result;
}
// 1400282F0: using guessed type __int64 __fastcall RtlLookupElementGenericTableAvl(_QWORD, _QWORD);

//----- (0000000140005C64) ----------------------------------------------------
signed __int64 __fastcall sub_140005C64(__int16 a1, struct _FILE_OBJECT *a2, __int64 a3, char a4, char a5)
{
  signed __int64 v5; // rbx
  const UNICODE_STRING *v6; // r14
  struct _FILE_OBJECT *v7; // rsi
  __int16 v8; // r12
  struct _FILE_OBJECT *v9; // rcx
  HANDLE v10; // rax
  unsigned int v11; // eax
  NTSTATUS v13; // edi
  unsigned int v14; // eax
  ULONG v15; // er15
  __int16 *v16; // rax
  __int16 *v17; // rdi
  NTSTATUS v18; // eax
  HANDLE FileHandle; // [rsp+60h] [rbp-51h]
  HANDLE Handle; // [rsp+68h] [rbp-49h]
  __int16 v21; // [rsp+70h] [rbp-41h]
  __int16 v22; // [rsp+72h] [rbp-3Fh]
  __int16 *v23; // [rsp+78h] [rbp-39h]
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+80h] [rbp-31h]
  OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+90h] [rbp-21h]
  unsigned int FileInformation; // [rsp+C0h] [rbp+Fh]

  v5 = 0i64;
  v6 = (const UNICODE_STRING *)a3;
  v7 = a2;
  v8 = a1;
  if ( !a5 )
    return sub_14001A88C(a1, &a2->FileName, a2, (const UNICODE_STRING *)a3, 0);
  if ( !*(_BYTE *)(a3 + 1062) || a4 & 0x20 )
    return v5;
  v9 = a2->RelatedFileObject;
  v10 = 0i64;
  FileHandle = 0i64;
  Handle = 0i64;
  if ( !v9 )
  {
LABEL_10:
    ObjectAttributes.RootDirectory = v10;
    ObjectAttributes.Length = 48;
    ObjectAttributes.Attributes = 512;
    ObjectAttributes.ObjectName = &v7->FileName;
    _mm_storeu_si128((__m128i *)&ObjectAttributes.SecurityDescriptor, (__m128i)0i64);
    v13 = ZwCreateFile(&FileHandle, 0, &ObjectAttributes, &IoStatusBlock, 0i64, 0x80u, 7u, 1u, 0x2100u, 0i64, 0);
    if ( Handle )
      ZwClose(Handle);
    if ( v13 < 0 )
    {
      if ( v13 != 264 )
        goto LABEL_26;
    }
    else if ( v13 != 264 )
    {
      v14 = ZwQueryInformationFile(FileHandle, &IoStatusBlock, &FileInformation, 8u, (FILE_INFORMATION_CLASS)9);
      if ( v14 == -2147483643 )
      {
        v15 = (unsigned __int16)(FileInformation + 8);
        v16 = (__int16 *)sub_14001A0AC(v15);
        v17 = v16;
        if ( v16 )
        {
          v18 = ZwQueryInformationFile(FileHandle, &IoStatusBlock, v16, v15, (FILE_INFORMATION_CLASS)9);
          if ( v18 < 0 )
          {
            if ( dword_140035180 & 1 )
              sub_140007A38(
                (__int64)L"ZwQueryInformationFile failed getting name for a file opened by id with status code: %x",
                (unsigned int)v18);
          }
          else
          {
            v17[((unsigned __int64)FileInformation >> 1) + 2] = 0;
            v22 = *v17;
            v21 = v22;
            v23 = v17 + 2;
            v5 = sub_14001A88C(v8, (const UNICODE_STRING *)&v21, v7, v6, 0);
          }
          sub_14001A454((__int64)v17);
        }
      }
      else if ( dword_140035180 & 1 )
      {
        sub_140007A38(
          (__int64)L"ZwQueryInformationFile failed getting name size for a file opened by id with status code: %x",
          v14);
      }
      ZwClose(FileHandle);
      return v5;
    }
    ZwClose(FileHandle);
LABEL_26:
    if ( dword_140035180 & 1 )
      sub_140007A38((__int64)L"ZwCreateFile failed opening a file opened by id with status code: %x", (unsigned int)v13);
    return v5;
  }
  v11 = ObOpenObjectByPointer(v9, 512i64, 0i64, 0i64, 0i64, 0, &Handle);
  if ( (v11 & 0x80000000) == 0 )
  {
    v10 = Handle;
    goto LABEL_10;
  }
  if ( dword_140035180 & 1 )
    sub_140007A38(
      (__int64)L"ObOpenObjectByPointer failed opening related fileobject for a file opened by id with status code: %x",
      v11);
  return 0i64;
}
// 1400227B0: using guessed type wchar_t aObopenobjectby[101];
// 140022880: using guessed type wchar_t aZwqueryinforma_0[88];
// 140022930: using guessed type wchar_t aZwqueryinforma[93];
// 1400229F0: using guessed type wchar_t aZwcreatefileFa[69];
// 140028300: using guessed type __int64 __fastcall ObOpenObjectByPointer(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140035180: using guessed type int dword_140035180;

//----- (0000000140005F18) ----------------------------------------------------
char sub_140005F18()
{
  UNICODE_STRING *v0; // rax
  char result; // al
  int v2; // [rsp+30h] [rbp+8h]

  v2 = 0;
  SpinLock = 0i64;
  v0 = sub_14000589C();
  result = sub_1400095B8(v0, L"ThrottleBusyMsgs", &v2);
  if ( result )
    byte_14002B0F8 = v2 == 1;
  return result;
}
// 140022A90: using guessed type wchar_t aThrottlebusyms[17];
// 14002B0F8: using guessed type char byte_14002B0F8;

//----- (0000000140005F58) ----------------------------------------------------
void __usercall sub_140005F58(ULONG_PTR BugCheckParameter1@<rcx>, ULONG_PTR BugCheckParameter2@<rdx>, ULONG a3@<r8d>, int a4@<r9d>, __int64 a5, __int64 a6, __int64 a7)
{
  unsigned int v7; // er15
  int v8; // edi
  ULONG v9; // esi
  unsigned int v10; // er14
  char v11; // bp
  char v12; // bl
  KIRQL v13; // dl
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-38h]

  v7 = BugCheckParameter1;
  v8 = a4;
  v9 = a3;
  v10 = BugCheckParameter2;
  v11 = 0;
  v12 = 0;
  v13 = KeAcquireSpinLockRaiseToDpc(&SpinLock);
  byte_140030755 = 1;
  if ( byte_14002B0F8 )
  {
    if ( v9 != -532873136 && v9 + 532872653 > 4 || v8 != -1073741670 )
    {
      v12 = byte_140030754;
    }
    else
    {
      v12 = byte_140030754;
      if ( (unsigned int)dword_140030750 >= 0xA )
      {
        if ( byte_140030754 )
          goto LABEL_11;
        v11 = 1;
        v12 = 1;
        byte_140030754 = 1;
      }
      if ( !v12 )
        ++dword_140030750;
    }
  }
LABEL_11:
  KeReleaseSpinLock(&SpinLock, v13);
  if ( v11 )
  {
    LODWORD(BugCheckParameter3) = v8;
    sub_140006BB4(0x14Aui64, 0xE5ui64, 0i64, 0xE03D0053, BugCheckParameter3, 0);
  }
  if ( !v12 )
    sub_140006248(v7, v10, v9, v8, a5, a6, a7);
}
// 14002B0F8: using guessed type char byte_14002B0F8;
// 140030750: using guessed type int dword_140030750;
// 140030754: using guessed type char byte_140030754;
// 140030755: using guessed type char byte_140030755;

//----- (0000000140006084) ----------------------------------------------------
void __fastcall sub_140006084(ULONG_PTR BugCheckParameter1, ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter3, unsigned __int16 *a4, __int64 a5)
{
  unsigned __int16 *v5; // rbx
  int v6; // edi
  unsigned int v7; // er14
  unsigned int v8; // esi
  __int64 v9; // rcx
  __int64 v10; // rax
  int v11; // er9
  ULONG v12; // er8
  __int64 v13; // r15
  __int64 v14; // rax
  __int16 v15; // cx
  unsigned __int64 v16; // r15
  signed __int16 v17; // cx
  ULONG_PTR BugCheckParameter3a; // [rsp+20h] [rbp-61h]
  char v19[8]; // [rsp+40h] [rbp-41h]
  __int64 v20; // [rsp+48h] [rbp-39h]
  char v21[4]; // [rsp+50h] [rbp-31h]
  wchar_t *v22; // [rsp+58h] [rbp-29h]
  wchar_t Dest; // [rsp+60h] [rbp-21h]

  *(_DWORD *)v21 = 2228224;
  v5 = a4;
  v22 = &Dest;
  v6 = BugCheckParameter3;
  v7 = BugCheckParameter2;
  v8 = BugCheckParameter1;
  if ( a4 && !KeGetCurrentIrql() )
  {
    *(_QWORD *)v19 = a5;
    if ( (signed int)sub_140006350(&Dest, 17i64, L"%16I64x", a5) >= 0 )
      strcpy(v21, " ");
    if ( v6 == -1073741670 )
    {
      v10 = PsGetCurrentProcessId(v9);
      v11 = -1073741670;
      v12 = -532873136;
LABEL_14:
      sub_140005F58(v8, v7, v12, v11, (__int64)v5, v10, (__int64)v21);
      return;
    }
    if ( *v5 <= 0x7Au )
    {
      v10 = PsGetCurrentProcessId(v9);
      v11 = v6;
      v12 = -532873135;
      goto LABEL_14;
    }
    v20 = *((_QWORD *)v5 + 1);
    v13 = v20;
    *(_DWORD *)v19 = 7995514;
    v14 = PsGetCurrentProcessId(v9);
    sub_140005F58(v8, v7, 0xE03D0051, v6, (__int64)v19, v14, (__int64)v21);
    v15 = *v5;
    v16 = v13 + 122;
    do
    {
      v17 = v5[4] + v15 - v16;
      v20 = v16;
      if ( (unsigned __int16)v17 > 0x9Cu )
        v17 = 156;
      *(_WORD *)v19 = v17;
      *(_WORD *)&v19[2] = v17;
      LODWORD(BugCheckParameter3a) = v6;
      sub_140006BB4(v8, v7, 0i64, 0xE03D0052, BugCheckParameter3a, (unsigned __int64)v21);
      v15 = *v5;
      v16 += 156i64;
    }
    while ( v16 < *((_QWORD *)v5 + 1) + (unsigned __int64)*v5 );
  }
}
// 140022AC0: using guessed type wchar_t a16i64x[8];
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);

//----- (0000000140006248) ----------------------------------------------------
int __usercall sub_140006248@<eax>(ULONG_PTR BugCheckParameter1@<rcx>, ULONG_PTR BugCheckParameter2@<rdx>, ULONG a3@<r8d>, int a4@<r9d>, __int64 a5, __int64 a6, __int64 a7)
{
  int result; // eax
  _WORD *v8; // rsi
  unsigned int v9; // er14
  unsigned int v10; // er15
  int v11; // er13
  ULONG v12; // er12
  unsigned __int16 v13; // di
  unsigned __int16 v14; // ax
  unsigned __int64 v15; // r8
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-91h]
  __int16 *v17; // [rsp+28h] [rbp-89h]
  int v18; // [rsp+50h] [rbp-61h]
  char *v19; // [rsp+58h] [rbp-59h]
  __int16 v20; // [rsp+60h] [rbp-51h]
  unsigned __int16 v21; // [rsp+68h] [rbp-49h]
  unsigned __int16 v22; // [rsp+6Ah] [rbp-47h]
  unsigned __int64 v23; // [rsp+70h] [rbp-41h]
  char v24; // [rsp+78h] [rbp-39h]

  result = a7;
  v8 = &unk_140028B70;
  v18 = 2228225;
  if ( a7 )
    v8 = (_WORD *)a7;
  v9 = BugCheckParameter1;
  v10 = BugCheckParameter2;
  v11 = a4;
  v12 = a3;
  v19 = &v24;
  v13 = 154 - *v8;
  v20 = 154 - *v8;
  if ( a5 && *(_QWORD *)(a5 + 8) )
  {
    sub_140007D18((__int64)&v18, a6);
    v14 = *(_WORD *)a5;
    if ( *(_WORD *)a5 <= v13 )
    {
      LOBYTE(v17) = a5;
    }
    else
    {
      v21 = v13;
      v15 = *(_QWORD *)(a5 + 8) + v14 - (unsigned __int64)v13;
      v17 = (__int16 *)&v21;
      v22 = v13;
      v23 = v15;
    }
    LODWORD(BugCheckParameter3) = v11;
    result = sub_140006BB4(v9, v10, 0i64, v12, BugCheckParameter3, (char)v17);
  }
  return result;
}

//----- (0000000140006350) ----------------------------------------------------
__int64 sub_140006350(wchar_t *Dest, __int64 a2, const wchar_t *a3, ...)
{
  wchar_t *v3; // rsi
  signed int v4; // edi
  unsigned __int64 v5; // rbx
  int v6; // eax
  va_list Args; // [rsp+68h] [rbp+20h]

  va_start(Args, a3);
  v3 = Dest;
  v4 = 0;
  if ( (unsigned __int64)(a2 - 1) > 0x7FFFFFFE )
    v4 = -1073741811;
  if ( v4 < 0 )
  {
    if ( a2 )
      *Dest = 0;
  }
  else
  {
    v5 = a2 - 1;
    v4 = 0;
    v6 = vsnwprintf(Dest, a2 - 1, a3, Args);
    if ( v6 < 0 || v6 > v5 )
    {
      v3[v5] = 0;
      v4 = -2147483643;
    }
    else if ( v6 == v5 )
    {
      v3[v5] = 0;
    }
  }
  return (unsigned int)v4;
}

//----- (00000001400063C8) ----------------------------------------------------
void __fastcall sub_1400063C8(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rdi
  char v3; // bp
  char v4; // si
  _QWORD *v5; // rbx
  KIRQL v6; // al
  signed int v7; // ecx
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 v10; // [rsp+48h] [rbp-60h]
  wchar_t *v11; // [rsp+50h] [rbp-58h]
  wchar_t Dest; // [rsp+58h] [rbp-50h]

  v2 = a1;
  v3 = 0;
  v4 = 0;
  v5 = a2;
  v6 = KeAcquireSpinLockRaiseToDpc(&SpinLock);
  if ( byte_140030754 )
  {
    dword_140030750 = 0;
    v3 = 1;
    byte_140030754 = 0;
  }
  if ( byte_140030755 )
  {
    v7 = 10;
    byte_140030755 = 0;
    dword_140030758 = 10;
  }
  else
  {
    v7 = dword_140030758;
  }
  if ( v7 && v2 && v5 )
  {
    v4 = 1;
    dword_140030758 = v7 - 1;
  }
  KeReleaseSpinLock(&SpinLock, v6);
  if ( v3 )
    sub_140006BB4(0x14Aui64, 0x87ui64, 0i64, 0xE03D0054, 0i64, 0);
  if ( v4 && v2 && v5 )
  {
    LODWORD(v10) = 2228224;
    v11 = &Dest;
    if ( (signed int)sub_140006350(&Dest, 17i64, L"%16I64x", *v5) >= 0 )
      LOWORD(v10) = 32;
    v9 = PsGetCurrentProcessId(v8);
    sub_140006248(0x14Aui64, 0x95ui64, 0xE03D0055, 0, v2, v9, (__int64)&v10);
  }
}
// 140022AC0: using guessed type wchar_t a16i64x[8];
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 140030750: using guessed type int dword_140030750;
// 140030754: using guessed type char byte_140030754;
// 140030755: using guessed type char byte_140030755;
// 140030758: using guessed type int dword_140030758;

//----- (0000000140006568) ----------------------------------------------------
__int64 __fastcall sub_140006568(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  signed int v3; // er8
  HANDLE Handle; // [rsp+30h] [rbp+8h]

  v2 = a2;
  if ( *(_DWORD *)(a1 + 16) != 4 || *(_DWORD *)(a1 + 8) != 4 )
  {
    v3 = -1073741811;
  }
  else
  {
    v3 = sub_140008B80((void *)**(unsigned int **)(a2 + 24), (__int64)&Handle);
    if ( v3 >= 0 )
    {
      if ( (HANDLE)(unsigned int)Handle == Handle )
      {
        **(_DWORD **)(v2 + 24) = (_DWORD)Handle;
        *(_QWORD *)(v2 + 56) = 4i64;
      }
      else
      {
        ZwClose(Handle);
        v3 = -1073741823;
      }
    }
  }
  return (unsigned int)v3;
}

//----- (00000001400065D4) ----------------------------------------------------
__int64 __fastcall sub_1400065D4(__int64 a1)
{
  __int64 v1; // rdi
  __int64 *v2; // rbx
  __int64 *i; // rdx
  char v5; // [rsp+20h] [rbp-28h]

  v1 = a1;
  v2 = &qword_140030760;
  KeAcquireInStackQueuedSpinLock(&qword_1400396A0, &v5);
  for ( i = (__int64 *)qword_140030760; i; i = (__int64 *)*v2 )
  {
    if ( i[3] == v1 )
    {
      *v2 = *i;
      *i = qword_140030770;
      qword_140030770 = (__int64)i;
    }
    else
    {
      v2 = i;
    }
  }
  return KeReleaseInStackQueuedSpinLock(&v5);
}
// 140028330: using guessed type __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD, _QWORD);
// 140028338: using guessed type __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD);
// 140030760: using guessed type __int64 qword_140030760;
// 140030770: using guessed type __int64 qword_140030770;
// 1400396A0: using guessed type __int64 qword_1400396A0;

//----- (0000000140006650) ----------------------------------------------------
char __fastcall sub_140006650(__int64 a1)
{
  __int64 v1; // rdi
  char v2; // bl
  char *v3; // r8
  int i; // eax
  __int64 v5; // rcx
  char v6; // dl
  char v7; // al

  v1 = a1;
  v2 = 0;
  if ( dword_14002B0FC != -1 )
  {
    v3 = (char *)IoGetCurrentProcess() + dword_14002B0FC;
    for ( i = 0; ; ++i )
    {
      v5 = i;
      v6 = *(_BYTE *)(i + v1);
      if ( !v6 || v6 != v3[i] )
        break;
    }
    v7 = 0;
    if ( v6 == v3[v5] )
      v7 = 1;
    v2 = v7;
  }
  return v2;
}
// 14002B0FC: using guessed type int dword_14002B0FC;

//----- (00000001400066CC) ----------------------------------------------------
char __fastcall sub_1400066CC(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rbp
  char v5; // bl
  __int64 v6; // rdi
  _QWORD *i; // rax
  _QWORD *v8; // rcx
  char v10; // [rsp+20h] [rbp-28h]

  v3 = a2;
  v4 = a1;
  v5 = 0;
  v6 = a3;
  KeAcquireInStackQueuedSpinLock(&qword_1400396A0, &v10);
  for ( i = (_QWORD *)qword_140030760; i; i = (_QWORD *)*i )
  {
    if ( i[3] == v6 && i[1] == v4 && i[2] == v3 )
      goto LABEL_9;
  }
  v8 = (_QWORD *)qword_140030770;
  if ( !qword_140030770 )
    goto LABEL_10;
  qword_140030770 = *(_QWORD *)qword_140030770;
  v8[1] = v4;
  v8[2] = v3;
  v8[3] = v6;
  *v8 = qword_140030760;
  qword_140030760 = (__int64)v8;
LABEL_9:
  v5 = 1;
LABEL_10:
  KeReleaseInStackQueuedSpinLock(&v10);
  return v5;
}
// 140028330: using guessed type __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD, _QWORD);
// 140028338: using guessed type __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD);
// 140030760: using guessed type __int64 qword_140030760;
// 140030770: using guessed type __int64 qword_140030770;
// 1400396A0: using guessed type __int64 qword_1400396A0;

//----- (0000000140006784) ----------------------------------------------------
char __fastcall sub_140006784(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 *v4; // rbx
  __int64 v5; // rbp
  __int64 v6; // rdi
  __int64 *v7; // r9
  bool i; // zf
  char v10; // [rsp+20h] [rbp-28h]

  v3 = a2;
  v4 = &qword_140030760;
  v5 = a1;
  v6 = a3;
  KeAcquireInStackQueuedSpinLock(&qword_1400396A0, &v10);
  v7 = (__int64 *)qword_140030760;
  for ( i = qword_140030760 == 0; !i; i = v7 == 0i64 )
  {
    if ( v7[3] == v6 && v7[1] == v5 && v7[2] == v3 )
    {
      *v4 = *v7;
      *v7 = qword_140030770;
      qword_140030770 = (__int64)v7;
      break;
    }
    v4 = v7;
    v7 = (__int64 *)*v7;
  }
  KeReleaseInStackQueuedSpinLock(&v10);
  return 1;
}
// 140028330: using guessed type __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD, _QWORD);
// 140028338: using guessed type __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD);
// 140030760: using guessed type __int64 qword_140030760;
// 140030770: using guessed type __int64 qword_140030770;
// 1400396A0: using guessed type __int64 qword_1400396A0;

//----- (000000014000682C) ----------------------------------------------------
PEPROCESS sub_14000682C()
{
  PEPROCESS result; // rax
  PEPROCESS v1; // r10
  signed int i; // edx
  int j; // er8
  char v4; // r9

  dword_14002B0FC = -1;
  result = IoGetCurrentProcess();
  v1 = result;
  for ( i = 0; i < 1024; ++i )
  {
    for ( j = 0; ; ++j )
    {
      v4 = aSystem[j];
      if ( !v4 || *((_BYTE *)v1 + j + i) != v4 )
        break;
    }
    result = (PEPROCESS)(unsigned int)(j + i);
    if ( *((_BYTE *)v1 + (signed int)result) == v4 )
    {
      dword_14002B0FC = i;
      return result;
    }
  }
  return result;
}
// 14002B0FC: using guessed type int dword_14002B0FC;

//----- (00000001400068A4) ----------------------------------------------------
__int64 sub_1400068A4()
{
  __int64 *v0; // rcx
  __int64 result; // rax

  sub_140006968();
  sub_14000682C();
  qword_1400396A0 = 0i64;
  v0 = (__int64 *)&unk_140030780;
  result = qword_140030770;
  do
  {
    *v0 = result;
    result = (__int64)v0;
    v0 += 4;
  }
  while ( (signed __int64)v0 < (signed __int64)&unk_140030F80 );
  qword_140030770 = result;
  return result;
}
// 140030770: using guessed type __int64 qword_140030770;
// 1400396A0: using guessed type __int64 qword_1400396A0;

//----- (00000001400068EC) ----------------------------------------------------
char __fastcall sub_1400068EC(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdi
  char v4; // bl
  _QWORD *i; // rax
  __int64 v6; // rcx
  char v8; // [rsp+20h] [rbp-28h]

  v2 = a2;
  v3 = a1;
  v4 = 0;
  KeAcquireInStackQueuedSpinLock(&qword_1400396A0, &v8);
  for ( i = (_QWORD *)qword_140030760; i; i = (_QWORD *)*i )
  {
    if ( i[1] == v3 )
    {
      v6 = i[2];
      if ( !v6 || v6 == v2 )
      {
        v4 = 1;
        break;
      }
    }
  }
  KeReleaseInStackQueuedSpinLock(&v8);
  return v4;
}
// 140028330: using guessed type __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD, _QWORD);
// 140028338: using guessed type __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD);
// 140030760: using guessed type __int64 qword_140030760;
// 1400396A0: using guessed type __int64 qword_1400396A0;

//----- (0000000140006968) ----------------------------------------------------
void sub_140006968()
{
  signed int v0; // edi
  CHAR **v1; // rsi
  UNICODE_STRING *v2; // rax
  CHAR *v3; // rax
  CHAR *v4; // rbx
  UNICODE_STRING Destination; // [rsp+20h] [rbp-B8h]
  UNICODE_STRING SourceString; // [rsp+30h] [rbp-A8h]
  UNICODE_STRING String; // [rsp+40h] [rbp-98h]
  STRING v8; // [rsp+50h] [rbp-88h]
  UNICODE_STRING DestinationString; // [rsp+60h] [rbp-78h]
  char v10; // [rsp+70h] [rbp-68h]
  __int64 v11; // [rsp+90h] [rbp-48h]
  __int64 v12; // [rsp+120h] [rbp+48h]

  *(_DWORD *)&SourceString.Length = 0x1000000;
  *(_DWORD *)&String.Length = 0x200000;
  SourceString.Buffer = (PWSTR)&v12;
  *(_DWORD *)&Destination.Length = 8519680;
  String.Buffer = (PWSTR)&v10;
  v0 = 0;
  Destination.Buffer = (PWSTR)&v11;
  v1 = (CHAR **)&unk_140030F80;
  do
  {
    RtlInitUnicodeString(&DestinationString, L"ExcludedProcess");
    RtlCopyUnicodeString(&Destination, &DestinationString);
    if ( RtlIntegerToUnicodeString(v0, 0xAu, &String) )
      break;
    if ( RtlAppendUnicodeStringToString(&Destination, &String) )
      break;
    Destination.Buffer[(unsigned __int64)Destination.Length >> 1] = 0;
    v2 = sub_14000589C();
    if ( !sub_14000972C(v2, Destination.Buffer, (__int64)&SourceString) )
      break;
    if ( SourceString.Length )
    {
      v3 = (CHAR *)ExAllocatePoolWithTag(PagedPool, SourceString.Length + 2i64, 0x49444349u);
      v4 = v3;
      if ( !v3 )
        return;
      v8.Length = 0;
      v8.MaximumLength = SourceString.Length + 1;
      v8.Buffer = v3;
      if ( RtlUnicodeStringToAnsiString(&v8, &SourceString, 0) )
      {
        ExFreePoolWithTag(v4, 0);
        return;
      }
      v4[v8.Length] = 0;
      *v1 = v4;
      ++v1;
      if ( !qword_140030768 )
        qword_140030768 = (__int64)&unk_140030F80;
    }
    ++v0;
  }
  while ( v0 < 32 );
}
// 140030768: using guessed type __int64 qword_140030768;

//----- (0000000140006B5C) ----------------------------------------------------
__int64 sub_140006B5C()
{
  signed __int64 v0; // rbx
  __int64 result; // rax
  void *v2; // rcx

  if ( qword_140030768 )
  {
    v0 = 0i64;
    do
    {
      result = qword_140030768;
      v2 = *(void **)(v0 + qword_140030768);
      if ( !v2 )
        break;
      ExFreePoolWithTag(v2, 0);
      result = qword_140030768;
      *(_QWORD *)(v0 + qword_140030768) = 0i64;
      v0 += 8i64;
    }
    while ( v0 < 256 );
  }
  return result;
}
// 140030768: using guessed type __int64 qword_140030768;

//----- (0000000140006BAC) ----------------------------------------------------
__int64 sub_140006BAC()
{
  return (unsigned int)dword_140031094;
}
// 140031094: using guessed type int dword_140031094;

//----- (0000000140006BB4) ----------------------------------------------------
LONG __usercall sub_140006BB4@<eax>(ULONG_PTR BugCheckParameter1@<rcx>, ULONG_PTR BugCheckParameter2@<rdx>, void *a3@<r8>, ULONG a4@<r9d>, ULONG_PTR BugCheckParameter3, char a6)
{
  int v6; // er15
  char v7; // r12
  ULONG v8; // esi
  ULONG_PTR v9; // rdi
  PVOID v10; // rbx
  __m128 *v11; // r8
  unsigned int v12; // ecx
  __m128 *v13; // rax
  unsigned int v14; // ecx
  __m128 *v15; // rax
  unsigned int v16; // ecx
  unsigned int v17; // edx
  _DWORD *v18; // rcx
  LONG result; // eax
  unsigned int v20; // er14
  __m128i *v21; // rax
  __m128i *v22; // rbx
  unsigned __int8 v23; // [rsp+30h] [rbp-18h]
  char *v24; // [rsp+38h] [rbp-10h]

  v6 = BugCheckParameter2;
  v7 = 0;
  v23 = 0;
  v8 = a4;
  v9 = (unsigned int)BugCheckParameter1;
  v10 = a3;
  _InterlockedIncrement(&dword_140031094);
  v11 = &stru_140031120;
  v12 = 0;
  v13 = &stru_140031120;
  do
  {
    if ( !LODWORD(v13->m128_u64[0]) )
      break;
    if ( LODWORD(v13->m128_u64[0]) == -1 )
LABEL_26:
      KeBugCheckEx(a4, v9, (unsigned int)BugCheckParameter2, (unsigned int)BugCheckParameter3, 0i64);
    ++v12;
    v13 = (__m128 *)((char *)v13 + 4);
  }
  while ( v12 < 0x14 );
  v14 = 0;
  v15 = &stru_140031120;
  do
  {
    if ( !LODWORD(v15->m128_u64[0]) )
      break;
    if ( a4 == LODWORD(v15->m128_u64[0]) )
      goto LABEL_26;
    ++v14;
    v15 = (__m128 *)((char *)v15 + 4);
  }
  while ( v14 < 0x14 );
  v16 = 0;
  do
  {
    if ( !LODWORD(v11->m128_u64[0]) )
      break;
    if ( (unsigned __int16)a4 == LODWORD(v11->m128_u64[0]) )
      goto LABEL_26;
    ++v16;
    v11 = (__m128 *)((char *)v11 + 4);
  }
  while ( v16 < 0x14 );
  v17 = 0;
  v18 = &unk_1400310D0;
  do
  {
    if ( !*v18 )
      break;
    result = (unsigned __int16)a4;
    if ( (unsigned __int16)a4 == *v18 )
      return result;
    ++v17;
    ++v18;
  }
  while ( v17 < 0x14 );
  v24 = &a6;
  if ( !v10 )
    v10 = IoObject;
  v20 = sub_140009904((__int64 *)&v24, &v23);
  v24 = 0i64;
  if ( v20 > 0xC0 )
    v20 = 192;
  v21 = (__m128i *)IoAllocateErrorLogEntry(v10, (unsigned __int8)v20 + 48);
  v22 = v21;
  if ( v21 )
  {
    LOWORD(v21->m128i_i64[0]) = 0;
    WORD1(v21->m128i_i64[0]) = 4;
    v21[2].m128i_i32[2] = BugCheckParameter3;
    HIWORD(v21->m128i_i64[0]) = 48;
    WORD2(v21->m128i_i64[0]) = v23;
    if ( v23 )
    {
      v24 = &a6;
      if ( !sub_1400092F4(v23, v21 + 3, v20, &v24) )
        HIDWORD(v22->m128i_i64[0]) = 0;
      v24 = 0i64;
    }
    else
    {
      HIWORD(v21->m128i_i64[0]) = 0;
    }
    LOWORD(v22->m128i_i64[1]) = 0;
    v22[1].m128i_i32[0] = v6 + ((_DWORD)v9 << 16);
    HIDWORD(v22->m128i_i64[1]) = v8;
    v22[1].m128i_i32[1] = -1073741437;
    v22[1].m128i_i64[1] = 0i64;
    IoWriteErrorLogEntry(v22);
  }
  result = KeGetCurrentIrql();
  if ( (_BYTE)result )
    goto LABEL_36;
  KeWaitForSingleObject(&Object, UserRequest, 0, 0, 0i64);
  if ( qword_140031088 )
  {
    v24 = &a6;
    sub_140021A40((__int64 (*)(void))qword_140031088);
    v7 = 1;
    v24 = 0i64;
  }
  result = KeReleaseMutex(&Object, 0);
  if ( !v7 )
LABEL_36:
    _InterlockedIncrement(&dword_140031090);
  return result;
}
// 140031088: using guessed type __int64 qword_140031088;
// 140031090: using guessed type int dword_140031090;
// 140031094: using guessed type int dword_140031094;

//----- (0000000140006E04) ----------------------------------------------------
signed __int32 __fastcall sub_140006E04(__int64 (*a1)(void))
{
  __int64 (*v1)(void); // rbx
  signed __int32 result; // eax

  v1 = a1;
  KeWaitForSingleObject(&Object, UserRequest, 0, 0, 0i64);
  qword_140031088 = (__int64)v1;
  result = KeReleaseMutex(&Object, 0);
  if ( v1 )
  {
    result = _InterlockedExchange(&dword_140031090, 0);
    if ( result )
      result = sub_140021A40(v1);
  }
  return result;
}
// 140031088: using guessed type __int64 qword_140031088;
// 140031090: using guessed type int dword_140031090;

//----- (0000000140006E84) ----------------------------------------------------
char sub_140006E84()
{
  UNICODE_STRING *v0; // rax
  __int64 v1; // rax
  __m128 *v2; // rcx
  int v4; // [rsp+30h] [rbp+8h]

  sub_140006F08(&stru_140031120, 0x14u, L"BugCheckErrors");
  sub_140006F08((__m128 *)&unk_1400310D0, 0x14u, L"SuppressErrors");
  v0 = sub_14000589C();
  LOBYTE(v1) = sub_1400095B8(v0, L"BugCheckOnError", &v4);
  if ( (_BYTE)v1 )
  {
    v1 = 0i64;
    v2 = &stru_140031120;
    while ( LODWORD(v2->m128_u64[0]) != v4 )
    {
      if ( !LODWORD(v2->m128_u64[0]) )
      {
        stru_140031120.m128_i32[v1] = v4;
        return v1;
      }
      v1 = (unsigned int)(v1 + 1);
      v2 = (__m128 *)((char *)v2 + 4);
      if ( (unsigned int)v1 >= 0x14 )
        return v1;
    }
  }
  return v1;
}
// 140022B00: using guessed type wchar_t aBugcheckerrors[15];
// 140022B20: using guessed type wchar_t aSuppresserrors[15];
// 140022B40: using guessed type wchar_t aBugcheckonerro[16];

//----- (0000000140006F08) ----------------------------------------------------
char __fastcall sub_140006F08(__m128 *a1, unsigned int a2, const WCHAR *a3)
{
  unsigned int v3; // ebx
  const WCHAR *v4; // rsi
  __m128 *v5; // rdi
  unsigned __int16 v6; // r8
  UNICODE_STRING *v7; // rax
  __int64 v8; // rax
  int v9; // ecx
  char *v10; // r8
  __int64 v11; // r10
  __m128 *v12; // rdx
  __m128 *v13; // rdx
  int v15; // [rsp+20h] [rbp-1C8h]
  char *v16; // [rsp+28h] [rbp-1C0h]
  char v17; // [rsp+30h] [rbp-1B8h]

  v3 = a2;
  v15 = 26214400;
  v16 = &v17;
  v4 = a3;
  v5 = a1;
  v6 = 0;
  if ( a2 )
  {
    do
      ++v6;
    while ( v6 < a2 );
    sub_140021DC0(a1, 0, 4i64 * (unsigned __int16)a2);
  }
  v7 = sub_14000589C();
  LOBYTE(v8) = sub_14000972C(v7, v4, (__int64)&v15);
  if ( (_BYTE)v8 )
  {
    v9 = 0;
    LOWORD(v8) = (unsigned __int16)v15 >> 1;
    if ( (unsigned __int16)((unsigned __int16)v15 >> 1) > 0u )
    {
      v10 = v16;
      v11 = (unsigned __int16)v8;
      do
      {
        LOBYTE(v8) = *(unsigned __int16 *)v10 - 48;
        if ( (unsigned __int16)(*(_WORD *)v10 - 48) > 9u )
        {
          if ( v9 )
          {
            v8 = 0i64;
            if ( v3 )
            {
              v12 = v5;
              while ( LODWORD(v12->m128_u64[0]) != v9 )
              {
                if ( !LODWORD(v12->m128_u64[0]) )
                {
                  *((_DWORD *)v5->m128_u64 + v8) = v9;
                  break;
                }
                v8 = (unsigned int)(v8 + 1);
                v12 = (__m128 *)((char *)v12 + 4);
                if ( (unsigned int)v8 >= v3 )
                  break;
              }
            }
          }
          v9 = 0;
        }
        else
        {
          LOBYTE(v8) = *(_WORD *)v10;
          v9 = *(unsigned __int16 *)v10 + 2 * (5 * v9 - 24);
        }
        v10 += 2;
        --v11;
      }
      while ( v11 );
      if ( v9 )
      {
        v8 = 0i64;
        if ( v3 )
        {
          v13 = v5;
          while ( LODWORD(v13->m128_u64[0]) != v9 )
          {
            if ( !LODWORD(v13->m128_u64[0]) )
            {
              *((_DWORD *)v5->m128_u64 + v8) = v9;
              return v8;
            }
            v8 = (unsigned int)(v8 + 1);
            v13 = (__m128 *)((char *)v13 + 4);
            if ( (unsigned int)v8 >= v3 )
              return v8;
          }
        }
      }
    }
  }
  return v8;
}

//----- (0000000140007050) ----------------------------------------------------
__int64 __fastcall sub_140007050(__int64 a1, PVOID *a2)
{
  PVOID *v2; // rdi
  char HandleInformation; // ST28_1
  __int64 result; // rax
  NTSTATUS v5; // ebx
  PVOID *Object; // [rsp+20h] [rbp-21h]
  HANDLE v7; // [rsp+38h] [rbp-9h]
  HANDLE Handle; // [rsp+40h] [rbp-1h]
  int v9; // [rsp+48h] [rbp+7h]
  __int64 v10; // [rsp+50h] [rbp+Fh]
  __int64 v11; // [rsp+58h] [rbp+17h]
  int v12; // [rsp+60h] [rbp+1Fh]
  __int64 v13; // [rsp+68h] [rbp+27h]
  int *v14; // [rsp+70h] [rbp+2Fh]
  int v15; // [rsp+78h] [rbp+37h]
  int v16; // [rsp+7Ch] [rbp+3Bh]
  __int16 v17; // [rsp+80h] [rbp+3Fh]

  v2 = a2;
  if ( a1 )
  {
    HandleInformation = 0;
    result = ObOpenObjectByPointer(a1, 512i64, 0i64, 0i64, 0i64, HandleInformation, &Handle);
    goto LABEL_3;
  }
  if ( (signed int)ZwOpenThreadTokenEx(-2i64, 2i64, 0i64, 512i64, &Handle) < 0 )
  {
    result = ZwOpenProcessTokenEx(-1i64, 2i64, 512i64, &v7);
LABEL_3:
    if ( (signed int)result < 0 )
      return result;
  }
  v17 = 0;
  v10 = 0i64;
  v11 = 0i64;
  v13 = 0i64;
  v14 = &v15;
  LODWORD(Object) = 2;
  v15 = 12;
  v16 = 2;
  v9 = 48;
  v12 = 512;
  v5 = ZwDuplicateToken(v7, 983551i64, &v9, 0i64, Object, &Handle);
  if ( v5 >= 0 )
  {
    v5 = ObReferenceObjectByHandle(Handle, 0xF01FFu, 0i64, 0, v2, 0i64);
    ZwClose(Handle);
  }
  ZwClose(v7);
  return (unsigned int)v5;
}
// 140028300: using guessed type __int64 __fastcall ObOpenObjectByPointer(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140028370: using guessed type __int64 __fastcall ZwOpenProcessTokenEx(_QWORD, _QWORD, _QWORD, _QWORD);
// 140028378: using guessed type __int64 __fastcall ZwOpenThreadTokenEx(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140028380: using guessed type __int64 __fastcall ZwDuplicateToken(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400071D0) ----------------------------------------------------
__int64 __fastcall sub_1400071D0(__int64 a1)
{
  __int64 result; // rax
  unsigned int v2; // ebx
  HANDLE Handle; // [rsp+50h] [rbp+8h]

  Handle = 0i64;
  if ( !a1 )
    return 3221225473i64;
  result = ObOpenObjectByPointer(a1, 512i64, 0i64, 0i64, 0i64, 0, &Handle);
  if ( (signed int)result >= 0 )
  {
    v2 = ZwSetInformationThread(-2i64, 5i64, &Handle);
    ZwClose(Handle);
    result = v2;
  }
  return result;
}
// 140028300: using guessed type __int64 __fastcall ObOpenObjectByPointer(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140028368: using guessed type __int64 __fastcall ZwSetInformationThread(_QWORD, _QWORD, _QWORD);

//----- (0000000140007260) ----------------------------------------------------
__int64 __fastcall sub_140007260(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  unsigned int v3; // ebx
  struct _IRP *v4; // rdi
  int v5; // edx
  _DWORD *v7; // rcx

  v2 = *(_QWORD *)(a2 + 184);
  v3 = 0;
  v4 = (struct _IRP *)a2;
  *(_QWORD *)(a2 + 56) = 0i64;
  v5 = *(_DWORD *)(v2 + 24);
  switch ( v5 )
  {
    case -2019347453:
      if ( !sub_14001763C(v2, 0, 4) || *(_QWORD *)(v2 + 32) )
      {
        if ( dword_140035180 & 0x400080 )
          sub_140007A38((__int64)L"GetInterfaceVersion called with invalid parameters");
        v3 = -1073741811;
      }
      else
      {
        v7 = v4->UserBuffer;
        if ( (unsigned __int64)v7 >= MmSystemRangeStart )
        {
          *v7 = 3;
          v4->IoStatus.Information = 4i64;
        }
        else
        {
          if ( dword_140035180 & 0x400080 )
            sub_140007A38(
              (__int64)L"GetInterfaceVersion called with an invalid output buffer address (0x%p)",
              v4->UserBuffer);
          v3 = -1073741819;
        }
      }
      goto LABEL_23;
    case -2019347449:
      return sub_14000CC3C(a1, (__int64)v4);
    case -2019347445:
      if ( sub_14001763C(v2, 14, 0) )
      {
        v3 = sub_140019D00(
               4i64,
               0xFFFFFFFFi64,
               **(unsigned int **)(v2 + 32),
               *(_WORD *)(*(_QWORD *)(v2 + 32) + 4i64),
               *(_QWORD **)(*(_QWORD *)(v2 + 32) + 6i64));
      }
      else
      {
        v3 = -1073741811;
        if ( (dword_140035180 & 0x80u) != 0 )
          sub_140007A38((__int64)L"DispatchInternalDIOC: Invalid buffer size in ID_IOCTL_INTERNAL_ReportError");
      }
      goto LABEL_23;
  }
  if ( !((v5 + 2019347441) & 0xFFFFFFFB) )
    return sub_1400051C0(a1, (__int64)v4);
  if ( v5 == -2019347433 )
    return sub_14000CC3C(a1, (__int64)v4);
  v3 = -1073741808;
LABEL_23:
  v4->IoStatus.Status = v3;
  IofCompleteRequest(v4, 0);
  return v3;
}
// 140022B60: using guessed type wchar_t aDispatchintern[75];
// 140022C00: using guessed type wchar_t aGetinterfaceve_0[51];
// 140022C70: using guessed type wchar_t aGetinterfaceve[72];
// 140035180: using guessed type int dword_140035180;

//----- (00000001400073D8) ----------------------------------------------------
void sub_1400073D8()
{
  _QWORD *v0; // rax

  v0 = &unk_1400311C0;
  do
  {
    v0[1] = v0;
    *v0 = v0;
    v0 += 2;
  }
  while ( (signed __int64)v0 < (signed __int64)&unk_1400350D0 );
  stru_140031180.Count = 1;
  stru_140031180.Owner = 0i64;
  stru_140031180.Contention = 0;
  KeInitializeEvent(&stru_140031180.Event, SynchronizationEvent, 0);
  ExInitializeNPagedLookasideList(&Lookaside, 0i64, 0i64, PoolType, 0x20ui64, 0x64744349u, 0);
}

//----- (0000000140007468) ----------------------------------------------------
void sub_140007468()
{
  ExDeleteNPagedLookasideList(&Lookaside);
}

//----- (000000014000747C) ----------------------------------------------------
char __fastcall sub_14000747C(unsigned __int64 a1)
{
  unsigned __int64 v1; // rsi
  char v2; // di
  __int64 **v3; // rbx
  __int64 *v4; // rcx
  bool i; // zf

  v1 = a1;
  v2 = 0;
  v3 = (__int64 **)((char *)&unk_1400311C0
                  + 16
                  * (signed int)(a1
                               - 1009 * ((unsigned __int64)(a1 * (unsigned __int128)0x81E722C258CD00C3ui64 >> 64) >> 9)));
  ExAcquireFastMutex(&stru_140031180);
  v4 = *v3;
  for ( i = *v3 == (__int64 *)v3; !i; i = v4 == (__int64 *)v3 )
  {
    if ( v4[2] == v1 && *((_DWORD *)v4 + 6) == 1 )
    {
      v2 = 1;
      break;
    }
    v4 = (__int64 *)*v4;
  }
  ExReleaseFastMutex(&stru_140031180);
  return v2;
}

//----- (0000000140007518) ----------------------------------------------------
__int64 __fastcall sub_140007518(unsigned __int64 a1)
{
  unsigned __int64 v1; // rsi
  __int64 v2; // rbx
  char *v3; // rdi
  __int64 *v4; // rax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]

  ++Lookaside.L.TotalAllocates;
  v1 = a1;
  v2 = (__int64)ExpInterlockedPopEntrySList(&Lookaside.L.ListHead);
  if ( v2 || (++Lookaside.L.AllocateMisses, (v2 = sub_140021A40((__int64 (*)(void))Lookaside.L.Allocate)) != 0) )
  {
    *(_QWORD *)(v2 + 16) = v1;
    *(_DWORD *)(v2 + 24) = 1;
    v3 = (char *)&unk_1400311C0
       + 16 * (signed int)(v1 - 1009 * ((unsigned __int64)(v1 * (unsigned __int128)0x81E722C258CD00C3ui64 >> 64) >> 9));
    ExAcquireFastMutex(&stru_140031180);
    v4 = (__int64 *)*((_QWORD *)v3 + 1);
    if ( (char *)*v4 != v3 )
      __fastfail(3u);
    *(_QWORD *)v2 = v3;
    *(_QWORD *)(v2 + 8) = v4;
    *v4 = v2;
    *((_QWORD *)v3 + 1) = v2;
    ExReleaseFastMutex(&stru_140031180);
  }
  else
  {
    LODWORD(BugCheckParameter3) = -1073741670;
    sub_140006BB4(0x12Fui64, 0xF3ui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
  }
  return v2;
}

//----- (000000014000762C) ----------------------------------------------------
void __fastcall sub_14000762C(PSLIST_ENTRY ListEntry)
{
  struct _SLIST_ENTRY *v1; // rbx
  PSLIST_ENTRY v2; // rdx
  struct _SLIST_ENTRY **v3; // rax

  if ( ListEntry )
  {
    v1 = ListEntry;
    ExAcquireFastMutex(&stru_140031180);
    v2 = v1->Next;
    if ( *(&v1->Next->Next + 1) != v1 || (v3 = (struct _SLIST_ENTRY **)*((_QWORD *)&v1->Next + 1), *v3 != v1) )
      __fastfail(3u);
    *v3 = v2;
    *((_QWORD *)&v2->Next + 1) = v3;
    ExReleaseFastMutex(&stru_140031180);
    ++Lookaside.L.TotalFrees;
    if ( ExQueryDepthSList(&Lookaside.L.ListHead) < Lookaside.L.Depth )
    {
      ExpInterlockedPushEntrySList(&Lookaside.L.ListHead, v1);
    }
    else
    {
      ++Lookaside.L.FreeMisses;
      sub_140021A40((__int64 (*)(void))Lookaside.L.Free);
    }
  }
}

//----- (00000001400076DC) ----------------------------------------------------
__int64 __fastcall sub_1400076DC(PUNICODE_STRING Destination, __int64 a2, _QWORD *a3)
{
  _QWORD *v3; // rdi
  __int64 v4; // r12
  PUNICODE_STRING v5; // rbx
  int i; // esi
  int v7; // er9
  unsigned __int64 v8; // r8
  __int64 result; // rax
  WCHAR v10; // dx
  __int16 v11; // cx
  ULONG v12; // ecx
  unsigned __int64 v13; // rdx
  USHORT v14; // ax
  ULONGLONG v15; // rcx
  unsigned __int64 v16; // rdx
  ULONG v17; // ecx
  unsigned __int64 v18; // rdx
  UNICODE_STRING *v19; // rdx
  const WCHAR *v20; // rdx
  UNICODE_STRING String; // [rsp+20h] [rbp-98h]
  UNICODE_STRING v22; // [rsp+30h] [rbp-88h]
  UNICODE_STRING v23; // [rsp+40h] [rbp-78h]
  UNICODE_STRING v24; // [rsp+50h] [rbp-68h]
  UNICODE_STRING DestinationString; // [rsp+60h] [rbp-58h]

  v3 = a3;
  v4 = a2;
  v5 = Destination;
  Destination->Length = 0;
  for ( i = 0; ; ++i )
  {
    v7 = i;
    v8 = v5->Length;
    result = (unsigned int)v5->MaximumLength - 1;
    if ( (signed int)v8 >= (signed int)result )
      break;
    result = i;
    v10 = *(_WORD *)(v4 + 2i64 * i);
    if ( !v10 )
      break;
    if ( v10 != 37 )
    {
      v5->Buffer[(unsigned __int64)v5->Length >> 1] = v10;
LABEL_26:
      v5->Length += 2;
      continue;
    }
    v11 = *(_WORD *)(v4 + 2i64 * ++i);
    if ( v11 )
    {
      switch ( v11 )
      {
        case 37:
          v5->Buffer[v8 >> 1] = 37;
          goto LABEL_26;
        case 67:
          *v3 += 8i64;
          v5->Buffer[(unsigned __int64)v5->Length >> 1] = *(_WORD *)(*v3 - 8i64);
          goto LABEL_26;
        case 83:
          *v3 += 8i64;
          v20 = *(const WCHAR **)(*v3 - 8i64);
          if ( !v20 )
            v20 = L"<null>";
          RtlInitUnicodeString(&v24, v20);
          RtlAppendUnicodeStringToString(v5, &v24);
          break;
        case 90:
          *v3 += 8i64;
          v19 = *(UNICODE_STRING **)(*v3 - 8i64);
          if ( !v19 )
          {
            RtlInitUnicodeString(&DestinationString, L"<null>");
            v19 = &DestinationString;
          }
          RtlAppendUnicodeStringToString(v5, v19);
          break;
        default:
          switch ( v11 )
          {
            case 100:
              *v3 += 8i64;
              v17 = *(_DWORD *)(*v3 - 8i64);
              v23.Length = 0;
              v18 = v5->Length;
              v23.MaximumLength = v5->MaximumLength - v18;
              v23.Buffer = &v5->Buffer[v18 >> 1];
              RtlIntegerToUnicodeString(v17, 0xAu, &v23);
              v14 = v23.Length;
              break;
            case 112:
              *v3 += 8i64;
              v15 = *(_QWORD *)(*v3 - 8i64);
              v22.Length = 0;
              v16 = v5->Length;
              v22.MaximumLength = v5->MaximumLength - v16;
              v22.Buffer = &v5->Buffer[v16 >> 1];
              RtlInt64ToUnicodeString(v15, 0x10u, &v22);
              v14 = v22.Length;
              break;
            case 120:
              *v3 += 8i64;
              v12 = *(_DWORD *)(*v3 - 8i64);
              String.Length = 0;
              v13 = v5->Length;
              String.MaximumLength = v5->MaximumLength - v13;
              String.Buffer = &v5->Buffer[v13 >> 1];
              RtlIntegerToUnicodeString(v12, 0x10u, &String);
              v14 = String.Length;
              break;
            default:
              continue;
          }
          v5->Length += v14;
          break;
      }
    }
    else
    {
      i = v7;
    }
  }
  return result;
}

//----- (0000000140007A14) ----------------------------------------------------
char sub_140007A14()
{
  KeInitializeMutex(&stru_140035990, 0);
  return sub_140007AF8();
}

//----- (0000000140007A38) ----------------------------------------------------
LONG sub_140007A38(__int64 a1, ...)
{
  __int64 v1; // rbx
  va_list v3; // [rsp+30h] [rbp-30h]
  UNICODE_STRING **v4; // [rsp+38h] [rbp-28h]
  UNICODE_STRING Destination; // [rsp+40h] [rbp-20h]
  UNICODE_STRING *v6; // [rsp+50h] [rbp-10h]
  __int64 v7; // [rsp+58h] [rbp-8h]
  va_list va; // [rsp+88h] [rbp+28h]

  va_start(va, a1);
  v1 = a1;
  va_copy(v3, va);
  KeWaitForSingleObject(&stru_140035990, UserRequest, 0, 0, 0i64);
  Destination.Buffer = (PWSTR)&unk_140035190;
  Destination.MaximumLength = 2046;
  sub_1400076DC(&Destination, v1, &v3);
  Destination.Buffer[(unsigned __int64)Destination.Length >> 1] = 0;
  v6 = &Destination;
  v7 = 0i64;
  v4 = &v6;
  sub_140019C14(1614610490, 1u, &v4);
  return KeReleaseMutex(&stru_140035990, 0);
}

//----- (0000000140007AF8) ----------------------------------------------------
char sub_140007AF8()
{
  int v0; // ebx
  UNICODE_STRING *v1; // rax
  char result; // al
  int v3; // edx
  int v4; // [rsp+30h] [rbp+8h]

  v0 = dword_140035180;
  v1 = sub_14000589C();
  result = -sub_1400095B8(v1, L"LogFlags", &v4);
  v3 = result != 0 ? v4 : 0;
  dword_140035180 = v3;
  if ( v3 != v0 )
  {
    if ( v3 )
      result = sub_140007A38((__int64)L"Logging enabled Flags:%x");
    else
      result = sub_140007A38((__int64)L"Logging disabled");
  }
  return result;
}
// 140022D00: using guessed type wchar_t aLogflags[9];
// 140022D20: using guessed type wchar_t aLoggingDisable[17];
// 140022D50: using guessed type wchar_t aLoggingEnabled[25];
// 140035180: using guessed type int dword_140035180;

//----- (0000000140007B54) ----------------------------------------------------
char __fastcall sub_140007B54(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  char v3; // bl
  unsigned __int16 v5; // cx
  unsigned int v6; // eax
  unsigned __int64 v7; // rax
  _WORD *v8; // rcx
  signed int v9; // ecx
  __int64 v10; // [rsp+20h] [rbp-28h]
  PVOID Object; // [rsp+60h] [rbp+18h]
  unsigned __int64 v12; // [rsp+68h] [rbp+20h]

  v2 = a1;
  v3 = 0;
  Object = 0i64;
  if ( dword_14002B0FC == -1 || (signed int)PsLookupProcessByProcessId(a2, &Object) < 0 )
    return 0;
  LOBYTE(v10) = 0;
  v5 = *(_WORD *)(v2 + 2);
  if ( (v5 & 0xFFFEu) <= 0x20 )
    v6 = (unsigned int)v5 >> 1;
  else
    v6 = 16;
  if ( (signed int)sub_140006350(*(wchar_t **)(v2 + 8), v6, L"%S", (char *)Object + dword_14002B0FC, v10) >= 0 )
  {
    v12 = 0i64;
    v7 = (unsigned __int64)*(unsigned __int16 *)(v2 + 2) >> 1;
    v8 = *(_WORD **)(v2 + 8);
    if ( v8 )
    {
      while ( v7 && *v8 )
      {
        ++v8;
        --v7;
      }
      v9 = 0;
      if ( !v7 )
        v9 = -1073741811;
      if ( v9 < 0 )
        v12 = 0i64;
      else
        v12 = ((unsigned __int64)*(unsigned __int16 *)(v2 + 2) >> 1) - v7;
    }
    else
    {
      v9 = -1073741811;
    }
    if ( v9 >= 0 )
    {
      *(_WORD *)v2 = 2 * v12;
      v3 = 1;
    }
    else
    {
      v12 = 0i64;
    }
  }
  ObfDereferenceObject(Object);
  return v3;
}
// 140022DC0: using guessed type wchar_t aS[3];
// 140028398: using guessed type __int64 __fastcall PsLookupProcessByProcessId(_QWORD, _QWORD);
// 14002B0FC: using guessed type int dword_14002B0FC;

//----- (0000000140007C84) ----------------------------------------------------
char __fastcall sub_140007C84(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  _WORD *v3; // rax
  __int16 v4; // cx
  unsigned __int64 i; // rdx
  int v6; // er8
  char result; // al

  v2 = a1;
  if ( (signed int)sub_140006350(*(wchar_t **)(a1 + 8), (unsigned __int64)*(unsigned __int16 *)(a1 + 2) >> 1, L"%d", a2) < 0 )
    return 0;
  v3 = *(_WORD **)(v2 + 8);
  v4 = 0;
  if ( v3 )
  {
    for ( i = (unsigned __int64)*(unsigned __int16 *)(v2 + 2) >> 1; i; --i )
    {
      if ( !*v3 )
        break;
      ++v3;
    }
    v6 = i == 0 ? 0xC000000D : 0;
    v4 = i ? (*(_WORD *)(v2 + 2) >> 1) - i : 0;
  }
  else
  {
    v6 = -1073741811;
  }
  if ( v6 < 0 )
    return 0;
  result = 1;
  *(_WORD *)v2 = 2 * v4;
  return result;
}
// 140022DB0: using guessed type wchar_t aD[3];

//----- (0000000140007D18) ----------------------------------------------------
void __fastcall sub_140007D18(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx

  if ( a1 )
  {
    v2 = a2;
    v3 = a1;
    if ( *(_QWORD *)(a1 + 8) )
    {
      if ( *(_WORD *)(a1 + 2) >= 2u && !sub_140007B54(a1, a2) && !sub_140007C84(v3, v2) )
      {
        **(_WORD **)(v3 + 8) = 63;
        *(_WORD *)v3 = 2;
      }
    }
  }
}

//----- (0000000140007D7C) ----------------------------------------------------
void sub_140007D7C()
{
  _QWORD *v0; // rcx
  signed __int64 v1; // r8

  v0 = &unk_140035A40;
  qword_140035A00 = 0i64;
  qword_1400359F8 = (__int64)&unk_140035A40;
  v1 = 99i64;
  do
  {
    *v0 = v0 + 3;
    v0 += 3;
    --v1;
  }
  while ( v1 );
  qword_140036388 = 0i64;
  stru_140035A08.Count = 1;
  stru_140035A08.Owner = 0i64;
  stru_140035A08.Contention = 0;
  KeInitializeEvent(&stru_140035A08.Event, SynchronizationEvent, 0);
  KeInitializeEvent(&stru_1400359D8, SynchronizationEvent, 0);
}
// 1400359F8: using guessed type __int64 qword_1400359F8;
// 140035A00: using guessed type __int64 qword_140035A00;
// 140036388: using guessed type __int64 qword_140036388;

//----- (0000000140007E00) ----------------------------------------------------
NTSTATUS sub_140007E00()
{
  bool v0; // bl
  __int64 v2; // rbx
  struct _DEVICE_OBJECT *v3; // rdi
  struct _SLIST_ENTRY *v4; // rbx
  _QWORD *v5; // rcx

  IoSetThreadHardErrorMode(0i64);
  KeSetPriorityThread((PKTHREAD)__readgsqword(0x188u), 16);
  while ( !byte_1400359F0 )
  {
    sub_140009B44(&stru_1400359D8);
    while ( 1 )
    {
      ExAcquireFastMutex(&stru_140035A08);
      v0 = qword_140035A00 == 0;
      ExReleaseFastMutex(&stru_140035A08);
      if ( v0 || byte_1400359F0 )
        break;
      KeDelayExecutionThread(0, 0, &Interval);
      while ( 1 )
      {
        v2 = MEMORY[0xFFFFF78000000014];
        v3 = 0i64;
        ExAcquireFastMutex(&stru_140035A08);
        if ( qword_140035A00 && v2 >= *(_QWORD *)(qword_140035A00 + 16) )
          v3 = *(struct _DEVICE_OBJECT **)(qword_140035A00 + 8);
        ExReleaseFastMutex(&stru_140035A08);
        if ( !v3 || byte_1400359F0 )
          break;
        v4 = (struct _SLIST_ENTRY *)sub_140007518(__readgsqword(0x188u));
        if ( v4 )
        {
          sub_1400080E4(v3);
          sub_14000762C(v4);
        }
        ExAcquireFastMutex(&stru_140035A08);
        v5 = (_QWORD *)qword_140035A00;
        if ( qword_140035A00 )
        {
          qword_140035A00 = *(_QWORD *)qword_140035A00;
          *v5 = qword_1400359F8;
          qword_1400359F8 = (__int64)v5;
        }
        ExReleaseFastMutex(&stru_140035A08);
      }
    }
  }
  return PsTerminateSystemThread(0);
}
// 1400283D8: using guessed type __int64 __fastcall IoSetThreadHardErrorMode(_QWORD);
// 1400359F0: using guessed type char byte_1400359F0;
// 1400359F8: using guessed type __int64 qword_1400359F8;
// 140035A00: using guessed type __int64 qword_140035A00;

//----- (0000000140007FA0) ----------------------------------------------------
void __fastcall sub_140007FA0(__int64 a1)
{
  __int64 v1; // rdi
  signed __int64 v2; // rbx
  __int64 v3; // rdx
  __int64 *v4; // rcx
  __int64 *v5; // r8
  __int64 v6; // rax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-48h]
  char v8; // [rsp+40h] [rbp-28h]
  char v9; // [rsp+44h] [rbp-24h]

  if ( a1 )
  {
    v1 = a1;
    if ( byte_1400359F1 )
    {
      if ( (unsigned int)dword_140039698 >= 4 )
      {
        sub_14001749C((__int64)&v8);
        if ( !(v9 & 1) )
        {
          v2 = MEMORY[0xFFFFF78000000014] + 10000000i64;
          ExAcquireFastMutex(&stru_140035A08);
          v3 = qword_1400359F8;
          if ( qword_1400359F8 )
          {
            v4 = (__int64 *)qword_140035A00;
            v5 = &qword_140035A00;
            if ( qword_140035A00 )
            {
              do
              {
                if ( v4[1] == v1 )
                  break;
                v5 = v4;
                v4 = (__int64 *)*v4;
              }
              while ( v4 );
            }
            if ( !*v5 )
            {
              v6 = *(_QWORD *)qword_1400359F8;
              *(_QWORD *)qword_1400359F8 = 0i64;
              *(_QWORD *)(v3 + 8) = v1;
              *(_QWORD *)(v3 + 16) = v2;
              *v5 = v3;
              qword_1400359F8 = v6;
              KeSetEvent(&stru_1400359D8, 0, 0);
            }
          }
          else
          {
            LODWORD(BugCheckParameter3) = -1073741670;
            sub_140006BB4(0x136ui64, 0x12Bui64, 0i64, 0xE03D001C, BugCheckParameter3, *(_BYTE *)(v1 + 8) + 56);
          }
          ExReleaseFastMutex(&stru_140035A08);
        }
      }
    }
  }
}
// 1400359F1: using guessed type char byte_1400359F1;
// 1400359F8: using guessed type __int64 qword_1400359F8;
// 140035A00: using guessed type __int64 qword_140035A00;
// 140039698: using guessed type int dword_140039698;

//----- (00000001400080E4) ----------------------------------------------------
__int16 __fastcall sub_1400080E4(struct _DEVICE_OBJECT *a1)
{
  struct _DEVICE_OBJECT *v1; // r14
  char v2; // si
  WCHAR v3; // bx
  NTSTATUS v4; // eax
  PFILE_OBJECT v5; // rcx
  PDEVICE_OBJECT v6; // rcx
  _QWORD *v7; // rax
  char v8; // di
  PDEVICE_OBJECT v9; // rdx
  bool v10; // al
  char v12; // [rsp+20h] [rbp-C8h]
  PFILE_OBJECT FileObject; // [rsp+28h] [rbp-C0h]
  UNICODE_STRING Destination; // [rsp+30h] [rbp-B8h]
  PDEVICE_OBJECT DeviceObject; // [rsp+40h] [rbp-A8h]
  char v16; // [rsp+48h] [rbp-A0h]
  unsigned int v17; // [rsp+50h] [rbp-98h]
  char v18; // [rsp+60h] [rbp-88h]

  Destination.MaximumLength = 198;
  v1 = a1;
  v2 = 0;
  Destination.Buffer = (PWSTR)&v18;
  v3 = 65;
  do
  {
    LOWORD(v4) = v3 - 65;
    if ( (unsigned __int16)(v3 - 65) >= 0x1Au )
      break;
    Destination.Length = 0;
    RtlAppendUnicodeToString(&Destination, L"\\DosDevices\\A:");
    Destination.Buffer[12] = v3;
    v4 = IoGetDeviceObjectPointer(&Destination, 0x80u, &FileObject, &DeviceObject);
    if ( v4 >= 0 && DeviceObject )
    {
      v5 = FileObject;
      if ( FileObject->DeviceObject != v1 )
        goto LABEL_19;
      v2 = 1;
      IoAcquireVpbSpinLock(&v12);
      v6 = FileObject->DeviceObject;
      v7 = v6->DoNotUse1;
      if ( !v7 || (v8 = 1, !v7[1]) )
        v8 = 0;
      LOBYTE(v6) = v12;
      IoReleaseVpbSpinLock(v6);
      v5 = FileObject;
      if ( v8
        || (v9 = FileObject->DeviceObject, !(v9->Characteristics & 1))
        || v9->DeviceType == 2
        || (v10 = sub_140013910(v3), v5 = FileObject, v10) )
      {
LABEL_19:
        LOWORD(v4) = ObfDereferenceObject(v5);
      }
      else
      {
        ObfDereferenceObject(FileObject);
        sub_14001749C((__int64)&v16);
        LOWORD(v4) = sub_1400167F8(v3, v17, 0i64);
      }
    }
    ++v3;
  }
  while ( !v2 );
  return v4;
}
// 1400283E8: using guessed type __int64 __fastcall IoAcquireVpbSpinLock(_QWORD);
// 1400283F0: using guessed type __int64 __fastcall IoReleaseVpbSpinLock(_QWORD);

//----- (0000000140008290) ----------------------------------------------------
signed __int64 sub_140008290()
{
  unsigned int v1; // ebx
  PVOID *Object; // [rsp+20h] [rbp-28h]
  HANDLE Handle; // [rsp+50h] [rbp+8h]
  __int64 v4; // [rsp+58h] [rbp+10h]

  if ( byte_1400359F1 )
    return 0i64;
  byte_1400359F0 = byte_1400359F1;
  if ( PsCreateSystemThread(&Handle, 0x1FFFFFu, 0i64, 0i64, 0i64, (PKSTART_ROUTINE)sub_140007E00, 0i64) < 0 )
    return 3221225626i64;
  v1 = ObReferenceObjectByHandle(Handle, 0, 0i64, 0, &qword_1400359D0, 0i64);
  if ( !v1 )
  {
    ZwClose(Handle);
    byte_1400359F1 = 1;
    return 0i64;
  }
  byte_1400359F0 = 1;
  KeSetEvent(&stru_1400359D8, 0, 0);
  v4 = -600000000i64;
  if ( (unsigned int)ZwWaitForSingleObject(Handle, 0i64, &v4) == 258 )
  {
    LODWORD(Object) = 258;
    sub_140006BB4(0x136ui64, 0xB4ui64, 0i64, 0xE03D000D, (ULONG_PTR)Object, 0);
    ZwWaitForSingleObject(Handle, 0i64, 0i64);
  }
  ZwClose(Handle);
  return v1;
}
// 1400283F8: using guessed type __int64 __fastcall ZwWaitForSingleObject(_QWORD, _QWORD, _QWORD);
// 1400359F0: using guessed type char byte_1400359F0;
// 1400359F1: using guessed type char byte_1400359F1;

//----- (00000001400083D4) ----------------------------------------------------
char sub_1400083D4()
{
  char result; // al
  __int64 v1; // rbx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]
  LARGE_INTEGER Interval; // [rsp+40h] [rbp+8h]

  result = byte_1400359F1;
  if ( byte_1400359F1 )
  {
    byte_1400359F1 = 0;
    byte_1400359F0 = 1;
    KeSetEvent(&stru_1400359D8, 0, 0);
    v1 = 0i64;
    Interval.QuadPart = -200000i64;
    while ( !(unsigned __int8)PsIsThreadTerminating(qword_1400359D0) )
    {
      if ( v1 == -600000000 / Interval.QuadPart )
      {
        LODWORD(BugCheckParameter3) = 258;
        sub_140006BB4(0x136ui64, 0xE4ui64, 0i64, 0xE03D000E, BugCheckParameter3, 0);
      }
      KeDelayExecutionThread(0, 0, &Interval);
      ++v1;
    }
    result = ObfDereferenceObject(qword_1400359D0);
  }
  return result;
}
// 1400283E0: using guessed type __int64 __fastcall PsIsThreadTerminating(_QWORD);
// 1400359F0: using guessed type char byte_1400359F0;
// 1400359F1: using guessed type char byte_1400359F1;

//----- (000000014000849C) ----------------------------------------------------
char sub_14000849C()
{
  char result; // al

  result = byte_1400359F1;
  if ( byte_1400359F1 )
    result = sub_1400083D4();
  return result;
}
// 1400359F1: using guessed type char byte_1400359F1;

//----- (00000001400084B4) ----------------------------------------------------
BOOLEAN sub_1400084B4()
{
  BOOLEAN v0; // bl
  NTSTATUS v1; // edi
  GENERIC_MAPPING *GenericMapping; // rax
  PLARGE_INTEGER Timeout; // [rsp+20h] [rbp-58h]
  struct _SECURITY_SUBJECT_CONTEXT SubjectSecurityContext; // [rsp+50h] [rbp-28h]
  NTSTATUS AccessStatus; // [rsp+80h] [rbp+8h]
  ACCESS_MASK GrantedAccess; // [rsp+88h] [rbp+10h]

  v0 = 0;
  KeWaitForSingleObject(&stru_1400363D8, UserRequest, 0, 0, 0i64);
  if ( dword_140036410 )
  {
    if ( dword_140036410 == 2 )
    {
      KeReleaseMutex(&stru_1400363D8, 0);
      return 0;
    }
  }
  else
  {
    v1 = sub_1400087C0();
    if ( v1 < 0 )
    {
      KeReleaseMutex(&stru_1400363D8, 0);
      LODWORD(Timeout) = v1;
      sub_140006BB4(0x141ui64, 0x16Bui64, 0i64, 0xE03D002B, (ULONG_PTR)Timeout, 0);
      return 0;
    }
    dword_140036410 = 1;
  }
  KeReleaseMutex(&stru_1400363D8, 0);
  if ( dword_140036410 == 1 )
  {
    SeCaptureSubjectContext(&SubjectSecurityContext);
    GenericMapping = (GENERIC_MAPPING *)IoGetFileObjectGenericMapping();
    v0 = SeAccessCheck(
           SecurityDescriptor,
           &SubjectSecurityContext,
           0,
           2u,
           0,
           0i64,
           GenericMapping,
           1,
           &GrantedAccess,
           &AccessStatus);
    SeReleaseSubjectContext(&SubjectSecurityContext);
  }
  return v0;
}
// 140028410: using guessed type __int64 __fastcall SeCaptureSubjectContext(_QWORD);
// 140028418: using guessed type __int64 __fastcall SeReleaseSubjectContext(_QWORD);
// 140028428: using guessed type __int64 IoGetFileObjectGenericMapping(void);
// 140036410: using guessed type int dword_140036410;

//----- (0000000140008610) ----------------------------------------------------
signed __int64 __fastcall sub_140008610(int a1, _QWORD *a2)
{
  int v2; // esi
  _QWORD *v3; // r14
  unsigned int v4; // eax
  PVOID v5; // rax
  __int64 v6; // r8
  void *v7; // rbx
  signed __int64 result; // rax
  unsigned int v9; // edi
  int v10; // [rsp+20h] [rbp-18h]
  __int16 v11; // [rsp+24h] [rbp-14h]

  v10 = 0;
  v2 = a1;
  v11 = 1280;
  v3 = a2;
  v4 = RtlLengthRequiredSid(1i64);
  v5 = ExAllocatePoolWithTag((POOL_TYPE)PoolType, v4, 0x65734349u);
  v7 = v5;
  if ( !v5 )
    return 3221225626i64;
  LOBYTE(v6) = 1;
  v9 = RtlInitializeSid(v5, &v10, v6);
  if ( (v9 & 0x80000000) == 0 )
  {
    *(_DWORD *)RtlSubAuthoritySid(v7, 0i64) = v2;
    result = 0i64;
    *v3 = v7;
  }
  else
  {
    ExFreePoolWithTag(v7, 0);
    result = v9;
  }
  return result;
}
// 140028430: using guessed type __int64 __fastcall RtlLengthRequiredSid(_QWORD);
// 140028438: using guessed type __int64 __fastcall RtlInitializeSid(_QWORD, _QWORD, _QWORD);
// 140028440: using guessed type __int64 __fastcall RtlSubAuthoritySid(_QWORD, _QWORD);

//----- (00000001400086E8) ----------------------------------------------------
signed __int64 __fastcall sub_1400086E8(const WCHAR *a1, __m128i **a2)
{
  __m128i **v2; // rdi
  const WCHAR *v3; // rsi
  UNICODE_STRING *v4; // rax
  __m128i *v6; // rbx
  UNICODE_STRING *v7; // rax
  unsigned int v8; // edi
  SIZE_T NumberOfBytes; // [rsp+40h] [rbp+18h]

  LODWORD(NumberOfBytes) = 0;
  v2 = a2;
  v3 = a1;
  v4 = sub_14000589C();
  sub_140009418(v4, v3, 0i64, (unsigned int *)&NumberOfBytes);
  if ( !(_DWORD)NumberOfBytes )
    return 3221225524i64;
  v6 = (__m128i *)ExAllocatePoolWithTag((POOL_TYPE)PoolType, (unsigned int)NumberOfBytes, 0x65734349u);
  if ( !v6 )
    return 3221225626i64;
  v7 = sub_14000589C();
  if ( !sub_140009418(v7, v3, v6, (unsigned int *)&NumberOfBytes) )
  {
    v8 = -1073741823;
LABEL_9:
    ExFreePoolWithTag(v6, 0x65734349u);
    return v8;
  }
  if ( !(unsigned __int8)RtlValidSid(v6) )
  {
    v8 = -1073741704;
    goto LABEL_9;
  }
  *v2 = v6;
  return 0i64;
}
// 140028278: using guessed type __int64 __fastcall RtlValidSid(_QWORD);

//----- (00000001400087C0) ----------------------------------------------------
NTSTATUS sub_1400087C0()
{
  signed __int64 v0; // rbx
  NTSTATUS result; // eax
  int v2; // eax
  signed int v3; // eax
  signed int v4; // edi
  bool v5; // sf
  signed int v6; // eax
  unsigned int v7; // edi
  char *v8; // rsi
  __int64 v9; // rbp
  int v10; // eax
  ACL *v11; // rax
  ACL *v12; // rsi
  unsigned int v13; // ebp
  char *v14; // r14
  PVOID *v15; // rsi
  char v16[32]; // [rsp+20h] [rbp-48h]

  sub_140021DC0((__m128 *)v16, 0, 0x20ui64);
  v0 = 0i64;
  result = RtlCreateSecurityDescriptor(&unk_1400363A0, 1u);
  if ( result >= 0 )
  {
    LOWORD(v2) = dword_140036414;
    if ( dword_140036414 & 0x808 )
    {
      v3 = sub_1400086E8(L"SAVServiceSid", (__m128i **)v16);
      v4 = v3;
      v5 = v3 < 0;
      v2 = dword_140036414;
      if ( v5 )
      {
        if ( _bittest(&v2, 0xBu) )
          return v4;
      }
      else
      {
        v0 = 1i64;
      }
    }
    if ( v2 & 0x404 )
    {
      v6 = sub_1400086E8(L"SAVOnAccessSid", (__m128i **)&v16[8 * v0]);
      v4 = v6;
      v5 = v6 < 0;
      v2 = dword_140036414;
      if ( v5 )
      {
        if ( _bittest(&v2, 0xAu) )
          goto LABEL_34;
      }
      else
      {
        v0 = (unsigned int)(v0 + 1);
      }
    }
    if ( v2 & 1 )
    {
      v4 = sub_140008610(18, &v16[8 * v0]);
      if ( v4 < 0 )
        goto LABEL_34;
      LOBYTE(v2) = dword_140036414;
      v0 = (unsigned int)(v0 + 1);
    }
    if ( v2 & 2 )
    {
      v4 = sub_140008610(19, &v16[8 * v0]);
      if ( v4 < 0 )
        goto LABEL_34;
      v0 = (unsigned int)(v0 + 1);
    }
    v7 = 8;
    if ( (_DWORD)v0 )
    {
      v8 = v16;
      v9 = (unsigned int)v0;
      do
      {
        v10 = RtlLengthSid(*(_QWORD *)v8);
        v8 += 8;
        v7 += v10 + 12;
        --v9;
      }
      while ( v9 );
    }
    v11 = (ACL *)ExAllocatePoolWithTag((POOL_TYPE)PoolType, v7, 0x65734349u);
    v12 = v11;
    if ( v11 )
    {
      v4 = RtlCreateAcl(v11, v7, 2i64);
      if ( v4 < 0 )
        goto LABEL_40;
      v13 = 0;
      if ( (_DWORD)v0 )
      {
        v14 = v16;
        while ( 1 )
        {
          v4 = RtlAddAccessAllowedAce(v12, 2i64, 2i64, *(_QWORD *)v14);
          if ( v4 < 0 )
            break;
          ++v13;
          v14 += 8;
          if ( v13 >= (unsigned int)v0 )
            goto LABEL_31;
        }
        ExFreePoolWithTag(v12, 0x65734349u);
      }
LABEL_31:
      if ( v4 < 0 )
        goto LABEL_34;
      v4 = RtlSetDaclSecurityDescriptor(&unk_1400363A0, 1u, v12, 0);
      if ( v4 < 0 )
      {
LABEL_40:
        ExFreePoolWithTag(v12, 0x65734349u);
      }
      else
      {
        SecurityDescriptor = &unk_1400363A0;
        P = v12;
      }
    }
    else
    {
      v4 = -1073741670;
    }
LABEL_34:
    if ( (_DWORD)v0 )
    {
      v15 = (PVOID *)v16;
      do
      {
        ExFreePoolWithTag(*v15, 0x65734349u);
        ++v15;
        --v0;
      }
      while ( v0 );
    }
    return v4;
  }
  return result;
}
// 140022DF0: using guessed type wchar_t aSavservicesid[14];
// 140022E10: using guessed type wchar_t aSavonaccesssid[15];
// 140028448: using guessed type __int64 __fastcall RtlLengthSid(_QWORD);
// 140028450: using guessed type __int64 __fastcall RtlCreateAcl(_QWORD, _QWORD, _QWORD);
// 140028458: using guessed type __int64 __fastcall RtlAddAccessAllowedAce(_QWORD, _QWORD, _QWORD, _QWORD);
// 140036414: using guessed type int dword_140036414;
// 1400087C0: using guessed type char var_48[32];

//----- (0000000140008A38) ----------------------------------------------------
void __fastcall sub_140008A38(int a1)
{
  int v1; // ebx

  v1 = a1;
  KeInitializeMutex(&stru_1400363D8, 0);
  dword_140036410 = 0;
  dword_140036414 = v1;
}
// 140036410: using guessed type int dword_140036410;
// 140036414: using guessed type int dword_140036414;

//----- (0000000140008A68) ----------------------------------------------------
char sub_140008A68()
{
  __int64 v0; // rcx
  char v1; // bl
  __int64 v3; // [rsp+20h] [rbp-28h]
  __int64 v4; // [rsp+30h] [rbp-18h]

  SeCaptureSubjectContext(&v3);
  v0 = v4;
  if ( v3 )
    v0 = v3;
  v1 = SeTokenIsAdmin(v0);
  SeReleaseSubjectContext(&v3);
  return v1;
}
// 140028410: using guessed type __int64 __fastcall SeCaptureSubjectContext(_QWORD);
// 140028418: using guessed type __int64 __fastcall SeReleaseSubjectContext(_QWORD);
// 140028460: using guessed type __int64 __fastcall SeTokenIsAdmin(_QWORD);

//----- (0000000140008AB8) ----------------------------------------------------
LONG sub_140008AB8()
{
  KeWaitForSingleObject(&stru_1400363D8, UserRequest, 0, 0, 0i64);
  dword_140036410 = 2;
  if ( P )
  {
    ExFreePoolWithTag(P, 0);
    P = 0i64;
  }
  return KeReleaseMutex(&stru_1400363D8, 0);
}
// 140036410: using guessed type int dword_140036410;

//----- (0000000140008B24) ----------------------------------------------------
bool __fastcall sub_140008B24(__int16 *a1)
{
  unsigned __int16 v1; // ax
  unsigned __int64 v2; // rbx
  bool result; // al

  result = 0;
  if ( qword_140036418 )
  {
    v1 = *a1;
    if ( *(_WORD *)qword_140036418 > (unsigned __int16)*a1 )
    {
      v2 = v1;
      if ( RtlCompareMemory(*((const void **)a1 + 1), *((const void **)qword_140036418 + 1), v1) == v1
        && *(_WORD *)(*((_QWORD *)qword_140036418 + 1) + 2 * (v2 >> 1)) == 92 )
      {
        result = 1;
      }
    }
  }
  return result;
}

//----- (0000000140008B80) ----------------------------------------------------
signed __int64 __fastcall sub_140008B80(void *a1, __int64 a2)
{
  __int64 v2; // rdi
  unsigned int v3; // ebx
  __int64 v5; // [rsp+28h] [rbp-20h]
  PVOID Object; // [rsp+58h] [rbp+10h]

  v2 = a2;
  if ( !a2 )
    return 3221225485i64;
  Object = 0i64;
  v3 = ObReferenceObjectByHandle(a1, 0, (POBJECT_TYPE)IoFileObjectType, 1, &Object, 0i64);
  if ( !v3 )
  {
    LOBYTE(v5) = 1;
    v3 = ObOpenObjectByPointer(Object, 0i64, 0i64, 0x80000000i64, IoFileObjectType, v5, v2);
    ObfDereferenceObject(Object);
  }
  return v3;
}
// 140028300: using guessed type __int64 __fastcall ObOpenObjectByPointer(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140008C24) ----------------------------------------------------
char __fastcall sub_140008C24(__int64 a1, unsigned int a2, __m128i **a3, _DWORD *a4)
{
  SIZE_T v4; // rsi
  _DWORD *v5; // rbx
  __m128i **v6; // rdi
  unsigned __int64 v7; // rbp
  __m128i *v8; // rax

  v4 = a2;
  v5 = a4;
  v6 = a3;
  v7 = a1;
  if ( a3 && a4 )
  {
    *a3 = 0i64;
    *a4 = 0;
  }
  LOBYTE(v8) = sub_140008CCC(a1, a2);
  if ( (_BYTE)v8 && v6 && v5 && v7 && (_DWORD)v4 )
  {
    v8 = (__m128i *)ExAllocatePoolWithTag(PagedPool, v4, 0x45414349u);
    *v6 = v8;
    if ( v8 )
    {
      LOBYTE(v8) = (unsigned __int64)sub_140021A80(v8, v7, v4);
      *v5 = v4;
    }
    else
    {
      *v5 = 0;
    }
  }
  return (char)v8;
}

//----- (0000000140008CCC) ----------------------------------------------------
bool __fastcall sub_140008CCC(__int64 a1, unsigned int a2)
{
  return a2 >= 0x26
      && a1
      && *(_BYTE *)(a1 + 5) == 26
      && *(unsigned __int8 *)(a1 + 5) == RtlCompareMemory(
                                           "Filestream_Transaction_Tag",
                                           (const void *)(a1 + 8),
                                           0x1Aui64);
}

//----- (0000000140008D18) ----------------------------------------------------
bool sub_140008D18()
{
  UNICODE_STRING *v0; // rax
  int v2; // [rsp+30h] [rbp+8h]

  v0 = sub_14000589C();
  return sub_1400095B8(v0, L"FileMetaDataDisabled", &v2) && v2 == 1;
}
// 140022E70: using guessed type wchar_t aFilemetadatadi[21];

//----- (0000000140008D4C) ----------------------------------------------------
_BOOL8 __fastcall sub_140008D4C(const UNICODE_STRING *a1)
{
  return RtlCompareUnicodeString(a1, &String2, 1u) == 0;
}

//----- (0000000140008D74) ----------------------------------------------------
char __fastcall sub_140008D74(PDEVICE_OBJECT DeviceObject, _DWORD *a2)
{
  _DWORD *v2; // rdi
  struct _DEVICE_OBJECT *v3; // rbx
  struct _IRP *v4; // rax
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+50h] [rbp-58h]
  struct _KEVENT Object; // [rsp+60h] [rbp-48h]
  char OutputBuffer; // [rsp+78h] [rbp-30h]

  v2 = a2;
  v3 = DeviceObject;
  IoStatusBlock.Pointer = 0i64;
  IoStatusBlock.Information = 0i64;
  KeInitializeEvent(&Object, SynchronizationEvent, 0);
  v4 = IoBuildDeviceIoControlRequest(0x70000u, v3, 0i64, 0, &OutputBuffer, 0x18u, 0, &Object, &IoStatusBlock);
  if ( v4 )
  {
    LODWORD(v4) = IofCallDriver(v3, v4);
    if ( (_DWORD)v4 == 259 )
    {
      sub_140009B44(&Object);
      LODWORD(v4) = IoStatusBlock.Status;
    }
    *v2 = (_DWORD)v4;
    LOBYTE(v4) = 1;
  }
  return (char)v4;
}

//----- (0000000140008E54) ----------------------------------------------------
char __fastcall sub_140008E54(_QWORD *a1, _QWORD *a2)
{
  bool v2; // zf
  _QWORD *v3; // rsi
  _QWORD *v4; // rdi
  PVOID v5; // rax
  void *v6; // rbx
  __int64 v7; // r8
  int v8; // eax
  PVOID v9; // rax
  void *v10; // rbx
  __int64 v11; // r8
  SIZE_T NumberOfBytes; // [rsp+30h] [rbp+8h]

  v2 = *a1 == 0i64;
  v3 = a2;
  v4 = a1;
  LODWORD(NumberOfBytes) = 1040;
  if ( v2 )
    return 0;
  v5 = ExAllocatePoolWithTag(PagedPool, 0x410ui64, 0x65734344u);
  v6 = v5;
  if ( !v5 )
    return 0;
  v7 = (unsigned int)NumberOfBytes;
  *v3 = v5;
  v8 = ObQueryNameString(*v4, v5, v7, &NumberOfBytes);
  if ( v8 < 0 )
  {
    if ( v8 != -1073741820 && v8 != -2147483643 )
      return 0;
    if ( !(_DWORD)NumberOfBytes )
      return 0;
    ExFreePoolWithTag(v6, 0);
    v9 = ExAllocatePoolWithTag(PagedPool, (unsigned int)NumberOfBytes, 0x65734344u);
    v10 = v9;
    if ( !v9 )
      return 0;
    v11 = (unsigned int)NumberOfBytes;
    *v3 = v9;
    if ( (signed int)ObQueryNameString(*v4, v9, v11, &NumberOfBytes) < 0 )
    {
      ExFreePoolWithTag(v10, 0);
      return 0;
    }
  }
  return 1;
}
// 1400284A8: using guessed type __int64 __fastcall ObQueryNameString(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140008F5C) ----------------------------------------------------
char __fastcall sub_140008F5C(void **a1, PVOID *Object)
{
  void *v2; // rcx
  PVOID *v3; // rbx

  v2 = *a1;
  v3 = Object;
  if ( !v2 )
    return 0;
  if ( ObReferenceObjectByHandle(v2, 0, 0i64, 0, Object, 0i64) < 0 )
  {
    *v3 = 0i64;
    return 0;
  }
  return 1;
}

//----- (0000000140008FA0) ----------------------------------------------------
char __fastcall sub_140008FA0(PDEVICE_OBJECT DeviceObject, _DWORD *a2)
{
  _DWORD *v2; // rdi
  struct _DEVICE_OBJECT *v3; // rbx
  struct _IRP *v4; // rax
  NTSTATUS v5; // eax
  char result; // al
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+50h] [rbp-58h]
  struct _KEVENT Object; // [rsp+60h] [rbp-48h]
  char OutputBuffer; // [rsp+78h] [rbp-30h]
  int v10; // [rsp+8Ch] [rbp-1Ch]

  v2 = a2;
  v3 = DeviceObject;
  IoStatusBlock.Pointer = 0i64;
  IoStatusBlock.Information = 0i64;
  KeInitializeEvent(&Object, SynchronizationEvent, 0);
  v4 = IoBuildDeviceIoControlRequest(0x70000u, v3, 0i64, 0, &OutputBuffer, 0x18u, 0, &Object, &IoStatusBlock);
  if ( !v4 )
    return 0;
  v5 = IofCallDriver(v3, v4);
  if ( v5 == 259 )
  {
    sub_140009B44(&Object);
    v5 = IoStatusBlock.Status;
  }
  if ( v5 || IoStatusBlock.Information != 24 )
    return 0;
  result = 1;
  *v2 = v10;
  return result;
}

//----- (0000000140009094) ----------------------------------------------------
char sub_140009094()
{
  char v0; // bl
  _WORD *v2; // rax
  unsigned __int16 *v3; // rsi
  _WORD *v4; // r14
  __m128i *v5; // rax
  __m128i *v6; // r15
  int v7; // [rsp+60h] [rbp-19h]
  const wchar_t *v8; // [rsp+68h] [rbp-11h]
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+70h] [rbp-9h]
  OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+80h] [rbp+7h]
  HANDLE FileHandle; // [rsp+E0h] [rbp+67h]
  PVOID Object; // [rsp+E8h] [rbp+6Fh]
  PVOID P; // [rsp+F0h] [rbp+77h]

  v0 = 0;
  v7 = 1572886;
  v8 = L"\\SystemRoot";
  P = 0i64;
  FileHandle = 0i64;
  Object = 0i64;
  if ( qword_140036418 )
    return 1;
  ObjectAttributes.Length = 48;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 576;
  ObjectAttributes.ObjectName = (PUNICODE_STRING)&v7;
  _mm_storeu_si128((__m128i *)&ObjectAttributes.SecurityDescriptor, (__m128i)0i64);
  if ( ZwCreateFile(&FileHandle, 0, &ObjectAttributes, &IoStatusBlock, 0i64, 0, 3u, 1u, 1u, 0i64, 0) >= 0 )
  {
    if ( !sub_140008F5C(&FileHandle, &Object) )
    {
LABEL_4:
      ZwClose(FileHandle);
      return 0;
    }
    if ( !sub_140008E54(&Object, &P) )
    {
      ObfDereferenceObject(Object);
      goto LABEL_4;
    }
    ObfDereferenceObject(Object);
    ZwClose(FileHandle);
    v2 = ExAllocatePoolWithTag(PagedPool, 0x10ui64, 0x54554349u);
    v3 = (unsigned __int16 *)P;
    v4 = v2;
    if ( v2 )
    {
      v5 = (__m128i *)ExAllocatePoolWithTag(PagedPool, *(unsigned __int16 *)P, 0x54554349u);
      v6 = v5;
      if ( v5 )
      {
        sub_140021A80(v5, *((_QWORD *)v3 + 1), *v3);
        v0 = 1;
        *v4 = *v3;
        v4[1] = v3[1];
        *((_QWORD *)v4 + 1) = v6;
        qword_140036418 = v4;
      }
      else
      {
        ExFreePoolWithTag(v4, 0);
      }
    }
    ExFreePoolWithTag(v3, 0);
  }
  return v0;
}
// 140022E50: using guessed type wchar_t aSystemroot[12];

//----- (0000000140009260) ----------------------------------------------------
char sub_140009260()
{
  bool v0; // cf
  bool v1; // zf
  int v3; // [rsp+20h] [rbp-138h]
  unsigned int v4; // [rsp+24h] [rbp-134h]
  unsigned int v5; // [rsp+28h] [rbp-130h]

  if ( !byte_140036421 )
  {
    v3 = 276;
    sub_140021DC0((__m128 *)&v4, 0, 0x110ui64);
    if ( !(unsigned int)RtlGetVersion(&v3) )
    {
      v0 = v4 < 6;
      v1 = v4 == 6;
      if ( v4 == 6 )
      {
        if ( v5 >= 2 )
          goto LABEL_7;
        v0 = v4 < 6;
        v1 = v4 == 6;
      }
      if ( v0 || v1 )
      {
LABEL_8:
        byte_140036421 = 1;
        return byte_140036420;
      }
LABEL_7:
      byte_140036420 = 1;
      goto LABEL_8;
    }
  }
  return byte_140036420;
}
// 140028468: using guessed type __int64 __fastcall RtlGetVersion(_QWORD);
// 140036420: using guessed type char byte_140036420;
// 140036421: using guessed type char byte_140036421;

//----- (00000001400092F4) ----------------------------------------------------
char __fastcall sub_1400092F4(unsigned int a1, __m128i *a2, unsigned int a3, _QWORD *a4)
{
  _QWORD *v4; // r14
  unsigned int v5; // esi
  __m128i *v6; // rdi
  unsigned int v7; // er12
  unsigned int v8; // er15
  char v9; // r8
  unsigned int v10; // er13
  unsigned int v12; // esi
  unsigned __int16 *v13; // rdx
  int v14; // ecx
  unsigned __int64 v15; // rbx
  char v16; // [rsp+78h] [rbp+10h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = 0;
  v9 = 0;
  v16 = 0;
  v10 = 0;
  if ( !a2 || a1 > v5 >> 1 )
    return 0;
  v12 = v5 - 2 * a1;
  *a4 += 8i64;
  v13 = *(unsigned __int16 **)(*a4 - 8i64);
  while ( v13 && v10 < v7 )
  {
    ++v10;
    if ( v9 )
    {
      LOWORD(v6->m128i_i64[0]) = 0;
      v6 = (__m128i *)((char *)v6 + 2);
    }
    else
    {
      v14 = *v13;
      v8 += v14;
      if ( v8 > v12 )
      {
        LOWORD(v14) = v12 - v8 + v14;
        v8 = v12;
        v16 = 1;
      }
      if ( (_WORD)v14 )
      {
        v15 = (unsigned __int16)v14;
        sub_140021A80(v6, *((_QWORD *)v13 + 1), (unsigned __int16)v14);
        v6 = (__m128i *)((char *)v6 + 2 * (v15 >> 1));
      }
      LOWORD(v6->m128i_i64[0]) = 0;
      v6 = (__m128i *)((char *)v6 + 2);
      *v4 += 8i64;
      v13 = *(unsigned __int16 **)(*v4 - 8i64);
      v9 = v16;
    }
  }
  return 1;
}

//----- (0000000140009418) ----------------------------------------------------
char __fastcall sub_140009418(UNICODE_STRING *a1, const WCHAR *a2, __m128i *a3, unsigned int *a4)
{
  unsigned int *v4; // rsi
  __m128i *v5; // r14
  const WCHAR *v6; // rbx
  HANDLE v7; // rcx
  _DWORD *v8; // rax
  _DWORD *v9; // rdi
  NTSTATUS v10; // ebx
  unsigned int v11; // ecx
  __int64 v12; // rdx
  HANDLE KeyHandle; // [rsp+30h] [rbp-50h]
  UNICODE_STRING DestinationString; // [rsp+38h] [rbp-48h]
  OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+48h] [rbp-38h]
  ULONG ResultLength; // [rsp+A0h] [rbp+20h]
  ULONG v18; // [rsp+B8h] [rbp+38h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  if ( !a4 )
    return 0;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.ObjectName = a1;
  ObjectAttributes.Length = 48;
  ObjectAttributes.Attributes = 576;
  _mm_storeu_si128((__m128i *)&ObjectAttributes.SecurityDescriptor, (__m128i)0i64);
  if ( ZwOpenKey(&KeyHandle, 0x2000000u, &ObjectAttributes) < 0 )
  {
    *v4 = 0;
    return 0;
  }
  RtlInitUnicodeString(&DestinationString, v6);
  if ( ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, 0i64, 0, &ResultLength) != -1073741789 )
  {
    v7 = KeyHandle;
LABEL_6:
    *v4 = 0;
    ZwClose(v7);
    return 0;
  }
  v8 = ExAllocatePoolWithTag(PagedPool, ResultLength, 0x54554349u);
  v7 = KeyHandle;
  v9 = v8;
  if ( !v8 )
    goto LABEL_6;
  v10 = ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, v8, ResultLength, &v18);
  ZwClose(KeyHandle);
  if ( v10 < 0 || v9[1] != 3 || (v11 = v9[3], v12 = (unsigned int)v9[2], (unsigned int)v12 + v11 > ResultLength) )
  {
    *v4 = 0;
  }
  else
  {
    if ( v11 <= *v4 && v5 )
    {
      sub_140021A80(v5, (unsigned __int64)v9 + v12, v11);
      ExFreePoolWithTag(v9, 0);
      return 1;
    }
    *v4 = v11;
  }
  ExFreePoolWithTag(v9, 0);
  return 0;
}

//----- (00000001400095B8) ----------------------------------------------------
char __fastcall sub_1400095B8(UNICODE_STRING *a1, const WCHAR *a2, _DWORD *a3)
{
  _DWORD *v3; // rsi
  const WCHAR *v4; // rbx
  HANDLE v5; // rcx
  _DWORD *v6; // rax
  _DWORD *v7; // rdi
  NTSTATUS v8; // ebx
  __int64 v9; // r8
  HANDLE KeyHandle; // [rsp+30h] [rbp-50h]
  UNICODE_STRING DestinationString; // [rsp+38h] [rbp-48h]
  OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+48h] [rbp-38h]
  ULONG ResultLength; // [rsp+A0h] [rbp+20h]
  ULONG v15; // [rsp+B8h] [rbp+38h]

  ObjectAttributes.RootDirectory = 0i64;
  v3 = a3;
  v4 = a2;
  ObjectAttributes.ObjectName = a1;
  ObjectAttributes.Length = 48;
  ObjectAttributes.Attributes = 576;
  _mm_storeu_si128((__m128i *)&ObjectAttributes.SecurityDescriptor, (__m128i)0i64);
  if ( ZwOpenKey(&KeyHandle, 0x2000000u, &ObjectAttributes) < 0 )
    return 0;
  RtlInitUnicodeString(&DestinationString, v4);
  if ( ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, 0i64, 0, &ResultLength) != -1073741789 )
  {
    v5 = KeyHandle;
LABEL_4:
    ZwClose(v5);
    return 0;
  }
  v6 = ExAllocatePoolWithTag(PagedPool, ResultLength, 0x54554349u);
  v5 = KeyHandle;
  v7 = v6;
  if ( !v6 )
    goto LABEL_4;
  v8 = ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, v6, ResultLength, &v15);
  ZwClose(KeyHandle);
  if ( v8 >= 0 && v7[1] == 4 && v7[3] == 4 )
  {
    v9 = (unsigned int)v7[2];
    if ( v9 + 4 <= (unsigned __int64)ResultLength )
    {
      *v3 = *(_DWORD *)((char *)v7 + v9);
      ExFreePoolWithTag(v7, 0);
      return 1;
    }
  }
  ExFreePoolWithTag(v7, 0);
  return 0;
}

//----- (000000014000972C) ----------------------------------------------------
char __fastcall sub_14000972C(UNICODE_STRING *a1, const WCHAR *a2, __int64 a3)
{
  __int64 v3; // rsi
  const WCHAR *v4; // rbx
  HANDLE v5; // rcx
  _DWORD *v6; // rax
  _DWORD *v7; // rdi
  NTSTATUS v8; // ebx
  unsigned int v9; // ecx
  __int64 v10; // r9
  HANDLE KeyHandle; // [rsp+30h] [rbp-50h]
  UNICODE_STRING DestinationString; // [rsp+38h] [rbp-48h]
  OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+48h] [rbp-38h]
  ULONG ResultLength; // [rsp+A0h] [rbp+20h]
  ULONG v16; // [rsp+B8h] [rbp+38h]

  ObjectAttributes.RootDirectory = 0i64;
  v3 = a3;
  v4 = a2;
  ObjectAttributes.ObjectName = a1;
  ObjectAttributes.Length = 48;
  ObjectAttributes.Attributes = 576;
  _mm_storeu_si128((__m128i *)&ObjectAttributes.SecurityDescriptor, (__m128i)0i64);
  if ( ZwOpenKey(&KeyHandle, 0x2000000u, &ObjectAttributes) < 0 )
    return 0;
  RtlInitUnicodeString(&DestinationString, v4);
  if ( ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, 0i64, 0, &ResultLength) != -1073741789 )
  {
    v5 = KeyHandle;
LABEL_4:
    ZwClose(v5);
    return 0;
  }
  v6 = ExAllocatePoolWithTag(PagedPool, ResultLength, 0x54554349u);
  v5 = KeyHandle;
  v7 = v6;
  if ( !v6 )
    goto LABEL_4;
  v8 = ZwQueryValueKey(KeyHandle, &DestinationString, KeyValueFullInformation, v6, ResultLength, &v16);
  ZwClose(KeyHandle);
  if ( v8 >= 0 && v7[1] == 1 )
  {
    v9 = v7[3];
    if ( v9 >= 2 && v9 - 2 <= *(unsigned __int16 *)(v3 + 2) )
    {
      v10 = (unsigned int)v7[2];
      if ( (unsigned int)v10 + v9 <= ResultLength )
      {
        sub_140021A80(*(__m128i **)(v3 + 8), (unsigned __int64)v7 + v10, v9 - 2);
        *(_WORD *)v3 = *((_WORD *)v7 + 6) - 2;
        ExFreePoolWithTag(v7, 0);
        return 1;
      }
    }
  }
  ExFreePoolWithTag(v7, 0);
  return 0;
}

//----- (00000001400098C0) ----------------------------------------------------
__int64 __fastcall sub_1400098C0(__int64 a1)
{
  return *(_QWORD *)(a1 - 48);
}

//----- (0000000140009904) ----------------------------------------------------
__int64 __fastcall sub_140009904(__int64 *a1, _BYTE *a2)
{
  _BYTE *v2; // r10
  unsigned int v3; // er9
  char v4; // r8
  __int64 v5; // rdx
  unsigned __int16 *i; // rax

  v2 = a2;
  v3 = 0;
  v4 = 0;
  *a1 += 8i64;
  v5 = *a1;
  for ( i = *(unsigned __int16 **)(*a1 - 8); i; i = *(unsigned __int16 **)(v5 - 8) )
  {
    ++v4;
    v3 += *i + 2;
    v5 += 8i64;
    *a1 = v5;
  }
  *v2 = v4;
  return v3;
}

//----- (0000000140009970) ----------------------------------------------------
void sub_140009970()
{
  PVOID v0; // rcx

  v0 = qword_140036418;
  if ( qword_140036418 )
  {
    if ( *((_QWORD *)qword_140036418 + 1) )
    {
      ExFreePoolWithTag(*((PVOID *)qword_140036418 + 1), 0);
      v0 = qword_140036418;
      *((_QWORD *)qword_140036418 + 1) = 0i64;
    }
    ExFreePoolWithTag(v0, 0);
    qword_140036418 = 0i64;
  }
}

//----- (00000001400099C4) ----------------------------------------------------
__int64 __fastcall sub_1400099C4(ULONG Count, PVOID Object[], LARGE_INTEGER *a3)
{
  PVOID *v3; // rbp
  ULONG v4; // er14
  __int64 v5; // rbx
  unsigned int v6; // edi
  LARGE_INTEGER Timeout; // [rsp+70h] [rbp+18h]

  v3 = Object;
  v4 = Count;
  if ( a3 )
  {
    Timeout = *a3;
    v5 = MEMORY[0xFFFFF78000000014];
    v6 = KeWaitForMultipleObjects(Count, Object, WaitAny, 0, 0, 1u, &Timeout, 0i64);
    if ( v6 == 257 )
    {
      while ( !(unsigned __int8)PsIsThreadTerminating(__readgsqword(0x188u)) )
      {
        Timeout.QuadPart += MEMORY[0xFFFFF78000000014] - v5;
        if ( Timeout.QuadPart > 0 )
        {
          v6 = 258;
          break;
        }
        v5 = MEMORY[0xFFFFF78000000014];
        v6 = KeWaitForMultipleObjects(v4, v3, WaitAny, 0, 0, 1u, &Timeout, 0i64);
        if ( v6 != 257 )
          break;
      }
LABEL_10:
      if ( v6 == 257 && (unsigned __int8)PsIsThreadTerminating(__readgsqword(0x188u)) )
        v6 = -1073741749;
    }
  }
  else
  {
    while ( 1 )
    {
      v6 = KeWaitForMultipleObjects(v4, v3, WaitAny, 0, 0, 1u, 0i64, 0i64);
      if ( v6 != 257 )
        break;
      if ( (unsigned __int8)PsIsThreadTerminating(__readgsqword(0x188u)) )
        goto LABEL_10;
    }
  }
  return v6;
}
// 1400283E0: using guessed type __int64 __fastcall PsIsThreadTerminating(_QWORD);

//----- (0000000140009B44) ----------------------------------------------------
NTSTATUS __fastcall sub_140009B44(PVOID Object)
{
  PVOID v1; // rbx
  NTSTATUS result; // eax

  v1 = Object;
  do
    result = KeWaitForSingleObject(v1, 0, 0, 0, 0i64);
  while ( result );
  return result;
}

//----- (0000000140009B74) ----------------------------------------------------
bool __fastcall sub_140009B74(UNICODE_STRING *a1, const WCHAR *a2, int a3)
{
  const WCHAR *v3; // rbx
  NTSTATUS v5; // ebx
  UNICODE_STRING DestinationString; // [rsp+30h] [rbp-40h]
  OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+40h] [rbp-30h]
  HANDLE KeyHandle; // [rsp+80h] [rbp+10h]
  int Data; // [rsp+90h] [rbp+20h]

  Data = a3;
  ObjectAttributes.RootDirectory = 0i64;
  v3 = a2;
  ObjectAttributes.ObjectName = a1;
  ObjectAttributes.Length = 48;
  ObjectAttributes.Attributes = 576;
  _mm_storeu_si128((__m128i *)&ObjectAttributes.SecurityDescriptor, (__m128i)0i64);
  if ( ZwOpenKey(&KeyHandle, 0x2000000u, &ObjectAttributes) < 0 )
    return 0;
  RtlInitUnicodeString(&DestinationString, v3);
  v5 = ZwSetValueKey(KeyHandle, &DestinationString, 0, 4u, &Data, 4u);
  ZwClose(KeyHandle);
  return v5 >= 0;
}

//----- (0000000140009C2C) ----------------------------------------------------
__int64 sub_140009C2C()
{
  __int64 result; // rax

  ++dword_1400364D4;
  result = (__int64)ExpInterlockedPopEntrySList(&stru_1400364C0);
  if ( !result )
  {
    ++dword_1400364D8;
    result = sub_140021A40((__int64 (*)(void))qword_1400364F0);
  }
  return result;
}
// 1400364D4: using guessed type int dword_1400364D4;
// 1400364D8: using guessed type int dword_1400364D8;
// 1400364F0: using guessed type __int64 qword_1400364F0;

//----- (0000000140009C7C) ----------------------------------------------------
void __fastcall sub_140009C7C(PSLIST_ENTRY ListEntry)
{
  struct _SLIST_ENTRY *v1; // rbx

  if ( ListEntry )
  {
    ++dword_1400364DC;
    v1 = ListEntry;
    if ( ExQueryDepthSList(&stru_1400364C0) < (unsigned __int16)word_1400364D0 )
    {
      ExpInterlockedPushEntrySList(&stru_1400364C0, v1);
    }
    else
    {
      ++dword_1400364E0;
      sub_140021A40((__int64 (*)(void))qword_1400364F8);
    }
  }
}
// 1400364D0: using guessed type __int16 word_1400364D0;
// 1400364DC: using guessed type int dword_1400364DC;
// 1400364E0: using guessed type int dword_1400364E0;
// 1400364F8: using guessed type __int64 qword_1400364F8;

//----- (0000000140009CE0) ----------------------------------------------------
LONG __fastcall sub_140009CE0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  char v5; // [rsp+20h] [rbp-28h]

  v2 = a2;
  v3 = a1;
  KeAcquireInStackQueuedSpinLock(a1 + 16, &v5);
  if ( *(_QWORD *)v3 )
    *(_QWORD *)(*(_QWORD *)(v3 + 8) + 16i64) = v2;
  else
    *(_QWORD *)v3 = v2;
  *(_QWORD *)(v3 + 8) = v2;
  KeReleaseInStackQueuedSpinLock(&v5);
  return KeReleaseSemaphore((PRKSEMAPHORE)(v3 + 24), 1, 1, 0);
}
// 140028330: using guessed type __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD, _QWORD);
// 140028338: using guessed type __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD);

//----- (0000000140009D54) ----------------------------------------------------
char __fastcall sub_140009D54(__int64 a1, unsigned int a2)
{
  unsigned int v2; // edi
  __int64 v3; // rbx
  UNICODE_STRING *v4; // rax
  __int64 v5; // rsi
  signed __int64 v6; // rax
  unsigned __int8 v7; // cf
  SIZE_T v8; // rax
  char *v9; // rax
  signed __int64 v10; // rdi
  __int64 v11; // rdi
  __int64 v13; // rax
  void *v14; // r14
  __int64 v15; // rdi
  HANDLE *i; // rsi
  unsigned int v17; // [rsp+38h] [rbp+10h]

  *(_QWORD *)a1 = 0i64;
  v2 = a2;
  *(_QWORD *)(a1 + 16) = 0i64;
  v3 = a1;
  KeInitializeSemaphore((PRKSEMAPHORE)(a1 + 24), 0, 0x7FFFFFFF);
  *(_QWORD *)(v3 + 56) = 0i64;
  *(_DWORD *)(v3 + 64) = 0;
  if ( v2 )
    goto LABEL_5;
  v4 = sub_14000589C();
  if ( !sub_1400095B8(v4, L"NumberOfWorkerThreads", &v17) || (v2 = v17) == 0 )
  {
    v2 = 3;
LABEL_5:
    v17 = v2;
  }
  v5 = v2;
  v6 = 8i64 * v2;
  if ( !is_mul_ok(v2, 8ui64) )
    v6 = -1i64;
  v7 = __CFADD__(v6, 8i64);
  v8 = v6 + 8;
  if ( v7 )
    v8 = -1i64;
  v9 = (char *)sub_14000E268(v8);
  if ( v9 )
  {
    *(_QWORD *)v9 = v2;
    v10 = (signed __int64)(v9 + 8);
    if ( v5 )
      sub_140021DC0((__m128 *)(v9 + 8), 0, 8 * v5);
  }
  else
  {
    v10 = 0i64;
  }
  *(_QWORD *)(v3 + 56) = v10;
  if ( v10 )
  {
    v11 = 0i64;
    if ( v17 )
    {
      do
      {
        if ( sub_14000E284(
               (HANDLE *)(*(_QWORD *)(v3 + 56) + 8 * v11),
               (void (__stdcall *)(PVOID))sub_14000A010,
               (void *)v3) )
        {
          ++*(_DWORD *)(v3 + 64);
        }
        v11 = (unsigned int)(v11 + 1);
      }
      while ( (unsigned int)v11 < v17 );
    }
    if ( *(_DWORD *)(v3 + 64) )
      return 1;
    v13 = *(_QWORD *)(v3 + 56);
    if ( v13 )
    {
      v14 = (void *)(v13 - 8);
      v15 = *(_QWORD *)(v13 - 8);
      for ( i = (HANDLE *)(v13 + 8 * v15); v15; --v15 )
      {
        --i;
        sub_14000E1E8(i);
      }
      sub_14000AB20(v14);
    }
    *(_QWORD *)(v3 + 56) = 0i64;
  }
  return 0;
}
// 14000A010: using guessed type __int64 __fastcall sub_14000A010();
// 140022EA0: using guessed type wchar_t aNumberofworker[22];

//----- (0000000140009EA8) ----------------------------------------------------
NTSTATUS __fastcall sub_140009EA8(__int64 *a1)
{
  __int64 *v1; // rdi
  __int64 v2; // rbx
  __int64 v3; // rax
  __int64 v4; // rcx
  char v6; // [rsp+30h] [rbp-28h]

  v1 = a1;
  IoSetThreadHardErrorMode(0i64);
  KeSetPriorityThread((PKTHREAD)__readgsqword(0x188u), 16);
  while ( 1 )
  {
    KeWaitForSingleObject(v1 + 3, 0, 0, 0, 0i64);
    KeAcquireInStackQueuedSpinLock(v1 + 2, &v6);
    if ( !*v1 )
      break;
    v2 = *v1;
    v3 = *(_QWORD *)(*v1 + 16);
    *(_QWORD *)(*v1 + 16) = 0i64;
    *v1 = v3;
    KeReleaseInStackQueuedSpinLock(&v6);
    v4 = *(_QWORD *)(v2 + 8);
    sub_140021A40(*(__int64 (**)(void))v2);
    sub_140009C7C((PSLIST_ENTRY)v2);
  }
  KeReleaseInStackQueuedSpinLock(&v6);
  return PsTerminateSystemThread(0);
}
// 140028330: using guessed type __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD, _QWORD);
// 140028338: using guessed type __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD);
// 1400283D8: using guessed type __int64 __fastcall IoSetThreadHardErrorMode(_QWORD);

//----- (0000000140009F88) ----------------------------------------------------
void __fastcall sub_140009F88(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  void *v3; // r14
  __int64 v4; // rdi
  HANDLE *i; // rsi

  v1 = a1;
  if ( *(_QWORD *)(a1 + 56) )
  {
    KeReleaseSemaphore((PRKSEMAPHORE)(a1 + 24), 1, *(_DWORD *)(a1 + 64), 0);
    v2 = *(_QWORD *)(v1 + 56);
    if ( v2 )
    {
      v3 = (void *)(v2 - 8);
      v4 = *(_QWORD *)(v2 - 8);
      for ( i = (HANDLE *)(v2 + 8 * v4); v4; --v4 )
      {
        --i;
        sub_14000E1E8(i);
      }
      sub_14000AB20(v3);
    }
    *(_QWORD *)(v1 + 56) = 0i64;
  }
}

//----- (000000014000A018) ----------------------------------------------------
char __fastcall sub_14000A018(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  _QWORD *v4; // rax

  v2 = a1;
  v3 = a2;
  v4 = (_QWORD *)sub_140009C2C();
  if ( v4 )
  {
    v4[2] = 0i64;
    *v4 = v2;
    v4[1] = v3;
  }
  if ( v4 )
  {
    sub_140009CE0((__int64)&unk_140036460, (__int64)v4);
    LOBYTE(v4) = 1;
  }
  return (char)v4;
}

//----- (000000014000A064) ----------------------------------------------------
char sub_14000A064()
{
  return sub_14000A06C(0);
}

//----- (000000014000A06C) ----------------------------------------------------
char __fastcall sub_14000A06C(unsigned int a1)
{
  unsigned int v1; // ebx

  v1 = a1;
  KeInitializeEvent(&stru_140036440, 0, 0);
  if ( !sub_140009D54((__int64)&unk_140036460, v1) )
    return 0;
  ExInitializeNPagedLookasideList(
    (PNPAGED_LOOKASIDE_LIST)&stru_1400364C0,
    0i64,
    0i64,
    PoolType,
    0x18ui64,
    0x69714349u,
    0);
  return 1;
}

//----- (000000014000A0E4) ----------------------------------------------------
void sub_14000A0E4()
{
  KeSetEvent(&stru_140036440, 0, 0);
  sub_140009F88((__int64)&unk_140036460);
  ExDeleteNPagedLookasideList((PNPAGED_LOOKASIDE_LIST)&stru_1400364C0);
}

//----- (000000014000A124) ----------------------------------------------------
__int64 sub_14000A124()
{
  __int64 result; // rax

  while ( 1 )
  {
    result = (unsigned int)dword_140036940;
    if ( !dword_140036940 )
      break;
    dword_140036940 = result - 1;
    sub_140021A40((__int64 (*)(void))qword_140036540[(signed int)result - 1]);
  }
  return result;
}
// 140036940: using guessed type int dword_140036940;

//----- (000000014000A154) ----------------------------------------------------
__int64 (*sub_14000A154())(void)
{
  __int64 (**v0)(void); // rbx
  unsigned __int64 v1; // rsi
  __int64 (*result)(void); // rax
  unsigned __int64 v3; // rdi

  v0 = (__int64 (**)(void))&unk_140028690;
  v1 = 0i64;
  result = (__int64 (*)(void))&unk_1400287F8;
  v3 = (unsigned __int64)(&unk_1400287FF - &unk_140028690) >> 3;
  if ( &unk_140028690 > &unk_1400287F8 )
    v3 = 0i64;
  if ( v3 )
  {
    do
    {
      result = *v0;
      if ( *v0 )
        result = (__int64 (*)(void))sub_140021A40(result);
      ++v0;
      ++v1;
    }
    while ( v1 < v3 );
  }
  return result;
}

//----- (000000014000A1C4) ----------------------------------------------------
__int64 __fastcall sub_14000A1C4(__int64 a1)
{
  __int64 v1; // rdx

  if ( a1 )
  {
    v1 = dword_140036940;
    qword_140036540[v1] = a1;
    dword_140036940 = v1 + 1;
  }
  return 0i64;
}
// 140036940: using guessed type int dword_140036940;

//----- (000000014000A1E8) ----------------------------------------------------
signed __int64 __fastcall sub_14000A1E8(__int64 a1, __m128i *a2, __int64 a3)
{
  signed __int64 result; // rax
  __int64 v4; // rbx
  __int64 v5; // [rsp+40h] [rbp+8h]
  __int64 v6; // [rsp+58h] [rbp+20h]

  result = a3;
  v4 = a1;
  if ( !*(_QWORD *)(a1 + 8) )
  {
    v5 = 0i64;
    v6 = 0i64;
    result = sub_140005A14(a2, a3, a1, &v6, &v5);
    if ( (signed int)result >= 0 )
    {
      if ( v5 )
        *(_QWORD *)(v5 + 8) = 0i64;
      result = v6;
      *(_QWORD *)(v4 + 8) = v6;
    }
  }
  return result;
}

//----- (000000014000A248) ----------------------------------------------------
void __fastcall sub_14000A248(void **a1)
{
  void ***v1; // rbx
  void **i; // rdi
  void **v3; // rax

  v1 = (void ***)*a1;
  for ( i = a1; *i != i; v1 = (void ***)*i )
  {
    if ( v1[1] != i || (v3 = *v1, (*v1)[1] != v1) )
      __fastfail(3u);
    *i = v3;
    v3[1] = i;
    sub_14000DF38(v1[2]);
    sub_14000AB20(v1);
  }
}

//----- (000000014000A2A4) ----------------------------------------------------
char __fastcall sub_14000A2A4(_QWORD *a1, WCHAR *a2)
{
  _QWORD *v2; // rbx
  WCHAR *v3; // rsi
  _QWORD *v4; // rdi

  v2 = (_QWORD *)*a1;
  v3 = a2;
  v4 = a1;
  if ( (_QWORD *)*a1 == a1 )
    return 0;
  while ( !sub_14000D9D0((PCUNICODE_STRING)v2[2], v3) )
  {
    v2 = (_QWORD *)*v2;
    if ( v2 == v4 )
      return 0;
  }
  return 1;
}

//----- (000000014000A2F0) ----------------------------------------------------
__int64 __fastcall sub_14000A2F0(_WORD *a1, volatile signed __int32 **a2)
{
  volatile signed __int32 **v2; // r14
  _WORD *v3; // rsi
  volatile signed __int32 *v4; // rax
  volatile signed __int32 *v5; // rbx
  signed int v6; // edi
  volatile signed __int32 *v8; // rax
  volatile signed __int32 **v9; // rcx
  signed __int64 v10; // rax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]
  _QWORD *v12; // [rsp+60h] [rbp+18h]

  v2 = a2;
  v3 = a1;
  v4 = (volatile signed __int32 *)sub_14000AB04(0x18ui64, PagedPool);
  v5 = v4;
  if ( v4 )
  {
    *((_QWORD *)v4 + 1) = v4;
    *(_QWORD *)v4 = v4;
    *((_DWORD *)v4 + 4) = 0;
  }
  else
  {
    v5 = 0i64;
  }
  if ( v5 )
  {
    while ( 1 )
    {
      if ( !*v3 )
      {
        _InterlockedIncrement(v5 + 4);
        *v2 = v5;
        return 0i64;
      }
      v6 = sub_14000DB1C(v3, &v12);
      if ( v6 < 0 )
        break;
      v8 = (volatile signed __int32 *)sub_14000AB04(0x18ui64, PagedPool);
      if ( !v8 )
      {
        v6 = -1073741670;
        LODWORD(BugCheckParameter3) = -1073741670;
        sub_140006BB4(0x25Eui64, 0x57ui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
        sub_14000DF38(v12);
        break;
      }
      *((_QWORD *)v8 + 2) = v12;
      v9 = (volatile signed __int32 **)*((_QWORD *)v5 + 1);
      if ( *v9 != v5 )
        __fastfail(3u);
      *(_QWORD *)v8 = v5;
      *((_QWORD *)v8 + 1) = v9;
      *v9 = v8;
      *((_QWORD *)v5 + 1) = v8;
      v10 = -1i64;
      do
        ++v10;
      while ( v3[v10] );
      v3 += v10 + 1;
    }
    sub_14000A248((void **)v5);
    sub_14000AB20((void *)v5);
  }
  else
  {
    v6 = -1073741670;
    LODWORD(BugCheckParameter3) = -1073741670;
    sub_140006BB4(0x25Eui64, 0x3Fui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
  }
  return (unsigned int)v6;
}

//----- (000000014000A43C) ----------------------------------------------------
void __fastcall sub_14000A43C(HANDLE *a1)
{
  HANDLE *v1; // rbx

  v1 = a1;
  ObfDereferenceObject(a1[3]);
  ZwClose(v1[4]);
  ExFreePoolWithTag(v1, 0x686F4349u);
}

//----- (000000014000A480) ----------------------------------------------------
char __fastcall sub_14000A480(__int64 a1)
{
  __int64 v1; // rdi
  __int64 *i; // rbx
  char result; // al
  __int64 v4; // rax
  __int64 *v5; // rcx

  v1 = a1;
  ExAcquireFastMutex(&stru_140036958);
  for ( i = (__int64 *)qword_140036948; i != &qword_140036948; i = (__int64 *)*i )
  {
    if ( i[2] == v1 )
      goto LABEL_6;
  }
  i = 0i64;
LABEL_6:
  if ( i )
  {
    v4 = *i;
    if ( *(__int64 **)(*i + 8) != i || (v5 = (__int64 *)i[1], (__int64 *)*v5 != i) )
      __fastfail(3u);
    *v5 = v4;
    *(_QWORD *)(v4 + 8) = v5;
    ExReleaseFastMutex(&stru_140036958);
    sub_14000A43C((HANDLE *)i);
    result = 1;
  }
  else
  {
    ExReleaseFastMutex(&stru_140036958);
    result = 0;
  }
  return result;
}
// 140036948: using guessed type __int64 qword_140036948;

//----- (000000014000A524) ----------------------------------------------------
bool __fastcall sub_14000A524(__int64 a1, _DWORD *a2)
{
  __int64 v2; // rsi
  _DWORD *v3; // rdi
  __int64 i; // rbx

  v2 = a1;
  v3 = a2;
  ExAcquireFastMutex(&stru_140036958);
  for ( i = qword_140036948; (__int64 *)i != &qword_140036948; i = *(_QWORD *)i )
  {
    if ( *(_QWORD *)(i + 16) == v2 )
      goto LABEL_6;
  }
  i = 0i64;
LABEL_6:
  if ( i && v3 )
    *v3 = *(_DWORD *)(i + 40);
  ExReleaseFastMutex(&stru_140036958);
  return i != 0;
}
// 140036948: using guessed type __int64 qword_140036948;

//----- (000000014000A5A4) ----------------------------------------------------
void sub_14000A5A4()
{
  stru_140036958.Owner = 0i64;
  stru_140036958.Contention = 0;
  qword_140036950 = (__int64)&qword_140036948;
  qword_140036948 = (__int64)&qword_140036948;
  stru_140036958.Count = 1;
  KeInitializeEvent(&stru_140036958.Event, SynchronizationEvent, 0);
}
// 140036948: using guessed type __int64 qword_140036948;
// 140036950: using guessed type __int64 qword_140036950;

//----- (000000014000A5EC) ----------------------------------------------------
signed __int64 __fastcall sub_14000A5EC(__int64 a1, UNICODE_STRING *a2, _QWORD *a3)
{
  _QWORD *v3; // rsi
  UNICODE_STRING *v4; // rdi
  __int64 v5; // r15
  NTSTATUS v6; // eax
  unsigned int v7; // ebx
  NTSTATUS v9; // eax
  __int64 v10; // r8
  const wchar_t *v11; // rcx
  NTSTATUS v12; // eax
  PVOID v13; // rbx
  HANDLE v14; // r12
  _QWORD *v15; // rax
  _QWORD *v16; // r14
  __int64 v17; // rbx
  __int64 v18; // rax
  __int64 *v19; // rcx
  _QWORD *v20; // rax
  ULONG_PTR FileInformationClass; // [rsp+20h] [rbp-99h]
  HANDLE FileHandle; // [rsp+60h] [rbp-59h]
  PVOID Object; // [rsp+68h] [rbp-51h]
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+70h] [rbp-49h]
  OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+80h] [rbp-39h]
  __int64 FileInformation; // [rsp+B0h] [rbp-9h]
  __int64 v27; // [rsp+B8h] [rbp-1h]
  __int64 v28; // [rsp+C0h] [rbp+7h]
  __int64 v29; // [rsp+D8h] [rbp+1Fh]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !a1 || !a2 )
    return 3221225485i64;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.ObjectName = a2;
  ObjectAttributes.Length = 48;
  ObjectAttributes.Attributes = 576;
  _mm_storeu_si128((__m128i *)&ObjectAttributes.SecurityDescriptor, (__m128i)0i64);
  v6 = ZwCreateFile(&FileHandle, 0, &ObjectAttributes, &IoStatusBlock, 0i64, 0x80u, 7u, 1u, 0x40u, 0i64, 0);
  v7 = v6;
  if ( v6 < 0 )
  {
    if ( dword_140035180 & 1 )
      sub_140007A38((__int64)L"Failed to open file %Z, status: %x", v4, (unsigned int)v6);
    return v7;
  }
  v9 = ZwQueryInformationFile(FileHandle, &IoStatusBlock, &FileInformation, 0x38u, (FILE_INFORMATION_CLASS)34);
  v7 = v9;
  if ( v9 < 0 )
  {
    if ( !(dword_140035180 & 1) )
    {
LABEL_11:
      ZwClose(FileHandle);
      return v7;
    }
    v10 = (unsigned int)v9;
    v11 = L"Failed to query network open information for file %Z, status: %x";
LABEL_10:
    sub_140007A38((__int64)v11, v4, v10);
    goto LABEL_11;
  }
  v12 = ObReferenceObjectByHandle(FileHandle, 0, (POBJECT_TYPE)IoFileObjectType, 0, &Object, 0i64);
  v7 = v12;
  if ( v12 < 0 )
  {
    if ( !(dword_140035180 & 1) )
      goto LABEL_11;
    v10 = (unsigned int)v12;
    v11 = L"Failed to reference file %Z, status: %x";
    goto LABEL_10;
  }
  v13 = Object;
  if ( !*(_QWORD *)(*((_QWORD *)Object + 1) + 56i64) )
  {
    if ( dword_140035180 & 1 )
    {
      sub_140007A38((__int64)L"File %Z is remote", v4);
      v13 = Object;
    }
    ObfDereferenceObject(v13);
    v7 = -1073741811;
    goto LABEL_11;
  }
  v14 = FileHandle;
  v15 = ExAllocatePoolWithTag(PagedPool, 0x30ui64, 0x686F4349u);
  v16 = v15;
  if ( !v15 )
  {
    v7 = -1073741670;
    LODWORD(FileInformationClass) = -1073741670;
    sub_140006BB4(0x278ui64, 0x52ui64, 0i64, 0xE03D000B, FileInformationClass, 0);
    ObfDereferenceObject(Object);
    goto LABEL_11;
  }
  *((_DWORD *)v15 + 10) = 0;
  v15[2] = v5;
  v15[3] = v13;
  v15[4] = v14;
  ExAcquireFastMutex(&stru_140036958);
  v17 = qword_140036948;
  if ( (__int64 *)qword_140036948 == &qword_140036948 )
  {
LABEL_24:
    v17 = 0i64;
  }
  else
  {
    while ( *(PVOID *)(v17 + 16) != Object )
    {
      v17 = *(_QWORD *)v17;
      if ( (__int64 *)v17 == &qword_140036948 )
        goto LABEL_24;
    }
  }
  if ( v17 )
  {
    if ( dword_140035180 & 1 )
      sub_140007A38((__int64)L"Collision in the open handle records, file: %Z", v4);
    v18 = *(_QWORD *)v17;
    if ( *(_QWORD *)(*(_QWORD *)v17 + 8i64) != v17 || (v19 = *(__int64 **)(v17 + 8), *v19 != v17) )
LABEL_32:
      __fastfail(3u);
    *v19 = v18;
    *(_QWORD *)(v18 + 8) = v19;
  }
  v20 = (_QWORD *)qword_140036950;
  if ( *(__int64 **)qword_140036950 != &qword_140036948 )
    goto LABEL_32;
  *v16 = &qword_140036948;
  v16[1] = v20;
  *v20 = v16;
  qword_140036950 = (__int64)v16;
  ExReleaseFastMutex(&stru_140036958);
  if ( v17 )
    sub_14000A43C((HANDLE *)v17);
  if ( v3 )
  {
    *v3 = v29;
    v3[1] = FileInformation;
    v3[2] = v27;
    v3[3] = v28;
  }
  return 0i64;
}
// 140022ED0: using guessed type wchar_t aFailedToOpenFi[35];
// 140022F20: using guessed type wchar_t aFailedToQueryN[65];
// 140022FB0: using guessed type wchar_t aFailedToRefere[40];
// 140023000: using guessed type wchar_t aFileZIsRemote[18];
// 140023030: using guessed type wchar_t aCollisionInThe[47];
// 140035180: using guessed type int dword_140035180;
// 140036948: using guessed type __int64 qword_140036948;
// 140036950: using guessed type __int64 qword_140036950;

//----- (000000014000A930) ----------------------------------------------------
HANDLE *sub_14000A930()
{
  __int64 v0; // rax
  __int64 v1; // rcx
  HANDLE *result; // rax
  __int64 *v3; // [rsp+20h] [rbp-10h]
  __int64 *v4; // [rsp+28h] [rbp-8h]

  v4 = (__int64 *)&v3;
  v3 = (__int64 *)&v3;
  ExAcquireFastMutex(&stru_140036958);
  if ( *(__int64 **)(qword_140036948 + 8) != &qword_140036948
    || (v3 = (__int64 *)qword_140036948,
        v4 = &qword_140036948,
        *(_QWORD *)(qword_140036948 + 8) = &v3,
        qword_140036948 = (__int64)&v3,
        v0 = qword_140036950,
        v4 != &qword_140036948)
    || *(__int64 **)qword_140036950 != &qword_140036948 )
  {
LABEL_10:
    __fastfail(3u);
  }
  *(_QWORD *)qword_140036950 = &v3;
  v4 = (__int64 *)v0;
  qword_140036950 = (__int64)&qword_140036948;
  qword_140036948 = (__int64)&qword_140036948;
  ExReleaseFastMutex(&stru_140036958);
  while ( 1 )
  {
    result = (HANDLE *)v3;
    if ( v3 == (__int64 *)&v3 )
      return result;
    if ( (__int64 **)v3[1] != &v3 )
      goto LABEL_10;
    v1 = *v3;
    if ( *(__int64 **)(*v3 + 8) != v3 )
      goto LABEL_10;
    v3 = (__int64 *)*v3;
    *(_QWORD *)(v1 + 8) = &v3;
    sub_14000A43C(result);
  }
}
// 140036948: using guessed type __int64 qword_140036948;
// 140036950: using guessed type __int64 qword_140036950;

//----- (000000014000AA10) ----------------------------------------------------
__int64 __fastcall sub_14000AA10(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rbx
  __int64 i; // rax

  v1 = a1;
  v2 = 0i64;
  ExAcquireFastMutex(&stru_140036958);
  for ( i = qword_140036948; (__int64 *)i != &qword_140036948; i = *(_QWORD *)i )
  {
    if ( *(_QWORD *)(i + 16) == v1 )
      goto LABEL_6;
  }
  i = 0i64;
LABEL_6:
  if ( i )
  {
    v2 = *(_QWORD *)(i + 24);
    ObfReferenceObject(*(PVOID *)(i + 24));
  }
  ExReleaseFastMutex(&stru_140036958);
  return v2;
}
// 140036948: using guessed type __int64 qword_140036948;

//----- (000000014000AA8C) ----------------------------------------------------
bool __fastcall sub_14000AA8C(__int64 a1, int a2)
{
  __int64 v2; // rdi
  int v3; // esi
  __int64 i; // rbx

  v2 = a1;
  v3 = a2;
  ExAcquireFastMutex(&stru_140036958);
  for ( i = qword_140036948; (__int64 *)i != &qword_140036948; i = *(_QWORD *)i )
  {
    if ( *(_QWORD *)(i + 16) == v2 )
      goto LABEL_6;
  }
  i = 0i64;
LABEL_6:
  if ( i )
    *(_DWORD *)(i + 40) = v3;
  ExReleaseFastMutex(&stru_140036958);
  return i != 0;
}
// 140036948: using guessed type __int64 qword_140036948;

//----- (000000014000AB04) ----------------------------------------------------
PVOID __fastcall sub_14000AB04(SIZE_T a1, POOL_TYPE a2)
{
  return ExAllocatePoolWithTag(a2, a1, 0x53465042u);
}

//----- (000000014000AB20) ----------------------------------------------------
void __fastcall sub_14000AB20(void *a1)
{
  if ( a1 )
    ExFreePoolWithTag(a1, 0);
}

//----- (000000014000AB40) ----------------------------------------------------
char *sub_14000AB40()
{
  __int64 (**v0)(void); // rbx
  char *result; // rax

  v0 = (__int64 (**)(void))qword_140036998;
  do
  {
    if ( *v0 )
      sub_140021A40(*v0);
    ++v0;
    result = &byte_1400369C0;
  }
  while ( (signed __int64)v0 < (signed __int64)&byte_1400369C0 );
  return result;
}
// 1400369C0: using guessed type char byte_1400369C0;

//----- (000000014000ABA0) ----------------------------------------------------
__int64 __fastcall sub_14000ABA0(int a1, __int64 a2)
{
  __int64 v2; // r8
  _QWORD *v3; // rax
  unsigned int v4; // ebx
  char v5; // cl
  int v6; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]

  v2 = a1;
  v3 = qword_140036998;
  v4 = 0;
  while ( !*v3 )
  {
    ++v3;
    if ( (signed __int64)v3 >= (signed __int64)&byte_1400369C0 )
    {
      v5 = 0;
      goto LABEL_6;
    }
  }
  v5 = 1;
LABEL_6:
  qword_140036998[v2] = a2;
  if ( v5 || (v6 = PsSetCreateProcessNotifyRoutineEx(sub_14000AB40, 0i64), v4 = v6, (byte_140036990 = v6 >= 0) != 0) )
  {
    if ( dword_140035180 & 0x80800000 )
      sub_140007A38((__int64)L"Process creation & termination filtering activated successfully");
  }
  else
  {
    LODWORD(BugCheckParameter3) = v6;
    sub_140006BB4(0x90ui64, 0x6Eui64, 0i64, 0xE03D0220, BugCheckParameter3, 0);
  }
  return v4;
}
// 140023090: using guessed type wchar_t aProcessCreatio[64];
// 1400284C0: using guessed type __int64 __fastcall PsSetCreateProcessNotifyRoutineEx(_QWORD, _QWORD);
// 140035180: using guessed type int dword_140035180;
// 140036990: using guessed type char byte_140036990;
// 1400369C0: using guessed type char byte_1400369C0;

//----- (000000014000AC40) ----------------------------------------------------
int __fastcall sub_14000AC40(int a1, __int64 a2)
{
  char *v2; // rax
  _QWORD *v3; // rcx

  v2 = (char *)a1;
  v3 = qword_140036998;
  qword_140036998[(_QWORD)v2] = 0i64;
  while ( !*v3 )
  {
    ++v3;
    v2 = &byte_1400369C0;
    if ( (signed __int64)v3 >= (signed __int64)&byte_1400369C0 )
    {
      LOBYTE(a2) = 1;
      byte_140036990 = 0;
      LODWORD(v2) = PsSetCreateProcessNotifyRoutineEx(sub_14000AB40, a2);
      if ( (signed int)v2 < 0 )
      {
        if ( dword_140035180 & 0x80800000 )
          LODWORD(v2) = sub_140007A38(
                          (__int64)L"PsSetCreateProcessNotifyRoutineEx( REMOVE ) failed 0x%x",
                          (unsigned int)v2);
        return (signed int)v2;
      }
      break;
    }
  }
  if ( dword_140035180 & 0x80800000 )
    LODWORD(v2) = sub_140007A38((__int64)L"Process creation & termination filtering deactivated successfully");
  return (signed int)v2;
}
// 140023110: using guessed type wchar_t aPssetcreatepro[56];
// 140023180: using guessed type wchar_t aProcessCreatio_0[66];
// 1400284C0: using guessed type __int64 __fastcall PsSetCreateProcessNotifyRoutineEx(_QWORD, _QWORD);
// 140035180: using guessed type int dword_140035180;
// 140036990: using guessed type char byte_140036990;
// 1400369C0: using guessed type char byte_1400369C0;

//----- (000000014000ACC4) ----------------------------------------------------
__int64 __fastcall sub_14000ACC4(__int64 a1, __int64 a2)
{
  unsigned int v2; // ebx
  unsigned int v3; // eax
  unsigned int v4; // eax

  v2 = 0;
  if ( (_DWORD)a1 )
  {
    if ( (_DWORD)a1 != 1 )
    {
      if ( (_DWORD)a1 != 2 )
      {
        if ( (_DWORD)a1 != 3 )
        {
          if ( (_DWORD)a1 != 4 )
          {
            if ( (_DWORD)a1 != 5 )
            {
              if ( (_DWORD)a1 != 6 && (_DWORD)a1 != 65535 && dword_140035180 & 0x800000 )
                sub_140007A38((__int64)L"Unknown module activation index %d", (unsigned int)a1);
              v3 = sub_14001E5AC();
              if ( (v3 & 0x80000000) != 0 )
              {
                v2 = v3;
                if ( dword_140035180 & 0x800000 )
                  sub_140007A38((__int64)L"Failed to unhook driver loading filter, status %X", v3);
              }
            }
            v4 = sub_14001F4DC();
            a2 = v4;
            if ( (v4 & 0x80000000) != 0 )
            {
              if ( (v2 & 0x80000000) == 0 )
                v2 = v4;
              if ( dword_140035180 & 0x800000 )
                sub_140007A38((__int64)L"Failed to unhook registry filter, status %X", v4);
            }
          }
          sub_14000D254(a1, a2);
        }
        sub_14000C930();
      }
      sub_14001E680();
    }
    sub_14000AC40(0, a2);
  }
  sub_14000BBD0();
  return v2;
}
// 140023210: using guessed type wchar_t aUnknownModuleA[35];
// 140023260: using guessed type wchar_t aFailedToUnhook[50];
// 1400232D0: using guessed type wchar_t aFailedToUnhook_0[44];
// 140035180: using guessed type int dword_140035180;

//----- (000000014000AD94) ----------------------------------------------------
struct _KEVENT *sub_14000AD94()
{
  return &stru_1400369D0;
}

//----- (000000014000AD9C) ----------------------------------------------------
char sub_14000AD9C()
{
  return byte_1400369C0;
}
// 1400369C0: using guessed type char byte_1400369C0;

//----- (000000014000ADA4) ----------------------------------------------------
void sub_14000ADA4()
{
  KeInitializeEvent(&stru_1400369D0, 0, 0);
}

//----- (000000014000ADBC) ----------------------------------------------------
__int64 __fastcall sub_14000ADBC(char a1)
{
  char v1; // bl
  signed int v2; // ebx
  unsigned int v3; // edi
  unsigned int v4; // ebx
  UNICODE_STRING *v5; // rax
  __int64 v6; // rdx
  signed int v7; // eax
  ULONG v8; // er9
  ULONG_PTR v9; // rdx
  signed int v10; // eax
  unsigned int v11; // eax
  __int64 v12; // rcx
  __int64 v13; // rdx
  __int64 v14; // rdx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]
  unsigned int v17; // [rsp+48h] [rbp+10h]

  v1 = a1;
  KeWaitForSingleObject(&stru_140039660, UserRequest, 0, 0, 0i64);
  if ( (unsigned int)dword_140039698 >= 3 )
  {
    if ( !v1 )
    {
      KeSetEvent(&stru_1400369D0, 0, 0);
      v2 = 0;
      v10 = sub_14001E5AC();
      if ( v10 < 0 )
      {
        v2 = v10;
        if ( dword_140035180 & 0x800000 )
          sub_140007A38((__int64)L"Failed to unhook driver loading filter, status %X", (unsigned int)v10);
      }
      v11 = sub_14001F4DC();
      v13 = v11;
      if ( (v11 & 0x80000000) != 0 )
      {
        if ( v2 >= 0 )
          v2 = v11;
        if ( dword_140035180 & 0x800000 )
          sub_140007A38((__int64)L"Failed to unhook registry filter, status %X", v11);
      }
      sub_14000D254(v12, v13);
      sub_14000C930();
      sub_14001E680();
      sub_14000AC40(0, v14);
      sub_14000BBD0();
      byte_1400369C0 = 0;
      goto LABEL_32;
    }
    v3 = 0;
    v4 = 120;
    v5 = sub_14000589C();
    if ( sub_1400095B8(v5, L"HIPSTimeout", &v17) )
      v4 = v17;
    dword_14002B140 = v4;
    if ( dword_140035180 & 0xF4F00000 )
      sub_140007A38((__int64)L"HIPS event processing timeout will be %d seconds", v4);
    qword_1400369C8 = qword_1400382A8;
    KeClearEvent(&stru_1400369D0);
    sub_14000BBAC();
    v2 = sub_14000ABA0(0, (__int64)sub_14000B480);
    if ( v2 < 0 )
    {
LABEL_22:
      sub_14000ACC4(v3, v6);
LABEL_32:
      qword_1400369C8 = 0i64;
      goto LABEL_33;
    }
    v3 = 1;
    v7 = sub_14001E600();
    v2 = v7;
    if ( v7 < 0 )
    {
      v8 = -532872702;
      v9 = 237i64;
    }
    else
    {
      v3 = 2;
      v7 = sub_14000C924();
      v2 = v7;
      if ( v7 < 0 )
      {
        v8 = -532872700;
        v9 = 250i64;
      }
      else
      {
        v3 = 3;
        v7 = sub_14000D20C();
        v2 = v7;
        if ( v7 < 0 )
        {
          v8 = -532872699;
          v9 = 263i64;
        }
        else
        {
          v3 = 4;
          v7 = sub_14001F430();
          v2 = v7;
          if ( v7 < 0 )
          {
            v8 = -532872703;
            v9 = 275i64;
          }
          else
          {
            v3 = 5;
            v7 = sub_14001E550();
            v2 = v7;
            if ( v7 >= 0 )
            {
              v3 = 6;
              byte_1400369C0 = 1;
              goto LABEL_21;
            }
            v8 = -532872698;
            v9 = 287i64;
          }
        }
      }
    }
    LODWORD(BugCheckParameter3) = v7;
    sub_140006BB4(0x1F4ui64, v9, 0i64, v8, BugCheckParameter3, 0);
LABEL_21:
    if ( v2 >= 0 )
      goto LABEL_33;
    goto LABEL_22;
  }
  v2 = -1073741436;
  LODWORD(BugCheckParameter3) = -1073741436;
  sub_140006BB4(0x1F4ui64, 0xBEui64, 0i64, 0xE03D0200, BugCheckParameter3, 0);
LABEL_33:
  KeReleaseMutex(&stru_140039660, 0);
  return (unsigned int)v2;
}
// 140023260: using guessed type wchar_t aFailedToUnhook[50];
// 1400232D0: using guessed type wchar_t aFailedToUnhook_0[44];
// 140023330: using guessed type wchar_t aHipstimeout[12];
// 140023350: using guessed type wchar_t aHipsEventProce[49];
// 14002B140: using guessed type int dword_14002B140;
// 140035180: using guessed type int dword_140035180;
// 1400369C0: using guessed type char byte_1400369C0;
// 1400369C8: using guessed type __int64 qword_1400369C8;
// 1400382A8: using guessed type __int64 qword_1400382A8;
// 140039698: using guessed type int dword_140039698;

//----- (000000014000B028) ----------------------------------------------------
void __fastcall sub_14000B028(__int64 a1, unsigned int a2)
{
  unsigned int v2; // edi
  __int64 v3; // rbx
  __int64 v4; // rax
  PVOID v5; // rax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]

  *(_BYTE *)(a1 + 12) = 0;
  v2 = a2;
  v3 = a1;
  if ( a2 )
  {
    if ( a2 <= 0x400 )
    {
      ++stru_140036A00.L.TotalAllocates;
      v4 = (__int64)ExpInterlockedPopEntrySList(&stru_140036A00.L.ListHead);
      if ( !v4 )
      {
        ++stru_140036A00.L.AllocateMisses;
        v4 = sub_140021A40((__int64 (*)(void))stru_140036A00.L.Allocate);
      }
      *(_QWORD *)v3 = v4;
      if ( v4 )
      {
        *(_BYTE *)(v3 + 12) = 1;
        v2 = 1024;
      }
    }
    if ( !*(_BYTE *)(v3 + 12) )
    {
      v5 = ExAllocatePoolWithTag(PagedPool, v2, 0x70705352u);
      *(_QWORD *)v3 = v5;
      if ( !v5 )
      {
        LODWORD(BugCheckParameter3) = -1073741670;
        sub_140006BB4(0x1F5ui64, 0x65ui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
        v2 = 0;
      }
    }
  }
  *(_DWORD *)(v3 + 8) = v2;
}

//----- (000000014000B0FC) ----------------------------------------------------
void __fastcall sub_14000B0FC(__int64 a1)
{
  struct _SLIST_ENTRY *v1; // rdi
  __int64 v2; // rbx

  v1 = *(struct _SLIST_ENTRY **)a1;
  v2 = a1;
  if ( *(_QWORD *)a1 )
  {
    if ( *(_BYTE *)(a1 + 12) )
    {
      ++stru_140036A00.L.TotalFrees;
      if ( ExQueryDepthSList(&stru_140036A00.L.ListHead) < stru_140036A00.L.Depth )
      {
        ExpInterlockedPushEntrySList(&stru_140036A00.L.ListHead, v1);
      }
      else
      {
        ++stru_140036A00.L.FreeMisses;
        sub_140021A40((__int64 (*)(void))stru_140036A00.L.Free);
      }
    }
    else
    {
      ExFreePoolWithTag(*(PVOID *)a1, 0x70705352u);
    }
    *(_QWORD *)v2 = 0i64;
  }
  *(_DWORD *)(v2 + 8) = 0;
}

//----- (000000014000B190) ----------------------------------------------------
__int64 __fastcall sub_14000B190(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rbx
  __int64 v4; // r8
  __int64 v5; // rdx
  signed int v6; // eax
  const wchar_t *v7; // rcx
  unsigned int v8; // edi
  __int64 v9; // r8
  __int64 v10; // rdx
  unsigned int v12; // [rsp+30h] [rbp+8h]
  int v13; // [rsp+38h] [rbp+10h]

  *(_QWORD *)a1 = 0i64;
  v2 = a2;
  *(_DWORD *)(a1 + 8) = 0;
  v3 = a1;
  *(_BYTE *)(a1 + 12) = 0;
  sub_14000B028(a1, 0);
  *(_QWORD *)(v3 + 16) = 0i64;
  *(_DWORD *)(v3 + 24) = -1073741823;
  if ( v2 )
  {
    sub_14000B0FC(v3);
    sub_14000B028(v3, 1u);
    v4 = *(unsigned int *)(v3 + 8);
    v12 = v4;
    if ( !(_DWORD)v4 )
    {
      *(_DWORD *)(v3 + 24) = -1073741670;
      return v3;
    }
    v5 = *(_QWORD *)v3;
    *(_QWORD *)(v3 + 16) = *(_QWORD *)v3;
    v6 = ObQueryNameString(v2, v5, v4, &v12);
    *(_DWORD *)(v3 + 24) = v6;
    if ( v6 >= 0 )
      return v3;
    if ( v6 == -1073741820 || v6 == -2147483643 )
    {
      v8 = v12;
      if ( !v12 )
      {
        if ( dword_140035180 & 0xF4700000 )
          sub_140007A38((__int64)L"ObjectName: ObQueryNameString requested zero-length buffer");
        goto LABEL_18;
      }
      sub_14000B0FC(v3);
      sub_14000B028(v3, v8);
      v9 = *(unsigned int *)(v3 + 8);
      v13 = v9;
      if ( (_DWORD)v9 )
      {
        v10 = *(_QWORD *)v3;
        *(_QWORD *)(v3 + 16) = *(_QWORD *)v3;
        v6 = ObQueryNameString(v2, v10, v9, &v13);
        *(_DWORD *)(v3 + 24) = v6;
        if ( v6 >= 0 )
          return v3;
        if ( dword_140035180 & 0xF4700000 )
        {
          v7 = L"ObjectName: ObQueryNameString failed 0x%x with re-allocated buffer";
          goto LABEL_15;
        }
      }
      else
      {
        *(_DWORD *)(v3 + 24) = -1073741670;
      }
    }
    else if ( dword_140035180 & 0xF4700000 )
    {
      v7 = L"ObjectName: ObQueryNameString failed 0x%x";
LABEL_15:
      sub_140007A38((__int64)v7, (unsigned int)v6);
      goto LABEL_18;
    }
LABEL_18:
    *(_QWORD *)(v3 + 16) = 0i64;
    sub_14000B0FC(v3);
    sub_14000B028(v3, 0);
  }
  return v3;
}
// 140023430: using guessed type wchar_t aObjectnameObqu[67];
// 1400234C0: using guessed type wchar_t aObjectnameObqu_1[59];
// 140023540: using guessed type wchar_t aObjectnameObqu_0[42];
// 1400284A8: using guessed type __int64 __fastcall ObQueryNameString(_QWORD, _QWORD, _QWORD, _QWORD);
// 140035180: using guessed type int dword_140035180;

//----- (000000014000B2FC) ----------------------------------------------------
PVOID *__fastcall sub_14000B2FC(PVOID *Object, HANDLE Handle)
{
  PVOID *v2; // rbx
  NTSTATUS v3; // eax

  *Object = 0i64;
  *((_DWORD *)Object + 2) = -1073741816;
  v2 = Object;
  if ( Handle )
  {
    v3 = ObReferenceObjectByHandle(Handle, 0, 0i64, 0, Object, 0i64);
    *((_DWORD *)v2 + 2) = v3;
    if ( v3 < 0 )
    {
      if ( dword_140035180 & 0xF4700000 )
        sub_140007A38((__int64)L"ObjectReference: ObReferenceObjectByHandle failed 0x%x", (unsigned int)v3);
      *v2 = 0i64;
    }
  }
  return v2;
}
// 1400233C0: using guessed type wchar_t aObjectreferenc[55];
// 140035180: using guessed type int dword_140035180;

//----- (000000014000B368) ----------------------------------------------------
LONG_PTR __fastcall sub_14000B368(void **a1)
{
  void *v1; // rcx
  LONG_PTR result; // rax

  v1 = *a1;
  if ( v1 )
    result = ObfDereferenceObject(v1);
  return result;
}

//----- (000000014000B388) ----------------------------------------------------
__int64 __fastcall sub_14000B388(__int64 a1)
{
  bool v1; // zf
  __int64 result; // rax
  unsigned int v3; // ebx
  UNICODE_STRING SystemRoutineName; // [rsp+30h] [rbp-50h]
  __int64 v5; // [rsp+40h] [rbp-40h]
  __int64 v6; // [rsp+48h] [rbp-38h]
  int v7; // [rsp+50h] [rbp-30h]
  __int64 v8; // [rsp+58h] [rbp-28h]
  __int64 v9; // [rsp+60h] [rbp-20h]
  int v10; // [rsp+68h] [rbp-18h]
  __int128 v11; // [rsp+70h] [rbp-10h]
  HANDLE Handle; // [rsp+90h] [rbp+10h]

  v6 = 0i64;
  v8 = 0i64;
  v9 = 0i64;
  v1 = qword_140036A80 == 0;
  v5 = a1;
  v7 = 48;
  v10 = 512;
  _mm_storeu_si128((__m128i *)&v11, (__m128i)0i64);
  if ( v1 )
  {
    *(_DWORD *)&SystemRoutineName.Length = 3407922;
    SystemRoutineName.Buffer = L"ZwQueryInformationProcess";
    qword_140036A80 = (__int64)MmGetSystemRoutineAddress(&SystemRoutineName);
    if ( !qword_140036A80 )
      return 3221225473i64;
  }
  result = ZwOpenProcess(&Handle, 0i64, &v7, &v5);
  if ( (signed int)result >= 0 )
  {
    v3 = sub_140021A40((__int64 (*)(void))qword_140036A80);
    ZwClose(Handle);
    result = v3;
  }
  return result;
}
// 1400235A0: using guessed type wchar_t aZwqueryinforma_1[26];
// 1400284D8: using guessed type __int64 __fastcall ZwOpenProcess(_QWORD, _QWORD, _QWORD, _QWORD);
// 140036A80: using guessed type __int64 qword_140036A80;

//----- (000000014000B480) ----------------------------------------------------
void __fastcall sub_14000B480(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r14
  __int64 v4; // r13
  __int64 v5; // rcx
  __int64 v6; // r12
  struct _SLIST_ENTRY *v7; // rdi
  unsigned int v8; // esi
  struct _SLIST_ENTRY *v9; // rbx
  unsigned __int16 *v10; // rax
  __int64 v11; // rdx
  __int64 v12; // rcx
  unsigned __int64 v13; // r15
  int v14; // eax
  int v15; // esi
  unsigned int v16; // er15
  signed int v17; // edx
  struct _SLIST_ENTRY *v18; // rcx
  __int64 v19; // rcx
  bool v20; // [rsp+40h] [rbp-49h]
  __int64 v21; // [rsp+48h] [rbp-41h]
  int v22; // [rsp+50h] [rbp-39h]
  signed int v23; // [rsp+54h] [rbp-35h]
  struct _SLIST_ENTRY *v24; // [rsp+58h] [rbp-31h]
  unsigned __int64 v25; // [rsp+60h] [rbp-29h]
  int v26; // [rsp+68h] [rbp-21h]
  char v27; // [rsp+6Ch] [rbp-1Dh]
  int v28; // [rsp+70h] [rbp-19h]
  __int16 *v29; // [rsp+78h] [rbp-11h]
  __int16 v30; // [rsp+80h] [rbp-9h]
  char v31; // [rsp+82h] [rbp-7h]

  v3 = a3;
  v4 = a2;
  v20 = a3 != 0;
  if ( ExGetPreviousMode() == 1 && IoGetCurrentProcess() != (PEPROCESS)qword_1400369C8 )
  {
    v24 = 0i64;
    v6 = 0i64;
    v7 = 0i64;
    if ( v3 )
    {
      v21 = PsGetCurrentProcessId(v5);
      v6 = sub_14000BBB4(v4);
      v7 = (struct _SLIST_ENTRY *)sub_14000BBB4(v21);
      v24 = v7;
    }
    else
    {
      sub_14000BC10(v4);
      v21 = 0i64;
    }
    v8 = 40;
    v22 = 40;
    v9 = (struct _SLIST_ENTRY *)v6;
    if ( v3 )
    {
      v10 = *(unsigned __int16 **)(v3 + 56);
      if ( v10 )
      {
        v8 = *v10 + 42;
        v22 = *v10 + 42;
      }
    }
    v25 = 0i64;
    v26 = 0;
    v27 = 0;
    sub_14000B028((__int64)&v25, v8);
    v13 = v25;
    if ( v25 )
    {
      *(_DWORD *)(v25 + 8) = v21;
      *(_BYTE *)(v13 + 12) = v20;
      *(_DWORD *)(v13 + 4) = v4;
      *(_DWORD *)v13 = 2;
      *(_DWORD *)(v13 + 16) = PsGetCurrentThreadId(v12, v11, 0x80000000i64);
      *(_QWORD *)(v13 + 24) = MEMORY[0xFFFFF78000000014];
      *(_DWORD *)(v13 + 32) = 0;
      if ( !v3 )
        goto LABEL_47;
      if ( *(_QWORD *)(v3 + 56) )
      {
        *(_DWORD *)(v13 + 32) = 40;
        sub_140021A80((__m128i *)(v13 + 40), *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8i64), **(unsigned __int16 **)(v3 + 56));
        v8 = v22;
        *(_WORD *)(**(unsigned __int16 **)(v3 + 56) + v13 + 40) = 0;
      }
      if ( v3 )
      {
        if ( dword_140035180 < 0 )
          sub_140007A38(
            (__int64)L"Process 0x%x is creating process 0x%x (thread 0x%x)",
            *(unsigned int *)(v13 + 8),
            *(unsigned int *)(v13 + 4),
            *(unsigned int *)(v13 + 16));
      }
      else
      {
LABEL_47:
        if ( dword_140035180 < 0 )
          sub_140007A38(
            (__int64)L"Process 0x%x is terminating (thread 0x%x)",
            *(unsigned int *)(v13 + 4),
            *(unsigned int *)(v13 + 16));
      }
      v14 = sub_140019B6C(dword_14002B140, v13, v8);
      v15 = v14;
      if ( v14 == -1073741536 || v14 == -1073741248 )
      {
        sub_14000B0FC((__int64)&v25);
        sub_14000BBE4(v24);
        v18 = (struct _SLIST_ENTRY *)v6;
LABEL_44:
        sub_14000BBE4(v18);
        return;
      }
      if ( v14 < 0 || v14 == 258 )
      {
        v30 = 63;
        sub_140021DC0((__m128 *)&v31, 0, 0x20ui64);
        v16 = v21;
        v29 = &v30;
        v28 = 2228225;
        sub_140007D18((__int64)&v28, v21);
        sub_140005F58(
          0x208ui64,
          0xDEui64,
          v3 != 0 ? -532872651 : -532872649,
          v15,
          (__int64)&byte_140028BB0,
          v4,
          (__int64)&v28);
      }
      else
      {
        v16 = v21;
        if ( v3 )
        {
          v17 = v23;
          if ( v23 <= 2 )
          {
LABEL_29:
            if ( v17 )
            {
              if ( v17 == 1 )
              {
                if ( dword_140035180 & 0x80000000 )
                  sub_140007A38((__int64)L"Process filter is terminating PID 0x%x", (unsigned int)v4);
                v9 = 0i64;
                v19 = v6;
              }
              else
              {
                if ( v17 != 2 )
                {
                  if ( dword_140035180 & 0x80000000 )
                    sub_140007A38((__int64)L"Unknown action %d returned to CreateOrTerminateProcessNotifyRoutine");
                  goto LABEL_43;
                }
                if ( dword_140035180 & 0x80000000 )
                  sub_140007A38((__int64)L"Process filter is terminating PID 0x%x", (unsigned int)v4);
                v9 = 0i64;
                sub_14000BC20(v6);
                if ( dword_140035180 < 0 )
                  sub_140007A38((__int64)L"Process filter is terminating PID 0x%x", v16);
                v19 = (__int64)v24;
                v7 = 0i64;
              }
              sub_14000BC20(v19);
            }
LABEL_43:
            sub_14000B0FC((__int64)&v25);
            sub_14000BBE4(v7);
            v18 = v9;
            goto LABEL_44;
          }
        }
      }
    }
    else
    {
      v16 = v21;
    }
    v17 = 0;
    goto LABEL_29;
  }
}
// 1400235E0: using guessed type wchar_t aProcess0xXIsCr[52];
// 140023650: using guessed type wchar_t aProcess0xXIsTe[42];
// 1400236B0: using guessed type wchar_t aProcessFilterI[39];
// 140023700: using guessed type wchar_t aUnknownActionD[68];
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 1400284E8: using guessed type __int64 __fastcall PsGetCurrentThreadId(_QWORD, _QWORD, _QWORD);
// 14002B140: using guessed type int dword_14002B140;
// 140035180: using guessed type int dword_140035180;
// 1400369C8: using guessed type __int64 qword_1400369C8;

//----- (000000014000B81C) ----------------------------------------------------
__int64 __fastcall sub_14000B81C(__int64 a1)
{
  __int64 v1; // rbx
  __int64 result; // rax

  *(_QWORD *)(a1 + 16) = 0i64;
  *(_BYTE *)(a1 + 24) = 0;
  v1 = a1;
  *(_QWORD *)(a1 + 8) = a1;
  *(_QWORD *)a1 = a1;
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 32) = 1;
  KeInitializeEvent((PRKEVENT)(a1 + 56), SynchronizationEvent, 0);
  *(_DWORD *)(v1 + 88) = 0;
  result = v1;
  *(_DWORD *)(v1 + 92) = 0;
  return result;
}

//----- (000000014000B86C) ----------------------------------------------------
__int64 __fastcall sub_14000B86C(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 v3; // rbx
  __int64 v4; // rax

  *(_QWORD *)(a1 + 16) = a2;
  v3 = a1;
  *(_BYTE *)(a1 + 24) = 1;
  if ( a2 && a3 )
  {
    v4 = *a3;
    if ( *(__int64 **)(*a3 + 8) != a3 )
      __fastfail(3u);
    *(_QWORD *)a1 = v4;
    *(_QWORD *)(a1 + 8) = a3;
    *(_QWORD *)(v4 + 8) = a1;
    *a3 = a1;
  }
  else if ( dword_140035180 < 0 )
  {
    sub_140007A38((__int64)L"Invalid parameter for new event ticket");
  }
  return v3;
}
// 140023790: using guessed type wchar_t aInvalidParamet[39];
// 140035180: using guessed type int dword_140035180;

//----- (000000014000B8C8) ----------------------------------------------------
__int64 sub_14000B8C8()
{
  __int64 result; // rax

  ++stru_140036AC0.L.TotalAllocates;
  result = (__int64)ExpInterlockedPopEntrySList(&stru_140036AC0.L.ListHead);
  if ( !result )
  {
    ++stru_140036AC0.L.AllocateMisses;
    result = sub_140021A40((__int64 (*)(void))stru_140036AC0.L.Allocate);
  }
  return result;
}

//----- (000000014000B918) ----------------------------------------------------
void __fastcall sub_14000B918(PSLIST_ENTRY ListEntry)
{
  struct _SLIST_ENTRY *v1; // rbx

  if ( ListEntry )
  {
    ++stru_140036AC0.L.TotalFrees;
    v1 = ListEntry;
    if ( ExQueryDepthSList(&stru_140036AC0.L.ListHead) < stru_140036AC0.L.Depth )
    {
      ExpInterlockedPushEntrySList(&stru_140036AC0.L.ListHead, v1);
    }
    else
    {
      ++stru_140036AC0.L.FreeMisses;
      sub_140021A40((__int64 (*)(void))stru_140036AC0.L.Free);
    }
  }
}

//----- (000000014000B97C) ----------------------------------------------------
__int64 __fastcall sub_14000B97C(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbp
  __int64 v4; // rsi
  __int64 v6; // rax
  __int64 v7; // rcx
  int v8; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]

  v2 = 0i64;
  v3 = a2;
  v4 = a1;
  if ( !a2 )
    return 0i64;
  ExAcquireFastMutex((PFAST_MUTEX)(a1 + 32));
  v6 = sub_14000B8C8();
  if ( v6 )
    v7 = sub_14000B86C(v6, v3, (__int64 *)v4);
  else
    v7 = 0i64;
  if ( v7 )
  {
    v8 = *(_DWORD *)(v4 + 88) + 1;
    *(_DWORD *)(v4 + 88) = v8;
    if ( v8 > *(_DWORD *)(v4 + 92) )
      *(_DWORD *)(v4 + 92) = v8;
    v2 = v7;
  }
  else
  {
    LODWORD(BugCheckParameter3) = -1073741670;
    sub_140006BB4(0x209ui64, 0xF8ui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
  }
  ExReleaseFastMutex((PFAST_MUTEX)(v4 + 32));
  return v2;
}

//----- (000000014000BA40) ----------------------------------------------------
void __fastcall sub_14000BA40(__int64 a1, struct _SLIST_ENTRY *a2)
{
  __int64 v2; // rsi
  struct _SLIST_ENTRY *v3; // rdi
  PSLIST_ENTRY v4; // rax
  struct _SLIST_ENTRY **v5; // rcx

  if ( a2 )
  {
    v2 = a1;
    v3 = a2;
    ExAcquireFastMutex((PFAST_MUTEX)(a1 + 32));
    if ( v3[1].Next )
    {
      v4 = v3->Next;
      if ( *(&v3->Next->Next + 1) != v3 || (v5 = (struct _SLIST_ENTRY **)*((_QWORD *)&v3->Next + 1), *v5 != v3) )
        __fastfail(3u);
      *v5 = v4;
      *((_QWORD *)&v4->Next + 1) = v5;
      sub_14000B918(v3);
      --*(_DWORD *)(v2 + 88);
    }
    else if ( dword_140035180 < 0 )
    {
      sub_140007A38((__int64)L"Attempt to delete root of event ticket collection");
    }
    ExReleaseFastMutex((PFAST_MUTEX)(v2 + 32));
  }
}
// 1400237E0: using guessed type wchar_t aAttemptToDelet[50];
// 140035180: using guessed type int dword_140035180;

//----- (000000014000BAD8) ----------------------------------------------------
void __fastcall sub_14000BAD8(__int64 **a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 **v3; // rdi
  __int64 *i; // rax
  __int64 v5; // rcx

  v2 = a2;
  v3 = a1;
  if ( a2 )
  {
    ExAcquireFastMutex((PFAST_MUTEX)(a1 + 4));
    for ( i = *v3; i; i = (__int64 *)*i )
    {
      v5 = i[2];
      if ( !v5 )
        break;
      if ( v5 == v2 )
        *((_BYTE *)i + 24) = 0;
    }
    ExReleaseFastMutex((PFAST_MUTEX)(v3 + 4));
  }
  else if ( dword_140035180 < 0 )
  {
    sub_140007A38((__int64)L"Attempt to punch tickets for PID 0");
  }
}
// 140023850: using guessed type wchar_t aAttemptToPunch[35];
// 140035180: using guessed type int dword_140035180;

//----- (000000014000BB5C) ----------------------------------------------------
void __fastcall sub_14000BB5C(__int64 **a1)
{
  __int64 **v1; // rdi
  __int64 *i; // rax

  v1 = a1;
  ExAcquireFastMutex((PFAST_MUTEX)(a1 + 4));
  for ( i = *v1; i && i[2]; i = (__int64 *)*i )
    *((_BYTE *)i + 24) = 0;
  ExReleaseFastMutex((PFAST_MUTEX)(v1 + 4));
}

//----- (000000014000BBAC) ----------------------------------------------------
void sub_14000BBAC()
{
  byte_140036BA0 = 1;
}
// 140036BA0: using guessed type char byte_140036BA0;

//----- (000000014000BBB4) ----------------------------------------------------
__int64 __fastcall sub_14000BBB4(__int64 a1)
{
  __int64 result; // rax

  if ( byte_140036BA0 )
    result = sub_14000B97C((__int64)&qword_140036B40, a1);
  else
    result = 0i64;
  return result;
}
// 140036B40: using guessed type __int64 qword_140036B40;
// 140036BA0: using guessed type char byte_140036BA0;

//----- (000000014000BBD0) ----------------------------------------------------
void sub_14000BBD0()
{
  byte_140036BA0 = 0;
  sub_14000BB5C((__int64 **)&qword_140036B40);
}
// 140036B40: using guessed type __int64 qword_140036B40;
// 140036BA0: using guessed type char byte_140036BA0;

//----- (000000014000BBE4) ----------------------------------------------------
void __fastcall sub_14000BBE4(struct _SLIST_ENTRY *a1)
{
  sub_14000BA40((__int64)&qword_140036B40, a1);
}
// 140036B40: using guessed type __int64 qword_140036B40;

//----- (000000014000BBF4) ----------------------------------------------------
__int64 __fastcall sub_14000BBF4(__int64 a1)
{
  __int64 result; // rax

  result = 0i64;
  if ( a1 )
    result = *(_QWORD *)(a1 + 16);
  return result;
}

//----- (000000014000BC00) ----------------------------------------------------
char __fastcall sub_14000BC00(__int64 a1)
{
  char result; // al

  result = 0;
  if ( !a1 || !*(_BYTE *)(a1 + 24) )
    result = 1;
  return result;
}

//----- (000000014000BC10) ----------------------------------------------------
void __fastcall sub_14000BC10(__int64 a1)
{
  sub_14000BAD8((__int64 **)&qword_140036B40, a1);
}
// 140036B40: using guessed type __int64 qword_140036B40;

//----- (000000014000BC20) ----------------------------------------------------
__int64 __fastcall sub_14000BC20(__int64 a1)
{
  struct _SLIST_ENTRY *v1; // rdi
  char v2; // al
  unsigned int v3; // ebx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]

  v1 = (struct _SLIST_ENTRY *)a1;
  v2 = sub_14000A018((__int64)sub_14000BC90, a1);
  v3 = v2 == 0 ? 0xC0000001 : 0;
  if ( !v2 )
  {
    sub_14000BA40((__int64)&qword_140036B40, v1);
    LODWORD(BugCheckParameter3) = v3;
    sub_140006BB4(0x209ui64, 0x1FCui64, 0i64, 0xE03D0224, BugCheckParameter3, 0);
  }
  return v3;
}
// 140036B40: using guessed type __int64 qword_140036B40;

//----- (000000014000BC90) ----------------------------------------------------
__int64 __fastcall sub_14000BC90(__int64 a1)
{
  struct _SLIST_ENTRY *v1; // rdi
  __int64 v2; // rbx
  signed int v3; // ebx
  ULONG v4; // er9
  ULONG_PTR v5; // rdx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-50h]
  __int64 v8; // [rsp+30h] [rbp-40h]
  __int64 v9; // [rsp+38h] [rbp-38h]
  int v10; // [rsp+40h] [rbp-30h]
  __int64 v11; // [rsp+48h] [rbp-28h]
  __int64 v12; // [rsp+50h] [rbp-20h]
  int v13; // [rsp+58h] [rbp-18h]
  __int128 v14; // [rsp+60h] [rbp-10h]
  HANDLE Handle; // [rsp+80h] [rbp+10h]

  v1 = (struct _SLIST_ENTRY *)a1;
  if ( !a1 || !*(_BYTE *)(a1 + 24) )
  {
    v3 = -1073741823;
    goto LABEL_10;
  }
  v2 = *(_QWORD *)(a1 + 16);
  if ( v2 == PsGetCurrentProcessId(a1) )
  {
    v3 = -1073741790;
    v4 = -532872664;
    v5 = 465i64;
LABEL_8:
    LODWORD(BugCheckParameter3) = v3;
    sub_140006BB4(0x209ui64, v5, 0i64, v4, BugCheckParameter3, 0);
    goto LABEL_10;
  }
  v11 = 0i64;
  v12 = 0i64;
  v9 = 0i64;
  v10 = 48;
  v13 = 512;
  _mm_storeu_si128((__m128i *)&v14, (__m128i)0i64);
  v8 = v2;
  v3 = ZwOpenProcess(&Handle, 0i64, &v10, &v8);
  if ( v3 < 0 || (v3 = ZwTerminateProcess(Handle, 0xFFFFFFFFi64), ZwClose(Handle), v3 < 0) )
  {
    v4 = -532872669;
    v5 = 486i64;
    goto LABEL_8;
  }
LABEL_10:
  sub_14000BA40((__int64)&qword_140036B40, v1);
  return (unsigned int)v3;
}
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 1400284D8: using guessed type __int64 __fastcall ZwOpenProcess(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400284F0: using guessed type __int64 __fastcall ZwTerminateProcess(_QWORD, _QWORD);
// 140036B40: using guessed type __int64 qword_140036B40;

//----- (000000014000BDA8) ----------------------------------------------------
__int64 __fastcall sub_14000BDA8(unsigned __int16 *a1, unsigned __int16 *a2, char a3, unsigned int a4)
{
  char v4; // bl
  unsigned __int16 *v5; // rdi
  unsigned __int16 *v6; // rsi
  int v7; // eax
  unsigned int v8; // er15
  __int64 v9; // rcx
  unsigned int v10; // er13
  __m128i *v11; // r14
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __m128i *v15; // rbx
  _WORD *v16; // rbx
  _WORD *v17; // rbx
  __int16 v18; // bx
  const wchar_t *v20; // rcx
  int v21; // eax
  __int64 v22; // rcx
  int v23; // ebx
  __int64 v24; // rax
  unsigned int v25; // [rsp+40h] [rbp-A8h]
  HANDLE KeyHandle; // [rsp+50h] [rbp-98h]
  __m128i *v27; // [rsp+58h] [rbp-90h]
  int v28; // [rsp+60h] [rbp-88h]
  char v29; // [rsp+64h] [rbp-84h]
  __int64 v30; // [rsp+68h] [rbp-80h]
  __m128i *v31; // [rsp+70h] [rbp-78h]
  OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+78h] [rbp-70h]
  signed int v33; // [rsp+F0h] [rbp+8h]
  char v34; // [rsp+100h] [rbp+18h]
  unsigned int v35; // [rsp+108h] [rbp+20h]

  v35 = a4;
  v34 = a3;
  v4 = a3;
  v5 = a2;
  v6 = a1;
  v25 = 0;
  if ( a1 )
    v7 = *a1 + 36;
  else
    v7 = 34;
  v8 = v7 + *a2;
  v27 = 0i64;
  v28 = 0;
  v29 = 0;
  sub_14000B028((__int64)&v27, v8);
  if ( !v27 )
    goto LABEL_27;
  v10 = PsGetCurrentProcessId(v9);
  v11 = v27;
  HIDWORD(v27->m128i_i64[0]) = v10;
  LODWORD(v11->m128i_i64[0]) = 1;
  BYTE4(v11->m128i_i64[1]) = v4;
  LODWORD(v11->m128i_i64[1]) = 32;
  v11[1].m128i_i32[0] = PsGetCurrentThreadId(v13, v12, v14);
  v11[1].m128i_i64[1] = MEMORY[0xFFFFF78000000014];
  v15 = v11 + 2;
  if ( v6 )
  {
    sub_140021A80(v11 + 2, *((_QWORD *)v6 + 1), *v6);
    v16 = (_WORD *)((char *)v15->m128i_i64 + *v6);
    *v16 = 92;
    v15 = (__m128i *)(v16 + 1);
  }
  sub_140021A80(v15, *((_QWORD *)v5 + 1), *v5);
  v17 = (_WORD *)((char *)v15->m128i_i64 + *v5);
  *v17 = 0;
  v18 = (_WORD)v17 + 2;
  if ( !v34 )
  {
    if ( !(dword_140035180 & 0x40000000) )
      goto LABEL_18;
    v20 = L"NtDeleteKey: PID=0x%x ThreadId=0x%x key=\"%Z\"";
    goto LABEL_17;
  }
  v30 = 0i64;
  *(_DWORD *)((char *)&v30 + 2) = (unsigned __int16)(v18 - ((_WORD)v11 + 32));
  v31 = v11 + 2;
  LOWORD(v30) = WORD1(v30) - 2;
  ObjectAttributes.Length = 48;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 576;
  ObjectAttributes.ObjectName = (PUNICODE_STRING)&v30;
  _mm_storeu_si128((__m128i *)&ObjectAttributes.SecurityDescriptor, (__m128i)0i64);
  if ( ZwOpenKey(&KeyHandle, 1u, &ObjectAttributes) >= 0 )
  {
    ZwClose(KeyHandle);
    sub_14000B0FC((__int64)&v27);
    return 0i64;
  }
  if ( v6 )
  {
    if ( dword_140035180 & 0x40000000 )
      sub_140007A38(
        (__int64)L"NtCreateKey: PID=0x%x ThreadId=0x%x root=\"%Z\" name=\"%Z\"",
        v10,
        v11[1].m128i_u32[0],
        v6,
        v5);
    goto LABEL_18;
  }
  if ( dword_140035180 & 0x40000000 )
  {
    v20 = L"NtCreateKey: PID=0x%x ThreadId=0x%x name=\"%Z\"";
LABEL_17:
    sub_140007A38((__int64)v20, v10, v11[1].m128i_u32[0], v5);
  }
LABEL_18:
  v21 = sub_140019B6C(v35, (unsigned __int64)v11, v8);
  v23 = v21;
  if ( v21 == -1073741536 || v21 == -1073741248 )
  {
    sub_14000B0FC((__int64)&v27);
    return 0i64;
  }
  if ( v21 < 0 || v21 == 258 )
  {
    v24 = PsGetCurrentProcessId(v22);
    sub_140005F58(0x1FFui64, 0xF1ui64, 0xE03D0233, v23, (__int64)v6, v24, (__int64)v5);
  }
  else if ( v33 <= 2 )
  {
    v25 = v33;
  }
LABEL_27:
  sub_14000B0FC((__int64)&v27);
  return v25;
}
// 1400238A0: using guessed type wchar_t aNtcreatekeyPid_0[56];
// 140023910: using guessed type wchar_t aNtcreatekeyPid[46];
// 140023970: using guessed type wchar_t aNtdeletekeyPid[45];
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 1400284E8: using guessed type __int64 __fastcall PsGetCurrentThreadId(_QWORD, _QWORD, _QWORD);
// 140035180: using guessed type int dword_140035180;

//----- (000000014000C0A4) ----------------------------------------------------
signed __int64 __fastcall sub_14000C0A4(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // er12
  __int64 v4; // rsi
  __int64 v5; // rdi
  __int64 v6; // r15
  struct _SLIST_ENTRY *v7; // rbx
  int v8; // er14
  __int64 v9; // rcx
  signed __int64 result; // rax
  char v11; // [rsp+28h] [rbp-60h]
  unsigned __int16 *v12[10]; // [rsp+38h] [rbp-50h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = PsGetCurrentProcessId(a1);
  v7 = (struct _SLIST_ENTRY *)sub_14000BBB4(v6);
  v8 = 0;
  if ( *(_WORD *)v4 >= 2u && **(_WORD **)(v4 + 8) == 92 )
    v5 = 0i64;
  sub_14000B190((__int64)&v11, v5);
  if ( !v5 || v12[0] )
  {
    v8 = sub_14000BDA8(v12[0], (unsigned __int16 *)v4, 1, v3);
    if ( v8 && dword_140035180 & 0x40000000 )
      sub_140007A38(
        (__int64)L"NtCreateKey: Blocking attempt by process 0x%x to access key \"%Z\"",
        (unsigned int)v6,
        v4);
  }
  else if ( dword_140035180 & 0x40000000 )
  {
    sub_140007A38((__int64)L"CreateKey: Could not get root key name");
  }
  sub_14000BDA0(&v11);
  if ( v8 )
  {
    if ( v8 == 2 )
    {
      if ( dword_140035180 & 0x40000000 )
        sub_140007A38((__int64)L"Registry key filter is terminating process 0x%x", (unsigned int)v6);
      v9 = (__int64)v7;
      v7 = 0i64;
      sub_14000BC20(v9);
    }
    sub_14000BBE4(v7);
    result = 3221225506i64;
  }
  else
  {
    sub_14000BBE4(v7);
    result = 0i64;
  }
  return result;
}
// 14000BDA0: using guessed type __int64 __fastcall sub_14000BDA0(_QWORD);
// 140023B20: using guessed type wchar_t aCreatekeyCould[39];
// 140023B70: using guessed type wchar_t aNtcreatekeyBlo[65];
// 140023C00: using guessed type wchar_t aRegistryKeyFil[48];
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 140035180: using guessed type int dword_140035180;

//----- (000000014000C25C) ----------------------------------------------------
__int64 __fastcall sub_14000C25C(__int64 a1, unsigned int a2)
{
  unsigned int v2; // er14
  __int64 v3; // rdi
  __int64 v4; // rbp
  struct _SLIST_ENTRY *v5; // rbx
  unsigned __int16 *v6; // r15
  unsigned int v7; // esi
  int v8; // er14
  __int64 v9; // rcx
  char v11; // [rsp+20h] [rbp-38h]
  unsigned __int16 *v12[5]; // [rsp+30h] [rbp-28h]

  v2 = a2;
  v3 = a1;
  v4 = PsGetCurrentProcessId(a1);
  v5 = (struct _SLIST_ENTRY *)sub_14000BBB4(v4);
  sub_14000B190((__int64)&v11, v3);
  v6 = v12[0];
  v7 = 0;
  if ( v12[0] )
  {
    v8 = sub_14000BDA8(0i64, v12[0], 0, v2);
    if ( v8 )
    {
      if ( dword_140035180 & 0x40000000 )
        sub_140007A38(
          (__int64)L"NtDeleteKey: Blocking attempt by process 0x%x to access protected key \"%Z\"",
          (unsigned int)v4,
          v6);
      if ( v8 == 2 )
      {
        if ( dword_140035180 & 0x40000000 )
          sub_140007A38((__int64)L"Registry key filter is terminating process 0x%x", (unsigned int)v4);
        v9 = (__int64)v5;
        v5 = 0i64;
        sub_14000BC20(v9);
      }
      v7 = -1073741790;
    }
  }
  else if ( dword_140035180 & 0x40000000 )
  {
    sub_140007A38((__int64)L"NtDeleteKey: Could not get key name");
  }
  sub_14000B0FC((__int64)&v11);
  sub_14000BBE4(v5);
  return v7;
}
// 140023C00: using guessed type wchar_t aRegistryKeyFil[48];
// 140023C60: using guessed type wchar_t aNtdeletekeyCou[36];
// 140023CB0: using guessed type wchar_t aNtdeletekeyBlo[75];
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 140035180: using guessed type int dword_140035180;

//----- (000000014000C358) ----------------------------------------------------
__int64 __usercall sub_14000C358@<rax>(unsigned __int16 *a1@<rdx>, unsigned __int16 *a2@<rcx>, unsigned int a3@<r8d>, unsigned int a4@<r9d>, __int64 a5, int a6)
{
  unsigned int v6; // er15
  unsigned __int16 *v7; // rdi
  unsigned __int16 *v8; // r14
  unsigned int v9; // er12
  __int64 v10; // rcx
  unsigned int v11; // er13
  __m128i *v12; // rbx
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __m128i *v16; // rsi
  _WORD *v17; // rsi
  unsigned __int64 v18; // rcx
  int v19; // eax
  __int64 v20; // rcx
  int v21; // ebx
  __int64 v22; // rax
  unsigned int v24; // [rsp+40h] [rbp-58h]
  __m128i *v25; // [rsp+50h] [rbp-48h]
  int v26; // [rsp+58h] [rbp-40h]
  char v27; // [rsp+5Ch] [rbp-3Ch]
  signed int v28; // [rsp+A0h] [rbp+8h]
  unsigned int v29; // [rsp+B0h] [rbp+18h]

  v29 = a3;
  v6 = a4;
  v7 = a1;
  v8 = a2;
  v24 = 0;
  v9 = a4 + ((*a2 + 41 + *a1) & 0xFFFFFFFC);
  v25 = 0i64;
  v26 = 0;
  v27 = 0;
  sub_14000B028((__int64)&v25, v9 + 8);
  if ( v25 )
  {
    v11 = PsGetCurrentProcessId(v10);
    v12 = v25;
    HIDWORD(v25->m128i_i64[0]) = v11;
    LODWORD(v12->m128i_i64[0]) = 0;
    v12[1].m128i_i32[1] = PsGetCurrentThreadId(v14, v13, v15);
    v12[1].m128i_i64[1] = MEMORY[0xFFFFF78000000014];
    LODWORD(v12->m128i_i64[1]) = 32;
    sub_140021A80(v12 + 2, *((_QWORD *)v8 + 1), *v8);
    v16 = (__m128i *)((char *)v12 + *v8 + 32);
    LODWORD(v16->m128i_i64[0]) = 92;
    v16 = (__m128i *)((char *)v16 + 4);
    HIDWORD(v12->m128i_i64[1]) = (_DWORD)v16 - (_DWORD)v12;
    sub_140021A80(v16, *((_QWORD *)v7 + 1), *v7);
    v17 = (_WORD *)((char *)v16->m128i_i64 + *v7);
    *v17 = 0;
    v18 = ((unsigned __int64)v17 + 5) & 0xFFFFFFFFFFFFFFFCui64;
    v12[1].m128i_i32[0] = (((_DWORD)v17 + 5) & 0xFFFFFFFC) - (_DWORD)v12;
    *(_QWORD *)v18 = __PAIR__(v6, v29);
    sub_140021A80((__m128i *)(v18 + 8), a5, v6);
    if ( dword_140035180 & 0x20000000 )
      sub_140007A38(
        (__int64)L"NtSetValueKey: PID=0x%x ThreadId=0x%x key_name=\"%Z\" value_name=\"%Z\"",
        v11,
        v12[1].m128i_u32[1],
        v8,
        v7);
    v19 = sub_140019B6C(a6, (unsigned __int64)v12, v9 + 8);
    v21 = v19;
    if ( v19 == -1073741536 || v19 == -1073741248 )
    {
      sub_14000B0FC((__int64)&v25);
      return 0i64;
    }
    if ( v19 < 0 || v19 == 258 )
    {
      v22 = PsGetCurrentProcessId(v20);
      sub_140005F58(0x200ui64, 0xC4ui64, 0xE03D0234, v21, (__int64)v8, v22, (__int64)v7);
    }
    else if ( v28 <= 2 )
    {
      v24 = v28;
    }
  }
  sub_14000B0FC((__int64)&v25);
  return v24;
}
// 140023D50: using guessed type wchar_t aNtsetvaluekeyP[68];
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 1400284E8: using guessed type __int64 __fastcall PsGetCurrentThreadId(_QWORD, _QWORD, _QWORD);
// 140035180: using guessed type int dword_140035180;

//----- (000000014000C598) ----------------------------------------------------
signed __int64 __fastcall sub_14000C598(__int64 a1, unsigned __int16 *a2, __int64 a3, unsigned int a4, void *Address, unsigned int Length, int a7)
{
  unsigned int v7; // er12
  unsigned __int16 *v8; // r15
  __int64 v9; // rsi
  __int64 v10; // r14
  struct _SLIST_ENTRY *v11; // rbx
  int v12; // edi
  unsigned __int16 *v13; // rsi
  __int64 v14; // rcx
  signed __int64 result; // rax
  char v16; // [rsp+40h] [rbp-38h]
  unsigned __int16 *v17[2]; // [rsp+50h] [rbp-28h]

  v7 = a4;
  v8 = a2;
  v9 = a1;
  v10 = PsGetCurrentProcessId(a1);
  v11 = (struct _SLIST_ENTRY *)sub_14000BBB4(v10);
  v12 = 0;
  if ( !sub_140009260() )
    ProbeForRead(Address, Length, 1u);
  sub_14000B190((__int64)&v16, v9);
  v13 = v17[0];
  if ( v17[0] )
  {
    v12 = sub_14000C358(v8, v17[0], v7, Length, (__int64)Address, a7);
    if ( v12 && dword_140035180 & 0x20000000 )
      sub_140007A38(
        (__int64)L"NtSetValueKey: Blocking attempt by process 0x%x to access key \"%Z\"",
        (unsigned int)v10,
        v13);
  }
  else if ( dword_140035180 & 0x20000000 )
  {
    sub_140007A38((__int64)L"NtSetValueKey: Could not get key name");
  }
  sub_14000BDA0(&v16);
  if ( v12 )
  {
    if ( v12 == 2 )
    {
      if ( dword_140035180 & 0x20000000 )
        sub_140007A38((__int64)L"Registry value filter is terminating process 0x%x", (unsigned int)v10);
      v14 = (__int64)v11;
      v11 = 0i64;
      sub_14000BC20(v14);
    }
    sub_14000BBE4(v11);
    result = 3221225506i64;
  }
  else
  {
    sub_14000BBE4(v11);
    result = 0i64;
  }
  return result;
}
// 14000BDA0: using guessed type __int64 __fastcall sub_14000BDA0(_QWORD);
// 140023F60: using guessed type wchar_t aNtsetvaluekeyC[38];
// 140023FB0: using guessed type wchar_t aNtsetvaluekeyB[67];
// 140024140: using guessed type wchar_t aRegistryValueF[50];
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 140035180: using guessed type int dword_140035180;

//----- (000000014000C794) ----------------------------------------------------
__int64 __fastcall sub_14000C794(__int64 a1, __int64 a2, int a3)
{
  PVOID *v3; // rdi
  __int64 v4; // rbx
  signed int v5; // eax
  __int64 v6; // rcx
  __int64 v7; // rdi
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]

  *(_QWORD *)a1 = 0i64;
  v3 = (PVOID *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = 0i64;
  v4 = a1;
  *(_DWORD *)(a1 + 8) = 5;
  if ( a3 == -2019347449 )
  {
    *(_DWORD *)(a1 + 12) = *(_DWORD *)a2;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)a2;
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 8);
    *(_WORD *)(a1 + 28) = *(_WORD *)(a2 + 12);
    v6 = 0i64;
LABEL_6:
    v5 = sub_140007050(v6, v3);
    if ( v5 >= 0 )
      goto LABEL_8;
    goto LABEL_7;
  }
  if ( a3 == -2019347433 )
  {
    *(_DWORD *)(a1 + 12) = *(_DWORD *)a2;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)a2;
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 8);
    *(_WORD *)(a1 + 28) = *(_WORD *)(a2 + 12);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 39);
    v6 = *(_QWORD *)(a2 + 14);
    goto LABEL_6;
  }
  v5 = -1073741808;
LABEL_7:
  LODWORD(BugCheckParameter3) = v5;
  sub_140006BB4(0x21Cui64, 0x7Cui64, 0i64, 0xE03D02F0, BugCheckParameter3, 0);
  *v3 = 0i64;
LABEL_8:
  v7 = sub_14000BBB4(*(unsigned int *)(v4 + 12));
  if ( *(_QWORD *)v4 != v7 )
  {
    sub_14000BBE4(*(struct _SLIST_ENTRY **)v4);
    *(_QWORD *)v4 = v7;
  }
  return v4;
}

//----- (000000014000C870) ----------------------------------------------------
__int64 sub_14000C870()
{
  __int64 result; // rax

  ++stru_140036BC0.L.TotalAllocates;
  result = (__int64)ExpInterlockedPopEntrySList(&stru_140036BC0.L.ListHead);
  if ( !result )
  {
    ++stru_140036BC0.L.AllocateMisses;
    result = sub_140021A40((__int64 (*)(void))stru_140036BC0.L.Allocate);
  }
  return result;
}

//----- (000000014000C8C0) ----------------------------------------------------
void __fastcall sub_14000C8C0(PSLIST_ENTRY ListEntry)
{
  struct _SLIST_ENTRY *v1; // rbx

  if ( ListEntry )
  {
    ++stru_140036BC0.L.TotalFrees;
    v1 = ListEntry;
    if ( ExQueryDepthSList(&stru_140036BC0.L.ListHead) < stru_140036BC0.L.Depth )
    {
      ExpInterlockedPushEntrySList(&stru_140036BC0.L.ListHead, v1);
    }
    else
    {
      ++stru_140036BC0.L.FreeMisses;
      sub_140021A40((__int64 (*)(void))stru_140036BC0.L.Free);
    }
  }
}

//----- (000000014000C924) ----------------------------------------------------
__int64 sub_14000C924()
{
  byte_140036C40 = 1;
  return 0i64;
}
// 140036C40: using guessed type char byte_140036C40;

//----- (000000014000C930) ----------------------------------------------------
void sub_14000C930()
{
  byte_140036C40 = 0;
}
// 140036C40: using guessed type char byte_140036C40;

//----- (000000014000C938) ----------------------------------------------------
void __fastcall sub_14000C938(__int64 a1, _DWORD *a2)
{
  _DWORD *v2; // rbp
  __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rdx
  unsigned int *v6; // rsi
  __int64 v7; // rbx
  __int64 v8; // rax
  struct _SLIST_ENTRY *v9; // rbx
  PSLIST_ENTRY v10; // rcx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]

  *(_QWORD *)(a1 + 56) = 0i64;
  v2 = a2;
  v3 = a1;
  if ( a2[2] || *(_QWORD *)(a1 + 112) )
  {
    if ( dword_140035180 & 0x400000 )
      sub_140007A38((__int64)L"IPConnect filter called with an output buffer");
    *(_DWORD *)(v3 + 48) = -1073741811;
  }
  else
  {
    v4 = (unsigned int)a2[6];
    v5 = (unsigned int)a2[4];
    if ( ((_DWORD)v4 != -2019347449 || (_DWORD)v5 != 14) && ((_DWORD)v4 != -2019347433 || (_DWORD)v5 != 55) )
    {
      if ( dword_140035180 & 0x400000 )
        sub_140007A38((__int64)L"IPConnect filter called with an invalid buffer size (%d bytes)", v5, 2275619863i64);
      *(_DWORD *)(v3 + 48) = -1073741306;
    }
    else
    {
      v6 = (unsigned int *)*((_QWORD *)v2 + 4);
      if ( (unsigned __int64)v6 < MmSystemRangeStart )
      {
        if ( dword_140035180 & 0x400000 )
          sub_140007A38(
            (__int64)L"IPConnect filter called with an invalid input buffer address (0x%p)",
            *((_QWORD *)v2 + 4),
            2275619863i64);
        *(_DWORD *)(v3 + 48) = -1073741819;
        return;
      }
      if ( (_DWORD)v4 == -2019347449 )
      {
        v7 = *v6;
        if ( v7 != PsGetCurrentProcessId(v4) )
        {
          if ( dword_140035180 & 0x400000 )
            sub_140007A38((__int64)L"IPConnect filter: The process doing IPConnect is not current");
          *(_DWORD *)(v3 + 48) = -1073741526;
          return;
        }
      }
      else if ( (_DWORD)v4 == -2019347433 && *((_BYTE *)v6 + 22) )
      {
        goto LABEL_14;
      }
      if ( !byte_140036C40 )
        goto LABEL_14;
      v8 = sub_14000C870();
      if ( v8 )
        v9 = (struct _SLIST_ENTRY *)sub_14000C794(v8, (__int64)v6, v2[6]);
      else
        v9 = 0i64;
      if ( !v9 )
      {
        LODWORD(BugCheckParameter3) = -1073741670;
        sub_140006BB4(0x21Cui64, 0x1A3ui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
        *(_DWORD *)(v3 + 48) = -1073741670;
        return;
      }
      if ( sub_14000A018((__int64)sub_14000CB40, (__int64)v9) )
      {
LABEL_14:
        *(_DWORD *)(v3 + 48) = 0;
        return;
      }
      LODWORD(BugCheckParameter3) = -1073741823;
      sub_140006BB4(0x21Cui64, 0x1C1ui64, 0i64, 0xE03D0240, BugCheckParameter3, 0);
      v10 = v9[2].Next;
      if ( v10 )
        ObfDereferenceObject(v10);
      sub_14000BBE4(v9->Next);
      sub_14000C8C0(v9);
      *(_DWORD *)(v3 + 48) = -1073741823;
    }
  }
}
// 140024270: using guessed type wchar_t aIpconnectFilte_2[46];
// 1400242D0: using guessed type wchar_t aIpconnectFilte_0[63];
// 140024350: using guessed type wchar_t aIpconnectFilte[68];
// 1400243E0: using guessed type wchar_t aIpconnectFilte_1[61];
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 140035180: using guessed type int dword_140035180;
// 140036C40: using guessed type char byte_140036C40;

//----- (000000014000CB40) ----------------------------------------------------
void __fastcall sub_14000CB40(PSLIST_ENTRY ListEntry)
{
  unsigned int v1; // esi
  int v2; // edi
  PSLIST_ENTRY v3; // rbx
  int v4; // eax
  struct _SLIST_ENTRY *v5; // rcx
  PSLIST_ENTRY v6; // rcx
  int *BugCheckParameter3; // [rsp+20h] [rbp-18h]
  int v8; // [rsp+40h] [rbp+8h]

  v1 = *((_DWORD *)&ListEntry->Next + 3);
  v2 = 0;
  v3 = ListEntry;
  if ( dword_140035180 & 0x400000 )
    sub_140007A38((__int64)L"IPConnect filter-worker called for PID 0x%x", v1);
  BugCheckParameter3 = &v8;
  v4 = sub_140019D34((unsigned int)dword_14002B140, (unsigned __int64)(&v3->Next + 1), 0x18u, (__int64)v3[2].Next);
  if ( v4 != -1073741536 && v4 != -1073741248 )
  {
    if ( v4 < 0 || v4 == 258 )
    {
      LODWORD(BugCheckParameter3) = v4;
      sub_140006BB4(0x21Cui64, 0xCCui64, 0i64, 0xE03D0241, (ULONG_PTR)BugCheckParameter3, 0);
    }
    else
    {
      v2 = v8;
      if ( v8 > 2 )
        goto LABEL_14;
    }
    if ( v2 == 2 )
    {
      if ( dword_140035180 & 0x400000 )
        sub_140007A38((__int64)L"IPConnect filter is terminating process 0x%x", v1);
      v5 = v3->Next;
      v3->Next = 0i64;
      sub_14000BC90((__int64)v5);
    }
  }
LABEL_14:
  v6 = v3[2].Next;
  if ( v6 )
    ObfDereferenceObject(v6);
  sub_14000BBE4(v3->Next);
  sub_14000C8C0(v3);
}
// 1400241B0: using guessed type wchar_t aIpconnectFilte_3[44];
// 140024210: using guessed type wchar_t aIpconnectFilte_4[45];
// 14002B140: using guessed type int dword_14002B140;
// 140035180: using guessed type int dword_140035180;

//----- (000000014000CC3C) ----------------------------------------------------
__int64 __fastcall sub_14000CC3C(__int64 a1, __int64 a2)
{
  _DWORD *v2; // rcx
  struct _IRP *v3; // rbx
  unsigned int v4; // edi

  v2 = *(_DWORD **)(a2 + 184);
  v3 = (struct _IRP *)a2;
  if ( (v2[6] + 2019347449) & 0xFFFFFFEF )
  {
    if ( dword_140035180 & 0x400000 )
      sub_140007A38((__int64)L"IPConnect filter called with an unknown IOCTL code (0x%X)");
    v3->IoStatus.Information = 0i64;
    v4 = -1073741808;
    v3->IoStatus.Status = -1073741808;
  }
  else
  {
    sub_14000C938(a2, v2);
    v4 = v3->IoStatus.Status;
  }
  IofCompleteRequest(v3, 0);
  return v4;
}
// 140024460: using guessed type wchar_t aIpconnectFilte_5[58];
// 140035180: using guessed type int dword_140035180;

//----- (000000014000CCB4) ----------------------------------------------------
char __fastcall sub_14000CCB4(__int64 a1, __int64 a2, _BYTE *a3)
{
  signed __int64 v3; // rbx
  __int64 v4; // rdi
  _BYTE *v5; // r14
  __int64 v6; // rsi
  _QWORD *v7; // rdx
  char v8; // di
  _QWORD *i; // rcx
  _BYTE *v10; // rdx

  v3 = a1 + 4128;
  v4 = a1;
  v5 = a3;
  v6 = a2;
  FltAcquirePushLockShared(a1 + 4128);
  v7 = (_QWORD *)(v4 + 16i64 * ((unsigned int)v6 % 0x101));
  v8 = 0;
  for ( i = (_QWORD *)*v7; i != v7; i = (_QWORD *)*i )
  {
    if ( i[4] == v6 )
      goto LABEL_6;
  }
  i = 0i64;
LABEL_6:
  v10 = (_BYTE *)((unsigned __int64)(i + 5) & -(signed __int64)(i != 0i64));
  if ( v10 )
  {
    v8 = 1;
    *v5 = *v10;
  }
  FltReleasePushLock(v3);
  return v8;
}
// 14002151A: using guessed type __int64 __fastcall FltAcquirePushLockShared(_QWORD);
// 140021526: using guessed type __int64 __fastcall FltReleasePushLock(_QWORD);

//----- (000000014000CD4C) ----------------------------------------------------
void __fastcall sub_14000CD4C(PSLIST_ENTRY ListEntry)
{
  struct _SLIST_ENTRY *v1; // rbx

  if ( ListEntry )
  {
    ++stru_140037C80.L.TotalFrees;
    v1 = ListEntry;
    if ( ExQueryDepthSList(&stru_140037C80.L.ListHead) < stru_140037C80.L.Depth )
    {
      ExpInterlockedPushEntrySList(&stru_140037C80.L.ListHead, v1);
    }
    else
    {
      ++stru_140037C80.L.FreeMisses;
      sub_140021A40((__int64 (*)(void))stru_140037C80.L.Free);
    }
  }
}

//----- (000000014000CDB0) ----------------------------------------------------
__int64 __fastcall sub_14000CDB0(struct _SLIST_ENTRY **a1)
{
  signed __int64 v1; // rbx
  struct _SLIST_ENTRY **v2; // rdi

  v1 = (signed __int64)(a1 + 516);
  v2 = a1;
  FltAcquirePushLockExclusive(a1 + 516);
  sub_14000CDE8(v2);
  return FltReleasePushLock(v1);
}
// 14002150E: using guessed type __int64 __fastcall FltAcquirePushLockExclusive(_QWORD);
// 140021526: using guessed type __int64 __fastcall FltReleasePushLock(_QWORD);

//----- (000000014000CDE8) ----------------------------------------------------
_QWORD *__fastcall sub_14000CDE8(struct _SLIST_ENTRY **a1)
{
  struct _SLIST_ENTRY **v1; // rsi
  unsigned int v2; // edi
  struct _SLIST_ENTRY **v3; // rbx
  PSLIST_ENTRY v4; // rcx
  struct _SLIST_ENTRY *v5; // rax
  _QWORD *result; // rax

  v1 = a1;
  v2 = 0;
  v3 = a1;
  do
  {
    while ( 1 )
    {
      v5 = *v3;
      if ( *v3 == (struct _SLIST_ENTRY *)v3 )
        break;
      if ( *((struct _SLIST_ENTRY ***)&v5->Next + 1) != v3 || (v4 = v5->Next, *(&v5->Next->Next + 1) != v5) )
        __fastfail(3u);
      *v3 = v4;
      *((_QWORD *)&v4->Next + 1) = v3;
      sub_14000CD4C(v5);
    }
    ++v2;
    v3 += 2;
  }
  while ( v2 < 0x101 );
  result = v1 + 514;
  result[1] = result;
  *result = result;
  return result;
}

//----- (000000014000CE5C) ----------------------------------------------------
__int64 __fastcall sub_14000CE5C(__int64 a1, __int64 a2, _BYTE *a3)
{
  signed __int64 v3; // rbx
  __int64 v4; // rsi
  _BYTE *v5; // rdi
  __int64 v7; // [rsp+38h] [rbp+10h]

  v7 = a2;
  v3 = a1 + 4128;
  v4 = a1;
  v5 = a3;
  FltAcquirePushLockExclusive(a1 + 4128);
  LODWORD(v5) = sub_14000D0CC(v4, &v7, v5, 0i64);
  FltReleasePushLock(v3);
  return (unsigned int)v5;
}
// 14002150E: using guessed type __int64 __fastcall FltAcquirePushLockExclusive(_QWORD);
// 140021526: using guessed type __int64 __fastcall FltReleasePushLock(_QWORD);

//----- (000000014000CEC0) ----------------------------------------------------
void __fastcall sub_14000CEC0(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rsi
  __int64 v6; // rax
  struct _SLIST_ENTRY *v7; // rbx
  signed int v8; // eax
  __int64 v9; // rcx

  v3 = a1;
  if ( byte_140037C78 )
  {
    if ( a3 )
    {
      if ( ExGetPreviousMode() == 1 )
      {
        v5 = PsGetCurrentProcessId(v4);
        v6 = PsGetProcessId(PsInitialSystemProcess);
        if ( v5 != v3 && v5 != v6 && sub_14000D29C(v3) )
        {
          v7 = (struct _SLIST_ENTRY *)sub_14000BBB4(v5);
          v8 = sub_14000D340(v5, v3);
          if ( v8 >= 0 )
          {
            if ( v8 <= 1 )
            {
LABEL_15:
              sub_14000BBE4(v7);
              return;
            }
            if ( v8 == 2 )
            {
              if ( dword_140035180 & 0x200000 )
                sub_140007A38((__int64)L"CreateRemoteThreadEvent: Terminating process 0x%x", v3);
              v9 = (__int64)v7;
              v7 = 0i64;
              sub_14000BC20(v9);
              goto LABEL_15;
            }
          }
          if ( dword_140035180 & 0x200000 )
            sub_140007A38((__int64)L"Unknown action %d returned to CreateThreadNotifyRoutine", (unsigned int)v8);
          goto LABEL_15;
        }
      }
    }
  }
}
// 1400245F0: using guessed type wchar_t aCreateremoteth[50];
// 140024660: using guessed type wchar_t aUnknownActionD_0[56];
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 140028500: using guessed type __int64 __fastcall PsGetProcessId(_QWORD);
// 140035180: using guessed type int dword_140035180;
// 140037C78: using guessed type char byte_140037C78;

//----- (000000014000CFB4) ----------------------------------------------------
__int64 __fastcall sub_14000CFB4(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 v5; // [rsp+38h] [rbp+10h]

  v5 = a2;
  v2 = a1 + 4128;
  v3 = a1;
  FltAcquirePushLockExclusive(a1 + 4128);
  sub_14000CFF4(v3, (PSLIST_ENTRY *)&v5);
  return FltReleasePushLock(v2);
}
// 14002150E: using guessed type __int64 __fastcall FltAcquirePushLockExclusive(_QWORD);
// 140021526: using guessed type __int64 __fastcall FltReleasePushLock(_QWORD);

//----- (000000014000CFF4) ----------------------------------------------------
void __fastcall sub_14000CFF4(__int64 a1, PSLIST_ENTRY *a2)
{
  struct _SLIST_ENTRY **v2; // r8
  struct _SLIST_ENTRY *v3; // rcx
  PSLIST_ENTRY v4; // rdx
  struct _SLIST_ENTRY **v5; // r8
  PSLIST_ENTRY v6; // rdx
  struct _SLIST_ENTRY **v7; // rax

  v2 = (struct _SLIST_ENTRY **)(a1 + 16i64 * (*(_DWORD *)a2 % 0x101u));
  v3 = *v2;
  if ( *v2 == (struct _SLIST_ENTRY *)v2 )
  {
LABEL_4:
    v3 = 0i64;
  }
  else
  {
    while ( v3[2].Next != *a2 )
    {
      v3 = v3->Next;
      if ( v3 == (struct _SLIST_ENTRY *)v2 )
        goto LABEL_4;
    }
  }
  if ( v3 )
  {
    v4 = v3[1].Next;
    if ( *(&v4->Next + 1) != &v3[1]
      || (v5 = (struct _SLIST_ENTRY **)*((_QWORD *)&v3[1].Next + 1), *v5 != &v3[1])
      || (*v5 = v4, *((_QWORD *)&v4->Next + 1) = v5, v6 = v3->Next, *(&v3->Next->Next + 1) != v3)
      || (v7 = (struct _SLIST_ENTRY **)*((_QWORD *)&v3->Next + 1), *v7 != v3) )
    {
      __fastfail(3u);
    }
    *v7 = v6;
    *((_QWORD *)&v6->Next + 1) = v7;
    sub_14000CD4C(v3);
  }
}

//----- (000000014000D080) ----------------------------------------------------
int __fastcall sub_14000D080(__int64 a1, __int64 a2, __int64 a3)
{
  int result; // eax
  char v4; // [rsp+40h] [rbp+18h]

  if ( !a3 )
    return sub_14000CFB4((__int64)&unk_140036C50, a2);
  v4 = 1;
  result = sub_14000CE5C((__int64)&unk_140036C50, a2, &v4);
  if ( result )
  {
    if ( dword_140035180 & 0x200000 )
      result = sub_140007A38((__int64)L"Unable to create or update process record.");
  }
  return result;
}
// 140024590: using guessed type wchar_t aUnableToCreate[43];
// 140035180: using guessed type int dword_140035180;

//----- (000000014000D0CC) ----------------------------------------------------
signed __int64 __fastcall sub_14000D0CC(__int64 a1, _DWORD *a2, _BYTE *a3, signed __int64 *a4)
{
  _QWORD *v4; // rsi
  signed __int64 *v5; // rdi
  _BYTE *v6; // r14
  __int64 v7; // rbp
  _QWORD *v8; // rbx
  _QWORD *v9; // rax
  __int64 v10; // rcx
  signed __int64 v12; // rdx
  __int64 *v13; // rax
  _QWORD *v14; // rcx
  _QWORD *v15; // r8

  v4 = a2;
  v5 = a4;
  v6 = a3;
  v7 = a1;
  v8 = (_QWORD *)(a1 + 16i64 * (*a2 % 0x101u));
  v9 = (_QWORD *)*v8;
  if ( (_QWORD *)*v8 == v8 )
  {
LABEL_4:
    v9 = 0i64;
  }
  else
  {
    while ( v9[4] != *(_QWORD *)a2 )
    {
      v9 = (_QWORD *)*v9;
      if ( v9 == v8 )
        goto LABEL_4;
    }
  }
  if ( v9 )
  {
    v12 = (signed __int64)(v9 + 5);
    *((_BYTE *)v9 + 40) = *a3;
  }
  else
  {
    ++stru_140037C80.L.TotalAllocates;
    v10 = (__int64)ExpInterlockedPopEntrySList(&stru_140037C80.L.ListHead);
    if ( !v10 )
    {
      ++stru_140037C80.L.AllocateMisses;
      v10 = sub_140021A40((__int64 (*)(void))stru_140037C80.L.Allocate);
    }
    if ( !v10 )
      return 3221225626i64;
    v12 = v10 + 40;
    *(_QWORD *)(v10 + 32) = *v4;
    *(_BYTE *)(v10 + 40) = *v6;
    v13 = (__int64 *)v8[1];
    if ( (_QWORD *)*v13 != v8
      || (*(_QWORD *)(v10 + 8) = v13,
          *(_QWORD *)v10 = v8,
          *v13 = v10,
          v8[1] = v10,
          v14 = (_QWORD *)(v10 + 16),
          v15 = *(_QWORD **)(v7 + 4120),
          *v15 != v7 + 4112) )
    {
      __fastfail(3u);
    }
    *v14 = v7 + 4112;
    v14[1] = v15;
    *v15 = v14;
    *(_QWORD *)(v7 + 4120) = v14;
  }
  if ( v5 )
    *v5 = v12;
  return 0i64;
}

//----- (000000014000D20C) ----------------------------------------------------
__int64 sub_14000D20C()
{
  __int64 result; // rax

  result = 0i64;
  if ( !byte_140037C78 )
  {
    result = sub_14000ABA0(3, (__int64)sub_14000D080);
    if ( (signed int)result >= 0 )
    {
      result = sub_14000E308(1, (__int64)sub_14000CEC0);
      byte_140037C79 = (signed int)result >= 0;
      byte_140037C78 = (signed int)result >= 0;
    }
  }
  return result;
}
// 140037C78: using guessed type char byte_140037C78;
// 140037C79: using guessed type char byte_140037C79;

//----- (000000014000D254) ----------------------------------------------------
__int64 __fastcall sub_14000D254(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = 0i64;
  if ( byte_140037C78 )
  {
    byte_140037C78 = 0;
    if ( byte_140037C79 )
    {
      byte_140037C79 = 0;
      sub_14000E410(1);
    }
    sub_14000AC40(3, a2);
    result = sub_14000CDB0((struct _SLIST_ENTRY **)&unk_140036C50);
  }
  return result;
}
// 140037C78: using guessed type char byte_140037C78;
// 140037C79: using guessed type char byte_140037C79;

//----- (000000014000D29C) ----------------------------------------------------
char __fastcall sub_14000D29C(__int64 a1)
{
  __int64 v1; // rbx
  int v2; // eax
  char v4; // [rsp+38h] [rbp+10h]

  v1 = a1;
  v4 = 0;
  if ( sub_14000CCB4((__int64)&unk_140036C50, a1, &v4) )
  {
    if ( v4 )
    {
      v4 = 0;
      if ( (unsigned int)sub_14000CE5C((__int64)&unk_140036C50, v1, &v4) )
      {
LABEL_6:
        v2 = dword_140035180;
        if ( _bittest(&v2, 0x15u) )
          sub_140007A38((__int64)L"Unable to create or update process record.");
      }
      return 0;
    }
  }
  else
  {
    v4 = 0;
    if ( (unsigned int)sub_14000CE5C((__int64)&unk_140036C50, v1, &v4) )
      goto LABEL_6;
  }
  if ( IoGetCurrentProcess() == (PEPROCESS)qword_1400369C8 )
    return 0;
  return 1;
}
// 140024590: using guessed type wchar_t aUnableToCreate[43];
// 140035180: using guessed type int dword_140035180;
// 1400369C8: using guessed type __int64 qword_1400369C8;

//----- (000000014000D340) ----------------------------------------------------
__int64 __fastcall sub_14000D340(int a1, int a2)
{
  int v2; // ebp
  int v3; // er14
  signed int v4; // edi
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // r8
  unsigned __int64 v8; // rsi
  signed int v9; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-38h]
  _DWORD *v12; // [rsp+30h] [rbp-28h]
  unsigned int v13; // [rsp+38h] [rbp-20h]
  char v14; // [rsp+3Ch] [rbp-1Ch]

  v2 = a2;
  v3 = a1;
  v12 = 0i64;
  v13 = 0;
  v4 = -1073741823;
  v14 = 0;
  sub_14000B028((__int64)&v12, 0x18u);
  v8 = (unsigned __int64)v12;
  if ( !v12 )
    goto LABEL_12;
  *v12 = 4;
  *(_DWORD *)(v8 + 4) = v3;
  *(_DWORD *)(v8 + 8) = v2;
  *(_DWORD *)(v8 + 12) = PsGetCurrentThreadId(v6, v5, v7);
  *(_QWORD *)(v8 + 16) = MEMORY[0xFFFFF78000000014];
  if ( dword_140035180 & 0x200000 )
    sub_140007A38(
      (__int64)L"CreateRemoteThreadEvent: Reporting process 0x%x (thread 0x%x) targetting process 0x%x",
      *(unsigned int *)(v8 + 4),
      *(unsigned int *)(v8 + 12),
      *(unsigned int *)(v8 + 8));
  v9 = sub_140019B6C(dword_14002B140, v8, v13);
  v4 = v9;
  if ( v9 != -1073741536 && v9 != -1073741248 && (v9 < 0 || v9 == 258) )
  {
LABEL_12:
    LODWORD(BugCheckParameter3) = v4;
    sub_140006BB4(0x20Eui64, 0x9Bui64, 0i64, 0xE03D0250, BugCheckParameter3, 0);
  }
  sub_14000B0FC((__int64)&v12);
  return 0i64;
}
// 1400244E0: using guessed type wchar_t aCreateremoteth_0[86];
// 1400284E8: using guessed type __int64 __fastcall PsGetCurrentThreadId(_QWORD, _QWORD, _QWORD);
// 14002B140: using guessed type int dword_14002B140;
// 140035180: using guessed type int dword_140035180;

//----- (000000014000D454) ----------------------------------------------------
NTSTATUS __fastcall sub_14000D454(ULONG IoControlCode, PDEVICE_OBJECT DeviceObject, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength)
{
  PVOID v6; // rdi
  struct _DEVICE_OBJECT *v7; // rbp
  ULONG v8; // esi
  ULONG v9; // ebx
  struct _IRP *v10; // rax
  NTSTATUS result; // eax
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+50h] [rbp-38h]
  struct _KEVENT Object; // [rsp+60h] [rbp-28h]

  v6 = InputBuffer;
  v7 = DeviceObject;
  IoStatusBlock.Pointer = 0i64;
  v8 = IoControlCode;
  IoStatusBlock.Information = 0i64;
  v9 = InputBufferLength;
  KeInitializeEvent(&Object, 0, 0);
  v10 = IoBuildDeviceIoControlRequest(v8, v7, v6, v9, OutputBuffer, OutputBufferLength, 1u, &Object, &IoStatusBlock);
  if ( !v10 )
    return -1073741670;
  result = IofCallDriver(v7, v10);
  if ( result == 259 )
  {
    KeWaitForSingleObject(&Object, 0, 0, 0, 0i64);
    result = IoStatusBlock.Status;
  }
  return result;
}

//----- (000000014000D540) ----------------------------------------------------
__int64 __usercall sub_14000D540@<rax>(ULONG IoControlCode@<ecx>, const WCHAR *a2@<rdx>, unsigned int a3@<r8d>, ULONG a4@<r9d>, PVOID InputBuffer, ULONG InputBufferLength, __int64 a7, PVOID a8, __int64 a9)
{
  ULONG v9; // er14
  ULONG v10; // esi
  unsigned int v11; // edi
  NTSTATUS v12; // eax
  PFILE_OBJECT v14; // rbx
  NTSTATUS v15; // eax
  unsigned int v16; // edi
  unsigned int v17; // [rsp+30h] [rbp-30h]
  PDEVICE_OBJECT DeviceObject; // [rsp+38h] [rbp-28h]
  PFILE_OBJECT FileObject; // [rsp+40h] [rbp-20h]
  UNICODE_STRING DestinationString; // [rsp+48h] [rbp-18h]

  FileObject = 0i64;
  v9 = IoControlCode;
  DeviceObject = 0i64;
  v10 = a4;
  v11 = a3;
  RtlInitUnicodeString(&DestinationString, a2);
  v12 = IoGetDeviceObjectPointer(&DestinationString, 0x1F01FFu, &FileObject, &DeviceObject);
  if ( v12 < 0 )
  {
    if ( v12 == -1073741772 )
      return 2i64;
    if ( a9 )
      *(_DWORD *)a9 = v12;
    return 1i64;
  }
  v14 = FileObject;
  if ( !v11 || !v10 )
    goto LABEL_24;
  v17 = 0;
  v15 = sub_14000D454(v10, DeviceObject, 0i64, 0, &v17, 4u);
  if ( v15 < 0 )
  {
    if ( v15 == -1073741808 )
      goto LABEL_13;
LABEL_15:
    if ( a9 )
      *(_DWORD *)a9 = v15;
    v16 = 1;
    goto LABEL_19;
  }
  if ( v17 >= v11 )
  {
LABEL_24:
    v15 = sub_14000D454(v9, DeviceObject, InputBuffer, InputBufferLength, (PVOID)a7, (ULONG)a8);
    if ( v15 >= 0 )
    {
      v16 = 0;
      goto LABEL_19;
    }
    goto LABEL_15;
  }
LABEL_13:
  v16 = 3;
LABEL_19:
  if ( v14 )
    ObfDereferenceObject(v14);
  return v16;
}

//----- (000000014000D680) ----------------------------------------------------
__int64 __fastcall sub_14000D680(HANDLE *a1, UNICODE_STRING *a2)
{
  HANDLE *v2; // rsi
  signed __int64 v3; // r8
  PWSTR v4; // rax
  WCHAR v5; // cx
  WCHAR v6; // cx
  WCHAR v7; // cx
  const UNICODE_STRING *v8; // rbx
  UNICODE_STRING v9; // xmm0
  WCHAR *v10; // rcx
  __int16 v11; // r8
  NTSTATUS v12; // ebx
  signed int v13; // edi
  ACCESS_MASK i; // edx
  PLARGE_INTEGER AllocationSize; // [rsp+20h] [rbp-59h]
  UNICODE_STRING DestinationString; // [rsp+60h] [rbp-19h]
  UNICODE_STRING Source; // [rsp+70h] [rbp-9h]
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+80h] [rbp+7h]
  OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+90h] [rbp+17h]
  HANDLE FileHandle; // [rsp+E8h] [rbp+6Fh]

  v2 = a1;
  v3 = 4i64;
  if ( a2->Length < 4u || (v4 = a2->Buffer, *v4 != 92) && *v4 != 47 || (v5 = v4[1], v5 != 92) && v5 != 47 )
  {
    v3 = 0i64;
  }
  else if ( a2->Length < 8u || (v6 = v4[2], v6 != 46) && v6 != 63 || (v7 = v4[3], v7 != 92) && v7 != 47 )
  {
    v3 = 2i64;
    v8 = &stru_140028BD0;
    goto LABEL_14;
  }
  v8 = (const UNICODE_STRING *)L"\b\b";
LABEL_14:
  v9 = *a2;
  DestinationString.Length = 0;
  Source = v9;
  v10 = (WCHAR *)(*(unsigned __int128 *)&_mm_srli_si128((__m128i)v9, 8) + 2 * v3);
  v11 = 2 * v3;
  Source.Buffer = v10;
  Source.MaximumLength -= v11;
  Source.Length = v9.Length - v11;
  DestinationString.MaximumLength = v8->Length + v9.Length - v11;
  DestinationString.Buffer = (PWSTR)ExAllocatePoolWithTag(PagedPool, DestinationString.MaximumLength, 0x6C734349u);
  if ( DestinationString.Buffer )
  {
    RtlCopyUnicodeString(&DestinationString, v8);
    RtlAppendUnicodeStringToString(&DestinationString, &Source);
    v13 = 1048577;
    for ( i = 1048577; ; i = 0 )
    {
      ObjectAttributes.Length = 48;
      ObjectAttributes.RootDirectory = 0i64;
      ObjectAttributes.Attributes = 576;
      ObjectAttributes.ObjectName = &DestinationString;
      _mm_storeu_si128((__m128i *)&ObjectAttributes.SecurityDescriptor, (__m128i)0i64);
      v12 = ZwCreateFile(&FileHandle, i, &ObjectAttributes, &IoStatusBlock, 0i64, 0x80u, 7u, 1u, 0x21u, 0i64, 0);
      if ( v12 != -1073741790 || !v13 )
        break;
      v13 = 0;
    }
    if ( v12 >= 0 )
    {
      v12 = 0;
      *v2 = FileHandle;
    }
    ExFreePoolWithTag(DestinationString.Buffer, 0);
  }
  else
  {
    v12 = -1073741670;
    LODWORD(AllocationSize) = -1073741670;
    sub_140006BB4(0x146ui64, 0x8Fui64, 0i64, 0xE03D000B, (ULONG_PTR)AllocationSize, 0);
  }
  return (unsigned int)v12;
}
// 140028BC0: using guessed type wchar_t asc_140028BC0[3];

//----- (000000014000D884) ----------------------------------------------------
signed __int64 __fastcall sub_14000D884(__int64 a1, __int64 a2, _QWORD *a3)
{
  unsigned int v3; // esi
  __int64 v4; // rbp
  _QWORD *v5; // r14
  __int64 v6; // r15
  SIZE_T v7; // rdx
  unsigned int v8; // edi
  PVOID v9; // rbx
  signed __int64 result; // rax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-68h]
  __int64 v12; // [rsp+30h] [rbp-58h]
  __int64 v13; // [rsp+38h] [rbp-50h]
  __int64 v14; // [rsp+40h] [rbp-48h]
  _QWORD v15[2]; // [rsp+50h] [rbp-38h]
  char v16; // [rsp+60h] [rbp-28h]

  v3 = 520;
  v4 = a2;
  v5 = a3;
  v6 = a1;
  v7 = 616i64;
  while ( 1 )
  {
    v9 = ExAllocatePoolWithTag(PagedPool, v7, 0x6C734349u);
    if ( !v9 )
    {
      LODWORD(BugCheckParameter3) = -1073741670;
      sub_140006BB4(0x146ui64, 0xE5ui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
      return 3221225626i64;
    }
    LOBYTE(v15[0]) = 1;
    LOBYTE(v14) = 1;
    LODWORD(v13) = 3;
    LODWORD(v12) = v3 + 96;
    v8 = ZwQueryDirectoryFile(v6, 0i64, 0i64, 0i64, &v16, v9, v12, v13, v14, v4, v15[0]);
    if ( v8 != -2147483643 )
      break;
    ExFreePoolWithTag(v9, 0);
    if ( 2 * v3 < v3 )
    {
      LODWORD(BugCheckParameter3) = -2147483643;
      sub_140006BB4(0x146ui64, 0xFFui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
      return 2147483653i64;
    }
    v7 = 2 * v3 + 96i64;
    v3 *= 2;
  }
  if ( v8 )
  {
    ExFreePoolWithTag(v9, 0);
    result = v8;
  }
  else
  {
    *v5 = v9;
    result = 0i64;
  }
  return result;
}
// 140028518: using guessed type __int64 __fastcall ZwQueryDirectoryFile(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014000D9D0) ----------------------------------------------------
char __fastcall sub_14000D9D0(PCUNICODE_STRING String1, WCHAR *a2)
{
  WCHAR *v2; // rsi
  PCUNICODE_STRING v3; // rdi
  unsigned __int64 v4; // rbx
  __int64 *v5; // rdi
  unsigned __int64 v6; // rbx
  WCHAR *v7; // rdx
  WCHAR v8; // ax
  unsigned __int64 v9; // rcx
  UNICODE_STRING String1a; // [rsp+20h] [rbp-28h]
  UNICODE_STRING String2; // [rsp+30h] [rbp-18h]
  __int64 v13; // [rsp+50h] [rbp+8h]

  v2 = a2;
  v3 = String1;
  if ( (signed int)sub_140003BE8(a2, String1->Length, &v13) >= 0 )
    return 0;
  String2.MaximumLength = v3->Length;
  String2.Length = String2.MaximumLength;
  String2.Buffer = v2;
  if ( !RtlEqualUnicodeString(v3, &String2, 1u) )
    return 0;
  v4 = v3->Length;
  v5 = *(__int64 **)&v3[1].Length;
  v6 = v4 >> 1;
  while ( v5 )
  {
    while ( 1 )
    {
      v7 = &v2[v6];
      v8 = *v7;
      if ( *v7 != 92 && v8 != 47 )
        break;
      ++v6;
    }
    if ( !v8 )
      return 0;
    v9 = v6;
    do
    {
      if ( v8 == 92 )
        break;
      if ( v8 == 47 )
        break;
      v8 = v2[++v6];
    }
    while ( v8 );
    if ( v6 - v9 > 0x7FFF )
      return 0;
    String1a.Buffer = v7;
    String1a.MaximumLength = 2 * (v6 - v9);
    String1a.Length = 2 * (v6 - v9);
    if ( (!*((_WORD *)v5 + 4) || !RtlEqualUnicodeString(&String1a, (PCUNICODE_STRING)(v5 + 1), 1u))
      && (!v5[4] || !RtlEqualUnicodeString(&String1a, (PCUNICODE_STRING)(v5 + 3), 1u)) )
    {
      return 0;
    }
    v5 = (__int64 *)*v5;
  }
  return 1;
}

//----- (000000014000DB1C) ----------------------------------------------------
__int64 __fastcall sub_14000DB1C(_WORD *a1, _QWORD *a2)
{
  _QWORD *v2; // r13
  _WORD *v3; // rsi
  _QWORD *v4; // rax
  _QWORD *v5; // r12
  unsigned int v6; // ebx
  _QWORD *v8; // r14
  __int16 v9; // ax
  __int16 v10; // ax
  unsigned __int64 j; // rbx
  __int16 v12; // ax
  signed int v13; // edx
  signed __int64 v14; // rax
  __int16 v15; // cx
  unsigned __int16 v16; // di
  __m128i *v17; // rax
  __int16 v18; // ax
  __int16 v19; // dx
  __int16 *v20; // r8
  unsigned __int64 v21; // rcx
  __int16 i; // ax
  unsigned __int64 v23; // rax
  __int16 v24; // cx
  __int64 v25; // rdi
  char *v26; // rax
  __m128i **v27; // rcx
  UNICODE_STRING *v28; // r14
  UNICODE_STRING *v29; // r15
  USHORT v30; // dx
  USHORT v31; // ax
  WCHAR *v32; // rax
  USHORT v33; // dx
  ULONG_PTR v34; // rdx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-40h]
  UNICODE_STRING String2; // [rsp+30h] [rbp-30h]
  __m128i v37; // [rsp+40h] [rbp-20h]
  __int16 v38; // [rsp+50h] [rbp-10h]
  __int16 v39; // [rsp+52h] [rbp-Eh]
  _WORD *v40; // [rsp+58h] [rbp-8h]
  HANDLE Handle; // [rsp+B0h] [rbp+50h]
  _QWORD *v42; // [rsp+B8h] [rbp+58h]

  v2 = a2;
  v3 = a1;
  v4 = ExAllocatePoolWithTag(PagedPool, 0x18ui64, 0x6C734349u);
  v5 = v4;
  if ( !v4 )
  {
    v6 = -1073741670;
    LODWORD(BugCheckParameter3) = -1073741670;
    sub_140006BB4(0x146ui64, 0x164ui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
    return v6;
  }
  v8 = v4 + 2;
  v4[2] = 0i64;
  *v4 = 0i64;
  v4[1] = 0i64;
  v9 = *v3;
  if ( *v3 == 92 || v9 == 47 )
  {
    v12 = v3[1];
    if ( v12 != 92 && v12 != 47 )
    {
      j = 1i64;
      goto LABEL_24;
    }
    v13 = 0;
    v14 = 2i64;
    do
    {
      while ( 1 )
      {
        v15 = v3[v14];
        if ( v15 == 92 || v15 == 47 )
          break;
        if ( !v15 )
          goto LABEL_22;
        ++v14;
      }
      ++v14;
      ++v13;
    }
    while ( v13 < 2 );
LABEL_22:
    j = v14;
  }
  else
  {
    if ( v9 && v3[1] == 58 )
    {
      v10 = v3[2];
      if ( v10 == 92 || v10 == 47 )
        j = 3i64;
      else
        j = 2i64;
      goto LABEL_24;
    }
    j = 0i64;
  }
  if ( j > 0x7FFF )
  {
LABEL_64:
    v6 = -1073741823;
    goto LABEL_65;
  }
LABEL_24:
  v16 = 2 * j;
  v17 = (__m128i *)ExAllocatePoolWithTag(PagedPool, 2 * j, 0x6C734349u);
  v5[1] = v17;
  if ( !v17 )
  {
    v6 = -1073741670;
    LODWORD(BugCheckParameter3) = -1073741670;
    sub_140006BB4(0x146ui64, 0x181ui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
LABEL_65:
    sub_14000DF38(v5);
    return v6;
  }
  *((_WORD *)v5 + 1) = v16;
  *(_WORD *)v5 = v16;
  sub_140021A80(v17, (unsigned __int64)v3, v16);
  while ( 1 )
  {
    v18 = v3[j];
    if ( v18 != 92 && v18 != 47 )
      break;
    ++j;
  }
  if ( v18 )
  {
    while ( 1 )
    {
      v19 = j;
      if ( j > 0x7FFF )
        goto LABEL_64;
      v20 = &v3[j];
      v21 = j;
      for ( i = *v20; i && i != 92 && i != 47; i = v3[++v21] )
        ;
      v23 = v21 - j;
      for ( j = v21; ; ++j )
      {
        v24 = v3[j];
        if ( v24 != 92 && v24 != 47 )
          break;
      }
      if ( v23 > 0x7FFF )
        goto LABEL_64;
      v40 = v3;
      v39 = 2 * v19;
      v38 = 2 * v19;
      v37.m128i_i64[1] = (__int64)v20;
      v37.m128i_i16[1] = 2 * v23;
      v25 = 0i64;
      v37.m128i_i16[0] = 2 * v23;
      v42 = 0i64;
      if ( (signed int)sub_14000D680(&Handle, (UNICODE_STRING *)&v38) >= 0 )
      {
        sub_14000D884((__int64)Handle, (__int64)&v37, &v42);
        ZwClose(Handle);
        v25 = (__int64)v42;
      }
      v26 = (char *)ExAllocatePoolWithTag(PagedPool, 0x40ui64, 0x6C734349u);
      v27 = (__m128i **)v26;
      if ( !v26 )
        break;
      *v8 = v26;
      v28 = (UNICODE_STRING *)(v26 + 8);
      *(_QWORD *)v26 = 0i64;
      v29 = (UNICODE_STRING *)(v26 + 24);
      v42 = v26;
      *(_QWORD *)&v28->Length = 0i64;
      v28->MaximumLength = 24;
      v28->Buffer = (PWSTR)(v26 + 40);
      *(_QWORD *)&v29->Length = 0i64;
      v29->MaximumLength = 0;
      v29->Buffer = 0i64;
      if ( v25 )
      {
        v30 = *(char *)(v25 + 68);
        v31 = *((_WORD *)v26 + 5);
        v28->Length = v30;
        if ( v30 <= v31 )
          v31 = v30;
        else
          v28->Length = v31;
        sub_140021A80(v27[2], v25 + 70, v31);
        String2.Buffer = (PWSTR)(v25 + 94);
        String2.MaximumLength = *(_WORD *)(v25 + 60);
        String2.Length = String2.MaximumLength;
      }
      else
      {
        _mm_store_si128((__m128i *)&String2, v37);
      }
      if ( !v28->Length || !RtlEqualUnicodeString(v28, &String2, 1u) )
      {
        v32 = (WCHAR *)ExAllocatePoolWithTag(PagedPool, String2.Length, 0x6C734349u);
        if ( !v32 )
        {
          v34 = 542i64;
          goto LABEL_62;
        }
        v33 = String2.Length;
        *(_QWORD *)&v29->Length = 0i64;
        v29->MaximumLength = v33;
        v29->Buffer = v32;
        RtlCopyUnicodeString(v29, &String2);
      }
      if ( v25 )
        ExFreePoolWithTag((PVOID)v25, 0);
      v8 = v42;
      if ( !v3[j] )
        goto LABEL_58;
    }
    v34 = 492i64;
LABEL_62:
    v6 = -1073741670;
    LODWORD(BugCheckParameter3) = -1073741670;
    sub_140006BB4(0x146ui64, v34, 0i64, 0xE03D000B, BugCheckParameter3, 0);
    if ( v25 )
      ExFreePoolWithTag((PVOID)v25, 0);
    goto LABEL_65;
  }
LABEL_58:
  *v2 = v5;
  return 0i64;
}

//----- (000000014000DF38) ----------------------------------------------------
void __fastcall sub_14000DF38(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rdi
  _QWORD *v3; // rsi
  void *v4; // rcx
  void *v5; // rcx

  v1 = (_QWORD *)a1[2];
  v2 = a1;
  while ( v1 )
  {
    v3 = v1;
    v1 = (_QWORD *)*v1;
    v4 = (void *)v3[4];
    if ( v4 )
      ExFreePoolWithTag(v4, 0);
    ExFreePoolWithTag(v3, 0);
  }
  v5 = (void *)v2[1];
  if ( v5 )
    ExFreePoolWithTag(v5, 0);
  ExFreePoolWithTag(v2, 0);
}

//----- (000000014000DFBC) ----------------------------------------------------
_QWORD *__fastcall sub_14000DFBC(_QWORD *a1, __int64 *a2)
{
  _QWORD *v2; // rdi
  __int64 *v3; // rbx
  void *v4; // rax

  v2 = a1;
  v3 = a2;
  v4 = sub_14000E138(*a2);
  *v2 = v4;
  v2[1] = v3[1];
  if ( !v4 )
    v2[1] = 0i64;
  return v2;
}

//----- (000000014000DFF8) ----------------------------------------------------
void **__fastcall sub_14000DFF8(void **a1, __int64 a2)
{
  void **v2; // rbx

  v2 = a1;
  *a1 = sub_14000E138(a2);
  v2[1] = (void *)sub_14000E0E8(v2);
  return v2;
}

//----- (000000014000E024) ----------------------------------------------------
_QWORD *__fastcall sub_14000E024(_QWORD *a1)
{
  _QWORD *result; // rax

  *a1 = 0i64;
  result = a1;
  a1[1] = 0i64;
  return result;
}

//----- (000000014000E034) ----------------------------------------------------
void __fastcall sub_14000E034(void **a1)
{
  void *v1; // rcx

  v1 = *a1;
  if ( v1 )
    ExFreePoolWithTag(v1, 0);
}

//----- (000000014000E054) ----------------------------------------------------
__int64 *__fastcall sub_14000E054(__int64 *a1, __int64 *a2)
{
  __int64 *v2; // rbx
  void *v3; // rcx
  __int64 v5; // [rsp+20h] [rbp-18h]
  __int64 v6; // [rsp+28h] [rbp-10h]

  v2 = a1;
  if ( a1 != a2 )
  {
    sub_14000DFBC(&v5, a2);
    v3 = (void *)*v2;
    *v2 = v5;
    v2[1] = v6;
    if ( v3 )
      ExFreePoolWithTag(v3, 0);
  }
  return v2;
}

//----- (000000014000E09C) ----------------------------------------------------
char __fastcall sub_14000E09C(__int64 *a1, __int64 *a2)
{
  __int64 v2; // rcx
  char v3; // bl
  __int64 v4; // rax

  if ( a1[1] == a2[1] )
  {
    v2 = *a1;
    v3 = 0;
    v4 = *a2;
    if ( v2 )
    {
      if ( v4 )
      {
        if ( (unsigned __int8)RtlEqualSid(v2, *a2) )
          return 1;
        return 0;
      }
    }
    else if ( !v4 )
    {
      v3 = 1;
    }
    return v3;
  }
  return 0;
}
// 140028520: using guessed type __int64 __fastcall RtlEqualSid(_QWORD, _QWORD);

//----- (000000014000E0E8) ----------------------------------------------------
__int64 __fastcall sub_14000E0E8(_QWORD *a1)
{
  unsigned int *v1; // rdi
  __int64 v2; // rbx
  unsigned int v4; // eax
  __int64 v5; // rdx
  __int64 v6; // rcx

  v1 = (unsigned int *)*a1;
  v2 = 0i64;
  if ( !*a1 )
    return 0i64;
  v4 = (unsigned int)RtlLengthSid((unsigned int *)*a1) >> 2;
  if ( v4 )
  {
    v5 = v4;
    do
    {
      v6 = *v1;
      ++v1;
      v2 ^= v6;
      --v5;
    }
    while ( v5 );
  }
  return v2;
}
// 140028448: using guessed type __int64 __fastcall RtlLengthSid(_QWORD);

//----- (000000014000E138) ----------------------------------------------------
void *__fastcall sub_14000E138(__int64 a1)
{
  __int64 v1; // rdi
  unsigned int v2; // eax
  unsigned int v3; // esi
  PVOID v4; // rax
  void *v5; // rbx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]

  v1 = a1;
  v2 = RtlLengthSid(a1);
  v3 = v2;
  v4 = ExAllocatePoolWithTag(PagedPool, v2, 0x43746144u);
  v5 = v4;
  if ( !v4 )
  {
    LODWORD(BugCheckParameter3) = -1073741670;
    sub_140006BB4(0x25Dui64, 0x9Cui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
    return 0i64;
  }
  if ( (unsigned int)RtlCopySid(v3, v4, v1) )
  {
    ExFreePoolWithTag(v5, 0);
    return 0i64;
  }
  return v5;
}
// 140028448: using guessed type __int64 __fastcall RtlLengthSid(_QWORD);
// 140028528: using guessed type __int64 __fastcall RtlCopySid(_QWORD, _QWORD, _QWORD);

//----- (000000014000E1E0) ----------------------------------------------------
bool __fastcall sub_14000E1E0(_QWORD *a1)
{
  return *a1 != 0i64;
}

//----- (000000014000E1E8) ----------------------------------------------------
void __fastcall sub_14000E1E8(HANDLE *a1)
{
  HANDLE *v1; // rbx
  HANDLE v2; // rcx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]
  __int64 v4; // [rsp+40h] [rbp+8h]

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    v4 = -300000000i64;
    if ( (unsigned int)ZwWaitForSingleObject(v2, 0i64, &v4) == 258 )
    {
      LODWORD(BugCheckParameter3) = 258;
      sub_140006BB4(0x93ui64, 0x26ui64, 0i64, 0xE03D000C, BugCheckParameter3, 0);
      ZwWaitForSingleObject(*v1, 0i64, 0i64);
    }
    ZwClose(*v1);
  }
}
// 1400283F8: using guessed type __int64 __fastcall ZwWaitForSingleObject(_QWORD, _QWORD, _QWORD);

//----- (000000014000E268) ----------------------------------------------------
PVOID __fastcall sub_14000E268(SIZE_T a1)
{
  return ExAllocatePoolWithTag(PagedPool, a1, 0x64744349u);
}

//----- (000000014000E284) ----------------------------------------------------
char __fastcall sub_14000E284(HANDLE *a1, void (__stdcall *a2)(PVOID StartContext), void *a3)
{
  HANDLE *v3; // rbx
  NTSTATUS v4; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-58h]
  int v7; // [rsp+40h] [rbp-38h]
  __int64 v8; // [rsp+48h] [rbp-30h]
  __int64 v9; // [rsp+50h] [rbp-28h]
  int v10; // [rsp+58h] [rbp-20h]
  __int64 v11; // [rsp+60h] [rbp-18h]

  v8 = 0i64;
  v9 = 0i64;
  v3 = a1;
  v7 = 48;
  v10 = 512;
  _mm_storeu_si128((__m128i *)&v11, (__m128i)0i64);
  v4 = PsCreateSystemThread(a1, 0x1FFFFFu, (POBJECT_ATTRIBUTES)&v7, 0i64, 0i64, a2, a3);
  if ( !v4 )
    return 1;
  LODWORD(BugCheckParameter3) = v4;
  sub_140006BB4(0x93ui64, 0x14ui64, 0i64, 0xE03D0026, BugCheckParameter3, 0);
  *v3 = 0i64;
  return 0;
}

//----- (000000014000E308) ----------------------------------------------------
__int64 __fastcall sub_14000E308(int a1, __int64 a2)
{
  __int64 v2; // r8
  _QWORD *v3; // rax
  unsigned int v4; // ebx
  char v5; // cl
  int v6; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]

  v2 = a1;
  v3 = qword_140037D08;
  v4 = 0;
  while ( !*v3 )
  {
    ++v3;
    if ( (signed __int64)v3 >= (signed __int64)&dword_140037D18 )
    {
      v5 = 0;
      goto LABEL_6;
    }
  }
  v5 = 1;
LABEL_6:
  qword_140037D08[v2] = a2;
  if ( v5 || (v6 = PsSetCreateThreadNotifyRoutine(sub_14000E3B0), v4 = v6, (byte_140037D00 = v6 >= 0) != 0) )
  {
    if ( dword_140035180 & 0xA00000 )
      sub_140007A38((__int64)L"Thread creation & termination monitoring activated successfully");
  }
  else
  {
    LODWORD(BugCheckParameter3) = v6;
    sub_140006BB4(0x91ui64, 0x74ui64, 0i64, 0xE03D0205, BugCheckParameter3, 0);
  }
  return v4;
}
// 140024700: using guessed type wchar_t aThreadCreation_0[64];
// 140028530: using guessed type __int64 __fastcall PsSetCreateThreadNotifyRoutine(_QWORD);
// 140035180: using guessed type int dword_140035180;
// 140037D00: using guessed type char byte_140037D00;
// 140037D18: using guessed type int dword_140037D18;

//----- (000000014000E3B0) ----------------------------------------------------
int *sub_14000E3B0()
{
  __int64 (**v0)(void); // rbx
  int *result; // rax

  v0 = (__int64 (**)(void))qword_140037D08;
  do
  {
    if ( *v0 )
      sub_140021A40(*v0);
    ++v0;
    result = &dword_140037D18;
  }
  while ( (signed __int64)v0 < (signed __int64)&dword_140037D18 );
  return result;
}
// 140037D18: using guessed type int dword_140037D18;

//----- (000000014000E410) ----------------------------------------------------
int __fastcall sub_14000E410(int a1)
{
  int *v1; // rax
  _QWORD *v2; // rcx

  v1 = (int *)a1;
  v2 = qword_140037D08;
  qword_140037D08[(_QWORD)v1] = 0i64;
  while ( !*v2 )
  {
    ++v2;
    v1 = &dword_140037D18;
    if ( (signed __int64)v2 >= (signed __int64)&dword_140037D18 )
    {
      byte_140037D00 = 0;
      LODWORD(v1) = PsRemoveCreateThreadNotifyRoutine(sub_14000E3B0);
      if ( (signed int)v1 < 0 )
      {
        if ( dword_140035180 & 0xA00000 )
          LODWORD(v1) = sub_140007A38((__int64)L"PsRemoveCreateThreadNotifyRoutine failed 0x%x", (unsigned int)v1);
        return (signed int)v1;
      }
      break;
    }
  }
  if ( dword_140035180 & 0xA00000 )
    LODWORD(v1) = sub_140007A38((__int64)L"Thread creation & termination monitoring deactivated successfully");
  return (signed int)v1;
}
// 140024780: using guessed type wchar_t aPsremovecreate[46];
// 1400247E0: using guessed type wchar_t aThreadCreation[66];
// 140028538: using guessed type __int64 __fastcall PsRemoveCreateThreadNotifyRoutine(_QWORD);
// 140035180: using guessed type int dword_140035180;
// 140037D00: using guessed type char byte_140037D00;
// 140037D18: using guessed type int dword_140037D18;

//----- (000000014000E494) ----------------------------------------------------
__int64 sub_14000E494()
{
  return (unsigned int)_InterlockedCompareExchange(&dword_140037D18, 0, 0);
}
// 140037D18: using guessed type int dword_140037D18;

//----- (000000014000E4A4) ----------------------------------------------------
bool sub_14000E4A4()
{
  return KeReadStateEvent(&stru_140036440) == 0;
}

//----- (000000014000E4D0) ----------------------------------------------------
NTSTATUS sub_14000E4D0()
{
  NTSTATUS result; // eax

  while ( 1 )
  {
    result = KeWaitForSingleObject(&stru_140036440, 0, 0, 0, &Timeout);
    if ( result != 258 )
      break;
    _InterlockedIncrement(&dword_140037D18);
  }
  return result;
}
// 140037D18: using guessed type int dword_140037D18;

//----- (000000014000E514) ----------------------------------------------------
char __usercall sub_14000E514@<al>(ULONG Tag@<ecx>, PUNICODE_STRING DestinationString@<rdx>, unsigned __int16 *a3@<r8>, unsigned int a4@<r9d>, ULONG_PTR BugCheckParameter2)
{
  unsigned int v5; // ebp
  unsigned __int16 *v6; // rbx
  PUNICODE_STRING v7; // rdi
  __m128i *v9; // rax
  __m128i *v10; // rsi
  USHORT v11; // cx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]

  v5 = a4;
  v6 = a3;
  v7 = DestinationString;
  if ( !DestinationString )
    return 0;
  if ( *((_QWORD *)a3 + 1) && 0 != *a3 )
  {
    v9 = (__m128i *)ExAllocatePoolWithTag(PagedPool, *a3, Tag);
    v10 = v9;
    if ( !v9 )
    {
      LODWORD(BugCheckParameter3) = -1073741670;
      sub_140006BB4(v5, (unsigned int)BugCheckParameter2, 0i64, 0xE03D000B, BugCheckParameter3, 0);
      return 0;
    }
    sub_140021A80(v9, *((_QWORD *)v6 + 1), *v6);
    v11 = *v6;
    v7->MaximumLength = *v6;
    v7->Length = v11;
    v7->Buffer = (PWSTR)v10;
  }
  else
  {
    RtlInitUnicodeString(DestinationString, 0i64);
  }
  return 1;
}

//----- (000000014000E5E8) ----------------------------------------------------
void __fastcall sub_14000E5E8(ULONG Tag, __int64 a2)
{
  __int64 v2; // rbx
  ULONG v3; // edx
  void *v4; // rcx

  v2 = a2;
  v3 = Tag;
  v4 = *(void **)(v2 + 8);
  if ( v4 )
  {
    ExFreePoolWithTag(v4, v3);
    *(_QWORD *)(v2 + 8) = 0i64;
  }
  *(_DWORD *)v2 = 0;
}

//----- (000000014000E620) ----------------------------------------------------
bool __fastcall sub_14000E620(__m128i *a1, USHORT *a2, BOOLEAN a3)
{
  const UNICODE_STRING *v3; // rax
  USHORT v4; // dx
  UNICODE_STRING String2; // [rsp+20h] [rbp-18h]

  v3 = (const UNICODE_STRING *)a2;
  v4 = *a2;
  if ( LOWORD(a1->m128i_i64[0]) < v4 )
    return 0;
  _mm_storeu_si128((__m128i *)&String2, *a1);
  String2.Length = v4;
  return RtlCompareUnicodeString(v3, &String2, a3) == 0;
}

//----- (000000014000E660) ----------------------------------------------------
__int64 sub_14000E660()
{
  __int64 result; // rax

  ++stru_140037DC0.L.TotalAllocates;
  result = (__int64)ExpInterlockedPopEntrySList(&stru_140037DC0.L.ListHead);
  if ( !result )
  {
    ++stru_140037DC0.L.AllocateMisses;
    result = sub_140021A40((__int64 (*)(void))stru_140037DC0.L.Allocate);
  }
  return result;
}

//----- (000000014000E6B0) ----------------------------------------------------
void __fastcall sub_14000E6B0(PSLIST_ENTRY ListEntry)
{
  struct _SLIST_ENTRY *v1; // rbx

  if ( ListEntry )
  {
    ++stru_140037DC0.L.TotalFrees;
    v1 = ListEntry;
    if ( ExQueryDepthSList(&stru_140037DC0.L.ListHead) < stru_140037DC0.L.Depth )
    {
      ExpInterlockedPushEntrySList(&stru_140037DC0.L.ListHead, v1);
    }
    else
    {
      ++stru_140037DC0.L.FreeMisses;
      sub_140021A40((__int64 (*)(void))stru_140037DC0.L.Free);
    }
  }
}

//----- (000000014000E720) ----------------------------------------------------
struct _SLIST_ENTRY *__fastcall sub_14000E720(PSLIST_ENTRY ListEntry, char a2)
{
  char v2; // di
  struct _SLIST_ENTRY *v3; // rbx

  v2 = a2;
  ListEntry->Next = (PSLIST_ENTRY)&off_140028C10;
  v3 = ListEntry;
  sub_14001CE9C(ListEntry);
  if ( v2 & 1 )
  {
    if ( v2 & 4 )
      nullsub_1(v3, 16i64);
    else
      sub_14000E6B0(v3);
  }
  return v3;
}
// 140003220: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);
// 140028C10: using guessed type __int64 (__fastcall *off_140028C10)(PSLIST_ENTRY ListEntry);

//----- (000000014000E770) ----------------------------------------------------
__int64 __fastcall sub_14000E770(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v3; // rax
  int v4; // eax
  __int64 *v5; // rax
  char v7; // [rsp+20h] [rbp-48h]

  v3 = *(_QWORD *)(a2 + 16);
  if ( *(_DWORD *)(v3 + 24) == 1 )
  {
    v4 = *(_DWORD *)(v3 + 28);
    if ( (v4 == 4 || v4 == 64) && *(_BYTE *)(a3[4] + 75i64) && *(_DWORD *)(a2 + 24) >= 0 )
    {
      v5 = sub_140010A8C((__int64)&v7, a3);
      sub_140010B74(v5, 1);
      sub_140010B54(&v7);
    }
  }
  return 0i64;
}

//----- (000000014000E7D0) ----------------------------------------------------
__int64 __fastcall sub_14000E7D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  char v6; // [rsp+30h] [rbp-28h]

  v4 = a4;
  sub_14001BF38(
    (__int64)&v6,
    2048,
    (__int64)L"IRP_MJ_CLEANUP complete Data:%p FileObj:%p, Status:%x",
    a2,
    *(_QWORD *)(a3 + 32));
  if ( (dword_140039698 == 4 || sub_14000AD9C() || !sub_140004500()) && *(_BYTE *)(v4 + 114) < 0 )
    sub_14001573C(v4);
  sub_14001BFAC((__int64)&v6);
  if ( v4 )
    sub_140021A40(**(__int64 (***)(void))v4);
  return 0i64;
}
// 140024C70: using guessed type wchar_t aIrpMjCleanupCo[54];
// 140039698: using guessed type int dword_140039698;

//----- (000000014000E850) ----------------------------------------------------
__int64 __fastcall sub_14000E850(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 v5; // rdi
  _QWORD *v6; // rax
  __int64 v7; // rbx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-48h]
  char v10; // [rsp+40h] [rbp-28h]
  __int64 v11; // [rsp+80h] [rbp+18h]

  v4 = *(_QWORD *)(a3 + 32);
  v11 = a4;
  v5 = a3;
  sub_14001BF38((__int64)&v10, 2048, (__int64)L"IRP_MJ_CLOSE complete Data:%p FileObj:%p, Status:%x", a2, v4);
  if ( dword_140039698 == 4 || sub_14000AD9C() )
  {
    v6 = (_QWORD *)sub_140014138();
    if ( v6 )
      v7 = sub_140013DFC(v6, &v11, 1, 0i64, 0);
    else
      v7 = 0i64;
    if ( v7 && *(_QWORD *)(v7 + 16) )
    {
      if ( sub_1400154CC(v7, 0) )
      {
        if ( byte_140037DA8 || !IoGetTopLevelIrp() )
        {
          sub_1400148C0(v7, v5, *(_QWORD *)(v11 + 48), *(_DWORD *)(v11 + 56), 0i64, 1, 1);
        }
        else
        {
          if ( dword_140035180 & 1 )
            sub_140007A38((__int64)L"Reentrancy detected - skipping check of %Z", *(_QWORD *)(v5 + 32) + 88i64);
          sub_140020880((__int64)&unk_140037D80);
        }
      }
    }
    else
    {
      LODWORD(BugCheckParameter3) = -1073741823;
      sub_140006BB4(0x190ui64, 0x4D5ui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
    }
    if ( v7 )
      sub_140021A40(**(__int64 (***)(void))v7);
  }
  sub_14001BFAC((__int64)&v10);
  if ( v11 )
    FltReleaseContext(v11);
  return 0i64;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 140024D40: using guessed type wchar_t aIrpMjCloseComp[52];
// 140024DB0: using guessed type wchar_t aReentrancyDete[43];
// 140028548: using guessed type __int64 IoGetTopLevelIrp(void);
// 140035180: using guessed type int dword_140035180;
// 140037DA8: using guessed type char byte_140037DA8;
// 140039698: using guessed type int dword_140039698;

//----- (000000014000E9D0) ----------------------------------------------------
__int64 __fastcall sub_14000E9D0(__int64 a1, __int64 a2, __int64 a3, __m128i *a4)
{
  __m128i *v4; // rsi
  __int64 v5; // ST20_8
  __int64 v6; // rdi
  __int64 v7; // rbx
  __int64 v8; // r15
  char v9; // r14
  char v10; // r8
  __int64 v11; // rcx
  __int64 v12; // r15
  __int64 v13; // r14
  __int64 v14; // rcx
  __int64 v15; // r9
  char v16; // r8
  int v17; // ST30_4
  int v18; // eax
  __int64 *v19; // rax
  signed int v20; // ecx
  int v21; // ecx
  int v22; // ecx
  int v23; // ecx
  int v24; // ecx
  int v25; // ecx
  __int32 v26; // eax
  int v27; // ST30_4
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-91h]
  char v30; // [rsp+40h] [rbp-71h]
  char v31; // [rsp+60h] [rbp-51h]
  char v32; // [rsp+80h] [rbp-31h]
  char v33; // [rsp+110h] [rbp+5Fh]
  __int16 v34; // [rsp+118h] [rbp+67h]
  int v35; // [rsp+120h] [rbp+6Fh]
  __int64 v36; // [rsp+128h] [rbp+77h]

  v4 = a4;
  v5 = *(_QWORD *)(a3 + 32);
  v6 = a3;
  v7 = a2;
  v8 = a1;
  v34 = 0;
  v9 = 0;
  sub_14001BF38((__int64)&v31, 512, (__int64)L"IRP_MJ_CREATE complete Data:%p FileObj:%p, Status:%x", a2, v5);
  v36 = v8;
  if ( v8 )
    FltReferenceContext(v8);
  v10 = v4[12].m128i_i8[12];
  v4[12].m128i_i8[12] = 0;
  if ( sub_1400114F4(*(_QWORD *)(v6 + 8), v7, v10, &v34) )
  {
    v9 = 0;
    if ( v34 & 0x10 )
      v9 = 1;
  }
  v11 = *(_QWORD *)(v7 + 16);
  v33 = 0;
  sub_14001576C((__int64)v4, v7, (__int64 *)v6, &v36, v9, &v33, *(_QWORD *)(v11 + 56), *(_DWORD *)(v11 + 48));
  if ( *(_DWORD *)(v7 + 24) != -1073741790 && v4[7].m128i_i8[0] )
  {
    v12 = v36 + 152;
    v13 = sub_1400109C8(*(_QWORD *)(v7 + 16));
    if ( !v13 )
    {
      LODWORD(BugCheckParameter3) = -1073741823;
      v13 = 0i64;
      sub_140006BB4(0x190ui64, 0x2D9ui64, 0i64, 0xE03D0300, BugCheckParameter3, v12);
    }
    v14 = *(_QWORD *)(v7 + 16);
    v15 = *(_QWORD *)(v7 + 32);
    v16 = v4[7].m128i_i8[1];
    v35 = *(_DWORD *)(v7 + 24);
    v17 = *(_DWORD *)(*(_QWORD *)(v14 + 24) + 16i64);
    sub_1400054F8(v14 + 32, &v35, v16, v15, v12, v13);
    if ( v35 == -1073741790 )
      *(_DWORD *)(v7 + 24) = -1073741790;
    if ( !v4[7].m128i_i8[1] )
      FltSetCallbackDataDirty(v7);
  }
  v18 = *(_DWORD *)(v7 + 24);
  if ( v18 >= 0 )
  {
    if ( v18 == 260 )
    {
      if ( !*(_QWORD *)(v7 + 32) )
        sub_140016534((__int64)v4, (const UNICODE_STRING *)(*(_QWORD *)(v6 + 32) + 88i64));
      goto LABEL_52;
    }
    v19 = sub_140010A8C((__int64)&v32, (_QWORD *)v6);
    sub_140010F2C(v19);
    sub_140010B54(&v32);
    if ( !*(_QWORD *)(v6 + 40) )
      sub_140014E6C((__int64)v4, v7, *(struct _FILE_OBJECT **)(v6 + 32));
    sub_1400161A4(
      (__int64)v4,
      (__int64 *)v6,
      *(_QWORD *)(*(_QWORD *)(v7 + 16) + 56i64),
      *(_DWORD *)(*(_QWORD *)(v7 + 16) + 48i64));
    if ( *(_DWORD *)(v7 + 24) == 264 )
    {
      sub_140014234((__int64)v4, 0x108u);
      goto LABEL_52;
    }
    sub_140011168((__int64)&v30, 0i64);
    if ( !(*(_DWORD *)(*(_QWORD *)(v6 + 32) + 80i64) & 0x40000) )
      sub_140011338((__int64)&v30, v7);
    if ( v33 || !v4[6].m128i_i8[9] )
      v20 = 3;
    else
      v20 = sub_1400144E0(v4, v6, (__int64)&v30, 0);
    v21 = v20 - 4;
    if ( v21 )
    {
      v22 = v21 - 4;
      if ( !v22 )
      {
        if ( !sub_140011260(*(_QWORD *)(v6 + 24), *(_QWORD *)(v6 + 32)) )
          goto LABEL_51;
        sub_140014C28((__int64)v4, (__int64)&v30, v6);
LABEL_49:
        *(_DWORD *)(v7 + 24) = -1073741790;
        goto LABEL_50;
      }
      v23 = v22 - 2;
      if ( v23 )
      {
        v24 = v23 - 1;
        if ( !v24 )
        {
          if ( sub_140011260(*(_QWORD *)(v6 + 24), *(_QWORD *)(v6 + 32)) )
          {
            *(_DWORD *)(v7 + 24) = 260;
            *(_QWORD *)(v7 + 32) = 1i64;
          }
          goto LABEL_51;
        }
        v25 = v24 - 1;
        if ( v25 )
        {
          if ( v25 != 1 )
          {
            v26 = v4[6].m128i_i32[3];
            if ( v26 == 1 || v26 == 4 )
            {
              v27 = *(unsigned __int16 *)(*(_QWORD *)(v7 + 16) + 40i64);
              if ( (unsigned int)sub_14001425C((__int64)v4, (_QWORD *)v6, 6) == 14 )
              {
                if ( sub_140011260(*(_QWORD *)(v6 + 24), *(_QWORD *)(v6 + 32)) )
                {
                  *(_DWORD *)(v7 + 24) = -1073741790;
                  *(_QWORD *)(v7 + 32) = 0i64;
                }
              }
            }
            sub_140014EA0((__int64)v4, v6);
            goto LABEL_51;
          }
          if ( sub_140011260(*(_QWORD *)(v6 + 24), *(_QWORD *)(v6 + 32)) )
          {
            *(_DWORD *)(v7 + 24) = -1073741536;
LABEL_50:
            *(_QWORD *)(v7 + 32) = 0i64;
            goto LABEL_51;
          }
        }
        else if ( sub_140011260(*(_QWORD *)(v6 + 24), *(_QWORD *)(v6 + 32)) )
        {
          *(_DWORD *)(v7 + 24) = -1073741805;
          goto LABEL_50;
        }
LABEL_51:
        sub_1400111B4((__int64)&v30);
        goto LABEL_52;
      }
    }
    if ( !sub_140011260(*(_QWORD *)(v6 + 24), *(_QWORD *)(v6 + 32)) )
      goto LABEL_51;
    goto LABEL_49;
  }
LABEL_52:
  if ( v36 )
  {
    FltReleaseContext(v36);
    v36 = 0i64;
  }
  sub_14001BFAC((__int64)&v31);
  if ( v4 )
    sub_140021A40(*(__int64 (**)(void))v4->m128i_i64[0]);
  return 0i64;
}
// 140021532: using guessed type __int64 __fastcall FltSetCallbackDataDirty(_QWORD);
// 14002154A: using guessed type __int64 __fastcall FltReferenceContext(_QWORD);
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 140024B10: using guessed type wchar_t aIrpMjCreateCom[53];

//----- (000000014000EDB0) ----------------------------------------------------
__int64 __fastcall sub_14000EDB0(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 *v3; // rax
  char v5; // [rsp+20h] [rbp-48h]

  v3 = sub_140010A8C((__int64)&v5, a3);
  sub_14001113C((_DWORD **)v3);
  sub_140010B54(&v5);
  return 0i64;
}

//----- (000000014000EDE0) ----------------------------------------------------
__int64 __fastcall sub_14000EDE0(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 *v3; // rax
  char v5; // [rsp+20h] [rbp-48h]

  if ( *(_DWORD *)(a2 + 24) < 0 )
  {
    v3 = sub_140010A8C((__int64)&v5, a3);
    sub_14001113C((_DWORD **)v3);
    sub_140010B54(&v5);
  }
  return 0i64;
}

//----- (000000014000EE10) ----------------------------------------------------
__int64 __fastcall sub_14000EE10(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 v7; // rbx

  v4 = a4;
  v5 = a2;
  if ( a4 )
  {
    v6 = sub_140020530(*(_QWORD *)(a3 + 24), *(_QWORD *)(a3 + 32));
    v7 = v6;
    if ( v6 )
      sub_140002124((struct _FAST_MUTEX **)(v6 + 64), *(_QWORD *)(v4 + 8), *(_DWORD *)(v5 + 24), *(_QWORD *)(v5 + 32));
    sub_140021A40(**(__int64 (***)(void))v4);
    if ( v7 )
      FltReleaseContext(v7);
  }
  return 0i64;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);

//----- (000000014000EE90) ----------------------------------------------------
__int64 __fastcall sub_14000EE90(__int64 a1, __int64 a2, _QWORD *a3, __int64 (***a4)(void))
{
  __int64 (***v4)(void); // rbx
  _QWORD *v5; // rdi
  __int64 v6; // rsi
  int v7; // ecx
  __int64 *v8; // rax
  char v10; // [rsp+30h] [rbp-68h]
  char v11; // [rsp+50h] [rbp-48h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = *(_DWORD *)(*(_QWORD *)(a2 + 16) + 32i64);
  if ( v7 == 10 || v7 == 65 )
  {
    sub_14001BF38(
      (__int64)&v10,
      0x2000,
      (__int64)L"IRP_MJ_SET_INFORMATION complete Data:%p FileObj:%p Status:%x",
      a2,
      a3[4]);
    v8 = sub_140010A8C((__int64)&v11, v5);
    sub_140011040((_DWORD **)v8);
    sub_140010B54(&v11);
    if ( *(_DWORD *)(v6 + 24) >= 0 )
      sub_140016134((__int64)v5, (__int64)v4);
    sub_14001BFAC((__int64)&v10);
  }
  if ( v4 )
    sub_140021A40(**v4);
  return 0i64;
}
// 140024FF0: using guessed type wchar_t aIrpMjSetInform[61];

//----- (000000014000EF50) ----------------------------------------------------
__int64 __fastcall sub_14000EF50(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4)
{
  __int64 v4; // rsi
  _QWORD *v5; // rdi
  __int64 v6; // rbp
  __int64 v7; // rax
  __int64 v8; // rbx
  char v9; // cl
  __int64 *v10; // rax
  __int64 *v11; // rax
  char v13; // [rsp+20h] [rbp-48h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  if ( a4 )
  {
    if ( *(_QWORD *)(a4 + 8) )
    {
      v7 = sub_140020530(a3[3], a3[4]);
      v8 = v7;
      if ( v7 )
      {
        sub_140002824((struct _FAST_MUTEX **)(v7 + 64), *(_QWORD *)(v4 + 8), *(_DWORD *)(v6 + 24), *(_QWORD *)(v6 + 32));
        FltReleaseContext(v8);
      }
    }
    sub_140021A40(**(__int64 (***)(void))v4);
  }
  v9 = *(_BYTE *)(*(_QWORD *)(v6 + 16) + 5i64);
  if ( v9 & 4 || !(v9 & 2) )
  {
    v11 = sub_140010A8C((__int64)&v13, v5);
    sub_14001113C((_DWORD **)v11);
    goto LABEL_11;
  }
  if ( *(_QWORD *)(v6 + 32) )
  {
    v10 = sub_140010A8C((__int64)&v13, v5);
    sub_140011118(v10);
LABEL_11:
    sub_140010B54(&v13);
  }
  return 0i64;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);

//----- (000000014000F030) ----------------------------------------------------
__int64 __fastcall sub_14000F030(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rbp
  __int64 v5; // rdx
  unsigned int v7; // edi
  __int64 v8; // rax
  int v9; // ebx
  __int64 v10; // rax
  char v11; // r14
  int v12; // ebx
  char v13; // r14
  _QWORD *v14; // rax
  char v15; // dl
  __int64 v16; // rbx
  int v17; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-68h]
  __int64 v19; // [rsp+30h] [rbp-58h]
  char v20; // [rsp+38h] [rbp-50h]

  v3 = a3;
  v20 = 0;
  v4 = a2;
  if ( KeGetCurrentIrql() )
  {
    if ( !byte_140037E40 )
    {
      LODWORD(BugCheckParameter3) = -1073741496;
      sub_140006BB4(0x190ui64, 0x517ui64, 0i64, 0xE03D0070, BugCheckParameter3, 0);
      if ( v3 )
      {
        v5 = *(_QWORD *)(v3 + 32);
        if ( v5 )
        {
          if ( dword_140035180 & 1 )
            sub_140007A38((__int64)L"AntiVirusPreAcquireForSectionSync called at wrong IRQL for file %Z", v5 + 88);
        }
      }
      byte_140037E40 = 1;
    }
    return 0i64;
  }
  v7 = 4;
  if ( dword_140039698 != 4 )
    return 0i64;
  if ( sub_14000747C(__readgsqword(0x188u)) )
    return 0i64;
  if ( sub_1400192EC() )
    return 0i64;
  v8 = *(_QWORD *)(v4 + 16);
  if ( *(_DWORD *)(v8 + 24) != 1 )
    return 0i64;
  v9 = *(_DWORD *)(v8 + 28);
  if ( !(v9 & 0xF6) )
    return 0i64;
  v10 = sub_140020530(*(_QWORD *)(v3 + 24), *(_QWORD *)(v3 + 32));
  v19 = v10;
  if ( v10 && *(_BYTE *)(v10 + 33) & 0x10 )
  {
    v11 = -((v9 & 0xE6) != 0);
    v12 = v9 & 0xF0;
    v13 = v11 & 2;
    v14 = (_QWORD *)sub_140014138();
    if ( v14 )
    {
      v15 = v13 | 8;
      if ( !v12 )
        v15 = v13;
      v16 = sub_140013DFC(v14, &v19, 1, &v20, v15);
    }
    else
    {
      v16 = 0i64;
    }
    if ( v16 && !*(_QWORD *)(v16 + 16) )
    {
      LODWORD(BugCheckParameter3) = -1073741823;
      sub_140006BB4(0x190ui64, 0x55Eui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
LABEL_29:
      v7 = 0;
LABEL_32:
      if ( v16 )
        sub_140021A40(**(__int64 (***)(void))v16);
      v10 = v19;
      goto LABEL_36;
    }
    v17 = sub_1400144E0((__m128i *)v16, v3, 0i64, 0);
    if ( v17 != 4 )
    {
      if ( v17 == 8 )
      {
        sub_140014C28(v16, 0i64, 0i64);
      }
      else if ( v17 != 10 )
      {
        *(_BYTE *)(v19 + 33) &= 0xEFu;
        goto LABEL_29;
      }
    }
    *(_QWORD *)(v4 + 32) = 0i64;
    *(_DWORD *)(v4 + 24) = -1073741790;
    goto LABEL_32;
  }
  v7 = 0;
LABEL_36:
  if ( v10 )
    FltReleaseContext(v10);
  return v7;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 140024E10: using guessed type wchar_t aAntiviruspreac[67];
// 140035180: using guessed type int dword_140035180;
// 140037E40: using guessed type char byte_140037E40;
// 140039698: using guessed type int dword_140039698;

//----- (000000014000F250) ----------------------------------------------------
signed __int64 __fastcall sub_14000F250(__int64 a1, __int64 a2, _QWORD *a3, __m128i **a4)
{
  __m128i **v4; // r13
  _QWORD *v5; // r14
  __int64 v6; // rdi
  __int64 v7; // r12
  __int64 v9; // rbx
  __int64 v10; // rax
  _QWORD *v11; // rax
  __m128i *v12; // rsi
  bool v13; // r15
  char v14; // bl
  __int8 v15; // r12
  __int64 *v16; // rax
  unsigned int v17; // ebx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-A9h]
  __int64 v19; // [rsp+40h] [rbp-89h]
  char v20; // [rsp+48h] [rbp-81h]
  char v21; // [rsp+68h] [rbp-61h]
  char v22; // [rsp+A0h] [rbp-29h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( dword_140039698 != 4 && !sub_14000AD9C() && sub_140004500() )
    return 1i64;
  if ( dword_140035180 & 0x400 )
  {
    if ( !sub_1400192EC() && !sub_14000747C(__readgsqword(0x188u)) )
    {
      v9 = sub_14001BD68(v5[3]);
      sub_140007A38(
        (__int64)L"IRP_MJ_CLEANUP Data:%p FileObj:%p, Flags:%x %Z %Z",
        v6,
        v5[4],
        *(unsigned __int8 *)(*(_QWORD *)(v6 + 16) + 6i64),
        v9 + 664,
        v5[4] + 88i64);
      if ( v9 )
        FltReleaseContext(v9);
    }
  }
  sub_14001BF38((__int64)&v20, 2048, (__int64)L"IRP_MJ_CLEANUP complete Data:%p FileObj:%p, Status:%x", v6, v5[4]);
  v10 = sub_140020530(v5[3], v5[4]);
  v19 = v10;
  v22 = 0;
  if ( v10 )
  {
    if ( sub_1400025E0((PFAST_MUTEX *)(v10 + 64), (struct _FILE_OBJECT *)v5[4], (__int64)&v22) )
      *(_BYTE *)(v19 + 33) |= 8u;
    if ( v19 )
    {
      if ( !(*(_BYTE *)(v19 + 32) & 2) )
      {
        FltDeleteContext(v19);
        if ( sub_1400098C0(v5[4]) )
        {
          v11 = (_QWORD *)sub_140014138();
          if ( v11 )
            v12 = (__m128i *)sub_140013DFC(v11, &v19, 1, &v22, 0);
          else
            v12 = 0i64;
          v13 = v12 != 0i64;
          if ( v12 && v12[1].m128i_i64[0] )
          {
            v14 = sub_1400154CC((__int64)v12, 1);
            sub_140016594((__int64)v12, *(_BYTE *)(v7 + 1336) != 0);
            v15 = v12[7].m128i_i8[2];
            if ( v14 )
            {
              if ( *(_QWORD *)(v5[4] + 16i64) )
              {
                if ( !(((unsigned int)sub_1400144E0(v12, (__int64)v5, 0i64, 1) - 4) & 0xFFFFFFFB) )
                {
                  v16 = sub_140010A8C((__int64)&v21, v5);
                  sub_140011064((__int64)v16);
                  sub_140010B54(&v21);
                }
              }
              else
              {
                sub_1400148C0(
                  (__int64)v12,
                  (__int64)v5,
                  *(_QWORD *)(v19 + 48),
                  *(_DWORD *)(v19 + 56),
                  0i64,
                  1,
                  (*(_BYTE *)(v19 + 32) >> 2) & 1);
              }
            }
            if ( v15 < 0 )
            {
              sub_14001BFDC(&v20);
              v13 = 0;
              *v4 = v12;
              v17 = 0;
LABEL_30:
              if ( v13 && v12 )
                sub_140021A40(*(__int64 (**)(void))v12->m128i_i64[0]);
              goto LABEL_34;
            }
          }
          else
          {
            LODWORD(BugCheckParameter3) = -1073741823;
            sub_140006BB4(0x190ui64, 0x3FDui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
          }
          sub_14001BFE0((__int64)&v20);
          v17 = 1;
          goto LABEL_30;
        }
      }
    }
  }
  sub_14001BFE0((__int64)&v20);
  v17 = 1;
LABEL_34:
  if ( v19 )
  {
    FltReleaseContext(v19);
    v19 = 0i64;
  }
  sub_14001BFAC((__int64)&v20);
  return v17;
}
// 14002153E: using guessed type __int64 __fastcall FltDeleteContext(_QWORD);
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 140024C00: using guessed type wchar_t aIrpMjCleanupDa[50];
// 140024C70: using guessed type wchar_t aIrpMjCleanupCo[54];
// 140035180: using guessed type int dword_140035180;
// 140039698: using guessed type int dword_140039698;

//----- (000000014000F550) ----------------------------------------------------
signed __int64 __fastcall sub_14000F550(__int64 a1, __int64 a2, __int64 a3, __int64 *a4)
{
  __int64 *v4; // rsi
  __int64 v5; // rdi
  __int64 v6; // rbp
  __int64 v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rbx
  unsigned int v11; // edi
  __int64 v12; // rax
  char v13; // [rsp+30h] [rbp-28h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  if ( dword_140039698 != 4 )
    return 1i64;
  if ( dword_140035180 & 0x400 )
  {
    if ( !sub_1400192EC() && !sub_14000747C(__readgsqword(0x188u)) )
    {
      v8 = sub_14001BD68(*(_QWORD *)(v5 + 24));
      sub_140007A38(
        (__int64)L"IRP_MJ_CLOSE Data:%p FileObj:%p, Flags:%x %Z %Z",
        v6,
        *(_QWORD *)(v5 + 32),
        *(unsigned __int8 *)(*(_QWORD *)(v6 + 16) + 6i64),
        v8 + 664,
        *(_QWORD *)(v5 + 32) + 88i64);
      if ( v8 )
        FltReleaseContext(v8);
    }
  }
  v9 = sub_140020530(*(_QWORD *)(v5 + 24), *(_QWORD *)(v5 + 32));
  v10 = v9;
  if ( v9 && *(_BYTE *)(v9 + 32) & 2 )
  {
    *v4 = v9;
    v11 = 0;
  }
  else
  {
    v12 = sub_14001BF38(
            (__int64)&v13,
            2048,
            (__int64)L"IRP_MJ_CLOSE complete Data:%p FileObj:%p, Status:%x",
            v6,
            *(_QWORD *)(v5 + 32));
    sub_14001BFE0(v12);
    sub_14001BFAC((__int64)&v13);
    v11 = 1;
    if ( v10 )
      FltReleaseContext(v10);
  }
  return v11;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 140024CE0: using guessed type wchar_t aIrpMjCloseData[48];
// 140024D40: using guessed type wchar_t aIrpMjCloseComp[52];
// 140035180: using guessed type int dword_140035180;
// 140039698: using guessed type int dword_140039698;

//----- (000000014000F670) ----------------------------------------------------
__int64 __fastcall sub_14000F670(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 *v3; // r13
  __int64 v4; // rdi
  unsigned int v5; // esi
  signed __int64 v6; // r12
  __int64 v7; // rbx
  __int64 v8; // r8
  __int64 v9; // r11
  int v10; // edx
  int v11; // er10
  __int64 v12; // r9
  char v13; // bl
  _QWORD *v14; // rax
  __int64 v15; // r14
  signed int v16; // ebx
  __int64 v17; // rbx
  PEPROCESS v18; // rax
  __int64 v19; // rcx
  signed __int64 v20; // rbx
  __int64 v21; // rax
  __int64 v22; // rbx
  __int64 v23; // r9
  int v24; // eax
  __int64 *v25; // r12
  int v26; // eax
  int v27; // eax
  __int64 v28; // rcx
  __int64 v29; // r12
  __int64 v30; // rax
  int v31; // eax
  signed int v32; // eax
  int v33; // eax
  __int64 v34; // rax
  int v35; // ST30_4
  unsigned int v36; // eax
  unsigned int v37; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-31h]
  ULONG_PTR BugCheckParameter3a; // [rsp+20h] [rbp-31h]
  __int64 v41; // [rsp+28h] [rbp-29h]
  __int64 v42; // [rsp+30h] [rbp-21h]
  int v43; // [rsp+38h] [rbp-19h]
  int v44; // [rsp+3Ch] [rbp-15h]
  __int64 v45; // [rsp+40h] [rbp-11h]
  __int64 v46; // [rsp+48h] [rbp-9h]
  __int64 v47; // [rsp+50h] [rbp-1h]
  char v48; // [rsp+68h] [rbp+17h]
  char v49; // [rsp+B8h] [rbp+67h]
  __int64 *vars0; // [rsp+D0h] [rbp+7Fh]

  v49 = 0;
  v3 = a3;
  v45 = a1;
  v4 = a2;
  if ( a1 )
  {
    FltReferenceContext(a1);
    a1 = v45;
  }
  v5 = 4;
  v6 = a1 + 152;
  if ( dword_140039698 != 4 && !sub_14000AD9C() && sub_140004500() && !sub_140005550()
    || sub_14000747C(__readgsqword(0x188u))
    || sub_140011A90(v3[1], v4) )
  {
    v5 = 1;
    goto LABEL_90;
  }
  if ( dword_140035180 & 0x100 && !sub_1400192EC() && !sub_14000747C(__readgsqword(0x188u)) )
  {
    v7 = *(_QWORD *)(v4 + 16);
    v8 = v3[4];
    v9 = *(_QWORD *)(v7 + 24);
    v10 = *(unsigned __int16 *)(v7 + 42);
    v11 = *(unsigned __int16 *)(v7 + 40);
    v12 = *(unsigned __int8 *)(v7 + 6);
    v47 = v8 + 88;
    v46 = v45 + 664;
    LODWORD(v45) = *(_DWORD *)(v9 + 20);
    v43 = *(_DWORD *)(v9 + 16);
    LODWORD(v42) = v10;
    LODWORD(v41) = v11;
    LODWORD(BugCheckParameter3) = *(_DWORD *)(v7 + 32);
    sub_140007A38(
      (__int64)L"IRP_MJ_CREATE Data:%p FileObj:%p Flags:%x, Opts:%x Attrib:%x Share:%x Access:%x FullOpts:%x\n%Z %Z",
      v4,
      v8,
      v12,
      BugCheckParameter3,
      v41,
      v42,
      *(_QWORD *)&v43);
  }
  sub_14001BF38((__int64)&v46, 512, (__int64)L"IRP_MJ_CREATE complete Data:%p FileObj:%p, Status:%x", v4, v3[4]);
  v13 = (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 16) + 24i64) + 20i64) >> 13) & 1;
  v14 = (_QWORD *)sub_140014138();
  if ( v14 )
    v15 = sub_140013F8C(v14, v3[4], v6, v13);
  else
    v15 = 0i64;
  LOBYTE(v43) = v15 != 0;
  if ( !v15 || !*(_QWORD *)(v15 + 16) )
  {
    LODWORD(BugCheckParameter3a) = -1073741823;
    sub_140006BB4(0x190ui64, 0x18Aui64, 0i64, 0xE03D000B, BugCheckParameter3a, 0);
    sub_14001BFE0((__int64)&v46);
    goto LABEL_84;
  }
  if ( (unsigned int)sub_140015F64(v15, v4, (__int64)v3, v6) == -1073741790 )
  {
    *(_DWORD *)(v4 + 24) = -1073741790;
LABEL_20:
    *(_QWORD *)(v4 + 32) = 0i64;
    goto LABEL_85;
  }
  v16 = -1073741536;
  if ( sub_140005550() && *(_BYTE *)(v6 + 1062) && !*(_BYTE *)(v6 + 1184) && !sub_1400192EC() )
  {
    v17 = __readgsqword(0x188u);
    v18 = IoGetCurrentProcess();
    if ( !sub_140010A04((__int64)v18, v17) )
    {
      if ( qword_140030768 )
      {
        v20 = 0i64;
        do
        {
          v19 = *(_QWORD *)(v20 + qword_140030768);
          if ( !v19 )
            break;
          if ( sub_140006650(v19) )
            goto LABEL_43;
          v20 += 8i64;
        }
        while ( v20 < 256 );
      }
      v21 = PsGetCurrentProcessId(v19);
      if ( !sub_14001E300(v21) )
      {
        v22 = sub_1400109C8(*(_QWORD *)(v4 + 16));
        if ( !v22 )
        {
          LODWORD(BugCheckParameter3a) = -1073741823;
          sub_140006BB4(0x190ui64, 0x1B3ui64, 0i64, 0xE03D0300, BugCheckParameter3a, v6);
        }
        v23 = *(_QWORD *)(v4 + 16);
        *(_WORD *)((char *)&v43 + 1) = 1;
        HIBYTE(v43) = 0;
        v24 = sub_1400052C8(
                v6,
                v22,
                (_BYTE *)&v43 + 1,
                v23 + 32,
                *(_DWORD *)(*(_QWORD *)(v23 + 24) + 16i64),
                (_BYTE *)&v43 + 2,
                (char *)&v43 + 3);
        if ( v24 )
        {
          BYTE1(v43) = 1;
          v16 = -1073741536;
          if ( v24 == -1073741749 || v24 == -1073741536 )
          {
            *(_DWORD *)(v4 + 24) = -1073741536;
            goto LABEL_20;
          }
        }
        else
        {
          if ( !BYTE1(v43) )
          {
            sub_140005188(*(_QWORD *)(v3[4] + 8), &v44);
            *(_DWORD *)(v4 + 24) = v44;
            goto LABEL_20;
          }
          v16 = -1073741536;
        }
        v25 = vars0;
        if ( BYTE2(v43) )
        {
          *(_BYTE *)(v15 + 113) = HIBYTE(v43);
          *(_BYTE *)(v15 + 112) = 1;
          *v25 = v15;
          LOBYTE(v43) = 0;
          sub_14001BFDC(&v46);
          FltSetCallbackDataDirty(v4);
        }
        goto LABEL_45;
      }
    }
LABEL_43:
    v16 = -1073741536;
  }
  v25 = vars0;
LABEL_45:
  v26 = sub_14001599C(v15, v4, v3, &v45);
  if ( v26 )
  {
    v27 = v26 - 1;
    if ( v27 )
    {
      if ( v27 == 2 )
      {
        *(_DWORD *)(v4 + 24) = -1073741790;
        goto LABEL_20;
      }
      sub_140011168((__int64)&v48, (_DWORD *)v4);
      v28 = *(_QWORD *)(v4 + 16);
      v29 = 0i64;
      v44 = 0;
      if ( sub_140008CCC(*(_QWORD *)(v28 + 56), *(_DWORD *)(v28 + 48)) )
      {
        v30 = *(_QWORD *)(v4 + 16);
        v29 = *(_QWORD *)(v30 + 56);
        v31 = *(_DWORD *)(v30 + 48);
      }
      else
      {
        v31 = v44;
      }
      if ( *(_BYTE *)(v15 + 104) )
        v32 = sub_1400148C0(v15, (__int64)v3, v29, v31, (__int64)&v48, 0, 1);
      else
        v32 = 3;
      switch ( v32 )
      {
        case 4:
          v16 = -1073741790;
LABEL_70:
          *(_DWORD *)(v4 + 24) = v16;
          goto LABEL_71;
        case 8:
          v33 = (unsigned __int64)sub_140014C28(v15, (__int64)&v48, 0i64) - 1;
          if ( v33 && v33 != 5 )
          {
LABEL_62:
            *(_DWORD *)(v4 + 24) = -1073741790;
LABEL_71:
            *(_QWORD *)(v4 + 32) = 0i64;
LABEL_72:
            sub_1400111B4((__int64)&v48);
            goto LABEL_85;
          }
          break;
        case 13:
          goto LABEL_70;
      }
      if ( (*(_DWORD *)(v15 + 108) - 2) & 0xFFFFFFFD
        || (v34 = *(_QWORD *)(v4 + 16),
            v35 = *(unsigned __int16 *)(v34 + 40),
            (unsigned int)sub_14001425C(v15, v3, (*(_DWORD *)(*(_QWORD *)(v34 + 24) + 16i64) & 0x2000006) != 0) != 14) )
      {
        v36 = sub_140011378(v3[1], v4, &v49);
        if ( (v36 & 0x80000000) == 0 )
        {
          if ( v49 )
            *(_BYTE *)(v15 + 204) = 1;
        }
        else if ( dword_140035180 & 1 )
        {
          sub_140007A38((__int64)L"AttachECPToCheckForPlaceHolder failed (0x%X) for file %Z", v36, v3[4] + 88);
        }
        LOBYTE(v43) = 0;
        *vars0 = v15;
        sub_14001BFDC(&v46);
        v5 = 0;
        goto LABEL_72;
      }
      goto LABEL_62;
    }
    v37 = sub_140011378(v3[1], v4, &v49);
    if ( (v37 & 0x80000000) == 0 )
    {
      if ( v49 )
        *(_BYTE *)(v15 + 204) = 1;
    }
    else if ( dword_140035180 & 1 )
    {
      sub_140007A38((__int64)L"AttachECPToCheckForPlaceHolder failed (0x%X) for file %Z", v37, v3[4] + 88);
    }
    LOBYTE(v43) = 0;
    *v25 = v15;
    sub_14001BFDC(&v46);
    goto LABEL_80;
  }
  sub_14001BFE0((__int64)&v46);
  if ( *(_BYTE *)(v15 + 112) )
  {
LABEL_80:
    v5 = 0;
    goto LABEL_85;
  }
LABEL_84:
  v5 = 1;
LABEL_85:
  if ( (_BYTE)v43 && v15 )
    sub_140021A40(**(__int64 (***)(void))v15);
  sub_14001BFAC((__int64)&v46);
LABEL_90:
  if ( v45 )
    FltReleaseContext(v45);
  return v5;
}
// 140021532: using guessed type __int64 __fastcall FltSetCallbackDataDirty(_QWORD);
// 14002154A: using guessed type __int64 __fastcall FltReferenceContext(_QWORD);
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 140024A40: using guessed type wchar_t aIrpMjCreateDat[98];
// 140024B10: using guessed type wchar_t aIrpMjCreateCom[53];
// 140024B80: using guessed type wchar_t aAttachecptoche[57];
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 140030768: using guessed type __int64 qword_140030768;
// 140035180: using guessed type int dword_140035180;
// 140039698: using guessed type int dword_140039698;

//----- (000000014000FC90) ----------------------------------------------------
__int64 __fastcall sub_14000FC90(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 *v3; // rax
  char v5; // [rsp+20h] [rbp-48h]

  v3 = sub_140010A8C((__int64)&v5, a3);
  sub_140011118(v3);
  sub_140010B54(&v5);
  return 0i64;
}

//----- (000000014000FCC0) ----------------------------------------------------
signed __int64 __fastcall sub_14000FCC0(__int64 a1, __int64 a2, __int64 a3, __int64 (****a4)(void))
{
  __int64 (****v4)(void); // r14
  __int64 v5; // rsi
  __int64 v6; // rbp
  __int64 v8; // rax
  unsigned int v9; // ebx
  __int64 v10; // rdx
  _QWORD *v11; // rax
  __m128i *v12; // rdi
  int v13; // eax
  __int64 (***v14)(void); // rax
  __int64 (***v15)(void); // rdi
  __int64 (**v16)(void); // rax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-78h]
  __int64 v18; // [rsp+30h] [rbp-68h]
  char v19; // [rsp+38h] [rbp-60h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  if ( *(_BYTE *)(*(_QWORD *)(a2 + 16) + 5i64) & 5 )
    return 1i64;
  *a4 = 0i64;
  v8 = sub_140020530(*(_QWORD *)(a3 + 24), *(_QWORD *)(a3 + 32));
  v18 = v8;
  v9 = 1;
  if ( v8 )
  {
    if ( !(*(_BYTE *)(v8 + 33) & 0x10) )
      goto LABEL_27;
    if ( KeGetCurrentIrql() )
    {
      if ( !byte_140037E41 )
      {
        LODWORD(BugCheckParameter3) = -1073741496;
        sub_140006BB4(0x190ui64, 0x667ui64, 0i64, 0xE03D0070, BugCheckParameter3, 0);
        v10 = *(_QWORD *)(v5 + 32);
        if ( v10 && dword_140035180 & 1 )
          sub_140007A38((__int64)L"AntiVirusPreRead called at raised IRQL for file %Z", v10 + 88);
        byte_140037E41 = 1;
      }
      goto LABEL_27;
    }
    if ( sub_14000747C(__readgsqword(0x188u)) || sub_1400192EC() )
    {
LABEL_27:
      if ( !(*(_BYTE *)(*(_QWORD *)(v6 + 16) + 5i64) & 2) )
      {
        v14 = (__int64 (***)(void))sub_14000E660();
        v15 = v14;
        if ( v14 )
        {
          v14[1] = 0i64;
          *v14 = (__int64 (**)(void))&off_140028C10;
        }
        else
        {
          v15 = 0i64;
        }
        if ( v15 )
        {
          v16 = (__int64 (**)(void))sub_140001C3C(
                                      v18 + 64,
                                      *(_QWORD *)(v6 + 8),
                                      *(_QWORD *)(*(_QWORD *)(v6 + 16) + 40i64),
                                      *(unsigned int *)(*(_QWORD *)(v6 + 16) + 24i64));
          if ( v16 )
          {
            v15[1] = v16;
            *v4 = v15;
          }
          else
          {
            sub_140021A40(**v15);
          }
        }
        if ( *v4 )
          v9 = 0;
      }
      goto LABEL_37;
    }
    v19 = 0;
    v11 = (_QWORD *)sub_140014138();
    if ( v11 )
      v12 = (__m128i *)sub_140013DFC(v11, &v18, 1, &v19, 2);
    else
      v12 = 0i64;
    if ( v12 && v12[1].m128i_i64[0] )
    {
      v13 = sub_1400144E0(v12, v5, 0i64, 0);
      if ( v13 != 4 )
      {
        if ( v13 == 8 )
        {
          sub_140014C28((__int64)v12, 0i64, 0i64);
        }
        else if ( v13 != 10 )
        {
          *(_BYTE *)(v18 + 33) &= 0xEFu;
          goto LABEL_25;
        }
      }
      *(_QWORD *)(v6 + 32) = 0i64;
      *(_DWORD *)(v6 + 24) = -1073741790;
      sub_140021A40(*(__int64 (**)(void))v12->m128i_i64[0]);
      v9 = 4;
LABEL_37:
      if ( v18 )
        FltReleaseContext(v18);
      return v9;
    }
    LODWORD(BugCheckParameter3) = -1073741823;
    sub_140006BB4(0x190ui64, 0x6A9ui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
LABEL_25:
    if ( v12 )
      sub_140021A40(*(__int64 (**)(void))v12->m128i_i64[0]);
    goto LABEL_27;
  }
  return v9;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 140024EA0: using guessed type wchar_t aAntivirusprere[51];
// 140028C10: using guessed type __int64 (__fastcall *off_140028C10)(PSLIST_ENTRY ListEntry);
// 140035180: using guessed type int dword_140035180;
// 140037E41: using guessed type char byte_140037E41;

//----- (000000014000FF40) ----------------------------------------------------
signed __int64 __fastcall sub_14000FF40(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 *v3; // rax
  char v5; // [rsp+20h] [rbp-48h]

  v3 = sub_140010A8C((__int64)&v5, a3);
  sub_140010B74(v3, 0);
  sub_140010B54(&v5);
  return 1i64;
}

//----- (000000014000FF70) ----------------------------------------------------
__int64 __fastcall sub_14000FF70(__int64 a1, __int64 a2, _QWORD *a3, __int64 **a4)
{
  __int64 **v4; // r15
  _QWORD *v5; // r14
  __int64 v6; // rbx
  unsigned int v7; // esi
  unsigned int v8; // edi
  __int64 v9; // rcx
  __int64 v10; // r9
  __int64 v11; // rdx
  __int64 *v12; // rax
  __int64 *v13; // rax
  char *v14; // rcx
  __int64 *v15; // rax
  __int64 *v16; // rax
  __int64 *v17; // rbx
  __int64 *v18; // rax
  __int64 v19; // rcx
  UNICODE_STRING *v20; // rax
  __int64 v22; // [rsp+20h] [rbp-E0h]
  __int64 (__fastcall **v23)(PSLIST_ENTRY); // [rsp+40h] [rbp-C0h]
  UNICODE_STRING *v24; // [rsp+48h] [rbp-B8h]
  __int64 v25; // [rsp+50h] [rbp-B0h]
  __int16 v26; // [rsp+58h] [rbp-A8h]
  __int16 v27; // [rsp+5Ah] [rbp-A6h]
  __int64 v28; // [rsp+60h] [rbp-A0h]
  char v29; // [rsp+68h] [rbp-98h]
  char v30; // [rsp+A0h] [rbp-60h]
  char v31; // [rsp+D8h] [rbp-28h]
  char v32; // [rsp+110h] [rbp+10h]
  char v33; // [rsp+150h] [rbp+50h]
  char v34; // [rsp+158h] [rbp+58h]
  char v35; // [rsp+159h] [rbp+59h]
  __int64 v36; // [rsp+160h] [rbp+60h]

  *a4 = 0i64;
  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = 1;
  v8 = *(_DWORD *)(*(_QWORD *)(a2 + 16) + 32i64);
  if ( *(_DWORD *)(*(_QWORD *)(a2 + 16) + 32i64) == 10 )
  {
LABEL_4:
    if ( dword_140035180 & 0x1000 && !sub_1400192EC() && !sub_14000747C(__readgsqword(0x188u)) )
    {
      v9 = *(_QWORD *)(v6 + 16);
      v10 = v5[4];
      v11 = *(_QWORD *)(v9 + 56);
      v28 = v11 + 20;
      v27 = *(_WORD *)(v11 + 16);
      v26 = v27;
      LODWORD(v22) = *(unsigned __int8 *)(v9 + 6);
      sub_140007A38(
        (__int64)L"IRP_MJ_SET_INFORMATION (FileRenameInformation[Ex]) op: %d, Data:%p FileObj:%p Flags:%x, RootDir:%p FileName:%Z",
        v8,
        v6,
        v10,
        v22,
        *(_QWORD *)(v11 + 8),
        &v26);
    }
    v12 = sub_140010A8C((__int64)&v29, v5);
    sub_1400110F4(v12);
    sub_140010B54(&v29);
    goto LABEL_9;
  }
  if ( *(_DWORD *)(*(_QWORD *)(a2 + 16) + 32i64) != 11 )
  {
    if ( *(_DWORD *)(*(_QWORD *)(a2 + 16) + 32i64) != 65 )
      return v7;
    goto LABEL_4;
  }
  if ( !(*(_DWORD *)a2 & 1) )
    return v7;
LABEL_9:
  v24 = sub_1400151C8(v6, (__int64)v5);
  v23 = &off_140028B58;
  if ( !v24 )
  {
    if ( v8 != 10 && v8 != 65 )
      goto LABEL_46;
    v13 = sub_140010A8C((__int64)&v30, v5);
    sub_140011040((_DWORD **)v13);
    v14 = &v30;
    goto LABEL_39;
  }
  if ( !sub_140004500() )
  {
    v25 = sub_140020530(v5[3], v5[4]);
    if ( v25 )
    {
      sub_140013DFC(&v33, &v25, 0, 0i64, 0);
      if ( v36
        && ((v8 == 10 || v8 == 65) && v35 || v8 == 11 && v34)
        && (unsigned int)sub_140014ED4((__int64)&v33, v5, (__int64)&v23) == 14 )
      {
        if ( v8 == 10 || v8 == 65 )
        {
          v15 = sub_140010A8C((__int64)&v31, v5);
          sub_140011040((_DWORD **)v15);
          sub_140010B54(&v31);
        }
        *(_QWORD *)(v6 + 32) = 0i64;
        *(_DWORD *)(v6 + 24) = -1073741790;
        sub_14001405C(&v33);
        if ( v25 )
          FltReleaseContext(v25);
        v7 = 4;
        goto LABEL_46;
      }
      sub_14001405C(&v33);
      if ( v25 )
        FltReleaseContext(v25);
    }
  }
  v16 = (__int64 *)sub_14001663C();
  v17 = v16;
  if ( v16 )
  {
    v16[1] = 0i64;
    *v16 = (__int64)&off_140028B58;
  }
  else
  {
    v17 = 0i64;
  }
  if ( v17 )
  {
    if ( v17 != (__int64 *)&v23 )
    {
      v19 = v17[1];
      if ( v19 )
      {
        sub_14001A4D8(v19);
        v17[1] = 0i64;
      }
      v20 = v24;
      v17[1] = (__int64)v24;
      if ( v20 )
        sub_14001B77C((__int64)v24);
    }
    *v4 = v17;
    v7 = 0;
    goto LABEL_46;
  }
  if ( v8 == 10 || v8 == 65 )
  {
    v18 = sub_140010A8C((__int64)&v32, v5);
    sub_140011040((_DWORD **)v18);
    v14 = &v32;
LABEL_39:
    sub_140010B54(v14);
  }
LABEL_46:
  v23 = &off_140028B58;
  if ( v24 )
  {
    sub_14001A4D8(v24);
    v24 = 0i64;
  }
  sub_14001CE9C(&v23);
  return v7;
}
// 14001A4D8: using guessed type __int64 __fastcall sub_14001A4D8(_QWORD);
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 140024F10: using guessed type wchar_t aIrpMjSetInform_0[111];
// 140028B58: using guessed type __int64 (__fastcall *off_140028B58)(PSLIST_ENTRY ListEntry);
// 140035180: using guessed type int dword_140035180;

//----- (0000000140010270) ----------------------------------------------------
signed __int64 __fastcall sub_140010270(__int64 a1, __int64 a2, _QWORD *a3, __int64 (****a4)(void))
{
  __int64 v4; // rbp
  __int64 (****v5)(void); // r12
  _QWORD *v6; // r15
  __int64 v7; // r14
  char v8; // cl
  __int64 *v10; // rax
  __int64 (***v11)(void); // rax
  __int64 (***v12)(void); // rsi
  __int64 v13; // rax
  __int64 v14; // rbx
  __int64 (**v15)(void); // rax
  __int64 v16; // rax
  signed int v17; // edx
  __int64 v18; // rax
  unsigned int v19; // edx
  const void *v20; // rcx
  unsigned int v21; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-68h]
  char v23; // [rsp+30h] [rbp-58h]

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = *(_BYTE *)(*(_QWORD *)(a2 + 16) + 5i64);
  if ( !(v8 & 6) )
  {
    if ( v8 & 1 )
    {
      LODWORD(BugCheckParameter3) = -1073741823;
      sub_140006BB4(0x190ui64, 0x73Dui64, 0i64, 0xE03D0030, BugCheckParameter3, 0);
      return 1i64;
    }
    v10 = sub_140010A8C((__int64)&v23, a3);
    sub_140011118(v10);
    sub_140010B54(&v23);
    *v5 = 0i64;
    v11 = (__int64 (***)(void))sub_14000E660();
    v12 = v11;
    if ( v11 )
    {
      v11[1] = 0i64;
      *v11 = (__int64 (**)(void))&off_140028C10;
    }
    else
    {
      v12 = 0i64;
    }
    if ( v12 )
    {
      v13 = sub_140020530(v6[3], v6[4]);
      v14 = v13;
      if ( !v13 )
      {
        sub_140021A40(**v12);
        return 0i64;
      }
      v15 = (__int64 (**)(void))sub_140001DC0(
                                  v13 + 64,
                                  *(_QWORD *)(v7 + 8),
                                  *(_QWORD *)(*(_QWORD *)(v7 + 16) + 40i64),
                                  *(unsigned int *)(*(_QWORD *)(v7 + 16) + 24i64));
      if ( v15 )
      {
        v12[1] = v15;
        *v5 = v12;
      }
      else
      {
        sub_140021A40(**v12);
      }
      if ( !(*(_DWORD *)(v6[4] + 80i64) & 8)
        || (v16 = *(_QWORD *)(v7 + 16), *(_QWORD *)(v16 + 40))
        || !*(_DWORD *)(v16 + 24) )
      {
LABEL_28:
        FltReleaseContext(v14);
        return 0i64;
      }
      if ( v4 )
        FltReferenceContext(v4);
      if ( !*(_BYTE *)(v4 + 1215) && *(_BYTE *)(v4 + 1214) )
      {
        if ( *(_DWORD *)(v14 + 152) )
        {
          v17 = 3;
        }
        else
        {
          v18 = *(_QWORD *)(v7 + 16);
          v19 = *(_DWORD *)(v18 + 24);
          v20 = *(const void **)(v18 + 48);
          v21 = 1024;
          if ( v19 < 0x400 )
            v21 = v19;
          if ( v21 < 0xAui64 )
            goto LABEL_27;
          v17 = sub_1400107E0(v20, v21);
        }
        sub_140020630(v14, v17);
      }
LABEL_27:
      FltReleaseContext(v4);
      goto LABEL_28;
    }
  }
  return 0i64;
}
// 14002154A: using guessed type __int64 __fastcall FltReferenceContext(_QWORD);
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 140028C10: using guessed type __int64 (__fastcall *off_140028C10)(PSLIST_ENTRY ListEntry);

//----- (0000000140010438) ----------------------------------------------------
__int64 __fastcall sub_140010438(PVOID Object)
{
  PVOID v1; // rsi
  __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rdx
  __int64 v6; // rcx
  UNICODE_STRING *v7; // rax
  UNICODE_STRING *v8; // rax
  UNICODE_STRING *v9; // rax
  char v10; // al
  UNICODE_STRING *v11; // rax
  __int128 v12; // xmm1
  __int128 v13; // xmm0
  __int128 v14; // xmm1
  __int128 v15; // xmm0
  __int128 v16; // xmm1
  __int128 v17; // xmm0
  __int128 v18; // xmm1
  int v19; // eax
  unsigned int v20; // ebx
  UNICODE_STRING *v21; // rax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-81h]
  __int64 v23; // [rsp+28h] [rbp-79h]
  int v24; // [rsp+30h] [rbp-71h]
  __int128 *v25; // [rsp+38h] [rbp-69h]
  __int128 v26; // [rsp+48h] [rbp-59h]
  __int128 v27; // [rsp+58h] [rbp-49h]
  __int128 v28; // [rsp+68h] [rbp-39h]
  __int128 v29; // [rsp+78h] [rbp-29h]
  __int128 v30; // [rsp+88h] [rbp-19h]
  __int128 v31; // [rsp+98h] [rbp-9h]
  __int128 v32; // [rsp+A8h] [rbp+7h]
  __int128 v33; // [rsp+B8h] [rbp+17h]
  __int128 v34; // [rsp+C8h] [rbp+27h]
  int v35; // [rsp+D8h] [rbp+37h]

  v1 = Object;
  sub_140005F18();
  sub_140012400();
  sub_1400059DC();
  sub_14000A5A4();
  if ( !(unsigned __int8)sub_140009258() )
    return 3221225473i64;
  v3 = sub_1400098C0((__int64)v1);
  ObfReferenceObject(v1);
  v4 = sub_1400098C0((__int64)v1);
  ObfDereferenceObject(v1);
  if ( v4 - v3 != 1 )
  {
    LODWORD(BugCheckParameter3) = -1073741823;
    sub_140006BB4(0x190ui64, 0x91ui64, 0i64, 0xE03D0031, BugCheckParameter3, 0);
LABEL_35:
    sub_140009970();
    return 3221225473i64;
  }
  sub_140008A38(2052);
  sub_1400073D8();
  sub_1400068A4();
  sub_140016C60();
  sub_140017454();
  if ( !sub_14000A064() )
  {
    LODWORD(BugCheckParameter3) = -1073741823;
    sub_140006BB4(0x190ui64, 0x9Eui64, 0i64, 0xE03D0028, BugCheckParameter3, 0);
LABEL_34:
    sub_1400171DC();
    sub_140006B5C();
    sub_140007468();
    sub_140008AB8();
    goto LABEL_35;
  }
  sub_14000ADA4();
  if ( !sub_14000A018((__int64)sub_14000E4D0, 0i64) || !sub_140019208() )
  {
    LODWORD(BugCheckParameter3) = -1073741823;
    sub_140006BB4(0x190ui64, 0xB1ui64, 0i64, 0xE03D0027, BugCheckParameter3, 0);
    goto LABEL_33;
  }
  sub_140007A14();
  if ( (unsigned int)sub_14001B3D0() )
  {
    LODWORD(BugCheckParameter3) = -1073741823;
    sub_140006BB4(0x190ui64, 0xC8ui64, 0i64, 0xE03D0004, BugCheckParameter3, 0);
LABEL_11:
    nullsub_1(v6, v5);
LABEL_33:
    sub_14000A0E4();
    goto LABEL_34;
  }
  sub_140007D7C();
  sub_1400044E8();
  if ( !sub_14001082C() )
  {
    LODWORD(BugCheckParameter3) = -1073741823;
    sub_140006BB4(0x190ui64, 0xDEui64, 0i64, 0xE03D0004, BugCheckParameter3, 0);
    sub_14000849C();
    sub_14001B784();
    goto LABEL_11;
  }
  v7 = sub_14000589C();
  if ( sub_1400095B8(v7, L"CacheOff", &v23) && (_DWORD)v23 )
    sub_140010B98(0);
  v8 = sub_14000589C();
  if ( sub_1400095B8(v8, L"DisableOfflineFileDetection", &v23) && (_DWORD)v23 )
    sub_1400115C0(0);
  v9 = sub_14000589C();
  if ( sub_1400095B8(v9, L"DisableRemoteTopLevelIrpCheck", &v23) )
  {
    v10 = byte_140037DA8;
    if ( (_DWORD)v23 )
      v10 = 1;
    byte_140037DA8 = v10;
  }
  v11 = sub_14000589C();
  if ( !sub_1400095B8(v11, L"DisableDriverTelemetry", &v23) || !(_DWORD)v23 )
  {
    v24 = 9699474;
    v12 = *(_OWORD *)L"Y\\Machine\\SOFTWARE\\WOW6432Node\\Sophos\\SAVService\\Telemetry\\Driver";
    v26 = *(_OWORD *)L"\\REGISTRY\\Machine\\SOFTWARE\\WOW6432Node\\Sophos\\SAVService\\Telemetry\\Driver";
    v13 = *(_OWORD *)L"e\\SOFTWARE\\WOW6432Node\\Sophos\\SAVService\\Telemetry\\Driver";
    v27 = v12;
    v14 = *(_OWORD *)L"RE\\WOW6432Node\\Sophos\\SAVService\\Telemetry\\Driver";
    v28 = v13;
    v15 = *(_OWORD *)L"32Node\\Sophos\\SAVService\\Telemetry\\Driver";
    v29 = v14;
    v16 = *(_OWORD *)L"ophos\\SAVService\\Telemetry\\Driver";
    v30 = v15;
    v17 = *(_OWORD *)L"VService\\Telemetry\\Driver";
    v31 = v16;
    v18 = *(_OWORD *)L"ry\\Driver";
    v32 = v17;
    v19 = *(_DWORD *)L"r";
    v33 = *(_OWORD *)L"\\Telemetry\\Driver";
    v34 = v18;
    v35 = v19;
    v25 = &v26;
    sub_1400207D4((__int64)&unk_140037D80, (const UNICODE_STRING *)&v24);
    sub_140020F14(&unk_140037D40, 10000, (__int64)&unk_140037D80);
  }
  v20 = 0x2000;
  v21 = sub_14000589C();
  if ( sub_1400095B8(v21, L"MinimumStackSize", &v23) )
    v20 = v23;
  dword_14002B150[0] = v20;
  if ( v20 > 0x11800 )
    dword_14002B150[0] = 71680;
  return 0i64;
}
// 140003220: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);
// 140009258: using guessed type __int64 sub_140009258(void);
// 1400248A0: using guessed type wchar_t aCacheoff[9];
// 1400248C0: using guessed type wchar_t aDisableoffline[28];
// 140024900: using guessed type wchar_t aDisableremotet[30];
// 140024940: using guessed type wchar_t aDisabledrivert[23];
// 140024970: using guessed type wchar_t aRegistryMachin[74];
// 140024A10: using guessed type wchar_t aMinimumstacksi[17];
// 140037DA8: using guessed type char byte_140037DA8;

//----- (00000001400107E0) ----------------------------------------------------
__int64 __fastcall sub_1400107E0(const void *a1, SIZE_T a2)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rdi

  v2 = a2;
  v3 = (__int64)a1;
  ProbeForRead(a1, a2, 1u);
  return 2 - (unsigned int)(sub_14002148C(v3, v2) != 0);
}

//----- (000000014001082C) ----------------------------------------------------
char sub_14001082C()
{
  _QWORD *v0; // rax
  char v1; // di
  void *v2; // rbx
  int v4; // [rsp+20h] [rbp-18h]
  const wchar_t *v5; // [rsp+28h] [rbp-10h]

  v0 = ExAllocatePoolWithTag(PagedPool, 0x90ui64, 0x43564153u);
  v1 = 0;
  v2 = v0;
  if ( v0 )
  {
    v4 = 2752552;
    v5 = L"SAVOnAccess Instance";
    *v0 = sub_14000F670;
    v0[1] = sub_14000E9D0;
    v0[2] = sub_14000F250;
    v0[3] = sub_14000E7D0;
    v0[4] = sub_14000F550;
    v0[5] = sub_14000E850;
    v0[6] = sub_14000FCC0;
    v0[7] = sub_14000EE10;
    v0[8] = sub_140010270;
    v0[9] = sub_14000EF50;
    v0[10] = sub_14000FF70;
    v0[11] = sub_14000EE90;
    v0[12] = sub_14000FC90;
    v0[13] = sub_14000EDE0;
    v0[14] = sub_14000EDB0;
    v0[15] = sub_14000F030;
    v0[16] = sub_14000E770;
    v0[17] = sub_14000FF40;
    if ( sub_14001D4A0(v0, (const UNICODE_STRING *)&v4) )
      v1 = 1;
    ExFreePoolWithTag(v2, 0x43564153u);
    LOBYTE(v0) = v1;
  }
  return (char)v0;
}
// 140024870: using guessed type wchar_t aSavonaccessIns[21];

//----- (0000000140010978) ----------------------------------------------------
void sub_140010978()
{
  __int64 v0; // rdx
  __int64 v1; // rcx

  sub_140021018((__int64)&unk_140037D40);
  sub_14002088C((__int64)&unk_140037D80);
  sub_14000849C();
  sub_14001B784();
  nullsub_1(v1, v0);
  sub_14000A0E4();
  sub_1400171DC();
  sub_140006B5C();
  sub_140007468();
  sub_140008AB8();
  sub_140009970();
}
// 140003220: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);

//----- (00000001400109C8) ----------------------------------------------------
__int64 __fastcall sub_1400109C8(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // rcx
  __int64 v3; // rcx

  result = 0i64;
  v2 = *(_QWORD *)(a1 + 24);
  if ( v2 )
  {
    v3 = *(_QWORD *)(v2 + 8);
    if ( v3 )
    {
      result = *(_QWORD *)(v3 + 32);
      if ( !*(_QWORD *)(v3 + 32) )
        result = *(_QWORD *)(v3 + 48);
    }
  }
  return result;
}

//----- (0000000140010A04) ----------------------------------------------------
char __fastcall sub_140010A04(__int64 a1, __int64 a2)
{
  char v2; // bl
  __int64 v3; // rsi
  __int64 v4; // rdi
  _QWORD *i; // rax
  __int64 v7; // rcx
  char v8; // [rsp+20h] [rbp-28h]

  v2 = 0;
  v3 = a2;
  v4 = a1;
  if ( !qword_140030760 )
    return 0;
  KeAcquireInStackQueuedSpinLock(&qword_1400396A0, &v8);
  for ( i = (_QWORD *)qword_140030760; i; i = (_QWORD *)*i )
  {
    if ( i[1] == v4 )
    {
      v7 = i[2];
      if ( !v7 || v7 == v3 )
      {
        v2 = 1;
        break;
      }
    }
  }
  KeReleaseInStackQueuedSpinLock(&v8);
  return v2;
}
// 140028330: using guessed type __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD, _QWORD);
// 140028338: using guessed type __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD);
// 140030760: using guessed type __int64 qword_140030760;
// 1400396A0: using guessed type __int64 qword_1400396A0;

//----- (0000000140010A8C) ----------------------------------------------------
__int64 *__fastcall sub_140010A8C(__int64 a1, _QWORD *a2)
{
  __int64 *v2; // rbx
  _QWORD *v3; // rdi
  __int64 v4; // rdx
  __int64 v5; // rsi
  __int64 v6; // rdi

  *(_QWORD *)a1 = 0i64;
  v2 = (__int64 *)a1;
  *(_DWORD *)(a1 + 20) = 0;
  v3 = a2;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_QWORD *)(a1 + 8) = a2;
  *(_BYTE *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  if ( sub_14001BF00(a2[3]) )
  {
    *((_BYTE *)v2 + 48) = 1;
  }
  else if ( !*((_BYTE *)v2 + 48) )
  {
    v4 = v3[4];
    if ( *(_QWORD *)(v4 + 16) )
    {
      v5 = sub_14001FB40(v3[3], v4, 0i64);
      if ( *v2 )
        FltReleaseContext(*v2);
      *v2 = v5;
      if ( !v5 && (unsigned int)sub_14001F918(v3, v2) == -1071906814 )
      {
        v6 = sub_14001FB40(v3[3], v3[4], 0i64);
        if ( *v2 )
          FltReleaseContext(*v2);
        *v2 = v6;
      }
    }
  }
  return v2;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);

//----- (0000000140010B54) ----------------------------------------------------
__int64 __fastcall sub_140010B54(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rcx
  __int64 result; // rax

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    result = FltReleaseContext(v2);
    *v1 = 0i64;
  }
  return result;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);

//----- (0000000140010B74) ----------------------------------------------------
void __fastcall sub_140010B74(__int64 *a1, char a2)
{
  __int64 *v2; // rax
  __int64 v3; // rcx

  v2 = a1;
  v3 = *a1;
  if ( v3 )
  {
    if ( !*(_QWORD *)(v2[1] + 40) )
      sub_14001F79C(v3, a2);
  }
}

//----- (0000000140010B98) ----------------------------------------------------
void __fastcall sub_140010B98(char a1)
{
  byte_14002B168 = a1;
}
// 14002B168: using guessed type char byte_14002B168;

//----- (0000000140010BA0) ----------------------------------------------------
void __fastcall sub_140010BA0(__int64 *a1)
{
  __int64 *v1; // rbx
  unsigned __int64 v2; // rax

  v1 = a1;
  if ( byte_14002B168 )
  {
    if ( *a1 )
    {
      if ( !*(_QWORD *)(a1[1] + 40) )
      {
        v2 = PsGetCurrentProcessId(a1);
        if ( *((_BYTE *)v1 + 24) )
        {
          if ( v1[4] == v2 )
          {
            sub_14001F9C0(*v1, v2, v1[5]);
            *((_BYTE *)v1 + 24) = 0;
          }
        }
      }
    }
  }
}
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 14002B168: using guessed type char byte_14002B168;

//----- (0000000140010BF4) ----------------------------------------------------
bool __fastcall sub_140010BF4(__int64 *a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 *v3; // rbx
  __int64 v4; // rcx
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // rsi
  bool v8; // di
  __int64 v10; // [rsp+20h] [rbp-28h]
  char v11; // [rsp+60h] [rbp+18h]
  __int64 v12; // [rsp+68h] [rbp+20h]

  v2 = a2;
  v3 = a1;
  if ( !byte_14002B168 )
    return 0;
  v4 = *a1;
  if ( !v4 )
    return 0;
  v5 = v3[1];
  if ( *(_QWORD *)(v5 + 40) )
    return 0;
  sub_14001F7F8(v4, *(_QWORD *)(v5 + 32));
  v7 = PsGetCurrentProcessId(v6);
  v8 = sub_14001FA1C(*v3, v7, &v10, &v11);
  if ( !v8 )
  {
    if ( v11 )
    {
      v12 = 0i64;
      if ( (signed int)sub_140010CD0(v3, v2, &v12) >= 0 )
      {
        v8 = sub_14001FA1C(*v3, v7, &v10, 0i64);
        FltClose(v12);
      }
    }
  }
  *((_BYTE *)v3 + 24) = !v8;
  if ( !v8 )
  {
    v3[5] = v10;
    v3[4] = v7;
  }
  return v8;
}
// 14002156E: using guessed type __int64 __fastcall FltClose(_QWORD);
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 14002B168: using guessed type char byte_14002B168;

//----- (0000000140010CD0) ----------------------------------------------------
__int64 __fastcall sub_140010CD0(__int64 *a1, __int64 a2, _QWORD *a3)
{
  __int64 *v3; // rbx
  __int64 v4; // rcx
  _QWORD *v5; // rdi
  signed int v6; // ST50_4
  signed int v7; // ST48_4
  signed int v8; // ST40_4
  int v9; // ST38_4
  __int64 result; // rax
  __int64 v12; // [rsp+58h] [rbp+7h]
  int v13; // [rsp+60h] [rbp+Fh]
  int v14; // [rsp+68h] [rbp+17h]
  __int64 v15; // [rsp+70h] [rbp+1Fh]
  int v16; // [rsp+78h] [rbp+27h]
  __int64 v17; // [rsp+80h] [rbp+2Fh]
  __int64 v18; // [rsp+88h] [rbp+37h]
  int v19; // [rsp+90h] [rbp+3Fh]
  __int128 v20; // [rsp+98h] [rbp+47h]
  void *retaddr; // [rsp+B8h] [rbp+67h]
  __int64 v22; // [rsp+C0h] [rbp+6Fh]
  __int64 v23; // [rsp+C8h] [rbp+77h]

  v17 = 0i64;
  v3 = a1;
  v4 = a1[1];
  v14 = 2048;
  v5 = a3;
  v13 = 0;
  v12 = 0i64;
  v6 = 256;
  v7 = 1;
  v8 = 1;
  v9 = 0;
  v16 = 48;
  v19 = 576;
  v18 = a2;
  _mm_storeu_si128((__m128i *)&v20, (__m128i)0i64);
  result = FltCreateFile(*(_QWORD *)(v4 + 8), *(_QWORD *)(v4 + 24), &v23, 0i64, &v16, &v15, 0i64, v9, v8, v7, v6, v12);
  if ( (signed int)result >= 0 )
  {
    sub_14001FE9C(*v3, (_BYTE **)&retaddr);
    *v5 = v22;
    result = 0i64;
  }
  return result;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 140021562: using guessed type __int64 __fastcall FltCreateFile(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140010DA8) ----------------------------------------------------
void __fastcall sub_140010DA8(_DWORD **a1)
{
  _DWORD **v1; // rbx
  _DWORD *v2; // rcx

  v1 = a1;
  if ( byte_14002B168 )
  {
    v2 = *a1;
    if ( v2 )
    {
      if ( *((_BYTE *)v1 + 16) )
      {
        sub_14001FAB8(v2, *((_DWORD *)v1 + 5));
        *((_BYTE *)v1 + 16) = 0;
      }
    }
  }
}
// 14002B168: using guessed type char byte_14002B168;

//----- (0000000140010DDC) ----------------------------------------------------
char __fastcall sub_140010DDC(__int64 *a1)
{
  __int64 v1; // rcx
  char result; // al

  v1 = *a1;
  if ( v1 )
    result = sub_14001FB04(v1);
  else
    result = 0;
  return result;
}

//----- (0000000140010DEC) ----------------------------------------------------
__int64 __fastcall sub_140010DEC(_DWORD *a1)
{
  _DWORD *v1; // rbx
  __int64 result; // rax

  v1 = a1;
  *a1 = sub_14001FB7C();
  v1[1] = dword_140037E44;
  result = (unsigned int)dword_140037E48;
  v1[2] = dword_140037E48;
  return result;
}
// 140037E44: using guessed type int dword_140037E44;
// 140037E48: using guessed type int dword_140037E48;

//----- (0000000140010E14) ----------------------------------------------------
char __fastcall sub_140010E14(__int64 *a1, int a2, __int64 a3)
{
  __int64 v3; // rbp
  int v4; // esi
  __int64 *v5; // rbx
  __int64 v6; // rcx
  __int64 v7; // rdx
  char v8; // di
  volatile signed __int32 *v9; // rax
  __int64 v11; // [rsp+20h] [rbp-28h]
  char v12; // [rsp+68h] [rbp+20h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !byte_14002B168 )
    return 0;
  v6 = *a1;
  if ( !v6 )
    return 0;
  v7 = v5[1];
  if ( *(_QWORD *)(v7 + 40) )
    return 0;
  sub_14001F7F8(v6, *(_QWORD *)(v7 + 32));
  v8 = sub_14001FB84(*v5, v4, (_DWORD *)v5 + 5, &v12);
  if ( v8
    || v12
    && (v11 = 0i64, (signed int)sub_140010CD0(v5, v3, &v11) >= 0)
    && (v8 = sub_14001FB84(*v5, v4, (_DWORD *)v5 + 5, 0i64), FltClose(v11), v8) )
  {
    v9 = &dword_140037E44;
  }
  else
  {
    *((_BYTE *)v5 + 16) = 1;
    v9 = &dword_140037E48;
  }
  _InterlockedIncrement(v9);
  return v8;
}
// 14002156E: using guessed type __int64 __fastcall FltClose(_QWORD);
// 14002B168: using guessed type char byte_14002B168;
// 140037E44: using guessed type int dword_140037E44;
// 140037E48: using guessed type int dword_140037E48;

//----- (0000000140010EF0) ----------------------------------------------------
char __fastcall sub_140010EF0(__int64 *a1, char *a2)
{
  __int64 v2; // rcx

  v2 = *a1;
  if ( !v2 )
    return 0;
  *a2 = sub_14001FC48(v2);
  return 1;
}

//----- (0000000140010F14) ----------------------------------------------------
void __fastcall sub_140010F14(__int64 *a1, __m128i *a2, __int64 a3)
{
  __int64 v3; // rcx

  v3 = *a1;
  if ( v3 )
    sub_14001FD1C(v3, a2, a3);
}

//----- (0000000140010F2C) ----------------------------------------------------
void __fastcall sub_140010F2C(__int64 *a1)
{
  __int64 *v1; // rdi
  __int64 v2; // rcx
  __int64 *v3; // r8
  __int64 v4; // rdx
  _BYTE *v5; // rax
  __int64 v6; // rbx
  int v7; // esi
  __int64 v8; // rbx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]
  __int64 v10; // [rsp+40h] [rbp+8h]

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    v10 = 0i64;
    v3 = (__int64 *)v1[1];
    v4 = v3[5];
    v5 = (_BYTE *)v3[4];
    if ( v4 )
    {
      if ( !v5[75] && !v5[76] )
        goto LABEL_19;
      v6 = sub_140021200(v3[3], v4);
      if ( v10 )
        FltReleaseContext(v10);
      v10 = v6;
      if ( !v6 )
      {
        v7 = sub_140021110(v1[1], &v10);
        if ( v7 == -1071906814 )
        {
          v8 = sub_140021200(*(_QWORD *)(v1[1] + 24), *(_QWORD *)(v1[1] + 40));
          if ( v10 )
            FltReleaseContext(v10);
          v10 = v8;
        }
        else
        {
          v8 = v10;
        }
        if ( !v8 )
        {
          LODWORD(BugCheckParameter3) = v7;
          sub_140006BB4(0x195ui64, 0x99ui64, 0i64, 0xE03D0044, BugCheckParameter3, 0);
          goto LABEL_19;
        }
      }
      v2 = *v1;
    }
    else if ( v5[78] )
    {
      return;
    }
    sub_14001FE9C(v2, (_BYTE **)&v10);
LABEL_19:
    if ( v10 )
      FltReleaseContext(v10);
  }
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);

//----- (0000000140011040) ----------------------------------------------------
void __fastcall sub_140011040(_DWORD **a1)
{
  _DWORD **v1; // rax
  _DWORD *v2; // rcx

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    if ( !*((_QWORD *)v1[1] + 5) )
      sub_14001FDB0(v2);
  }
}

//----- (0000000140011064) ----------------------------------------------------
void __fastcall sub_140011064(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rcx
  __int64 v3; // rdx
  __int64 v4; // rax
  __int64 v5; // rbx
  int v6; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(v2 + 40);
  if ( v3 )
  {
    v4 = sub_140021200(*(_QWORD *)(v2 + 24), v3);
    v5 = v4;
    if ( v4 )
    {
      v6 = FltRollbackEnlistment(*(_QWORD *)(*(_QWORD *)(v1 + 8) + 24i64), *(_QWORD *)(*(_QWORD *)(v1 + 8) + 40i64), v4);
      if ( v6 < 0 )
      {
        LODWORD(BugCheckParameter3) = v6;
        sub_140006BB4(0x195ui64, 0x166ui64, 0i64, 0xE03D0045, BugCheckParameter3, 0);
      }
      FltReleaseContext(v5);
    }
  }
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002157A: using guessed type __int64 __fastcall FltRollbackEnlistment(_QWORD, _QWORD, _QWORD);

//----- (00000001400110DC) ----------------------------------------------------
void __fastcall sub_1400110DC(__int64 *a1, char a2)
{
  __int64 v2; // rcx

  v2 = *a1;
  if ( v2 )
    sub_14001FE58(v2, a2);
}

//----- (00000001400110F4) ----------------------------------------------------
void __fastcall sub_1400110F4(__int64 *a1)
{
  __int64 *v1; // rax
  __int64 v2; // rcx

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    if ( !*(_QWORD *)(v1[1] + 40) )
      sub_14001FF74(v2);
  }
}

//----- (0000000140011118) ----------------------------------------------------
void __fastcall sub_140011118(__int64 *a1)
{
  __int64 *v1; // rax
  __int64 v2; // rcx

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    if ( !*(_QWORD *)(v1[1] + 40) )
      sub_14001FFCC(v2);
  }
}

//----- (000000014001113C) ----------------------------------------------------
void __fastcall sub_14001113C(_DWORD **a1)
{
  _DWORD **v1; // rax
  _DWORD *v2; // rcx

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    if ( !*((_QWORD *)v1[1] + 5) )
      sub_140020028(v2);
  }
}

//----- (0000000140011168) ----------------------------------------------------
__int64 __fastcall sub_140011168(__int64 a1, _DWORD *a2)
{
  _DWORD *v2; // rdi
  __int64 v3; // rbx

  *(_QWORD *)(a1 + 24) = 0i64;
  v2 = a2;
  v3 = a1;
  KeInitializeEvent((PRKEVENT)a1, 0, 0);
  if ( v2 && *v2 & 1 )
    sub_140011338(v3, (__int64)v2);
  return v3;
}

//----- (00000001400111B4) ----------------------------------------------------
void __fastcall sub_1400111B4(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  if ( *(_QWORD *)(a1 + 24) )
  {
    ExAcquireFastMutex(&stru_14002B170);
    *(_QWORD *)(*(_QWORD *)(v1 + 24) + 48i64) = 0i64;
    FltClearCancelCompletion(*(_QWORD *)(v1 + 24));
    ExReleaseFastMutex(&stru_14002B170);
  }
}
// 14002159E: using guessed type __int64 __fastcall FltClearCancelCompletion(_QWORD);

//----- (0000000140011210) ----------------------------------------------------
void __fastcall sub_140011210(__int64 a1)
{
  __int64 v1; // rbx
  struct _KEVENT *v2; // rcx

  v1 = a1;
  ExAcquireFastMutex(&stru_14002B170);
  v2 = *(struct _KEVENT **)(v1 + 48);
  if ( v2 )
    KeSetEvent(v2, 0, 0);
  ExReleaseFastMutex(&stru_14002B170);
}

//----- (0000000140011260) ----------------------------------------------------
char __fastcall sub_140011260(__int64 a1, __int64 a2)
{
  int v2; // eax
  __int64 v3; // rbx
  __int64 v4; // rsi
  int v5; // edi
  int v6; // eax
  char result; // al
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]
  LARGE_INTEGER Interval; // [rsp+58h] [rbp+10h]

  v2 = *(_DWORD *)(a2 + 80);
  v3 = a2;
  v4 = a1;
  if ( _bittest(&v2, 0x12u) )
  {
    Interval.QuadPart = -200000i64;
    v5 = 0;
    while ( 1 )
    {
      if ( v5 == 500 )
      {
        LODWORD(BugCheckParameter3) = 258;
        sub_140006BB4(0x456ui64, 0x66ui64, 0i64, 0xE03D001E, BugCheckParameter3, v3 + 88);
      }
      if ( (unsigned __int8)PsIsThreadTerminating(__readgsqword(0x188u)) || KeReadStateEvent(&stru_140039590) )
        break;
      KeDelayExecutionThread(0, 0, &Interval);
      v6 = *(_DWORD *)(v3 + 80);
      ++v5;
      if ( !_bittest(&v6, 0x12u) )
        goto LABEL_8;
    }
    result = 0;
  }
  else
  {
LABEL_8:
    FltCancelFileOpen(v4, v3);
    result = 1;
  }
  return result;
}
// 140021586: using guessed type __int64 __fastcall FltCancelFileOpen(_QWORD, _QWORD);
// 1400283E0: using guessed type __int64 __fastcall PsIsThreadTerminating(_QWORD);

//----- (0000000140011338) ----------------------------------------------------
__int64 __fastcall sub_140011338(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 result; // rax

  v2 = a2;
  *(_QWORD *)(a2 + 48) = a1;
  v3 = a1;
  result = FltSetCancelCompletion(a2, sub_140011210);
  if ( (signed int)result >= 0 )
    *(_QWORD *)(v3 + 24) = v2;
  else
    *(_QWORD *)(v2 + 48) = 0i64;
  return result;
}
// 140021592: using guessed type __int64 __fastcall FltSetCancelCompletion(_QWORD, _QWORD);

//----- (0000000140011378) ----------------------------------------------------
__int64 __fastcall sub_140011378(__int64 a1, __int64 a2, _BYTE *a3)
{
  char v3; // si
  _BYTE *v4; // r14
  __int64 v5; // r15
  __int64 v6; // rbx
  __int64 result; // rax
  unsigned int v8; // edi
  __m128 *v9; // [rsp+40h] [rbp-10h]
  char v10; // [rsp+48h] [rbp-8h]
  __int64 v11; // [rsp+98h] [rbp+48h]

  v11 = 0i64;
  v3 = 0;
  v4 = a3;
  v5 = a2;
  v6 = a1;
  if ( byte_14002B1A8 )
  {
    result = FltGetEcpListFromCallbackData(a1, a2, &v11);
    if ( (signed int)result < 0 )
      return result;
    if ( !v11 )
    {
      result = FltAllocateExtraCreateParameterList(v6, 0i64, &v11);
      if ( (signed int)result < 0 )
        return result;
      v3 = 1;
    }
    v8 = FltAllocateExtraCreateParameter(v6, &unk_140028C28, 36i64);
    if ( (v8 & 0x80000000) != 0 )
    {
      if ( v3 )
      {
LABEL_8:
        FltFreeExtraCreateParameterList(v6, v11);
        return v8;
      }
      return v8;
    }
    sub_140021DC0(v9, 0, 0x24ui64);
    LOWORD(v9->m128_u64[0]) = 36;
    v8 = FltInsertExtraCreateParameter(v6, v11, v9);
    if ( (v8 & 0x80000000) == 0 )
    {
      if ( !v3 || (v8 = FltSetEcpListIntoCallbackData(v6, v5, v11), (v8 & 0x80000000) == 0) )
      {
        *v4 = 1;
        return v8;
      }
      if ( (signed int)FltRemoveExtraCreateParameter(v6, v11, &unk_140028C28, &v10, 0i64) >= 0 )
      {
        FltFreeExtraCreateParameter(v6, v9);
        goto LABEL_8;
      }
      return v8;
    }
    FltFreeExtraCreateParameter(v6, v9);
    if ( v3 )
      FltFreeExtraCreateParameterList(v6, v11);
    if ( v8 != -1073741811 )
      return v8;
  }
  *v4 = 0;
  return 0i64;
}
// 1400215AA: using guessed type __int64 __fastcall FltAllocateExtraCreateParameterList(_QWORD, _QWORD, _QWORD);
// 1400215B6: using guessed type __int64 __fastcall FltAllocateExtraCreateParameter(_QWORD, _QWORD, _QWORD);
// 1400215C2: using guessed type __int64 __fastcall FltInsertExtraCreateParameter(_QWORD, _QWORD, _QWORD);
// 1400215DA: using guessed type __int64 __fastcall FltRemoveExtraCreateParameter(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400215E6: using guessed type __int64 __fastcall FltFreeExtraCreateParameterList(_QWORD, _QWORD);
// 1400215F2: using guessed type __int64 __fastcall FltFreeExtraCreateParameter(_QWORD, _QWORD);
// 1400215FE: using guessed type __int64 __fastcall FltGetEcpListFromCallbackData(_QWORD, _QWORD, _QWORD);
// 14002160A: using guessed type __int64 __fastcall FltSetEcpListIntoCallbackData(_QWORD, _QWORD, _QWORD);
// 14002B1A8: using guessed type char byte_14002B1A8;

//----- (00000001400114F4) ----------------------------------------------------
char __fastcall sub_1400114F4(__int64 a1, __int64 a2, char a3, _WORD *a4)
{
  _WORD *v4; // rdi
  bool v5; // zf
  char v6; // si
  __int64 v7; // rbx
  __int64 v9; // [rsp+30h] [rbp-18h]
  __int64 v10; // [rsp+38h] [rbp-10h]
  char v11; // [rsp+68h] [rbp+20h]

  v4 = a4;
  v5 = byte_14002B1A8 == 0;
  v6 = a3;
  v7 = a1;
  *a4 = 0;
  if ( v5
    || (signed int)FltGetEcpListFromCallbackData(a1, a2, &v10) < 0
    || !v10
    || (signed int)FltFindExtraCreateParameter(v7, v10, &unk_140028C28, &v9, &v11) < 0 )
  {
    return 0;
  }
  *v4 = *(_WORD *)(v9 + 2);
  if ( v6 )
  {
    if ( (signed int)FltRemoveExtraCreateParameter(v7, v10, &unk_140028C28, &v9, &v11) >= 0 )
      FltFreeExtraCreateParameter(v7, v9);
  }
  return 1;
}
// 1400215CE: using guessed type __int64 __fastcall FltFindExtraCreateParameter(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400215DA: using guessed type __int64 __fastcall FltRemoveExtraCreateParameter(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400215F2: using guessed type __int64 __fastcall FltFreeExtraCreateParameter(_QWORD, _QWORD);
// 1400215FE: using guessed type __int64 __fastcall FltGetEcpListFromCallbackData(_QWORD, _QWORD, _QWORD);
// 14002B1A8: using guessed type char byte_14002B1A8;

//----- (00000001400115C0) ----------------------------------------------------
void __fastcall sub_1400115C0(char a1)
{
  byte_14002B1A8 = a1;
}
// 14002B1A8: using guessed type char byte_14002B1A8;

//----- (00000001400115D0) ----------------------------------------------------
char __fastcall sub_1400115D0(__int64 a1, _QWORD *a2, unsigned int a3, __int64 a4, __int64 a5, void *a6, __m128i *a7)
{
  unsigned int v7; // er14
  _QWORD *v8; // r15
  __int64 v9; // rdi
  char v10; // bp
  struct _FILE_OBJECT *v11; // rsi
  char v12; // al
  int v13; // edx

  v7 = a3;
  v8 = a2;
  v9 = a1;
  v10 = 0;
  v11 = (struct _FILE_OBJECT *)sub_1400190CC(a1);
  if ( v11 || (v11 = (struct _FILE_OBJECT *)sub_14000AA10(v9), v10 = 1, v11) )
  {
    v12 = ExGetPreviousMode();
    sub_1400124CC(v11, v8, v7, a6, a7, v12);
    ObfDereferenceObject(v11);
    v13 = a7->m128i_i64[0];
    if ( (a7->m128i_i64[0] & 0xC0000000) == -1073741824 )
    {
      if ( v10 )
        sub_14000AA8C(v9, v13);
      else
        sub_140019F50(v9, v13);
    }
  }
  else
  {
    a7->m128i_i64[1] = 0i64;
    LODWORD(a7->m128i_i64[0]) = -1073741642;
  }
  return 1;
}

//----- (00000001400116B0) ----------------------------------------------------
char __fastcall sub_1400116B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  *(_QWORD *)(a7 + 8) = 0i64;
  *(_DWORD *)a7 = -1073741790;
  return 1;
}

//----- (00000001400116CC) ----------------------------------------------------
void __fastcall sub_1400116CC(PDEVICE_OBJECT *a1)
{
  PDEVICE_OBJECT *v1; // rbx
  UNICODE_STRING DestinationString; // [rsp+20h] [rbp-18h]

  v1 = a1;
  RtlInitUnicodeString(&DestinationString, L"\\DosDevices\\SAVOnAccess");
  IoDeleteSymbolicLink(&DestinationString);
  if ( *v1 )
    IoDeleteDevice(*v1);
}

//----- (0000000140011718) ----------------------------------------------------
bool sub_140011718()
{
  return _InterlockedCompareExchange(&dword_140037E50, 0, 0) == 0;
}
// 140037E50: using guessed type int dword_140037E50;

//----- (0000000140011728) ----------------------------------------------------
__int64 __fastcall sub_140011728(PDEVICE_OBJECT *DeviceObject, PDRIVER_OBJECT DriverObject)
{
  struct _DRIVER_OBJECT *v2; // rdi
  PDEVICE_OBJECT *v3; // rbx
  NTSTATUS v4; // eax
  ULONG v5; // er9
  ULONG_PTR v6; // rdx
  ULONG_PTR DeviceCharacteristics; // [rsp+20h] [rbp-48h]
  UNICODE_STRING DestinationString; // [rsp+40h] [rbp-28h]
  UNICODE_STRING SymbolicLinkName; // [rsp+50h] [rbp-18h]

  v2 = DriverObject;
  DriverObject->MajorFunction[0] = (PDRIVER_DISPATCH)sub_140011920;
  v3 = DeviceObject;
  DriverObject->MajorFunction[18] = (PDRIVER_DISPATCH)sub_140011860;
  DriverObject->MajorFunction[2] = (PDRIVER_DISPATCH)sub_1400118B0;
  DriverObject->MajorFunction[14] = (PDRIVER_DISPATCH)sub_1400179B0;
  DriverObject->MajorFunction[3] = (PDRIVER_DISPATCH)sub_140011A10;
  DriverObject->MajorFunction[15] = (PDRIVER_DISPATCH)sub_140007260;
  DriverObject->FastIoDispatch = (PFAST_IO_DISPATCH)&unk_14002B1B0;
  RtlInitUnicodeString(&DestinationString, L"\\Device\\SAVOnAccess");
  v4 = IoCreateDevice(v2, 0, &DestinationString, 0x22u, 0, 0, v3);
  if ( v4 < 0 )
  {
    v5 = -532873164;
    v6 = 126i64;
LABEL_3:
    LODWORD(DeviceCharacteristics) = v4;
    sub_140006BB4(0x192ui64, v6, 0i64, v5, DeviceCharacteristics, 0);
    return 3221225473i64;
  }
  RtlInitUnicodeString(&SymbolicLinkName, L"\\DosDevices\\SAVOnAccess");
  IoDeleteSymbolicLink(&SymbolicLinkName);
  v4 = IoCreateSymbolicLink(&SymbolicLinkName, &DestinationString);
  if ( v4 < 0 )
  {
    v5 = -532873210;
    v6 = 139i64;
    goto LABEL_3;
  }
  return 0i64;
}

//----- (0000000140011860) ----------------------------------------------------
__int64 __fastcall sub_140011860(__int64 a1, struct _IRP *a2)
{
  struct _IRP *v2; // rbx

  v2 = a2;
  sub_140019458((__int64)a2->Tail.Overlay.CurrentStackLocation->FileObject, 1);
  v2->IoStatus.Status = 0;
  v2->IoStatus.Information = 0i64;
  IofCompleteRequest(v2, 0);
  _InterlockedDecrement(&dword_140037E50);
  return 0i64;
}
// 140037E50: using guessed type int dword_140037E50;

//----- (00000001400118B0) ----------------------------------------------------
__int64 __fastcall sub_1400118B0(__int64 a1, struct _IRP *a2)
{
  struct _IO_STACK_LOCATION *v2; // rdi
  struct _IRP *v3; // rbx
  __int64 v4; // rcx
  __int64 v5; // rcx

  v2 = a2->Tail.Overlay.CurrentStackLocation;
  v3 = a2;
  v4 = (__int64)v2->FileObject;
  if ( v4 )
  {
    sub_140019458(v4, 0);
    v4 = (__int64)v2->FileObject;
  }
  sub_1400065D4(v4);
  sub_140004A84((__int64)v2->FileObject);
  v5 = (__int64)v2->FileObject;
  if ( v5 )
    sub_14000A480(v5);
  v3->IoStatus.Status = 0;
  v3->IoStatus.Information = 0i64;
  IofCompleteRequest(v3, 0);
  return 0i64;
}

//----- (0000000140011920) ----------------------------------------------------
__int64 __fastcall sub_140011920(__int64 a1, struct _IRP *a2)
{
  struct _IO_STACK_LOCATION *v2; // rbx
  struct _IRP *v3; // rdi
  unsigned int v4; // ebx
  PFILE_OBJECT v5; // rbx

  v2 = a2->Tail.Overlay.CurrentStackLocation;
  v3 = a2;
  if ( !KeReadStateEvent(&stru_140039590) )
  {
    v5 = v2->FileObject;
    *(_WORD *)&v5->WriteAccess = 0;
    v5->ReadAccess = 0;
    if ( RtlCompareUnicodeString(&v5->FileName, &stru_14002B290, 1u) || !(v5->Flags & 2) )
    {
      if ( v5->FileName.Length <= 0u )
      {
        if ( sub_1400084B4() )
          v5->DeleteAccess = 1;
        if ( sub_140008A68() )
          v5->WriteAccess = 1;
        goto LABEL_15;
      }
    }
    else if ( sub_1400084B4() && sub_1400192EC() )
    {
      v5->PrivateCacheMap = (PVOID)-1i64;
      v5->ReadAccess = 1;
LABEL_15:
      _InterlockedIncrement(&dword_140037E50);
      v4 = 0;
      v3->IoStatus.Status = 0;
      goto LABEL_16;
    }
    v4 = -1073741790;
    goto LABEL_10;
  }
  v4 = -1073741823;
LABEL_10:
  v3->IoStatus.Status = v4;
LABEL_16:
  v3->IoStatus.Information = 0i64;
  IofCompleteRequest(v3, 0);
  return v4;
}
// 140037E50: using guessed type int dword_140037E50;

//----- (0000000140011A10) ----------------------------------------------------
__int64 __fastcall sub_140011A10(__int64 a1, struct _IRP *a2)
{
  struct _IO_STACK_LOCATION *v2; // rdi
  struct _IRP *v3; // rbx
  signed int v4; // er8
  bool v5; // al
  unsigned int v7; // [rsp+38h] [rbp+10h]

  v2 = a2->Tail.Overlay.CurrentStackLocation;
  v3 = a2;
  v7 = sub_14001907C((__int64)v2->FileObject);
  v4 = v7;
  if ( (v7 & 0xC0000000) != -1073741824 )
  {
    v5 = sub_14000A524((__int64)v2->FileObject, &v7);
    v4 = v7;
    if ( !v5 )
      v4 = -1073741822;
    v7 = v4;
  }
  v3->IoStatus.Information = 0i64;
  v3->IoStatus.Status = v4;
  IofCompleteRequest(v3, 0);
  return v7;
}

//----- (0000000140011A90) ----------------------------------------------------
bool __fastcall sub_140011A90(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v4; // [rsp+50h] [rbp+18h]
  char v5; // [rsp+58h] [rbp+20h]

  v2 = a1;
  return (signed int)FltGetEcpListFromCallbackData(a1, a2, &v4) >= 0
      && v4
      && (signed int)FltFindExtraCreateParameter(v2, v4, &unk_140028C38, &v5, 0i64) >= 0;
}
// 1400215CE: using guessed type __int64 __fastcall FltFindExtraCreateParameter(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400215FE: using guessed type __int64 __fastcall FltGetEcpListFromCallbackData(_QWORD, _QWORD, _QWORD);

//----- (0000000140011ADC) ----------------------------------------------------
char __fastcall sub_140011ADC(__int64 a1)
{
  char v1; // bl
  unsigned int v2; // eax
  PDEVICE_OBJECT v3; // rax
  struct _DEVICE_OBJECT *v4; // rdi
  struct _IRP *v5; // rax
  NTSTATUS v6; // eax
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+50h] [rbp-1h]
  struct _KEVENT Event; // [rsp+60h] [rbp+Fh]
  char OutputBuffer; // [rsp+78h] [rbp+27h]
  __int64 v12; // [rsp+80h] [rbp+2Fh]

  v1 = 0;
  v2 = FltGetDiskDeviceObject(a1, &IoStatusBlock);
  if ( (v2 & 0x80000000) == 0 )
  {
    v3 = IoGetAttachedDeviceReference(0i64);
    IoStatusBlock.Information = 0i64;
    v4 = v3;
    sub_140021DC0((__m128 *)&OutputBuffer, 0, 0x20ui64);
    KeInitializeEvent(&Event, 0, 0);
    v5 = IoBuildDeviceIoControlRequest(0x70214u, v4, 0i64, 0, &OutputBuffer, 0x20u, 0, &Event, &IoStatusBlock);
    if ( v5 )
    {
      v6 = IofCallDriver(v4, v5);
      if ( v6 == 259 )
      {
        KeWaitForSingleObject(&Event, 0, 0, 0, 0i64);
        v6 = IoStatusBlock.Status;
      }
      if ( v6 >= 0 )
      {
        v1 = ((unsigned __int8)v12 >> 1) & 1;
        if ( v12 & 2 )
        {
          if ( v12 & 4 )
            v1 = 0;
        }
      }
    }
    else
    {
      DbgPrint("Failed to allocate Irp, status 0x%x\n", 3221225626i64);
    }
    if ( v4 )
    {
      KeEnterCriticalRegion();
      ObfDereferenceObject(v4);
      KeLeaveCriticalRegion();
    }
  }
  else
  {
    DbgPrint("Failed to get disk object from volume, status 0x%x\n", v2);
  }
  return v1;
}
// 140021616: using guessed type __int64 __fastcall FltGetDiskDeviceObject(_QWORD, _QWORD);

//----- (0000000140011C84) ----------------------------------------------------
_QWORD *__fastcall sub_140011C84(__int64 a1, __int64 a2, __int64 a3)
{
  CCHAR v3; // cl
  __int64 v4; // rbx
  __int64 v5; // rdi
  _QWORD *result; // rax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]

  v3 = *(_BYTE *)(a1 + 76);
  v4 = a3;
  v5 = a2;
  if ( qword_140037E60 )
    result = (_QWORD *)sub_140021A40((__int64 (*)(void))qword_140037E60);
  else
    result = IoAllocateIrp(v3, 0);
  if ( result )
  {
    result[3] = 0i64;
    result[1] = 0i64;
    result[14] = v5;
  }
  else
  {
    *(_QWORD *)(v4 + 8) = 0i64;
    *(_DWORD *)v4 = -1073741670;
    LODWORD(BugCheckParameter3) = -1073741670;
    sub_140006BB4(0x143ui64, 0x1F0ui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
    result = 0i64;
  }
  return result;
}
// 140037E60: using guessed type __int64 qword_140037E60;

//----- (0000000140011D14) ----------------------------------------------------
void __fastcall sub_140011D14(struct _FILE_OBJECT *a1, __m128 *a2, __m128i *a3)
{
  __m128i *v3; // rdi
  __m128 *v4; // rbp
  struct _FILE_OBJECT *v5; // r14
  PDEVICE_OBJECT v6; // rsi
  PFAST_IO_DISPATCH v7; // rbx
  __int64 (*v8)(void); // rax
  __m128i *v9; // rax
  __m128i *v10; // rbx
  __int64 v11; // rax
  ULONG_PTR InvokeOnSuccess; // [rsp+20h] [rbp-48h]
  struct _KEVENT Event; // [rsp+40h] [rbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = IoGetRelatedDeviceObject(a1);
  v7 = v6->DriverObject->FastIoDispatch;
  sub_140021DC0(v4, 0, 0x28ui64);
  if ( !v7
    || v7->SizeOfFastIoDispatch < 0x28
    || (v8 = (__int64 (*)(void))v7->FastIoQueryBasicInfo) == 0i64
    || !(unsigned __int8)sub_140021A40(v8) )
  {
    if ( qword_140037E60 )
      v9 = (__m128i *)sub_140021A40((__int64 (*)(void))qword_140037E60);
    else
      v9 = (__m128i *)IoAllocateIrp(v6->StackSize, 0);
    v10 = v9;
    if ( v9 )
    {
      v9[1].m128i_i64[1] = (__int64)v4;
      v9[9].m128i_i64[1] = __readgsqword(0x188u);
      v11 = v9[11].m128i_i64[1];
      v10[4].m128i_i8[0] = 0;
      v10[1].m128i_i32[0] = 20;
      *(_BYTE *)(v11 - 72) = 5;
      *(_QWORD *)(v11 - 32) = v6;
      *(_QWORD *)(v11 - 24) = v5;
      *(_DWORD *)(v11 - 64) = 40;
      *(_DWORD *)(v11 - 56) = 4;
      KeInitializeEvent(&Event, SynchronizationEvent, 0);
      if ( IoSetCompletionRoutineEx(v6, (PIRP)v10, (PIO_COMPLETION_ROUTINE)CompletionRoutine, &Event, 1u, 1u, 1u) >= 0 )
      {
        if ( IofCallDriver(v6, (PIRP)v10) == 259 )
        {
          while ( KeWaitForSingleObject(&Event, 0, 0, 1u, 0i64) )
            ;
        }
        _mm_storeu_si128(v3, v10[3]);
      }
      else
      {
        LODWORD(InvokeOnSuccess) = -1073741670;
        sub_140006BB4(0x143ui64, 0x182ui64, 0i64, 0xE03D000B, InvokeOnSuccess, 0);
        if ( dword_140035180 & 1 )
          sub_140007A38((__int64)L"GetFileBasicInformation: Failed to set IoCompletion routine");
        v3->m128i_i64[1] = 0i64;
        LODWORD(v3->m128i_i64[0]) = -1073741670;
      }
      IoFreeIrp((PIRP)v10);
    }
    else
    {
      v3->m128i_i64[1] = 0i64;
      LODWORD(v3->m128i_i64[0]) = -1073741670;
    }
  }
}
// 140025220: using guessed type wchar_t aGetfilebasicin[60];
// 140035180: using guessed type int dword_140035180;
// 140037E60: using guessed type __int64 qword_140037E60;

//----- (0000000140011F10) ----------------------------------------------------
void __fastcall sub_140011F10(struct _FILE_OBJECT *a1, __int64 a2, int a3, __m128i *a4)
{
  __m128i *v4; // rdi
  int v5; // er14
  __int64 v6; // r15
  struct _FILE_OBJECT *v7; // rbp
  PDEVICE_OBJECT v8; // rsi
  __m128i *v9; // rax
  __m128i *v10; // rbx
  __int64 v11; // rax
  ULONG_PTR InvokeOnSuccess; // [rsp+20h] [rbp-58h]
  struct _KEVENT Event; // [rsp+40h] [rbp-38h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = IoGetRelatedDeviceObject(a1);
  if ( qword_140037E60 )
    v9 = (__m128i *)sub_140021A40((__int64 (*)(void))qword_140037E60);
  else
    v9 = (__m128i *)IoAllocateIrp(v8->StackSize, 0);
  v10 = v9;
  if ( v9 )
  {
    v9[1].m128i_i64[1] = v6;
    v9[9].m128i_i64[1] = __readgsqword(0x188u);
    v11 = v9[11].m128i_i64[1];
    v10[4].m128i_i8[0] = 0;
    v10[1].m128i_i32[0] = 20;
    *(_BYTE *)(v11 - 72) = 5;
    *(_QWORD *)(v11 - 32) = v8;
    *(_QWORD *)(v11 - 24) = v7;
    *(_DWORD *)(v11 - 64) = v5;
    *(_DWORD *)(v11 - 56) = 9;
    KeInitializeEvent(&Event, SynchronizationEvent, 0);
    if ( IoSetCompletionRoutineEx(v8, (PIRP)v10, (PIO_COMPLETION_ROUTINE)CompletionRoutine, &Event, 1u, 1u, 1u) >= 0 )
    {
      if ( IofCallDriver(v8, (PIRP)v10) == 259 )
      {
        while ( KeWaitForSingleObject(&Event, 0, 0, 1u, 0i64) )
          ;
      }
      _mm_storeu_si128(v4, v10[3]);
    }
    else
    {
      LODWORD(InvokeOnSuccess) = -1073741670;
      sub_140006BB4(0x143ui64, 0x1CEui64, 0i64, 0xE03D000B, InvokeOnSuccess, 0);
      if ( dword_140035180 & 1 )
        sub_140007A38((__int64)L"GetFileNameInformation: Failed to set IoCompletion routine");
      v4->m128i_i64[1] = 0i64;
      LODWORD(v4->m128i_i64[0]) = -1073741670;
    }
    IoFreeIrp((PIRP)v10);
  }
  else
  {
    v4->m128i_i64[1] = 0i64;
    LODWORD(v4->m128i_i64[0]) = -1073741670;
    if ( dword_140035180 & 1 )
      sub_140007A38((__int64)L"GetFileNameInformation: Failed to allocate an IRP");
  }
}
// 1400252A0: using guessed type wchar_t aGetfilenameinf[50];
// 140025310: using guessed type wchar_t aGetfilenameinf_0[59];
// 140035180: using guessed type int dword_140035180;
// 140037E60: using guessed type __int64 qword_140037E60;

//----- (00000001400120E0) ----------------------------------------------------
void __fastcall sub_1400120E0(struct _FILE_OBJECT *a1, __m128 *a2, __m128i *a3)
{
  __m128i *v3; // rdi
  __m128 *v4; // rbx
  struct _FILE_OBJECT *v5; // rsi
  PFAST_IO_DISPATCH v6; // rbp
  __int64 (*v7)(void); // rax
  unsigned __int64 v8; // [rsp+30h] [rbp-78h]
  unsigned __int64 v9; // [rsp+38h] [rbp-70h]
  unsigned __int64 v10; // [rsp+40h] [rbp-68h]
  unsigned __int64 v11; // [rsp+48h] [rbp-60h]
  int v12; // [rsp+50h] [rbp-58h]
  unsigned __int64 v13; // [rsp+58h] [rbp-50h]
  unsigned __int64 v14; // [rsp+60h] [rbp-48h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = IoGetRelatedDeviceObject(a1)->DriverObject->FastIoDispatch;
  sub_140021DC0(v4, 0, 0x38ui64);
  if ( !v6
    || v6->SizeOfFastIoDispatch < 0x78
    || (v7 = (__int64 (*)(void))v6->FastIoQueryNetworkOpenInfo) == 0i64
    || !(unsigned __int8)sub_140021A40(v7) )
  {
    sub_140011D14(v5, (__m128 *)&v8, v3);
    if ( !LODWORD(v3->m128i_i64[0]) )
    {
      sub_1400121E8(v5, &v13, v3);
      if ( !LODWORD(v3->m128i_i64[0]) )
      {
        v4->m128_u64[0] = v8;
        v4->m128_u64[1] = v9;
        v4[1].m128_u64[0] = v10;
        v4[1].m128_u64[1] = v11;
        v4[2].m128_u64[0] = v13;
        v4[2].m128_u64[1] = v14;
        v4[3].m128_i32[0] = v12;
        LODWORD(v3->m128i_i64[0]) = 0;
        v3->m128i_i64[1] = 56i64;
      }
    }
  }
}

//----- (00000001400121E8) ----------------------------------------------------
void __fastcall sub_1400121E8(struct _FILE_OBJECT *a1, _QWORD *a2, __m128i *a3)
{
  __m128i *v3; // rdi
  _QWORD *v4; // r14
  struct _FILE_OBJECT *v5; // rbp
  PDEVICE_OBJECT v6; // rax
  struct _DEVICE_OBJECT *v7; // rsi
  PFAST_IO_DISPATCH v8; // rax
  __int64 (*v9)(void); // rax
  __m128i *v10; // rax
  __m128i *v11; // rbx
  __int64 v12; // rax
  ULONG_PTR InvokeOnSuccess; // [rsp+20h] [rbp-48h]
  ULONG_PTR InvokeOnSuccessa; // [rsp+20h] [rbp-48h]
  struct _KEVENT Event; // [rsp+40h] [rbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = IoGetRelatedDeviceObject(a1);
  v7 = v6;
  v8 = v6->DriverObject->FastIoDispatch;
  *v4 = 0i64;
  v4[1] = 0i64;
  v4[2] = 0i64;
  if ( !v8
    || v8->SizeOfFastIoDispatch < 0x30
    || (v9 = (__int64 (*)(void))v8->FastIoQueryStandardInfo) == 0i64
    || (HIDWORD(InvokeOnSuccess) = HIDWORD(v7), !(unsigned __int8)sub_140021A40(v9)) )
  {
    if ( qword_140037E60 )
      v10 = (__m128i *)sub_140021A40((__int64 (*)(void))qword_140037E60);
    else
      v10 = (__m128i *)IoAllocateIrp(v7->StackSize, 0);
    v11 = v10;
    if ( v10 )
    {
      v10[1].m128i_i64[1] = (__int64)v4;
      v10[9].m128i_i64[1] = __readgsqword(0x188u);
      v12 = v10[11].m128i_i64[1];
      v11[4].m128i_i8[0] = 0;
      v11[1].m128i_i32[0] = 20;
      *(_BYTE *)(v12 - 72) = 5;
      *(_QWORD *)(v12 - 32) = v7;
      *(_QWORD *)(v12 - 24) = v5;
      *(_DWORD *)(v12 - 64) = 24;
      *(_DWORD *)(v12 - 56) = 5;
      KeInitializeEvent(&Event, SynchronizationEvent, 0);
      if ( IoSetCompletionRoutineEx(v7, (PIRP)v11, (PIO_COMPLETION_ROUTINE)CompletionRoutine, &Event, 1u, 1u, 1u) >= 0 )
      {
        if ( IofCallDriver(v7, (PIRP)v11) == 259 )
        {
          while ( KeWaitForSingleObject(&Event, 0, 0, 1u, 0i64) )
            ;
        }
        _mm_storeu_si128(v3, v11[3]);
      }
      else
      {
        LODWORD(InvokeOnSuccessa) = -1073741670;
        sub_140006BB4(0x143ui64, 0x126ui64, 0i64, 0xE03D000B, InvokeOnSuccessa, 0);
        if ( dword_140035180 & 1 )
          sub_140007A38((__int64)L"GetFileStandardInformation: Failed to set IoCompletion routine");
        v3->m128i_i64[1] = 0i64;
        LODWORD(v3->m128i_i64[0]) = -1073741670;
      }
      IoFreeIrp((PIRP)v11);
    }
    else
    {
      v3->m128i_i64[1] = 0i64;
      LODWORD(v3->m128i_i64[0]) = -1073741670;
      LODWORD(InvokeOnSuccess) = -1073741670;
      sub_140006BB4(0x143ui64, 0x107ui64, 0i64, 0xE03D000B, InvokeOnSuccess, 0);
    }
  }
}
// 1400251A0: using guessed type wchar_t aGetfilestandar[63];
// 140035180: using guessed type int dword_140035180;
// 140037E60: using guessed type __int64 qword_140037E60;

//----- (0000000140012400) ----------------------------------------------------
PVOID sub_140012400()
{
  UNICODE_STRING *v0; // rax
  PVOID result; // rax
  int v2; // [rsp+20h] [rbp-48h]
  UNICODE_STRING SystemRoutineName; // [rsp+28h] [rbp-40h]
  __int128 v4; // [rsp+38h] [rbp-30h]
  __int128 v5; // [rsp+48h] [rbp-20h]

  v2 = 0;
  v0 = sub_14000589C();
  if ( sub_1400095B8(v0, L"DisableNonCachedReads", &v2) )
    byte_140037E58 = v2 != 0;
  *(_DWORD *)&SystemRoutineName.Length = 2097182;
  SystemRoutineName.Buffer = (PWSTR)&v4;
  v4 = xmmword_140025180;
  v5 = xmmword_140025190;
  result = MmGetSystemRoutineAddress(&SystemRoutineName);
  qword_140037E60 = (__int64)result;
  return result;
}
// 140025150: using guessed type wchar_t aDisablenoncach[22];
// 140025180: using guessed type __int128 xmmword_140025180;
// 140025190: using guessed type __int128 xmmword_140025190;
// 140037E58: using guessed type char byte_140037E58;
// 140037E60: using guessed type __int64 qword_140037E60;

//----- (00000001400124A0) ----------------------------------------------------
signed __int64 __fastcall CompletionRoutine(PDEVICE_OBJECT DeviceObject, PIRP Irp, PVOID Context)
{
  if ( Context )
    KeSetEvent((PRKEVENT)Context, 0, 0);
  return 3221225494i64;
}

//----- (00000001400124CC) ----------------------------------------------------
void __fastcall sub_1400124CC(struct _FILE_OBJECT *a1, _QWORD *a2, unsigned int a3, void *a4, __m128i *a5, char a6)
{
  void *v6; // r14
  unsigned int v7; // er15
  _QWORD *v8; // r12
  __int64 v9; // rdi
  PDEVICE_OBJECT v10; // rax
  __int64 v11; // rsi
  PFAST_IO_DISPATCH v12; // rax
  __int64 (*v13)(void); // rax
  int v14; // eax
  ULONG v15; // er9
  ULONG_PTR v16; // rdx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-48h]

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = (__int64)a1;
  v10 = IoGetRelatedDeviceObject(a1);
  v11 = (__int64)v10;
  v12 = v10->DriverObject->FastIoDispatch;
  if ( !v12
    || v12->SizeOfFastIoDispatch < 0x18
    || (v13 = (__int64 (*)(void))v12->FastIoRead) == 0i64
    || !(unsigned __int8)sub_140021A40(v13)
    || LODWORD(a5->m128i_i64[0]) )
  {
    v14 = *(_DWORD *)(v11 + 48);
    if ( v14 & 4 )
    {
      v15 = -532873170;
      v16 = 909i64;
LABEL_8:
      LODWORD(BugCheckParameter3) = -1073741637;
      sub_140006BB4(0x143ui64, v16, 0i64, v15, BugCheckParameter3, 0);
      a5->m128i_i64[1] = 0i64;
      LODWORD(a5->m128i_i64[0]) = -1073741637;
      return;
    }
    if ( v14 & 0x10 )
    {
      v15 = -532873169;
      v16 = 923i64;
      goto LABEL_8;
    }
    if ( sub_140012B50(v9) )
      sub_140012740(v9, v11, v8, v7, v6, a5, 0, a6);
    else
      sub_140012984(v9, v11, v8, v7, (__int64)v6, a5, 0, 0, a6);
    if ( LODWORD(a5->m128i_i64[0]) == -1073741740 )
    {
      if ( *(_QWORD *)(v9 + 16) )
        sub_140012740(v9, v11, v8, v7, v6, a5, 1, a6);
    }
  }
}

//----- (0000000140012660) ----------------------------------------------------
void __fastcall sub_140012660(__int64 a1)
{
  if ( a1 )
    sub_1400124CC(
      *(struct _FILE_OBJECT **)a1,
      *(_QWORD **)(a1 + 8),
      *(_DWORD *)(a1 + 16),
      *(void **)(a1 + 24),
      *(__m128i **)(a1 + 32),
      *(_BYTE *)(a1 + 40));
}

//----- (0000000140012694) ----------------------------------------------------
LONG __fastcall sub_140012694(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, char a6)
{
  LONG result; // eax
  LONG v7; // edi
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-48h]
  __int64 v9; // [rsp+30h] [rbp-38h]
  __int64 v10; // [rsp+38h] [rbp-30h]
  int v11; // [rsp+40h] [rbp-28h]
  __int64 v12; // [rsp+48h] [rbp-20h]
  __int64 v13; // [rsp+50h] [rbp-18h]
  char v14; // [rsp+58h] [rbp-10h]

  v9 = a1;
  v10 = a2;
  v11 = a3;
  v12 = a4;
  v13 = a5;
  v14 = a6;
  result = KeExpandKernelStackAndCalloutEx(sub_140012660, &v9, dword_14002B150[0], 0i64, 0i64);
  v7 = result;
  if ( result < 0 )
  {
    LODWORD(BugCheckParameter3) = result;
    result = sub_140006BB4(0x143ui64, 0x3F2ui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
    if ( dword_140035180 & 1 )
      result = sub_140007A38((__int64)L"CheckStackAndReadFromFile: Failed to expand stack");
    *(_QWORD *)(a5 + 8) = 0i64;
    *(_DWORD *)a5 = v7;
  }
  return result;
}
// 1400253F0: using guessed type wchar_t aCheckstackandr[50];
// 1400285C0: using guessed type __int64 __fastcall KeExpandKernelStackAndCalloutEx(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140035180: using guessed type int dword_140035180;

//----- (0000000140012740) ----------------------------------------------------
void __fastcall sub_140012740(__int64 a1, __int64 a2, _QWORD *a3, unsigned int a4, PVOID Address, __m128i *a6, char a7, char a8)
{
  SIZE_T v8; // r12
  _QWORD *v9; // rbx
  __int64 v10; // r13
  __int64 v11; // rdi
  struct _DEVICE_OBJECT *v12; // rax
  __m128i *v13; // rax
  unsigned __int64 v14; // r14
  unsigned int v15; // er15
  PVOID v16; // rsi
  char v17; // bl
  __int64 v18; // rcx
  char v19; // ST30_1
  __m128i *v20; // rbx
  unsigned __int64 v21; // r8
  unsigned __int64 v22; // r8
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-78h]
  __int64 v24; // [rsp+50h] [rbp-48h]
  PVOID v25; // [rsp+58h] [rbp-40h]
  ULONG_PTR v26; // [rsp+60h] [rbp-38h]
  unsigned int v27; // [rsp+A0h] [rbp+8h]

  v8 = a4;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  v12 = (struct _DEVICE_OBJECT *)IoGetAttachedDevice(*(_QWORD *)(a1 + 8));
  if ( !sub_140008FA0(v12, &v27) )
  {
    v13 = a6;
    LODWORD(a6->m128i_i64[0]) = -1073741811;
LABEL_3:
    v13->m128i_i64[1] = 0i64;
    return;
  }
  LODWORD(v14) = *v9 % (signed __int64)v27;
  v15 = v27 * (((unsigned int)v8 + (_DWORD)v14 + v27 - 1) / v27);
  v16 = ExAllocatePoolWithTag(
          (POOL_TYPE)PoolType,
          (v27 * (((unsigned int)v8 + (_DWORD)v14 + v27 - 1) / v27) + 4095i64) & 0xFFFFFFFFFFFFF000ui64,
          0x69704349u);
  v25 = v16;
  if ( !v16 )
  {
    v13 = a6;
    LODWORD(a6->m128i_i64[0]) = -1073741670;
    goto LABEL_3;
  }
  v14 = (unsigned int)v14;
  v24 = *v9 - (unsigned int)v14;
  v17 = a7;
  if ( a7 )
  {
    FsRtlAcquireFileExclusive(v11);
    v18 = *(_QWORD *)(v11 + 40);
    if ( v18 )
    {
      if ( *(_QWORD *)(v18 + 8) )
      {
        CcFlushCache(v18, &v24, v15, &v26);
        if ( (v26 & 0x80000000) != 0i64 )
        {
          LODWORD(BugCheckParameter3) = v26;
          sub_140006BB4(0x143ui64, 0x2DDui64, 0i64, 0xE03D0046, BugCheckParameter3, v11 + 88);
        }
      }
    }
    FsRtlReleaseFile(v11);
  }
  v19 = v17;
  v20 = a6;
  sub_140012984(v11, v10, &v24, v15, (__int64)v16, a6, v19, 1, 0);
  if ( !LODWORD(v20->m128i_i64[0]) )
  {
    v21 = v20->m128i_i64[1];
    if ( v21 > v14 )
    {
      v22 = v21 - v14;
      v20->m128i_i64[1] = v22;
      if ( v22 > v8 )
      {
        v20->m128i_i64[1] = v8;
        v22 = v8;
      }
      if ( a8 )
      {
        ProbeForWrite(Address, v8, 1u);
        v22 = v20->m128i_i64[1];
      }
      sub_140021A80((__m128i *)Address, (unsigned __int64)v16 + v14, v22);
    }
    else
    {
      LODWORD(v20->m128i_i64[0]) = -1073741807;
      v20->m128i_i64[1] = 0i64;
    }
  }
  ExFreePoolWithTag(v16, 0);
}
// 1400282C8: using guessed type __int64 __fastcall IoGetAttachedDevice(_QWORD);
// 1400285C8: using guessed type __int64 __fastcall FsRtlAcquireFileExclusive(_QWORD);
// 1400285D0: using guessed type __int64 __fastcall FsRtlReleaseFile(_QWORD);
// 1400285D8: using guessed type __int64 __fastcall CcFlushCache(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140012984) ----------------------------------------------------
void __fastcall sub_140012984(__int64 a1, __int64 a2, _QWORD *a3, int a4, __int64 a5, __m128i *a6, char a7, char a8, char a9)
{
  struct _DEVICE_OBJECT *v9; // rsi
  _QWORD *v10; // r14
  __int64 v11; // r15
  int v12; // ebp
  __m128i *v13; // rax
  __m128i *v14; // rbx
  int v15; // eax
  __int64 v16; // rcx
  struct _MDL *v17; // rcx
  ULONG_PTR InvokeOnSuccess; // [rsp+20h] [rbp-58h]
  struct _KEVENT Event; // [rsp+40h] [rbp-38h]

  v9 = (struct _DEVICE_OBJECT *)a2;
  v10 = a3;
  v11 = a1;
  v12 = a4;
  v13 = (__m128i *)sub_140011C84(a2, a5, (__int64)a6);
  v14 = v13;
  if ( v13 )
  {
    v13[9].m128i_i64[1] = __readgsqword(0x188u);
    v13[4].m128i_i8[0] = a9;
    if ( a7 )
      v15 = 67;
    else
      v15 = (a8 != 0) + 260;
    v16 = v14[11].m128i_i64[1];
    v14[1].m128i_i32[0] = v15;
    *(_WORD *)(v16 - 72) = 3;
    *(_QWORD *)(v16 - 32) = v9;
    *(_QWORD *)(v16 - 24) = v11;
    *(_DWORD *)(v16 - 64) = v12;
    *(_QWORD *)(v16 - 48) = *v10;
    KeInitializeEvent(&Event, SynchronizationEvent, 0);
    if ( IoSetCompletionRoutineEx(v9, (PIRP)v14, (PIO_COMPLETION_ROUTINE)CompletionRoutine, &Event, 1u, 1u, 1u) >= 0 )
    {
      if ( IofCallDriver(v9, (PIRP)v14) == 259 )
      {
        while ( KeWaitForSingleObject(&Event, 0, 0, 1u, 0i64) )
          ;
      }
      v17 = (struct _MDL *)v14->m128i_i64[1];
      if ( v17 )
      {
        MmUnlockPages(v17);
        IoFreeMdl((PMDL)v14->m128i_i64[1]);
      }
      _mm_storeu_si128(a6, v14[3]);
    }
    else
    {
      LODWORD(InvokeOnSuccess) = -1073741670;
      sub_140006BB4(0x143ui64, 0x259ui64, 0i64, 0xE03D000B, InvokeOnSuccess, 0);
      if ( dword_140035180 & 1 )
        sub_140007A38((__int64)L"SendReadIrp: Failed to set IoCompletion routine");
      a6->m128i_i64[1] = 0i64;
      LODWORD(a6->m128i_i64[0]) = -1073741670;
    }
    IoFreeIrp((PIRP)v14);
  }
}
// 140025390: using guessed type wchar_t aSendreadirpFai[48];
// 140035180: using guessed type int dword_140035180;

//----- (0000000140012B50) ----------------------------------------------------
char __fastcall sub_140012B50(__int64 a1)
{
  __int64 v1; // rdx
  char result; // al

  if ( byte_140037E58
    || !(*(_DWORD *)(a1 + 80) & 8)
    || (v1 = *(_QWORD *)(a1 + 8)) == 0
    || (result = 1, !(*(_DWORD *)(v1 + 52) & 1))
    || *(_DWORD *)(v1 + 72) != 7 )
  {
    result = 0;
  }
  return result;
}
// 140037E58: using guessed type char byte_140037E58;

//----- (0000000140012B7C) ----------------------------------------------------
bool __fastcall sub_140012B7C(__int64 a1, __int64 *a2)
{
  __int64 *v2; // rsi
  __int64 v3; // rdi
  __int64 v4; // rax
  __int64 v5; // rbx
  signed __int64 v6; // rax
  __int64 v7; // rcx
  _QWORD **v8; // rdx
  _QWORD *v9; // rax
  unsigned __int64 v10; // rcx
  signed int v11; // edi
  unsigned __int64 v12; // rax
  __int16 v13; // bp
  __int16 v14; // ax
  signed int v15; // eax
  __int16 v17; // [rsp+30h] [rbp+8h]

  v2 = a2;
  v3 = a1;
  if ( !*(_QWORD *)(a1 + 16) )
    return 0;
  v4 = sub_140013548();
  v5 = v4;
  if ( v4 )
  {
    *(_QWORD *)(v4 + 800) = v4;
    v6 = v4 + 808;
    *(_QWORD *)(v6 + 800) = v6;
    *(_QWORD *)(v5 + 1616) = v5;
    *(_QWORD *)(v5 + 1624) = v6;
    *(_BYTE *)(v5 + 1632) = 0;
  }
  else
  {
    v5 = 0i64;
  }
  if ( !v5 )
    return 0;
  *(_BYTE *)(v5 + 1632) = 0;
  *(_QWORD *)(v5 + 800) = v5;
  *(_QWORD *)(v5 + 1608) = v5 + 808;
  v7 = *(_QWORD *)(v3 + 16);
  if ( v7 )
  {
    v8 = (_QWORD **)(*(_QWORD *)(v5 + 1616) + 800i64);
    v9 = *v8;
    while ( v9 != v8 )
    {
      *v9 = v7;
      v9 = *v8 + 1;
      *v8 = v9;
      v7 = *(_QWORD *)(v7 + 8);
      if ( !v7 )
        goto LABEL_10;
    }
    sub_1400135E8((PSLIST_ENTRY)v5);
    return 0;
  }
LABEL_10:
  v10 = v2[2];
  v11 = -2;
  v12 = v2[1];
  if ( v10 >= v12 )
    goto LABEL_25;
  v13 = v17;
  do
  {
    if ( v11 != -2 )
      break;
    if ( v10 < v12 )
    {
      v13 = *(_WORD *)(*v2 + 2 * v10);
      v2[2] = v10 + 1;
    }
    v14 = sub_1400136D4(v13);
    v15 = sub_140013224(v5, v14);
    v10 = v2[2];
    v11 = v15;
    v12 = v2[1];
  }
  while ( v10 < v12 );
  if ( v11 == -1 )
  {
    sub_1400136B0((__int64)L"Error matching ");
    sub_1400136B0(*v2);
    sub_1400136B0((__int64)L"\n");
  }
  if ( v11 == -2 )
LABEL_25:
    v11 = sub_1400133FC(v5);
  sub_1400135E8((PSLIST_ENTRY)v5);
  return v11 == 1;
}
// 140025460: using guessed type wchar_t aErrorMatching[16];
// 140025480: using guessed type wchar_t asc_140025480[2];

//----- (0000000140012CF8) ----------------------------------------------------
bool __fastcall sub_140012CF8(__int64 a1, __int16 *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rdi
  __int16 *v4; // rbx
  __int64 v5; // rsi
  __int16 v6; // cx
  __int16 v7; // r9
  int v8; // er8
  __int16 v9; // ax
  char v11; // [rsp+58h] [rbp+38h]
  __int64 v12; // [rsp+68h] [rbp+48h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a2 && a3 )
  {
    v12 = a1;
    v11 = 1;
    if ( a3 >= 2 )
    {
      v6 = *a2;
      if ( ((unsigned __int16)(*a2 - 65) <= 0x19u || (unsigned __int16)(v6 - 97) <= 0x19u) && a2[1] == 58 )
      {
        if ( a3 == 2 )
        {
          *(_BYTE *)((unsigned __int16)sub_1400136D4(v6) + v5 - 41) = 1;
          v6 = *v4;
        }
        v7 = sub_1400136D4(v6);
        v8 = 2;
LABEL_16:
        sub_140012F40(&v11, (_DWORD **)&v12, v8, v7);
        sub_140012F40(&v11, (_DWORD **)&v12, 2, 58);
        v4 += 2;
        v3 -= 2i64;
LABEL_25:
        sub_140013160(&v11, (_DWORD **)&v12, v4, v3);
        return v12 != 0;
      }
      if ( (v6 == 42 || v6 == 63) && a2[1] == 58 )
      {
        if ( a3 == 2 )
        {
          *(_QWORD *)(v5 + 24) = 72340172838076673i64;
          *(_QWORD *)(v5 + 32) = 72340172838076673i64;
          *(_QWORD *)(v5 + 40) = 72340172838076673i64;
          *(_WORD *)(v5 + 48) = 257;
        }
        v7 = 0;
        v8 = 1;
        goto LABEL_16;
      }
    }
    if ( a3 >= 1 && (*a2 == 92 || *a2 == 47) )
    {
      if ( a3 == 1 || (v9 = a2[1], v9 != 92) && v9 != 47 )
      {
        sub_140012F40(&v11, (_DWORD **)&v12, 1, 0);
        sub_140012F40(&v11, (_DWORD **)&v12, 2, 58);
        sub_140013160(&v11, (_DWORD **)&v12, v4, v3);
        if ( v12 )
        {
          v12 = v5;
          v11 = 1;
          sub_140012F40(&v11, (_DWORD **)&v12, 3, 0);
          sub_140012F40(&v11, (_DWORD **)&v12, 3, 0);
          sub_140012F40(&v11, (_DWORD **)&v12, 5, 0);
          sub_140012F40(&v11, (_DWORD **)&v12, 3, 0);
          sub_140012F40(&v11, (_DWORD **)&v12, 5, 0);
        }
      }
    }
    goto LABEL_25;
  }
  return 1;
}

//----- (0000000140012F00) ----------------------------------------------------
bool __fastcall sub_140012F00(__int64 a1, __int16 *a2, unsigned __int64 a3)
{
  char v4; // [rsp+38h] [rbp+10h]
  __int64 v5; // [rsp+48h] [rbp+20h]

  if ( !a2 || !a3 )
    return 1;
  v5 = a1;
  v4 = 0;
  sub_140012FF4(&v4, (_DWORD **)&v5, a2, a3);
  return v5 != 0;
}

//----- (0000000140012F40) ----------------------------------------------------
_DWORD *__fastcall sub_140012F40(_BYTE *a1, _DWORD **a2, int a3, __int16 a4)
{
  _DWORD *result; // rax
  __int16 v5; // bp
  int v6; // edi
  _QWORD *v7; // rsi
  _DWORD **i; // rbx

  result = *a2;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  if ( *a2 )
  {
    if ( a3 == 3 )
    {
      if ( *result == 3 )
      {
        if ( !*a1 )
          return result;
        *a1 = 0;
      }
    }
    else
    {
      *a1 = 0;
      if ( (unsigned int)(a3 - 4) <= 1 )
      {
        result = *a2;
        if ( **a2 == a3 )
          return result;
      }
    }
    for ( i = (_DWORD **)(*a2 + 4); ; i = (_DWORD **)(result + 2) )
    {
      result = *i;
      if ( !*i )
        break;
      if ( *result == a3 && (a3 != 2 || *((_WORD *)result + 2) == a4) )
      {
        *a2 = result;
        return result;
      }
    }
    result = (_DWORD *)sub_140013598();
    if ( result )
    {
      *((_QWORD *)result + 1) = 0i64;
      *((_QWORD *)result + 2) = 0i64;
      *result = v6;
      *((_WORD *)result + 2) = v5;
      *i = result;
    }
    *v7 = result;
  }
  return result;
}

//----- (0000000140012FF4) ----------------------------------------------------
_DWORD *__fastcall sub_140012FF4(_BYTE *a1, _DWORD **a2, __int16 *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rdi
  __int16 *v5; // rbx
  _DWORD **v6; // rbp
  _BYTE *v7; // r14
  char v8; // si
  __int16 v9; // cx
  char v10; // dl
  __int16 v11; // ax
  __int16 v12; // ax
  signed __int64 v13; // rax
  __int16 v14; // r9
  int v15; // er8

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = 1;
  if ( a4 )
  {
    while ( 1 )
    {
      v9 = *v5;
      v10 = v8;
      if ( *v5 != 92 && v9 != 47 )
        break;
      v8 = 1;
      if ( v4 < 3 )
        goto LABEL_11;
      if ( v5[1] != 42 )
        goto LABEL_11;
      if ( v5[2] != 42 )
        goto LABEL_11;
      if ( v4 != 3 )
      {
        v11 = v5[3];
        if ( v11 != 92 && v11 != 47 )
          goto LABEL_11;
      }
LABEL_29:
      ++v5;
      if ( !--v4 )
        return sub_140012F40(v7, v6, 9 - (unsigned int)(v8 != 0), 0);
    }
    v8 = 0;
LABEL_11:
    if ( v10 && v4 >= 2 && v9 == 42 && v5[1] == 42 && (v4 == 2 || (v12 = v5[2], v12 == 92) || v12 == 47) )
    {
      sub_140012F40(v7, v6, 4, 0);
      v8 = 1;
      v13 = (v4 != 2) + 1i64;
      v4 -= v13;
      v5 += v13;
    }
    else
    {
      if ( v8 )
      {
        v14 = 0;
        v15 = 3;
      }
      else
      {
        switch ( v9 )
        {
          case 42:
            v14 = 0;
            v15 = 5;
            break;
          case 46:
            v14 = 0;
            v15 = 7;
            break;
          case 63:
            v14 = 0;
            v15 = 6;
            break;
          default:
            v14 = sub_1400136D4(v9);
            v15 = 2;
            break;
        }
      }
      sub_140012F40(v7, v6, v15, v14);
    }
    goto LABEL_29;
  }
  return sub_140012F40(v7, v6, 9 - (unsigned int)(v8 != 0), 0);
}

//----- (0000000140013160) ----------------------------------------------------
_DWORD *__fastcall sub_140013160(_BYTE *a1, _DWORD **a2, __int16 *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbp
  __int16 *v5; // rbx
  _DWORD **v6; // rdi
  _BYTE *v7; // rsi

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !a4 || *a3 != 92 && *a3 != 47 )
    sub_140012F40(a1, a2, 4, 0);
  return sub_140012FF4(v7, v6, v5, v4);
}

//----- (00000001400131C8) ----------------------------------------------------
char __fastcall sub_1400131C8(__int64 a1, __int16 a2)
{
  __int64 v2; // rbx
  unsigned __int16 v3; // ax
  char result; // al

  v2 = a1;
  v3 = sub_1400136D4(a2);
  if ( (unsigned __int16)(v3 - 65) > 0x19u )
    result = 0;
  else
    result = *(_BYTE *)(v3 + v2 - 41);
  return result;
}

//----- (00000001400131F4) ----------------------------------------------------
bool __fastcall sub_1400131F4(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // [rsp+20h] [rbp-28h]
  __int64 v5; // [rsp+28h] [rbp-20h]
  __int64 v6; // [rsp+30h] [rbp-18h]

  if ( !a2 || !a3 )
    return 0;
  v6 = 0i64;
  v4 = a2;
  v5 = a3;
  return sub_140012B7C(a1, &v4);
}

//----- (0000000140013224) ----------------------------------------------------
signed __int64 __fastcall sub_140013224(__int64 a1, __int16 a2)
{
  __int16 v2; // r10
  __int64 v3; // r8
  char v4; // bl
  __int64 v5; // rcx
  __int64 v6; // rax
  _QWORD *v7; // rax
  char v8; // di
  bool v9; // r9
  char v10; // dl
  _DWORD *v11; // r11
  signed __int64 result; // rax
  __int64 v13; // rcx
  _QWORD **v14; // rax
  _QWORD *v15; // r9
  _QWORD *v16; // rax
  __int64 v17; // rcx
  _QWORD **v18; // rax
  _QWORD *v19; // rdx

  v2 = a2;
  v3 = a1;
  if ( a2 == 92 || a2 == 47 )
  {
    v4 = 1;
    *(_BYTE *)(a1 + 1632) = 0;
  }
  else
  {
    v4 = 0;
    if ( a2 == 46 )
      *(_BYTE *)(a1 + 1632) = 1;
  }
  v5 = *(_QWORD *)(a1 + 1616);
  v6 = *(_QWORD *)(v5 + 800);
  if ( v6 == v5 )
    return 0i64;
  while ( 1 )
  {
    v7 = (_QWORD *)(v6 - 8);
    v8 = 0;
    *(_QWORD *)(v5 + 800) = v7;
    v9 = 0;
    v10 = 0;
    v11 = (_DWORD *)*v7;
    if ( *(_DWORD *)*v7 != 1 )
      break;
    if ( (unsigned __int16)(v2 - 65) > 0x19u )
    {
      v10 = 0;
      goto LABEL_30;
    }
LABEL_39:
    v17 = *((_QWORD *)v11 + 2);
    if ( v17 )
    {
      v18 = (_QWORD **)(*(_QWORD *)(v3 + 1624) + 800i64);
      v19 = *v18;
      while ( v19 != v18 )
      {
        *v19 = v17;
        ++*v18;
        v17 = *(_QWORD *)(v17 + 8);
        v19 = *v18;
        if ( !v17 )
          goto LABEL_43;
      }
      return 0xFFFFFFFFi64;
    }
LABEL_43:
    v5 = *(_QWORD *)(v3 + 1616);
    v6 = *(_QWORD *)(v5 + 800);
    if ( v6 == v5 )
    {
      *(_QWORD *)(v3 + 1616) = *(_QWORD *)(v3 + 1624);
      result = 4294967294i64;
      *(_QWORD *)(v3 + 1624) = v5;
      return result;
    }
  }
  switch ( *(_DWORD *)*v7 )
  {
    case 2:
      v10 = v2 == *((_WORD *)v11 + 2);
      goto LABEL_38;
    case 3:
      v10 = v4;
      goto LABEL_38;
    case 4:
      v10 = v4;
LABEL_36:
      v16 = (_QWORD *)(*(_QWORD *)(v3 + 1624) + 800i64);
      if ( (_QWORD *)*v16 == v16 )
        return 0xFFFFFFFFi64;
      *(_QWORD *)*v16 = v11;
      *v16 += 8i64;
      goto LABEL_38;
    case 5:
      v8 = v4 ^ 1;
      break;
    case 6:
      v9 = v2 == 46 || v4;
      v10 = !v9;
LABEL_30:
      if ( !v9 )
      {
LABEL_38:
        if ( !v10 )
          goto LABEL_43;
        goto LABEL_39;
      }
      break;
    case 7:
      v10 = v2 == 46;
      if ( !v4 || *(_BYTE *)(v3 + 1632) )
        goto LABEL_38;
      break;
    case 8:
      return 1i64;
    default:
      goto LABEL_38;
  }
  v13 = *((_QWORD *)v11 + 2);
  if ( !v13 )
  {
LABEL_35:
    if ( !v8 )
      goto LABEL_38;
    goto LABEL_36;
  }
  v14 = (_QWORD **)(*(_QWORD *)(v3 + 1616) + 800i64);
  v15 = *v14;
  while ( v15 != v14 )
  {
    *v15 = v13;
    ++*v14;
    v13 = *(_QWORD *)(v13 + 8);
    v15 = *v14;
    if ( !v13 )
      goto LABEL_35;
  }
  return 0xFFFFFFFFi64;
}

//----- (00000001400133FC) ----------------------------------------------------
signed __int64 __fastcall sub_1400133FC(__int64 a1)
{
  __int64 v1; // r8
  __int64 v2; // rdx
  __int64 v3; // rax
  signed int **v4; // rax
  signed int *v5; // rcx
  signed int v6; // eax
  bool v8; // al
  __int64 v9; // rcx
  _QWORD **v10; // rax
  _QWORD *v11; // rdx

  v1 = a1;
  while ( 1 )
  {
    while ( 1 )
    {
      do
      {
LABEL_2:
        v2 = *(_QWORD *)(v1 + 1616);
        v3 = *(_QWORD *)(v2 + 800);
        if ( v3 == v2 )
          return 0i64;
        v4 = (signed int **)(v3 - 8);
        *(_QWORD *)(v2 + 800) = v4;
        v5 = *v4;
        v6 = **v4;
      }
      while ( v6 < 5 );
      if ( v6 <= 6 )
      {
        v8 = 1;
        goto LABEL_11;
      }
      if ( v6 == 7 )
        break;
      if ( v6 > 7 && v6 <= 9 )
        return 1i64;
    }
    v8 = *(_BYTE *)(v1 + 1632) == 0;
LABEL_11:
    if ( v8 )
    {
      v9 = *((_QWORD *)v5 + 2);
      if ( v9 )
        break;
    }
  }
  v10 = (_QWORD **)(*(_QWORD *)(v1 + 1616) + 800i64);
  v11 = *v10;
  while ( v11 != v10 )
  {
    *v11 = v9;
    ++*v10;
    v9 = *(_QWORD *)(v9 + 8);
    v11 = *v10;
    if ( !v9 )
      goto LABEL_2;
  }
  return 0xFFFFFFFFi64;
}

//----- (0000000140013490) ----------------------------------------------------
__int64 __fastcall sub_140013490(__int64 a1)
{
  __int64 v1; // rbx
  __int64 i; // rcx
  __int64 v3; // rax
  _QWORD *v4; // rdx
  __int64 result; // rax

  v1 = a1;
  for ( i = *(_QWORD *)(a1 + 16); i; i = *(_QWORD *)(v1 + 16) )
  {
    v3 = *(_QWORD *)(i + 16);
    v4 = (_QWORD *)(i + 16);
    while ( v3 )
    {
      v4 = (_QWORD *)(v3 + 8);
      v3 = *(_QWORD *)(v3 + 8);
    }
    *v4 = *(_QWORD *)(i + 8);
    *(_QWORD *)(v1 + 16) = *(_QWORD *)(i + 16);
    sub_14001364C((PSLIST_ENTRY)i);
  }
  result = 0i64;
  *(_QWORD *)(v1 + 24) = 0i64;
  *(_QWORD *)(v1 + 32) = 0i64;
  *(_QWORD *)(v1 + 40) = 0i64;
  *(_WORD *)(v1 + 48) = 0;
  return result;
}

//----- (00000001400134EC) ----------------------------------------------------
__int64 __fastcall sub_1400134EC(__int128 *a1, __int128 *a2)
{
  __int128 v2; // xmm3
  __int128 *v3; // r8
  __int64 v4; // xmm2_8
  __int128 v5; // xmm0
  __int128 v6; // xmm3
  __int64 v7; // xmm2_8
  __int16 v8; // cx
  __int64 result; // rax

  v2 = *a1;
  v3 = a1;
  v4 = *((_QWORD *)a1 + 2);
  *a1 = *a2;
  *((_QWORD *)a1 + 2) = *((_QWORD *)a2 + 2);
  v5 = *(__int128 *)((char *)a2 + 24);
  *a2 = v2;
  *((_QWORD *)a2 + 2) = v4;
  v6 = *(__int128 *)((char *)a1 + 24);
  v7 = *((_QWORD *)a1 + 5);
  v8 = *((_WORD *)a1 + 24);
  *(__int128 *)((char *)v3 + 24) = v5;
  *((_QWORD *)v3 + 5) = *((_QWORD *)a2 + 5);
  result = *((unsigned __int16 *)a2 + 24);
  *((_WORD *)v3 + 24) = result;
  *(__int128 *)((char *)a2 + 24) = v6;
  *((_QWORD *)a2 + 5) = v7;
  *((_WORD *)a2 + 24) = v8;
  return result;
}

//----- (0000000140013548) ----------------------------------------------------
__int64 sub_140013548()
{
  __int64 result; // rax

  ++stru_140037E80.L.TotalAllocates;
  result = (__int64)ExpInterlockedPopEntrySList(&stru_140037E80.L.ListHead);
  if ( !result )
  {
    ++stru_140037E80.L.AllocateMisses;
    result = sub_140021A40((__int64 (*)(void))stru_140037E80.L.Allocate);
  }
  return result;
}

//----- (0000000140013598) ----------------------------------------------------
__int64 sub_140013598()
{
  __int64 result; // rax

  ++stru_140037F00.L.TotalAllocates;
  result = (__int64)ExpInterlockedPopEntrySList(&stru_140037F00.L.ListHead);
  if ( !result )
  {
    ++stru_140037F00.L.AllocateMisses;
    result = sub_140021A40((__int64 (*)(void))stru_140037F00.L.Allocate);
  }
  return result;
}

//----- (00000001400135E8) ----------------------------------------------------
void __fastcall sub_1400135E8(PSLIST_ENTRY ListEntry)
{
  struct _SLIST_ENTRY *v1; // rbx

  if ( ListEntry )
  {
    ++stru_140037E80.L.TotalFrees;
    v1 = ListEntry;
    if ( ExQueryDepthSList(&stru_140037E80.L.ListHead) < stru_140037E80.L.Depth )
    {
      ExpInterlockedPushEntrySList(&stru_140037E80.L.ListHead, v1);
    }
    else
    {
      ++stru_140037E80.L.FreeMisses;
      sub_140021A40((__int64 (*)(void))stru_140037E80.L.Free);
    }
  }
}

//----- (000000014001364C) ----------------------------------------------------
void __fastcall sub_14001364C(PSLIST_ENTRY ListEntry)
{
  struct _SLIST_ENTRY *v1; // rbx

  if ( ListEntry )
  {
    ++stru_140037F00.L.TotalFrees;
    v1 = ListEntry;
    if ( ExQueryDepthSList(&stru_140037F00.L.ListHead) < stru_140037F00.L.Depth )
    {
      ExpInterlockedPushEntrySList(&stru_140037F00.L.ListHead, v1);
    }
    else
    {
      ++stru_140037F00.L.FreeMisses;
      sub_140021A40((__int64 (*)(void))stru_140037F00.L.Free);
    }
  }
}

//----- (00000001400136B0) ----------------------------------------------------
LONG __fastcall sub_1400136B0(__int64 a1)
{
  LONG result; // eax

  if ( dword_140035180 & 0x10000 )
    result = sub_140007A38((__int64)L"%ws", a1);
  return result;
}
// 140025490: using guessed type wchar_t aWs[4];
// 140035180: using guessed type int dword_140035180;

//----- (00000001400136D4) ----------------------------------------------------
__int16 __fastcall sub_1400136D4(__int16 a1)
{
  __int16 result; // ax

  result = a1 - 32;
  if ( (unsigned __int16)(a1 - 97) > 0x19u )
    result = a1;
  return result;
}

//----- (00000001400136E4) ----------------------------------------------------
bool __fastcall sub_1400136E4(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rax
  __int64 v5; // rbx
  signed __int64 v6; // rax
  __int64 v7; // rcx
  _QWORD **v8; // rdx
  _QWORD *v9; // rax
  unsigned __int64 v10; // rdx
  signed int v11; // esi
  __int16 v12; // bp
  unsigned __int64 v13; // rcx
  signed __int64 v14; // rdx
  unsigned __int64 v15; // rax
  __int16 v16; // ax
  signed int v17; // eax
  __int16 v19; // [rsp+30h] [rbp+8h]

  v2 = a2;
  v3 = a1;
  if ( !*(_QWORD *)(a1 + 16) )
    return 0;
  v4 = sub_140013548();
  v5 = v4;
  if ( v4 )
  {
    *(_QWORD *)(v4 + 800) = v4;
    v6 = v4 + 808;
    *(_QWORD *)(v6 + 800) = v6;
    *(_QWORD *)(v5 + 1616) = v5;
    *(_QWORD *)(v5 + 1624) = v6;
    *(_BYTE *)(v5 + 1632) = 0;
  }
  else
  {
    v5 = 0i64;
  }
  if ( !v5 )
    return 0;
  *(_BYTE *)(v5 + 1632) = 0;
  *(_QWORD *)(v5 + 800) = v5;
  *(_QWORD *)(v5 + 1608) = v5 + 808;
  v7 = *(_QWORD *)(v3 + 16);
  if ( v7 )
  {
    v8 = (_QWORD **)(*(_QWORD *)(v5 + 1616) + 800i64);
    v9 = *v8;
    while ( v9 != v8 )
    {
      *v9 = v7;
      v9 = *v8 + 1;
      *v8 = v9;
      v7 = *(_QWORD *)(v7 + 8);
      if ( !v7 )
        goto LABEL_10;
    }
    sub_1400135E8((PSLIST_ENTRY)v5);
    return 0;
  }
LABEL_10:
  v10 = *(_QWORD *)(v2 + 40);
  v11 = -2;
  if ( v10 >= 2 )
    goto LABEL_27;
  v12 = v19;
  do
  {
    if ( v11 != -2 )
      break;
    if ( v10 < 2 )
    {
      v13 = *(_QWORD *)(v2 + 48);
      v14 = 2 * v10;
      v12 = *(_WORD *)(*(_QWORD *)(v2 + 8 * v14 + 16) + 2 * v13++);
      *(_QWORD *)(v2 + 48) = v13;
      if ( v13 >= (unsigned __int64)*(unsigned __int16 *)(v2 + 8 * v14 + 8) >> 1 )
      {
        do
        {
          v15 = ++*(_QWORD *)(v2 + 40);
          *(_QWORD *)(v2 + 48) = 0i64;
        }
        while ( v15 < 2 && !(*(_WORD *)(v2 + 16 * v15 + 8) & 0xFFFE) );
      }
    }
    v16 = sub_1400136D4(v12);
    v17 = sub_140013224(v5, v16);
    v10 = *(_QWORD *)(v2 + 40);
    v11 = v17;
  }
  while ( v10 < 2 );
  if ( v11 == -1 )
  {
    sub_1400136B0((__int64)L"Error matching ");
    sub_1400136B0(*(_QWORD *)(v2 + 16 * (*(_QWORD *)(v2 + 40) + 1i64)));
    sub_1400136B0((__int64)L"\n");
  }
  if ( v11 == -2 )
LABEL_27:
    v11 = sub_1400133FC(v5);
  sub_1400135E8((PSLIST_ENTRY)v5);
  return v11 == 1;
}
// 140025460: using guessed type wchar_t aErrorMatching[16];
// 140025480: using guessed type wchar_t asc_140025480[2];

//----- (00000001400138A0) ----------------------------------------------------
__int64 __fastcall sub_1400138A0(__int64 a1, _WORD *a2)
{
  __int64 v2; // rbx
  signed __int16 v3; // di
  __int64 result; // rax
  __int16 v5; // [rsp+30h] [rbp+8h]

  *(_QWORD *)(a1 + 16) = a1;
  v2 = a1;
  v3 = 4;
  *(_WORD *)(a1 + 10) = 4;
  sub_14001B244(a2, &v5, (UNICODE_STRING *)(a1 + 24), 0);
  if ( v5 )
  {
    *(_WORD *)v2 = v5;
    *(_WORD *)(v2 + 2) = 58;
  }
  else
  {
    *(_WORD *)v2 = 92;
    v3 = 2;
  }
  *(_WORD *)(v2 + 8) = v3;
  result = v2;
  *(_QWORD *)(v2 + 48) = 0i64;
  *(_QWORD *)(v2 + 40) = 0i64;
  return result;
}

//----- (0000000140013910) ----------------------------------------------------
bool __fastcall sub_140013910(__int16 a1)
{
  __int16 v1; // bx
  bool v3; // bl
  char v4; // [rsp+30h] [rbp+8h]

  v1 = a1;
  if ( !a1 )
    return 0;
  sub_140017428((__int64)&v4);
  v3 = sub_1400131C8((__int64)&unk_140037FF0, v1) != 0;
  sub_140017448();
  return v3;
}

//----- (0000000140013954) ----------------------------------------------------
bool __fastcall sub_140013954(_WORD *a1)
{
  bool v2; // bl
  char v3; // [rsp+20h] [rbp-58h]
  char v4; // [rsp+28h] [rbp-50h]

  if ( !a1 )
    return 0;
  sub_1400138A0((__int64)&v4, a1);
  sub_140017428((__int64)&v3);
  v2 = sub_1400136E4((__int64)&unk_140037FF0, (__int64)&v4) != 0;
  sub_140017448();
  return v2;
}

//----- (00000001400139C0) ----------------------------------------------------
bool __fastcall sub_1400139C0(unsigned __int16 *a1)
{
  unsigned __int16 *v1; // rbx
  bool v3; // bl
  char v4; // [rsp+30h] [rbp+8h]

  v1 = a1;
  if ( !a1 )
    return 0;
  sub_140017428((__int64)&v4);
  v3 = sub_1400131F4((__int64)&unk_140037F80, *((_QWORD *)v1 + 1), (unsigned __int64)*v1 >> 1) != 0;
  sub_140017448();
  return v3;
}

//----- (0000000140013A0C) ----------------------------------------------------
bool __fastcall sub_140013A0C(unsigned __int16 *a1)
{
  unsigned __int16 *v1; // rbx
  bool v3; // bl
  char v4; // [rsp+30h] [rbp+8h]

  v1 = a1;
  if ( !a1 )
    return 0;
  sub_140017428((__int64)&v4);
  v3 = sub_1400131F4((__int64)&unk_140037FB8, *((_QWORD *)v1 + 1), (unsigned __int64)*v1 >> 1) != 0;
  sub_140017448();
  return v3;
}

//----- (0000000140013A58) ----------------------------------------------------
__int64 __fastcall sub_140013A58(_WORD *a1, unsigned __int64 a2, _DWORD *a3)
{
  unsigned int v3; // edi
  _DWORD *v4; // r12
  unsigned __int64 v5; // rsi
  _WORD *v6; // rbx
  int v7; // er15
  __int16 v8; // dx
  unsigned __int64 v9; // rsi
  unsigned __int16 *v10; // rbx
  unsigned __int64 v11; // r8
  __int16 *v12; // rbx
  __int64 v13; // r14
  int *v14; // rcx
  char v16; // [rsp+20h] [rbp-99h]
  int v17; // [rsp+28h] [rbp-91h]
  __int16 v18; // [rsp+2Ch] [rbp-8Dh]
  __int128 v19; // [rsp+30h] [rbp-89h]
  __int64 v20; // [rsp+40h] [rbp-79h]
  __int64 v21; // [rsp+48h] [rbp-71h]
  __int64 v22; // [rsp+50h] [rbp-69h]
  __int16 v23; // [rsp+58h] [rbp-61h]
  int v24; // [rsp+60h] [rbp-59h]
  __int16 v25; // [rsp+64h] [rbp-55h]
  __int128 v26; // [rsp+68h] [rbp-51h]
  __int64 v27; // [rsp+78h] [rbp-41h]
  __int64 v28; // [rsp+80h] [rbp-39h]
  __int64 v29; // [rsp+88h] [rbp-31h]
  __int16 v30; // [rsp+90h] [rbp-29h]
  int v31; // [rsp+98h] [rbp-21h]
  __int16 v32; // [rsp+9Ch] [rbp-1Dh]
  __int128 v33; // [rsp+A0h] [rbp-19h]
  __int64 v34; // [rsp+B0h] [rbp-9h]
  __int64 v35; // [rsp+B8h] [rbp-1h]
  __int64 v36; // [rsp+C0h] [rbp+7h]
  __int16 v37; // [rsp+C8h] [rbp+Fh]

  v3 = 0;
  v31 = 0;
  v32 = 0;
  v4 = a3;
  v34 = 0i64;
  v5 = a2;
  v35 = 0i64;
  v6 = a1;
  v36 = 0i64;
  v7 = 0;
  v37 = 0;
  v24 = 0;
  v25 = 0;
  v27 = 0i64;
  v28 = 0i64;
  v29 = 0i64;
  v30 = 0;
  v17 = 0;
  v18 = 0;
  v20 = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  v23 = 0;
  _mm_storeu_si128((__m128i *)&v33, (__m128i)0i64);
  _mm_storeu_si128((__m128i *)&v26, (__m128i)0i64);
  _mm_storeu_si128((__m128i *)&v19, (__m128i)0i64);
  if ( a2 )
  {
    while ( v5 >= 4 )
    {
      v8 = *v6;
      v9 = v5 - 4;
      v10 = v6 + 1;
      v11 = *v10;
      v12 = (__int16 *)(v10 + 1);
      v13 = (unsigned int)v11;
      if ( v9 < v11 )
        break;
      if ( v8 == 1 )
      {
        if ( (_WORD)v11 != 4 )
          break;
        v7 |= 1 << *(_DWORD *)v12;
      }
      else if ( v8 == 2 || v8 == 4 || v8 == 8 )
      {
        if ( v8 == 2 )
        {
          v14 = &v31;
        }
        else
        {
          v14 = &v24;
          if ( v8 != 4 )
            v14 = &v17;
        }
        if ( v11 & 1 )
          break;
        if ( !sub_140012CF8((__int64)v14, v12, (unsigned __int64)(unsigned int)v11 >> 1) )
        {
          v3 = -1073741670;
          goto LABEL_19;
        }
      }
      v6 = (__int16 *)((char *)v12 + v13);
      v5 = v9 - v13;
      if ( !v5 )
        goto LABEL_18;
    }
    v3 = -1073741811;
  }
  else
  {
LABEL_18:
    sub_140017408((__int64)&v16);
    sub_1400134EC((__int128 *)&unk_140037FF0, (__int128 *)&v31);
    sub_1400134EC((__int128 *)&unk_140037FB8, (__int128 *)&v24);
    sub_1400134EC((__int128 *)&unk_140037F80, (__int128 *)&v17);
    *v4 = v7;
    sub_140017448();
    sub_14001E1F8();
  }
LABEL_19:
  sub_140013490((__int64)&v17);
  sub_140013490((__int64)&v24);
  sub_140013490((__int64)&v31);
  return v3;
}

//----- (0000000140013C44) ----------------------------------------------------
bool __fastcall sub_140013C44(unsigned __int16 *a1)
{
  unsigned __int16 *v1; // rbx
  char v2; // bl
  char v4; // [rsp+30h] [rbp+8h]

  v1 = a1;
  sub_140017428((__int64)&v4);
  if ( *v1 )
    v2 = sub_1400131F4((__int64)&unk_140038028, *((_QWORD *)v1 + 1), (unsigned __int64)*v1 >> 1);
  else
    v2 = byte_140038060;
  sub_140017448();
  return v2 != 0;
}
// 140038060: using guessed type char byte_140038060;

//----- (0000000140013C98) ----------------------------------------------------
__int64 __fastcall sub_140013C98(wchar_t *Str1, unsigned __int64 a2)
{
  __int16 *v2; // r14
  unsigned int v4; // ebx
  char v5; // r12
  bool v6; // zf
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // rdi
  unsigned __int64 v9; // r15
  char v10; // [rsp+20h] [rbp-50h]
  int v11; // [rsp+28h] [rbp-48h]
  __int16 v12; // [rsp+2Ch] [rbp-44h]
  __int128 v13; // [rsp+30h] [rbp-40h]
  __int64 v14; // [rsp+40h] [rbp-30h]
  __int64 v15; // [rsp+48h] [rbp-28h]
  __int64 v16; // [rsp+50h] [rbp-20h]
  __int16 v17; // [rsp+58h] [rbp-18h]

  v2 = (__int16 *)Str1;
  if ( a2 & 1 )
    return 3221225485i64;
  v4 = 0;
  v11 = 0;
  v5 = 0;
  v12 = 0;
  _mm_storeu_si128((__m128i *)&v13, (__m128i)0i64);
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0i64;
  v17 = 0;
  v7 = a2 >> 1;
  v6 = a2 >> 1 == 0;
  while ( !v6 )
  {
    v8 = 0i64;
    if ( v7 )
    {
      do
      {
        if ( !v2[v8] )
          break;
        ++v8;
      }
      while ( v8 < v7 );
    }
    if ( v8 == v7 )
      goto LABEL_18;
    if ( wcscmp((const wchar_t *)v2, L"...") )
    {
      if ( *v2 )
      {
        v9 = 0i64;
        while ( !wcschr((const wchar_t *)v2, asc_14002B2A0[v9]) )
        {
          ++v9;
          if ( v9 >= 8 )
          {
            if ( sub_140012F00((__int64)&v11, v2, v8) )
              goto LABEL_16;
            v4 = -1073741670;
            goto LABEL_20;
          }
        }
      }
LABEL_18:
      v4 = -1073741811;
      goto LABEL_20;
    }
    v5 = 1;
LABEL_16:
    v2 += v8 + 1;
    v6 = -1i64 - v8 + v7 == 0;
    v7 += -1i64 - v8;
  }
  sub_140017408((__int64)&v10);
  sub_1400134EC((__int128 *)&unk_140038028, (__int128 *)&v11);
  byte_140038060 = v5;
  sub_14001A0A4();
  sub_140017448();
LABEL_20:
  sub_140013490((__int64)&v11);
  return v4;
}
// 14002B2A0: using guessed type wchar_t asc_14002B2A0[8];
// 140038060: using guessed type char byte_140038060;

//----- (0000000140013DFC) ----------------------------------------------------
__int64 __fastcall sub_140013DFC(_QWORD *a1, __int64 *a2, char a3, _OWORD *a4, char a5)
{
  _QWORD *v5; // r14
  __int64 v6; // rbx
  _OWORD *v7; // rdi
  char v8; // r15
  __int64 *v9; // rsi
  unsigned __int8 v10; // al
  _QWORD *v11; // rbp
  __int64 v12; // rcx
  __int64 v13; // rcx
  struct _SLIST_ENTRY *v14; // rbp
  struct _SLIST_ENTRY *v15; // rcx
  void *v16; // rcx
  __int64 (__fastcall **v18)(PSLIST_ENTRY); // [rsp+20h] [rbp-28h]
  __int64 v19; // [rsp+28h] [rbp-20h]

  v5 = a1 + 6;
  v6 = (__int64)a1;
  v7 = a4;
  *a1 = &off_140028C48;
  v5[1] = 0i64;
  v8 = a3;
  *v5 = &off_140028B58;
  v9 = a2;
  a1[12] = 0i64;
  a1[21] = 0i64;
  sub_140001AEC((__int64)(a1 + 23));
  *(_BYTE *)(v6 + 204) = 0;
  sub_1400153D4(v6);
  *(_BYTE *)(v6 + 116) = a5;
  v10 = *(_WORD *)(*v9 + 32);
  *(_WORD *)(v6 + 114) = *(_WORD *)(*v9 + 32);
  *(_BYTE *)(v6 + 88) = (v10 >> 3) & 1;
  v11 = sub_140020554(*v9, &v18);
  if ( v5 != v11 )
  {
    v12 = v5[1];
    if ( v12 )
    {
      sub_14001A4D8(v12);
      v5[1] = 0i64;
    }
    v13 = v11[1];
    v5[1] = v13;
    if ( v13 )
      sub_14001B77C(v13);
  }
  v18 = &off_140028B58;
  if ( v19 )
  {
    sub_14001A4D8(v19);
    v19 = 0i64;
  }
  sub_14001CE9C(&v18);
  *(_QWORD *)(v6 + 72) = *(_QWORD *)(*v9 + 24);
  *(_DWORD *)(v6 + 200) = *(_DWORD *)(*v9 + 152);
  if ( v8 )
  {
    v14 = *(struct _SLIST_ENTRY **)(*v9 + 40);
    *(_QWORD *)(*v9 + 40) = 0i64;
    v15 = *(struct _SLIST_ENTRY **)(v6 + 168);
    if ( v15 != v14 )
    {
      sub_14000BBE4(v15);
      *(_QWORD *)(v6 + 168) = v14;
    }
  }
  *(_WORD *)(v6 + 8) = *(_WORD *)(*v9 + 60);
  v16 = *(void **)(v6 + 72);
  if ( v16 )
    ObfReferenceObject(v16);
  if ( v7 )
  {
    *(_OWORD *)(v6 + 120) = *v7;
    *(_OWORD *)(v6 + 136) = v7[1];
    *(_OWORD *)(v6 + 152) = v7[2];
  }
  return v6;
}
// 14001A4D8: using guessed type __int64 __fastcall sub_14001A4D8(_QWORD);
// 140028B58: using guessed type __int64 (__fastcall *off_140028B58)(PSLIST_ENTRY ListEntry);
// 140028C48: using guessed type __int64 (__fastcall *off_140028C48)(PSLIST_ENTRY ListEntry);

//----- (0000000140013F8C) ----------------------------------------------------
__int64 __fastcall sub_140013F8C(_QWORD *a1, __int64 a2, __int64 a3, char a4)
{
  __int64 v4; // rbx
  char v5; // di
  __int64 v6; // rsi
  __int64 v7; // rbp
  __int64 v8; // rax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]

  v4 = (__int64)a1;
  *a1 = &off_140028C48;
  v5 = a4;
  a1[7] = 0i64;
  a1[6] = &off_140028B58;
  v6 = a3;
  a1[12] = 0i64;
  v7 = a2;
  a1[21] = 0i64;
  sub_140001AEC((__int64)(a1 + 23));
  *(_BYTE *)(v4 + 204) = 0;
  sub_1400153D4(v4);
  v8 = sub_140004AD0();
  if ( v8 )
    v8 = sub_140004A94(v8, v7, v6, *(_DWORD *)(v4 + 28), v5);
  *(_QWORD *)(v4 + 40) = v8;
  if ( !v8 )
  {
    LODWORD(BugCheckParameter3) = -1073741670;
    sub_140006BB4(0x191ui64, 0x8Bui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
  }
  return v4;
}
// 140028B58: using guessed type __int64 (__fastcall *off_140028B58)(PSLIST_ENTRY ListEntry);
// 140028C48: using guessed type __int64 (__fastcall *off_140028C48)(PSLIST_ENTRY ListEntry);

//----- (000000014001405C) ----------------------------------------------------
void **__fastcall sub_14001405C(_QWORD *a1)
{
  _QWORD *v1; // rbx
  struct _SLIST_ENTRY *v2; // rcx
  __int64 v3; // rdi
  __int64 v4; // rcx
  void *v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx

  v1 = a1;
  *a1 = &off_140028C48;
  v2 = (struct _SLIST_ENTRY *)a1[2];
  if ( v2 )
    sub_14000762C(v2);
  v3 = v1[5];
  if ( v3 )
  {
    v4 = *(_QWORD *)(v3 + 56);
    *(_QWORD *)(v3 + 48) = &off_140028B58;
    if ( v4 )
    {
      sub_14001A4D8(v4);
      *(_QWORD *)(v3 + 56) = 0i64;
    }
    sub_14001CE9C((_QWORD *)(v3 + 48));
    sub_140004B20((PSLIST_ENTRY)v3);
  }
  v5 = (void *)v1[9];
  if ( v5 )
    ObfDereferenceObject(v5);
  sub_14000BBE4((struct _SLIST_ENTRY *)v1[21]);
  v6 = v1[12];
  if ( v6 )
  {
    FltReleaseContext(v6);
    v1[12] = 0i64;
  }
  v7 = v1[7];
  v1[6] = &off_140028B58;
  if ( v7 )
  {
    sub_14001A4D8(v7);
    v1[7] = 0i64;
  }
  sub_14001CE9C(v1 + 6);
  return sub_14001CE9C(v1);
}
// 14001A4D8: using guessed type __int64 __fastcall sub_14001A4D8(_QWORD);
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 140028B58: using guessed type __int64 (__fastcall *off_140028B58)(PSLIST_ENTRY ListEntry);
// 140028C48: using guessed type __int64 (__fastcall *off_140028C48)(PSLIST_ENTRY ListEntry);

//----- (0000000140014138) ----------------------------------------------------
__int64 sub_140014138()
{
  __int64 result; // rax

  ++stru_1400380C0.L.TotalAllocates;
  result = (__int64)ExpInterlockedPopEntrySList(&stru_1400380C0.L.ListHead);
  if ( !result )
  {
    ++stru_1400380C0.L.AllocateMisses;
    result = sub_140021A40((__int64 (*)(void))stru_1400380C0.L.Allocate);
  }
  return result;
}

//----- (0000000140014188) ----------------------------------------------------
void __fastcall sub_140014188(PSLIST_ENTRY ListEntry)
{
  struct _SLIST_ENTRY *v1; // rbx

  if ( ListEntry )
  {
    ++stru_1400380C0.L.TotalFrees;
    v1 = ListEntry;
    if ( ExQueryDepthSList(&stru_1400380C0.L.ListHead) < stru_1400380C0.L.Depth )
    {
      ExpInterlockedPushEntrySList(&stru_1400380C0.L.ListHead, v1);
    }
    else
    {
      ++stru_1400380C0.L.FreeMisses;
      sub_140021A40((__int64 (*)(void))stru_1400380C0.L.Free);
    }
  }
}

//----- (00000001400141F0) ----------------------------------------------------
struct _SLIST_ENTRY *__fastcall sub_1400141F0(PSLIST_ENTRY ListEntry, char a2)
{
  char v2; // di
  struct _SLIST_ENTRY *v3; // rbx

  v2 = a2;
  v3 = ListEntry;
  sub_14001405C(ListEntry);
  if ( v2 & 1 )
  {
    if ( v2 & 4 )
      nullsub_1(v3, 264i64);
    else
      sub_140014188(v3);
  }
  return v3;
}
// 140003220: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);

//----- (0000000140014234) ----------------------------------------------------
LONG __fastcall sub_140014234(__int64 a1, unsigned int a2)
{
  LONG result; // eax

  result = dword_140035180;
  if ( dword_140035180 & 2 )
    result = sub_140007A38((__int64)L"Cancelled check for file %Z, status: %x", *(_QWORD *)(a1 + 56), a2);
  return result;
}
// 1400257F0: using guessed type wchar_t aCancelledCheck[40];
// 140035180: using guessed type int dword_140035180;

//----- (000000014001425C) ----------------------------------------------------
__int64 __fastcall sub_14001425C(__int64 a1, _QWORD *a2, char a3)
{
  __int64 v3; // rsi
  char v4; // r12
  _QWORD *v5; // r15
  unsigned int v6; // edi
  __int64 v7; // rax
  __int64 v8; // rbx
  __int64 v9; // rax
  const wchar_t *v10; // rcx
  struct _FILE_OBJECT *v11; // r14
  UNICODE_STRING *v12; // rdi
  PVOID v13; // rax
  unsigned int v14; // esi
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-39h]
  PVOID Object; // [rsp+28h] [rbp-31h]
  __int64 v18; // [rsp+30h] [rbp-29h]
  __int64 v19; // [rsp+38h] [rbp-21h]
  __int64 v20; // [rsp+60h] [rbp+7h]
  __int64 vars0; // [rsp+C0h] [rbp+67h]
  __int64 retaddr; // [rsp+C8h] [rbp+6Fh]
  int v23; // [rsp+D0h] [rbp+77h]
  char v24; // [rsp+D8h] [rbp+7Fh]

  v3 = a1;
  v4 = a3;
  v5 = a2;
  sub_140010A8C((__int64)&v20, a2);
  if ( v4 & 4 && sub_140010BF4(&v19, *(_QWORD *)(v3 + 56)) )
  {
    if ( dword_140035180 & 0x20 )
      sub_140007A38((__int64)L"DataControl check for %Z: in cache", *(_QWORD *)(v3 + 56));
    v6 = 16;
    goto LABEL_26;
  }
  v7 = sub_14001BD68(v5[3]);
  v8 = v7;
  if ( !v7 )
  {
    v9 = *(_QWORD *)(v3 + 56);
    v18 = 0i64;
    LODWORD(BugCheckParameter3) = -1073741823;
    sub_140006BB4(0x191ui64, 0x741ui64, 0i64, 0xE03D0042, BugCheckParameter3, v9);
    if ( dword_140035180 & 0x20 )
    {
      v10 = L"DataControl check for %Z: failed to get filter extension";
LABEL_13:
      sub_140007A38((__int64)v10, *(_QWORD *)(v3 + 56));
      goto LABEL_14;
    }
    goto LABEL_14;
  }
  v18 = 0i64;
  v11 = 0i64;
  Object = 0i64;
  if ( v4 & 1 )
  {
LABEL_16:
    if ( v4 & 2 )
      v11 = (struct _FILE_OBJECT *)v5[4];
    v12 = *(UNICODE_STRING **)(v3 + 56);
    v13 = sub_140015158(v3);
    v14 = sub_1400041D4(v8 + 152, v12, v3 + 120, (__int64)v13, v11, (__int64)Object, v4 & 1, vars0, v24);
    if ( v14 == 16 && v4 & 4 )
      sub_140010BA0(&v19);
    if ( v18 )
    {
      ObfDereferenceObject(Object);
      FltClose(v18);
    }
    v6 = v14;
    goto LABEL_24;
  }
  if ( (signed int)sub_1400170A8(
                     *(_QWORD *)(v3 + 56),
                     (PVOID)v5[1],
                     v5[3],
                     *(_BYTE *)(v7 + 1214) == 0,
                     &v18,
                     &Object,
                     retaddr,
                     v23) >= 0 )
  {
    v11 = (struct _FILE_OBJECT *)Object;
    goto LABEL_16;
  }
  if ( dword_140035180 & 0x20 )
  {
    v10 = L"DataControl check for %Z: failed to reopen file";
    goto LABEL_13;
  }
LABEL_14:
  v6 = 2;
LABEL_24:
  if ( v8 )
    FltReleaseContext(v8);
LABEL_26:
  sub_140010B54(&v19);
  return v6;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002156E: using guessed type __int64 __fastcall FltClose(_QWORD);
// 140025C60: using guessed type wchar_t aDatacontrolChe_9[35];
// 140025CB0: using guessed type wchar_t aDatacontrolChe_10[57];
// 140025D30: using guessed type wchar_t aDatacontrolChe_11[48];
// 140035180: using guessed type int dword_140035180;

//----- (0000000140014470) ----------------------------------------------------
bool __fastcall sub_140014470(__int64 a1)
{
  __int64 v1; // rcx
  signed __int64 v2; // rbx
  __int64 v3; // rax

  v1 = *(_QWORD *)(a1 + 40);
  if ( v1 && sub_140004BF4(v1) )
    return 1;
  if ( qword_140030768 )
  {
    v2 = 0i64;
    do
    {
      v1 = *(_QWORD *)(v2 + qword_140030768);
      if ( !v1 )
        break;
      if ( sub_140006650(v1) )
        return 1;
      v2 += 8i64;
    }
    while ( v2 < 256 );
  }
  v3 = PsGetCurrentProcessId(v1);
  return sub_14001E300(v3) != 0;
}
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 140030768: using guessed type __int64 qword_140030768;

//----- (00000001400144E0) ----------------------------------------------------
signed __int64 __fastcall sub_1400144E0(__m128i *a1, __int64 a2, __int64 a3, char a4)
{
  struct _FILE_OBJECT *v4; // r15
  _QWORD *v5; // rbx
  _WORD *v6; // rdx
  char v7; // di
  __m128i *v8; // rsi
  unsigned int v9; // er14
  signed __int64 result; // rax
  __int64 v11; // rbx
  int v12; // eax
  __int64 v13; // rcx
  __int64 v14; // rax
  char v15; // dl
  __int8 *v16; // rbx
  int v17; // eax
  bool v18; // zf
  __int64 v19; // rcx
  char v20; // r12
  int v21; // eax
  signed __int64 v22; // r13
  __int128 v23; // xmm1
  _QWORD *v24; // rcx
  __int128 v25; // xmm0
  __int64 v26; // rax
  __int64 v27; // rbx
  _WORD *v28; // rdi
  __m128i *v29; // rax
  int v30; // edx
  unsigned int v31; // eax
  unsigned int v32; // edi
  const wchar_t *v33; // rax
  __int64 v34; // rcx
  int v35; // eax
  __int64 v36; // [rsp+18h] [rbp-59h]
  __int64 v37; // [rsp+20h] [rbp-51h]
  int *v38; // [rsp+28h] [rbp-49h]
  struct _FILE_OBJECT *v39; // [rsp+30h] [rbp-41h]
  char v40; // [rsp+38h] [rbp-39h]
  __int64 v41; // [rsp+40h] [rbp-31h]
  __m128i *v42; // [rsp+48h] [rbp-29h]
  __int128 v43; // [rsp+58h] [rbp-19h]
  __int128 v44; // [rsp+68h] [rbp-9h]
  __int128 v45; // [rsp+78h] [rbp+7h]
  int v46; // [rsp+88h] [rbp+17h]
  int v47; // [rsp+D8h] [rbp+67h]
  _QWORD *v48; // [rsp+E0h] [rbp+6Fh]
  __int64 v49; // [rsp+E8h] [rbp+77h]

  v4 = *(struct _FILE_OBJECT **)(a2 + 32);
  v5 = (_QWORD *)a2;
  v6 = (_WORD *)a1[3].m128i_i64[1];
  v7 = a4;
  v8 = a1;
  if ( !v6 || !v4->FsContext )
    return 2i64;
  v9 = 1;
  if ( dword_140035180 & 1 )
    sub_1400156B4((__int64)L"Check local file", v6);
  _InterlockedAdd((volatile signed __int32 *)&qword_140038080, 1u);
  result = sub_140016900(v4, v8[3].m128i_i64[1], &v8[7].m128i_i8[8]);
  v47 = result;
  if ( (_DWORD)result == 9 )
  {
    sub_140010A8C((__int64)&v37, v5);
    v11 = v8[3].m128i_i64[1];
    v12 = sub_140019200();
    if ( sub_140010E14(&v37, v12, v11) )
    {
      if ( dword_140035180 & 2 )
        sub_140007A38((__int64)L"File %Z present in the cache - safe", v8[3].m128i_i64[1]);
      v8[12].m128i_i8[0] |= 4u;
LABEL_58:
      sub_140010B54(&v37);
      return v9;
    }
    if ( v7 && (v14 = PsGetCurrentProcessId(v13), sub_14001E298(v14)) )
    {
      sub_1400110DC(&v37, 1);
      v15 = 1;
    }
    else
    {
      v15 = sub_140010DDC(&v37);
    }
    if ( v7 && v8[8].m128i_i32[2] & 0x400000 )
    {
      if ( dword_140035180 & 2 )
        sub_140007A38((__int64)L"Skipping offline file %Z", v8[3].m128i_i64[1]);
      v9 = 7;
      goto LABEL_58;
    }
    if ( v8[7].m128i_i8[3] & 8 && v8[1].m128i_i32[2] & 1 )
    {
      if ( dword_140035180 & 2 )
        sub_140007A38((__int64)L"File %Z is a copy of a safe file - safe", v8[3].m128i_i64[1]);
      goto LABEL_58;
    }
    if ( !v15 )
    {
      v16 = &v8[5].m128i_i8[8];
      if ( !v8[5].m128i_i8[8] && v8[12].m128i_i32[2] == 2 )
        *v16 = 1;
      v17 = sub_140016A9C(v4, &v8[1].m128i_i32[2], v8[3].m128i_i64[1], &v8[5].m128i_i8[8]);
      v18 = *v16 == 0;
      v47 = v17;
      if ( !v18 )
      {
        v19 = v8[6].m128i_i64[0];
        if ( v19 )
          sub_140020688(v19);
      }
    }
    if ( v47 != 9 )
    {
LABEL_55:
      v4->CurrentByteOffset.QuadPart = 0i64;
      v35 = v47;
      if ( v47 == 1 )
      {
        sub_140010DA8((_DWORD **)&v37);
        v35 = v47;
      }
      v9 = v35;
      goto LABEL_58;
    }
    _InterlockedAdd((_DWORD *)&qword_140038080 + 1, 1u);
    v20 = 1;
    if ( !v7 )
      v20 = v8[7].m128i_i8[4];
    sub_140021DC0((__m128 *)&v43, 0, 0x34ui64);
    v21 = v46;
    v22 = (signed __int64)v8[13].m128i_i64;
    v23 = v44;
    v24 = v48;
    *(_OWORD *)v22 = v43;
    v25 = v45;
    *(_OWORD *)(v22 + 16) = v23;
    *(_OWORD *)(v22 + 32) = v25;
    *(_DWORD *)(v22 + 48) = v21;
    v26 = sub_14001BD68(v24[3]);
    v27 = v26;
    if ( !byte_140038090
      && *(_DWORD *)(v26 + 1228) == 1
      && sub_140015028((__int64)v8, v48, v8 + 13)
      && !sub_14001B660(v8[3].m128i_i64[1])
      && v7 )
    {
      sub_140010F14(&v37, v8 + 14, v8[15].m128i_i64[0]);
    }
    v28 = (_WORD *)v8[3].m128i_i64[1];
    v29 = (__m128i *)sub_140015158((__int64)v8);
    v30 = v8[2].m128i_i32[0];
    v42 = v8 + 13;
    v41 = v49;
    v40 = v20;
    v39 = v4;
    v38 = &v47;
    v31 = sub_140019618(1, v30, v28, (__int64)&v8[7].m128i_i64[1], v29);
    v32 = v31;
    if ( v31 )
    {
      if ( dword_140035180 & 2 )
        sub_140007A38((__int64)L"Failed to send file %Z for checking, Status: 0x%x", v8[3].m128i_i64[1], v31);
      if ( v32 != -1073741749 && v32 != -1073741536 && v32 != -1073741248 )
      {
        sub_140006084(0x191ui64, 0x484ui64, v32, (unsigned __int16 *)v8[3].m128i_i64[1], v36);
        v47 = 2;
      }
    }
    else
    {
      sub_1400063C8(v8[3].m128i_i64[1], &v36);
      if ( dword_140035180 & 2 )
      {
        v33 = sub_1400152F8(v47);
        sub_140007A38((__int64)L"File %Z checked, result: %S", v8[3].m128i_i64[1], v33);
      }
    }
    if ( v47 == 1 )
    {
      v8[12].m128i_i8[0] |= 4u;
      v34 = v8[6].m128i_i64[0];
      if ( !v34 )
      {
LABEL_53:
        if ( v27 )
          FltReleaseContext(v27);
        goto LABEL_55;
      }
      sub_140020520(v34);
    }
    if ( !((v47 - 4) & 0xFFFFFFFB) )
      _InterlockedAdd(&dword_140038088, 1u);
    goto LABEL_53;
  }
  return result;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 140025840: using guessed type wchar_t aCheckLocalFile[17];
// 140025870: using guessed type wchar_t aFileZPresentIn[36];
// 1400258C0: using guessed type wchar_t aSkippingOfflin[25];
// 140025900: using guessed type wchar_t aFileZIsACopyOf[40];
// 140025950: using guessed type wchar_t aFailedToSendFi[50];
// 1400259C0: using guessed type wchar_t aFileZCheckedRe[28];
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 140035180: using guessed type int dword_140035180;
// 140038080: using guessed type __int64 qword_140038080;
// 140038088: using guessed type int dword_140038088;
// 140038090: using guessed type char byte_140038090;

//----- (00000001400148C0) ----------------------------------------------------
signed __int64 __fastcall sub_1400148C0(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, char a6, char a7)
{
  __int64 v7; // rbx
  int v8; // er14
  _WORD *v9; // rdx
  __int64 v10; // r15
  __int64 v11; // rsi
  unsigned int v12; // edi
  struct _FILE_OBJECT *v13; // rcx
  unsigned int v14; // eax
  __int64 v16; // rcx
  char v17; // r14
  __int64 v18; // rax
  int v19; // eax
  bool v20; // zf
  char v21; // al
  char v22; // r14
  int v23; // eax
  signed __int64 v24; // rbx
  __int128 v25; // xmm1
  _WORD *v26; // rdi
  __int128 v27; // xmm0
  __m128i *v28; // rax
  unsigned int v29; // eax
  unsigned int v30; // ebx
  const wchar_t *v31; // rax
  char v32; // al
  PVOID Object; // [rsp+50h] [rbp-31h]
  __int64 v34; // [rsp+58h] [rbp-29h]
  __int64 v35; // [rsp+60h] [rbp-21h]
  __int128 v36; // [rsp+68h] [rbp-19h]
  __int128 v37; // [rsp+78h] [rbp-9h]
  __int128 v38; // [rsp+88h] [rbp+7h]
  int v39; // [rsp+98h] [rbp+17h]
  int v40; // [rsp+D0h] [rbp+4Fh]

  v7 = a2;
  v8 = a4;
  v9 = *(_WORD **)(a1 + 56);
  v10 = a3;
  v11 = a1;
  v12 = 2;
  if ( !v9 )
    return v12;
  if ( dword_140035180 & 1 )
    sub_1400156B4((__int64)L"Check remote file", v9);
  _InterlockedAdd((volatile signed __int32 *)&qword_140038080, 1u);
  v34 = 0i64;
  v13 = *(struct _FILE_OBJECT **)(v7 + 32);
  Object = *(PVOID *)(v7 + 32);
  if ( !a7 )
  {
LABEL_13:
    v40 = sub_140016900(v13, *(_QWORD *)(v11 + 56), (_BYTE *)(v11 + 120));
    v12 = v40;
    if ( v40 != 9 )
      goto LABEL_43;
    if ( *(_BYTE *)(v11 + 115) & 8 && *(_DWORD *)(v11 + 24) & 1 )
    {
      if ( dword_140035180 & 2 )
        sub_140007A38((__int64)L"File %Z is a copy of a safe file - safe", *(_QWORD *)(v11 + 56));
      v12 = 1;
      v40 = 1;
      goto LABEL_43;
    }
    v17 = a6;
    if ( a6 && (v18 = PsGetCurrentProcessId(v16), sub_14001E298(v18)) )
    {
      v12 = v40;
    }
    else
    {
      v19 = sub_140016A9C(
              (struct _FILE_OBJECT *)Object,
              (_DWORD *)(v11 + 24),
              *(_QWORD *)(v11 + 56),
              (_BYTE *)(v11 + 88));
      v20 = *(_BYTE *)(v11 + 88) == 0;
      v12 = v19;
      v40 = v19;
      if ( !v20 )
      {
        v21 = *(_BYTE *)(v11 + 114);
        if ( !(v21 & 0x10) )
          *(_BYTE *)(v11 + 114) = v21 | 8;
      }
    }
    if ( v12 != 9 )
      goto LABEL_43;
    _InterlockedAdd((_DWORD *)&qword_140038080 + 1, 1u);
    if ( !v17 )
      v22 = *(_BYTE *)(v11 + 116);
    v35 = MEMORY[0xFFFFF78000000014];
    sub_140021DC0((__m128 *)&v36, 0, 0x34ui64);
    v23 = v39;
    v24 = v11 + 208;
    v25 = v37;
    v26 = *(_WORD **)(v11 + 56);
    *(_OWORD *)v24 = v36;
    v27 = v38;
    *(_OWORD *)(v24 + 16) = v25;
    *(_OWORD *)(v24 + 32) = v27;
    *(_DWORD *)(v24 + 48) = v23;
    v28 = (__m128i *)sub_140015158(v11);
    v29 = sub_140019618(1, *(_DWORD *)(v11 + 32), v26, v11 + 120, v28);
    v30 = v29;
    if ( v29 )
    {
      v12 = 2;
      if ( dword_140035180 & 2 )
        sub_140007A38((__int64)L"Failed to send file %Z for checking, Status: 0x%x", *(_QWORD *)(v11 + 56), v29);
      if ( v30 != -1073741749 && v30 != -1073741536 && v30 != -1073741248 )
      {
        sub_140006084(0x191ui64, 0x53Bui64, v30, *(unsigned __int16 **)(v11 + 56), v35);
        v40 = 2;
LABEL_38:
        if ( v12 != 1 )
          goto LABEL_41;
        *(_BYTE *)(v11 + 192) |= 4u;
        v32 = *(_BYTE *)(v11 + 114);
        *(_BYTE *)(v11 + 176) = 1;
        if ( !(v32 & 0x10) )
        {
          *(_BYTE *)(v11 + 114) = v32 & 0xFC;
LABEL_41:
          if ( !((v12 - 4) & 0xFFFFFFFB) )
          {
            _InterlockedAdd(&dword_140038088, 1u);
            v12 = v40;
          }
        }
LABEL_43:
        if ( v34 )
        {
          ObfDereferenceObject(Object);
          FltClose(v34);
          v12 = v40;
        }
        return v12;
      }
    }
    else
    {
      sub_1400063C8(*(_QWORD *)(v11 + 56), &v35);
      if ( dword_140035180 & 2 )
      {
        v31 = sub_1400152F8(v40);
        sub_140007A38((__int64)L"File %Z checked, result: %S", *(_QWORD *)(v11 + 56), v31);
      }
    }
    v12 = v40;
    goto LABEL_38;
  }
  v14 = sub_1400170A8(*(_QWORD *)(v11 + 56), *(PVOID *)(v7 + 8), *(_QWORD *)(v7 + 24), 1, &v34, &Object, v10, v8);
  if ( v14 != -1073741536 )
  {
    if ( (v14 & 0x80000000) != 0 )
    {
      if ( dword_140035180 & 2 )
        sub_140007A38((__int64)L"Reopen failed for file %Z with status 0x%x", *(_QWORD *)(v11 + 56));
      return v12;
    }
    v13 = (struct _FILE_OBJECT *)Object;
    goto LABEL_13;
  }
  if ( dword_140035180 & 2 )
    sub_140007A38((__int64)L"Reopen cancelled for file %Z", *(_QWORD *)(v11 + 56), v14);
  return 13i64;
}
// 14002156E: using guessed type __int64 __fastcall FltClose(_QWORD);
// 140025900: using guessed type wchar_t aFileZIsACopyOf[40];
// 140025950: using guessed type wchar_t aFailedToSendFi[50];
// 1400259C0: using guessed type wchar_t aFileZCheckedRe[28];
// 140025A00: using guessed type wchar_t aCheckRemoteFil[18];
// 140025A30: using guessed type wchar_t aReopenCancelle[29];
// 140025A70: using guessed type wchar_t aReopenFailedFo[43];
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 140035180: using guessed type int dword_140035180;
// 140038080: using guessed type __int64 qword_140038080;
// 140038088: using guessed type int dword_140038088;

//----- (0000000140014C28) ----------------------------------------------------
signed __int64 __fastcall sub_140014C28(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rcx
  __int64 v6; // rdx
  __int64 v7; // rcx
  int v8; // eax
  int v9; // ebx
  int v10; // eax
  signed __int64 v11; // rdi
  __int128 v12; // xmm1
  _WORD *v13; // rbx
  __int128 v14; // xmm0
  __m128i *v15; // rax
  char v16; // ST38_1
  unsigned int v17; // eax
  unsigned int v18; // edi
  signed int v19; // ebx
  const wchar_t *v20; // rax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-69h]
  ULONG_PTR BugCheckParameter3a; // [rsp+20h] [rbp-69h]
  char v23; // [rsp+80h] [rbp-9h]
  __int128 v24; // [rsp+90h] [rbp+7h]
  __int128 v25; // [rsp+A0h] [rbp+17h]
  __int128 v26; // [rsp+B0h] [rbp+27h]
  int v27; // [rsp+C0h] [rbp+37h]
  unsigned int v28; // [rsp+F0h] [rbp+67h]
  __int64 v29; // [rsp+108h] [rbp+7Fh]

  v3 = a1;
  v4 = *(_QWORD *)(a1 + 56);
  if ( !v4 )
    return 2i64;
  v29 = 0i64;
  if ( a3 )
  {
    v6 = *(_QWORD *)(a3 + 24);
    *((_QWORD *)&v24 + 1) = 0i64;
    *(_QWORD *)&v25 = v4;
    v7 = *(_QWORD *)(a3 + 8);
    LODWORD(v24) = 48;
    DWORD2(v25) = 576;
    _mm_storeu_si128((__m128i *)&v26, (__m128i)0i64);
    v8 = FltCreateFileEx(v7, v6, &v29, 0i64, 0, &v24, &v23, 0i64, 0, 7, 1, 256, 0i64, 0, 2048);
    v9 = v8;
    if ( v8 < 0 || v8 == 264 )
    {
      LODWORD(BugCheckParameter3) = v8;
      sub_140006BB4(0x191ui64, 0x589ui64, 0i64, 0xE03D0037, BugCheckParameter3, *(_QWORD *)(v3 + 56));
      if ( v9 == 264 )
      {
        FltClose(v29);
        return 2i64;
      }
      v29 = 0i64;
    }
  }
  sub_140021DC0((__m128 *)&v24, 0, 0x34ui64);
  v10 = v27;
  v11 = v3 + 208;
  v12 = v25;
  v13 = *(_WORD **)(v3 + 56);
  *(_OWORD *)v11 = v24;
  v14 = v26;
  *(_OWORD *)(v11 + 16) = v12;
  *(_OWORD *)(v11 + 32) = v14;
  *(_DWORD *)(v11 + 48) = v10;
  v15 = (__m128i *)sub_140015158(v3);
  v16 = *(_BYTE *)(v3 + 116);
  v17 = sub_140019618(5, *(_DWORD *)(v3 + 32), v13, v3 + 120, v15);
  v18 = v17;
  v19 = 2;
  if ( v17 )
  {
    if ( dword_140035180 & 2 )
      sub_140007A38((__int64)L"Failed to send file %Z for action, Status: 0x%x", *(_QWORD *)(v3 + 56), v17);
    if ( v18 == -1073741248 )
    {
      v19 = 3;
    }
    else
    {
      LODWORD(BugCheckParameter3a) = v18;
      sub_140006BB4(0x191ui64, 0x5A4ui64, 0i64, 0xE03D0037, BugCheckParameter3a, *(_QWORD *)(v3 + 56));
    }
    v28 = v19;
  }
  else if ( dword_140035180 & 2 )
  {
    v20 = sub_1400152F8(v28);
    sub_140007A38((__int64)L"Action performed on %Z, result: %S", *(_QWORD *)(v3 + 56), v20);
  }
  if ( v29 )
    FltClose(v29);
  return v28;
}
// 14002156E: using guessed type __int64 __fastcall FltClose(_QWORD);
// 140021622: using guessed type __int64 __fastcall FltCreateFileEx(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140025AD0: using guessed type wchar_t aFailedToSendFi_0[48];
// 140025B30: using guessed type wchar_t aActionPerforme[35];
// 140035180: using guessed type int dword_140035180;

//----- (0000000140014E6C) ----------------------------------------------------
void __fastcall sub_140014E6C(__int64 a1, __int64 a2, struct _FILE_OBJECT *a3)
{
  sub_1400023A8(a1 + 184, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 24i64) + 16i64), a2 + 24, a3, a1 + 120);
}

//----- (0000000140014EA0) ----------------------------------------------------
void __fastcall sub_140014EA0(__int64 a1, __int64 a2)
{
  __int64 v2; // r10

  v2 = *(_QWORD *)(a1 + 96);
  if ( v2 )
    sub_14000247C(
      (PFAST_MUTEX *)(v2 + 64),
      a1 + 184,
      (__m128i *)(*(_QWORD *)(a2 + 32) + 88i64),
      (*(_BYTE *)(a1 + 114) & 3) != 0);
}

//----- (0000000140014ED4) ----------------------------------------------------
signed __int64 __fastcall sub_140014ED4(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rsi
  _QWORD *v4; // r14
  __int64 v5; // rdi
  __int64 v6; // rbx
  const wchar_t *v7; // rcx
  unsigned int v8; // edi
  __int64 v9; // rcx
  __int64 v10; // rcx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !*(_QWORD *)(a1 + 56) || !*(_QWORD *)(a1 + 72) )
    return 16i64;
  v6 = sub_14001BD68(a2[3]);
  if ( !v6 )
  {
    LODWORD(BugCheckParameter3) = -1073741823;
    sub_140006BB4(0x191ui64, 0x6B0ui64, 0i64, 0xE03D0042, BugCheckParameter3, *(_QWORD *)(v5 + 56));
    goto LABEL_12;
  }
  if ( sub_140013954(*(_WORD **)(v3 + 8)) )
  {
    if ( !(dword_140035180 & 0x20) )
      goto LABEL_12;
    v7 = L"DataControl check for %Z: new name %Z excluded";
LABEL_11:
    sub_140007A38((__int64)v7, *(_QWORD *)(v5 + 56), *(_QWORD *)(v3 + 8));
    goto LABEL_12;
  }
  if ( (unsigned int)sub_140003504(*(_QWORD *)(v5 + 72), *(_WORD **)(v3 + 8)) )
  {
    if ( v5 + 48 != v3 )
    {
      v9 = *(_QWORD *)(v5 + 56);
      if ( v9 )
      {
        sub_14001A4D8(v9);
        *(_QWORD *)(v5 + 56) = 0i64;
      }
      v10 = *(_QWORD *)(v3 + 8);
      *(_QWORD *)(v5 + 56) = v10;
      if ( v10 )
        sub_14001B77C(v10);
    }
    v8 = sub_14001425C(v5, v4, 3);
    goto LABEL_19;
  }
  if ( dword_140035180 & 0x20 )
  {
    v7 = L"DataControl check for %Z: new name %Z not in monitored area";
    goto LABEL_11;
  }
LABEL_12:
  v8 = 16;
LABEL_19:
  if ( v6 )
    FltReleaseContext(v6);
  return v8;
}
// 14001A4D8: using guessed type __int64 __fastcall sub_14001A4D8(_QWORD);
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 140025B80: using guessed type wchar_t aDatacontrolChe_12[47];
// 140025BE0: using guessed type wchar_t aDatacontrolChe_4[60];
// 140035180: using guessed type int dword_140035180;

//----- (0000000140015028) ----------------------------------------------------
char __fastcall sub_140015028(__int64 a1, _QWORD *a2, __m128i *a3)
{
  __m128i *v3; // rsi
  _QWORD *v4; // r14
  char v5; // r15
  __int64 v6; // rbx
  _QWORD *v7; // rax
  _QWORD *v8; // rbp
  __int64 *v9; // rax
  char v10; // di
  __m128i v11; // xmm0
  __int64 v12; // rcx
  char v14; // [rsp+40h] [rbp-58h]
  char v15; // [rsp+A8h] [rbp+10h]

  v3 = a3;
  v4 = a2;
  v5 = 0;
  v6 = sub_14001BD68(a2[3]);
  v7 = sub_14000AB04(0x240ui64, PagedPool);
  v8 = v7;
  if ( v7 )
  {
    if ( !(unsigned int)FltFsControlFile(v4[3], v4[4], 590059i64, 0i64, 0, v7, 576, 0i64) )
    {
      v9 = sub_140010A8C((__int64)&v14, v4);
      v10 = sub_140010EF0(v9, &v15);
      sub_140010B54(&v14);
      if ( v10 )
      {
        v3[2].m128i_i64[1] = v8[3];
        v3[2].m128i_i64[0] = v8[1];
        v11 = *(__m128i *)(v6 + 1232);
        v3[3].m128i_i8[0] = v15;
        _mm_storeu_si128(v3 + 1, v11);
        v12 = v4[5];
        if ( v12 )
          TmGetTransactionId(v12, v3);
        else
          _mm_storeu_si128(v3, (__m128i)xmmword_140028BA0);
        v5 = 1;
      }
    }
    sub_14000AB20(v8);
  }
  if ( v6 )
    FltReleaseContext(v6);
  return v5;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002162E: using guessed type __int64 __fastcall FltFsControlFile(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400285F8: using guessed type __int64 __fastcall TmGetTransactionId(_QWORD, _QWORD);
// 140028BA0: using guessed type __int128 xmmword_140028BA0;

//----- (0000000140015158) ----------------------------------------------------
PVOID __fastcall sub_140015158(__int64 a1)
{
  PVOID *v1; // rbx
  __int64 v2; // rdi
  __int64 v3; // rcx
  int v4; // eax
  __int64 v5; // rcx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]

  v1 = (PVOID *)(a1 + 72);
  v2 = a1;
  if ( !*(_QWORD *)(a1 + 72) )
  {
    v3 = *(_QWORD *)(a1 + 80);
    if ( v3 )
    {
      v4 = sub_140007050(v3, v1);
      if ( v4 || !*v1 )
      {
        v5 = *(_QWORD *)(v2 + 56);
        *v1 = 0i64;
        LODWORD(BugCheckParameter3) = v4;
        sub_140006BB4(0x191ui64, 0x5E0ui64, 0i64, 0xE03D000F, BugCheckParameter3, v5);
      }
    }
  }
  return *v1;
}

//----- (00000001400151C8) ----------------------------------------------------
UNICODE_STRING *__fastcall sub_1400151C8(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rbp
  __int64 v4; // rdi
  UNICODE_STRING *v5; // rsi
  __int64 v6; // rbx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-38h]
  __int64 (__fastcall **v9)(PSLIST_ENTRY); // [rsp+40h] [rbp-18h]
  const UNICODE_STRING *v10[2]; // [rsp+48h] [rbp-10h]

  v2 = a2;
  v3 = a1;
  v4 = sub_140020530(*(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 32));
  if ( !v4 )
    return 0i64;
  v6 = sub_14001BD68(*(_QWORD *)(v2 + 24));
  if ( v6 )
  {
    sub_140020554(v4, &v9);
    v5 = sub_14001AD10(v6 + 152, v10[0], *(_QWORD *)(*(_QWORD *)(v3 + 16) + 56i64));
    if ( !v5 )
    {
      LODWORD(BugCheckParameter3) = -1073741823;
      sub_140006BB4(0x191ui64, 0x67Aui64, 0i64, 0xE03D0011, BugCheckParameter3, (char)v10[0]);
    }
    v9 = &off_140028B58;
    if ( v10[0] )
    {
      sub_14001A4D8(v10[0]);
      v10[0] = 0i64;
    }
    sub_14001CE9C(&v9);
    FltReleaseContext(v6);
  }
  else
  {
    LODWORD(BugCheckParameter3) = -1073741823;
    sub_140006BB4(0x191ui64, 0x669ui64, 0i64, 0xE03D0042, BugCheckParameter3, *(unsigned __int64 *)(v2 + 32) + 88);
    v5 = 0i64;
  }
  FltReleaseContext(v4);
  return v5;
}
// 14001A4D8: using guessed type __int64 __fastcall sub_14001A4D8(_QWORD);
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 140028B58: using guessed type __int64 (__fastcall *off_140028B58)(PSLIST_ENTRY ListEntry);

//----- (00000001400152F8) ----------------------------------------------------
const wchar_t *__fastcall sub_1400152F8(signed int a1)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx

  if ( a1 <= 9 )
  {
    if ( a1 == 9 )
      return L"more checking needed";
    v1 = a1 - 1;
    if ( !v1 )
      return L"safe";
    v2 = v1 - 1;
    if ( !v2 )
      return L"error";
    v3 = v2 - 1;
    if ( !v3 )
      return L"unchecked";
    v4 = v3 - 1;
    if ( !v4 )
      return L"virus found";
    v5 = v4 - 1;
    if ( !v5 )
      return L"not a file";
    v6 = v5 - 1;
    if ( !v6 )
      return L"disinfection successful";
    v7 = v6 - 1;
    if ( !v7 )
      return L"file exempt";
    if ( v7 == 1 )
      return L"action pending";
    return L"???";
  }
  v9 = a1 - 10;
  if ( !v9 )
    return L"threat neutralized";
  v10 = v9 - 1;
  if ( !v10 )
    return L"invalid device";
  v11 = v10 - 1;
  if ( !v11 )
    return L"no media";
  v12 = v11 - 1;
  if ( !v12 )
    return L"cancelled";
  v13 = v12 - 1;
  if ( !v13 )
    return L"data control, block access";
  v14 = v13 - 1;
  if ( !v14 )
    return L"data control, allow access once";
  if ( v14 != 1 )
    return L"???";
  return L"data control, allow access and cache the result";
}
// 1400254E0: using guessed type wchar_t aSafe[5];
// 1400254F0: using guessed type wchar_t aError[6];
// 140025500: using guessed type wchar_t aUnchecked[10];
// 140025520: using guessed type wchar_t aVirusFound[12];
// 140025540: using guessed type wchar_t aNotAFile[11];
// 140025560: using guessed type wchar_t aDisinfectionSu[24];
// 140025590: using guessed type wchar_t aFileExempt[12];
// 1400255B0: using guessed type wchar_t aActionPending[15];
// 1400255D0: using guessed type wchar_t aMoreCheckingNe[21];
// 140025600: using guessed type wchar_t aThreatNeutrali[19];
// 140025630: using guessed type wchar_t aInvalidDevice[15];
// 140025650: using guessed type wchar_t aNoMedia[9];
// 140025670: using guessed type wchar_t aCancelled[10];
// 140025690: using guessed type wchar_t aDataControlBlo[27];
// 1400256D0: using guessed type wchar_t aDataControlAll_0[32];
// 140025710: using guessed type wchar_t aDataControlAll[48];
// 140025770: using guessed type wchar_t asc_140025770[4];

//----- (00000001400153D4) ----------------------------------------------------
__int64 __fastcall sub_1400153D4(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rcx
  __int64 result; // rax

  v1 = a1;
  *(_QWORD *)(a1 + 80) = 0i64;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_WORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 108) = 0i64;
  *(_BYTE *)(a1 + 88) = 0;
  *(_BYTE *)(a1 + 116) = 0;
  v2 = *(_QWORD *)(a1 + 56);
  if ( v2 )
    sub_14001A4D8(v2);
  *(_QWORD *)(v1 + 56) = 0i64;
  *(_BYTE *)(v1 + 120) = 0;
  *(_BYTE *)(v1 + 64) = 0;
  *(_BYTE *)(v1 + 176) = 0;
  *(_WORD *)(v1 + 8) = 0;
  sub_14001749C(v1 + 24);
  result = sub_140007518(__readgsqword(0x188u));
  *(_QWORD *)(v1 + 16) = result;
  return result;
}
// 14001A4D8: using guessed type __int64 __fastcall sub_14001A4D8(_QWORD);

//----- (000000014001544C) ----------------------------------------------------
char __fastcall sub_14001544C(__int64 a1, __int64 a2, int a3, __int64 a4, char a5)
{
  int v5; // er10
  char result; // al

  v5 = *(_DWORD *)(a1 + 24);
  result = 0;
  if ( v5 & 4 && a3 & 0x2010000 || !a5 && v5 & 2 && a3 & 0x2000006 )
  {
    sub_140016430(a1, a2, a3, a4);
    result = 1;
  }
  else
  {
    *(_BYTE *)(a1 + 114) &= 0xC8u;
  }
  return result;
}

//----- (000000014001548C) ----------------------------------------------------
char __fastcall sub_14001548C(__int64 a1, int a2, unsigned int a3)
{
  char v3; // r9
  unsigned int v4; // er8
  signed int v5; // eax

  v3 = 0;
  if ( *(_DWORD *)(a1 + 24) & 1 )
  {
    v4 = a3 >> 24;
    if ( v4 > 5 || (v5 = 53, !_bittest(&v5, v4)) )
    {
      if ( a2 & 0x2000021 )
      {
        *(_BYTE *)(a1 + 116) |= 2u;
        v3 = 1;
      }
    }
  }
  if ( a2 & 0x2000020 )
    *(_BYTE *)(a1 + 116) |= 8u;
  return v3;
}

//----- (00000001400154CC) ----------------------------------------------------
char __fastcall sub_1400154CC(__int64 a1, char a2)
{
  char v2; // al
  char v3; // bl
  __int64 v4; // rdi
  bool v5; // zf
  int v7; // ecx

  v2 = *(_BYTE *)(a1 + 114);
  v3 = 0;
  v4 = a1;
  if ( a2 )
    v5 = (v2 & 1) == 0;
  else
    v5 = (v2 & 2) == 0;
  if ( v5 )
    return 0;
  if ( !sub_140013954(*(_WORD **)(a1 + 56)) )
  {
    v7 = *(_DWORD *)(v4 + 24);
    if ( v7 & 4 && (*(_BYTE *)(v4 + 114) & 0x60) == 96 )
    {
      v3 = 1;
    }
    else if ( v7 & 2 )
    {
      v3 = 0;
      if ( *(_BYTE *)(v4 + 114) & 0x10 )
        v3 = 1;
    }
  }
  return v3;
}

//----- (0000000140015540) ----------------------------------------------------
bool __fastcall sub_140015540(__int64 a1, unsigned __int16 a2, __int64 a3)
{
  struct _FAST_MUTEX *v3; // rbp
  __int64 v4; // r14
  __int64 v5; // rdi
  unsigned __int16 v6; // r15
  signed __int16 v7; // si
  __int16 v8; // bx
  PVOID v10; // rax
  int v11; // eax

  v3 = (struct _FAST_MUTEX *)(a3 + 1096);
  v4 = a1;
  v5 = a3;
  v6 = a2;
  ExAcquireFastMutex((PFAST_MUTEX)(a3 + 1096));
  v7 = *(_WORD *)(v5 + 1066);
  v8 = 1;
  if ( v7 == 2 )
  {
    if ( MEMORY[0xFFFFF78000000014] - *(_QWORD *)(v5 + 1152) >= 20000000i64 )
    {
      *(_WORD *)(v5 + 1066) = 1;
      v7 = 1;
    }
    else
    {
      v7 = *(_WORD *)(v5 + 1066);
      *(_QWORD *)(v5 + 1152) = MEMORY[0xFFFFF78000000014];
    }
  }
  ExReleaseFastMutex(v3);
  if ( v7 == 2 )
    return 0;
  v10 = sub_140015158(v4);
  v11 = (unsigned __int64)sub_1400167F8(v6, *(_DWORD *)(v4 + 32), (__int64)v10) - 1;
  if ( v11 )
  {
    if ( v11 == 3 )
      v8 = 3;
  }
  else
  {
    v8 = 2;
  }
  sub_1400164CC(v4, v5, v8);
  return v8 == 3;
}

//----- (0000000140015648) ----------------------------------------------------
char __fastcall sub_140015648(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  char v3; // bl
  __int64 v5; // [rsp+50h] [rbp+18h]
  __int64 v6; // [rsp+58h] [rbp+20h]

  v2 = a1;
  v3 = 0;
  if ( (signed int)FltGetEcpListFromCallbackData(a1, a2, &v5) >= 0 )
  {
    if ( v5 )
    {
      if ( (signed int)FltFindExtraCreateParameter(v2, v5, &unk_140028C18, &v6, 0i64) >= 0 )
      {
        v3 = 0;
        if ( !(unsigned __int8)FltIsEcpFromUserMode(v2, v6) )
          v3 = 1;
      }
    }
  }
  return v3;
}
// 1400215CE: using guessed type __int64 __fastcall FltFindExtraCreateParameter(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400215FE: using guessed type __int64 __fastcall FltGetEcpListFromCallbackData(_QWORD, _QWORD, _QWORD);
// 14002163A: using guessed type __int64 __fastcall FltIsEcpFromUserMode(_QWORD, _QWORD);

//----- (00000001400156B4) ----------------------------------------------------
LONG __fastcall sub_1400156B4(__int64 a1, _WORD *a2)
{
  _WORD *v2; // rbx
  __int64 v3; // rdi
  char v5; // [rsp+30h] [rbp-28h]
  int v6; // [rsp+40h] [rbp-18h]

  v2 = a2;
  v3 = a1;
  sub_14001B244(a2, &v6, (UNICODE_STRING *)&v5, 1);
  if ( (_WORD)v6 )
    *(int *)((char *)&v6 + 2) = 58;
  else
    v6 = 92;
  return sub_140007A38((__int64)L"%S %Z (%S%Z)", v3, v2, &v6, &v5);
}
// 140025780: using guessed type wchar_t aSZSZ[13];

//----- (000000014001573C) ----------------------------------------------------
void __fastcall sub_14001573C(__int64 a1)
{
  sub_14001EBC0(
    (__int64 *)(a1 + 168),
    *(unsigned __int16 **)(a1 + 56),
    *(_QWORD *)(a1 + 72),
    *(_BYTE *)(a1 + 115) & 1,
    (*(_BYTE *)(a1 + 115) >> 1) & 1);
}

//----- (000000014001576C) ----------------------------------------------------
void __fastcall sub_14001576C(__int64 a1, __int64 a2, __int64 *a3, __int64 *a4, char a5, _BYTE *a6, __int64 a7, unsigned int a8)
{
  __int64 v8; // rbx
  __int64 *v9; // r14
  __int64 *v10; // r13
  __int64 v11; // rbp
  __int64 v12; // rdi
  PEPROCESS v13; // rax
  bool v14; // zf
  char v15; // al
  char v16; // si
  _BYTE *v17; // r15
  __int64 v18; // r14
  __int64 v19; // rax
  int v20; // ecx
  __int64 v21; // rax
  int v22; // ecx
  int v23; // ebx
  struct _SLIST_ENTRY *v24; // rcx
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // rbx
  __int64 v28; // rbx
  unsigned int v29; // eax
  char v30; // [rsp+60h] [rbp+8h]

  v8 = __readgsqword(0x188u);
  v9 = a4;
  v10 = a3;
  v11 = a2;
  v12 = a1;
  v13 = IoGetCurrentProcess();
  if ( sub_140010A04((__int64)v13, v8) || (v14 = sub_140014470(v12) == 0, v15 = 0, !v14) )
    v15 = 1;
  if ( dword_140039698 != 4 || (v16 = 0, v15) )
    v16 = 1;
  v17 = a6;
  v18 = *v9;
  *a6 = 0;
  v19 = *(_QWORD *)(*(_QWORD *)(v11 + 16) + 24i64);
  v20 = *(_DWORD *)(v19 + 16);
  if ( v20 & 0x2000000 && *(_DWORD *)(*(_QWORD *)(v19 + 8) + 20i64) != v20 )
  {
    if ( *(_BYTE *)(v12 + 114) < 0 )
    {
      v30 = 0;
      if ( sub_14001EAF4(v11, &v30) )
        *(_BYTE *)(v12 + 115) ^= (*(_BYTE *)(v12 + 115) ^ 4 * v30) & 4;
      else
        *(_BYTE *)(v12 + 114) &= 0x7Fu;
    }
    v21 = *(_QWORD *)(*(_QWORD *)(v11 + 16) + 24i64);
    v22 = *(_DWORD *)(v21 + 16);
    if ( !(v22 & 0x2000000) || (v23 = *(_DWORD *)(*(_QWORD *)(v21 + 8) + 20i64), v23 == v22) )
      v23 = *(_DWORD *)(v21 + 16);
    if ( *(_BYTE *)(v12 + 8) && !_bittest(&v23, 8u) )
      *(_BYTE *)(v12 + 8) = 0;
    if ( *(_BYTE *)(v12 + 9) && !_bittest(&v23, 0x10u) )
      *(_BYTE *)(v12 + 9) = 0;
    if ( !v16 )
    {
      sub_14001544C(v12, v10[4], v23, *(_QWORD *)(v11 + 16), *(_BYTE *)(v12 + 64));
      if ( !*(_BYTE *)(v12 + 64) && *(_BYTE *)(v18 + 1214) && *(_BYTE *)(v12 + 105) )
        *(_BYTE *)(v12 + 105) = sub_14001548C(v12, v23, *(_DWORD *)(*(_QWORD *)(v11 + 16) + 32i64));
    }
  }
  if ( *(_BYTE *)(v12 + 114) < 0 )
  {
    if ( !sub_14000BBF4(*(_QWORD *)(v12 + 168)) )
    {
      v25 = PsGetCurrentProcessId(v24);
      v26 = sub_14000BBB4(v25);
      v24 = *(struct _SLIST_ENTRY **)(v12 + 168);
      v27 = v26;
      if ( v24 != (struct _SLIST_ENTRY *)v26 )
      {
        sub_14000BBE4(v24);
        *(_QWORD *)(v12 + 168) = v27;
      }
    }
    if ( !*(_QWORD *)(v12 + 80) )
      *(_QWORD *)(v12 + 80) = sub_1400109C8(*(_QWORD *)(v11 + 16));
    if ( dword_140035180 & 0x10000000 )
    {
      v28 = *(_QWORD *)(v12 + 56);
      v29 = PsGetCurrentProcessId(v24);
      sub_140007A38((__int64)L"Process 0x%x should notify file %Z", v29, v28);
    }
  }
  if ( a5 )
  {
    if ( sub_140016340(v12, v10, a7, a8) )
      *v17 = 1;
  }
}
// 1400257A0: using guessed type wchar_t aProcess0xXShou[35];
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 140035180: using guessed type int dword_140035180;
// 140039698: using guessed type int dword_140039698;

//----- (000000014001599C) ----------------------------------------------------
signed __int64 __fastcall sub_14001599C(__int64 a1, __int64 a2, __int64 *a3, __int64 *a4)
{
  __int64 *v4; // r14
  __int64 *v5; // r13
  __int64 v6; // rsi
  __int64 v7; // rdi
  __int64 v8; // rbx
  PEPROCESS v9; // rax
  char v10; // r12
  unsigned __int64 v11; // rax
  _BYTE *v12; // r14
  unsigned int v13; // ebx
  __int64 v14; // r8
  _QWORD *v15; // r14
  __int64 v16; // rcx
  __int64 v17; // rcx
  __int64 (__fastcall **v19)(PSLIST_ENTRY); // rax
  __int64 v20; // rcx
  __int64 v21; // rcx
  _DWORD *v22; // r8
  __int64 v23; // rax
  __int64 v24; // rcx
  char v25; // al
  char v26; // cl
  char v27; // r15
  unsigned __int16 v28; // ax
  __int64 v29; // rax
  unsigned __int16 v30; // cx
  char v31; // al
  int v32; // eax
  char v33; // [rsp+40h] [rbp-40h]
  char v34; // [rsp+41h] [rbp-3Fh]
  char v35; // [rsp+42h] [rbp-3Eh]
  unsigned __int64 LowLimit; // [rsp+48h] [rbp-38h]
  unsigned __int64 HighLimit; // [rsp+50h] [rbp-30h]
  __int64 (__fastcall **v38)(PSLIST_ENTRY); // [rsp+58h] [rbp-28h]
  __int64 v39; // [rsp+60h] [rbp-20h]
  __int64 (__fastcall **v40)(PSLIST_ENTRY); // [rsp+68h] [rbp-18h]
  __int64 v41; // [rsp+70h] [rbp-10h]
  char v42; // [rsp+C8h] [rbp+48h]
  __int64 *v43; // [rsp+D8h] [rbp+58h]

  v43 = a4;
  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 24i64) + 16i64) & 0xFFEFFF7F) || sub_1400192EC() )
    return 0i64;
  v8 = __readgsqword(0x188u);
  v9 = IoGetCurrentProcess();
  if ( sub_140010A04((__int64)v9, v8) || (v10 = 0, sub_140014470(v7)) )
    v10 = 1;
  v35 = sub_140004500();
  if ( v10 )
  {
    if ( !sub_14000AD9C() && v35 )
      return 0i64;
  }
  if ( *(_BYTE *)(*(_QWORD *)(v6 + 16) + 6i64) & 2 )
    return 0i64;
  if ( !*(_WORD *)(v5[4] + 88) )
    return 0i64;
  if ( sub_140015648(v5[1], v6) )
    return 0i64;
  IoGetStackLimits(&LowLimit, &HighLimit);
  v11 = v5[4];
  if ( v11 > LowLimit && v11 < HighLimit )
    return 0i64;
  v12 = (_BYTE *)(*v4 + 152);
  *(_WORD *)(v7 + 114) = 0;
  v13 = 0;
  if ( !*(_QWORD *)(v7 + 40) )
    return 0i64;
  v14 = *(_QWORD *)(v6 + 16);
  if ( !(*(_DWORD *)(v14 + 32) & 1) )
  {
LABEL_28:
    v19 = (__int64 (__fastcall **)(PSLIST_ENTRY))sub_140004E24(*(_QWORD *)(v7 + 40), &v40);
    v38 = v19;
    if ( (__int64 (__fastcall **)(PSLIST_ENTRY))(v7 + 48) != v19 )
    {
      v20 = *(_QWORD *)(v7 + 56);
      if ( v20 )
      {
        sub_14001A4D8(v20);
        *(_QWORD *)(v7 + 56) = 0i64;
        v19 = v38;
      }
      v21 = (__int64)v19[1];
      *(_QWORD *)(v7 + 56) = v21;
      if ( v21 )
        sub_14001B77C(v21);
    }
    v40 = &off_140028B58;
    if ( v41 )
    {
      sub_14001A4D8(v41);
      v41 = 0i64;
    }
    sub_14001CE9C(&v40);
    if ( *(_QWORD *)(v7 + 56) )
    {
      v22 = *(_DWORD **)(v7 + 40);
      v34 = 0;
      v23 = *v43;
      v24 = v5[4];
      v33 = 0;
      v42 = 0;
      if ( sub_14001E910(v24, (__int64)v12, v22, v6, *(_BYTE *)(v23 + 1336) != 0, &v34, (bool *)&v33, (bool *)&v42) )
      {
        v13 = 1;
        v25 = v33;
        v26 = v42 & 1;
        *(_BYTE *)(v7 + 114) |= 0x80u;
        *(_BYTE *)(v7 + 115) = v34 & 1 | *(_BYTE *)(v7 + 115) & 0xF8 | 2 * (v25 & 1 | 2 * v26);
      }
      if ( dword_140039698 != 4 || v10 )
      {
        v27 = 1;
        if ( v35 )
          return v13;
      }
      else
      {
        v27 = 0;
      }
      if ( sub_140004F74(*(_DWORD **)(v7 + 40), 1) )
      {
        *(_BYTE *)(v7 + 64) = 1;
      }
      else
      {
        if ( !*(_QWORD *)(v7 + 80) )
          *(_QWORD *)(v7 + 80) = sub_1400109C8(*(_QWORD *)(v6 + 16));
        if ( !v27 )
        {
          v28 = sub_140004DF4(*(_QWORD *)(v7 + 40));
          if ( !(*(_DWORD *)(v7 + 28) & 1)
            && v12[1063]
            && v12[1062]
            && !v12[1064]
            && v28
            && sub_140015540(v7, v28, (__int64)v12)
            && !(*(_DWORD *)(v7 + 24) & 8) )
          {
            return 3i64;
          }
        }
        if ( !(*(_DWORD *)(*(_QWORD *)(v6 + 16) + 32i64) & 1) )
        {
          v29 = v5[4];
          v30 = *(_WORD *)(v29 + 88);
          if ( v30 <= 2u || *(_WORD *)(*(_QWORD *)(v29 + 96) + 2 * ((unsigned __int64)v30 >> 1) - 2) != 92 )
          {
            v31 = sub_140004F74(*(_DWORD **)(v7 + 40), 2);
            *(_BYTE *)(v7 + 64) = v31 == 1;
            if ( v31 != 1 )
            {
              sub_1400162C0(v7, (__int64)v12, *(_QWORD *)(v6 + 16));
              v32 = sub_140015E68(v7, (__int64)v12, *(_QWORD *)(v6 + 16));
              *(_DWORD *)(v7 + 108) = v32;
              if ( !((v32 - 2) & 0xFFFFFFFD) || *(_BYTE *)(v7 + 8) || *(_BYTE *)(v7 + 9) )
              {
                v13 = 2;
              }
              else if ( v32 == 1 )
              {
                v13 = 1;
              }
            }
            if ( !v27 )
            {
              if ( (sub_14001544C(
                      v7,
                      v5[4],
                      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v6 + 16) + 24i64) + 16i64),
                      *(_QWORD *)(v6 + 16),
                      *(_BYTE *)(v7 + 64))
                 || v5[5])
                && v13 != 2 )
              {
                v13 = 1;
              }
              if ( !*(_BYTE *)(v7 + 64)
                && sub_14001548C(
                     v7,
                     *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v6 + 16) + 24i64) + 16i64),
                     *(_DWORD *)(*(_QWORD *)(v6 + 16) + 32i64)) )
              {
                if ( v12[1062] )
                {
                  *(_BYTE *)(v7 + 105) = 1;
                  if ( v13 != 2 )
                    v13 = 1;
                }
                else
                {
                  *(_BYTE *)(v7 + 104) = 1;
                  v13 = 2;
                }
              }
            }
          }
        }
      }
      return v13;
    }
    return 0i64;
  }
  if ( !sub_1400162C0(v7, (__int64)v12, v14) )
  {
    if ( *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v6 + 16) + 24i64) + 16i64) & 0x20 )
      return 0i64;
    goto LABEL_28;
  }
  v15 = sub_140004F54(*(_QWORD *)(v7 + 40), &v38);
  if ( (_QWORD *)(v7 + 48) != v15 )
  {
    v16 = *(_QWORD *)(v7 + 56);
    if ( v16 )
    {
      sub_14001A4D8(v16);
      *(_QWORD *)(v7 + 56) = 0i64;
    }
    v17 = v15[1];
    *(_QWORD *)(v7 + 56) = v17;
    if ( v17 )
      sub_14001B77C(v17);
  }
  v38 = &off_140028B58;
  if ( v39 )
  {
    sub_14001A4D8(v39);
    v39 = 0i64;
  }
  sub_14001CE9C(&v38);
  if ( !*(_QWORD *)(v7 + 80) )
    *(_QWORD *)(v7 + 80) = sub_1400109C8(*(_QWORD *)(v6 + 16));
  sub_140015158(v7);
  return 1i64;
}
// 14001A4D8: using guessed type __int64 __fastcall sub_14001A4D8(_QWORD);
// 140028B58: using guessed type __int64 (__fastcall *off_140028B58)(PSLIST_ENTRY ListEntry);
// 140039698: using guessed type int dword_140039698;

//----- (0000000140015E68) ----------------------------------------------------
__int64 __fastcall sub_140015E68(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbp
  __int64 v4; // rsi
  __int64 v5; // r14
  unsigned int v6; // edi
  __int64 v7; // rcx
  _WORD *v8; // rbx
  PVOID v9; // rax
  __int64 v10; // rax
  signed int v11; // eax
  __int64 v13; // [rsp+20h] [rbp-18h]
  __int64 v14; // [rsp+28h] [rbp-10h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = 0;
  if ( sub_140004500() || sub_1400192EC() )
    return 0i64;
  if ( *(_BYTE *)(v4 + 1062) )
  {
    if ( *(_DWORD *)(*(_QWORD *)(v3 + 24) + 16i64) & 0x2000006 )
    {
      if ( (unsigned int)sub_14000336C(v4) != -1
        || (v8 = *(_WORD **)(v5 + 56), v9 = sub_140015158(v5), (unsigned int)sub_140003504((__int64)v9, v8)) )
      {
        v6 = 2;
      }
    }
  }
  if ( *(_DWORD *)(*(_QWORD *)(v3 + 24) + 16i64) & 0x2000001 )
  {
    v13 = 0i64;
    v14 = 0i64;
    v10 = PsGetCurrentProcessId(v7);
    if ( (unsigned int)sub_1400032BC(v10, (UNICODE_STRING *)&v13) != -1 )
    {
      if ( *(_BYTE *)(v4 + 1062) )
      {
        v11 = 1;
        if ( v6 == 2 )
          v11 = 4;
        v6 = v11;
      }
      else
      {
        v6 = 2;
      }
    }
  }
  return v6;
}
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);

//----- (0000000140015F64) ----------------------------------------------------
__int64 __fastcall sub_140015F64(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r12
  __int64 v5; // r15
  __int64 v6; // r14
  __int64 v7; // rdi
  __int64 v8; // rdx
  unsigned __int64 v9; // rbx
  _DWORD *v10; // rcx
  unsigned int v12; // ebx
  struct _SLIST_ENTRY **v13; // rsi
  __int64 v14; // rcx
  __int64 v15; // rax
  __int64 v16; // rbx
  __m128i *v17; // rbx
  PVOID v18; // rax
  char v19; // [rsp+30h] [rbp-30h]
  unsigned __int64 LowLimit; // [rsp+38h] [rbp-28h]
  unsigned __int64 HighLimit; // [rsp+40h] [rbp-20h]
  __int64 (__fastcall **v22)(PSLIST_ENTRY); // [rsp+48h] [rbp-18h]
  PCUNICODE_STRING String2; // [rsp+50h] [rbp-10h]
  char v24; // [rsp+98h] [rbp+38h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 24i64) + 16i64) & 0x2000006) )
    return 0i64;
  if ( !sub_14001EDAC() )
    return 0i64;
  if ( ExGetPreviousMode() != 1 )
    return 0i64;
  if ( sub_1400192EC() )
    return 0i64;
  v8 = *(_QWORD *)(v6 + 16);
  if ( *(_BYTE *)(v8 + 6) & 2 || *(_DWORD *)(*(_QWORD *)(v8 + 24) + 16i64) & 0x20 && *(_DWORD *)(v8 + 32) & 1 )
    return 0i64;
  v9 = *(_QWORD *)(v5 + 32);
  if ( !*(_WORD *)(v9 + 88) )
    return 0i64;
  if ( sub_140015648(*(_QWORD *)(v5 + 8), v6) )
    return 0i64;
  IoGetStackLimits(&LowLimit, &HighLimit);
  if ( v9 > LowLimit && v9 < HighLimit )
    return 0i64;
  v10 = *(_DWORD **)(v7 + 40);
  if ( !v10 )
    return 0i64;
  if ( sub_140004F74(v10, 0) )
  {
    *(_BYTE *)(v7 + 64) = 1;
    return 0i64;
  }
  sub_140004E24(*(_QWORD *)(v7 + 40), &v22);
  v19 = 0;
  v24 = 0;
  if ( sub_140020E24(String2, 0, &v19, &v24) )
  {
    v12 = 0;
  }
  else
  {
    if ( !*(_QWORD *)(v7 + 80) )
      *(_QWORD *)(v7 + 80) = sub_1400109C8(*(_QWORD *)(v6 + 16));
    v13 = (struct _SLIST_ENTRY **)(v7 + 168);
    if ( !sub_14000BBF4(*(_QWORD *)(v7 + 168)) )
    {
      v15 = PsGetCurrentProcessId(v14);
      v16 = sub_14000BBB4(v15);
      if ( *v13 != (struct _SLIST_ENTRY *)v16 )
      {
        sub_14000BBE4(*v13);
        *v13 = (struct _SLIST_ENTRY *)v16;
      }
    }
    v17 = (__m128i *)String2;
    v18 = sub_140015158(v7);
    v12 = sub_14001EDB4(v6, *(_QWORD *)(v5 + 32), v4, v17, (__int64)v18, (__int64 *)(v7 + 168));
  }
  v22 = &off_140028B58;
  if ( String2 )
  {
    sub_14001A4D8(String2);
    String2 = 0i64;
  }
  sub_14001CE9C(&v22);
  return v12;
}
// 14001A4D8: using guessed type __int64 __fastcall sub_14001A4D8(_QWORD);
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 140028B58: using guessed type __int64 (__fastcall *off_140028B58)(PSLIST_ENTRY ListEntry);

//----- (0000000140016134) ----------------------------------------------------
LONG __fastcall sub_140016134(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rax
  __int64 v4; // rbx
  LONG result; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]

  v2 = a2;
  v3 = sub_140020530(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
  v4 = v3;
  if ( v3 )
  {
    sub_1400205B4(v3, v2);
    result = FltReleaseContext(v4);
  }
  else
  {
    LODWORD(BugCheckParameter3) = -1073741823;
    result = sub_140006BB4(0x191ui64, 0x688ui64, 0i64, 0xE03D0011, BugCheckParameter3, *(_QWORD *)(v2 + 8));
  }
  return result;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);

//----- (00000001400161A4) ----------------------------------------------------
char __fastcall sub_1400161A4(__int64 a1, __int64 *a2, __int64 a3, unsigned int a4)
{
  _WORD *v4; // r14
  __int64 v5; // rsi
  _WORD *v6; // rax
  unsigned int v7; // er12
  __int64 v8; // r13
  __int64 *v9; // r15
  PVOID v10; // rax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-68h]

  v4 = (_WORD *)(a1 + 114);
  v5 = a1;
  LOBYTE(v6) = *(_BYTE *)(a1 + 114);
  v7 = a4;
  v8 = a3;
  v9 = a2;
  if ( (unsigned __int8)v6 & 3 || (char)v6 < 0 || *(_BYTE *)(a1 + 8) || *(_BYTE *)(a1 + 9) || *(_BYTE *)(a1 + 192) & 1 )
  {
    v6 = *(_WORD **)(a1 + 56);
    if ( v6 )
    {
      if ( *v6 )
      {
        if ( !*(_QWORD *)(a1 + 96) )
        {
          v10 = sub_140015158(a1);
          LODWORD(v6) = sub_1400203F4(
                          v9[1],
                          v9[3],
                          v9[4],
                          v5 + 48,
                          v10,
                          v4,
                          (__int64 *)(v5 + 168),
                          v8,
                          v7,
                          (_WORD *)(v5 + 8),
                          (_QWORD *)(v5 + 96));
          if ( (signed int)v6 < 0 && (_DWORD)v6 != -1073741637 && (_DWORD)v6 != -1071906814 )
          {
            LODWORD(BugCheckParameter3) = (_DWORD)v6;
            LOBYTE(v6) = sub_140006BB4(0x191ui64, 0x2EDui64, 0i64, 0xE03D0043, BugCheckParameter3, *(_QWORD *)(v5 + 56));
          }
        }
      }
    }
  }
  return (char)v6;
}

//----- (00000001400162C0) ----------------------------------------------------
char __fastcall sub_1400162C0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rbp
  __int64 v5; // rdi
  char v6; // bl
  __int64 v7; // rcx

  *(_WORD *)(a1 + 8) = 0;
  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = 0;
  if ( sub_140004500() || sub_1400192EC() )
    return 0;
  if ( *(_BYTE *)(v4 + 1062) )
  {
    v7 = *(_QWORD *)(v3 + 24);
    if ( *(_DWORD *)(v7 + 16) & 0x2000100 )
    {
      *(_BYTE *)(v5 + 8) = 1;
      v6 = 1;
      v7 = *(_QWORD *)(v3 + 24);
    }
    if ( *(_DWORD *)(v7 + 16) & 0x2010000 )
    {
      *(_BYTE *)(v5 + 9) = 1;
      v6 = 1;
    }
  }
  return v6;
}

//----- (0000000140016340) ----------------------------------------------------
char __fastcall sub_140016340(__int64 a1, __int64 *a2, __int64 a3, unsigned int a4)
{
  _QWORD *v4; // r15
  __int64 v5; // rax
  unsigned int v6; // er12
  __int64 *v7; // r13
  __int64 v8; // rbp
  char v9; // r14
  _WORD *v10; // rbx
  __int64 *v11; // rdi
  _WORD *v12; // rsi
  PVOID v13; // rax
  unsigned int v14; // eax
  __int64 v16; // [rsp+A0h] [rbp+18h]

  v16 = a3;
  *(_BYTE *)(a1 + 115) |= 0x10u;
  v4 = (_QWORD *)(a1 + 96);
  v5 = *(_QWORD *)(a1 + 96);
  v6 = a4;
  v7 = a2;
  v8 = a1;
  v9 = 1;
  if ( v5 )
  {
    *(_BYTE *)(v5 + 33) |= 0x10u;
  }
  else
  {
    v10 = (_WORD *)(a1 + 8);
    v11 = (__int64 *)(a1 + 168);
    v12 = (_WORD *)(a1 + 114);
    v13 = sub_140015158(a1);
    v14 = sub_1400203F4(v7[1], v7[3], v7[4], v8 + 48, v13, v12, v11, v16, v6, v10, v4);
    if ( (v14 & 0x80000000) != 0 && v14 != -1073741637 && v14 != -1071906814 )
    {
      if ( dword_140035180 & 1 )
        sub_140007A38(
          (__int64)L"CheckOnFirstRead: Failed to create StreamHandleContext for file %Z, status: %x",
          *(_QWORD *)(v8 + 56),
          v14);
      v9 = 0;
    }
  }
  return v9;
}
// 140025D90: using guessed type wchar_t aCheckonfirstre[79];
// 140035180: using guessed type int dword_140035180;

//----- (0000000140016430) ----------------------------------------------------
char __fastcall sub_140016430(__int64 a1, __int64 a2, int a3, __int64 a4)
{
  __int64 v4; // rsi
  __int64 v5; // rbx
  char v6; // al
  int v7; // edi
  char result; // al
  __int64 v9; // rcx

  v4 = a4;
  v5 = a1;
  if ( a3 & 6 )
    *(_BYTE *)(a1 + 114) |= 0x10u;
  v6 = *(_BYTE *)(a1 + 114);
  v7 = a3 & 0x10000;
  if ( a3 & 0x10000 )
    v6 |= 0x20u;
  result = v6 | 1;
  *(_BYTE *)(a1 + 114) = result;
  v9 = *(_QWORD *)(a2 + 8);
  if ( v9 && !*(_QWORD *)(v9 + 56) )
  {
    if ( !(a3 & 0x21) )
    {
      *(_BYTE *)(v5 + 114) = result | 4;
      result = sub_140008CCC(*(_QWORD *)(a4 + 56), *(_DWORD *)(a4 + 48));
      if ( !(*(_BYTE *)(v4 + 42) & 1) || v7 || result )
      {
        result = *(_BYTE *)(v5 + 114) & 0xFE | 2;
        *(_BYTE *)(v5 + 114) = result;
      }
    }
    if ( *(_BYTE *)(v5 + 176) )
    {
      result = *(_BYTE *)(v5 + 114);
      if ( !(result & 0x10) )
      {
        result &= 0xFCu;
        *(_BYTE *)(v5 + 114) = result;
      }
    }
  }
  return result;
}

//----- (00000001400164CC) ----------------------------------------------------
void __fastcall sub_1400164CC(__int64 a1, __int64 a2, __int16 a3)
{
  struct _FAST_MUTEX *v3; // rsi
  __int16 v4; // bx
  __int64 v5; // rdi

  v3 = (struct _FAST_MUTEX *)(a2 + 1096);
  v4 = a3;
  v5 = a2;
  ExAcquireFastMutex((PFAST_MUTEX)(a2 + 1096));
  *(_WORD *)(v5 + 1066) = v4;
  if ( v4 == 2 )
    *(_QWORD *)(v5 + 1152) = MEMORY[0xFFFFF78000000014];
  ExReleaseFastMutex(v3);
}

//----- (0000000140016534) ----------------------------------------------------
int __fastcall sub_140016534(__int64 a1, const UNICODE_STRING *a2)
{
  int result; // eax
  __int64 v3; // rbx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]

  result = (signed int)a2;
  v3 = a1;
  if ( *(_BYTE *)(a1 + 114) < 0 )
  {
    result = sub_140020B50(a2, *(_BYTE *)(a1 + 115) & 1, (*(_BYTE *)(a1 + 115) >> 1) & 1);
    if ( result < 0 )
    {
      LODWORD(BugCheckParameter3) = result;
      result = sub_140006BB4(0x191ui64, 0x5CCui64, 0i64, 0xE03D0047, BugCheckParameter3, *(_QWORD *)(v3 + 56));
    }
  }
  return result;
}

//----- (0000000140016594) ----------------------------------------------------
unsigned __int8 __fastcall sub_140016594(__int64 a1, char a2)
{
  unsigned __int8 result; // al
  char v3; // r8
  __int64 v4; // rbx
  char v5; // cl
  char v6; // dl

  result = *(_BYTE *)(a1 + 114);
  v3 = a2;
  v4 = a1;
  if ( (result & 0x80u) != 0 )
  {
    v5 = *(_BYTE *)(a1 + 115);
    v6 = (result >> 6) & 1;
    if ( v5 & 4 && !v6 )
      goto LABEL_15;
    if ( !(v5 & 1) && v6 )
    {
      v5 = sub_14001EB34(v3, v4 + 48) | *(_BYTE *)(v4 + 115) & 0xFE;
      result = *(_BYTE *)(v4 + 114);
      *(_BYTE *)(v4 + 115) = v5;
    }
    if ( v5 & 3 && (v5 & 5) != 4 )
    {
      if ( result & 0x40 )
      {
        result = sub_140013954(*(_WORD **)(v4 + 56));
        if ( result )
          *(_BYTE *)(v4 + 114) &= 0x7Fu;
      }
    }
    else
    {
LABEL_15:
      result &= 0x7Fu;
      *(_BYTE *)(v4 + 114) = result;
    }
  }
  return result;
}

//----- (0000000140016610) ----------------------------------------------------
__int64 __fastcall sub_140016610(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)a1 = qword_140038080;
  result = (unsigned int)dword_140038088;
  *(_DWORD *)(a1 + 8) = dword_140038088;
  return result;
}
// 140038080: using guessed type __int64 qword_140038080;
// 140038088: using guessed type int dword_140038088;

//----- (0000000140016628) ----------------------------------------------------
bool sub_140016628()
{
  bool result; // al

  result = sub_140008D18();
  byte_140038090 = result;
  return result;
}
// 140038090: using guessed type char byte_140038090;

//----- (000000014001663C) ----------------------------------------------------
__int64 sub_14001663C()
{
  __int64 result; // rax

  ++stru_140038140.L.TotalAllocates;
  result = (__int64)ExpInterlockedPopEntrySList(&stru_140038140.L.ListHead);
  if ( !result )
  {
    ++stru_140038140.L.AllocateMisses;
    result = sub_140021A40((__int64 (*)(void))stru_140038140.L.Allocate);
  }
  return result;
}

//----- (000000014001668C) ----------------------------------------------------
void __fastcall sub_14001668C(PSLIST_ENTRY ListEntry)
{
  struct _SLIST_ENTRY *v1; // rbx

  if ( ListEntry )
  {
    ++stru_140038140.L.TotalFrees;
    v1 = ListEntry;
    if ( ExQueryDepthSList(&stru_140038140.L.ListHead) < stru_140038140.L.Depth )
    {
      ExpInterlockedPushEntrySList(&stru_140038140.L.ListHead, v1);
    }
    else
    {
      ++stru_140038140.L.FreeMisses;
      sub_140021A40((__int64 (*)(void))stru_140038140.L.Free);
    }
  }
}

//----- (00000001400166F0) ----------------------------------------------------
__int64 __fastcall sub_1400166F0(__m128i *a1, __m128i **a2)
{
  __m128i **v2; // rsi
  __m128i *v3; // rbx
  UNICODE_STRING *v4; // rax
  signed int v5; // edi
  PVOID v6; // rax
  void *v7; // rdi
  UNICODE_STRING Destination; // [rsp+20h] [rbp-18h]

  v2 = a2;
  v3 = a1;
  if ( !a1->m128i_i64[1] )
  {
    sub_14000576C((__m128i *)&Destination);
    v4 = sub_14000589C();
    v5 = sub_1400057A0(&Destination, &v4->Length, L"\\RegistryFilter");
    if ( v5 < 0 )
    {
LABEL_7:
      sub_14000577C((__int64)&Destination);
      return (unsigned int)v5;
    }
    v6 = ExAllocatePoolWithTag(PagedPool, 0x3Cui64, 0x61664349u);
    v7 = v6;
    if ( !v6 )
    {
      v5 = -1073741670;
      goto LABEL_7;
    }
    v3->m128i_i64[1] = (__int64)v6;
    WORD1(v3->m128i_i64[0]) = 60;
    if ( !sub_14000972C(&Destination, L"Altitude", (__int64)v3) )
    {
      _mm_storeu_si128(v3, (__m128i)xmmword_140028C50);
      ExFreePoolWithTag(v7, 0x61664349u);
      v5 = -1073741823;
      goto LABEL_7;
    }
    sub_14000577C((__int64)&Destination);
  }
  *v2 = v3;
  return 0i64;
}
// 140025E30: using guessed type wchar_t aRegistryfilter[16];
// 140025E50: using guessed type wchar_t aAltitude[9];
// 140028C50: using guessed type __int128 xmmword_140028C50;

//----- (00000001400167E4) ----------------------------------------------------
__int64 __fastcall sub_1400167E4(__m128i **a1)
{
  return sub_1400166F0((__m128i *)&unk_1400381C0, a1);
}

//----- (00000001400167F4) ----------------------------------------------------
char sub_1400167F4()
{
  return 1;
}

//----- (00000001400167F8) ----------------------------------------------------
signed __int64 __fastcall sub_1400167F8(unsigned __int16 a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // rbx
  unsigned int v4; // edi
  signed __int64 result; // rax
  int v6; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-30h]
  char v8[4]; // [rsp+40h] [rbp-10h]
  unsigned __int16 *v9; // [rsp+48h] [rbp-8h]
  unsigned __int16 v10; // [rsp+60h] [rbp+10h]
  unsigned int v11; // [rsp+78h] [rbp+28h]

  v10 = a1;
  v3 = a3;
  v4 = a2;
  if ( dword_140035180 & 4 )
  {
    sub_140007A38((__int64)L"Checking boot sector of drive %C:", a1);
    a1 = v10;
  }
  if ( sub_140016E2C(a1) )
  {
    v6 = sub_1400194E0(v4, v10, v3, &v11);
    if ( v6 )
    {
      if ( v6 != -1073741248 && v6 != -1073741749 && v6 != -1073741536 )
      {
        v9 = &v10;
        *(_DWORD *)v8 = 131074;
        LODWORD(BugCheckParameter3) = v6;
        sub_140006BB4(0x12Eui64, 0x3E5ui64, 0i64, 0xE03D000A, BugCheckParameter3, (unsigned __int64)v8);
        return 2i64;
      }
    }
    else if ( dword_140035180 & 8 )
    {
      sub_140007A38((__int64)L"Boot sector of drive %C has been scanned for viruses (status=%x)", v10, v11);
    }
    result = v11;
  }
  else
  {
    if ( dword_140035180 & 8 )
      sub_140007A38((__int64)L"Could not read boot sector of drive %C:", v10);
    result = 2i64;
  }
  return result;
}
// 140026020: using guessed type wchar_t aCheckingBootSe[34];
// 140026070: using guessed type wchar_t aCouldNotReadBo[40];
// 1400260C0: using guessed type wchar_t aBootSectorOfDr[65];
// 140035180: using guessed type int dword_140035180;

//----- (0000000140016900) ----------------------------------------------------
signed __int64 __fastcall sub_140016900(struct _FILE_OBJECT *a1, __int64 a2, _BYTE *a3)
{
  _BYTE *v3; // rdi
  __int64 v4; // rbx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]

  v3 = a3;
  v4 = a2;
  if ( a1->Flags & 0xB80 )
  {
    if ( dword_140035180 & 2 )
      goto LABEL_9;
    return 5i64;
  }
  if ( (unsigned int)sub_140016BA0(a1, a3) )
    return 2i64;
  if ( *((_DWORD *)v3 + 4) & 0x10 )
  {
    if ( dword_140035180 & 2 )
    {
      a2 = v4;
LABEL_9:
      sub_140007A38((__int64)L"Not a file %Z", a2);
    }
    return 5i64;
  }
  if ( !*((_QWORD *)v3 + 1) )
  {
    if ( dword_140035180 & 2 )
      sub_140007A38((__int64)L"Zero length file %Z", v4);
    return 1i64;
  }
  if ( *((_DWORD *)v3 + 3) && !byte_1400382A0 )
  {
    if ( v4 )
    {
      LODWORD(BugCheckParameter3) = -1073741823;
      sub_140006BB4(0x12Eui64, 0x330ui64, 0i64, 0x603D002Du, BugCheckParameter3, v4);
    }
    return 1i64;
  }
  return 9i64;
}
// 140025FD0: using guessed type wchar_t aNotAFileZ[14];
// 140025FF0: using guessed type wchar_t aZeroLengthFile[20];
// 140035180: using guessed type int dword_140035180;
// 1400382A0: using guessed type char byte_1400382A0;

//----- (00000001400169E0) ----------------------------------------------------
bool __fastcall sub_1400169E0(const UNICODE_STRING *a1)
{
  return sub_1400169F0(a1, 0, (const UNICODE_STRING *)L"\\\\");
}
// 140028CC0: using guessed type wchar_t asc_140028CC0[3];

//----- (00000001400169F0) ----------------------------------------------------
bool __fastcall sub_1400169F0(const UNICODE_STRING *a1, char a2, const UNICODE_STRING *a3)
{
  char v3; // di
  UNICODE_STRING *v4; // rbx
  bool result; // al
  unsigned __int16 v6; // [rsp+20h] [rbp-18h]
  _WORD *v7; // [rsp+28h] [rbp-10h]
  __int16 v8; // [rsp+50h] [rbp+18h]

  v3 = a2;
  v4 = (UNICODE_STRING *)a1;
  result = 0;
  if ( !a3 || RtlCompareUnicodeString(a1, a3, 1u) )
  {
    sub_14001B244(v4, &v8, (UNICODE_STRING *)&v6, 1);
    if ( v6 >= 2u
      && *v7 == 92
      && (v3 || v7[((unsigned __int64)v6 >> 1) - 1] != 92)
      && (v8 || !sub_140016CD4((__int16 *)&v6)) )
    {
      result = 1;
    }
  }
  return result;
}

//----- (0000000140016A90) ----------------------------------------------------
bool __fastcall sub_140016A90(const UNICODE_STRING *a1)
{
  return sub_1400169F0(a1, 1, 0i64);
}

//----- (0000000140016A9C) ----------------------------------------------------
signed __int64 __fastcall sub_140016A9C(struct _FILE_OBJECT *a1, _DWORD *a2, __int64 a3, _BYTE *a4)
{
  _BYTE *v4; // rsi
  __m128i *v5; // rbx
  _DWORD *v6; // rdi
  struct _FILE_OBJECT *v7; // rbp
  signed __int64 result; // rax
  unsigned int v9; // edi
  char v10; // [rsp+20h] [rbp-18h]

  v4 = a4;
  v5 = (__m128i *)a3;
  v6 = a2;
  v7 = a1;
  if ( !a4 )
    return 9i64;
  if ( *a2 & 0x10
    || sub_14001B664(a3) && *v6 & 0x20
    || sub_140017014(v5)
    || sub_14001B3C4((__int64)v5) && (sub_14001ACF0((__int64)v5, (__int64)&v10), sub_140017014((__m128i *)&v10)) )
  {
    *v4 = 0;
    return 9i64;
  }
  if ( byte_140038280 )
  {
    *v4 = 0;
    if ( dword_140035180 & 2 )
      sub_140007A38((__int64)L"File not on extension list and type check off: %Z", v5);
    result = 1i64;
  }
  else
  {
    if ( *v4 )
      v9 = 1;
    else
      v9 = sub_1400171F0(v7);
    if ( v9 == 1 )
    {
      *v4 = 1;
      if ( dword_140035180 & 2 )
        sub_140007A38((__int64)L"Type check found file ot executable %Z", v5);
    }
    result = v9;
  }
  return result;
}
// 140025EA0: using guessed type wchar_t aFileNotOnExten[50];
// 140025F10: using guessed type wchar_t aTypeCheckFound[39];
// 140035180: using guessed type int dword_140035180;
// 140038280: using guessed type char byte_140038280;

//----- (0000000140016BA0) ----------------------------------------------------
signed __int64 __fastcall sub_140016BA0(struct _FILE_OBJECT *a1, _BYTE *a2)
{
  _BYTE *v2; // rbx
  unsigned int v3; // ecx
  unsigned int v5; // [rsp+20h] [rbp-58h]
  __int64 v6; // [rsp+28h] [rbp-50h]
  __int64 v7; // [rsp+30h] [rbp-48h]
  __int64 v8; // [rsp+38h] [rbp-40h]
  __int64 v9; // [rsp+40h] [rbp-38h]
  __int64 v10; // [rsp+58h] [rbp-20h]
  int v11; // [rsp+60h] [rbp-18h]

  v2 = a2;
  if ( *a2 )
    return 0i64;
  sub_1400120E0(a1, (__m128 *)&v7, (__m128i *)&v5);
  v3 = v5;
  if ( v5 )
  {
    if ( dword_140035180 & 2 )
    {
      sub_140007A38((__int64)L"Query failed Status:%x", v5);
      v3 = v5;
    }
    return v3;
  }
  if ( v6 == 56 )
  {
    *((_QWORD *)v2 + 1) = v10;
    *((_DWORD *)v2 + 4) = v11;
    *((_QWORD *)v2 + 3) = v7;
    *((_QWORD *)v2 + 4) = v8;
    *((_QWORD *)v2 + 5) = v9;
    *v2 = 1;
    return 0i64;
  }
  if ( dword_140035180 & 2 )
    sub_140007A38((__int64)L"Query failed unexpected size");
  return 3221225473i64;
}
// 140025F60: using guessed type wchar_t aQueryFailedSta[23];
// 140025F90: using guessed type wchar_t aQueryFailedUne[29];
// 140035180: using guessed type int dword_140035180;

//----- (0000000140016C60) ----------------------------------------------------
char sub_140016C60()
{
  UNICODE_STRING *v0; // rax
  char result; // al
  int v2; // [rsp+50h] [rbp+8h]

  ExInitializePagedLookasideList(&stru_140038200, 0i64, 0i64, 0, 0x400ui64, 0x48434349u, 0);
  v0 = sub_14000589C();
  result = sub_1400095B8(v0, L"DisableTypeCheck", &v2);
  if ( result )
  {
    result = byte_140038280;
    if ( v2 )
      result = 1;
    byte_140038280 = result;
  }
  return result;
}
// 140025E70: using guessed type wchar_t aDisabletypeche[17];
// 140038280: using guessed type char byte_140038280;

//----- (0000000140016CD4) ----------------------------------------------------
char __fastcall sub_140016CD4(__int16 *a1)
{
  __int16 v1; // r8
  _WORD *v2; // rcx
  _WORD *v3; // rcx
  __int16 v4; // r8
  _WORD *v5; // rcx
  bool v6; // zf

  v1 = *a1;
  if ( *a1 < 2 )
    return 0;
  v2 = (_WORD *)*((_QWORD *)a1 + 1);
  if ( *v2 != 92 )
    return 0;
  v3 = v2 + 1;
  v4 = v1 - 2;
  if ( !v4 )
    return 1;
  do
  {
    if ( *v3 == 92 )
      break;
    ++v3;
    v4 -= 2;
  }
  while ( v4 );
  if ( !v4 )
    return 1;
  v5 = v3 + 1;
  if ( v4 == 10 )
  {
    if ( (*v5 - 73) & 0xFFDF || (v5[1] - 80) & 0xFFDF || (v5[2] - 67) & 0xFFDF )
      return 0;
    v6 = v5[3] == 36;
    goto LABEL_28;
  }
  if ( v4 >= 12
    && !((*v5 - 80) & 0xFFDF)
    && !((v5[1] - 73) & 0xFFDF)
    && !((v5[2] - 80) & 0xFFDF)
    && !((v5[3] - 69) & 0xFFDF)
    && v5[4] == 92 )
  {
    return 1;
  }
  if ( v4 >= 20
    && !((*v5 - 77) & 0xFFDF)
    && !((v5[1] - 65) & 0xFFDF)
    && !((v5[2] - 73) & 0xFFDF)
    && !((v5[3] - 76) & 0xFFDF)
    && !((v5[4] - 83) & 0xFFDF)
    && !((v5[5] - 76) & 0xFFDF)
    && !((v5[6] - 79) & 0xFFDF)
    && !((v5[7] - 84) & 0xFFDF) )
  {
    v6 = v5[8] == 92;
LABEL_28:
    if ( v6 )
      return 1;
  }
  return 0;
}

//----- (0000000140016E2C) ----------------------------------------------------
char __fastcall sub_140016E2C(__int16 a1)
{
  char v1; // bl
  PDEVICE_OBJECT v2; // rcx
  struct _DEVICE_OBJECT *v3; // rdi
  PVOID v4; // rsi
  __int64 v5; // r14
  struct _IRP *v6; // rax
  NTSTATUS v7; // eax
  ULONG Length; // [rsp+38h] [rbp-29h]
  PFILE_OBJECT FileObject; // [rsp+40h] [rbp-21h]
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+48h] [rbp-19h]
  LARGE_INTEGER StartingOffset; // [rsp+58h] [rbp-9h]
  UNICODE_STRING ObjectName; // [rsp+60h] [rbp-1h]
  struct _KEVENT Event; // [rsp+78h] [rbp+17h]
  __int128 v15; // [rsp+90h] [rbp+2Fh]
  __int64 v16; // [rsp+A0h] [rbp+3Fh]
  int v17; // [rsp+A8h] [rbp+47h]
  __int16 v18; // [rsp+ACh] [rbp+4Bh]

  v17 = 3801176;
  v1 = 0;
  v18 = 0;
  LOWORD(v17) = a1;
  ObjectName.Buffer = (PWSTR)((char *)&v15 + 8);
  v15 = xmmword_140022E30;
  *(_DWORD *)&ObjectName.Length = 1966108;
  v16 = 25896191785238627i64;
  if ( IoGetDeviceObjectPointer(&ObjectName, 0x80u, (PFILE_OBJECT *)&IoStatusBlock, (PDEVICE_OBJECT *)&Event) >= 0 )
  {
    v2 = FileObject->DeviceObject;
    if ( v2 )
    {
      v3 = (struct _DEVICE_OBJECT *)IoGetAttachedDevice(v2);
      if ( sub_140008FA0(v3, &Length) )
      {
        if ( Length - 512 <= 0xFE00 )
        {
          v4 = ExAllocatePoolWithTag(PagedPool, (Length + 4095i64) & 0xFFFFFFFFFFFFF000ui64, 0x73624349u);
          if ( v4 )
          {
            v5 = Length;
            StartingOffset.QuadPart = 0i64;
            IoStatusBlock.Pointer = 0i64;
            IoStatusBlock.Information = 0i64;
            KeInitializeEvent(&Event, SynchronizationEvent, 0);
            v6 = IoBuildSynchronousFsdRequest(3u, v3, v4, v5, &StartingOffset, &Event, &IoStatusBlock);
            if ( v6 )
            {
              v7 = IofCallDriver(v3, v6);
              if ( v7 == 259 )
              {
                sub_140009B44(&Event);
                v7 = IoStatusBlock.Status;
              }
              if ( !v7 && IoStatusBlock.Information == v5 )
                v1 = 1;
            }
            ExFreePoolWithTag(v4, 0);
          }
        }
      }
    }
    ObfDereferenceObject(FileObject);
  }
  return v1;
}
// 140022E30: using guessed type __int128 xmmword_140022E30;
// 1400282C8: using guessed type __int64 __fastcall IoGetAttachedDevice(_QWORD);

//----- (0000000140017014) ----------------------------------------------------
bool __fastcall sub_140017014(__m128i *a1)
{
  unsigned __int16 v1; // r8
  unsigned __int16 v2; // dx
  __int16 *v3; // rax
  __int16 v4; // cx
  __m128i v6; // [rsp+20h] [rbp-18h]

  v1 = _mm_cvtsi128_si32(*a1);
  v6 = *a1;
  v6.m128i_i16[0] = v1;
  v2 = v1;
  if ( v1 < 2u )
    return 0;
  v3 = (__int16 *)(v6.m128i_i64[1] + 2 * ((unsigned __int64)v1 >> 1) - 2);
  if ( v1 )
  {
    while ( 1 )
    {
      v4 = *v3;
      if ( *v3 == 46 )
        break;
      if ( v4 == 92 )
        goto LABEL_7;
      if ( v4 == 58 )
        return 0;
      --v3;
      v2 -= 2;
      if ( !v2 )
        goto LABEL_7;
    }
    v6.m128i_i64[1] = (__int64)(v3 + 1);
    v6.m128i_i16[0] = v1 - v2;
  }
  else
  {
LABEL_7:
    v6.m128i_i16[0] = 0;
  }
  return sub_140013C44((unsigned __int16 *)&v6);
}

//----- (00000001400170A8) ----------------------------------------------------
__int64 __fastcall sub_1400170A8(__int64 a1, PVOID Object, __int64 a3, int a4, _QWORD *a5, PVOID Objecta, __int64 a7, int a8)
{
  _QWORD *v8; // rdi
  signed int v9; // ST70_4
  int v10; // ST68_4
  signed int v11; // ST58_4
  signed int v12; // ST50_4
  signed int v13; // ST48_4
  signed int v14; // ST40_4
  int v15; // ST20_4
  __int64 result; // rax
  char v17; // [rsp+80h] [rbp-48h]
  int v18; // [rsp+90h] [rbp-38h]
  __int64 v19; // [rsp+98h] [rbp-30h]
  __int64 v20; // [rsp+A0h] [rbp-28h]
  int v21; // [rsp+A8h] [rbp-20h]
  __int64 v22; // [rsp+B0h] [rbp-18h]

  v8 = a5;
  if ( !a5 || !Objecta )
    return 3221225473i64;
  v19 = 0i64;
  v9 = 2048;
  v20 = a1;
  _mm_storeu_si128((__m128i *)&v22, (__m128i)0i64);
  v18 = 48;
  v21 = 576;
  v10 = a8;
  v11 = 256;
  v12 = 1;
  v13 = 7;
  v14 = 128;
  v15 = a4;
  result = FltCreateFileEx(Object, a3, &a5, Objecta, v15, &v18, &v17, 0i64, v14, v13, v12, v11, a7, v10, v9);
  if ( (_DWORD)result != -1073740951 && (_DWORD)result != -1073741805 )
  {
    if ( (_DWORD)result == -1073741536 )
      return 3221225760i64;
    if ( (_DWORD)result == 264 )
    {
      ObfDereferenceObject(Objecta);
      FltClose(a5);
      return 3221225473i64;
    }
    if ( (signed int)result < 0 )
      return 3221225473i64;
    *v8 = a5;
    result = 0i64;
  }
  return result;
}
// 14002156E: using guessed type __int64 __fastcall FltClose(_QWORD);
// 140021622: using guessed type __int64 __fastcall FltCreateFileEx(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400171DC) ----------------------------------------------------
void sub_1400171DC()
{
  ExDeletePagedLookasideList(&stru_140038200);
}

//----- (00000001400171F0) ----------------------------------------------------
signed __int64 __fastcall sub_1400171F0(struct _FILE_OBJECT *a1)
{
  struct _FILE_OBJECT *v1; // rdi
  struct _SLIST_ENTRY *v2; // rbx
  signed __int64 result; // rax
  bool v4; // al
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-38h]
  int v6; // [rsp+30h] [rbp-28h]
  unsigned __int64 v7; // [rsp+38h] [rbp-20h]
  __int64 v8; // [rsp+68h] [rbp+10h]
  unsigned __int64 HighLimit; // [rsp+70h] [rbp+18h]
  unsigned __int64 LowLimit; // [rsp+78h] [rbp+20h]

  ++stru_140038200.L.TotalAllocates;
  v1 = a1;
  v2 = ExpInterlockedPopEntrySList(&stru_140038200.L.ListHead);
  if ( !v2 )
  {
    ++stru_140038200.L.AllocateMisses;
    v2 = (struct _SLIST_ENTRY *)sub_140021A40((__int64 (*)(void))stru_140038200.L.Allocate);
    if ( !v2 )
    {
      LODWORD(BugCheckParameter3) = -1073741670;
      sub_140006BB4(0x12Eui64, 0xF0ui64, 0i64, 0xE03D000B, BugCheckParameter3, 0);
      return 2i64;
    }
  }
  v8 = 0i64;
  if ( dword_14002B150[0]
    && (IoGetStackLimits(&LowLimit, &HighLimit), (unsigned __int64)&HighLimit - LowLimit <= dword_14002B150[0]) )
  {
    sub_140012694((__int64)v1, (__int64)&v8, 1024, (__int64)v2, (__int64)&v6, 0);
  }
  else
  {
    sub_1400124CC(v1, &v8, 0x400u, v2, (__m128i *)&v6, 0);
  }
  if ( v6 < 0 )
  {
    ++stru_140038200.L.TotalFrees;
    if ( ExQueryDepthSList(&stru_140038200.L.ListHead) < stru_140038200.L.Depth )
    {
      ExpInterlockedPushEntrySList(&stru_140038200.L.ListHead, v2);
    }
    else
    {
      ++stru_140038200.L.FreeMisses;
      sub_140021A40((__int64 (*)(void))stru_140038200.L.Free);
    }
    return 2i64;
  }
  v4 = sub_14002148C((__int64)v2, v7);
  ++stru_140038200.L.TotalFrees;
  if ( v4 )
  {
    if ( ExQueryDepthSList(&stru_140038200.L.ListHead) < stru_140038200.L.Depth )
    {
      ExpInterlockedPushEntrySList(&stru_140038200.L.ListHead, v2);
    }
    else
    {
      ++stru_140038200.L.FreeMisses;
      sub_140021A40((__int64 (*)(void))stru_140038200.L.Free);
    }
    result = 9i64;
  }
  else
  {
    if ( ExQueryDepthSList(&stru_140038200.L.ListHead) < stru_140038200.L.Depth )
    {
      ExpInterlockedPushEntrySList(&stru_140038200.L.ListHead, v2);
    }
    else
    {
      ++stru_140038200.L.FreeMisses;
      sub_140021A40((__int64 (*)(void))stru_140038200.L.Free);
    }
    result = 1i64;
  }
  return result;
}

//----- (0000000140017408) ----------------------------------------------------
__int64 __fastcall sub_140017408(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  FltAcquirePushLockExclusive(&unk_140038288);
  return v1;
}
// 14002150E: using guessed type __int64 __fastcall FltAcquirePushLockExclusive(_QWORD);

//----- (0000000140017428) ----------------------------------------------------
__int64 __fastcall sub_140017428(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  FltAcquirePushLockShared(&unk_140038288);
  return v1;
}
// 14002151A: using guessed type __int64 __fastcall FltAcquirePushLockShared(_QWORD);

//----- (0000000140017448) ----------------------------------------------------
__int64 sub_140017448()
{
  return FltReleasePushLock(&unk_140038288);
}
// 140021526: using guessed type __int64 __fastcall FltReleasePushLock(_QWORD);

//----- (0000000140017454) ----------------------------------------------------
char sub_140017454()
{
  UNICODE_STRING *v0; // rax
  char result; // al
  signed int v2; // ecx
  int v3; // [rsp+30h] [rbp+8h]

  v0 = sub_14000589C();
  result = sub_1400095B8(v0, L"ScanTimeOut", &v3);
  v2 = v3;
  LODWORD(qword_140038290) = 1;
  if ( !result )
    v2 = 600;
  HIDWORD(qword_140038290) = 0;
  dword_140038298 = v2;
  return result;
}
// 140026150: using guessed type wchar_t aScantimeout[12];
// 140038290: using guessed type __int64 qword_140038290;
// 140038298: using guessed type int dword_140038298;

//----- (000000014001749C) ----------------------------------------------------
__int64 __fastcall sub_14001749C(__int64 a1)
{
  __int64 v1; // rbx
  __int64 result; // rax

  if ( a1 )
  {
    v1 = a1;
    FltAcquirePushLockShared(&unk_140038288);
    *(_QWORD *)v1 = qword_140038290;
    *(_DWORD *)(v1 + 8) = dword_140038298;
    result = FltReleasePushLock(&unk_140038288);
  }
  return result;
}
// 14002151A: using guessed type __int64 __fastcall FltAcquirePushLockShared(_QWORD);
// 140021526: using guessed type __int64 __fastcall FltReleasePushLock(_QWORD);
// 140038290: using guessed type __int64 qword_140038290;
// 140038298: using guessed type int dword_140038298;

//----- (00000001400174DC) ----------------------------------------------------
__int64 __fastcall sub_1400174DC(_WORD *a1, unsigned __int64 a2)
{
  return sub_140013A58(a1, a2, (_DWORD *)&qword_140038290 + 1);
}
// 140038290: using guessed type __int64 qword_140038290;

//----- (00000001400174E8) ----------------------------------------------------
__int64 __fastcall sub_1400174E8(int a1)
{
  int v1; // ebx

  v1 = a1;
  FltAcquirePushLockExclusive(&unk_140038288);
  if ( ((unsigned __int8)v1 ^ (unsigned __int8)qword_140038290) & 0x10 )
    sub_14001A0A4();
  LODWORD(qword_140038290) = v1;
  return FltReleasePushLock(&unk_140038288);
}
// 14002150E: using guessed type __int64 __fastcall FltAcquirePushLockExclusive(_QWORD);
// 140021526: using guessed type __int64 __fastcall FltReleasePushLock(_QWORD);
// 140038290: using guessed type __int64 qword_140038290;

//----- (0000000140017524) ----------------------------------------------------
unsigned __int64 __fastcall sub_140017524(int a1, __int64 a2, _WORD *a3, char a4, _DWORD *a5, __m128i *a6)
{
  _DWORD *v6; // rbx
  __m128i *v7; // rcx
  __int16 v8; // cx
  unsigned __int64 result; // rax
  UNICODE_STRING v10; // [rsp+20h] [rbp-18h]
  __int16 v11; // [rsp+40h] [rbp+8h]

  v6 = a5;
  *a5 = a1;
  v6[3] = _InterlockedIncrement(&dword_140038340);
  v6[1] = *(_DWORD *)(a2 + 8);
  *((_BYTE *)v6 + 20) = a1 != 5;
  if ( byte_1400382A0 )
  {
    v6[262] = *(_DWORD *)(a2 + 12);
    *(_QWORD *)(v6 + 263) = *(_QWORD *)(a2 + 24);
    *(_QWORD *)(v6 + 265) = *(_QWORD *)(a2 + 32);
    *(_QWORD *)(v6 + 267) = *(_QWORD *)(a2 + 40);
    if ( byte_1400382A1 )
    {
      v7 = a6;
      _mm_storeu_si128((__m128i *)(v6 + 269), *a6);
      _mm_storeu_si128((__m128i *)(v6 + 273), v7[1]);
      *(_QWORD *)(v6 + 277) = v7[2].m128i_i64[0];
      *(_QWORD *)(v6 + 279) = v7[2].m128i_i64[1];
      *((_BYTE *)v6 + 1124) = v7[3].m128i_i8[0];
      *(_WORD *)((char *)v6 + 1125) = 0;
      *((_BYTE *)v6 + 1127) = 0;
    }
  }
  if ( !byte_140038312 )
    a4 &= 1u;
  *((_BYTE *)v6 + 21) = a4;
  sub_14001B244(a3, &v11, &v10, 1);
  v8 = v11;
  *((_WORD *)v6 + 11) = v11;
  result = sub_14001B3B0(v8, &v10.Length);
  v6[2] = result;
  if ( (unsigned int)result <= 0x400 )
  {
    result = sub_14001A2AC((_WORD *)v6 + 12, v11, &v10.Length);
    v6[2] = 0;
  }
  return result;
}
// 1400382A0: using guessed type char byte_1400382A0;
// 1400382A1: using guessed type char byte_1400382A1;
// 140038312: using guessed type char byte_140038312;
// 140038340: using guessed type int dword_140038340;

//----- (000000014001763C) ----------------------------------------------------
bool __fastcall sub_14001763C(__int64 a1, int a2, int a3)
{
  return *(_DWORD *)(a1 + 16) == a2 && *(_DWORD *)(a1 + 8) == a3;
}

//----- (0000000140017650) ----------------------------------------------------
__int64 __usercall sub_140017650@<rax>(PIRP Irp@<rcx>, int a2@<edx>, _DWORD *a3@<r8>, __int64 a4@<r9>, char a5, __int64 a6)
{
  __int64 v6; // r13
  _DWORD *v7; // r14
  int v8; // ebx
  PIRP v9; // r15
  PFILE_OBJECT v10; // rbp
  unsigned int v11; // esi
  __int64 v12; // rax
  signed __int64 v13; // rdi
  signed __int64 v14; // rax
  signed __int64 v15; // rdx
  bool v16; // zf
  LARGE_INTEGER *Timeout; // rax
  ULONG v18; // ecx
  unsigned int v19; // eax
  unsigned int v20; // ebx
  __int64 v21; // rdx
  _QWORD *v22; // rax
  int v24; // [rsp+40h] [rbp-68h]
  LARGE_INTEGER v25; // [rsp+48h] [rbp-60h]
  PVOID Object; // [rsp+50h] [rbp-58h]
  struct _KEVENT *v27; // [rsp+58h] [rbp-50h]
  __int64 v28; // [rsp+60h] [rbp-48h]

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = Irp;
  v10 = Irp->Tail.Overlay.CurrentStackLocation->FileObject;
  v11 = 0;
  v24 = sub_14000E494();
  *(_DWORD *)(v6 + 28) = 3;
  *(_DWORD *)(v6 + 40) = v8;
  KeInitializeEvent((PRKEVENT)v6, SynchronizationEvent, 0);
  ObfReferenceObject(v10);
  ExAcquireFastMutex(&unk_1400382C8);
  v10->FsContext = (PVOID)v6;
  v12 = qword_140038300;
  v13 = v6 + 104;
  if ( *(__int64 **)(qword_140038300 + 8) != &qword_140038300 )
    goto LABEL_32;
  *(_QWORD *)(v6 + 112) = &qword_140038300;
  *(_QWORD *)v13 = v12;
  *(_QWORD *)(v12 + 8) = v13;
  qword_140038300 = v6 + 104;
  ExReleaseFastMutex(&unk_1400382C8);
  v14 = 1048i64;
  v15 = byte_1400382A1 != 0 ? 1128i64 : 1076i64;
  v16 = byte_1400382A0 == 0;
  v9->IoStatus.Status = 0;
  if ( !v16 )
    v14 = v15;
  v9->IoStatus.Information = v14;
  IofCompleteRequest(v9, 1);
  v28 = a6;
  Object = (PVOID)v6;
  v27 = &stru_140038320;
  while ( 1 )
  {
    if ( v7 )
    {
      Timeout = &v25;
      v25.QuadPart = -10000000i64 * (signed int)(*v7 - v11);
    }
    else
    {
      Timeout = 0i64;
    }
    v18 = (a6 != 0) + 2;
    if ( a5 )
      v19 = sub_1400099C4(v18, &Object, Timeout);
    else
      v19 = KeWaitForMultipleObjects(v18, &Object, WaitAny, 0, 0, 0, Timeout, 0i64);
    v20 = v19;
    if ( !v19 )
    {
      v20 = 0;
LABEL_17:
      if ( v20 != 258 )
        goto LABEL_24;
      goto LABEL_18;
    }
    if ( v19 == 1 )
      break;
    if ( v19 == 2 )
    {
      v20 = -1073741536;
      goto LABEL_24;
    }
    if ( v19 != 258 )
      goto LABEL_17;
    v11 = (unsigned __int64)sub_14000E494() - v24;
LABEL_18:
    if ( !v7 || *v7 <= v11 || !sub_14000E4A4() )
      goto LABEL_24;
  }
  v20 = -1073741248;
LABEL_24:
  ExAcquireFastMutex(&unk_1400382C8);
  v21 = *(_QWORD *)v13;
  if ( *(_QWORD *)(*(_QWORD *)v13 + 8i64) != v13 || (v22 = *(_QWORD **)(v6 + 112), *v22 != v13) )
LABEL_32:
    __fastfail(3u);
  *v22 = v21;
  *(_QWORD *)(v21 + 8) = v22;
  if ( v10->FsContext == (PVOID)v6 )
    v10->FsContext = 0i64;
  ExReleaseFastMutex(&unk_1400382C8);
  ObfDereferenceObject(v10);
  return v20;
}
// 1400382A0: using guessed type char byte_1400382A0;
// 1400382A1: using guessed type char byte_1400382A1;
// 140038300: using guessed type __int64 qword_140038300;

//----- (00000001400178D0) ----------------------------------------------------
void __fastcall sub_1400178D0(__int64 a1, __int64 a2)
{
  _LIST_ENTRY *v2; // rdi
  KIRQL v3; // al
  _LIST_ENTRY *v4; // rcx
  bool v5; // zf
  KIRQL v6; // r8
  struct _IRP *v7; // rbx
  _LIST_ENTRY *v8; // rax
  _LIST_ENTRY *v9; // rdx

  v2 = (_LIST_ENTRY *)a2;
  IoReleaseCancelSpinLock(*(_BYTE *)(a2 + 69));
  v3 = KeAcquireSpinLockRaiseToDpc(&Lock);
  v4 = stru_1400382B0.Flink;
  v5 = stru_1400382B0.Flink == &stru_1400382B0;
  v6 = v3;
  while ( 1 )
  {
    if ( v5 )
    {
      KeReleaseSpinLock(&Lock, v3);
      return;
    }
    v7 = (struct _IRP *)&v4[-11].Blink;
    if ( &v4[-11].Blink == (_LIST_ENTRY **)v2 )
    {
      if ( v7->Cancel )
        break;
    }
    v4 = v4->Flink;
    v5 = v4 == &stru_1400382B0;
  }
  v8 = v4->Flink;
  if ( v4->Flink->Blink != v4 || (v9 = v4->Blink, v9->Flink != v4) )
    __fastfail(3u);
  v9->Flink = v8;
  v8->Blink = v9;
  KeReleaseSpinLock(&Lock, v6);
  v7->IoStatus.Information = 0i64;
  v7->IoStatus.Status = -1073741536;
  IofCompleteRequest(v7, 1);
}

//----- (00000001400179B0) ----------------------------------------------------
signed __int64 __fastcall sub_1400179B0(__int64 a1, __int64 a2)
{
  __int64 v3; // rdi
  unsigned int v4; // er14
  char v5; // bl
  int v6; // esi
  unsigned int v7; // ecx
  _BYTE *v8; // rdx
  __int64 v9; // r8
  char v10; // cl
  signed int v11; // esi
  unsigned __int64 v12; // rax
  signed __int64 v13; // r8
  unsigned __int64 v14; // rcx
  signed __int64 v15; // rax
  unsigned int v16; // eax
  int v17; // eax
  signed __int64 v18; // r12
  int v19; // eax
  _BYTE *v20; // rcx
  __int64 v21; // rcx
  LONG *v22; // rsi
  __int64 v23; // rax
  struct _KEVENT *v24; // rcx
  signed int v25; // eax
  __int64 v26; // rdi
  struct _KEVENT *v27; // rcx
  PLIST_ENTRY v30; // rax
  int v32; // eax
  signed int v33; // esi
  __int64 v34; // rsi
  _WORD *v35; // rsi
  unsigned __int16 v36; // r13
  unsigned __int16 v37; // si
  unsigned int v38; // ecx
  _WORD *v39; // r12
  __int64 v40; // rdi
  __int64 v41; // rdi
  void *v42; // rdi
  int v43; // ebx
  __int64 v44; // r12
  unsigned int v45; // eax
  __int64 v46; // rbx
  signed int v47; // er9
  _QWORD *v48; // rdx
  unsigned int v49; // ecx
  void **v50; // r8
  unsigned __int8 v51; // al
  signed int v52; // ecx
  const wchar_t *v53; // rcx
  unsigned __int64 v54; // rax
  _QWORD *v55; // r8
  int v56; // eax
  int v57; // ebx
  __int64 *i; // rax
  signed __int64 v59; // rdx
  __int64 v60; // rcx
  _OWORD *v61; // rcx
  unsigned int v62; // eax
  __int64 v63; // rbx
  __int64 v64; // rdi
  PEPROCESS v65; // rax
  __int64 v66; // rdx
  unsigned __int64 v67; // rbx
  PEPROCESS v68; // rax
  __int64 v69; // rdx
  _DWORD *v70; // rsi
  unsigned int v71; // eax
  int v72; // er12
  __int64 *v73; // rax
  signed __int64 v74; // rdi
  unsigned __int64 v75; // rbx
  __int64 v76; // rbx
  PEPROCESS v77; // rax
  __int64 v78; // r8
  bool v79; // zf
  _DWORD *v80; // rax
  __int64 v81; // rbx
  PEPROCESS v82; // rax
  __int64 v83; // r8
  int v84; // eax
  __int64 v85; // rdx
  __m128i v86; // xmm0
  signed __int64 v87; // rdi
  unsigned __int16 v88; // cx
  __int64 v89; // rbx
  __int64 v90; // rsi
  int v91; // eax
  SIZE_T v92; // rbx
  PLARGE_INTEGER Timeout; // [rsp+20h] [rbp-1B8h]
  KIRQL Irql; // [rsp+50h] [rbp-188h]
  int v95; // [rsp+54h] [rbp-184h]
  _WORD *v96; // [rsp+58h] [rbp-180h]
  _WORD *v97; // [rsp+60h] [rbp-178h]
  char v98; // [rsp+68h] [rbp-170h]
  int v99; // [rsp+6Ch] [rbp-16Ch]
  int v100; // [rsp+70h] [rbp-168h]
  __int16 v101; // [rsp+78h] [rbp-160h]
  __int16 v102; // [rsp+7Ah] [rbp-15Eh]
  _QWORD *v103; // [rsp+80h] [rbp-158h]
  __int16 v104; // [rsp+88h] [rbp-150h]
  __int16 v105; // [rsp+8Ah] [rbp-14Eh]
  __int64 v106; // [rsp+90h] [rbp-148h]
  UNICODE_STRING v107; // [rsp+98h] [rbp-140h]
  __int64 v108; // [rsp+A8h] [rbp-130h]
  int v109; // [rsp+B0h] [rbp-128h]
  int v110; // [rsp+B8h] [rbp-120h]
  int v111; // [rsp+BCh] [rbp-11Ch]
  int v112; // [rsp+C0h] [rbp-118h]
  char v113; // [rsp+D0h] [rbp-108h]

  _R15 = a2;
  v108 = a2;
  v3 = *(_QWORD *)(a2 + 184);
  v4 = 0;
  *(_QWORD *)(a2 + 56) = 0i64;
  *(_DWORD *)(a2 + 48) = 0;
  v5 = 1;
  if ( KeGetCurrentIrql() > 1u )
  {
    v6 = -1073741823;
    *(_DWORD *)(a2 + 48) = -1073741823;
LABEL_338:
    IofCompleteRequest((PIRP)_R15, 0);
    return (unsigned int)v6;
  }
  v7 = *(_DWORD *)(v3 + 24);
  v8 = *(_BYTE **)(v3 + 48);
  if ( !v8 )
    goto LABEL_9;
  if ( !qword_140038338 || v8 != (_BYTE *)qword_140038338 )
  {
    v9 = (v7 >> 2) & 0xFFF;
    if ( (unsigned int)(v9 - 2304) > 0xC )
    {
      if ( v7 == -2019352564 || v7 == -2019352576 )
      {
        if ( !v8[76] || qword_140038338 )
          goto LABEL_9;
      }
      else
      {
        v12 = v7 + 2019352520;
        if ( (unsigned int)v12 > 0x30 || (v13 = 299616919650321i64, !_bittest64(&v13, v12)) )
        {
          if ( v7 + 2019348469 > 1 )
          {
            v14 = v7 + 2019352424;
            if ( (unsigned int)v14 > 0x3B )
              goto LABEL_9;
            v15 = 612489549322387457i64;
            if ( !_bittest64(&v15, v14) )
              goto LABEL_9;
          }
        }
        if ( !v8[74] || !sub_1400192EC() )
          goto LABEL_9;
      }
    }
    else
    {
      v10 = byte_140028D00[v9 - 2304];
      v98 = byte_140028D00[v9 - 2304];
      if ( !v8[75] && !v10 )
      {
LABEL_9:
        if ( *(_DWORD *)(v3 + 24) == -2019352520 && *(_BYTE *)(*(_QWORD *)(v3 + 48) + 74i64) )
        {
          if ( *(_DWORD *)(v3 + 16) != 1048 || *(_DWORD *)(v3 + 8) != 1048 )
          {
            v11 = -1073741811;
            *(_DWORD *)(_R15 + 48) = -1073741811;
            *(_QWORD *)(_R15 + 56) = 0i64;
          }
          else
          {
            **(_DWORD **)(_R15 + 24) = 3;
            *(_DWORD *)(_R15 + 48) = 0;
            *(_QWORD *)(_R15 + 56) = 1048i64;
            IofCompleteRequest((PIRP)_R15, 1);
            v11 = 0;
          }
          v4 = v11;
          goto LABEL_335;
        }
        v6 = -1073741790;
LABEL_337:
        *(_DWORD *)(_R15 + 48) = v6;
        goto LABEL_338;
      }
    }
  }
  v16 = *(_DWORD *)(v3 + 24);
  if ( v16 > 0x87A32094 )
  {
    if ( v16 > 0x87A32410 )
    {
      if ( v16 <= 0x87A3242C )
      {
        if ( v16 == -2019351508 )
        {
          if ( *(_DWORD *)(v3 + 16) || *(_DWORD *)(v3 + 8) )
            goto LABEL_239;
          sub_140004A68(*(_QWORD *)(v3 + 48));
          goto LABEL_76;
        }
        if ( v16 != -2019351532 )
        {
          switch ( v16 )
          {
            case 0x87A32418:
              if ( *(_DWORD *)(v3 + 16) )
                goto LABEL_239;
              v18 = 4i64;
              if ( *(_DWORD *)(v3 + 8) != 4 )
                goto LABEL_239;
              v81 = __readgsqword(0x188u);
              v82 = IoGetCurrentProcess();
              v83 = *(_QWORD *)(v3 + 48);
              v79 = sub_1400068EC((__int64)v82, v81) == 0;
              v80 = *(_DWORD **)(_R15 + 24);
              if ( !v79 )
              {
                *v80 = 1;
                goto LABEL_174;
              }
              break;
            case 0x87A3241C:
              if ( *(_DWORD *)(v3 + 16) )
                goto LABEL_239;
              v18 = 4i64;
              if ( *(_DWORD *)(v3 + 8) != 4 )
                goto LABEL_239;
              v77 = IoGetCurrentProcess();
              v78 = *(_QWORD *)(v3 + 48);
              v79 = sub_1400068EC((__int64)v77, 0i64) == 0;
              v80 = *(_DWORD **)(_R15 + 24);
              if ( !v79 )
              {
                *v80 = 1;
                goto LABEL_174;
              }
              break;
            case 0x87A32420:
              goto LABEL_283;
            case 0x87A32424:
              if ( *(_DWORD *)(v3 + 16) || *(_DWORD *)(v3 + 8) != 48 )
                goto LABEL_239;
              v76 = *(_QWORD *)(_R15 + 24);
              sub_140016610((__int64)&v108);
              *(_QWORD *)v76 = v108;
              *(_DWORD *)(v76 + 8) = v109;
              *(_DWORD *)(v76 + 12) = sub_140006BAC();
              sub_140011160(&v110);
              *(_DWORD *)(v76 + 16) = v110;
              *(_QWORD *)(v76 + 20) = 0i64;
              *(_DWORD *)(v76 + 28) = v111;
              *(_DWORD *)(v76 + 32) = v112;
              *(_QWORD *)(v76 + 36) = 0i64;
              *(_DWORD *)(v76 + 44) = 0;
              *(_QWORD *)(_R15 + 56) = 48i64;
              goto LABEL_76;
            case 0x87A32428:
              if ( !*(_DWORD *)(v3 + 16) && !*(_DWORD *)(v3 + 8) )
              {
                v17 = sub_140004A58(*(_QWORD *)(v3 + 48));
                goto LABEL_220;
              }
              goto LABEL_239;
            default:
              goto LABEL_308;
          }
          *v80 = 0;
          goto LABEL_174;
        }
        if ( *(_DWORD *)(v3 + 16) )
          goto LABEL_239;
        v18 = 4i64;
        if ( *(_DWORD *)(v3 + 8) != 4 )
          goto LABEL_239;
        v52 = 0;
        if ( dword_140039698 == 4 )
          v52 = 1;
        goto LABEL_173;
      }
      switch ( v16 )
      {
        case 0x87A32430:
          if ( *(_DWORD *)(v3 + 16) )
            goto LABEL_239;
          v18 = 4i64;
          if ( *(_DWORD *)(v3 + 8) != 4 )
            goto LABEL_239;
          v51 = sub_1400044D8();
          goto LABEL_172;
        case 0x87A33000:
          if ( *(_DWORD *)(v3 + 16) )
            goto LABEL_239;
          v18 = 4i64;
          if ( *(_DWORD *)(v3 + 8) != 4 )
            goto LABEL_239;
          v51 = sub_14000AD9C();
          goto LABEL_172;
        case 0x87A33004:
          if ( *(_DWORD *)(v3 + 16) == 4 && !*(_DWORD *)(v3 + 8) )
          {
            v17 = sub_14000ADBC(**(_BYTE **)(_R15 + 24));
            goto LABEL_220;
          }
          goto LABEL_239;
      }
      if ( v16 != -2019348469 )
      {
        if ( v16 == -2019348468 )
        {
          if ( *(_DWORD *)(v3 + 16) == 4 && *(_DWORD *)(v3 + 8) >= 4u )
          {
            v84 = sub_14000B388(**(unsigned int **)(_R15 + 24));
            v6 = v84;
            if ( v84 < 0 )
            {
              if ( v84 == -1073741820 )
              {
                **(_DWORD **)(_R15 + 24) = (_DWORD)v97;
                v6 = -2147483643;
                *(_QWORD *)(_R15 + 56) = 4i64;
              }
            }
            else
            {
              v85 = *(_QWORD *)(_R15 + 24);
              v86 = *(__m128i *)v85;
              v87 = v85 + 4;
              v88 = _mm_cvtsi128_si32(*(__m128i *)v85);
              *(_DWORD *)v85 = v88;
              v89 = v88;
              sub_140021A80((__m128i *)(v85 + 4), *(_OWORD *)&_mm_srli_si128(v86, 8), v88);
              *(_WORD *)(v89 + v87) = 0;
              *(_QWORD *)(_R15 + 56) = v89 + 6;
            }
            goto LABEL_337;
          }
          goto LABEL_239;
        }
        goto LABEL_308;
      }
      if ( *(_DWORD *)(v3 + 16) )
        goto LABEL_239;
      ExAcquireFastMutex(&unk_1400382C8);
      v90 = *(_QWORD *)(*(_QWORD *)(v3 + 48) + 24i64);
      if ( !v90 )
        goto LABEL_148;
      v91 = *(_DWORD *)(v90 + 72);
      if ( !v91 || !*(_QWORD *)(v90 + 64) )
      {
        v6 = -1073741823;
        goto LABEL_323;
      }
      if ( *(_DWORD *)(v3 + 8) == v91 )
      {
        v92 = *(unsigned int *)(v90 + 72);
        ProbeForWrite(*(PVOID *)(_R15 + 112), v92, 4u);
        sub_140021A80(*(__m128i **)(_R15 + 112), *(_QWORD *)(v90 + 64), v92);
        *(_QWORD *)(_R15 + 56) = v92;
        v6 = 0;
        v95 = 0;
        goto LABEL_323;
      }
      goto LABEL_320;
    }
    if ( v16 != -2019351536 )
    {
      if ( v16 <= 0x87A320CF )
      {
        if ( v16 == -2019352369 )
        {
          if ( *(_DWORD *)(v3 + 16) )
            goto LABEL_239;
          ExAcquireFastMutex(&unk_1400382C8);
          v60 = *(_QWORD *)(*(_QWORD *)(v3 + 48) + 24i64);
          if ( v60 )
          {
            v61 = *(_OWORD **)(v60 + 88);
            if ( v61 )
            {
              sub_140003C58(v61, (__int64)&v113);
              ExReleaseFastMutex(&unk_1400382C8);
              v62 = sub_140003D5C((__int64)&v113);
              if ( *(_DWORD *)(v3 + 8) != v62 )
              {
                sub_140003D28((__int64)&v113);
                goto LABEL_239;
              }
              v63 = *(_QWORD *)(_R15 + 112);
              v64 = v62;
              ProbeForWrite(*(PVOID *)(_R15 + 112), v62, 4u);
              sub_140003F48((__int64)&v113, v63);
              sub_140003D28((__int64)&v113);
              *(_QWORD *)(_R15 + 56) = v64;
              goto LABEL_76;
            }
          }
          goto LABEL_148;
        }
        if ( v16 != -2019352424 )
        {
          if ( v16 != -2019352420 )
          {
            switch ( v16 )
            {
              case 0x87A320A0:
                if ( !*(_DWORD *)(v3 + 8) )
                {
                  v17 = sub_1400174DC(*(_WORD **)(_R15 + 24), *(unsigned int *)(v3 + 16));
                  goto LABEL_220;
                }
                goto LABEL_239;
              case 0x87A320A4:
                if ( !*(_DWORD *)(v3 + 8) )
                {
                  v17 = sub_140013C98(*(wchar_t **)(_R15 + 24), *(unsigned int *)(v3 + 16));
                  goto LABEL_220;
                }
                goto LABEL_239;
              case 0x87A320C4:
                if ( *(_DWORD *)(v3 + 16) != 4 || *(_DWORD *)(v3 + 8) )
                  goto LABEL_239;
                sub_140004528(**(_DWORD **)(_R15 + 24) != 0);
                goto LABEL_76;
            }
            if ( v16 != -2019352376 )
              goto LABEL_308;
            if ( *(_DWORD *)(v3 + 16) || *(_DWORD *)(v3 + 8) )
              goto LABEL_239;
            sub_14000461C();
            goto LABEL_75;
          }
          if ( *(_DWORD *)(v3 + 16) != 24 )
            goto LABEL_239;
          v18 = 2i64;
          if ( *(_DWORD *)(v3 + 8) != 2 )
            goto LABEL_239;
          if ( !sub_140020218(
                  *(__m128i **)(_R15 + 24),
                  *(_QWORD *)(*(_QWORD *)(_R15 + 24) + 16i64),
                  dword_140038318,
                  *(bool **)(_R15 + 24),
                  (bool *)(*(_QWORD *)(_R15 + 24) + 1i64)) )
          {
            v6 = -1073741772;
            goto LABEL_337;
          }
LABEL_174:
          *(_QWORD *)(_R15 + 56) = v18;
          goto LABEL_76;
        }
        if ( *(_DWORD *)(v3 + 16) != 4 || *(_DWORD *)(v3 + 8) != 4 )
          goto LABEL_239;
        v57 = **(_DWORD **)(_R15 + 24);
        ExAcquireFastMutex(&unk_1400382C8);
        for ( i = (__int64 *)qword_140038300; i != &qword_140038300; i = (__int64 *)*i )
        {
          v59 = (signed __int64)(i - 13);
          if ( *((_DWORD *)i - 16) == v57 )
            goto LABEL_232;
        }
        v59 = 0i64;
LABEL_232:
        if ( v59 )
        {
          **(_DWORD **)(_R15 + 24) = *(_DWORD *)(v59 + 96);
          *(_QWORD *)(_R15 + 56) = 4i64;
          v6 = 0;
LABEL_323:
          ExReleaseFastMutex(&unk_1400382C8);
          goto LABEL_337;
        }
LABEL_320:
        v6 = -1073741811;
        goto LABEL_323;
      }
      switch ( v16 )
      {
        case 0x87A320D3:
          v70 = *(_DWORD **)(v3 + 32);
          v71 = *(_DWORD *)(v3 + 16);
          LODWORD(v97) = v71;
          if ( v71 < 0x18 || *(_DWORD *)(v3 + 8) )
            goto LABEL_239;
          ProbeForRead(v70, v71, 4u);
          LODWORD(v96) = *v70;
          v100 = (signed int)v96;
          v72 = v70[1];
          v99 = v70[1];
          ExAcquireFastMutex(&unk_1400382C8);
          v73 = (__int64 *)qword_140038300;
          if ( (__int64 *)qword_140038300 == &qword_140038300 )
          {
LABEL_262:
            v74 = 0i64;
          }
          else
          {
            while ( 1 )
            {
              v74 = (signed __int64)(v73 - 13);
              if ( *((_DWORD *)v73 - 16) == (_DWORD)v96 )
                break;
              v73 = (__int64 *)*v73;
              if ( v73 == &qword_140038300 )
                goto LABEL_262;
            }
          }
          v96 = (_WORD *)v74;
          if ( v74 )
          {
            sub_140003D6C(*(_QWORD *)(v74 + 88), (__int64)v70, (unsigned int)v97);
            *(_DWORD *)(v74 + 28) = v72;
            KeSetEvent((PRKEVENT)v74, 1, 0);
          }
          ExReleaseFastMutex(&unk_1400382C8);
          goto LABEL_75;
        case 0x87A32400:
LABEL_44:
          if ( *(_DWORD *)(v3 + 16) )
            goto LABEL_239;
          v18 = 4i64;
          if ( *(_DWORD *)(v3 + 8) != 4 )
            goto LABEL_239;
          **(_DWORD **)(_R15 + 24) = 794;
          goto LABEL_174;
        case 0x87A32404:
          if ( *(_DWORD *)(v3 + 16) || *(_DWORD *)(v3 + 8) )
            goto LABEL_239;
          v68 = IoGetCurrentProcess();
          v69 = 0i64;
          break;
        case 0x87A32408:
          if ( *(_DWORD *)(v3 + 16) || *(_DWORD *)(v3 + 8) )
            goto LABEL_239;
          v67 = __readgsqword(0x188u);
          v68 = IoGetCurrentProcess();
          v69 = v67;
          break;
        case 0x87A3240C:
          if ( *(_DWORD *)(v3 + 16) || *(_DWORD *)(v3 + 8) )
            goto LABEL_239;
          v65 = IoGetCurrentProcess();
          v66 = 0i64;
          goto LABEL_249;
        default:
          goto LABEL_308;
      }
      v6 = sub_1400066CC((__int64)v68, v69, *(_QWORD *)(v3 + 48)) == 0 ? 0xC000009A : 0;
      goto LABEL_337;
    }
    if ( *(_DWORD *)(v3 + 16) || *(_DWORD *)(v3 + 8) )
      goto LABEL_239;
    v75 = __readgsqword(0x188u);
    v65 = IoGetCurrentProcess();
    v66 = v75;
LABEL_249:
    sub_140006784((__int64)v65, v66, *(_QWORD *)(v3 + 48));
    goto LABEL_76;
  }
  if ( v16 == -2019352428 )
  {
    v56 = *(_DWORD *)(v3 + 16);
    if ( v56 && !*(_DWORD *)(v3 + 8) && !(v56 & 1) )
    {
      v105 = *(_DWORD *)(v3 + 16);
      v104 = v56;
      v106 = *(_QWORD *)(_R15 + 24);
      v17 = sub_140020094((__int64)&v104);
      goto LABEL_220;
    }
    goto LABEL_239;
  }
  if ( v16 > 0x87A32040 )
  {
    if ( v16 <= 0x87A32060 )
    {
      switch ( v16 )
      {
        case 0x87A32060:
          v47 = 0;
          if ( *(_DWORD *)(v3 + 16) != 16 || *(_DWORD *)(v3 + 8) != 4 )
            goto LABEL_239;
          v48 = *(_QWORD **)(_R15 + 24);
          v49 = 0;
          v50 = &off_14002B2C0;
          while ( *v48 != *(_QWORD *)*v50 || v48[1] != *((_QWORD *)*v50 + 1) )
          {
            ++v49;
            ++v50;
            if ( v49 >= 8 )
              goto LABEL_163;
          }
          v47 = 1;
LABEL_163:
          *(_QWORD *)(_R15 + 56) = 4i64;
          *(_DWORD *)v48 = v47;
          goto LABEL_76;
        case 0x87A32047:
          if ( *(_DWORD *)(v3 + 16) )
            goto LABEL_239;
          ExAcquireFastMutex(&unk_1400382C8);
          v44 = *(_QWORD *)(*(_QWORD *)(v3 + 48) + 24i64);
          if ( v44 )
          {
            if ( *(_DWORD *)(v44 + 80) )
            {
              v39 = *(_WORD **)(v44 + 56);
              if ( v39 )
              {
                v97 = v39;
                sub_14001B77C((__int64)v39);
                ExReleaseFastMutex(&unk_1400382C8);
                sub_14001B244(v39, &v96, &v107, 1);
                v45 = sub_14001B3B0((__int16)v96, &v107.Length);
                if ( *(_DWORD *)(v3 + 8) == v45 )
                {
                  v46 = v45;
                  ProbeForWrite(*(PVOID *)(_R15 + 112), v45, 1u);
                  sub_14001A2AC(*(_WORD **)(_R15 + 112), (__int16)v96, &v107.Length);
                  *(_QWORD *)(_R15 + 56) = v46;
                  v6 = 0;
                  v95 = 0;
                }
                else
                {
                  *(_QWORD *)(_R15 + 56) = 0i64;
                  v6 = -1073741811;
                }
LABEL_154:
                sub_14001A4D8(v39);
                goto LABEL_337;
              }
            }
          }
LABEL_148:
          ExReleaseFastMutex(&unk_1400382C8);
          goto LABEL_105;
        case 0x87A3204C:
          if ( *(_DWORD *)(v3 + 16) || *(_DWORD *)(v3 + 8) )
            goto LABEL_239;
          ExAcquireFastMutex(&unk_1400382C8);
          v41 = *(_QWORD *)(*(_QWORD *)(v3 + 48) + 24i64);
          if ( v41 )
          {
            v42 = *(void **)(v41 + 48);
            if ( v42 )
            {
              ObfReferenceObject(v42);
              ExReleaseFastMutex(&unk_1400382C8);
              v43 = sub_1400071D0((__int64)v42);
              ObfDereferenceObject(v42);
              v32 = -(v43 != 0);
              v33 = -1073741823;
LABEL_117:
              v6 = v32 & v33;
              goto LABEL_337;
            }
          }
          goto LABEL_148;
      }
      if ( v16 != -2019352492 )
      {
        if ( v16 == -2019352485 )
          goto LABEL_75;
        if ( v16 == -2019352484 )
        {
          v17 = sub_140006568(v3, _R15);
          goto LABEL_220;
        }
        if ( v16 != -2019352481 )
          goto LABEL_308;
        ExAcquireFastMutex(&unk_1400382C8);
        v34 = *(_QWORD *)(*(_QWORD *)(v3 + 48) + 24i64);
        if ( v34 )
        {
          v35 = *(_WORD **)(v34 + 56);
          v97 = v35;
          if ( v35 )
          {
            v96 = v35;
            sub_14001B77C((__int64)v35);
            ExReleaseFastMutex(&unk_1400382C8);
            v36 = *v35;
            v37 = v36 + 4;
            v38 = *(_DWORD *)(v3 + 8);
            if ( v38 >= (unsigned __int16)(v36 + 4) )
            {
              ProbeForWrite(*(PVOID *)(_R15 + 112), v37, 1u);
              v40 = *(_QWORD *)(_R15 + 112);
              *(_WORD *)v40 = v36 + 2;
              v39 = v97;
              sub_140021A80((__m128i *)(v40 + 2), *((_QWORD *)v97 + 1), v36);
              *(_WORD *)(v36 + v40 + 2) = 0;
              *(_QWORD *)(_R15 + 56) = v37;
              v6 = 0;
              v95 = 0;
            }
            else
            {
              if ( v38 >= 2 )
              {
                ProbeForWrite(*(PVOID *)(_R15 + 112), 2ui64, 1u);
                **(_WORD **)(_R15 + 112) = v37;
                *(_QWORD *)(_R15 + 56) = 2i64;
                v6 = 0;
                v95 = 0;
              }
              else
              {
                *(_QWORD *)(_R15 + 56) = 0i64;
                v6 = -1073741811;
              }
              v39 = v97;
            }
            goto LABEL_154;
          }
        }
        goto LABEL_148;
      }
LABEL_283:
      if ( !*(_DWORD *)(v3 + 16) && !*(_DWORD *)(v3 + 8) )
      {
        v6 = 0;
        LODWORD(Timeout) = 0;
        sub_140006BB4(0x131ui64, 0xBF3ui64, 0i64, 0xE03D0001, (ULONG_PTR)Timeout, (unsigned __int64)&byte_140028CD0);
        goto LABEL_337;
      }
      goto LABEL_239;
    }
    switch ( v16 )
    {
      case 0x87A32064:
        v54 = *(unsigned int *)(v3 + 16);
        v55 = *(_QWORD **)(_R15 + 24);
        if ( (_DWORD)v54
          && !(v54 & 1)
          && (unsigned __int16)v54 == (_DWORD)v54
          && !*((_WORD *)v55 + (v54 >> 1) - 1)
          && *(_DWORD *)(v3 + 8) == 32 )
        {
          v102 = *(_DWORD *)(v3 + 16);
          v101 = v54 - 2;
          v103 = v55;
          v6 = sub_14000A5EC(*(_QWORD *)(v3 + 48), (UNICODE_STRING *)&v101, v55);
          if ( v6 >= 0 )
            *(_QWORD *)(_R15 + 56) = 32i64;
          goto LABEL_337;
        }
        goto LABEL_239;
      case 0x87A32068:
        if ( !*(_DWORD *)(v3 + 16) && !*(_DWORD *)(v3 + 8) )
        {
          v6 = sub_14000A480(*(_QWORD *)(v3 + 48)) == 0 ? 0xC0000001 : 0;
          goto LABEL_337;
        }
        goto LABEL_239;
      case 0x87A32084:
        if ( *(_DWORD *)(v3 + 16) == 4 && !*(_DWORD *)(v3 + 8) )
        {
          sub_140005424(**(_DWORD **)(_R15 + 24) != 0);
          goto LABEL_75;
        }
        v6 = -1073741811;
        if ( (dword_140035180 & 0x80u) == 0 )
          goto LABEL_337;
        v53 = L"DIOCFilter: Invalid buffer size in ID_IOCTL_SetDCFilterState";
        break;
      case 0x87A3208B:
        if ( *(_DWORD *)(v3 + 16) || *(_DWORD *)(v3 + 8) )
          goto LABEL_239;
        sub_14000572C();
        goto LABEL_75;
      case 0x87A3208C:
        if ( !*(_DWORD *)(v3 + 16) )
        {
          v18 = 4i64;
          if ( *(_DWORD *)(v3 + 8) == 4 )
          {
            v51 = sub_140005550();
LABEL_172:
            v52 = v51;
LABEL_173:
            **(_DWORD **)(_R15 + 24) = v52;
            goto LABEL_174;
          }
        }
        v6 = -1073741811;
        if ( (dword_140035180 & 0x80u) == 0 )
          goto LABEL_337;
        v53 = L"DIOCFilter: Invalid buffer size in ID_IOCTL_GetDCFilterState";
        break;
      default:
        goto LABEL_308;
    }
    sub_140007A38((__int64)v53);
    goto LABEL_337;
  }
  if ( v16 == -2019352512 )
  {
    if ( *(_DWORD *)(v3 + 16) || *(_DWORD *)(v3 + 8) )
      goto LABEL_239;
    KeWaitForSingleObject(&stru_140039660, UserRequest, 0, 0, 0i64);
    sub_140019FF8();
    KeReleaseMutex(&stru_140039660, 0);
    goto LABEL_76;
  }
  if ( v16 <= 0x87A3201B )
  {
    if ( v16 != -2019352549 )
    {
      switch ( v16 )
      {
        case 0x87A32000:
          if ( !*(_DWORD *)(v3 + 16) && !*(_DWORD *)(v3 + 8) )
          {
            sub_140005F18();
            sub_140007AF8();
            sub_140016628();
            sub_1400028C0();
            KeWaitForSingleObject(&stru_140039660, UserRequest, 0, 0, 0i64);
            if ( qword_1400382A8 || qword_140038338 && qword_140038338 != *(_QWORD *)(v3 + 48) || !sub_140019F9C() )
            {
              v6 = -1073741823;
            }
            else
            {
              qword_1400382A8 = (__int64)IoGetCurrentProcess();
              qword_140038338 = *(_QWORD *)(v3 + 48);
              v6 = 0;
            }
            KeReleaseMutex(&stru_140039660, 0);
            goto LABEL_337;
          }
          goto LABEL_239;
        case 0x87A32004:
          if ( *(_DWORD *)(v3 + 16) || *(_DWORD *)(v3 + 8) )
            goto LABEL_239;
          qword_1400382A8 = 0i64;
          sub_14001A05C();
          byte_140038312 = 0;
          break;
        case 0x87A32008:
          if ( dword_140039698 == 4 )
          {
            v6 = -1073741637;
            goto LABEL_337;
          }
          v19 = *(_DWORD *)(v3 + 16);
          if ( v19 != 24 || *(_DWORD *)(v3 + 8) )
          {
            if ( v19 != 20 || *(_DWORD *)(v3 + 8) )
            {
              if ( v19 != 16 || *(_DWORD *)(v3 + 8) )
              {
                if ( v19 != 12 || *(_DWORD *)(v3 + 8) )
                  goto LABEL_239;
                byte_140038312 = 0;
              }
              else
              {
                byte_140038312 = *(_BYTE *)(*(_QWORD *)(_R15 + 24) + 12i64);
              }
              byte_1400382A0 = 0;
            }
            else
            {
              v21 = *(_QWORD *)(_R15 + 24);
              byte_140038312 = *(_BYTE *)(v21 + 12);
              byte_1400382A0 = *(_BYTE *)(v21 + 16);
            }
            byte_1400382A1 = 0;
          }
          else
          {
            v20 = *(_BYTE **)(_R15 + 24);
            byte_140038312 = v20[12];
            byte_1400382A0 = v20[16];
            byte_1400382A1 = v20[20];
          }
          break;
        case 0x87A3200C:
          goto LABEL_44;
        case 0x87A32010:
          if ( *(_DWORD *)(v3 + 16) )
            goto LABEL_239;
          v18 = 4i64;
          if ( *(_DWORD *)(v3 + 8) != 4 )
            goto LABEL_239;
          KeWaitForSingleObject(&stru_140039660, UserRequest, 0, 0, 0i64);
          **(_DWORD **)(_R15 + 24) = (dword_140039698 == 4) + 1;
          KeReleaseMutex(&stru_140039660, 0);
          goto LABEL_174;
        case 0x87A32014:
          if ( *(_DWORD *)(v3 + 16) == 4 && !*(_DWORD *)(v3 + 8) )
          {
            v17 = sub_140019E80(**(_DWORD **)(_R15 + 24));
LABEL_220:
            v6 = v17;
            goto LABEL_337;
          }
LABEL_239:
          v6 = -1073741811;
          goto LABEL_337;
        default:
LABEL_308:
          v6 = -1073741822;
          goto LABEL_337;
      }
LABEL_76:
      v6 = 0;
      goto LABEL_337;
    }
LABEL_75:
    *(_QWORD *)(_R15 + 56) = 0i64;
    goto LABEL_76;
  }
  switch ( v16 )
  {
    case 0x87A3201C:
      if ( *(_DWORD *)(v3 + 16) != 4 || *(_DWORD *)(v3 + 8) )
        goto LABEL_239;
      sub_1400174E8(**(_DWORD **)(_R15 + 24));
      goto LABEL_76;
    case 0x87A32024:
      if ( *(_DWORD *)(v3 + 16) || *(_DWORD *)(v3 + 8) )
        v5 = 0;
      else
        _InterlockedAdd(&dword_140038318, 1u);
      v32 = -(v5 == 0);
      v33 = -1073741811;
      goto LABEL_117;
    case 0x87A3202C:
      if ( *(_DWORD *)(v3 + 16) || *(_DWORD *)(v3 + 8) )
        goto LABEL_239;
      KeSetEvent(&stru_140038320, 0, 0);
      goto LABEL_76;
    case 0x87A32034:
      if ( byte_14002B2B0 )
      {
        if ( *(_DWORD *)(v3 + 16) != 4 || *(_DWORD *)(v3 + 8) )
          goto LABEL_239;
        _InterlockedAdd(&dword_140038318, 1u);
        goto LABEL_76;
      }
LABEL_105:
      v6 = -1073741823;
      goto LABEL_337;
  }
  if ( v16 != -2019352520 )
  {
    if ( v16 != -2019352516 )
      goto LABEL_308;
    if ( *(_DWORD *)(v3 + 16) != 16 || *(_DWORD *)(v3 + 8) )
      goto LABEL_239;
    v22 = *(LONG **)(_R15 + 24);
    ExAcquireFastMutex(&unk_1400382C8);
    v23 = *(_QWORD *)(v3 + 48);
    v24 = *(struct _KEVENT **)(v23 + 24);
    if ( v24 )
    {
      *(_QWORD *)(v23 + 24) = 0i64;
      v24[1].Header.SignalState = *v22;
      KeSetEvent(v24, 1, 0);
    }
    ExReleaseFastMutex(&unk_1400382C8);
    goto LABEL_76;
  }
  v25 = 1048;
  if ( byte_1400382A0 )
    v25 = byte_1400382A1 != 0 ? 1128 : 1076;
  if ( *(_DWORD *)(v3 + 16) != v25 || *(_DWORD *)(v3 + 8) != v25 )
    goto LABEL_239;
  if ( byte_140038310 )
  {
    **(_DWORD **)(_R15 + 24) = 3;
    *(_DWORD *)(_R15 + 48) = 0;
    *(_QWORD *)(_R15 + 56) = 1048i64;
LABEL_335:
    IofCompleteRequest((PIRP)_R15, 1);
    return v4;
  }
  v26 = *(_QWORD *)(v3 + 48);
  if ( *(_QWORD *)(v26 + 24) )
  {
    ExAcquireFastMutex(&unk_1400382C8);
    v27 = *(struct _KEVENT **)(v26 + 24);
    if ( v27 && v27[1].Header.Lock != 8 )
    {
      *(_QWORD *)(v26 + 24) = 0i64;
      KeSetEvent(v27, 1, 0);
    }
    ExReleaseFastMutex(&unk_1400382C8);
  }
  IoAcquireCancelSpinLock(&Irql);
  _RAX = sub_1400178D0;
  __asm { xchg    rax, [r15+68h] }
  *(_BYTE *)(*(_QWORD *)(_R15 + 184) + 3i64) |= 1u;
  ExInterlockedInsertTailList(&stru_1400382B0, (PLIST_ENTRY)(_R15 + 168), &Lock);
  IoReleaseCancelSpinLock(Irql);
  if ( byte_140038310 )
  {
    while ( 1 )
    {
      v30 = sub_140018FC4();
      if ( !v30 )
        break;
      v30[1].Blink->Flink = (_LIST_ENTRY *)3;
      LODWORD(v30[3].Flink) = 0;
      v30[3].Blink = (_LIST_ENTRY *)1048;
      IofCompleteRequest((PIRP)v30, 1);
    }
  }
  return 259i64;
}
// 140011160: using guessed type __int64 __fastcall sub_140011160(_QWORD);
// 14001A4D8: using guessed type __int64 __fastcall sub_14001A4D8(_QWORD);
// 1400261F0: using guessed type wchar_t aDiocfilterInva[61];
// 140026270: using guessed type wchar_t aDiocfilterInva_0[61];
// 14002B2B0: using guessed type char byte_14002B2B0;
// 14002B2C0: using guessed type void *off_14002B2C0;
// 140035180: using guessed type int dword_140035180;
// 1400382A0: using guessed type char byte_1400382A0;
// 1400382A1: using guessed type char byte_1400382A1;
// 1400382A8: using guessed type __int64 qword_1400382A8;
// 140038300: using guessed type __int64 qword_140038300;
// 140038310: using guessed type char byte_140038310;
// 140038312: using guessed type char byte_140038312;
// 140038318: using guessed type int dword_140038318;
// 140038338: using guessed type __int64 qword_140038338;
// 140039698: using guessed type int dword_140039698;

//----- (0000000140018FC4) ----------------------------------------------------
PLIST_ENTRY sub_140018FC4()
{
  PLIST_ENTRY result; // rax
  KIRQL Irql; // [rsp+30h] [rbp+8h]

  result = ExInterlockedRemoveHeadList(&stru_1400382B0, &Lock);
  _RDI = 0i64;
  while ( result )
  {
    _RBX = (struct _IRP *)&result[-11].Blink;
    IoAcquireCancelSpinLock(&Irql);
    if ( !_RBX->Cancel )
    {
      __asm { xchg    rdi, [rbx+68h] }
      IoReleaseCancelSpinLock(Irql);
      return (PLIST_ENTRY)_RBX;
    }
    IoReleaseCancelSpinLock(Irql);
    _RBX->IoStatus.Status = -1073741536;
    _RBX->IoStatus.Information = 0i64;
    IofCompleteRequest(_RBX, 1);
    result = ExInterlockedRemoveHeadList(&stru_1400382B0, &Lock);
  }
  return result;
}

//----- (000000014001907C) ----------------------------------------------------
__int64 __fastcall sub_14001907C(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  unsigned int v3; // ebx

  v1 = a1;
  ExAcquireFastMutex(&unk_1400382C8);
  v2 = *(_QWORD *)(v1 + 24);
  if ( v2 )
  {
    v3 = *(_DWORD *)(v2 + 76);
    *(_DWORD *)(v2 + 76) = 0;
  }
  else
  {
    v3 = -1073741642;
  }
  ExReleaseFastMutex(&unk_1400382C8);
  return v3;
}

//----- (00000001400190CC) ----------------------------------------------------
__int64 __fastcall sub_1400190CC(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rdi
  __int64 v3; // rax

  v1 = a1;
  v2 = 0i64;
  ExAcquireFastMutex(&unk_1400382C8);
  v3 = *(_QWORD *)(v1 + 24);
  if ( v3 )
  {
    v2 = *(_QWORD *)(v3 + 32);
    if ( v2 )
      ObfReferenceObject(*(PVOID *)(v3 + 32));
  }
  ExReleaseFastMutex(&unk_1400382C8);
  return v2;
}

//----- (0000000140019130) ----------------------------------------------------
signed __int64 __fastcall sub_140019130(PLIST_ENTRY *a1)
{
  PLIST_ENTRY *v1; // rdi
  signed __int64 result; // rax
  int v3; // eax
  unsigned int v4; // ebx
  PLIST_ENTRY v5; // rax
  unsigned int v6; // ecx
  LARGE_INTEGER Interval; // [rsp+30h] [rbp+8h]

  v1 = a1;
  if ( !a1 )
    return 3221225473i64;
  v3 = dword_14003831C;
  if ( dword_140038314 )
    v3 = 0;
  Interval.QuadPart = -200000i64;
  v4 = 1000 * v3 / 0x14u;
  v5 = sub_140018FC4();
  if ( v5 )
  {
LABEL_12:
    *v1 = v5;
    result = 0i64;
    dword_140038314 = 0;
  }
  else
  {
    do
    {
      v6 = v4--;
      if ( !v6 )
        break;
      if ( KeReadStateEvent(&stru_140038320) )
        return 3221226048i64;
      KeDelayExecutionThread(0, 0, &Interval);
      v5 = sub_140018FC4();
    }
    while ( !v5 );
    if ( v5 )
      goto LABEL_12;
    dword_140038314 = 1;
    result = 3221225626i64;
  }
  return result;
}
// 140038314: using guessed type int dword_140038314;
// 14003831C: using guessed type int dword_14003831C;

//----- (0000000140019200) ----------------------------------------------------
__int64 sub_140019200()
{
  return (unsigned int)dword_140038318;
}
// 140038318: using guessed type int dword_140038318;

//----- (0000000140019208) ----------------------------------------------------
char sub_140019208()
{
  UNICODE_STRING *v0; // rax
  char v1; // al
  int v2; // ecx
  int v4; // [rsp+30h] [rbp+8h]

  dword_14003831C = 60;
  v0 = sub_14000589C();
  v1 = sub_1400095B8(v0, L"IRPQueueTimeout", &v4);
  v2 = dword_14003831C;
  unk_1400382C8.Count = 1;
  if ( v1 )
    v2 = v4;
  Lock = 0i64;
  unk_1400382D0 = 0i64;
  unk_1400382D8 = 0;
  dword_14003831C = v2;
  stru_1400382B0.Blink = &stru_1400382B0;
  stru_1400382B0.Flink = &stru_1400382B0;
  KeInitializeEvent(&stru_1400382E0, SynchronizationEvent, 0);
  dword_140039698 = 2;
  qword_140038308 = (__int64)&qword_140038300;
  qword_140038300 = (__int64)&qword_140038300;
  byte_140038310 = 0;
  KeInitializeEvent(&stru_140038320, 0, 1u);
  KeInitializeMutex(&stru_140039660, 0);
  return 1;
}
// 1400261D0: using guessed type wchar_t aIrpqueuetimeou[16];
// 140038300: using guessed type __int64 qword_140038300;
// 140038308: using guessed type __int64 qword_140038308;
// 140038310: using guessed type char byte_140038310;
// 14003831C: using guessed type int dword_14003831C;
// 140039698: using guessed type int dword_140039698;

//----- (00000001400192EC) ----------------------------------------------------
bool sub_1400192EC()
{
  bool result; // al

  if ( qword_1400382A8 )
    result = IoGetCurrentProcess() == (PEPROCESS)qword_1400382A8;
  else
    result = 0;
  return result;
}
// 1400382A8: using guessed type __int64 qword_1400382A8;

//----- (000000014001931C) ----------------------------------------------------
LONG sub_14001931C()
{
  __int64 *i; // rbx
  PLARGE_INTEGER Timeout; // [rsp+20h] [rbp-18h]

  KeWaitForSingleObject(&stru_140039660, UserRequest, 0, 0, 0i64);
  if ( byte_140038311 )
  {
    sub_140019FF8();
    LODWORD(Timeout) = -1073741823;
    sub_140006BB4(0x131ui64, 0x2B3ui64, 0i64, 0xE03D0025, (ULONG_PTR)Timeout, 0);
  }
  byte_140038310 = 0;
  if ( (unsigned int)dword_140039698 > 2 )
  {
    if ( sub_14000AD9C() )
      sub_14000ADBC(0);
    sub_140005424(0);
    sub_140004528(0);
    dword_140039698 = 2;
    sub_140006E04(0i64);
  }
  qword_1400382A8 = 0i64;
  qword_140038338 = 0i64;
  dword_140038314 = 0;
  byte_14002B2B0 = 1;
  byte_140038312 = 0;
  ExAcquireFastMutex(&unk_1400382C8);
  for ( i = (__int64 *)qword_140038300; i != &qword_140038300; i = (__int64 *)*i )
    KeSetEvent((PRKEVENT)(i - 13), 1, 0);
  ExReleaseFastMutex(&unk_1400382C8);
  sub_14000A930();
  sub_1400083D4();
  return KeReleaseMutex(&stru_140039660, 0);
}
// 14002B2B0: using guessed type char byte_14002B2B0;
// 1400382A8: using guessed type __int64 qword_1400382A8;
// 140038300: using guessed type __int64 qword_140038300;
// 140038310: using guessed type char byte_140038310;
// 140038311: using guessed type char byte_140038311;
// 140038312: using guessed type char byte_140038312;
// 140038314: using guessed type int dword_140038314;
// 140038338: using guessed type __int64 qword_140038338;
// 140039698: using guessed type int dword_140039698;

//----- (0000000140019458) ----------------------------------------------------
void __fastcall sub_140019458(__int64 a1, char a2)
{
  __int64 v2; // rbx
  struct _KEVENT *v3; // rcx

  v2 = a1;
  if ( qword_140038338 && a1 == qword_140038338 )
  {
    if ( !a2 )
      sub_14001931C();
  }
  else if ( a2 && *(_QWORD *)(a1 + 24) )
  {
    ExAcquireFastMutex(&unk_1400382C8);
    v3 = *(struct _KEVENT **)(v2 + 24);
    if ( v3 && v3[1].Header.Lock != 8 )
    {
      *(_QWORD *)(v2 + 24) = 0i64;
      KeSetEvent(v3, 1, 0);
    }
    ExReleaseFastMutex(&unk_1400382C8);
  }
}
// 140038338: using guessed type __int64 qword_140038338;

//----- (00000001400194E0) ----------------------------------------------------
signed __int64 __fastcall sub_1400194E0(__int64 a1, __int16 a2, __int64 a3, _DWORD *a4)
{
  __int16 v4; // r14
  __int64 v5; // rsi
  _DWORD *v6; // rdi
  signed __int64 result; // rax
  __int64 v8; // rcx
  struct _IRP *v9; // rbx
  signed __int32 v10; // eax
  char v11; // [rsp+18h] [rbp-39h]
  __int64 v12; // [rsp+28h] [rbp-29h]
  int v13; // [rsp+30h] [rbp-21h]
  int v14; // [rsp+34h] [rbp-1Dh]
  __int64 v15; // [rsp+48h] [rbp-9h]
  int v16; // [rsp+78h] [rbp+27h]
  char v17; // [rsp+B8h] [rbp+67h]
  PIRP Irp; // [rsp+D0h] [rbp+7Fh]

  Irp = 0i64;
  v4 = a2;
  v5 = a3;
  v6 = a4;
  sub_140021DC0((__m128 *)&v13, 0, 0x78ui64);
  *v6 = 2;
  if ( (unsigned int)dword_140039698 < 4 || !byte_140038311 || KeReadStateEvent(&stru_140038320) )
    return 3221226048i64;
  result = sub_140019130((PLIST_ENTRY *)&Irp);
  if ( !(_DWORD)result )
  {
    v9 = Irp->AssociatedIrp.MasterIrp;
    *(_DWORD *)&v9->Type = 2;
    v10 = _InterlockedExchangeAdd(&dword_140038340, 1u);
    *((_WORD *)&v9->Flags + 3) = v4;
    HIDWORD(v9->MdlAddress) = v10 + 1;
    v13 = 2;
    v15 = v5;
    v12 = 0i64;
    v16 = PsGetCurrentProcessId(v8);
    LODWORD(result) = sub_140017650(Irp, HIDWORD(v9->MdlAddress), &v17, (__int64)&v11, 1, 0i64);
    switch ( (_DWORD)result )
    {
      case 0xC000004B:
      case 0xC0000120:
        *v6 = 13;
        break;
      case 0xC0000240:
        *v6 = 3;
        break;
      case 0:
        *v6 = v14;
        break;
    }
    result = (unsigned int)result;
  }
  return result;
}
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 140038311: using guessed type char byte_140038311;
// 140038340: using guessed type int dword_140038340;
// 140039698: using guessed type int dword_140039698;

//----- (0000000140019618) ----------------------------------------------------
signed __int64 __fastcall sub_140019618(int a1, int a2, _WORD *a3, __int64 a4, __m128i *a5)
{
  _WORD *v5; // r14
  int v6; // er15
  __int64 v7; // r12
  signed __int64 result; // rax
  struct _IRP *v9; // rdi
  struct _IRP *v10; // rbx
  __int64 v11; // rcx
  unsigned int v12; // ebx
  char v13; // [rsp+18h] [rbp-79h]
  int v14[2]; // [rsp+28h] [rbp-69h]
  PIRP Irp; // [rsp+30h] [rbp-61h]
  __int64 v16; // [rsp+38h] [rbp-59h]
  __int64 v17; // [rsp+40h] [rbp-51h]
  __int64 v18; // [rsp+48h] [rbp-49h]
  _WORD *v19; // [rsp+50h] [rbp-41h]
  int v20; // [rsp+68h] [rbp-29h]
  int v21; // [rsp+78h] [rbp-19h]
  char v22; // [rsp+D0h] [rbp+3Fh]
  __int64 retaddr; // [rsp+E8h] [rbp+57h]
  _DWORD *v24; // [rsp+F0h] [rbp+5Fh]
  __int64 v25; // [rsp+F8h] [rbp+67h]
  char v26; // [rsp+100h] [rbp+6Fh]
  __int64 v27; // [rsp+108h] [rbp+77h]

  LODWORD(v25) = a2;
  Irp = 0i64;
  v5 = a3;
  v6 = a1;
  v7 = a4;
  sub_140021DC0((__m128 *)&v17, 0, 0x78ui64);
  *v24 = 2;
  if ( (unsigned int)dword_140039698 < 4 || !byte_140038311 || KeReadStateEvent(&stru_140038320) )
    return 3221226048i64;
  result = sub_140019130((PLIST_ENTRY *)&Irp);
  if ( !(_DWORD)result )
  {
    v9 = Irp;
    *(_QWORD *)v14 = a5;
    v10 = Irp->AssociatedIrp.MasterIrp;
    sub_140017524(v6, v7, v5, v26, &Irp->AssociatedIrp.MasterIrp->Type, a5);
    LODWORD(Irp) = v6;
    v19 = v5;
    v20 = (int)v10->MdlAddress;
    v16 = v25;
    v18 = retaddr;
    v21 = PsGetCurrentProcessId(v11);
    sub_14001B77C((__int64)v5);
    v12 = sub_140017650(v9, HIDWORD(v10->MdlAddress), &v22, (__int64)&v13, 1, v27);
    sub_14001A4D8(v5);
    switch ( v12 )
    {
      case 0xC000004B:
      case 0xC0000120:
        *v24 = 13;
        break;
      case 0xC0000240:
        *v24 = 3;
        break;
      case 0u:
        *v24 = HIDWORD(Irp);
        break;
    }
    result = v12;
  }
  return result;
}
// 14001A4D8: using guessed type __int64 __fastcall sub_14001A4D8(_QWORD);
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 140038311: using guessed type char byte_140038311;
// 140039698: using guessed type int dword_140039698;

//----- (0000000140019788) ----------------------------------------------------
signed __int64 __fastcall sub_140019788(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, __int64 a5)
{
  __int64 v5; // r14
  __int64 v6; // rbp
  __int64 v7; // rsi
  _DWORD *v8; // rdi
  signed __int64 result; // rax
  unsigned int v10; // eax
  struct _IRP *v11; // rbx
  char v12; // [rsp+30h] [rbp-98h]
  int v13; // [rsp+48h] [rbp-80h]
  int v14; // [rsp+4Ch] [rbp-7Ch]
  __int64 v15; // [rsp+50h] [rbp-78h]
  __int64 v16; // [rsp+60h] [rbp-68h]
  __int64 v17; // [rsp+88h] [rbp-40h]
  PIRP Irp; // [rsp+E8h] [rbp+20h]

  Irp = 0i64;
  v5 = a2;
  v6 = a3;
  v7 = a1;
  v8 = a4;
  sub_140021DC0((__m128 *)&v12, 0, 0x78ui64);
  *v8 = 2;
  if ( (unsigned int)dword_140039698 < 3 || !byte_140038311 || KeReadStateEvent(&stru_140038320) )
    return 3221226048i64;
  result = sub_140019130((PLIST_ENTRY *)&Irp);
  if ( !(_DWORD)result )
  {
    v10 = sub_140003D5C(v7);
    v11 = Irp->AssociatedIrp.MasterIrp;
    *(_DWORD *)&v11->Type = 8;
    *(_DWORD *)(&v11->Size + 1) = _InterlockedIncrement(&dword_140038340);
    if ( v10 <= 0x400 )
    {
      LODWORD(v11->MdlAddress) = 0;
      sub_140003F48(v7, (__int64)&v11->MdlAddress + 4);
    }
    else
    {
      LODWORD(v11->MdlAddress) = v10;
    }
    v13 = 8;
    v15 = v6;
    v16 = v5;
    v17 = v7;
    result = sub_140017650(Irp, *(_DWORD *)(&v11->Size + 1), 0i64, (__int64)&v12, 1, a5);
    if ( (_DWORD)result == -1073741749 || (_DWORD)result == -1073741536 )
    {
      *v8 = 13;
    }
    else if ( !(_DWORD)result )
    {
      *v8 = v14;
    }
  }
  return result;
}
// 140038311: using guessed type char byte_140038311;
// 140038340: using guessed type int dword_140038340;
// 140039698: using guessed type int dword_140039698;

//----- (00000001400198DC) ----------------------------------------------------
signed __int64 __fastcall sub_1400198DC(int a1, unsigned __int16 *a2, __int64 a3, _DWORD *a4)
{
  __int64 v4; // rbp
  unsigned __int16 *v5; // rdi
  _DWORD *v6; // rsi
  signed __int64 result; // rax
  struct _IRP *v8; // rbx
  struct _IRP *v9; // rcx
  char v10; // [rsp+30h] [rbp-98h]
  int v11; // [rsp+48h] [rbp-80h]
  int v12; // [rsp+4Ch] [rbp-7Ch]
  __int64 v13; // [rsp+60h] [rbp-68h]
  int v14; // [rsp+D0h] [rbp+8h]
  PIRP Irp; // [rsp+D8h] [rbp+10h]

  v14 = a1;
  v4 = a3;
  Irp = 0i64;
  v5 = a2;
  v6 = a4;
  sub_140021DC0((__m128 *)&v10, 0, 0x78ui64);
  if ( !v5 || (unsigned __int64)*v5 + 2 > 0x400 )
    return 3221225473i64;
  if ( (unsigned int)dword_140039698 < 3 || !byte_140038311 || KeReadStateEvent(&stru_140038320) )
    return 3221226048i64;
  result = sub_140019130((PLIST_ENTRY *)&Irp);
  if ( !(_DWORD)result )
  {
    v8 = Irp->AssociatedIrp.MasterIrp;
    *(_DWORD *)&v8->Type = 9;
    *(_DWORD *)(&v8->Size + 1) = _InterlockedIncrement(&dword_140038340);
    sub_140021A80((__m128i *)&v8->MdlAddress, *((_QWORD *)v5 + 1), *v5);
    v9 = Irp;
    *((_WORD *)&v8->MdlAddress + ((unsigned __int64)*v5 >> 1)) = 0;
    v11 = 9;
    v13 = v4;
    result = sub_140017650(v9, *(_DWORD *)(&v8->Size + 1), &v14, (__int64)&v10, 1, 0i64);
    if ( !(_DWORD)result )
      *v6 = v12;
  }
  return result;
}
// 140038311: using guessed type char byte_140038311;
// 140038340: using guessed type int dword_140038340;
// 140039698: using guessed type int dword_140039698;

//----- (0000000140019A20) ----------------------------------------------------
signed __int64 __fastcall sub_140019A20(int a1, int a2, unsigned __int16 *a3, __int64 a4)
{
  unsigned __int16 *v4; // rdi
  int v5; // ebp
  __int64 v6; // rsi
  signed __int64 result; // rax
  struct _IRP *v8; // rbx
  struct _IRP *v9; // rcx
  char v10; // [rsp+30h] [rbp-98h]
  int v11; // [rsp+48h] [rbp-80h]
  int v12; // [rsp+4Ch] [rbp-7Ch]
  __int64 v13; // [rsp+60h] [rbp-68h]
  int v14; // [rsp+D0h] [rbp+8h]
  PIRP Irp; // [rsp+E0h] [rbp+18h]

  v14 = a1;
  v4 = a3;
  Irp = 0i64;
  v5 = a2;
  v6 = a4;
  sub_140021DC0((__m128 *)&v10, 0, 0x78ui64);
  if ( !v4 || (unsigned __int64)*v4 + 2 > 0x400 )
    return 3221225473i64;
  if ( (unsigned int)dword_140039698 < 3 || !byte_140038311 || KeReadStateEvent(&stru_140038320) )
    return 3221226048i64;
  result = sub_140019130((PLIST_ENTRY *)&Irp);
  if ( !(_DWORD)result )
  {
    v8 = Irp->AssociatedIrp.MasterIrp;
    *(_DWORD *)&v8->Type = 10;
    *(_DWORD *)(&v8->Size + 1) = _InterlockedIncrement(&dword_140038340);
    sub_140021A80((__m128i *)((char *)&v8->MdlAddress + 4), *((_QWORD *)v4 + 1), *v4);
    v9 = Irp;
    *((_WORD *)&v8->MdlAddress + ((unsigned __int64)*v4 >> 1) + 2) = 0;
    LODWORD(v8->MdlAddress) = v5;
    v11 = 10;
    v13 = v6;
    result = sub_140017650(v9, *(_DWORD *)(&v8->Size + 1), &v14, (__int64)&v10, 1, 0i64);
    if ( !(_DWORD)result )
    {
      if ( v12 )
        result = 3221225473i64;
    }
  }
  return result;
}
// 140038311: using guessed type char byte_140038311;
// 140038340: using guessed type int dword_140038340;
// 140039698: using guessed type int dword_140039698;

//----- (0000000140019B6C) ----------------------------------------------------
__int64 __fastcall sub_140019B6C(unsigned int a1, unsigned __int64 a2, unsigned int a3)
{
  unsigned __int64 v3; // rsi
  unsigned int v4; // ebp
  unsigned int v5; // edi
  int v6; // eax
  PVOID v7; // r9
  unsigned int v8; // ebx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]
  PVOID Object; // [rsp+30h] [rbp-18h]

  Object = 0i64;
  v3 = a2;
  v4 = a1;
  v5 = a3;
  v6 = sub_140007050(0i64, &Object);
  if ( v6 >= 0 )
  {
    v7 = Object;
  }
  else
  {
    LODWORD(BugCheckParameter3) = v6;
    sub_140006BB4(0x131ui64, 0x1061ui64, 0i64, 0xE03D02F0, BugCheckParameter3, 0);
    v7 = 0i64;
    Object = 0i64;
  }
  v8 = sub_140019D34(v4, v3, v5, (__int64)v7);
  if ( Object )
    ObfDereferenceObject(Object);
  return v8;
}

//----- (0000000140019C14) ----------------------------------------------------
signed __int64 __fastcall sub_140019C14(int a1, unsigned __int16 a2, _QWORD *a3)
{
  _QWORD *v3; // rbp
  unsigned __int16 v4; // si
  int v5; // er14
  signed __int64 result; // rax
  PIRP v7; // rdi
  struct _IRP *v8; // rbx
  PIRP Irp; // [rsp+58h] [rbp+20h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  Irp = 0i64;
  if ( (unsigned int)dword_140039698 < 3 || !byte_140038311 || KeReadStateEvent(&stru_140038320) )
    return 3221226048i64;
  result = sub_140019130((PLIST_ENTRY *)&Irp);
  if ( !(_DWORD)result )
  {
    v7 = Irp;
    v8 = Irp->AssociatedIrp.MasterIrp;
    *(_DWORD *)&v8->Type = 4;
    *(_DWORD *)(&v8->Size + 1) = v5;
    if ( !v4
      || !v3
      || (LOWORD(v8->MdlAddress) = v4, !sub_1400092F4(v4, (__m128i *)((char *)&v8->MdlAddress + 2), 0x400u, v3)) )
    {
      LOWORD(v8->MdlAddress) = 0;
    }
    v7->IoStatus.Information = 1048i64;
    v7->IoStatus.Status = 0;
    IofCompleteRequest(v7, 1);
    result = 0i64;
  }
  return result;
}
// 140038311: using guessed type char byte_140038311;
// 140039698: using guessed type int dword_140039698;

//----- (0000000140019D00) ----------------------------------------------------
signed __int64 __fastcall sub_140019D00(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4, _QWORD *a5)
{
  _QWORD *v5; // r8
  __int64 v7; // [rsp+40h] [rbp+18h]

  v7 = a3;
  v5 = 0i64;
  if ( a4 )
    v5 = a5;
  return sub_140019C14(v7, a4, v5);
}

//----- (0000000140019D34) ----------------------------------------------------
signed __int64 __fastcall sub_140019D34(__int64 a1, unsigned __int64 a2, unsigned int a3, __int64 a4)
{
  unsigned __int64 v4; // r14
  unsigned __int64 v5; // rsi
  __int64 v6; // r15
  signed __int64 result; // rax
  __m128i *v8; // rbx
  bool v9; // cf
  struct _KEVENT *v10; // rax
  PIRP Irp; // [rsp+18h] [rbp-51h]
  int v12[2]; // [rsp+28h] [rbp-41h]
  int v13; // [rsp+40h] [rbp-29h]
  int v14; // [rsp+44h] [rbp-25h]
  __int64 v15; // [rsp+58h] [rbp-11h]
  unsigned __int64 v16; // [rsp+68h] [rbp-1h]
  int v17; // [rsp+70h] [rbp+7h]
  char v18; // [rsp+C8h] [rbp+5Fh]
  _DWORD *v19; // [rsp+E8h] [rbp+7Fh]

  v4 = a2;
  v5 = a3;
  v6 = a4;
  sub_140021DC0((__m128 *)&v13, 0, 0x78ui64);
  *v19 = 0;
  if ( (unsigned int)dword_140039698 < 3 || !byte_140038311 || KeReadStateEvent(&stru_140038320) )
    return 3221226048i64;
  result = sub_140019130((PLIST_ENTRY *)&Irp);
  if ( !(_DWORD)result )
  {
    v8 = (__m128i *)Irp->AssociatedIrp.MasterIrp;
    LODWORD(v8->m128i_i64[0]) = 6;
    HIDWORD(v8->m128i_i64[0]) = _InterlockedIncrement(&dword_140038340);
    if ( (unsigned int)v5 <= 0x400 )
    {
      HIDWORD(v8->m128i_i64[1]) = 0;
      sub_140021A80(v8 + 1, v4, v5);
    }
    else
    {
      HIDWORD(v8->m128i_i64[1]) = v5;
    }
    v13 = 6;
    v17 = HIDWORD(v8->m128i_i64[1]);
    v9 = HIDWORD(v8->m128i_i64[1]) != 0;
    v15 = v6;
    v16 = v4 & -(signed __int64)v9;
    v10 = sub_14000AD94();
    result = sub_140017650(Irp, HIDWORD(v8->m128i_i64[0]), &v18, (__int64)v12, 0, (__int64)v10);
    if ( (_DWORD)result )
    {
      if ( (_DWORD)result == -1073741536 )
        *v19 = 13;
    }
    else
    {
      *v19 = v14;
    }
  }
  return result;
}
// 140038311: using guessed type char byte_140038311;
// 140038340: using guessed type int dword_140038340;
// 140039698: using guessed type int dword_140039698;

//----- (0000000140019E80) ----------------------------------------------------
signed __int64 __fastcall sub_140019E80(int a1)
{
  int v1; // ebx

  v1 = a1;
  if ( (unsigned int)(a1 - 1) > 1 )
    return 3221225485i64;
  KeWaitForSingleObject(&stru_140039660, UserRequest, 0, 0, 0i64);
  if ( dword_140039698 == 2 )
  {
    sub_140006E04((__int64 (*)(void))sub_140019D00);
    dword_140039698 = 3;
    byte_140038311 = 1;
    if ( KeReadStateEvent(&stru_140038320) )
      KeClearEvent(&stru_140038320);
  }
  if ( v1 == 2 )
  {
    sub_140006E84();
    dword_140039698 = 4;
  }
  if ( v1 == 1 )
    dword_140039698 = 3;
  KeReleaseMutex(&stru_140039660, 0);
  return 0i64;
}
// 140038311: using guessed type char byte_140038311;
// 140039698: using guessed type int dword_140039698;

//----- (0000000140019F50) ----------------------------------------------------
void __fastcall sub_140019F50(__int64 a1, int a2)
{
  __int64 v2; // rbx
  int v3; // edi
  __int64 v4; // rax

  v2 = a1;
  v3 = a2;
  ExAcquireFastMutex(&unk_1400382C8);
  v4 = *(_QWORD *)(v2 + 24);
  if ( v4 )
    *(_DWORD *)(v4 + 76) = v3;
  ExReleaseFastMutex(&unk_1400382C8);
}

//----- (0000000140019F9C) ----------------------------------------------------
char sub_140019F9C()
{
  char v0; // bl

  v0 = 0;
  KeWaitForSingleObject(&stru_140039660, UserRequest, 0, 0, 0i64);
  if ( !(unsigned int)sub_140008290() )
  {
    dword_140039698 = 2;
    v0 = 1;
  }
  KeReleaseMutex(&stru_140039660, 0);
  return v0;
}
// 140039698: using guessed type int dword_140039698;

//----- (0000000140019FF8) ----------------------------------------------------
PLIST_ENTRY sub_140019FF8()
{
  PLIST_ENTRY result; // rax

  KeSetEvent(&stru_140038320, 0, 0);
  byte_140038311 = 0;
  byte_140038310 = 1;
  while ( 1 )
  {
    result = sub_140018FC4();
    if ( !result )
      break;
    result[1].Blink->Flink = (_LIST_ENTRY *)3;
    LODWORD(result[3].Flink) = 0;
    result[3].Blink = (_LIST_ENTRY *)1048;
    IofCompleteRequest((PIRP)result, 1);
  }
  return result;
}
// 140038310: using guessed type char byte_140038310;
// 140038311: using guessed type char byte_140038311;

//----- (000000014001A05C) ----------------------------------------------------
LONG sub_14001A05C()
{
  KeWaitForSingleObject(&stru_140039660, UserRequest, 0, 0, 0i64);
  sub_1400083D4();
  return KeReleaseMutex(&stru_140039660, 0);
}

//----- (000000014001A0A4) ----------------------------------------------------
void sub_14001A0A4()
{
  _InterlockedIncrement(&dword_140038318);
}
// 140038318: using guessed type int dword_140038318;

//----- (000000014001A0AC) ----------------------------------------------------
signed __int64 __fastcall sub_14001A0AC(int a1)
{
  __int64 v1; // rdx
  _DWORD *v2; // rax
  __int64 v3; // rdi
  char *v4; // rbx
  __int64 v5; // rdx
  __int64 (*v6)(void); // rax
  __int64 v7; // r8
  __int64 v8; // rcx

  v1 = (unsigned int)(a1 + 8);
  if ( (unsigned int)v1 <= dword_14002B540 )
  {
    v3 = 0i64;
    if ( dword_14002B300[0] < (unsigned int)v1 )
    {
      do
        v3 = (unsigned int)(v3 + 1);
      while ( dword_14002B300[48 * v3] < (unsigned int)v1 );
    }
    v4 = (char *)&stru_14002B340 + 192 * v3;
    ++*((_DWORD *)v4 + 5);
    v2 = ExpInterlockedPopEntrySList((PSLIST_HEADER)v4);
    if ( v2
      || (v5 = *((unsigned int *)v4 + 11),
          v6 = (__int64 (*)(void))*((_QWORD *)v4 + 6),
          v7 = *((unsigned int *)v4 + 10),
          v8 = *((unsigned int *)v4 + 9),
          ++*((_DWORD *)v4 + 6),
          (v2 = (_DWORD *)sub_140021A40(v6)) != 0i64) )
    {
      *v2 = v3;
      return (signed __int64)(v2 + 2);
    }
    return 0i64;
  }
  v2 = ExAllocatePoolWithTag(PagedPool, (v1 + 4095) & 0xFFFFFFFFFFFFF000ui64, 0x4E464349u);
  if ( !v2 )
    return 0i64;
  *v2 = 4;
  return (signed __int64)(v2 + 2);
}
// 14002B300: using guessed type int dword_14002B300[];
// 14002B540: using guessed type int dword_14002B540;

//----- (000000014001A170) ----------------------------------------------------
signed __int64 __fastcall sub_14001A170(unsigned __int16 a1)
{
  unsigned __int16 v1; // di
  int v2; // esi
  signed __int64 v3; // rbx

  v1 = a1;
  v2 = a1 + 64;
  v3 = sub_14001A0AC(v2);
  if ( v3 )
  {
    *(_DWORD *)v3 = v2;
    *(_QWORD *)(v3 + 48) = v3 + 60;
    *(_DWORD *)(v3 + 4) = 1;
    *(_WORD *)(v3 + 8) = 0;
    *(_BYTE *)(v3 + 10) = 0;
    *(_WORD *)(v3 + 12) = 0;
    *(_WORD *)(v3 + 40) = 0;
    *(_WORD *)(v3 + 42) = v1;
    *(_QWORD *)(v3 + 32) = 0i64;
    *(_BYTE *)(v3 + 14) = 0;
    *(_DWORD *)(v3 + 16) = 0;
    *(_QWORD *)(v3 + 24) = 0i64;
    *(_DWORD *)(v3 + 56) = 0;
  }
  else if ( dword_140035180 & 1 )
  {
    sub_140007A38((__int64)L"AllocateFileNameInfoRecord: Failed to allocate a buffer");
  }
  return v3;
}
// 140026300: using guessed type wchar_t aAllocatefilena[56];
// 140035180: using guessed type int dword_140035180;

//----- (000000014001A1F8) ----------------------------------------------------
__int64 __fastcall sub_14001A1F8(PCUNICODE_STRING SourceString, __int16 a2)
{
  const UNICODE_STRING *v2; // rbx
  unsigned __int16 v3; // cx
  __int64 result; // rax
  __int64 v5; // rdi
  char v6; // al
  __int64 v7; // r8

  v2 = SourceString;
  v3 = a2 + SourceString->MaximumLength;
  if ( *((_BYTE *)&v2[-2].MaximumLength + 4) )
    v3 += LOWORD(v2[-2].Buffer);
  result = sub_14001A170(v3);
  v5 = result;
  if ( result )
  {
    *(_WORD *)(result + 8) = v2[-2].Length;
    *(_BYTE *)(result + 10) = v2[-2].MaximumLength;
    *(_WORD *)(result + 12) = *(&v2[-2].MaximumLength + 1);
    RtlCopyUnicodeString((PUNICODE_STRING)(result + 40), v2);
    v6 = *((_BYTE *)&v2[-2].MaximumLength + 4);
    *(_BYTE *)(v5 + 14) = v6;
    if ( v6 )
    {
      v7 = *(unsigned __int16 *)(v5 + 42);
      *(_QWORD *)(v5 + 24) = v7 + *(_QWORD *)(v5 + 48) - LOWORD(v2[-2].Buffer);
      *(_WORD *)(v5 + 18) = v2[-2].Buffer;
      *(_WORD *)(v5 + 42) = v7 - LOWORD(v2[-2].Buffer);
      RtlCopyUnicodeString((PUNICODE_STRING)(v5 + 16), (const UNICODE_STRING *)((char *)v2 - 24));
    }
    result = v5 + 40;
  }
  return result;
}

//----- (000000014001A2AC) ----------------------------------------------------
unsigned __int64 __fastcall sub_14001A2AC(_WORD *a1, __int16 a2, unsigned __int16 *a3)
{
  __m128i *v3; // rbx
  unsigned __int16 *v4; // rdi
  unsigned __int64 result; // rax

  v3 = (__m128i *)(a1 + 1);
  v4 = a3;
  if ( a2 )
  {
    *a1 = a2;
    LOWORD(v3->m128i_i64[0]) = 58;
    v3 = (__m128i *)(a1 + 2);
  }
  else
  {
    *a1 = 92;
  }
  sub_140021A80(v3, *((_QWORD *)a3 + 1), *a3);
  result = (unsigned __int64)*v4 >> 1;
  *((_WORD *)v3->m128i_i64 + result) = 0;
  return result;
}

//----- (000000014001A30C) ----------------------------------------------------
__int64 __fastcall sub_14001A30C(const UNICODE_STRING *a1)
{
  const UNICODE_STRING *v1; // rdi
  unsigned __int16 v2; // bx
  char v4; // [rsp+40h] [rbp-F8h]
  char v5; // [rsp+50h] [rbp-E8h]

  v1 = a1;
  v2 = 65;
  while ( !sub_14001AF30(v2, v1, &v4, 1, (WCHAR *)&v5, 0xC8u, 0i64) )
  {
    if ( ++v2 > 0x5Au )
      return 0i64;
  }
  return v2;
}

//----- (000000014001A3A0) ----------------------------------------------------
signed __int16 __fastcall sub_14001A3A0(__int64 a1, _WORD *a2, signed __int16 *a3)
{
  _WORD *v3; // rbx
  unsigned __int16 v4; // di
  char v5; // r10
  unsigned __int16 v6; // r9
  unsigned __int16 v7; // dx
  signed __int16 result; // ax

  v3 = a2;
  v4 = 0;
  v5 = 0;
  if ( !*(_WORD *)a1 )
    goto LABEL_12;
  v6 = *(_WORD *)a1 >> 1;
  v7 = v6 - 1;
  if ( v6 != 1 )
  {
    do
    {
      result = v7;
      if ( *(_WORD *)(*(_QWORD *)(a1 + 8) + 2i64 * v7) == 92 )
        break;
      result = -1;
      --v7;
    }
    while ( v7 );
  }
  if ( v7 < v6 )
  {
    do
    {
      result = v7;
      if ( *(_WORD *)(*(_QWORD *)(a1 + 8) + 2i64 * v7) == 58 )
      {
        if ( v5 )
          goto LABEL_11;
        v4 = v7;
        v5 = 1;
      }
      ++v7;
    }
    while ( v7 < v6 );
    if ( !v5 )
      goto LABEL_12;
LABEL_11:
    *v3 = 2 * (v6 - v4);
    result = 2 * ((*(_WORD *)a1 >> 1) - v7);
    *a3 = result;
  }
  else
  {
LABEL_12:
    *a3 = 0;
    *v3 = 0;
  }
  return result;
}

//----- (000000014001A454) ----------------------------------------------------
void __fastcall sub_14001A454(__int64 a1)
{
  struct _SLIST_ENTRY *v1; // rdi
  __int64 v2; // rax
  char *v3; // rbx

  v1 = (struct _SLIST_ENTRY *)(a1 - 8);
  v2 = *(unsigned int *)(a1 - 8);
  if ( (unsigned int)v2 <= 4 )
  {
    if ( (_DWORD)v2 == 4 )
    {
      ExFreePoolWithTag((PVOID)(a1 - 8), 0);
    }
    else
    {
      v3 = (char *)&stru_14002B340 + 192 * v2;
      ++*((_DWORD *)v3 + 7);
      if ( ExQueryDepthSList((PSLIST_HEADER)v3) < *((_WORD *)v3 + 8) )
      {
        ExpInterlockedPushEntrySList((PSLIST_HEADER)v3, v1);
      }
      else
      {
        ++*((_DWORD *)v3 + 8);
        sub_140021A40(*((__int64 (**)(void))v3 + 7));
      }
    }
  }
}

//----- (000000014001A4E0) ----------------------------------------------------
__int64 __fastcall sub_14001A4E0(__int64 a1)
{
  __int64 v1; // rdi
  unsigned __int32 v2; // ebx
  __int64 v3; // rcx

  v1 = a1 - 40;
  v2 = _InterlockedDecrement((volatile signed __int32 *)(a1 - 40 + 4));
  if ( !v2 )
  {
    v3 = *(_QWORD *)(v1 + 32);
    if ( v3 )
      sub_14001A454(v3);
    sub_14001A454(v1);
  }
  return v2;
}

//----- (000000014001A520) ----------------------------------------------------
__int64 __fastcall sub_14001A520(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  char v3; // bp
  __int64 v4; // rbx
  __int16 v5; // di
  __int64 v6; // rax
  const UNICODE_STRING *v7; // r14
  signed __int64 v8; // rbx
  _DWORD *v9; // rbp
  struct _FILE_OBJECT *v10; // rcx
  char *v11; // rax
  _WORD *v12; // rax
  unsigned __int16 v13; // cx
  __int64 result; // rax
  char v15; // [rsp+40h] [rbp-158h]
  __m128i v16; // [rsp+50h] [rbp-148h]
  char v17; // [rsp+60h] [rbp-138h]
  __int128 v18; // [rsp+70h] [rbp-128h]
  char v19; // [rsp+80h] [rbp-118h]
  char v20; // [rsp+90h] [rbp-108h]

  v2 = a2;
  v3 = 0;
  v4 = 0i64;
  v5 = 0;
  if ( !a1 )
    return 0i64;
  v6 = *(_QWORD *)(a1 + 8);
  if ( !v6 )
    return 0i64;
  if ( *(_QWORD *)(v6 + 56) )
  {
    v5 = *(_WORD *)(a2 + 1060);
    if ( !v5 )
      goto LABEL_44;
    if ( *(_DWORD *)(v6 + 72) == 2 )
    {
      v7 = (const UNICODE_STRING *)(a2 + 512);
      if ( !sub_14001AF30(v5, (const UNICODE_STRING *)(a2 + 512), &v15, 1, (WCHAR *)&v20, 0xC8u, 0i64) )
      {
        v5 = sub_14001A30C(v7);
        v3 = 1;
      }
    }
    if ( !v5 )
    {
LABEL_44:
      v4 = MEMORY[0xFFFFF78000000014];
      if ( MEMORY[0xFFFFF78000000014] - *(_QWORD *)(v2 + 1160) > 10000000i64 )
      {
        v5 = sub_14001A30C((const UNICODE_STRING *)(v2 + 512));
        v3 = 1;
      }
    }
    if ( v3 )
    {
      ExAcquireFastMutex((PFAST_MUTEX)(v2 + 1096));
      *(_WORD *)(v2 + 1060) = v5;
      if ( v4 - *(_QWORD *)(v2 + 1160) > 10000000 )
        *(_QWORD *)(v2 + 1160) = v4;
      ExReleaseFastMutex((PFAST_MUTEX)(v2 + 1096));
    }
  }
  else
  {
    v8 = a1 + 88;
    v9 = 0i64;
    v10 = *(struct _FILE_OBJECT **)(a1 + 64);
    if ( v10 && (!*(_WORD *)v8 || **(_WORD **)(v8 + 8) != 92) )
    {
      v9 = sub_14001B668(v10, (__int64)&v17);
      v11 = &v17;
      if ( !v9 )
        v11 = (char *)v8;
      v8 = (signed __int64)v11;
    }
    if ( RtlCompareUnicodeString((PCUNICODE_STRING)(v2 + 512), &stru_140028D10, 1u)
      || *(_WORD *)v8 < 2u
      || **(_WORD **)(v8 + 8) != 92
      || (v16 = *(__m128i *)v8,
          _mm_store_si128((__m128i *)&v18, v16),
          FsRtlDissectName(&v18, &v19, &v16),
          v16.m128i_i16[0] < 6u)
      || *(_WORD *)v16.m128i_i64[1] != 59
      || *(_WORD *)(v16.m128i_i64[1] + 4) != 58
      || (v5 = *(_WORD *)(v16.m128i_i64[1] + 2)) == 0 )
    {
      if ( *(_WORD *)v8 >= 8u )
      {
        v12 = *(_WORD **)(v8 + 8);
        if ( *v12 == 92 && v12[1] == 59 && v12[3] == 58 )
          v5 = v12[2];
      }
    }
    if ( v9 )
      sub_14001A454((__int64)v9);
  }
  v13 = v5 - 32;
  if ( (unsigned __int16)(v5 - 97) > 0x19u )
    v13 = v5;
  result = v13;
  if ( v13 && (v13 < 0x41u || v13 > 0x5Au) )
    result = 0i64;
  return result;
}
// 140028258: using guessed type __int64 __fastcall FsRtlDissectName(_QWORD, _QWORD, _QWORD);

//----- (000000014001A79C) ----------------------------------------------------
__int64 __fastcall sub_14001A79C(PCUNICODE_STRING Source, const UNICODE_STRING *a2, const UNICODE_STRING *a3, UNICODE_STRING *a4)
{
  UNICODE_STRING *v4; // rdi
  const UNICODE_STRING *v5; // rsi
  PCUNICODE_STRING v6; // rbp
  unsigned int v7; // ebx

  v4 = a4;
  v5 = a3;
  v6 = Source;
  v7 = 0;
  if ( a4 )
    RtlCopyUnicodeString(a4, a2);
  else
    v7 = a2->Length;
  if ( v5->Buffer && v5->Length )
  {
    if ( v4 )
      RtlAppendUnicodeStringToString(v4, v5);
    else
      v7 += v5->Length;
    if ( v6->Length >= 2u && *v6->Buffer != 58 && v5->Buffer[((unsigned __int64)v5->Length >> 1) - 1] != 92 )
    {
      if ( v4 )
        RtlAppendUnicodeToString(v4, &word_140026510);
      else
        v7 += 2;
    }
  }
  if ( v4 )
    RtlAppendUnicodeStringToString(v4, v6);
  else
    v7 += v6->Length;
  return v7;
}

//----- (000000014001A88C) ----------------------------------------------------
signed __int64 __fastcall sub_14001A88C(__int16 a1, const UNICODE_STRING *a2, struct _FILE_OBJECT *a3, const UNICODE_STRING *a4, int a5)
{
  bool v5; // di
  struct _FILE_OBJECT *v6; // rbx
  const UNICODE_STRING *v7; // rsi
  __int16 v8; // r12
  const UNICODE_STRING *v9; // r15
  _DWORD *v10; // r13
  _DWORD *v11; // r14
  struct _FILE_OBJECT *v12; // rcx
  unsigned int v13; // esi
  unsigned __int16 v14; // dx
  __int64 v15; // rcx
  UNICODE_STRING v16; // xmm0
  WCHAR *v17; // rax
  signed __int64 v18; // rax
  signed __int64 v19; // rsi
  __int64 v20; // rcx
  unsigned __int16 *v22; // r14
  __int64 v23; // rcx
  __int16 v24; // ax
  USHORT v25; // dx
  PCUNICODE_STRING v26; // rdx
  __int64 v27; // r8
  __int64 v28; // rcx
  __int16 v29; // ax
  unsigned __int16 v30; // cx
  __int64 v31; // rax
  __int16 v32; // [rsp+40h] [rbp-C0h]
  USHORT v33; // [rsp+44h] [rbp-BCh]
  unsigned __int16 v34; // [rsp+48h] [rbp-B8h]
  UNICODE_STRING String1; // [rsp+50h] [rbp-B0h]
  UNICODE_STRING Source; // [rsp+60h] [rbp-A0h]
  _DWORD *v37; // [rsp+70h] [rbp-90h]
  PCUNICODE_STRING SourceString; // [rsp+78h] [rbp-88h]
  UNICODE_STRING v39; // [rsp+80h] [rbp-80h]
  UNICODE_STRING String2; // [rsp+90h] [rbp-70h]
  char v41[208]; // [rsp+A0h] [rbp-60h]
  char v42; // [rsp+170h] [rbp+70h]

  v5 = 0;
  *(_QWORD *)&v39.Length = a2;
  v32 = 0;
  SourceString = a4 + 65;
  v6 = a3;
  v37 = 0i64;
  v7 = a2;
  *(_DWORD *)&Source.Length = 0;
  v8 = a1;
  Source.Buffer = 0i64;
  v9 = a4 + 32;
  v33 = 0;
  v10 = 0i64;
  v11 = 0i64;
  if ( !a3 || !a3->DeviceObject )
    return 0i64;
  if ( a5 )
  {
    v37 = sub_14001B668(a3, (__int64)&Source);
    v11 = v37;
    if ( !v37 )
      return 0i64;
    v13 = Source.Length + v9->Length;
    if ( !v6->DeviceObject->DoNotUse1 )
    {
      if ( !sub_14001AF30(v8, v9, &v34, 1, (WCHAR *)v41, 0xC8u, 0i64) )
        goto LABEL_59;
      v14 = v34;
      if ( v34 > 0xC8u
        || (v15 = v9->Length,
            v16 = Source,
            _mm_store_si128((__m128i *)&String2, (__m128i)Source),
            String1.Buffer = (PWSTR)&v41[v15],
            String1.Length = v14 - v15,
            String1.MaximumLength = v14 - v15,
            String2.Length = v14 - v15,
            (unsigned __int16)_mm_cvtsi128_si32((__m128i)v16) < (unsigned __int16)(v14 - v15))
        || RtlCompareUnicodeString(&String1, &String2, 1u) )
      {
LABEL_59:
        v8 = 0;
      }
    }
  }
  else
  {
    if ( !a2->Length || *a2->Buffer != 92 )
    {
      v12 = a3->RelatedFileObject;
      if ( v12 )
      {
        if ( !(v12->Flags & 0x400000) )
        {
          v10 = sub_14001B668(v12, (__int64)&Source);
          if ( !v10 )
            return 0i64;
        }
      }
    }
    v13 = sub_14001A79C(v7, v9, &Source, 0i64);
  }
  if ( !sub_14001AF30(v8, v9, &v32, 0, (WCHAR *)&v42, 0xC8u, &v33) )
  {
    if ( v33 )
    {
      v17 = (WCHAR *)sub_14001A0AC(v33);
      *(_QWORD *)&String1.Length = v17;
      if ( v17 )
      {
        sub_14001AF30(v8, v9, &v32, 0, v17, v33, 0i64);
        sub_14001A454(*(__int64 *)&String1.Length);
      }
    }
  }
  if ( !v8 && v6->DeviceObject->DoNotUse1 )
    v13 += SourceString->Length;
  if ( v13 > 0xFFFF )
    return 0i64;
  v18 = sub_14001A170(v13);
  v19 = v18;
  if ( !v18 )
  {
    if ( v10 )
    {
      v20 = (__int64)v10;
LABEL_30:
      sub_14001A454(v20);
      return 0i64;
    }
    if ( v11 )
    {
      v20 = (__int64)v11;
      goto LABEL_30;
    }
    return 0i64;
  }
  *(_WORD *)(v18 + 8) = v8;
  v22 = (unsigned __int16 *)(v18 + 40);
  *(_BYTE *)(v18 + 10) = v6->DeviceObject->DoNotUse1 == 0i64;
  if ( a5 )
  {
    RtlCopyUnicodeString((PUNICODE_STRING)(v18 + 40), v9);
    RtlAppendUnicodeStringToString((PUNICODE_STRING)(v19 + 40), &Source);
    v23 = (__int64)v37;
  }
  else
  {
    sub_14001A79C(*(PCUNICODE_STRING *)&v39.Length, v9, &Source, (UNICODE_STRING *)(v18 + 40));
    if ( !v10 )
      goto LABEL_38;
    v23 = (__int64)v10;
  }
  sub_14001A454(v23);
LABEL_38:
  if ( !v8 || v6->DeviceObject->DoNotUse1 )
  {
    v25 = v9->Length;
    *(_WORD *)(v19 + 12) = v9->Length;
    if ( !v8 )
    {
      if ( v6->DeviceObject->DoNotUse1 )
      {
        v26 = SourceString;
        v27 = *(unsigned __int16 *)(v19 + 42);
        v28 = *(_QWORD *)(v19 + 48);
        *(_BYTE *)(v19 + 14) = 1;
        *(_QWORD *)(v19 + 24) = v27 + v28 - v26->Length;
        *(_WORD *)(v19 + 18) = v26->Length;
        *(_WORD *)(v19 + 42) = v27 - v26->Length;
        RtlCopyUnicodeString((PUNICODE_STRING)(v19 + 16), v26);
      }
      else if ( (unsigned int)v25 + 6 >= *v22
             && *(_WORD *)(*(_QWORD *)(v19 + 48) + 2 * ((unsigned __int64)((unsigned int)v25 + 4) >> 1)) == 58 )
      {
        *(_WORD *)(v19 + 12) = v25 + 6;
      }
    }
  }
  else
  {
    v24 = v32;
    if ( !v32 )
      v24 = v9->Length + 6;
    *(_WORD *)(v19 + 12) = v24;
  }
  sub_14001A3A0(v19 + 40, (_WORD *)(v19 + 56), &v32);
  v29 = *(_WORD *)(v19 + 56) - v32;
  v30 = *v22 - v32;
  *v22 = v30;
  *(_WORD *)(v19 + 56) = v29;
  if ( *(_WORD *)(v19 + 12) > v30 )
    *(_WORD *)(v19 + 12) = v30;
  if ( v29 )
  {
    *(_BYTE *)(v19 + 58) = 1;
    v39.Buffer = L":AFP_Resource";
    *(_DWORD *)&v39.Length = 1703962;
    if ( v30 )
    {
      if ( v29 == 26 )
      {
        v31 = *(_QWORD *)(v19 + 48);
        *(_DWORD *)&String1.Length = 1703962;
        String1.Buffer = (PWSTR)(v31 + 2 * (((unsigned __int64)v30 >> 1) - 13));
        v5 = RtlCompareUnicodeString(&String1, &v39, 1u) == 0;
      }
    }
    *(_BYTE *)(v19 + 59) = v5;
  }
  return v19 + 40;
}
// 140026520: using guessed type wchar_t aAfpResource[14];
// 14001A88C: using guessed type char var_1E0[208];

//----- (000000014001ACF0) ----------------------------------------------------
__int64 __fastcall sub_14001ACF0(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 8);
  *(_WORD *)(a2 + 2) = *(_WORD *)(a1 + 2);
  result = *(unsigned __int16 *)(a1 + 16);
  *(_WORD *)a2 = *(_WORD *)a1 - result;
  return result;
}

//----- (000000014001AD10) ----------------------------------------------------
UNICODE_STRING *__fastcall sub_14001AD10(__int64 a1, const UNICODE_STRING *a2, __int64 a3)
{
  __int16 v3; // r14
  _WORD *v4; // rax
  __int64 v5; // rbx
  __int64 v6; // r8
  __int64 v7; // rdi
  const UNICODE_STRING *v8; // r9
  __int64 v9; // rcx
  KPROCESSOR_MODE v10; // r9
  ACCESS_MASK v11; // edx
  POBJECT_TYPE *v12; // r8
  const UNICODE_STRING *v13; // rbx
  UNICODE_STRING *v14; // rax
  UNICODE_STRING *v15; // rdi
  USHORT v16; // ax
  int v17; // er10
  __int16 v18; // dx
  signed int v19; // ebx
  UNICODE_STRING *v20; // rax
  __int16 v21; // cx
  UNICODE_STRING Source; // [rsp+30h] [rbp-10h]
  __int16 v24; // [rsp+78h] [rbp+38h]
  PVOID Object; // [rsp+80h] [rbp+40h]

  v3 = a2[-2].Length;
  v4 = (_WORD *)(a3 + 20);
  v5 = a3;
  Source.Buffer = (PWSTR)(a3 + 20);
  v6 = *(unsigned __int16 *)(a3 + 16);
  v7 = a1;
  Source.MaximumLength = v6;
  v8 = a2;
  Source.Length = v6;
  v9 = *(_QWORD *)(v5 + 8);
  if ( v9 )
  {
    if ( (unsigned __int8)ObIsKernelHandle(v9, a2, v6, a2) )
    {
      v10 = 0;
      v11 = 983040;
      v12 = 0i64;
    }
    else
    {
      v10 = 1;
      v11 = 0;
      v12 = IoFileObjectType;
    }
    if ( ObReferenceObjectByHandle(*(HANDLE *)(v5 + 8), v11, (POBJECT_TYPE)v12, v10, &Object, 0i64) >= 0 )
    {
      if ( Object )
      {
        v13 = (const UNICODE_STRING *)sub_14001A88C(
                                        v3,
                                        (const UNICODE_STRING *)((char *)Object + 88),
                                        (struct _FILE_OBJECT *)Object,
                                        (const UNICODE_STRING *)v7,
                                        1);
        ObfDereferenceObject(Object);
        if ( v13 )
        {
          v14 = (UNICODE_STRING *)sub_14001A1F8(v13, Source.Length + 2);
          v15 = v14;
          if ( v14 )
          {
            v16 = v14->Length;
            if ( v16 < 2u || v15->Buffer[((unsigned __int64)v16 >> 1) - 1] != 92 )
              RtlAppendUnicodeToString(v15, &word_140026510);
            RtlAppendUnicodeStringToString(v15, &Source);
          }
          sub_14001A4E0((__int64)v13);
          goto LABEL_25;
        }
      }
    }
    return 0i64;
  }
  if ( (unsigned __int16)v6 < 2u || *v4 != 92 )
  {
    v17 = a2->Length;
    v18 = 0;
    v19 = ((unsigned int)v8->Length >> 1) - 1;
    if ( v19 < 0 )
      return 0i64;
    do
    {
      if ( v8->Buffer[v19] == 92 )
        break;
      --v19;
    }
    while ( v19 >= 0 );
    if ( v19 < 0 )
      return 0i64;
    if ( (unsigned __int16)v6 > v17 - (2 * v19 + 2) )
      v18 = v6 + 2 * (v19 + 1) - v17;
    v20 = (UNICODE_STRING *)sub_14001A1F8(v8, v18);
    v15 = v20;
    if ( !v20 )
      return 0i64;
    v20->Length = 2 * (v19 + 1);
    RtlAppendUnicodeStringToString(v20, &Source);
  }
  else
  {
    v15 = (UNICODE_STRING *)sub_14001B448(&Source, *(_BYTE *)(v7 + 1062) == 0);
  }
LABEL_25:
  if ( v15 )
  {
    sub_14001A3A0((__int64)v15, &v15[1].Length, &v24);
    v21 = v24;
    v15->Length -= v24;
    v15[1].Length -= v21;
  }
  return v15;
}
// 140028628: using guessed type __int64 __fastcall ObIsKernelHandle(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014001AF30) ----------------------------------------------------
char __fastcall sub_14001AF30(__int16 a1, const UNICODE_STRING *a2, _WORD *a3, char a4, WCHAR *a5, USHORT a6, _WORD *a7)
{
  char v7; // si
  _WORD *v8; // r12
  const UNICODE_STRING *v9; // r14
  NTSTATUS v10; // edi
  __int16 v12; // di
  char v13; // r15
  int v14; // ebx
  USHORT v15; // ax
  USHORT v16; // dx
  unsigned __int8 v17; // r9
  USHORT v18; // r8
  unsigned __int8 v19; // cl
  bool v20; // zf
  USHORT v21; // ax
  NTSTATUS v22; // esi
  UNICODE_STRING String2; // [rsp+20h] [rbp-81h]
  UNICODE_STRING LinkTarget; // [rsp+30h] [rbp-71h]
  ULONG ReturnedLength; // [rsp+40h] [rbp-61h]
  HANDLE LinkHandle; // [rsp+48h] [rbp-59h]
  OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+50h] [rbp-51h]
  __int128 v28; // [rsp+80h] [rbp-21h]
  __int64 v29; // [rsp+90h] [rbp-11h]
  int v30; // [rsp+98h] [rbp-9h]
  __int16 v31; // [rsp+9Ch] [rbp-5h]

  v7 = a4;
  v8 = a3;
  v30 = 3801176;
  v9 = a2;
  v31 = 0;
  String2.Buffer = (PWSTR)&v28;
  v29 = 25896191785238627i64;
  *(_DWORD *)&String2.Length = 1835036;
  v28 = xmmword_140022E30;
  if ( a7 )
    *a7 = 0;
  if ( !a1 )
    return 0;
  LOWORD(v30) = a1;
  *(_QWORD *)&LinkTarget.Length = 0i64;
  LinkTarget.MaximumLength = a6;
  LinkTarget.Buffer = a5;
  ObjectAttributes.ObjectName = &String2;
  ObjectAttributes.Length = 48;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 576;
  _mm_storeu_si128((__m128i *)&ObjectAttributes.SecurityDescriptor, (__m128i)0i64);
  if ( ZwOpenSymbolicLinkObject(&LinkHandle, 1u, &ObjectAttributes) )
    return 0;
  v10 = ZwQuerySymbolicLinkObject(LinkHandle, &LinkTarget, &ReturnedLength);
  ZwClose(LinkHandle);
  if ( v10 )
  {
    if ( v10 == -1073741789 && a7 && ReturnedLength == (unsigned __int16)ReturnedLength )
      *a7 = ReturnedLength;
    return 0;
  }
  if ( !v9 )
    return 1;
  _mm_store_si128((__m128i *)&String2, (__m128i)LinkTarget);
  v12 = 0;
  v13 = 0;
  if ( RtlCompareUnicodeString(v9, &stru_140028D10, 1u) )
  {
    v14 = v7 != 0 ? 0x40 : 0;
  }
  else
  {
    v14 = 1;
    v13 = 1;
  }
  while ( v13 )
  {
    v17 = 0;
    v18 = 0;
    String2.Length = 0;
    do
    {
      if ( v18 >= LinkTarget.Length )
        break;
      v19 = v17 + 1;
      if ( String2.Buffer[(unsigned __int64)v18 >> 1] != 92 )
        v19 = v17;
      v18 += 2;
      String2.Length = v18;
      v17 = v19;
    }
    while ( v19 < 3u );
    if ( v17 < 3u )
      return 0;
    String2.Length = v18 - 2;
    v20 = RtlCompareUnicodeString(v9, &String2, 1u) == 0;
    v21 = LinkTarget.Length;
    if ( v20 )
      goto LABEL_38;
    v12 += LinkTarget.Length - String2.Length;
LABEL_32:
    if ( v14 )
    {
      ObjectAttributes.Length = 48;
      ObjectAttributes.ObjectName = &String2;
      ObjectAttributes.RootDirectory = 0i64;
      ObjectAttributes.Attributes = 576;
      _mm_storeu_si128((__m128i *)&ObjectAttributes.SecurityDescriptor, (__m128i)0i64);
      v22 = ZwOpenSymbolicLinkObject(&LinkHandle, 1u, &ObjectAttributes);
      if ( !v22 )
      {
        v22 = ZwQuerySymbolicLinkObject(LinkHandle, &LinkTarget, &ReturnedLength);
        ZwClose(LinkHandle);
      }
      --v14;
      if ( !v22 )
        continue;
    }
    return 0;
  }
  v15 = v9->Length;
  v16 = LinkTarget.Length;
  if ( LinkTarget.Length < v9->Length
    || (String2.Length = v9->Length, LinkTarget.Length != v15) && LinkTarget.Buffer[(unsigned __int64)v15 >> 1] != 92 )
  {
LABEL_23:
    String2.Length = v16;
    goto LABEL_32;
  }
  if ( RtlCompareUnicodeString(v9, &String2, 1u) )
  {
    v16 = LinkTarget.Length;
    goto LABEL_23;
  }
  v21 = LinkTarget.Length;
LABEL_38:
  *v8 = v12 + v21;
  return 1;
}
// 140022E30: using guessed type __int128 xmmword_140022E30;

//----- (000000014001B244) ----------------------------------------------------
signed __int64 __fastcall sub_14001B244(_WORD *a1, _WORD *a2, UNICODE_STRING *a3, char a4)
{
  UNICODE_STRING *v4; // rbx
  signed __int64 result; // rax
  _WORD *v6; // rsi
  unsigned __int64 v7; // rcx
  unsigned __int16 v8; // dx
  unsigned __int16 v9; // r8
  int v10; // er9
  USHORT v11; // dx
  unsigned __int16 v12; // bp

  *a2 = *(a1 - 16);
  v4 = a3;
  result = (unsigned __int16)*(a1 - 14);
  v6 = a1;
  if ( (unsigned __int16)result < *a1 )
  {
    v7 = (unsigned __int16)result;
    result = *((_QWORD *)v6 + 1);
    a3->Buffer = (PWSTR)(result + 2 * (v7 >> 1));
    v8 = *v6;
    v9 = *(v6 - 14);
    if ( !a4 )
    {
      v10 = (unsigned __int16)v6[8];
      result = v9;
      if ( v8 - v9 >= v10 )
        v8 -= v10;
    }
    v11 = v8 - v9;
    v4->Length = v11;
    v4->MaximumLength = v11;
    if ( v11 >= 4u )
    {
      result = (signed __int64)(v4->Buffer + 1);
      if ( *(_WORD *)result == 92 )
      {
        v4->Buffer = (PWSTR)result;
        v4->Length = v11 - 2;
        v4->MaximumLength = v11 - 2;
      }
    }
    if ( *((_BYTE *)v6 - 26) )
    {
      result = *((_QWORD *)v6 - 1);
      if ( result )
        goto LABEL_17;
      v12 = *(v6 - 12) + stru_14002B600.Length + *v6 - *(v6 - 14);
      result = sub_14001A0AC((unsigned int)v12 + 16);
      *((_QWORD *)v6 - 1) = result;
      if ( !result )
        goto LABEL_18;
      *(_QWORD *)(result + 8) = result + 16;
      **((_WORD **)v6 - 1) = 0;
      *(_WORD *)(*((_QWORD *)v6 - 1) + 2i64) = v12;
      RtlCopyUnicodeString(*((PUNICODE_STRING *)v6 - 1), &stru_14002B600);
      RtlAppendUnicodeStringToString(*((PUNICODE_STRING *)v6 - 1), (PCUNICODE_STRING)(v6 - 12));
      RtlAppendUnicodeStringToString(*((PUNICODE_STRING *)v6 - 1), v4);
      result = *((_QWORD *)v6 - 1);
      if ( result )
      {
LABEL_17:
        _mm_storeu_si128((__m128i *)v4, *(__m128i *)result);
      }
      else
      {
LABEL_18:
        *(_DWORD *)&v4->Length = 0;
        v4->Buffer = 0i64;
      }
    }
  }
  else
  {
    *(_DWORD *)&a3->Length = 0;
    a3->Buffer = 0i64;
  }
  return result;
}

//----- (000000014001B3B0) ----------------------------------------------------
__int64 __fastcall sub_14001B3B0(__int16 a1, unsigned __int16 *a2)
{
  return *a2 + (a1 != 0 ? 6 : 4);
}

//----- (000000014001B3C4) ----------------------------------------------------
bool __fastcall sub_14001B3C4(__int64 a1)
{
  return *(_WORD *)(a1 + 16) != 0;
}

//----- (000000014001B3D0) ----------------------------------------------------
__int64 sub_14001B3D0()
{
  int *v0; // rbx
  signed __int64 v1; // rsi
  struct _PAGED_LOOKASIDE_LIST *v2; // rdi

  v0 = dword_14002B300;
  v1 = 4i64;
  v2 = &stru_14002B340;
  do
  {
    ExInitializePagedLookasideList(v2, 0i64, 0i64, 0, (unsigned int)*v0, 0x4E464349u, 0);
    v2 = (struct _PAGED_LOOKASIDE_LIST *)((char *)v2 + 192);
    v0 += 48;
    --v1;
  }
  while ( v1 );
  return 0i64;
}
// 14002B300: using guessed type int dword_14002B300[];

//----- (000000014001B448) ----------------------------------------------------
__int64 __fastcall sub_14001B448(PCUNICODE_STRING SourceString, char a2)
{
  char v2; // r14
  WCHAR v3; // r12
  PCUNICODE_STRING v4; // r15
  char v5; // r13
  UNICODE_STRING v6; // xmm0
  unsigned __int16 v7; // di
  PWSTR v8; // rbx
  signed __int16 v9; // ax
  void *v10; // rbx
  signed __int16 v11; // ax
  __int16 v12; // si
  __int64 result; // rax
  __int64 v14; // rbx
  __int64 v15; // rdx
  UNICODE_STRING SourceStringa; // [rsp+20h] [rbp-50h]
  void *Source1[2]; // [rsp+30h] [rbp-40h]
  UNICODE_STRING String2; // [rsp+40h] [rbp-30h]
  UNICODE_STRING String1; // [rsp+50h] [rbp-20h]
  UNICODE_STRING v20; // [rsp+60h] [rbp-10h]

  *(_DWORD *)&String2.Length = 1572888;
  v2 = 0;
  *(_DWORD *)&SourceStringa.Length = 0;
  v3 = 0;
  SourceStringa.Buffer = 0i64;
  v4 = SourceString;
  *(_DWORD *)&v20.Length = 393222;
  v5 = a2;
  String2.Buffer = L"\\DosDevices\\";
  v6 = *SourceString;
  v20.Buffer = L"UNC";
  v7 = _mm_cvtsi128_si32((__m128i)v6);
  *(UNICODE_STRING *)Source1 = v6;
  v8 = v6.Buffer;
  if ( v7 >= 8u && RtlCompareMemory(v6.Buffer, L"\\??\\", 8ui64) == 8 )
  {
    v8 = v6.Buffer + 4;
    v9 = -8;
LABEL_7:
    v7 += v9;
    Source1[1] = v8;
    goto LABEL_8;
  }
  if ( v7 >= 0x18u )
  {
    *(_DWORD *)&String1.Length = 1572888;
    String1.Buffer = v6.Buffer;
    if ( !RtlCompareUnicodeString(&String1, &String2, 1u) )
    {
      v8 = v6.Buffer + 12;
      v9 = -24;
      goto LABEL_7;
    }
  }
LABEL_8:
  if ( v7 >= 4u && v8[1] == 58 )
  {
    v3 = *v8;
    v10 = v8 + 2;
    v11 = -4;
LABEL_14:
    Source1[1] = v10;
    v7 += v11;
    goto LABEL_20;
  }
  *(_DWORD *)&String1.Length = 393222;
  String1.Buffer = v8;
  if ( v7 >= 6u && !RtlCompareUnicodeString(&String1, &v20, 1u) )
  {
    v10 = v8 + 3;
    v11 = -6;
    goto LABEL_14;
  }
  SourceStringa.Buffer = v8;
  if ( v7 >= 2u )
  {
    do
    {
      if ( *v8 == 92 )
        break;
      SourceStringa.Length += 2;
      v7 -= 2;
      ++v8;
    }
    while ( v7 >= 2u );
    Source1[1] = v8;
  }
  v2 = 1;
  SourceStringa.MaximumLength = SourceStringa.Length;
LABEL_20:
  v12 = LOWORD(Source1[1]) - LOWORD(v4->Buffer);
  result = sub_14001A170(SourceStringa.Length + v7 + v4->Length);
  v14 = result;
  if ( result )
  {
    RtlCopyUnicodeString((PUNICODE_STRING)(result + 40), v4);
    *(_WORD *)(v14 + 12) = v12;
    *(_WORD *)(v14 + 8) = v3;
    *(_BYTE *)(v14 + 10) = v5;
    *(_BYTE *)(v14 + 14) = v2;
    if ( v2 )
    {
      v15 = *(unsigned __int16 *)(v14 + 42);
      *(_QWORD *)(v14 + 24) = v15 + *(_QWORD *)(v14 + 48) - SourceStringa.Length;
      *(_WORD *)(v14 + 18) = SourceStringa.Length;
      *(_WORD *)(v14 + 42) = v15 - SourceStringa.Length;
      RtlCopyUnicodeString((PUNICODE_STRING)(v14 + 16), &SourceStringa);
    }
    result = v14 + 40;
  }
  return result;
}
// 1400246D0: using guessed type wchar_t asc_1400246D0[5];
// 140026540: using guessed type wchar_t aDosdevices[13];
// 140026560: using guessed type wchar_t aUnc[4];

//----- (000000014001B660) ----------------------------------------------------
char __fastcall sub_14001B660(__int64 a1)
{
  return *(_BYTE *)(a1 + 18);
}

//----- (000000014001B664) ----------------------------------------------------
char __fastcall sub_14001B664(__int64 a1)
{
  return *(_BYTE *)(a1 + 19);
}

//----- (000000014001B668) ----------------------------------------------------
_DWORD *__fastcall sub_14001B668(struct _FILE_OBJECT *a1, __int64 a2)
{
  __int64 v2; // rdi
  int v3; // esi
  struct _FILE_OBJECT *v4; // r14
  int v5; // ebp
  __int64 v6; // rax
  _DWORD *v7; // rbx
  __m128i v9; // [rsp+20h] [rbp-18h]

  v2 = a2;
  v3 = dword_14002B300[0] - 8;
  v4 = a1;
  v5 = 0;
  while ( 1 )
  {
    v6 = sub_14001A0AC(v3);
    v7 = (_DWORD *)v6;
    if ( !v6 )
    {
      if ( dword_140035180 & 1 )
        sub_140007A38((__int64)L"QueryFileName: Failed to allocate a buffer");
      return 0i64;
    }
    sub_140011F10(v4, v6, v3, &v9);
    if ( v9.m128i_i32[0] >= 0 )
      break;
    v3 = *v7 + 8;
    if ( v9.m128i_i32[0] != -1073741820 && v9.m128i_i32[0] != -2147483643 || (unsigned int)(*v7 - 1) > 0xFFF6 )
    {
      if ( dword_140035180 & 1 )
        sub_140007A38((__int64)L"QueryFileName: Unexpected response from query to filesystem: status %x, length: %d");
      sub_14001A454((__int64)v7);
      return 0i64;
    }
    if ( dword_140035180 & 1 )
      sub_140007A38((__int64)L"QueryFileName: Call to GetFileNameInformation failed with status: %x");
    sub_14001A454((__int64)v7);
    if ( (unsigned int)++v5 >= 2 )
      return 0i64;
  }
  if ( v2 )
  {
    *(_WORD *)v2 = *(_WORD *)v7;
    *(_WORD *)(v2 + 2) = *(_WORD *)v7;
    *(_QWORD *)(v2 + 8) = v7 + 1;
  }
  return v7;
}
// 140026370: using guessed type wchar_t aQueryfilenameF[43];
// 1400263D0: using guessed type wchar_t aQueryfilenameU[83];
// 140026480: using guessed type wchar_t aQueryfilenameC[69];
// 14002B300: using guessed type int dword_14002B300[];
// 140035180: using guessed type int dword_140035180;

//----- (000000014001B77C) ----------------------------------------------------
void __fastcall sub_14001B77C(__int64 a1)
{
  _InterlockedIncrement((volatile signed __int32 *)(a1 - 36));
}

//----- (000000014001B784) ----------------------------------------------------
void sub_14001B784()
{
  struct _PAGED_LOOKASIDE_LIST *v0; // rbx
  signed __int64 v1; // rdi

  v0 = &stru_14002B340;
  v1 = 4i64;
  do
  {
    ExDeletePagedLookasideList(v0);
    v0 = (struct _PAGED_LOOKASIDE_LIST *)((char *)v0 + 192);
    --v1;
  }
  while ( v1 );
}

//----- (000000014001B7C4) ----------------------------------------------------
__int64 __fastcall sub_14001B7C4(__int64 a1, const UNICODE_STRING *a2, UNICODE_STRING *a3, __int64 a4, __int64 a5, int a6, _OWORD *a7)
{
  __int64 v7; // rbp
  UNICODE_STRING *v8; // rdi
  UNICODE_STRING *v9; // rsi
  __int64 v10; // rbx
  __m128i v11; // xmm0
  __int16 *v12; // r14
  __m128i v13; // xmm0
  char v14; // di
  char v15; // cl
  UNICODE_STRING GuidString; // [rsp+20h] [rbp-68h]
  GUID Guid; // [rsp+30h] [rbp-58h]

  *(_QWORD *)(a1 + 1344) = 0i64;
  v7 = a4;
  *(_QWORD *)(a1 + 1352) = 0i64;
  v8 = a3;
  *(_DWORD *)(a1 + 1360) = a6;
  v9 = (UNICODE_STRING *)a2;
  v10 = a1;
  if ( a2 && a2->Length > 0x200u )
  {
    v11 = *(__m128i *)a2;
    v12 = (__int16 *)(a1 + 664);
    *(_QWORD *)(a1 + 1344) = a2;
    _mm_storeu_si128((__m128i *)(a1 + 664), v11);
  }
  else
  {
    *(_WORD *)(a1 + 666) = 512;
    v12 = (__int16 *)(a1 + 664);
    *(_WORD *)(a1 + 664) = 0;
    *(_QWORD *)(a1 + 672) = a1 + 152;
    if ( a2 )
    {
      RtlCopyUnicodeString((PUNICODE_STRING)(a1 + 664), a2);
      sub_14000AB20(v9);
    }
  }
  _mm_storeu_si128((__m128i *)(v10 + 1232), (__m128i)xmmword_140028BA0);
  if ( v8 && v8->Length > 0x200u )
  {
    v13 = *(__m128i *)v8;
    *(_QWORD *)(v10 + 1352) = v8;
    _mm_storeu_si128((__m128i *)(v10 + 1192), v13);
  }
  else
  {
    *(_WORD *)(v10 + 1194) = 512;
    *(_WORD *)(v10 + 1192) = 0;
    *(_QWORD *)(v10 + 1200) = v10 + 680;
    if ( v8 )
    {
      RtlCopyUnicodeString((PUNICODE_STRING)(v10 + 1192), v8);
      if ( v8->Length == 88 )
      {
        GuidString.Length = 76;
        GuidString.MaximumLength = v8->MaximumLength - 12;
        GuidString.Buffer = v8->Buffer + 6;
        if ( !RtlGUIDFromString(&GuidString, &Guid) )
          _mm_storeu_si128((__m128i *)(v10 + 1232), (__m128i)Guid);
      }
      sub_14000AB20(v8);
    }
  }
  *(_DWORD *)(v10 + 1228) = sub_140008D4C((const UNICODE_STRING *)(v7 + 24));
  v14 = 1;
  *(_DWORD *)(v10 + 1208) = 0;
  *(_WORD *)(v10 + 1212) = 0;
  *(_BYTE *)(v10 + 1214) = *(_DWORD *)v7 != 20;
  v15 = *(_BYTE *)(a5 + 4) & 1;
  *(_BYTE *)(v10 + 1215) = v15;
  *(_BYTE *)(v10 + 1216) = *(_DWORD *)v7 == 3;
  *(_WORD *)(v10 + 1218) = (unsigned __int8)(v15 ^ 1) + 1;
  *(_DWORD *)(v10 + 1220) = 2147483648;
  *(_DWORD *)(v10 + 1224) = 0;
  *(_DWORD *)(v10 + 1248) = 1;
  *(_QWORD *)(v10 + 1256) = 0i64;
  *(_DWORD *)(v10 + 1264) = 0;
  KeInitializeEvent((PRKEVENT)(v10 + 1272), SynchronizationEvent, 0);
  *(_DWORD *)(v10 + 1324) = -1;
  *(_QWORD *)(v10 + 1304) = 0i64;
  *(_QWORD *)(v10 + 1312) = 0i64;
  *(_DWORD *)(v10 + 1320) = 0;
  *(_QWORD *)(v10 + 1328) = 0i64;
  *(_BYTE *)(v10 + 1336) = sub_140008B24(v12);
  if ( a7 )
  {
    *(_OWORD *)v10 = *a7;
    *(_OWORD *)(v10 + 16) = a7[1];
    *(_OWORD *)(v10 + 32) = a7[2];
    *(_OWORD *)(v10 + 48) = a7[3];
    *(_OWORD *)(v10 + 64) = a7[4];
    *(_OWORD *)(v10 + 80) = a7[5];
    *(_OWORD *)(v10 + 96) = a7[6];
    *(_OWORD *)(v10 + 112) = a7[7];
    *(_OWORD *)(v10 + 128) = a7[8];
  }
  else
  {
    v14 = 0;
  }
  *(_BYTE *)(v10 + 144) = v14;
  return v10;
}
// 140028BA0: using guessed type __int128 xmmword_140028BA0;

//----- (000000014001BA90) ----------------------------------------------------
void __fastcall sub_14001BA90(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rcx
  void *v3; // rcx

  v1 = a1;
  v2 = *(void **)(a1 + 1344);
  if ( v2 )
    sub_14000AB20(v2);
  v3 = *(void **)(v1 + 1352);
  if ( v3 )
    sub_14000AB20(v3);
}

//----- (000000014001BACC) ----------------------------------------------------
__int64 __fastcall sub_14001BACC(__int64 a1, __int64 a2, int a3, _OWORD *a4)
{
  __int64 v4; // r12
  signed int v5; // ebx
  UNICODE_STRING *v6; // rax
  UNICODE_STRING *v7; // r15
  bool v8; // r13
  _DWORD *v9; // rax
  _DWORD *v10; // r14
  UNICODE_STRING *v11; // rsi
  bool v12; // di
  bool v14; // [rsp+40h] [rbp-30h]
  __int64 v15; // [rsp+48h] [rbp-28h]
  __int64 v16; // [rsp+50h] [rbp-20h]
  __int64 v17; // [rsp+58h] [rbp-18h]
  char v18; // [rsp+60h] [rbp-10h]
  __int64 v19; // [rsp+B0h] [rbp+40h]
  int v20; // [rsp+C0h] [rbp+50h]
  _OWORD *v21; // [rsp+C8h] [rbp+58h]

  v21 = a4;
  v20 = a3;
  v19 = a1;
  v15 = 0i64;
  v4 = a2;
  v5 = FltGetVolumeFromInstance(a2, &v15);
  if ( v5 >= 0 )
  {
    v6 = (UNICODE_STRING *)sub_14001BE0C(v15);
    v7 = v6;
    v8 = v6 != 0i64;
    v9 = sub_14001BE94(v15);
    v10 = v9;
    v14 = v9 != 0i64;
    if ( v7 && v9 )
    {
      v11 = (UNICODE_STRING *)sub_14001BCA8(v15);
      v12 = v11 != 0i64;
      if ( !v11 && *v10 != 20 )
      {
        v11 = sub_14001BD8C(v7);
        if ( v11 )
        {
          if ( v12 )
            sub_14000AB20(0i64);
          v12 = v11 != 0i64;
        }
      }
      v17 = 0i64;
      FltQueryVolumeInformation(v4, &v18, &v17, 8i64, 4);
      v5 = FltAllocateContext(v19, 2i64, 1368i64, PoolType, &v16);
      if ( v5 >= 0 )
      {
        v12 = 0;
        v8 = 0;
        sub_14001B7C4(v16, v7, v11, (__int64)v10, (__int64)&v17, v20, v21);
        v5 = FltSetInstanceContext(v4, 1i64, v16);
        FltReleaseContext(v16);
        if ( v5 >= 0 )
          v5 = 0;
      }
      if ( v12 )
        sub_14000AB20(v11);
    }
    else
    {
      v5 = -1073741823;
    }
    if ( v14 )
      sub_14000AB20(v10);
    if ( v8 )
      sub_14000AB20(v7);
  }
  if ( v15 )
    FltObjectDereference();
  return (unsigned int)v5;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 140021652: using guessed type __int64 __fastcall FltAllocateContext(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 14002165E: using guessed type __int64 __fastcall FltSetInstanceContext(_QWORD, _QWORD, _QWORD);
// 140021676: using guessed type __int64 __fastcall FltGetVolumeFromInstance(_QWORD, _QWORD);
// 14002169A: using guessed type __int64 __fastcall FltQueryVolumeInformation(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400216A6: using guessed type __int64 FltObjectDereference(void);

//----- (000000014001BCA8) ----------------------------------------------------
__m128i *__fastcall sub_14001BCA8(__int64 a1)
{
  __int64 v1; // rdi
  __m128i *v2; // rax
  __m128i *v3; // rbx
  __m128i *result; // rax
  int v5; // [rsp+20h] [rbp-40h]
  __int64 v6; // [rsp+28h] [rbp-38h]
  __int128 v7; // [rsp+30h] [rbp-30h]
  __m128i v8; // [rsp+40h] [rbp-20h]
  char v9; // [rsp+50h] [rbp-10h]
  unsigned int v10; // [rsp+78h] [rbp+18h]

  v5 = 0;
  v6 = 0i64;
  v1 = a1;
  if ( (unsigned int)FltGetVolumeGuidName(a1, &v5, &v10) != -1073741789 )
    return 0i64;
  v2 = (__m128i *)sub_14000AB04(v10 + 16i64, PagedPool);
  v3 = v2;
  if ( !v2 )
    return 0i64;
  LOWORD(v2->m128i_i64[0]) = 0;
  WORD1(v2->m128i_i64[0]) = v10;
  v2->m128i_i64[1] = (__int64)v2[1].m128i_i64;
  if ( (signed int)FltGetVolumeGuidName(v1, v2, 0i64) < 0 )
  {
    sub_14000AB20(v3);
    return 0i64;
  }
  _mm_storeu_si128((__m128i *)&v7, *v3);
  FsRtlDissectName(&v7, &v9, &v8);
  result = v3;
  _mm_storeu_si128(v3, v8);
  return result;
}
// 14002168E: using guessed type __int64 __fastcall FltGetVolumeGuidName(_QWORD, _QWORD, _QWORD);
// 140028258: using guessed type __int64 __fastcall FsRtlDissectName(_QWORD, _QWORD, _QWORD);

//----- (000000014001BD68) ----------------------------------------------------
__int64 __fastcall sub_14001BD68(__int64 a1)
{
  int v1; // eax
  __int64 v2; // rcx
  __int64 v4; // [rsp+38h] [rbp+10h]

  v1 = FltGetInstanceContext(a1, &v4);
  v2 = v4;
  if ( v1 < 0 )
    v2 = 0i64;
  return v2;
}
// 14002166A: using guessed type __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD);

//----- (000000014001BD8C) ----------------------------------------------------
UNICODE_STRING *__fastcall sub_14001BD8C(PCUNICODE_STRING Source)
{
  PCUNICODE_STRING v1; // rdi
  UNICODE_STRING *v2; // rbx
  UNICODE_STRING *result; // rax

  v1 = Source;
  v2 = (UNICODE_STRING *)sub_14000AB04(stru_14002B610.Length + (unsigned int)Source->Length + 16i64, PagedPool);
  result = 0i64;
  if ( v2 )
  {
    v2->Length = 0;
    v2->MaximumLength = stru_14002B610.Length + v1->Length;
    v2->Buffer = &v2[1].Length;
    RtlCopyUnicodeString(v2, &stru_14002B610);
    RtlAppendUnicodeStringToString(v2, v1);
    result = v2;
  }
  return result;
}

//----- (000000014001BE0C) ----------------------------------------------------
void *__fastcall sub_14001BE0C(__int64 a1)
{
  __int64 v1; // rdi
  char *v2; // rax
  void *v3; // rbx
  unsigned int v5; // [rsp+38h] [rbp+10h]

  v1 = a1;
  if ( (unsigned int)FltGetVolumeName(a1, 0i64, &v5) != -1073741789 )
    return 0i64;
  v2 = (char *)sub_14000AB04(v5 + 16i64, PagedPool);
  v3 = v2;
  if ( !v2 )
    return 0i64;
  *(_WORD *)v2 = 0;
  *((_WORD *)v2 + 1) = v5;
  *((_QWORD *)v2 + 1) = v2 + 16;
  if ( (signed int)FltGetVolumeName(v1, v2, 0i64) < 0 )
  {
    sub_14000AB20(v3);
    return 0i64;
  }
  return v3;
}
// 140021646: using guessed type __int64 __fastcall FltGetVolumeName(_QWORD, _QWORD, _QWORD);

//----- (000000014001BE94) ----------------------------------------------------
void *__fastcall sub_14001BE94(__int64 a1)
{
  __int64 v1; // rdi
  PVOID v2; // rax
  void *v3; // rbx
  unsigned int v5; // [rsp+38h] [rbp+10h]

  v1 = a1;
  if ( (unsigned int)FltGetVolumeProperties(a1, 0i64, 0i64, &v5) != -1073741789 )
    return 0i64;
  v2 = sub_14000AB04(v5, PagedPool);
  v3 = v2;
  if ( !v2 )
    return 0i64;
  if ( (signed int)FltGetVolumeProperties(v1, v2, v5, &v5) < 0 )
  {
    sub_14000AB20(v3);
    return 0i64;
  }
  return v3;
}
// 140021682: using guessed type __int64 __fastcall FltGetVolumeProperties(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014001BF00) ----------------------------------------------------
bool __fastcall sub_14001BF00(__int64 a1)
{
  __int64 v1; // rax
  bool v2; // bl

  v1 = sub_14001BD68(a1);
  v2 = 0;
  if ( v1 )
  {
    v2 = *(_DWORD *)(v1 + 1360) == 27;
    FltReleaseContext(v1);
  }
  return v2;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);

//----- (000000014001BF38) ----------------------------------------------------
__int64 __fastcall sub_14001BF38(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rbx

  *(_QWORD *)(a1 + 8) = 0i64;
  v5 = a4;
  *(_QWORD *)(a1 + 16) = 0i64;
  v6 = a3;
  *(_QWORD *)(a1 + 24) = 0i64;
  v7 = a1;
  *(_BYTE *)a1 = 0;
  if ( a2 & dword_140035180 && !sub_1400192EC() && !sub_14000747C(__readgsqword(0x188u)) )
  {
    *(_QWORD *)(v7 + 24) = a5;
    *(_BYTE *)v7 = 1;
    *(_QWORD *)(v7 + 8) = v6;
    *(_QWORD *)(v7 + 16) = v5;
  }
  return v7;
}
// 140035180: using guessed type int dword_140035180;

//----- (000000014001BFAC) ----------------------------------------------------
int __fastcall sub_14001BFAC(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rdx

  v1 = *(_QWORD *)(a1 + 8);
  if ( v1 )
  {
    v2 = *(_QWORD *)(a1 + 16);
    if ( v2 )
    {
      if ( *(_BYTE *)a1 )
        LODWORD(v1) = sub_140007A38(*(_QWORD *)(a1 + 8), v2, *(_QWORD *)(a1 + 24), *(unsigned int *)(v2 + 24));
    }
  }
  return v1;
}

//----- (000000014001BFDC) ----------------------------------------------------
void __fastcall sub_14001BFDC(_BYTE *a1)
{
  *a1 = 0;
}

//----- (000000014001BFE0) ----------------------------------------------------
int __fastcall sub_14001BFE0(__int64 a1)
{
  __int64 v1; // rax

  v1 = *(_QWORD *)(a1 + 8);
  *(_BYTE *)a1 = 0;
  if ( v1 )
    LODWORD(v1) = sub_140007A38(v1, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), 0xFFFFFFFFi64);
  return v1;
}

//----- (000000014001C010) ----------------------------------------------------
signed __int64 __fastcall sub_14001C010(char a1)
{
  int v1; // eax
  int v2; // ebx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]

  if ( a1 & 1 )
  {
    v1 = sub_14001F530();
    v2 = v1;
    if ( byte_140038480 )
    {
      LODWORD(BugCheckParameter3) = v1;
      sub_140006BB4(0x3E8ui64, 0x96ui64, 0i64, 0xE03D0061, BugCheckParameter3, 0);
    }
  }
  else
  {
    if ( byte_140038480 && (unsigned int)sub_1400206B0() == 1 )
      return 3223060496i64;
    v2 = sub_14001F530();
  }
  if ( v2 < 0 )
    return 3223060496i64;
  return 0i64;
}
// 140038480: using guessed type char byte_140038480;

//----- (000000014001C080) ----------------------------------------------------
__int64 __fastcall sub_14001C080(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 v3; // rbx
  unsigned int v4; // edi
  __int64 (**v5)(void); // rcx
  unsigned int v6; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]
  __int64 (**v9)(void); // [rsp+68h] [rbp+20h]

  v2 = *(_QWORD *)(a2 + 24);
  v3 = a2;
  v4 = 1;
  if ( v2 )
  {
    if ( (signed int)FltGetInstanceContext(v2, &v9) >= 0 )
    {
      v5 = v9;
      if ( v9 && *v9 )
      {
        v6 = sub_140021A40(*v9);
        v5 = v9;
        v4 = v6;
      }
      FltReleaseContext(v5);
    }
    else
    {
      LODWORD(BugCheckParameter3) = -1073741823;
      sub_140006BB4(0x3E8ui64, 0x17Fui64, 0i64, 0xE03D0042, BugCheckParameter3, *(unsigned __int64 *)(v3 + 32) + 88);
    }
  }
  return v4;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002166A: using guessed type __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD);

//----- (000000014001C140) ----------------------------------------------------
__int64 __fastcall sub_14001C140(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4)
{
  __int64 v4; // rsi
  __int64 result; // rax
  __int64 v6; // rcx
  unsigned int v7; // ebx
  __int64 v8; // rcx
  __int64 (*v9)(void); // rax
  unsigned int v10; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-38h]
  __int64 v12; // [rsp+40h] [rbp-18h]

  v4 = a2;
  if ( a4 & 1 )
  {
    if ( a3 )
      sub_140021A40(**a3);
    result = 0i64;
  }
  else
  {
    v6 = *(_QWORD *)(a2 + 24);
    v7 = 0;
    if ( v6 )
    {
      if ( (signed int)FltGetInstanceContext(v6, &v12) >= 0 )
      {
        v8 = v12;
        if ( v12 )
        {
          v9 = *(__int64 (**)(void))(v12 + 8);
          if ( v9 )
          {
            v10 = sub_140021A40(v9);
            v8 = v12;
            v7 = v10;
          }
        }
        FltReleaseContext(v8);
      }
      else
      {
        LODWORD(BugCheckParameter3) = -1073741823;
        sub_140006BB4(0x3E8ui64, 0x17Fui64, 0i64, 0xE03D0042, BugCheckParameter3, *(_BYTE *)(v4 + 32) + 88);
      }
    }
    result = v7;
  }
  return result;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002166A: using guessed type __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD);

//----- (000000014001C230) ----------------------------------------------------
__int64 __fastcall sub_14001C230(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 v3; // rbx
  unsigned int v4; // edi
  __int64 v5; // rcx
  __int64 (*v6)(void); // rax
  unsigned int v7; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]
  __int64 v10; // [rsp+68h] [rbp+20h]

  v2 = *(_QWORD *)(a2 + 24);
  v3 = a2;
  v4 = 1;
  if ( v2 )
  {
    if ( (signed int)FltGetInstanceContext(v2, &v10) >= 0 )
    {
      v5 = v10;
      if ( v10 )
      {
        v6 = *(__int64 (**)(void))(v10 + 16);
        if ( v6 )
        {
          v7 = sub_140021A40(v6);
          v5 = v10;
          v4 = v7;
        }
      }
      FltReleaseContext(v5);
    }
    else
    {
      LODWORD(BugCheckParameter3) = -1073741823;
      sub_140006BB4(0x3E8ui64, 0x17Fui64, 0i64, 0xE03D0042, BugCheckParameter3, *(unsigned __int64 *)(v3 + 32) + 88);
    }
  }
  return v4;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002166A: using guessed type __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD);

//----- (000000014001C2F0) ----------------------------------------------------
__int64 __fastcall sub_14001C2F0(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4)
{
  __int64 (__fastcall *BugCheckParameter3)(__int64, __int64, __int64 (***)(void), char); // [rsp+20h] [rbp-18h]
  unsigned int v6; // [rsp+58h] [rbp+20h]

  if ( a4 & 1 )
  {
    if ( a3 )
      sub_140021A40(**a3);
  }
  else
  {
    BugCheckParameter3 = sub_14001CF30;
    if ( (unsigned __int8)FltDoCompletionProcessingWhenSafe(a1, a2) )
      return v6;
    LODWORD(BugCheckParameter3) = -1073741823;
    sub_140006BB4(0x3E8ui64, 0x224ui64, 0i64, 0xE03D0040, (ULONG_PTR)BugCheckParameter3, 0);
  }
  return 0i64;
}
// 1400216B2: using guessed type __int64 __cdecl FltDoCompletionProcessingWhenSafe(_QWORD, _QWORD);

//----- (000000014001C370) ----------------------------------------------------
__int64 __fastcall sub_14001C370(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 v3; // rbx
  unsigned int v4; // edi
  __int64 v5; // rcx
  __int64 (*v6)(void); // rax
  unsigned int v7; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]
  __int64 v10; // [rsp+68h] [rbp+20h]

  v2 = *(_QWORD *)(a2 + 24);
  v3 = a2;
  v4 = 1;
  if ( v2 )
  {
    if ( (signed int)FltGetInstanceContext(v2, &v10) >= 0 )
    {
      v5 = v10;
      if ( v10 )
      {
        v6 = *(__int64 (**)(void))(v10 + 32);
        if ( v6 )
        {
          v7 = sub_140021A40(v6);
          v5 = v10;
          v4 = v7;
        }
      }
      FltReleaseContext(v5);
    }
    else
    {
      LODWORD(BugCheckParameter3) = -1073741823;
      sub_140006BB4(0x3E8ui64, 0x17Fui64, 0i64, 0xE03D0042, BugCheckParameter3, *(unsigned __int64 *)(v3 + 32) + 88);
    }
  }
  return v4;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002166A: using guessed type __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD);

//----- (000000014001C430) ----------------------------------------------------
__int64 __fastcall sub_14001C430(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4)
{
  __int64 (__fastcall *BugCheckParameter3)(__int64, __int64, __int64 (***)(void), char); // [rsp+20h] [rbp-18h]
  unsigned int v6; // [rsp+58h] [rbp+20h]

  if ( a4 & 1 )
  {
    if ( a3 )
      sub_140021A40(**a3);
  }
  else
  {
    BugCheckParameter3 = sub_14001D020;
    if ( (unsigned __int8)FltDoCompletionProcessingWhenSafe(a1, a2) )
      return v6;
    LODWORD(BugCheckParameter3) = -1073741823;
    sub_140006BB4(0x3E8ui64, 0x261ui64, 0i64, 0xE03D0040, (ULONG_PTR)BugCheckParameter3, 0);
  }
  return 0i64;
}
// 1400216B2: using guessed type __int64 __cdecl FltDoCompletionProcessingWhenSafe(_QWORD, _QWORD);

//----- (000000014001C4B0) ----------------------------------------------------
__int64 __fastcall sub_14001C4B0(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 v3; // rbx
  unsigned int v4; // edi
  __int64 v5; // rcx
  __int64 (*v6)(void); // rax
  unsigned int v7; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]
  __int64 v10; // [rsp+68h] [rbp+20h]

  v2 = *(_QWORD *)(a2 + 24);
  v3 = a2;
  v4 = 1;
  if ( v2 )
  {
    if ( (signed int)FltGetInstanceContext(v2, &v10) >= 0 )
    {
      v5 = v10;
      if ( v10 )
      {
        v6 = *(__int64 (**)(void))(v10 + 48);
        if ( v6 )
        {
          v7 = sub_140021A40(v6);
          v5 = v10;
          v4 = v7;
        }
      }
      FltReleaseContext(v5);
    }
    else
    {
      LODWORD(BugCheckParameter3) = -1073741823;
      sub_140006BB4(0x3E8ui64, 0x17Fui64, 0i64, 0xE03D0042, BugCheckParameter3, *(unsigned __int64 *)(v3 + 32) + 88);
    }
  }
  return v4;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002166A: using guessed type __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD);

//----- (000000014001C570) ----------------------------------------------------
__int64 __fastcall sub_14001C570(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4)
{
  __int64 (__fastcall *BugCheckParameter3)(__int64, __int64, __int64 (***)(void), char); // [rsp+20h] [rbp-18h]
  unsigned int v6; // [rsp+58h] [rbp+20h]

  if ( a4 & 1 )
  {
    if ( a3 )
      sub_140021A40(**a3);
  }
  else
  {
    BugCheckParameter3 = sub_14001D110;
    if ( (unsigned __int8)FltDoCompletionProcessingWhenSafe(a1, a2) )
      return v6;
    LODWORD(BugCheckParameter3) = -1073741823;
    sub_140006BB4(0x3E8ui64, 0x335ui64, 0i64, 0xE03D0040, (ULONG_PTR)BugCheckParameter3, 0);
  }
  return 0i64;
}
// 1400216B2: using guessed type __int64 __cdecl FltDoCompletionProcessingWhenSafe(_QWORD, _QWORD);

//----- (000000014001C5F0) ----------------------------------------------------
__int64 __fastcall sub_14001C5F0(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 v3; // rbx
  unsigned int v4; // edi
  __int64 v5; // rcx
  __int64 (*v6)(void); // rax
  unsigned int v7; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]
  __int64 v10; // [rsp+68h] [rbp+20h]

  v2 = *(_QWORD *)(a2 + 24);
  v3 = a2;
  v4 = 1;
  if ( v2 )
  {
    if ( (signed int)FltGetInstanceContext(v2, &v10) >= 0 )
    {
      v5 = v10;
      if ( v10 )
      {
        v6 = *(__int64 (**)(void))(v10 + 64);
        if ( v6 )
        {
          v7 = sub_140021A40(v6);
          v5 = v10;
          v4 = v7;
        }
      }
      FltReleaseContext(v5);
    }
    else
    {
      LODWORD(BugCheckParameter3) = -1073741823;
      sub_140006BB4(0x3E8ui64, 0x17Fui64, 0i64, 0xE03D0042, BugCheckParameter3, *(unsigned __int64 *)(v3 + 32) + 88);
    }
  }
  return v4;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002166A: using guessed type __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD);

//----- (000000014001C6B0) ----------------------------------------------------
__int64 __fastcall sub_14001C6B0(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4)
{
  __int64 (__fastcall *BugCheckParameter3)(__int64, __int64, __int64 (***)(void), char); // [rsp+20h] [rbp-18h]
  unsigned int v6; // [rsp+58h] [rbp+20h]

  if ( a4 & 1 )
  {
    if ( a3 )
      sub_140021A40(**a3);
  }
  else
  {
    BugCheckParameter3 = sub_14001D2F0;
    if ( (unsigned __int8)FltDoCompletionProcessingWhenSafe(a1, a2) )
      return v6;
    LODWORD(BugCheckParameter3) = -1073741823;
    sub_140006BB4(0x3E8ui64, 0x397ui64, 0i64, 0xE03D0040, (ULONG_PTR)BugCheckParameter3, 0);
  }
  return 0i64;
}
// 1400216B2: using guessed type __int64 __cdecl FltDoCompletionProcessingWhenSafe(_QWORD, _QWORD);

//----- (000000014001C730) ----------------------------------------------------
__int64 __fastcall sub_14001C730(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 v3; // rbx
  unsigned int v4; // edi
  __int64 v5; // rcx
  __int64 (*v6)(void); // rax
  unsigned int v7; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]
  __int64 v10; // [rsp+68h] [rbp+20h]

  v2 = *(_QWORD *)(a2 + 24);
  v3 = a2;
  v4 = 1;
  if ( v2 )
  {
    if ( (signed int)FltGetInstanceContext(v2, &v10) >= 0 )
    {
      v5 = v10;
      if ( v10 )
      {
        v6 = *(__int64 (**)(void))(v10 + 80);
        if ( v6 )
        {
          v7 = sub_140021A40(v6);
          v5 = v10;
          v4 = v7;
        }
      }
      FltReleaseContext(v5);
    }
    else
    {
      LODWORD(BugCheckParameter3) = -1073741823;
      sub_140006BB4(0x3E8ui64, 0x17Fui64, 0i64, 0xE03D0042, BugCheckParameter3, *(unsigned __int64 *)(v3 + 32) + 88);
    }
  }
  return v4;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002166A: using guessed type __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD);

//----- (000000014001C7F0) ----------------------------------------------------
__int64 __fastcall sub_14001C7F0(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4)
{
  __int64 (__fastcall *BugCheckParameter3)(__int64, __int64, __int64 (***)(void), char); // [rsp+20h] [rbp-18h]
  unsigned int v6; // [rsp+58h] [rbp+20h]

  if ( a4 & 1 )
  {
    if ( a3 )
      sub_140021A40(**a3);
  }
  else
  {
    BugCheckParameter3 = sub_14001D200;
    if ( (unsigned __int8)FltDoCompletionProcessingWhenSafe(a1, a2) )
      return v6;
    LODWORD(BugCheckParameter3) = -1073741823;
    sub_140006BB4(0x3E8ui64, 0x454ui64, 0i64, 0xE03D0040, (ULONG_PTR)BugCheckParameter3, 0);
  }
  return 0i64;
}
// 1400216B2: using guessed type __int64 __cdecl FltDoCompletionProcessingWhenSafe(_QWORD, _QWORD);

//----- (000000014001C870) ----------------------------------------------------
__int64 __fastcall sub_14001C870(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 v3; // rbx
  unsigned int v4; // edi
  __int64 v5; // rcx
  __int64 (*v6)(void); // rax
  unsigned int v7; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]
  __int64 v10; // [rsp+68h] [rbp+20h]

  v2 = *(_QWORD *)(a2 + 24);
  v3 = a2;
  v4 = 1;
  if ( v2 )
  {
    if ( (signed int)FltGetInstanceContext(v2, &v10) >= 0 )
    {
      v5 = v10;
      if ( v10 )
      {
        v6 = *(__int64 (**)(void))(v10 + 96);
        if ( v6 )
        {
          v7 = sub_140021A40(v6);
          v5 = v10;
          v4 = v7;
        }
      }
      FltReleaseContext(v5);
    }
    else
    {
      LODWORD(BugCheckParameter3) = -1073741823;
      sub_140006BB4(0x3E8ui64, 0x17Fui64, 0i64, 0xE03D0042, BugCheckParameter3, *(unsigned __int64 *)(v3 + 32) + 88);
    }
  }
  return v4;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002166A: using guessed type __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD);

//----- (000000014001C930) ----------------------------------------------------
__int64 __fastcall sub_14001C930(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4)
{
  __int64 v4; // rsi
  __int64 result; // rax
  __int64 v6; // rcx
  unsigned int v7; // ebx
  __int64 v8; // rcx
  __int64 (*v9)(void); // rax
  unsigned int v10; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-38h]
  __int64 v12; // [rsp+40h] [rbp-18h]

  v4 = a2;
  if ( a4 & 1 )
  {
    if ( a3 )
      sub_140021A40(**a3);
    result = 0i64;
  }
  else
  {
    v6 = *(_QWORD *)(a2 + 24);
    v7 = 0;
    if ( v6 )
    {
      if ( (signed int)FltGetInstanceContext(v6, &v12) >= 0 )
      {
        v8 = v12;
        if ( v12 )
        {
          v9 = *(__int64 (**)(void))(v12 + 104);
          if ( v9 )
          {
            v10 = sub_140021A40(v9);
            v8 = v12;
            v7 = v10;
          }
        }
        FltReleaseContext(v8);
      }
      else
      {
        LODWORD(BugCheckParameter3) = -1073741823;
        sub_140006BB4(0x3E8ui64, 0x17Fui64, 0i64, 0xE03D0042, BugCheckParameter3, *(_BYTE *)(v4 + 32) + 88);
      }
    }
    result = v7;
  }
  return result;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002166A: using guessed type __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD);

//----- (000000014001CA20) ----------------------------------------------------
__int64 __fastcall sub_14001CA20(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 v4; // rdi
  __int64 v6; // rcx
  unsigned int v7; // ebx
  __int64 v8; // rcx
  __int64 (*v9)(void); // rax
  unsigned int v10; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-38h]
  __int64 v12; // [rsp+40h] [rbp-18h]

  v4 = a2;
  if ( a4 & 1 )
    return 0i64;
  v6 = *(_QWORD *)(a2 + 24);
  v7 = 0;
  if ( v6 )
  {
    if ( (signed int)FltGetInstanceContext(v6, &v12) >= 0 )
    {
      v8 = v12;
      if ( v12 )
      {
        v9 = *(__int64 (**)(void))(v12 + 112);
        if ( v9 )
        {
          v10 = sub_140021A40(v9);
          v8 = v12;
          v7 = v10;
        }
      }
      FltReleaseContext(v8);
    }
    else
    {
      LODWORD(BugCheckParameter3) = -1073741823;
      sub_140006BB4(0x3E8ui64, 0x17Fui64, 0i64, 0xE03D0042, BugCheckParameter3, *(_BYTE *)(v4 + 32) + 88);
    }
  }
  return v7;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002166A: using guessed type __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD);

//----- (000000014001CAE0) ----------------------------------------------------
__int64 __fastcall sub_14001CAE0(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 v3; // rbx
  unsigned int v4; // edi
  __int64 v5; // rcx
  __int64 (*v6)(void); // rax
  unsigned int v7; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]
  __int64 v10; // [rsp+68h] [rbp+20h]

  v2 = *(_QWORD *)(a2 + 24);
  v3 = a2;
  v4 = 1;
  if ( v2 )
  {
    if ( (signed int)FltGetInstanceContext(v2, &v10) >= 0 )
    {
      v5 = v10;
      if ( v10 )
      {
        v6 = *(__int64 (**)(void))(v10 + 120);
        if ( v6 )
        {
          v7 = sub_140021A40(v6);
          v5 = v10;
          v4 = v7;
        }
      }
      FltReleaseContext(v5);
    }
    else
    {
      LODWORD(BugCheckParameter3) = -1073741823;
      sub_140006BB4(0x3E8ui64, 0x17Fui64, 0i64, 0xE03D0042, BugCheckParameter3, *(unsigned __int64 *)(v3 + 32) + 88);
    }
  }
  return v4;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002166A: using guessed type __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD);

//----- (000000014001CBA0) ----------------------------------------------------
__int64 __fastcall sub_14001CBA0(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 (__fastcall *BugCheckParameter3)(__int64, __int64, __int64, char); // [rsp+20h] [rbp-18h]
  unsigned int v6; // [rsp+58h] [rbp+20h]

  if ( !(a4 & 1) )
  {
    BugCheckParameter3 = sub_14001D3E0;
    if ( (unsigned __int8)FltDoCompletionProcessingWhenSafe(a1, a2) )
      return v6;
    LODWORD(BugCheckParameter3) = -1073741823;
    sub_140006BB4(0x3E8ui64, 0x2C0ui64, 0i64, 0xE03D0040, (ULONG_PTR)BugCheckParameter3, 0);
  }
  return 0i64;
}
// 1400216B2: using guessed type __int64 __cdecl FltDoCompletionProcessingWhenSafe(_QWORD, _QWORD);

//----- (000000014001CC00) ----------------------------------------------------
__int64 __fastcall sub_14001CC00(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rcx
  unsigned int v4; // edi
  __int64 v5; // rcx
  __int64 (*v6)(void); // rax
  unsigned int v7; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-28h]
  __int64 v10; // [rsp+68h] [rbp+20h]

  v2 = a2;
  v3 = *(_QWORD *)(a2 + 24);
  v4 = 1;
  if ( v3 )
  {
    if ( (signed int)FltGetInstanceContext(v3, &v10) >= 0 )
    {
      v5 = v10;
      if ( v10 )
      {
        v6 = *(__int64 (**)(void))(v10 + 136);
        if ( v6 )
        {
          v7 = sub_140021A40(v6);
          v5 = v10;
          v4 = v7;
        }
      }
      FltReleaseContext(v5);
    }
    else
    {
      LODWORD(BugCheckParameter3) = -1073741823;
      sub_140006BB4(0x3E8ui64, 0x17Fui64, 0i64, 0xE03D0042, BugCheckParameter3, *(unsigned __int64 *)(v2 + 32) + 88);
    }
  }
  return v4;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002166A: using guessed type __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD);

//----- (000000014001CCB0) ----------------------------------------------------
signed __int64 __fastcall sub_14001CCB0(__int64 a1, __int64 a2, _QWORD *a3)
{
  _QWORD *v3; // rdi
  __int64 v4; // rbx
  __int64 v6; // [rsp+38h] [rbp+10h]

  v3 = a3;
  v4 = a2;
  DbgPrint("PreMountVolume called\n");
  if ( (signed int)FltGetDiskDeviceObject(*(_QWORD *)(v4 + 16), &v6) < 0 )
    return 1i64;
  *v3 = v6;
  return 0i64;
}
// 140021616: using guessed type __int64 __fastcall FltGetDiskDeviceObject(_QWORD, _QWORD);

//----- (000000014001CD00) ----------------------------------------------------
__int64 __fastcall sub_14001CD00(__int64 a1, __int64 a2, void *a3)
{
  __int64 v3; // rbx
  void *v4; // rdi

  v3 = a1;
  v4 = a3;
  DbgPrint("PostMountVolume called\n");
  if ( *(_DWORD *)(v3 + 24) == -1073741489 )
    sub_140007FA0((__int64)v4);
  ObfDereferenceObject(v4);
  return 0i64;
}

//----- (000000014001CD50) ----------------------------------------------------
signed __int64 __fastcall sub_14001CD50(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v4; // edi
  __int64 v5; // rbx
  int v6; // edi
  __int64 v7; // rcx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-E0h]
  char v10[8]; // [rsp+40h] [rbp-C0h]
  char *v11; // [rsp+48h] [rbp-B8h]
  char v12; // [rsp+50h] [rbp-B0h]
  UNICODE_STRING String1; // [rsp+58h] [rbp-A8h]
  char v14; // [rsp+70h] [rbp-90h]
  char v15[4]; // [rsp+F0h] [rbp-10h]
  USHORT v16; // [rsp+F4h] [rbp-Ch]
  unsigned __int16 v17; // [rsp+F6h] [rbp-Ah]

  v4 = a4;
  v5 = a1;
  if ( a4 == 2 && sub_140011ADC(*(_QWORD *)(a1 + 16)) )
    return 3223060495i64;
  if ( (signed int)FltGetInstanceInformation(*(_QWORD *)(v5 + 24), 0i64, v15, 512i64, &v12) < 0 )
    return 3223060495i64;
  *(_QWORD *)v10 = 0i64;
  String1.Buffer = (PWSTR)&v15[v17];
  String1.MaximumLength = v16;
  String1.Length = v16;
  if ( !sub_14001CEA8(&String1, v10) || !*(_QWORD *)v10 )
    return 3223060495i64;
  v6 = sub_14001BACC(qword_140038478, *(_QWORD *)(v5 + 24), v4, *(_OWORD **)v10);
  if ( v6 < 0 )
  {
    v7 = *(_QWORD *)(v5 + 16);
    v11 = &v14;
    *(_DWORD *)v10 = 0x800000;
    if ( (signed int)FltGetVolumeName(v7, v10, 0i64) < 0 )
      *(_WORD *)v10 = 0;
    LODWORD(BugCheckParameter3) = v6;
    sub_140006BB4(0x3E8ui64, 0x15Cui64, 0i64, 0xE03D0041, BugCheckParameter3, (unsigned __int64)v10);
    return 3223060495i64;
  }
  return 0i64;
}
// 140021646: using guessed type __int64 __fastcall FltGetVolumeName(_QWORD, _QWORD, _QWORD);
// 1400216E2: using guessed type __int64 __fastcall FltGetInstanceInformation(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140038478: using guessed type __int64 qword_140038478;
// 14001CD50: using guessed type char var_220[4];

//----- (000000014001CE9C) ----------------------------------------------------
void **__fastcall sub_14001CE9C(_QWORD *a1)
{
  void **result; // rax

  result = &off_140028B50;
  *a1 = &off_140028B50;
  return result;
}
// 140028B50: using guessed type void *off_140028B50;

//----- (000000014001CEA8) ----------------------------------------------------
char __fastcall sub_14001CEA8(PCUNICODE_STRING String1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  const UNICODE_STRING *v3; // rdi

  v2 = a2;
  v3 = String1;
  if ( byte_140038470 )
  {
    if ( !RtlCompareUnicodeString(String1, &stru_14002B620, 1u) )
    {
      *v2 = xmmword_140038350;
      return 1;
    }
    if ( byte_140038470 && !RtlCompareUnicodeString(v3, &stru_14002B630, 1u) )
    {
      *v2 = xmmword_1400383E0;
      return 1;
    }
  }
  return 0;
}
// 140038470: using guessed type char byte_140038470;

//----- (000000014001CF30) ----------------------------------------------------
__int64 __fastcall sub_14001CF30(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4)
{
  __int64 v4; // rsi
  __int64 result; // rax
  __int64 v6; // rcx
  unsigned int v7; // ebx
  __int64 v8; // rcx
  __int64 (*v9)(void); // rax
  unsigned int v10; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-38h]
  __int64 v12; // [rsp+40h] [rbp-18h]

  v4 = a2;
  if ( a4 & 1 )
  {
    if ( a3 )
      sub_140021A40(**a3);
    result = 0i64;
  }
  else
  {
    v6 = *(_QWORD *)(a2 + 24);
    v7 = 0;
    if ( v6 )
    {
      if ( (signed int)FltGetInstanceContext(v6, &v12) >= 0 )
      {
        v8 = v12;
        if ( v12 )
        {
          v9 = *(__int64 (**)(void))(v12 + 24);
          if ( v9 )
          {
            v10 = sub_140021A40(v9);
            v8 = v12;
            v7 = v10;
          }
        }
        FltReleaseContext(v8);
      }
      else
      {
        LODWORD(BugCheckParameter3) = -1073741823;
        sub_140006BB4(0x3E8ui64, 0x17Fui64, 0i64, 0xE03D0042, BugCheckParameter3, *(_BYTE *)(v4 + 32) + 88);
      }
    }
    result = v7;
  }
  return result;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002166A: using guessed type __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD);

//----- (000000014001D020) ----------------------------------------------------
__int64 __fastcall sub_14001D020(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4)
{
  __int64 v4; // rsi
  __int64 result; // rax
  __int64 v6; // rcx
  unsigned int v7; // ebx
  __int64 v8; // rcx
  __int64 (*v9)(void); // rax
  unsigned int v10; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-38h]
  __int64 v12; // [rsp+40h] [rbp-18h]

  v4 = a2;
  if ( a4 & 1 )
  {
    if ( a3 )
      sub_140021A40(**a3);
    result = 0i64;
  }
  else
  {
    v6 = *(_QWORD *)(a2 + 24);
    v7 = 0;
    if ( v6 )
    {
      if ( (signed int)FltGetInstanceContext(v6, &v12) >= 0 )
      {
        v8 = v12;
        if ( v12 )
        {
          v9 = *(__int64 (**)(void))(v12 + 40);
          if ( v9 )
          {
            v10 = sub_140021A40(v9);
            v8 = v12;
            v7 = v10;
          }
        }
        FltReleaseContext(v8);
      }
      else
      {
        LODWORD(BugCheckParameter3) = -1073741823;
        sub_140006BB4(0x3E8ui64, 0x17Fui64, 0i64, 0xE03D0042, BugCheckParameter3, *(_BYTE *)(v4 + 32) + 88);
      }
    }
    result = v7;
  }
  return result;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002166A: using guessed type __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD);

//----- (000000014001D110) ----------------------------------------------------
__int64 __fastcall sub_14001D110(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4)
{
  __int64 v4; // rsi
  __int64 result; // rax
  __int64 v6; // rcx
  unsigned int v7; // ebx
  __int64 v8; // rcx
  __int64 (*v9)(void); // rax
  unsigned int v10; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-38h]
  __int64 v12; // [rsp+40h] [rbp-18h]

  v4 = a2;
  if ( a4 & 1 )
  {
    if ( a3 )
      sub_140021A40(**a3);
    result = 0i64;
  }
  else
  {
    v6 = *(_QWORD *)(a2 + 24);
    v7 = 0;
    if ( v6 )
    {
      if ( (signed int)FltGetInstanceContext(v6, &v12) >= 0 )
      {
        v8 = v12;
        if ( v12 )
        {
          v9 = *(__int64 (**)(void))(v12 + 56);
          if ( v9 )
          {
            v10 = sub_140021A40(v9);
            v8 = v12;
            v7 = v10;
          }
        }
        FltReleaseContext(v8);
      }
      else
      {
        LODWORD(BugCheckParameter3) = -1073741823;
        sub_140006BB4(0x3E8ui64, 0x17Fui64, 0i64, 0xE03D0042, BugCheckParameter3, *(_BYTE *)(v4 + 32) + 88);
      }
    }
    result = v7;
  }
  return result;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002166A: using guessed type __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD);

//----- (000000014001D200) ----------------------------------------------------
__int64 __fastcall sub_14001D200(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4)
{
  __int64 v4; // rsi
  __int64 result; // rax
  __int64 v6; // rcx
  unsigned int v7; // ebx
  __int64 v8; // rcx
  __int64 (*v9)(void); // rax
  unsigned int v10; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-38h]
  __int64 v12; // [rsp+40h] [rbp-18h]

  v4 = a2;
  if ( a4 & 1 )
  {
    if ( a3 )
      sub_140021A40(**a3);
    result = 0i64;
  }
  else
  {
    v6 = *(_QWORD *)(a2 + 24);
    v7 = 0;
    if ( v6 )
    {
      if ( (signed int)FltGetInstanceContext(v6, &v12) >= 0 )
      {
        v8 = v12;
        if ( v12 )
        {
          v9 = *(__int64 (**)(void))(v12 + 88);
          if ( v9 )
          {
            v10 = sub_140021A40(v9);
            v8 = v12;
            v7 = v10;
          }
        }
        FltReleaseContext(v8);
      }
      else
      {
        LODWORD(BugCheckParameter3) = -1073741823;
        sub_140006BB4(0x3E8ui64, 0x17Fui64, 0i64, 0xE03D0042, BugCheckParameter3, *(_BYTE *)(v4 + 32) + 88);
      }
    }
    result = v7;
  }
  return result;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002166A: using guessed type __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD);

//----- (000000014001D2F0) ----------------------------------------------------
__int64 __fastcall sub_14001D2F0(__int64 a1, __int64 a2, __int64 (***a3)(void), char a4)
{
  __int64 v4; // rsi
  __int64 result; // rax
  __int64 v6; // rcx
  unsigned int v7; // ebx
  __int64 v8; // rcx
  __int64 (*v9)(void); // rax
  unsigned int v10; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-38h]
  __int64 v12; // [rsp+40h] [rbp-18h]

  v4 = a2;
  if ( a4 & 1 )
  {
    if ( a3 )
      sub_140021A40(**a3);
    result = 0i64;
  }
  else
  {
    v6 = *(_QWORD *)(a2 + 24);
    v7 = 0;
    if ( v6 )
    {
      if ( (signed int)FltGetInstanceContext(v6, &v12) >= 0 )
      {
        v8 = v12;
        if ( v12 )
        {
          v9 = *(__int64 (**)(void))(v12 + 72);
          if ( v9 )
          {
            v10 = sub_140021A40(v9);
            v8 = v12;
            v7 = v10;
          }
        }
        FltReleaseContext(v8);
      }
      else
      {
        LODWORD(BugCheckParameter3) = -1073741823;
        sub_140006BB4(0x3E8ui64, 0x17Fui64, 0i64, 0xE03D0042, BugCheckParameter3, *(_BYTE *)(v4 + 32) + 88);
      }
    }
    result = v7;
  }
  return result;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002166A: using guessed type __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD);

//----- (000000014001D3E0) ----------------------------------------------------
__int64 __fastcall sub_14001D3E0(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 v4; // rdi
  __int64 v6; // rcx
  unsigned int v7; // ebx
  __int64 v8; // rcx
  __int64 (*v9)(void); // rax
  unsigned int v10; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-38h]
  __int64 v12; // [rsp+40h] [rbp-18h]

  v4 = a2;
  if ( a4 & 1 )
    return 0i64;
  v6 = *(_QWORD *)(a2 + 24);
  v7 = 0;
  if ( v6 )
  {
    if ( (signed int)FltGetInstanceContext(v6, &v12) >= 0 )
    {
      v8 = v12;
      if ( v12 )
      {
        v9 = *(__int64 (**)(void))(v12 + 128);
        if ( v9 )
        {
          v10 = sub_140021A40(v9);
          v8 = v12;
          v7 = v10;
        }
      }
      FltReleaseContext(v8);
    }
    else
    {
      LODWORD(BugCheckParameter3) = -1073741823;
      sub_140006BB4(0x3E8ui64, 0x17Fui64, 0i64, 0xE03D0042, BugCheckParameter3, *(_BYTE *)(v4 + 32) + 88);
    }
  }
  return v7;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002166A: using guessed type __int64 __fastcall FltGetInstanceContext(_QWORD, _QWORD);

//----- (000000014001D4A0) ----------------------------------------------------
char __fastcall sub_14001D4A0(_OWORD *a1, const UNICODE_STRING *a2)
{
  const UNICODE_STRING *v2; // rdi
  _OWORD *v3; // rbx
  __int128 v4; // xmm1
  _OWORD *v6; // rax
  __int128 v7; // xmm1

  v2 = a2;
  v3 = a1;
  if ( !byte_140038470 || !byte_140038471 )
  {
    if ( !RtlCompareUnicodeString(a2, &stru_14002B620, 1u) && !byte_140038470 )
    {
      xmmword_140038350[0] = *v3;
      xmmword_140038350[1] = v3[1];
      xmmword_140038350[2] = v3[2];
      xmmword_140038350[3] = v3[3];
      xmmword_140038350[4] = v3[4];
      xmmword_140038350[5] = v3[5];
      xmmword_140038350[6] = v3[6];
      xmmword_140038350[7] = v3[7];
      v4 = v3[8];
      byte_140038470 = 1;
      xmmword_140038350[8] = v4;
      return 1;
    }
    if ( !RtlCompareUnicodeString(v2, &stru_14002B630, 1u) && !byte_140038471 )
    {
      xmmword_1400383E0[0] = *v3;
      xmmword_1400383E0[1] = v3[1];
      xmmword_1400383E0[2] = v3[2];
      xmmword_1400383E0[3] = v3[3];
      xmmword_1400383E0[4] = v3[4];
      xmmword_1400383E0[5] = v3[5];
      xmmword_1400383E0[6] = v3[6];
      v6 = &xmmword_1400383E0[8];
      *(v6 - 1) = v3[7];
      v7 = v3[8];
      byte_140038471 = 1;
      *v6 = v7;
      return 1;
    }
  }
  return 0;
}
// 140038470: using guessed type char byte_140038470;
// 140038471: using guessed type char byte_140038471;

//----- (000000014001D5EC) ----------------------------------------------------
__int64 __fastcall sub_14001D5EC(__int64 a1)
{
  __int64 v1; // rbx
  signed int v2; // ebx

  v1 = a1;
  if ( sub_1400206DC() )
  {
    dword_14002B644 |= 1u;
    byte_140038480 = 1;
  }
  v2 = FltRegisterFilter(v1, &unk_14002B640, &qword_140038478);
  if ( v2 >= 0 )
  {
    v2 = FltStartFiltering(qword_140038478);
    if ( v2 >= 0 )
      return 0i64;
    FltUnregisterFilter(qword_140038478);
    qword_140038478 = 0i64;
  }
  return (unsigned int)v2;
}
// 1400216BE: using guessed type __int64 __fastcall FltRegisterFilter(_QWORD, _QWORD, _QWORD);
// 1400216CA: using guessed type __int64 __fastcall FltUnregisterFilter(_QWORD);
// 1400216D6: using guessed type __int64 __fastcall FltStartFiltering(_QWORD);
// 14002B644: using guessed type int dword_14002B644;
// 140038478: using guessed type __int64 qword_140038478;
// 140038480: using guessed type char byte_140038480;

//----- (000000014001D65C) ----------------------------------------------------
__int64 sub_14001D65C()
{
  __int64 result; // rax

  result = FltUnregisterFilter(qword_140038478);
  qword_140038478 = 0i64;
  return result;
}
// 1400216CA: using guessed type __int64 __fastcall FltUnregisterFilter(_QWORD);
// 140038478: using guessed type __int64 qword_140038478;

//----- (000000014001D67C) ----------------------------------------------------
char __fastcall sub_14001D67C(__int64 a1, __int64 a2, _QWORD *a3)
{
  signed __int64 v3; // rbx
  __int64 v4; // rdi
  _QWORD *v5; // r14
  __int64 v6; // rsi
  signed __int64 *v7; // rdx
  char v8; // di
  signed __int64 i; // rcx
  signed __int64 v10; // rax
  signed __int64 v11; // rcx

  v3 = a1 + 4128;
  v4 = a1;
  v5 = a3;
  v6 = a2;
  FltAcquirePushLockShared(a1 + 4128);
  v7 = (signed __int64 *)(v4 + 16i64 * ((unsigned int)v6 % 0x101));
  v8 = 0;
  for ( i = *v7; (signed __int64 *)i != v7; i = *(_QWORD *)i )
  {
    if ( *(_QWORD *)(i + 32) == v6 )
      goto LABEL_6;
  }
  i = 0i64;
LABEL_6:
  v10 = i + 40;
  v11 = -i;
  if ( v10 & -(signed __int64)(v11 != 0) )
  {
    v8 = 1;
    *v5 = *(_QWORD *)((v10 & -(signed __int64)(v11 != 0)) + 0x10);
  }
  FltReleasePushLock(v3);
  return v8;
}
// 14002151A: using guessed type __int64 __fastcall FltAcquirePushLockShared(_QWORD);
// 140021526: using guessed type __int64 __fastcall FltReleasePushLock(_QWORD);

//----- (000000014001D718) ----------------------------------------------------
void __fastcall sub_14001D718(PSLIST_ENTRY ListEntry)
{
  struct _SLIST_ENTRY *v1; // rbx

  if ( ListEntry )
  {
    ++stru_1400394C0.L.TotalFrees;
    v1 = ListEntry;
    if ( ExQueryDepthSList(&stru_1400394C0.L.ListHead) < stru_1400394C0.L.Depth )
    {
      ExpInterlockedPushEntrySList(&stru_1400394C0.L.ListHead, v1);
    }
    else
    {
      ++stru_1400394C0.L.FreeMisses;
      sub_140021A40((__int64 (*)(void))stru_1400394C0.L.Free);
    }
  }
}

//----- (000000014001D77C) ----------------------------------------------------
signed __int64 __fastcall sub_14001D77C(__int64 a1, unsigned __int16 a2)
{
  unsigned __int16 v2; // si
  __int64 v3; // rbx
  PVOID v4; // rdi
  void *v6; // rcx

  v2 = a2;
  v3 = a1;
  v4 = ExAllocatePoolWithTag(PagedPool, a2, 0x53554349u);
  if ( !v4 )
    return 3221225626i64;
  v6 = *(void **)(v3 + 8);
  *(_WORD *)v3 = 0;
  *(_WORD *)(v3 + 2) = v2;
  if ( v6 )
    ExFreePoolWithTag(v6, 0);
  *(_QWORD *)(v3 + 8) = v4;
  return 0i64;
}

//----- (000000014001D7F0) ----------------------------------------------------
__int64 __fastcall sub_14001D7F0(struct _SLIST_ENTRY **a1)
{
  signed __int64 v1; // rbx
  struct _SLIST_ENTRY **v2; // rdi

  v1 = (signed __int64)(a1 + 516);
  v2 = a1;
  FltAcquirePushLockExclusive(a1 + 516);
  sub_14001D828(v2);
  return FltReleasePushLock(v1);
}
// 14002150E: using guessed type __int64 __fastcall FltAcquirePushLockExclusive(_QWORD);
// 140021526: using guessed type __int64 __fastcall FltReleasePushLock(_QWORD);

//----- (000000014001D828) ----------------------------------------------------
_QWORD *__fastcall sub_14001D828(struct _SLIST_ENTRY **a1)
{
  struct _SLIST_ENTRY **v1; // rbp
  unsigned int v2; // esi
  struct _SLIST_ENTRY **v3; // rdi
  PSLIST_ENTRY v4; // rax
  PSLIST_ENTRY v5; // rcx
  struct _SLIST_ENTRY *v6; // rbx
  _QWORD *result; // rax

  v1 = a1;
  v2 = 0;
  v3 = a1;
  do
  {
    while ( 1 )
    {
      v6 = *v3;
      if ( *v3 == (struct _SLIST_ENTRY *)v3 )
        break;
      if ( *((struct _SLIST_ENTRY ***)&v6->Next + 1) != v3 || (v4 = v6->Next, *(&v6->Next->Next + 1) != v6) )
        __fastfail(3u);
      *v3 = v4;
      *((_QWORD *)&v4->Next + 1) = v3;
      v5 = v6[3].Next;
      *((_DWORD *)&v6[2].Next + 2) = 0;
      if ( v5 )
        ExFreePoolWithTag(v5, 0);
      v6[3].Next = 0i64;
      sub_14001D718(v6);
    }
    ++v2;
    v3 += 2;
  }
  while ( v2 < 0x101 );
  result = v1 + 514;
  result[1] = result;
  *result = result;
  return result;
}

//----- (000000014001D8D4) ----------------------------------------------------
__int64 __fastcall sub_14001D8D4(PUNICODE_STRING DestinationString, PCUNICODE_STRING SourceString)
{
  const UNICODE_STRING *v2; // rdi
  PUNICODE_STRING v3; // rbx
  __int64 result; // rax
  PWSTR v5; // rcx

  v2 = SourceString;
  v3 = DestinationString;
  if ( !SourceString )
    return 3221225485i64;
  if ( SourceString->Length )
  {
    result = sub_14001D77C((__int64)DestinationString, SourceString->MaximumLength);
    if ( (signed int)result < 0 )
      return result;
    RtlCopyUnicodeString(v3, v2);
  }
  else
  {
    *(_DWORD *)&DestinationString->Length = 0;
    v5 = DestinationString->Buffer;
    if ( v5 )
      ExFreePoolWithTag(v5, 0);
    v3->Buffer = 0i64;
  }
  return 0i64;
}

//----- (000000014001D94C) ----------------------------------------------------
__int64 __fastcall sub_14001D94C(__int64 a1)
{
  __int64 v1; // rbx
  const wchar_t *v2; // rcx
  bool v3; // al
  int v4; // ecx
  bool v5; // al
  int v6; // ecx
  __int64 v7; // rbx
  UNICODE_STRING SourceString; // [rsp+20h] [rbp-30h]
  UNICODE_STRING DestinationString; // [rsp+30h] [rbp-20h]
  __int64 v11; // [rsp+40h] [rbp-10h]

  *(_QWORD *)&DestinationString.Length = 0i64;
  v1 = a1;
  DestinationString.Buffer = 0i64;
  v11 = 4294967297i64;
  *(_QWORD *)&SourceString.Length = 0i64;
  SourceString.Buffer = 0i64;
  if ( (signed int)sub_14001DBD0(a1, &SourceString) < 0 )
  {
    if ( dword_140035180 & 0x10000 )
      sub_140007A38((__int64)L"CreateExclusionRecordForPid: Unable to get the process image name from the PID.");
    goto LABEL_15;
  }
  if ( (signed int)sub_14001D8D4(&DestinationString, &SourceString) < 0 )
  {
    if ( !(dword_140035180 & 0x10000) )
      goto LABEL_15;
    v2 = L"CreateExclusionRecordForPid: Failed to set the filename in the process exclusion record for PID: %ld.";
    goto LABEL_14;
  }
  v3 = sub_140013A0C(&SourceString.Length);
  v4 = v11;
  if ( v3 )
    v4 = 0;
  LODWORD(v11) = v4;
  v5 = sub_1400139C0(&SourceString.Length);
  v6 = HIDWORD(v11);
  if ( v5 )
    v6 = 0;
  HIDWORD(v11) = v6;
  if ( (signed int)sub_14001DA7C((__int64)&unk_140038490, v1, &DestinationString) < 0 && dword_140035180 & 0x10000 )
  {
    v2 = L"CreateExclusionRecordForPid: Failed to create or update record collection for PID: %ld.";
LABEL_14:
    sub_140007A38((__int64)v2, (unsigned int)v1);
  }
LABEL_15:
  v7 = v11;
  *(_DWORD *)&SourceString.Length = 0;
  if ( SourceString.Buffer )
    ExFreePoolWithTag(SourceString.Buffer, 0);
  SourceString.Buffer = 0i64;
  *(_DWORD *)&DestinationString.Length = 0;
  if ( DestinationString.Buffer )
    ExFreePoolWithTag(DestinationString.Buffer, 0);
  return v7;
}
// 140026B00: using guessed type wchar_t aCreateexclusio[80];
// 140026BA0: using guessed type wchar_t aCreateexclusio_0[102];
// 140026C70: using guessed type wchar_t aCreateexclusio_1[88];
// 140035180: using guessed type int dword_140035180;

//----- (000000014001DA7C) ----------------------------------------------------
__int64 __fastcall sub_14001DA7C(__int64 a1, __int64 a2, const UNICODE_STRING *a3)
{
  signed __int64 v3; // rbx
  __int64 v4; // rsi
  const UNICODE_STRING *v5; // rdi
  __int64 v7; // [rsp+38h] [rbp+10h]

  v7 = a2;
  v3 = a1 + 4128;
  v4 = a1;
  v5 = a3;
  FltAcquirePushLockExclusive(a1 + 4128);
  LODWORD(v5) = sub_14001DFAC(v4, &v7, v5, 0i64);
  FltReleasePushLock(v3);
  return (unsigned int)v5;
}
// 14002150E: using guessed type __int64 __fastcall FltAcquirePushLockExclusive(_QWORD);
// 140021526: using guessed type __int64 __fastcall FltReleasePushLock(_QWORD);

//----- (000000014001DAD4) ----------------------------------------------------
__int64 __fastcall sub_14001DAD4(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 v5; // [rsp+38h] [rbp+10h]

  v5 = a2;
  v2 = a1 + 4128;
  v3 = a1;
  FltAcquirePushLockExclusive(a1 + 4128);
  sub_14001DB14(v3, (PSLIST_ENTRY *)&v5);
  return FltReleasePushLock(v2);
}
// 14002150E: using guessed type __int64 __fastcall FltAcquirePushLockExclusive(_QWORD);
// 140021526: using guessed type __int64 __fastcall FltReleasePushLock(_QWORD);

//----- (000000014001DB14) ----------------------------------------------------
void __fastcall sub_14001DB14(__int64 a1, PSLIST_ENTRY *a2)
{
  struct _SLIST_ENTRY **v2; // r8
  struct _SLIST_ENTRY *v3; // rbx
  PSLIST_ENTRY v4; // rcx
  struct _SLIST_ENTRY **v5; // rdx
  PSLIST_ENTRY v6; // rcx
  struct _SLIST_ENTRY **v7; // rax
  PSLIST_ENTRY v8; // rcx

  v2 = (struct _SLIST_ENTRY **)(a1 + 16i64 * (*(_DWORD *)a2 % 0x101u));
  v3 = *v2;
  if ( *v2 == (struct _SLIST_ENTRY *)v2 )
  {
LABEL_4:
    v3 = 0i64;
  }
  else
  {
    while ( v3[2].Next != *a2 )
    {
      v3 = v3->Next;
      if ( v3 == (struct _SLIST_ENTRY *)v2 )
        goto LABEL_4;
    }
  }
  if ( v3 )
  {
    v4 = v3[1].Next;
    if ( *(&v4->Next + 1) != &v3[1]
      || (v5 = (struct _SLIST_ENTRY **)*((_QWORD *)&v3[1].Next + 1), *v5 != &v3[1])
      || (*v5 = v4, *((_QWORD *)&v4->Next + 1) = v5, v6 = v3->Next, *(&v3->Next->Next + 1) != v3)
      || (v7 = (struct _SLIST_ENTRY **)*((_QWORD *)&v3->Next + 1), *v7 != v3) )
    {
      __fastfail(3u);
    }
    *v7 = v6;
    *((_QWORD *)&v6->Next + 1) = v7;
    v8 = v3[3].Next;
    *((_DWORD *)&v3[2].Next + 2) = 0;
    if ( v8 )
      ExFreePoolWithTag(v8, 0);
    v3[3].Next = 0i64;
    sub_14001D718(v3);
  }
}

//----- (000000014001DBD0) ----------------------------------------------------
signed __int64 __fastcall sub_14001DBD0(__int64 a1, UNICODE_STRING *a2)
{
  UNICODE_STRING *v2; // r14
  __int64 v3; // r15
  __m128i *v5; // rsi
  struct _SLIST_ENTRY *v6; // rbx
  signed int v7; // eax
  signed int v8; // edi
  const wchar_t *v9; // rcx
  PWSTR v10; // rcx
  __int64 v11; // rcx
  const wchar_t *v12; // rcx
  PVOID Object; // [rsp+88h] [rbp-78h]
  PVOID P; // [rsp+90h] [rbp-70h]
  __int64 v15; // [rsp+98h] [rbp-68h]
  int v16; // [rsp+A0h] [rbp-60h]
  __int128 *v17; // [rsp+A8h] [rbp-58h]
  int v18; // [rsp+B0h] [rbp-50h]
  __int64 v19; // [rsp+B8h] [rbp-48h]
  __m128i *v20; // [rsp+C0h] [rbp-40h]
  int v21; // [rsp+C8h] [rbp-38h]
  __int128 v22; // [rsp+D0h] [rbp-30h]
  char v23; // [rsp+E0h] [rbp-20h]
  __int128 v24; // [rsp+F0h] [rbp-10h]
  __int64 v25; // [rsp+100h] [rbp+0h]
  int v26; // [rsp+108h] [rbp+8h]

  v2 = a2;
  v3 = a1;
  if ( !qword_140038478 )
  {
    if ( dword_140035180 & 0x10000 )
      sub_140007A38((__int64)L"GetProcessImageFileNameFromProcessHandle: Filtering has not yet started");
    return 3221225473i64;
  }
  v5 = (__m128i *)ExAllocatePoolWithTag(PagedPool, 0x200ui64, 0x45504349u);
  if ( !v5 )
  {
    if ( dword_140035180 & 0x10000 )
      sub_140007A38((__int64)L"GetProcessImageFileNameFromProcessHandle: Failed to allocate memory.");
    return 3221225626i64;
  }
  v6 = (struct _SLIST_ENTRY *)sub_140007518(__readgsqword(0x188u));
  v7 = sub_14000B388(v3);
  v8 = v7;
  if ( v7 < 0 )
  {
    if ( v7 == -1073741820 )
    {
      ExFreePoolWithTag(v5, 0);
      v5 = (__m128i *)ExAllocatePoolWithTag(PagedPool, 0i64, 0x45504349u);
      if ( !v5 )
      {
        if ( dword_140035180 & 0x10000 )
          sub_140007A38((__int64)L"GetProcessImageFileNameFromProcessHandle: Failed to allocate memory.");
        v8 = -1073741670;
        goto LABEL_43;
      }
      v8 = sub_14000B388(v3);
    }
    if ( v8 < 0 )
    {
      if ( dword_140035180 & 0x10000 )
        sub_140007A38((__int64)L"GetProcessImageFileNameFromProcessHandle: Failed to get the process image file name.");
      ExFreePoolWithTag(v5, 0);
      goto LABEL_43;
    }
  }
  if ( !LOWORD(v5->m128i_i64[0]) )
  {
    if ( dword_140035180 & 0x10000 )
    {
      v9 = L"GetProcessImageFileNameFromProcessHandle: Empty image file name returned";
LABEL_27:
      sub_140007A38((__int64)v9);
      goto LABEL_28;
    }
    goto LABEL_28;
  }
  if ( byte_1400394B8 )
  {
    v26 = 92;
    v17 = &v24;
    v24 = xmmword_140026840;
    v16 = 1835034;
    v25 = 32370060416122989i64;
    if ( sub_14000E620(v5, (USHORT *)&v16, 1u) )
    {
      if ( dword_140035180 & 0x10000 )
      {
        v9 = L"GetProcessImageFileNameFromProcessHandle: Ignoring clear case device";
        goto LABEL_27;
      }
LABEL_28:
      ExFreePoolWithTag(v5, 0);
      v10 = v2->Buffer;
      *(_DWORD *)&v2->Length = 0;
      if ( v10 )
        ExFreePoolWithTag(v10, 0);
      v2->Buffer = 0i64;
      goto LABEL_31;
    }
  }
  v11 = qword_140038478;
  v15 = 0i64;
  Object = 0i64;
  v18 = 48;
  v19 = 0i64;
  v21 = 576;
  v20 = v5;
  _mm_storeu_si128((__m128i *)&v22, (__m128i)0i64);
  v8 = FltCreateFileEx(v11, 0i64, &v15, &Object, 0, &v18, &v23, 0i64, 0, 7, 1, 320, 0i64, 0, 2048);
  ExFreePoolWithTag(v5, 0);
  if ( v8 < 0 || v8 == 264 )
  {
    if ( !(dword_140035180 & 0x10000) )
      goto LABEL_43;
    v12 = L"GetProcessImageFileNameFromProcessHandle: Failed to open the executable file for the process.";
    goto LABEL_42;
  }
  P = 0i64;
  v8 = IoQueryFileDosDeviceName(Object, &P);
  FltClose(v15);
  ObfDereferenceObject(Object);
  if ( v8 < 0 )
  {
    if ( !(dword_140035180 & 0x10000) )
      goto LABEL_43;
    v12 = L"GetProcessImageFileNameFromProcessHandle: Failed to query the dos device name for the process.";
LABEL_42:
    sub_140007A38((__int64)v12);
    goto LABEL_43;
  }
  v8 = sub_14001D8D4(v2, (PCUNICODE_STRING)P);
  ExFreePoolWithTag(P, 0);
  if ( v8 < 0 )
  {
    if ( !(dword_140035180 & 0x10000) )
      goto LABEL_43;
    v12 = L"GetProcessImageFileNameFromProcessHandle: Failed to copy the filename.";
    goto LABEL_42;
  }
LABEL_31:
  v8 = 0;
LABEL_43:
  if ( v6 )
    sub_14000762C(v6);
  return (unsigned int)v8;
}
// 14002156E: using guessed type __int64 __fastcall FltClose(_QWORD);
// 140021622: using guessed type __int64 __fastcall FltCreateFileEx(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400265D0: using guessed type wchar_t aGetprocessimag_3[72];
// 140026660: using guessed type wchar_t aGetprocessimag[69];
// 1400266F0: using guessed type wchar_t aGetprocessimag_4[85];
// 1400267A0: using guessed type wchar_t aGetprocessimag_5[73];
// 140026840: using guessed type __int128 xmmword_140026840;
// 140026860: using guessed type wchar_t aGetprocessimag_0[69];
// 1400268F0: using guessed type wchar_t aGetprocessimag_6[94];
// 1400269B0: using guessed type wchar_t aGetprocessimag_1[95];
// 140026A70: using guessed type wchar_t aGetprocessimag_2[71];
// 140028638: using guessed type __int64 __fastcall IoQueryFileDosDeviceName(_QWORD, _QWORD);
// 140035180: using guessed type int dword_140035180;
// 140038478: using guessed type __int64 qword_140038478;
// 1400394B8: using guessed type char byte_1400394B8;

//----- (000000014001DF90) ----------------------------------------------------
__int64 __fastcall sub_14001DF90(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax

  if ( a3 )
    result = sub_14001D94C(a2);
  else
    result = sub_14001DAD4((__int64)&unk_140038490, a2);
  return result;
}

//----- (000000014001DFAC) ----------------------------------------------------
__int64 __fastcall sub_14001DFAC(__int64 a1, _DWORD *a2, const UNICODE_STRING *a3, signed __int64 *a4)
{
  _QWORD *v4; // rsi
  signed __int64 *v5; // r15
  const UNICODE_STRING *v6; // rbp
  __int64 v7; // r13
  _QWORD *v8; // r14
  _QWORD *v9; // rdi
  __int64 v10; // rbx
  __int64 result; // rax
  signed __int64 v12; // rdi
  signed int v13; // esi
  void *v14; // rcx
  __int64 *v15; // rax
  _QWORD *v16; // rbx
  _QWORD *v17; // rcx

  v4 = a2;
  v5 = a4;
  v6 = a3;
  v7 = a1;
  v8 = (_QWORD *)(a1 + 16i64 * (*a2 % 0x101u));
  v9 = (_QWORD *)*v8;
  if ( (_QWORD *)*v8 == v8 )
  {
LABEL_4:
    v9 = 0i64;
  }
  else
  {
    while ( v9[4] != *(_QWORD *)a2 )
    {
      v9 = (_QWORD *)*v9;
      if ( v9 == v8 )
        goto LABEL_4;
    }
  }
  if ( v9 )
  {
    v12 = (signed __int64)(v9 + 5);
    result = sub_14001D8D4((PUNICODE_STRING)v12, a3);
    if ( (signed int)result < 0 )
      return result;
    *(_QWORD *)(v12 + 16) = *(_QWORD *)&v6[1].Length;
  }
  else
  {
    ++stru_1400394C0.L.TotalAllocates;
    v10 = (__int64)ExpInterlockedPopEntrySList(&stru_1400394C0.L.ListHead);
    if ( v10
      || (++stru_1400394C0.L.AllocateMisses, (v10 = sub_140021A40((__int64 (*)(void))stru_1400394C0.L.Allocate)) != 0) )
    {
      *(_QWORD *)(v10 + 40) = 0i64;
      *(_QWORD *)(v10 + 48) = 0i64;
      *(_DWORD *)(v10 + 56) = 1;
      *(_DWORD *)(v10 + 60) = 1;
    }
    else
    {
      v10 = 0i64;
    }
    if ( !v10 )
      return 3221225626i64;
    v12 = v10 + 40;
    *(_QWORD *)(v10 + 32) = *v4;
    v13 = sub_14001D8D4((PUNICODE_STRING)(v10 + 40), v6);
    if ( v13 >= 0 )
    {
      v13 = 0;
      *(_QWORD *)(v10 + 56) = *(_QWORD *)&v6[1].Length;
    }
    if ( v13 < 0 )
    {
      v14 = *(void **)(v10 + 48);
      *(_DWORD *)v12 = 0;
      if ( v14 )
        ExFreePoolWithTag(v14, 0);
      *(_QWORD *)(v10 + 48) = 0i64;
      sub_14001D718((PSLIST_ENTRY)v10);
      return (unsigned int)v13;
    }
    v15 = (__int64 *)v8[1];
    if ( (_QWORD *)*v15 != v8
      || (*(_QWORD *)(v10 + 8) = v15,
          *(_QWORD *)v10 = v8,
          *v15 = v10,
          v8[1] = v10,
          v16 = (_QWORD *)(v10 + 16),
          v17 = *(_QWORD **)(v7 + 4120),
          *v17 != v7 + 4112) )
    {
      __fastfail(3u);
    }
    *v16 = v7 + 4112;
    v16[1] = v17;
    *v17 = v16;
    *(_QWORD *)(v7 + 4120) = v16;
  }
  if ( v5 )
    *v5 = v12;
  return 0i64;
}

//----- (000000014001E178) ----------------------------------------------------
__int64 __fastcall sub_14001E178(__int64 a1)
{
  signed __int64 v1; // rbx
  __int64 **v2; // rsi
  __int64 *i; // r14

  v1 = a1 + 4128;
  v2 = (__int64 **)(a1 + 4112);
  FltAcquirePushLockExclusive(a1 + 4128);
  for ( i = *v2; i != (__int64 *)v2; i = (__int64 *)*i )
  {
    *((_DWORD *)i + 10) = sub_140013A0C((unsigned __int16 *)i + 12) == 0;
    *((_DWORD *)i + 11) = sub_1400139C0((unsigned __int16 *)i + 12) == 0;
  }
  return FltReleasePushLock(v1);
}
// 14002150E: using guessed type __int64 __fastcall FltAcquirePushLockExclusive(_QWORD);
// 140021526: using guessed type __int64 __fastcall FltReleasePushLock(_QWORD);

//----- (000000014001E1F8) ----------------------------------------------------
__int64 sub_14001E1F8()
{
  __int64 result; // rax

  if ( !byte_1400394B9 )
    result = sub_14001E178((__int64)&unk_140038490);
  return result;
}
// 1400394B9: using guessed type char byte_1400394B9;

//----- (000000014001E218) ----------------------------------------------------
__int64 sub_14001E218()
{
  UNICODE_STRING *v0; // rax
  char v1; // al
  int v2; // ecx
  signed int v3; // ebx
  UNICODE_STRING *v4; // rax
  __int64 result; // rax
  int v6; // [rsp+30h] [rbp+8h]

  v0 = sub_14000589C();
  v1 = sub_1400095B8(v0, L"DisableProcessPathExclusions", &v6);
  v2 = 0;
  if ( v1 )
    v2 = v6;
  byte_1400394B9 = v2 != 0;
  if ( v2 )
    return 0i64;
  v3 = 1;
  v4 = sub_14000589C();
  if ( sub_1400095B8(v4, L"DisableProcessPathExclusionsForMVFS", &v6) )
    v3 = v6;
  byte_1400394B8 = v3 != 0;
  result = sub_14000ABA0(4, (__int64)sub_14001DF90);
  if ( (signed int)result >= 0 )
    return 0i64;
  return result;
}
// 140026D20: using guessed type wchar_t aDisableprocess[29];
// 140026D60: using guessed type wchar_t aDisableprocess_0[36];
// 1400394B8: using guessed type char byte_1400394B8;
// 1400394B9: using guessed type char byte_1400394B9;

//----- (000000014001E298) ----------------------------------------------------
bool __fastcall sub_14001E298(__int64 a1)
{
  __int64 v1; // rbx
  char v4; // [rsp+38h] [rbp+10h]
  int v5; // [rsp+3Ch] [rbp+14h]

  v1 = a1;
  if ( byte_1400394B9 )
    return 0;
  if ( sub_14001D67C((__int64)&unk_140038490, a1, &v4) )
    return v5 == 0;
  if ( dword_140035180 & 0x10000 )
    sub_140007A38((__int64)L"IsProcessCxMailByPid: No process record found for PID %ld", (unsigned int)v1);
  return (unsigned __int64)sub_14001D94C(v1) >> 32 == 0;
}
// 140026E30: using guessed type wchar_t aIsprocesscxmai[58];
// 140035180: using guessed type int dword_140035180;
// 1400394B9: using guessed type char byte_1400394B9;

//----- (000000014001E300) ----------------------------------------------------
bool __fastcall sub_14001E300(__int64 a1)
{
  __int64 v1; // rbx
  int v4; // [rsp+38h] [rbp+10h]

  v1 = a1;
  if ( byte_1400394B9 )
    return 0;
  if ( sub_14001D67C((__int64)&unk_140038490, a1, &v4) )
    return v4 == 0;
  if ( dword_140035180 & 0x10000 )
    sub_140007A38((__int64)L"IsProcessExemptByPid: No process record found for PID %ld", (unsigned int)v1);
  return (unsigned int)sub_14001D94C(v1) == 0;
}
// 140026DB0: using guessed type wchar_t aIsprocessexemp[58];
// 140035180: using guessed type int dword_140035180;
// 1400394B9: using guessed type char byte_1400394B9;

//----- (000000014001E364) ----------------------------------------------------
__int64 __fastcall sub_14001E364(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  if ( !byte_1400394B9 )
  {
    sub_14000AC40(4, a2);
    result = sub_14001D7F0((struct _SLIST_ENTRY **)&unk_140038490);
  }
  return result;
}
// 1400394B9: using guessed type char byte_1400394B9;

//----- (000000014001E390) ----------------------------------------------------
__int64 __fastcall sub_14001E390(unsigned __int16 *a1, __int64 a2, _DWORD *a3)
{
  __int64 result; // rax

  if ( a3 && a1 )
  {
    if ( *a3 & 0x100 )
      result = sub_14001E3B8(a1, dword_14002B140);
  }
  return result;
}
// 14002B140: using guessed type int dword_14002B140;

//----- (000000014001E3B8) ----------------------------------------------------
__int64 __fastcall sub_14001E3B8(unsigned __int16 *a1, unsigned int a2)
{
  unsigned int v2; // er12
  unsigned __int16 *v3; // rbx
  int v4; // esi
  __int64 v5; // rcx
  unsigned int v6; // er15
  unsigned __int64 v7; // rdi
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  int v11; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-58h]
  unsigned int v14; // [rsp+30h] [rbp-48h]
  unsigned __int64 v15; // [rsp+38h] [rbp-40h]
  int v16; // [rsp+40h] [rbp-38h]
  char v17; // [rsp+44h] [rbp-34h]
  signed int v18; // [rsp+90h] [rbp+18h]

  v2 = a2;
  v3 = a1;
  v14 = 0;
  v4 = *a1;
  v15 = 0i64;
  v16 = 0;
  v17 = 0;
  sub_14000B028((__int64)&v15, v4 + 26);
  if ( v15 )
  {
    v6 = PsGetCurrentProcessId(v5);
    v7 = v15;
    *(_DWORD *)(v15 + 4) = v6;
    *(_DWORD *)v7 = 7;
    *(_DWORD *)(v7 + 8) = 24;
    *(_DWORD *)(v7 + 12) = PsGetCurrentThreadId(v9, v8, v10);
    *(_QWORD *)(v7 + 16) = MEMORY[0xFFFFF78000000014];
    sub_140021A80((__m128i *)(v7 + 24), *((_QWORD *)v3 + 1), *v3);
    *(_WORD *)(v7 + *v3 + 24) = 0;
    if ( dword_140035180 & 0x100000 )
      sub_140007A38(
        (__int64)L"LoadDriver: PID=0x%x [ThreadId=0x%x] imagefile=\"%wZ\"",
        v6,
        *(unsigned int *)(v7 + 12),
        v3);
    v11 = sub_140019B6C(v2, v7, v4 + 26);
    if ( v11 == -1073741536 || v11 == -1073741248 )
    {
      sub_14000B0FC((__int64)&v15);
      return 0i64;
    }
    if ( v11 < 0 || v11 == 258 )
    {
      LODWORD(BugCheckParameter3) = v11;
      sub_140006BB4(0x226ui64, 0xC1ui64, 0i64, 0xE03D0260, BugCheckParameter3, 0);
    }
    else if ( v18 <= 2 )
    {
      v14 = v18;
    }
  }
  sub_14000B0FC((__int64)&v15);
  return v14;
}
// 140026FF0: using guessed type wchar_t aLoaddriverPid0[53];
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 1400284E8: using guessed type __int64 __fastcall PsGetCurrentThreadId(_QWORD, _QWORD, _QWORD);
// 140035180: using guessed type int dword_140035180;

//----- (000000014001E550) ----------------------------------------------------
__int64 sub_14001E550()
{
  unsigned int v0; // ebx
  unsigned int v1; // eax
  __int64 result; // rax

  v0 = 0;
  if ( !byte_140039540 )
  {
    v1 = PsSetLoadImageNotifyRoutine(sub_14001E390);
    v0 = v1;
    if ( (v1 & 0x80000000) != 0 )
    {
      if ( dword_140035180 & 0x100000 )
        sub_140007A38((__int64)L"ActivateLoadDriverFilter: PsSetLoadImageNotifyRoutine failed, status 0x%X", v1);
    }
  }
  result = v0;
  byte_140039540 = (v0 & 0x80000000) == 0;
  return result;
}
// 140026EB0: using guessed type wchar_t aActivateloaddr[74];
// 140028640: using guessed type __int64 __fastcall PsSetLoadImageNotifyRoutine(_QWORD);
// 140035180: using guessed type int dword_140035180;
// 140039540: using guessed type char byte_140039540;

//----- (000000014001E5AC) ----------------------------------------------------
__int64 sub_14001E5AC()
{
  unsigned int v0; // ebx
  unsigned int v1; // eax

  v0 = 0;
  if ( byte_140039540 )
  {
    byte_140039540 = 0;
    v1 = PsRemoveLoadImageNotifyRoutine(sub_14001E390);
    v0 = v1;
    if ( (v1 & 0x80000000) != 0 )
    {
      if ( dword_140035180 & 0x100000 )
        sub_140007A38((__int64)L"DeactivateLoadDriverFilter: PsRemoveLoadImageNotifyRoutine failed, status 0x%X", v1);
    }
  }
  return v0;
}
// 140026F50: using guessed type wchar_t aDeactivateload[79];
// 140028648: using guessed type __int64 __fastcall PsRemoveLoadImageNotifyRoutine(_QWORD);
// 140035180: using guessed type int dword_140035180;
// 140039540: using guessed type char byte_140039540;

//----- (000000014001E600) ----------------------------------------------------
__int64 sub_14001E600()
{
  unsigned int v0; // ebx
  int v1; // eax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]

  v0 = 0;
  if ( byte_140039548
    || (v0 = sub_14001E6B0((PUNICODE_STRING)&stru_140039550), (byte_140039548 = (v0 & 0x80000000) == 0) != 0) )
  {
    v1 = sub_140020B18();
    if ( v1 < 0 )
    {
      LODWORD(BugCheckParameter3) = v1;
      sub_140006BB4(0x212ui64, 0x37Aui64, 0i64, 0xE03D0205, BugCheckParameter3, 0);
    }
  }
  if ( byte_140039548 && dword_140035180 & 0x10800000 )
    sub_140007A38((__int64)L"Monitoring of file modifications activated successfully");
  return v0;
}
// 140027500: using guessed type wchar_t aMonitoringOfFi[56];
// 140035180: using guessed type int dword_140035180;
// 140039548: using guessed type char byte_140039548;

//----- (000000014001E680) ----------------------------------------------------
void sub_14001E680()
{
  byte_140039548 = 0;
  sub_140020DC4();
  if ( dword_140035180 & 0x10800000 )
    sub_140007A38((__int64)L"Monitoring of file modifications deactivated successfully");
}
// 140027570: using guessed type wchar_t aMonitoringOfFi_0[58];
// 140035180: using guessed type int dword_140035180;
// 140039548: using guessed type char byte_140039548;

//----- (000000014001E6B0) ----------------------------------------------------
__int64 __fastcall sub_14001E6B0(PUNICODE_STRING Destination)
{
  NTSTATUS v1; // ebx
  PUNICODE_STRING v2; // rdi
  bool v3; // r14
  USHORT *v4; // rsi
  USHORT v5; // dx
  USHORT v6; // dx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-79h]
  PVOID Object; // [rsp+60h] [rbp-39h]
  NTSTATUS v10; // [rsp+68h] [rbp-31h]
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+70h] [rbp-29h]
  char v12; // [rsp+80h] [rbp-19h]
  PCUNICODE_STRING SourceString; // [rsp+90h] [rbp-9h]
  NTSTATUS v14; // [rsp+98h] [rbp-1h]
  OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+A0h] [rbp+7h]
  __int64 v16; // [rsp+100h] [rbp+67h]
  HANDLE FileHandle; // [rsp+108h] [rbp+6Fh]

  v1 = 0;
  v2 = Destination;
  if ( LOBYTE(Destination[2].Length) )
    goto LABEL_34;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Length = 48;
  ObjectAttributes.Attributes = 576;
  ObjectAttributes.ObjectName = (PUNICODE_STRING)&unk_140029020;
  _mm_storeu_si128((__m128i *)&ObjectAttributes.SecurityDescriptor, (__m128i)0i64);
  v1 = ZwCreateFile(&FileHandle, 0x100000u, &ObjectAttributes, &IoStatusBlock, 0i64, 0, 3u, 1u, 0x21u, 0i64, 0);
  if ( v1 < 0 )
    goto LABEL_35;
  v3 = 0;
  v4 = 0i64;
  sub_14000B2FC(&Object, FileHandle);
  v1 = v10;
  if ( v10 >= 0 )
  {
    v16 = 0i64;
    v1 = FltGetVolumeFromFileObject(qword_140038478, Object, &v16);
    if ( v1 >= 0 )
    {
      v4 = (USHORT *)sub_14001BE0C(v16);
      v3 = v4 ? v4 != 0i64 : 0;
      if ( !v4 )
      {
        v1 = -1073741823;
        if ( dword_140035180 & 0x800000 )
          sub_140007A38((__int64)L"Error initializing SystemRootPath - GetVolumeName failed");
      }
    }
    if ( v16 )
      FltObjectDereference();
    if ( v1 >= 0 )
    {
      sub_14000B190((__int64)&v12, (__int64)Object);
      v1 = v14;
      if ( v14 >= 0 )
        v1 = sub_14001F05C(v2, SourceString);
      sub_14000B0FC((__int64)&v12);
    }
  }
  ZwClose(FileHandle);
  if ( v1 >= 0 )
  {
    if ( v4 && (v5 = v2->Length, v2->Length >= *v4) )
    {
      v2[1].Buffer = &v2->Buffer[(unsigned __int64)*v4 >> 1];
      v6 = v5 - *v4;
      v2[1].MaximumLength = v6;
      v2[1].Length = v6;
    }
    else
    {
      v1 = -1073741823;
      if ( dword_140035180 & 0x800000 )
        sub_140007A38((__int64)L"Invalid system root path (%Z) or system drive name (%Z)", v2, v4);
    }
  }
  sub_14000B368(&Object);
  if ( v3 )
    sub_14000AB20(v4);
  if ( v1 >= 0 )
  {
LABEL_34:
    if ( dword_140035180 & 0x800000 )
    {
      sub_140007A38((__int64)L"System root path: %Z", v2);
      if ( dword_140035180 & 0x800000 )
        sub_140007A38((__int64)L"System directory: %Z", &v2[1]);
    }
  }
  else
  {
LABEL_35:
    LODWORD(BugCheckParameter3) = v1;
    sub_140006BB4(0x212ui64, 0xD8ui64, 0i64, 0xE03D0230, BugCheckParameter3, 0);
  }
  return (unsigned int)v1;
}
// 1400216A6: using guessed type __int64 FltObjectDereference(void);
// 1400216EE: using guessed type __int64 __fastcall FltGetVolumeFromFileObject(_QWORD, _QWORD, _QWORD);
// 140027110: using guessed type wchar_t aErrorInitializ[57];
// 140027190: using guessed type wchar_t aInvalidSystemR[56];
// 140027200: using guessed type wchar_t aSystemRootPath[21];
// 140027230: using guessed type wchar_t aSystemDirector[21];
// 140035180: using guessed type int dword_140035180;
// 140038478: using guessed type __int64 qword_140038478;

//----- (000000014001E910) ----------------------------------------------------
char __fastcall sub_14001E910(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, char a5, char *a6, bool *a7, bool *a8)
{
  __int64 v8; // rdi
  _DWORD *v9; // rbp
  __int64 v10; // r14
  __int64 v11; // rsi
  char v12; // bl
  __int64 v13; // rcx
  __int64 v14; // rax
  int v15; // esi
  int v16; // edi
  int v17; // esi
  char v18; // r14
  char v19; // bp
  USHORT v20; // ax
  bool v21; // cl
  __int64 (__fastcall **v23)(PSLIST_ENTRY); // [rsp+20h] [rbp-48h]
  PCUNICODE_STRING String2; // [rsp+28h] [rbp-40h]
  UNICODE_STRING String1; // [rsp+30h] [rbp-38h]

  v8 = a4;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  if ( !byte_140039548 )
    return 0;
  v12 = 1;
  if ( ExGetPreviousMode() != 1 )
    return 0;
  if ( IoGetCurrentProcess() == (PEPROCESS)qword_1400369C8 )
    return 0;
  v13 = *(_QWORD *)(v8 + 16);
  if ( *(_BYTE *)(v13 + 6) & 4 )
    return 0;
  v14 = *(_QWORD *)(v11 + 8);
  if ( !v14 )
    return 0;
  if ( !*(_QWORD *)(v14 + 56) )
    return 0;
  v15 = *(_DWORD *)(*(_QWORD *)(v13 + 24) + 16i64);
  v16 = v15 & 0x2010000;
  v17 = v15 & 0x2000006;
  if ( !v17 && !v16 )
    return 0;
  v18 = *(_BYTE *)(v10 + 1063);
  if ( !v18 && !a5 )
    return 0;
  if ( sub_140004F74(v9, 0) )
    return 0;
  sub_140004E24((__int64)v9, &v23);
  if ( !sub_140020E24(String2, 1, a6, a7) )
  {
    v19 = 0;
    if ( v17 )
    {
      v20 = _mm_cvtsi128_si32(*(__m128i *)String2);
      String1 = *String2;
      if ( v20 >= stru_140039550.Length )
      {
        String1.Length = stru_140039550.Length;
        v19 = 0;
        if ( RtlEqualUnicodeString(&String1, &stru_140039550, 1u) )
          v19 = 1;
      }
    }
    if ( v16 || v19 || v18 )
    {
      *a6 = v19;
      *a7 = v18 != 0;
      v21 = v16 && !v17;
      *a8 = v21;
    }
    else
    {
      v12 = 0;
    }
  }
  v23 = &off_140028B58;
  if ( String2 )
  {
    sub_14001A4D8(String2);
    String2 = 0i64;
  }
  sub_14001CE9C(&v23);
  return v12;
}
// 14001A4D8: using guessed type __int64 __fastcall sub_14001A4D8(_QWORD);
// 140028B58: using guessed type __int64 (__fastcall *off_140028B58)(PSLIST_ENTRY ListEntry);
// 1400369C8: using guessed type __int64 qword_1400369C8;
// 140039548: using guessed type char byte_140039548;

//----- (000000014001EAF4) ----------------------------------------------------
char __fastcall sub_14001EAF4(__int64 a1, char *a2)
{
  __int64 v2; // rax
  int v3; // ecx
  int v4; // er8
  char result; // al

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24i64);
  v3 = *(_DWORD *)(v2 + 16);
  if ( !_bittest(&v3, 0x19u) || (v4 = *(_DWORD *)(*(_QWORD *)(v2 + 8) + 20i64), v4 == v3) )
    v4 = *(_DWORD *)(v2 + 16);
  result = 0;
  if ( !(v4 & 6) )
  {
    if ( !(v4 & 0x10000) )
      return result;
    result = 1;
  }
  *a2 = result;
  return 1;
}

//----- (000000014001EB34) ----------------------------------------------------
char __fastcall sub_14001EB34(char a1, __int64 a2)
{
  char v2; // al
  char v3; // bl
  _WORD *v4; // rcx
  USHORT v5; // ax
  __m128i v7; // [rsp+20h] [rbp-28h]
  UNICODE_STRING String2; // [rsp+30h] [rbp-18h]
  char v9; // [rsp+58h] [rbp+10h]

  v2 = a1;
  v3 = 0;
  v4 = *(_WORD **)(a2 + 8);
  if ( !v4 || !v2 || !String1.Length )
    return 0;
  sub_14001B244(v4, &v9, (UNICODE_STRING *)&v7, 0);
  v5 = String1.Length;
  if ( (unsigned __int16)v7.m128i_i16[0] >= String1.Length )
  {
    _mm_store_si128((__m128i *)&String2, v7);
    String2.Length = v5;
    v3 = 0;
    if ( RtlEqualUnicodeString(&String1, &String2, 1u) )
      v3 = 1;
  }
  return v3;
}

//----- (000000014001EBC0) ----------------------------------------------------
void __usercall sub_14001EBC0(__int64 *a1@<rdx>, unsigned __int16 *a2@<rcx>, __int64 a3@<r8>, char a4@<r9b>, char a5)
{
  char v5; // r15
  __int64 v6; // r13
  __int64 *v7; // r14
  unsigned __int16 *v8; // rsi
  int v9; // edi
  unsigned int v10; // eax
  __m128i *v11; // rbx
  unsigned int v12; // ebp
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  signed int v16; // eax
  __int64 v17; // rcx
  int v18; // eax
  __int64 v19; // rcx
  int v20; // ebx
  int v21; // edi
  __int64 v22; // rax
  __int64 v23; // rcx
  int v24; // [rsp+40h] [rbp-48h]
  __m128i *v25; // [rsp+48h] [rbp-40h]
  int v26; // [rsp+50h] [rbp-38h]
  char v27; // [rsp+54h] [rbp-34h]

  v5 = a4;
  v6 = a3;
  v7 = a1;
  v8 = a2;
  if ( byte_140039548 && !sub_14000BC00(*a1) )
  {
    v9 = *v8;
    v25 = 0i64;
    v26 = 0;
    v27 = 0;
    sub_14000B028((__int64)&v25, v9 + 34);
    if ( !v25 )
      goto LABEL_21;
    v10 = sub_14000BBF4(*v7);
    v11 = v25;
    v12 = v10;
    HIDWORD(v25->m128i_i64[0]) = v10;
    LODWORD(v11->m128i_i64[0]) = 6;
    v11[1].m128i_i32[0] = PsGetCurrentThreadId(v14, v13, v15);
    v16 = 0;
    v17 = MEMORY[0xFFFFF78000000014];
    HIDWORD(v11->m128i_i64[1]) = 0;
    v11[1].m128i_i64[1] = v17;
    LODWORD(v11->m128i_i64[1]) = 32;
    if ( v5 )
    {
      v16 = 1;
      HIDWORD(v11->m128i_i64[1]) = 1;
    }
    if ( a5 )
      HIDWORD(v11->m128i_i64[1]) = v16 | 2;
    sub_140021A80(v11 + 2, *((_QWORD *)v8 + 1), *v8);
    *(__int16 *)((char *)v11[2].m128i_i16 + *v8) = 0;
    if ( dword_140035180 & 0x10000000 )
      sub_140007A38((__int64)L"Process 0x%x (Thread 0x%x) notifying file %Z", v12, v11[1].m128i_u32[0], v8);
    v18 = sub_140019D34((unsigned int)dword_14002B140, (unsigned __int64)v11, v9 + 34, v6);
    v20 = v18;
    if ( v18 == -1073741536 || v18 == -1073741248 )
      goto LABEL_21;
    v21 = 0;
    if ( v18 < 0 || v18 == 258 )
    {
      v22 = PsGetCurrentProcessId(v19);
      sub_140005F58(0x212ui64, 0x338ui64, 0xE03D0236, v20, (__int64)v8, v22, 0i64);
    }
    else
    {
      sub_1400063C8(0i64, 0i64);
      v21 = v24;
      if ( v24 > 2 )
      {
LABEL_21:
        sub_14000B0FC((__int64)&v25);
        return;
      }
    }
    if ( v21 == 2 )
    {
      if ( dword_140035180 & 0x10000000 )
        sub_140007A38((__int64)L"System file monitor is terminating process 0x%x", v12);
      v23 = *v7;
      *v7 = 0i64;
      sub_14000BC20(v23);
    }
    goto LABEL_21;
  }
}
// 140027440: using guessed type wchar_t aProcess0xXThre[45];
// 1400274A0: using guessed type wchar_t aSystemFileMoni[48];
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 1400284E8: using guessed type __int64 __fastcall PsGetCurrentThreadId(_QWORD, _QWORD, _QWORD);
// 14002B140: using guessed type int dword_14002B140;
// 140035180: using guessed type int dword_140035180;
// 140039548: using guessed type char byte_140039548;

//----- (000000014001EDAC) ----------------------------------------------------
char sub_14001EDAC()
{
  return byte_140039548;
}
// 140039548: using guessed type char byte_140039548;

//----- (000000014001EDB4) ----------------------------------------------------
__int64 __fastcall sub_14001EDB4(__int64 a1, __int64 a2, __int64 a3, __m128i *a4, __int64 a5, __int64 *a6)
{
  unsigned int v6; // edi
  __m128i *v7; // rbp
  __int64 v8; // rsi
  USHORT v9; // ax
  __int64 v10; // r14
  signed int v11; // ebx
  char v12; // al
  int v13; // esi
  bool v14; // zf
  __int64 v15; // rax
  __int64 *v16; // r13
  unsigned int v17; // eax
  int v18; // er15
  unsigned int v19; // er12
  __int64 v20; // rdx
  __int64 v21; // rcx
  __int64 v22; // r8
  __int64 v23; // r14
  int v24; // eax
  __int64 v25; // rcx
  int v26; // ebx
  int v27; // esi
  __int64 v28; // rax
  __int64 v29; // rcx
  __int64 **v31; // [rsp+20h] [rbp-68h]
  __int64 v32; // [rsp+40h] [rbp-48h]
  int v33; // [rsp+48h] [rbp-40h]
  char v34; // [rsp+4Ch] [rbp-3Ch]
  __m128i v35; // [rsp+50h] [rbp-38h]
  __int64 v36; // [rsp+90h] [rbp+8h]

  v36 = a1;
  v6 = 0;
  v7 = a4;
  v8 = a3;
  v9 = _mm_cvtsi128_si32(*a4);
  v10 = a2;
  v11 = 0;
  v35 = *a4;
  if ( v9 >= stru_140039550.Length )
  {
    v35.m128i_i16[0] = stru_140039550.Length;
    if ( RtlEqualUnicodeString((PCUNICODE_STRING)&v35, &stru_140039550, 1u) )
      v11 = 1;
  }
  v12 = *(_BYTE *)(v8 + 1063);
  v13 = v11 | 2;
  v14 = v12 == 0;
  v15 = *(_QWORD *)(v10 + 8);
  if ( v14 )
    v13 = v11;
  if ( !v15 || !*(_QWORD *)(v15 + 56) )
    v13 |= 4u;
  v16 = a6;
  v17 = sub_14000BBF4(*a6);
  v18 = LOWORD(v7->m128i_i64[0]);
  v19 = v17;
  v32 = 0i64;
  v33 = 0;
  v34 = 0;
  sub_14000B028((__int64)&v32, v18 + 42);
  v23 = v32;
  if ( v32 )
  {
    *(_DWORD *)(v32 + 4) = v19;
    *(_DWORD *)v23 = 8;
    *(_DWORD *)(v23 + 28) = PsGetCurrentThreadId(v21, v20, v22);
    *(_QWORD *)(v23 + 32) = MEMORY[0xFFFFF78000000014];
    *(_DWORD *)(v23 + 8) = 40;
    *(_DWORD *)(v23 + 12) = v13;
    *(_DWORD *)(v23 + 16) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v36 + 16) + 24i64) + 16i64);
    *(_WORD *)(v23 + 20) = *(unsigned __int8 *)(*(_QWORD *)(v36 + 16) + 35i64);
    *(_WORD *)(v23 + 22) = *(_WORD *)(*(_QWORD *)(v36 + 16) + 42i64);
    *(_WORD *)(v23 + 24) = *(_WORD *)(*(_QWORD *)(v36 + 16) + 40i64);
    sub_140021A80((__m128i *)(v23 + 40), v7->m128i_i64[1], LOWORD(v7->m128i_i64[0]));
    *(_WORD *)(LOWORD(v7->m128i_i64[0]) + v23 + 40) = 0;
    if ( dword_140035180 & 0x10000000 )
      sub_140007A38(
        (__int64)L"RS_NotifyCreatefile: Process 0x%x (Thread 0x%x) notifying file %Z opened for writing.",
        v19,
        *(unsigned int *)(v23 + 28),
        v7);
    v31 = &a6;
    v24 = sub_140019D34((unsigned int)dword_14002B140, v23, v18 + 42, a5);
    v26 = v24;
    if ( v24 != -1073741536 && v24 != -1073741248 )
    {
      v27 = 0;
      if ( v24 < 0 || v24 == 258 )
      {
        v28 = PsGetCurrentProcessId(v25);
        sub_140005F58(0x212ui64, 0x1D7ui64, 0xE03D0236, v26, (__int64)v7, v28, 0i64);
      }
      else
      {
        sub_1400063C8(0i64, 0i64);
        v27 = (signed int)a6;
        if ( (signed int)a6 > 2 )
          goto LABEL_27;
      }
      if ( v27 )
      {
        if ( dword_140035180 & 0x10000000 )
          sub_140007A38(
            (__int64)L"RS_NotifyCreateFile: Blocking attempt by process 0x%x (Thread 0x%x) to access file \"%Z\"",
            v19,
            *(unsigned int *)(v23 + 28),
            v7,
            v31);
        if ( v27 == 2 )
        {
          if ( dword_140035180 & 0x10000000 )
            sub_140007A38(
              (__int64)L"RS_NotifyCreatefile is terminating process 0x%x (Thread 0x%x)",
              v19,
              *(unsigned int *)(v23 + 28));
          v29 = *v16;
          *v16 = 0i64;
          sub_14000BC20(v29);
        }
        v6 = -1073741790;
      }
    }
  }
LABEL_27:
  sub_14000B0FC((__int64)&v32);
  return v6;
}
// 140027260: using guessed type wchar_t aRsNotifycreate_1[86];
// 140027310: using guessed type wchar_t aRsNotifycreate[88];
// 1400273C0: using guessed type wchar_t aRsNotifycreate_0[62];
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 1400284E8: using guessed type __int64 __fastcall PsGetCurrentThreadId(_QWORD, _QWORD, _QWORD);
// 14002B140: using guessed type int dword_14002B140;
// 140035180: using guessed type int dword_140035180;

//----- (000000014001F05C) ----------------------------------------------------
__int64 __fastcall sub_14001F05C(PUNICODE_STRING Destination, PCUNICODE_STRING SourceString)
{
  PCUNICODE_STRING v2; // rdi
  PUNICODE_STRING v3; // rsi
  __int64 result; // rax
  USHORT v5; // bx
  unsigned __int16 v6; // bp
  WCHAR *v7; // rax

  v2 = SourceString;
  v3 = Destination;
  result = 3221225473i64;
  if ( SourceString )
  {
    v5 = SourceString->Length;
    if ( SourceString->Length )
    {
      v6 = v5 >> 1;
      if ( (unsigned __int16)(v5 >> 1) >= 1u && SourceString->Buffer[v6 - 1] != 92 )
        v5 += 2;
      v7 = (WCHAR *)ExAllocatePoolWithTag(PagedPool, v5, 0x72735352u);
      if ( v7 )
      {
        *(_QWORD *)&v3->Length = 0i64;
        v3->MaximumLength = v5;
        v3->Buffer = v7;
        RtlCopyUnicodeString(v3, v2);
        if ( v6 >= 1u && v2->Buffer[v6 - 1] != 92 )
          RtlAppendUnicodeToString(v3, &word_140026510);
        LOBYTE(v3[2].Length) = 1;
        result = 0i64;
      }
      else
      {
        result = 3221225626i64;
      }
    }
  }
  return result;
}

//----- (000000014001F148) ----------------------------------------------------
char __fastcall sub_14001F148(__int64 a1, __m128i *a2, const UNICODE_STRING *a3)
{
  const UNICODE_STRING *v3; // rdi
  __m128i *v4; // rsi
  __int64 v5; // r14
  signed int i; // ebx
  int v7; // ebx
  unsigned int v8; // er15
  int v9; // eax
  UNICODE_STRING *v10; // rsi
  USHORT v11; // bx
  UNICODE_STRING SourceString; // [rsp+20h] [rbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !a2 || !a3 )
    goto LABEL_18;
  for ( i = ((unsigned int)LOWORD(a2->m128i_i64[0]) >> 1) - 1; i >= 0; --i )
  {
    if ( *(_WORD *)(a2->m128i_i64[1] + 2i64 * i) == 92 )
      break;
  }
  v7 = i + 1;
  if ( v7 )
  {
    v8 = 2 * v7 + a3->Length + 16;
    if ( v8 <= *(_DWORD *)(a1 + 8) || (sub_14000B0FC(a1), sub_14000B028(v5, v8), (v9 = *(_DWORD *)(v5 + 8)) != 0) )
    {
      _mm_storeu_si128((__m128i *)&SourceString, *v4);
      SourceString.Length = 2 * v7;
      v10 = *(UNICODE_STRING **)v5;
      v11 = v3->Length + 2 * v7;
      *(_QWORD *)&v10->Length = 0i64;
      v10->MaximumLength = v11;
      v10->Buffer = &v10[1].Length;
      RtlCopyUnicodeString(v10, &SourceString);
      if ( !sub_140009260() )
        ProbeForRead(v3->Buffer, v3->Length, 2u);
      LOBYTE(v9) = RtlAppendUnicodeStringToString(v10, v3) >= 0;
    }
  }
  else
  {
LABEL_18:
    LOBYTE(v9) = 0;
  }
  return v9;
}

//----- (000000014001F280) ----------------------------------------------------
__int64 __fastcall sub_14001F280(__int64 a1, int a2, __int64 a3)
{
  __int64 v3; // rsi
  int v4; // ebx
  struct _KEVENT *v5; // rax
  int v6; // ebx
  int v7; // ebx
  unsigned int v8; // edi
  __m128i *v9; // rbx
  __int64 v11; // [rsp+48h] [rbp-40h]
  int v12; // [rsp+50h] [rbp-38h]
  char v13; // [rsp+54h] [rbp-34h]
  char v14; // [rsp+58h] [rbp-30h]
  __m128i *v15; // [rsp+68h] [rbp-20h]

  v3 = a3;
  v4 = a2;
  if ( ExGetPreviousMode() != 1 )
    return 0i64;
  if ( IoGetCurrentProcess() == (PEPROCESS)qword_1400369C8 )
    return 0i64;
  if ( !byte_1400369C0 )
    return 0i64;
  v5 = sub_14000AD94();
  if ( KeReadStateEvent(v5) || !v3 )
    return 0i64;
  if ( v4 )
  {
    v6 = v4 - 1;
    if ( v6 )
    {
      v7 = v6 - 3;
      if ( v7 )
      {
        if ( v7 == 22 )
          v8 = sub_14000C0A4(*(_QWORD *)(v3 + 8), *(_QWORD *)v3, dword_14002B140);
        else
          v8 = 0;
      }
      else
      {
        v8 = sub_14000C25C(*(_QWORD *)v3, dword_14002B140);
        if ( !v8 )
        {
          sub_14000B190((__int64)&v14, *(_QWORD *)v3);
          v9 = v15;
          v11 = 0i64;
          v12 = 0;
          v13 = 0;
          sub_14000B028((__int64)&v11, 0);
          if ( sub_14001F148((__int64)&v11, v9, *(const UNICODE_STRING **)(v3 + 8)) )
            v8 = sub_14000C0A4(0i64, v11, dword_14002B140);
          sub_14000B0FC((__int64)&v11);
          sub_14000BDA0(&v14);
        }
      }
    }
    else
    {
      v8 = sub_14000C598(
             *(_QWORD *)v3,
             *(unsigned __int16 **)(v3 + 8),
             *(unsigned int *)(v3 + 16),
             *(_DWORD *)(v3 + 20),
             *(void **)(v3 + 24),
             *(_DWORD *)(v3 + 32),
             dword_14002B140);
    }
  }
  else
  {
    v8 = sub_14000C25C(*(_QWORD *)v3, dword_14002B140);
  }
  return v8;
}
// 14000BDA0: using guessed type __int64 __fastcall sub_14000BDA0(_QWORD);
// 14002B140: using guessed type int dword_14002B140;
// 1400369C0: using guessed type char byte_1400369C0;
// 1400369C8: using guessed type __int64 qword_1400369C8;

//----- (000000014001F430) ----------------------------------------------------
__int64 sub_14001F430()
{
  int v1; // eax
  unsigned int v2; // ebx
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-18h]
  __int64 v4; // [rsp+40h] [rbp+8h]

  if ( byte_140039580 )
    return 0i64;
  v4 = 0i64;
  v1 = sub_1400167E4((__m128i **)&v4);
  v2 = v1;
  if ( v1 >= 0 )
  {
    v2 = CmRegisterCallbackEx(sub_14001F280, v4, qword_140039588, 0i64, &Cookie, 0i64);
  }
  else
  {
    LODWORD(BugCheckParameter3) = v1;
    sub_140006BB4(0x1FEui64, 0x11Fui64, 0i64, 0xE03D0203, BugCheckParameter3, 0);
  }
  if ( (v2 & 0x80000000) == 0 )
  {
    byte_140039580 = 1;
    if ( dword_140035180 & 0x60800000 )
      sub_140007A38((__int64)L"Registry access filtering activated successfully");
  }
  return v2;
}
// 1400275F0: using guessed type wchar_t aRegistryAccess[49];
// 140028658: using guessed type __int64 __fastcall CmRegisterCallbackEx(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140035180: using guessed type int dword_140035180;
// 140039580: using guessed type char byte_140039580;
// 140039588: using guessed type __int64 qword_140039588;

//----- (000000014001F4DC) ----------------------------------------------------
__int64 sub_14001F4DC()
{
  NTSTATUS v1; // ebx

  if ( !byte_140039580 )
    return 0i64;
  byte_140039580 = 0;
  v1 = CmUnRegisterCallback(Cookie);
  if ( v1 >= 0 )
  {
    if ( dword_140035180 & 0x60800000 )
      sub_140007A38((__int64)L"Registry access filtering deactivated successfully");
  }
  return (unsigned int)v1;
}
// 140027660: using guessed type wchar_t aRegistryAccess_0[51];
// 140035180: using guessed type int dword_140035180;
// 140039580: using guessed type char byte_140039580;

//----- (000000014001F530) ----------------------------------------------------
signed __int64 sub_14001F530()
{
  __int64 v0; // rdx
  __int64 v1; // rcx
  __int64 v2; // rdx
  __int64 v3; // rcx

  if ( (unsigned int)dword_140039698 > 2 || !sub_140011718() )
    return 3221225473i64;
  KeSetEvent(&stru_140039590, 0, 0);
  sub_14001E364(v1, v0);
  sub_14001D65C();
  sub_140010978();
  nullsub_1(v3, v2);
  sub_14000A124();
  return 0i64;
}
// 140003220: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);
// 140039698: using guessed type int dword_140039698;

//----- (000000014001F588) ----------------------------------------------------
__int64 __fastcall sub_14001F588(PVOID Object, unsigned __int16 *a2)
{
  struct _DRIVER_OBJECT *v2; // rdi
  unsigned __int16 *v3; // rbx
  __int64 v4; // rdx
  __int64 v5; // rcx
  signed int v6; // ebx
  __int64 v7; // rdx
  __int64 v8; // rcx
  int v10; // [rsp+20h] [rbp-138h]
  unsigned int v11; // [rsp+24h] [rbp-134h]
  unsigned int v12; // [rsp+28h] [rbp-130h]

  v2 = (struct _DRIVER_OBJECT *)Object;
  v10 = 276;
  v3 = a2;
  if ( (signed int)RtlGetVersion(&v10) >= 0 && (v11 > 6 || v11 == 6 && v12 >= 2) )
  {
    PoolType = 512;
    dword_14002B7C4 = 0x40000000;
  }
  qword_140039588 = (__int64)v2;
  sub_14000A154();
  KeInitializeEvent(&stru_140039590, 0, 0);
  if ( (signed int)sub_1400058A4(v3) >= 0 && (sub_14003C000(v2), sub_1400167F4()) )
  {
    v6 = sub_140010438(v2);
    if ( v6 >= 0 )
    {
      v6 = sub_140011728(&DeviceObject, v2);
      if ( v6 >= 0 )
      {
        v6 = sub_14001D5EC((__int64)v2);
        if ( v6 >= 0 )
        {
          v6 = sub_14001E218();
          if ( !v6 )
            return 0i64;
          sub_14001D65C();
        }
      }
      nullsub_1(v8, v7);
      sub_140010978();
    }
    else
    {
      nullsub_1(v5, v4);
    }
  }
  else
  {
    v6 = -1073741823;
  }
  sub_14000A124();
  return (unsigned int)v6;
}
// 140003220: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);
// 140028468: using guessed type __int64 __fastcall RtlGetVersion(_QWORD);
// 14002B7C4: using guessed type int dword_14002B7C4;
// 140039588: using guessed type __int64 qword_140039588;

//----- (000000014001F6B8) ----------------------------------------------------
__int64 __fastcall sub_14001F6B8(__int64 a1)
{
  __int64 v1; // rbx

  *(_DWORD *)(a1 + 4) = 0;
  v1 = a1;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_WORD *)(a1 + 20) = 0;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_DWORD *)(a1 + 96) = 0;
  *(_DWORD *)a1 = 2;
  *(_BYTE *)(a1 + 100) = 0;
  sub_14000366C(a1 + 48);
  *(_QWORD *)(v1 + 88) = 0i64;
  *(_BYTE *)(v1 + 80) = 0;
  _InterlockedIncrement(&dword_1400395B0);
  return v1;
}
// 1400395B0: using guessed type int dword_1400395B0;

//----- (000000014001F70C) ----------------------------------------------------
void __fastcall sub_14001F70C(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rcx
  _QWORD *v3; // rdx
  __int64 v4; // rcx

  v1 = a1;
  ExAcquireFastMutex(&stru_14002B6A8);
  if ( (unsigned __int64)(v1[3] - 1i64) <= 0xFFFFFFFFFFFFFFFDui64 )
  {
    v2 = v1[4];
    if ( *(_QWORD **)(v2 + 8) != v1 + 4 || (v3 = (_QWORD *)v1[5], (_QWORD *)*v3 != v1 + 4) )
      __fastfail(3u);
    *v3 = v2;
    *(_QWORD *)(v2 + 8) = v3;
    v1[3] = 0i64;
  }
  sub_140003684((__int64)(v1 + 6));
  v4 = v1[11];
  if ( v4 )
  {
    sub_140005984(v4);
    v1[11] = 0i64;
  }
  _InterlockedDecrement(&dword_1400395B0);
  ExReleaseFastMutex(&stru_14002B6A8);
}
// 1400395B0: using guessed type int dword_1400395B0;

//----- (000000014001F79C) ----------------------------------------------------
void __fastcall sub_14001F79C(__int64 a1, char a2)
{
  __int64 v2; // rdi
  char v3; // bl

  v2 = a1;
  v3 = a2;
  ExAcquireFastMutex(&stru_14002B6A8);
  if ( v3 )
  {
    *(_BYTE *)(v2 + 20) = 1;
  }
  else if ( *(_BYTE *)(v2 + 20) )
  {
    sub_14001FD78(v2);
    *(_BYTE *)(v2 + 20) = 0;
  }
  ExReleaseFastMutex(&stru_14002B6A8);
}

//----- (000000014001F7F8) ----------------------------------------------------
void __fastcall sub_14001F7F8(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  int v4; // eax
  int v5; // eax

  v2 = a1;
  v3 = a2;
  ExAcquireFastMutex(&stru_14002B6A8);
  if ( *(_BYTE *)(v2 + 21) && (unsigned __int8)MmCanFileBeTruncated(*(_QWORD *)(v3 + 40), &unk_140029048) )
  {
    v4 = *(_DWORD *)(v2 + 96);
    *(_BYTE *)(v2 + 21) = 0;
    if ( v4 )
    {
      v5 = v4 - 1;
      *(_DWORD *)(v2 + 96) = v5;
      if ( !v5 )
        sub_1400038AC(v2 + 48);
    }
    else
    {
      sub_14000374C(v2 + 48);
    }
  }
  ExReleaseFastMutex(&stru_14002B6A8);
}
// 140028660: using guessed type __int64 __fastcall MmCanFileBeTruncated(_QWORD, _QWORD);

//----- (000000014001F880) ----------------------------------------------------
void __fastcall sub_14001F880(__int64 a1, char a2)
{
  __int64 v2; // rbx
  char v3; // di
  _QWORD *v4; // rcx
  signed __int64 v5; // rax
  __int64 v6; // r8
  _QWORD *v7; // r9
  signed __int64 v8; // rdx

  v2 = a1;
  v3 = a2;
  ExAcquireFastMutex(&stru_14002B6A8);
  v4 = *(_QWORD **)(v2 + 8);
  *(_BYTE *)v2 = 1;
  while ( v4 != (_QWORD *)(v2 + 8) )
  {
    v5 = (signed __int64)(v4 - 4);
    v4 = (_QWORD *)*v4;
    if ( !v5 )
      break;
    v6 = *(_QWORD *)(v5 + 32);
    if ( *(_QWORD *)(v6 + 8) != v5 + 32 || (v7 = *(_QWORD **)(v5 + 40), *v7 != v5 + 32) )
      __fastfail(3u);
    *v7 = v6;
    *(_QWORD *)(v6 + 8) = v7;
    if ( v3 )
    {
      v8 = 0i64;
    }
    else
    {
      *(_BYTE *)(v5 + 80) = 1;
      v8 = -1i64;
    }
    *(_QWORD *)(v5 + 24) = v8;
  }
  ExReleaseFastMutex(&stru_14002B6A8);
}

//----- (000000014001F918) ----------------------------------------------------
__int64 __fastcall sub_14001F918(_QWORD *a1, __int64 *a2)
{
  _QWORD *v2; // rdi
  __int64 *v3; // rbx
  __int64 result; // rax
  unsigned int v5; // edi
  __int64 v6; // rdi
  __int64 v7; // [rsp+40h] [rbp+8h]

  v2 = a1;
  v3 = a2;
  if ( !(unsigned __int8)FltSupportsStreamContexts(a1[4]) )
    return 3221225659i64;
  result = FltAllocateContext(v2[1], 8i64, 104i64, 1i64, &v7);
  if ( (signed int)result >= 0 )
  {
    sub_14001F6B8(v7);
    v5 = FltSetStreamContext(v2[3], v2[4], 1i64, v7, 0i64);
    if ( (v5 & 0x80000000) == 0 )
    {
      v6 = v7;
      if ( *v3 )
        FltReleaseContext(*v3);
      *v3 = v6;
      result = 0i64;
    }
    else
    {
      FltReleaseContext(v7);
      result = v5;
    }
  }
  return result;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 140021652: using guessed type __int64 __fastcall FltAllocateContext(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400216FA: using guessed type __int64 __fastcall FltSupportsStreamContexts(_QWORD);
// 140021706: using guessed type __int64 __fastcall FltSetStreamContext(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014001F9C0) ----------------------------------------------------
void __fastcall sub_14001F9C0(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  unsigned __int64 v5; // rsi

  v3 = a1;
  v4 = a3;
  v5 = a2;
  ExAcquireFastMutex(&stru_14002B6A8);
  sub_14000379C(v3 + 48, v5, v4);
  ExReleaseFastMutex(&stru_14002B6A8);
}

//----- (000000014001FA1C) ----------------------------------------------------
bool __fastcall sub_14001FA1C(__int64 a1, __int64 a2, _QWORD *a3, char *a4)
{
  __int64 v4; // rbp
  char *v5; // rbx
  _QWORD *v6; // r14
  __int64 v7; // r15
  char v8; // di
  bool v9; // si

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = 0;
  v9 = 0;
  ExAcquireFastMutex(&stru_14002B6A8);
  if ( *(_QWORD *)(v4 + 24) == -1i64 )
  {
    *v6 = 0i64;
    v8 = 1;
  }
  else
  {
    v9 = sub_1400036C0(v4 + 48, v7, v6) != 0;
  }
  ExReleaseFastMutex(&stru_14002B6A8);
  if ( v5 )
    *v5 = v8;
  return v9;
}

//----- (000000014001FAB8) ----------------------------------------------------
void __fastcall sub_14001FAB8(_DWORD *a1, int a2)
{
  _DWORD *v2; // rbx
  int v3; // edi

  v2 = a1;
  v3 = a2;
  ExAcquireFastMutex(&stru_14002B6A8);
  if ( *v2 == 3 && v2[3] == v3 )
    *v2 = 0;
  ExReleaseFastMutex(&stru_14002B6A8);
}

//----- (000000014001FB04) ----------------------------------------------------
char __fastcall sub_14001FB04(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  ExAcquireFastMutex(&stru_14002B6A8);
  LOBYTE(v1) = *(_BYTE *)(v1 + 100);
  ExReleaseFastMutex(&stru_14002B6A8);
  return v1;
}

//----- (000000014001FB40) ----------------------------------------------------
__int64 __fastcall sub_14001FB40(__int64 a1, __int64 a2, _BYTE *a3)
{
  _BYTE *v3; // rbx
  int v4; // eax
  __int64 v6; // [rsp+40h] [rbp+18h]

  v3 = a3;
  v4 = FltGetStreamContext(a1, a2, &v6);
  if ( v3 )
  {
    if ( v4 == -1073741275 )
    {
      *v3 = 1;
      return 0i64;
    }
    *v3 = 0;
  }
  if ( v4 < 0 )
    return 0i64;
  return v6;
}
// 140021712: using guessed type __int64 __fastcall FltGetStreamContext(_QWORD, _QWORD, _QWORD);

//----- (000000014001FB7C) ----------------------------------------------------
__int64 sub_14001FB7C()
{
  return (unsigned int)dword_1400395B0;
}
// 1400395B0: using guessed type int dword_1400395B0;

//----- (000000014001FB84) ----------------------------------------------------
char __fastcall sub_14001FB84(__int64 a1, int a2, _DWORD *a3, _BYTE *a4)
{
  __int64 v4; // rdi
  _BYTE *v5; // rsi
  _DWORD *v6; // r14
  int v7; // ebp
  char v8; // bl
  int v9; // eax

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  ExAcquireFastMutex(&stru_14002B6A8);
  v8 = 0;
  if ( v5 )
    *v5 = 0;
  if ( *(_QWORD *)(v4 + 24) == -1i64 )
  {
    if ( v5 )
      *v5 = 1;
    *v6 = *(_DWORD *)(v4 + 12) - 1;
  }
  else if ( *(_DWORD *)(v4 + 16) != v7 || *(_DWORD *)v4 )
  {
    if ( *(_DWORD *)(v4 + 4) || *(_DWORD *)(v4 + 8) || *(_BYTE *)(v4 + 21) )
    {
      *v6 = *(_DWORD *)(v4 + 12) - 1;
    }
    else
    {
      v9 = ++*(_DWORD *)(v4 + 12);
      *(_DWORD *)v4 = 3;
      *v6 = v9;
      *(_DWORD *)(v4 + 16) = v7;
    }
  }
  else
  {
    v8 = 1;
  }
  ExReleaseFastMutex(&stru_14002B6A8);
  return v8;
}

//----- (000000014001FC48) ----------------------------------------------------
char __fastcall sub_14001FC48(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  ExAcquireFastMutex(&stru_14002B6A8);
  LOBYTE(v1) = *(_BYTE *)(v1 + 80);
  ExReleaseFastMutex(&stru_14002B6A8);
  return v1;
}

//----- (000000014001FC84) ----------------------------------------------------
char __fastcall sub_14001FC84(__m128i *a1, __int64 a2, int a3, char *a4, bool *a5)
{
  __m128i *v5; // rdi
  char *v6; // r14
  int v7; // esi
  __int64 v8; // rbx
  _BYTE *v9; // rax
  char v10; // bl

  v5 = a1;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  ExAcquireFastMutex(&stru_14002B6A8);
  v9 = (_BYTE *)sub_140005BB8(v5, v8);
  v10 = 0;
  if ( v9 )
  {
    *a5 = *v9 != 0;
    if ( !*((_QWORD *)v9 - 7) && *((_DWORD *)v9 - 16) == v7 && !*((_DWORD *)v9 - 20) )
      v10 = 1;
    *v6 = v10;
    v10 = 1;
  }
  ExReleaseFastMutex(&stru_14002B6A8);
  return v10;
}

//----- (000000014001FD1C) ----------------------------------------------------
void __fastcall sub_14001FD1C(__int64 a1, __m128i *a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  __m128i *v5; // rsi

  v3 = a1;
  v4 = a3;
  v5 = a2;
  ExAcquireFastMutex(&stru_14002B6A8);
  sub_14000A1E8(v3 + 80, v5, v4);
  ExReleaseFastMutex(&stru_14002B6A8);
}

//----- (000000014001FD78) ----------------------------------------------------
void __fastcall sub_14001FD78(__int64 a1)
{
  __int64 v1; // rbx
  bool v2; // zf

  v1 = a1;
  if ( !*(_BYTE *)(a1 + 21) )
  {
    v2 = ++*(_DWORD *)(a1 + 96) == 1;
    *(_BYTE *)(a1 + 21) = 1;
    if ( v2 )
      sub_14000362C((_BYTE *)(a1 + 48));
    *(_BYTE *)(v1 + 80) = 1;
    *(_DWORD *)v1 = 2;
  }
}

//----- (000000014001FDB0) ----------------------------------------------------
void __fastcall sub_14001FDB0(_DWORD *a1)
{
  _DWORD *v1; // rbx
  int v2; // eax
  int v3; // eax
  int v4; // eax

  v1 = a1;
  ExAcquireFastMutex(&stru_14002B6A8);
  v2 = v1[2];
  if ( v2 )
    v1[2] = v2 - 1;
  else
    *v1 = 2;
  v3 = v1[24];
  if ( v3 )
  {
    v4 = v3 - 1;
    v1[24] = v4;
    if ( !v4 )
      sub_1400038AC((__int64)(v1 + 12));
  }
  else
  {
    sub_14000374C((__int64)(v1 + 12));
  }
  ExReleaseFastMutex(&stru_14002B6A8);
}

//----- (000000014001FE1C) ----------------------------------------------------
void __fastcall sub_14001FE1C(_DWORD *a1)
{
  _DWORD *v1; // rbx

  v1 = a1;
  ExAcquireFastMutex(&stru_14002B6A8);
  *v1 = 2;
  ExReleaseFastMutex(&stru_14002B6A8);
}

//----- (000000014001FE58) ----------------------------------------------------
void __fastcall sub_14001FE58(__int64 a1, char a2)
{
  __int64 v2; // rbx
  char v3; // di

  v2 = a1;
  v3 = a2;
  ExAcquireFastMutex(&stru_14002B6A8);
  *(_BYTE *)(v2 + 100) = v3;
  ExReleaseFastMutex(&stru_14002B6A8);
}

//----- (000000014001FE9C) ----------------------------------------------------
void __fastcall sub_14001FE9C(__int64 a1, _BYTE **a2)
{
  __int64 v2; // rbx
  _BYTE **v3; // rdi
  _BYTE *v4; // rcx
  _BYTE *v5; // rax
  __int64 v6; // rcx
  _QWORD *v7; // rdx
  _QWORD *v8; // rbx
  signed __int64 v9; // rax
  __int64 v10; // rcx

  v2 = a1;
  v3 = a2;
  ExAcquireFastMutex(&stru_14002B6A8);
  v4 = *v3;
  if ( !*v3 || !*v4 )
  {
    v5 = *(_BYTE **)(v2 + 24);
    if ( v4 != v5 )
    {
      if ( v5 == (_BYTE *)-1i64 )
      {
        *(_QWORD *)(v2 + 24) = 0i64;
        *(_DWORD *)v2 = 2;
        sub_14000374C(v2 + 48);
        *(_BYTE *)(v2 + 80) = 1;
      }
      else if ( v5 )
      {
        v6 = *(_QWORD *)(v2 + 32);
        if ( *(_QWORD *)(v6 + 8) != v2 + 32 || (v7 = *(_QWORD **)(v2 + 40), *v7 != v2 + 32) )
LABEL_12:
          __fastfail(3u);
        *v7 = v6;
        *(_QWORD *)(v6 + 8) = v7;
        *(_QWORD *)(v2 + 24) = 0i64;
      }
      if ( *v3 )
      {
        *(_QWORD *)(v2 + 24) = *v3;
        v8 = (_QWORD *)(v2 + 32);
        v9 = (signed __int64)(*v3 + 8);
        v10 = *(_QWORD *)v9;
        if ( *(_QWORD *)(*(_QWORD *)v9 + 8i64) != v9 )
          goto LABEL_12;
        *v8 = v10;
        v8[1] = v9;
        *(_QWORD *)(v10 + 8) = v8;
        *(_QWORD *)v9 = v8;
      }
    }
  }
  ExReleaseFastMutex(&stru_14002B6A8);
}

//----- (000000014001FF74) ----------------------------------------------------
void __fastcall sub_14001FF74(__int64 a1)
{
  __int64 v1; // rbx
  int v2; // eax
  bool v3; // zf

  v1 = a1;
  ExAcquireFastMutex(&stru_14002B6A8);
  v2 = *(_DWORD *)(v1 + 8);
  if ( !v2 )
    *(_DWORD *)v1 = 2;
  v3 = ++*(_DWORD *)(v1 + 96) == 1;
  *(_DWORD *)(v1 + 8) = v2 + 1;
  if ( v3 )
    sub_14000362C((_BYTE *)(v1 + 48));
  ExReleaseFastMutex(&stru_14002B6A8);
}

//----- (000000014001FFCC) ----------------------------------------------------
void __fastcall sub_14001FFCC(__int64 a1)
{
  __int64 v1; // rbx
  int v2; // eax
  bool v3; // zf

  v1 = a1;
  ExAcquireFastMutex(&stru_14002B6A8);
  v2 = *(_DWORD *)(v1 + 4);
  if ( !v2 )
    *(_DWORD *)v1 = 2;
  v3 = ++*(_DWORD *)(v1 + 96) == 1;
  *(_DWORD *)(v1 + 4) = v2 + 1;
  if ( v3 )
    sub_14000362C((_BYTE *)(v1 + 48));
  *(_BYTE *)(v1 + 80) = 1;
  ExReleaseFastMutex(&stru_14002B6A8);
}

//----- (0000000140020028) ----------------------------------------------------
void __fastcall sub_140020028(_DWORD *a1)
{
  _DWORD *v1; // rbx
  int v2; // eax
  int v3; // eax
  int v4; // eax

  v1 = a1;
  ExAcquireFastMutex(&stru_14002B6A8);
  v2 = v1[1];
  if ( v2 )
    v1[1] = v2 - 1;
  else
    *v1 = 2;
  v3 = v1[24];
  if ( v3 )
  {
    v4 = v3 - 1;
    v1[24] = v4;
    if ( !v4 )
      sub_1400038AC((__int64)(v1 + 12));
  }
  else
  {
    sub_14000374C((__int64)(v1 + 12));
  }
  ExReleaseFastMutex(&stru_14002B6A8);
}

//----- (0000000140020094) ----------------------------------------------------
__int64 __fastcall sub_140020094(__int64 a1)
{
  __int64 v1; // rcx
  signed int v2; // eax
  signed int v3; // edi
  _DWORD *v4; // rax
  _DWORD *v5; // rbx
  __int64 v7; // [rsp+80h] [rbp-19h]
  char v8; // [rsp+88h] [rbp-11h]
  int v9; // [rsp+98h] [rbp-1h]
  __int64 v10; // [rsp+A0h] [rbp+7h]
  __int64 v11; // [rsp+A8h] [rbp+Fh]
  int v12; // [rsp+B0h] [rbp+17h]
  __int128 v13; // [rsp+B8h] [rbp+1Fh]
  char v14; // [rsp+100h] [rbp+67h]
  PVOID Object; // [rsp+108h] [rbp+6Fh]
  __int64 v16; // [rsp+110h] [rbp+77h]
  __int64 v17; // [rsp+118h] [rbp+7Fh]

  v11 = a1;
  v1 = qword_140038478;
  v9 = 48;
  v10 = 0i64;
  v12 = 576;
  _mm_storeu_si128((__m128i *)&v13, (__m128i)0i64);
  v7 = 0i64;
  Object = 0i64;
  v2 = FltCreateFileEx(v1, 0i64, &v7, &Object, 0, &v9, &v8, 0i64, 0, 7, 1, 256, 0i64, 0, 2048);
  v3 = v2;
  if ( v2 >= 0 )
  {
    if ( v2 == 264 )
    {
      v3 = -1073741823;
LABEL_16:
      ObfDereferenceObject(Object);
      FltClose(v7);
      return (unsigned int)v3;
    }
    v17 = 0i64;
    v3 = FltGetVolumeFromFileObject(qword_140038478, Object, &v17);
    if ( v3 < 0 )
    {
LABEL_14:
      if ( v17 )
        FltObjectDereference();
      goto LABEL_16;
    }
    v16 = 0i64;
    v3 = FltGetVolumeInstanceFromName(qword_140038478, v17, asc_14002B158, &v16);
    if ( v3 >= 0 )
    {
      v14 = 0;
      v4 = (_DWORD *)sub_14001FB40(v16, (__int64)Object, &v14);
      v5 = v4;
      if ( v4 )
      {
        sub_14001FE1C(v4);
        goto LABEL_10;
      }
      if ( !v14 )
      {
        v3 = -1073741823;
LABEL_10:
        if ( v5 )
          FltReleaseContext(v5);
        goto LABEL_12;
      }
    }
LABEL_12:
    if ( v16 )
      FltObjectDereference();
    goto LABEL_14;
  }
  return (unsigned int)v3;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 14002156E: using guessed type __int64 __fastcall FltClose(_QWORD);
// 140021622: using guessed type __int64 __fastcall FltCreateFileEx(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400216A6: using guessed type __int64 FltObjectDereference(void);
// 1400216EE: using guessed type __int64 __fastcall FltGetVolumeFromFileObject(_QWORD, _QWORD, _QWORD);
// 14002171E: using guessed type __int64 __fastcall FltGetVolumeInstanceFromName(_QWORD, _QWORD, _QWORD, _QWORD);
// 14002B158: using guessed type wchar_t asc_14002B158[3];
// 140038478: using guessed type __int64 qword_140038478;

//----- (0000000140020218) ----------------------------------------------------
char __fastcall sub_140020218(__m128i *a1, __int64 a2, int a3, bool *a4, bool *a5)
{
  bool *v5; // rbx
  char v7; // [rsp+30h] [rbp-18h]
  char v8; // [rsp+50h] [rbp+8h]

  v5 = a4;
  if ( !a1 || !sub_14001FC84(a1, a2, a3, &v8, (bool *)&v7) )
    return 0;
  if ( v5 )
    *v5 = v8 != 0;
  if ( a5 )
    *a5 = v7 != 0;
  return 1;
}

//----- (0000000140020270) ----------------------------------------------------
_QWORD *__fastcall sub_140020270(_QWORD *a1, __int64 a2, void *a3, _WORD *a4, __int64 *a5, __int64 a6, int a7, _WORD *a8)
{
  _QWORD *v8; // rbx
  _WORD *v9; // rsi
  void *v10; // rdi
  __int64 v11; // rcx
  __int64 v12; // rcx

  v8 = a1;
  *a1 = &off_140029050;
  v9 = a4;
  v10 = a3;
  a1[1] = &off_140028B58;
  v11 = *(_QWORD *)(a2 + 8);
  v8[2] = v11;
  if ( v11 )
    sub_14001B77C(v11);
  v8[3] = v10;
  *((_WORD *)v8 + 16) = *v9;
  v12 = *a5;
  *a5 = 0i64;
  v8[5] = v12;
  v8[6] = a6;
  *((_DWORD *)v8 + 14) = a7;
  *((_WORD *)v8 + 30) = *a8;
  sub_140001A20((__int64)(v8 + 8), 1);
  *((_DWORD *)v8 + 38) = 0;
  if ( v10 )
    ObfReferenceObject(v10);
  return v8;
}
// 140028B58: using guessed type __int64 (__fastcall *off_140028B58)(PSLIST_ENTRY ListEntry);
// 140029050: using guessed type __int64 (__fastcall *off_140029050)();

//----- (0000000140020324) ----------------------------------------------------
void **__fastcall sub_140020324(_QWORD *a1)
{
  _QWORD *v1; // rbx
  void *v2; // rcx
  void *v3; // rcx
  __int64 v4; // rcx

  v1 = a1;
  *a1 = &off_140029050;
  v2 = (void *)a1[6];
  if ( v2 )
  {
    ExFreePoolWithTag(v2, 0x45414349u);
    v1[6] = 0i64;
    *((_DWORD *)v1 + 14) = 0;
  }
  v3 = (void *)v1[3];
  if ( v3 )
    ObfDereferenceObject(v3);
  sub_140001B98((__int64)(v1 + 8));
  sub_14000BBE4((struct _SLIST_ENTRY *)v1[5]);
  v4 = v1[2];
  v1[1] = &off_140028B58;
  if ( v4 )
  {
    sub_14001A4D8(v4);
    v1[2] = 0i64;
  }
  sub_14001CE9C(v1 + 1);
  return sub_14001CE9C(v1);
}
// 14001A4D8: using guessed type __int64 __fastcall sub_14001A4D8(_QWORD);
// 140028B58: using guessed type __int64 (__fastcall *off_140028B58)(PSLIST_ENTRY ListEntry);
// 140029050: using guessed type __int64 (__fastcall *off_140029050)();

//----- (00000001400203C0) ----------------------------------------------------
void *__fastcall sub_1400203C0(_QWORD *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140020324(a1);
  if ( v2 & 1 )
    sub_14000AB20(v3);
  return v3;
}

//----- (00000001400203F4) ----------------------------------------------------
__int64 __fastcall sub_1400203F4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, void *a5, _WORD *a6, __int64 *a7, __int64 a8, unsigned int a9, _WORD *a10, _QWORD *a11)
{
  __int64 v11; // rdi
  __int64 v12; // rsi
  __int64 v13; // rbx
  __int64 v14; // r14
  __int64 result; // rax
  __int64 v16; // rax
  __int64 v17; // rcx
  int v18; // edx
  unsigned int v19; // ebx
  _QWORD *v20; // rdi
  int v21; // [rsp+40h] [rbp-20h]
  _QWORD *v22; // [rsp+48h] [rbp-18h]
  __int64 v23; // [rsp+50h] [rbp-10h]

  v11 = a1;
  v12 = a4;
  v13 = a3;
  v14 = a2;
  if ( !(unsigned __int8)FltSupportsStreamHandleContexts(a3) )
    return 3221225659i64;
  result = FltAllocateContext(v11, 16i64, 160i64, 1i64, &v22);
  if ( (signed int)result >= 0 )
  {
    v16 = *(_QWORD *)(v13 + 8);
    v17 = 0i64;
    v18 = 0;
    v23 = 0i64;
    v21 = 0;
    if ( v16 && !*(_QWORD *)(v16 + 56) )
    {
      sub_140008C24(a8, a9, (__m128i **)&v23, &v21);
      v17 = v23;
      v18 = v21;
    }
    sub_140020270(v22, v12, a5, a6, a7, v17, v18, a10);
    v19 = FltSetStreamHandleContext(v14, v13, 1i64, v22, 0i64);
    if ( (v19 & 0x80000000) == 0 )
    {
      v20 = v22;
      if ( *a11 )
        FltReleaseContext(*a11);
      *a11 = v20;
      result = 0i64;
    }
    else
    {
      FltReleaseContext(v22);
      result = v19;
    }
  }
  return result;
}
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 140021652: using guessed type __int64 __fastcall FltAllocateContext(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 14002172A: using guessed type __int64 __fastcall FltSupportsStreamHandleContexts(_QWORD);
// 140021736: using guessed type __int64 __fastcall FltSetStreamHandleContext(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140020520) ----------------------------------------------------
char __fastcall sub_140020520(__int64 a1)
{
  char result; // al

  result = *(_BYTE *)(a1 + 32);
  if ( !(result & 0x10) )
  {
    result &= 0xFCu;
    *(_BYTE *)(a1 + 32) = result;
  }
  return result;
}

//----- (0000000140020530) ----------------------------------------------------
__int64 __fastcall sub_140020530(__int64 a1, __int64 a2)
{
  int v2; // eax
  __int64 v3; // rcx
  __int64 v5; // [rsp+40h] [rbp+18h]

  v2 = FltGetStreamHandleContext(a1, a2, &v5);
  v3 = v5;
  if ( v2 < 0 )
    v3 = 0i64;
  return v3;
}
// 140021742: using guessed type __int64 __fastcall FltGetStreamHandleContext(_QWORD, _QWORD, _QWORD);

//----- (0000000140020554) ----------------------------------------------------
_QWORD *__fastcall sub_140020554(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rdi
  __int64 v4; // rcx

  v2 = a1;
  v3 = a2;
  ExAcquireFastMutex(&stru_14002B6E0);
  v4 = *(_QWORD *)(v2 + 16);
  *v3 = &off_140028B58;
  v3[1] = v4;
  if ( v4 )
    sub_14001B77C(v4);
  ExReleaseFastMutex(&stru_14002B6E0);
  return v3;
}
// 140028B58: using guessed type __int64 (__fastcall *off_140028B58)(PSLIST_ENTRY ListEntry);

//----- (00000001400205B4) ----------------------------------------------------
void __fastcall sub_1400205B4(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rcx
  __int64 v5; // rcx

  v2 = a1;
  v3 = a2;
  ExAcquireFastMutex(&stru_14002B6E0);
  if ( v2 + 8 != v3 )
  {
    v4 = *(_QWORD *)(v2 + 16);
    if ( v4 )
    {
      sub_14001A4D8(v4);
      *(_QWORD *)(v2 + 16) = 0i64;
    }
    v5 = *(_QWORD *)(v3 + 8);
    *(_QWORD *)(v2 + 16) = v5;
    if ( v5 )
      sub_14001B77C(v5);
  }
  *(_BYTE *)(v2 + 32) |= 0x40u;
  ExReleaseFastMutex(&stru_14002B6E0);
}
// 14001A4D8: using guessed type __int64 __fastcall sub_14001A4D8(_QWORD);

//----- (0000000140020630) ----------------------------------------------------
void __fastcall sub_140020630(__int64 a1, signed int a2)
{
  __int64 v2; // rbx
  signed int v3; // edi
  signed int v4; // eax

  v2 = a1;
  v3 = a2;
  ExAcquireFastMutex(&stru_14002B6E0);
  v4 = 3;
  if ( v3 != 3 && !*(_DWORD *)(v2 + 152) )
    v4 = v3;
  *(_DWORD *)(v2 + 152) = v4;
  ExReleaseFastMutex(&stru_14002B6E0);
}

//----- (0000000140020688) ----------------------------------------------------
char __fastcall sub_140020688(__int64 a1)
{
  char result; // al

  result = *(_BYTE *)(a1 + 32);
  if ( !(result & 0x10) )
  {
    result |= 8u;
    *(_BYTE *)(a1 + 32) = result;
  }
  return result;
}

//----- (00000001400206A0) ----------------------------------------------------
__int64 __fastcall sub_1400206A0(__int64 **a1)
{
  return sub_140021A40((__int64 (*)(void))**a1);
}

//----- (00000001400206B0) ----------------------------------------------------
__int64 sub_1400206B0()
{
  char v0; // al
  int v2; // [rsp+30h] [rbp+8h]

  v0 = sub_1400095B8((UNICODE_STRING *)aAa, off_14002B730, &v2);
  return v2 & (unsigned int)-(v0 != 0);
}
// 14002B718: using guessed type wchar_t aAa[3];
// 14002B730: using guessed type wchar_t *off_14002B730;

//----- (00000001400206DC) ----------------------------------------------------
char sub_1400206DC()
{
  char v1; // [rsp+30h] [rbp+8h]

  return sub_1400095B8((UNICODE_STRING *)aAa, off_14002B730, &v1);
}
// 14002B718: using guessed type wchar_t aAa[3];
// 14002B730: using guessed type wchar_t *off_14002B730;

//----- (0000000140020700) ----------------------------------------------------
__int64 __fastcall sub_140020700(__int64 a1)
{
  *(_QWORD *)a1 = off_140029170;
  *(_BYTE *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_QWORD *)(a1 + 32) = 0i64;
  return a1;
}
// 140029170: using guessed type __int64 (__fastcall *off_140029170[2])();

//----- (0000000140020724) ----------------------------------------------------
void **__fastcall sub_140020724(__int64 a1)
{
  _QWORD *v1; // rbx
  void *v2; // rcx
  void **result; // rax

  *(_QWORD *)a1 = off_140029170;
  v1 = (_QWORD *)a1;
  *(_DWORD *)(a1 + 24) = 0;
  v2 = *(void **)(a1 + 32);
  if ( v2 )
    ExFreePoolWithTag(v2, 0);
  v1[4] = 0i64;
  result = &off_140029160;
  *v1 = &off_140029160;
  return result;
}
// 140029160: using guessed type void *off_140029160;
// 140029170: using guessed type __int64 (__fastcall *off_140029170[2])();

//----- (0000000140020770) ----------------------------------------------------
_QWORD *__fastcall sub_140020770(_QWORD *a1, char a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  *a1 = &off_140029160;
  if ( a2 & 1 )
    sub_14000AB20(a1);
  return v2;
}
// 140029160: using guessed type void *off_140029160;

//----- (00000001400207A0) ----------------------------------------------------
void *__fastcall sub_1400207A0(__int64 a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = (void *)a1;
  sub_140020724(a1);
  if ( v2 & 1 )
    sub_14000AB20(v3);
  return v3;
}

//----- (00000001400207D4) ----------------------------------------------------
void __fastcall sub_1400207D4(__int64 a1, const UNICODE_STRING *a2)
{
  __int64 v2; // rbx
  UNICODE_STRING *v3; // rdi
  signed __int64 v4; // rax
  int v5; // [rsp+38h] [rbp+10h]

  if ( a2 )
  {
    v2 = a1;
    if ( !*(_BYTE *)(a1 + 8) )
    {
      v3 = (UNICODE_STRING *)(a1 + 24);
      sub_14001D8D4((PUNICODE_STRING)(a1 + 24), a2);
      if ( v3->Length )
      {
        if ( sub_1400095B8(v3, L"SkippedFileCount", &v5) )
        {
          *(_DWORD *)(v2 + 12) = v5;
          *(_DWORD *)(v2 + 16) = *(_DWORD *)(v2 + 12);
        }
        if ( sub_1400095B8(v3, L"DayNumber", &v5) )
          LODWORD(v4) = v5;
        else
          v4 = MEMORY[0xFFFFF78000000014] / 864000000000i64;
        *(_DWORD *)(v2 + 20) = v4;
        *(_BYTE *)(v2 + 8) = 1;
      }
    }
  }
}
// 1400276D0: using guessed type wchar_t aSkippedfilecou[17];
// 140027700: using guessed type wchar_t aDaynumber[10];

//----- (0000000140020880) ----------------------------------------------------
void __fastcall sub_140020880(__int64 a1)
{
  if ( *(_BYTE *)(a1 + 8) )
    _InterlockedIncrement((volatile signed __int32 *)(a1 + 12));
}

//----- (000000014002088C) ----------------------------------------------------
void __fastcall sub_14002088C(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rcx

  v1 = a1;
  if ( *(_BYTE *)(a1 + 8) )
  {
    sub_140020990(a1);
    sub_140020904(v1);
    v2 = *(void **)(v1 + 32);
    *(_DWORD *)(v1 + 24) = 0;
    if ( v2 )
      ExFreePoolWithTag(v2, 0);
    *(_QWORD *)(v1 + 32) = 0i64;
    *(_BYTE *)(v1 + 8) = 0;
  }
}

//----- (00000001400208E0) ----------------------------------------------------
char __fastcall sub_1400208E0(__int64 a1)
{
  __int64 v1; // rbx
  char result; // al

  v1 = a1;
  if ( *(_BYTE *)(a1 + 8) )
  {
    sub_140020990(a1);
    result = sub_140020904(v1);
  }
  return result;
}

//----- (0000000140020904) ----------------------------------------------------
char __fastcall sub_140020904(__int64 a1)
{
  __int64 v1; // rsi
  signed __int64 v2; // rax
  int v3; // ebx

  v1 = a1;
  v2 = MEMORY[0xFFFFF78000000014] / 864000000000i64;
  if ( (unsigned __int64)(MEMORY[0xFFFFF78000000014] / 864000000000i64) != *(_DWORD *)(a1 + 20) )
  {
    v3 = _InterlockedExchange((volatile signed __int32 *)(a1 + 12), 0);
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = v2;
    sub_140009B74((UNICODE_STRING *)(a1 + 24), L"DayNumber", v2);
    sub_140009B74((UNICODE_STRING *)(v1 + 24), L"SkippedFileCountForDay", v3);
    LOBYTE(v2) = sub_140009B74((UNICODE_STRING *)(v1 + 24), L"SkippedFileCount", *(_DWORD *)(v1 + 12));
  }
  return v2;
}
// 1400276D0: using guessed type wchar_t aSkippedfilecou[17];
// 140027700: using guessed type wchar_t aDaynumber[10];
// 140027720: using guessed type wchar_t aSkippedfilecou_0[23];

//----- (0000000140020990) ----------------------------------------------------
bool __fastcall sub_140020990(__int64 a1)
{
  int v1; // edi
  __int64 v2; // rbx
  bool result; // al

  v1 = *(_DWORD *)(a1 + 12);
  v2 = a1;
  if ( v1 != *(_DWORD *)(a1 + 16) )
  {
    result = sub_140009B74((UNICODE_STRING *)(a1 + 24), L"SkippedFileCount", v1);
    *(_DWORD *)(v2 + 16) = v1;
  }
  return result;
}
// 1400276D0: using guessed type wchar_t aSkippedfilecou[17];

//----- (00000001400209C8) ----------------------------------------------------
__int64 __fastcall sub_1400209C8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5, char a6)
{
  _QWORD *v6; // rax
  _QWORD *v7; // rdx

  *(_BYTE *)(a1 + 40) = a5;
  *(_BYTE *)(a1 + 41) = a6;
  v6 = (_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 32) = a4;
  v7 = off_14002B738;
  if ( *((void ***)off_14002B738 + 1) != &off_14002B738 )
    __fastfail(3u);
  *v6 = off_14002B738;
  *(_QWORD *)(a1 + 24) = &off_14002B738;
  v7[1] = v6;
  off_14002B738 = (void *)(a1 + 16);
  return a1;
}
// 14002B738: using guessed type void *off_14002B738;

//----- (0000000140020A18) ----------------------------------------------------
signed __int64 __fastcall sub_140020A18(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rcx
  signed __int64 result; // rax
  __int64 v4; // rdx
  _QWORD *v5; // rcx

  v1 = a1;
  v2 = *(void **)(a1 + 32);
  if ( v2 )
    ExFreePoolWithTag(v2, 0);
  result = v1 + 16;
  v4 = *(_QWORD *)(v1 + 16);
  if ( *(_QWORD *)(v4 + 8) != v1 + 16 || (v5 = *(_QWORD **)(v1 + 24), *v5 != result) )
    __fastfail(3u);
  *v5 = v4;
  *(_QWORD *)(v4 + 8) = v5;
  return result;
}

//----- (0000000140020A64) ----------------------------------------------------
__int64 sub_140020A64()
{
  __int64 result; // rax

  ++stru_1400395C0.L.TotalAllocates;
  result = (__int64)ExpInterlockedPopEntrySList(&stru_1400395C0.L.ListHead);
  if ( !result )
  {
    ++stru_1400395C0.L.AllocateMisses;
    result = sub_140021A40((__int64 (*)(void))stru_1400395C0.L.Allocate);
  }
  return result;
}

//----- (0000000140020AB4) ----------------------------------------------------
void __fastcall sub_140020AB4(PSLIST_ENTRY ListEntry)
{
  struct _SLIST_ENTRY *v1; // rbx

  if ( ListEntry )
  {
    ++stru_1400395C0.L.TotalFrees;
    v1 = ListEntry;
    if ( ExQueryDepthSList(&stru_1400395C0.L.ListHead) < stru_1400395C0.L.Depth )
    {
      ExpInterlockedPushEntrySList(&stru_1400395C0.L.ListHead, v1);
    }
    else
    {
      ++stru_1400395C0.L.FreeMisses;
      sub_140021A40((__int64 (*)(void))stru_1400395C0.L.Free);
    }
  }
}

//----- (0000000140020B18) ----------------------------------------------------
__int64 sub_140020B18()
{
  __int64 result; // rax

  result = 0i64;
  if ( !byte_140039640 )
    result = sub_14000E308(0, (__int64)sub_140020DB0);
  byte_140039640 = (signed int)result >= 0;
  byte_140039641 = (signed int)result >= 0;
  return result;
}
// 140039640: using guessed type char byte_140039640;
// 140039641: using guessed type char byte_140039641;

//----- (0000000140020B50) ----------------------------------------------------
__int64 __fastcall sub_140020B50(const UNICODE_STRING *a1, char a2, char a3)
{
  unsigned int v3; // ebx
  char v4; // r14
  char v5; // r15
  const UNICODE_STRING *v6; // rsi
  __int64 result; // rax
  USHORT v8; // bp
  UNICODE_STRING *v9; // rax
  UNICODE_STRING *v10; // rdi
  __int64 v11; // rcx
  void *v12; // rbp
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  void *v16; // r12
  void **v17; // rax
  void **v18; // rsi
  __int64 v19; // rax
  __int64 v20; // rax
  ULONG_PTR BugCheckParameter3; // [rsp+20h] [rbp-38h]

  v3 = 0;
  v4 = a3;
  v5 = a2;
  v6 = a1;
  if ( !byte_140039641 )
    return 3221225473i64;
  if ( !a1 )
    return 3221225485i64;
  v8 = a1->Length;
  if ( a1->Length < 2u )
    v8 = 2;
  v9 = (UNICODE_STRING *)ExAllocatePoolWithTag(PagedPool, v8 + 16i64, 0x63745352u);
  v10 = v9;
  if ( v9 )
  {
    *(_QWORD *)&v9->Length = 0i64;
    v9->MaximumLength = v8;
    v9->Buffer = &v9[1].Length;
    RtlCopyUnicodeString(v9, v6);
    v12 = (void *)PsGetCurrentProcessId(v11);
    v16 = (void *)PsGetCurrentThreadId(v14, v13, v15);
    ExAcquireFastMutex(&stru_14002B748);
    v17 = sub_140020DF4(v12, v16);
    v18 = v17;
    if ( v17 )
    {
      ExFreePoolWithTag(v17[4], 0);
      v18[4] = v10;
      *((_BYTE *)v18 + 40) = v5;
      *((_BYTE *)v18 + 41) = v4;
    }
    else
    {
      v19 = sub_140020A64();
      if ( v19 )
        v20 = sub_1400209C8(v19, (__int64)v12, (__int64)v16, (__int64)v10, v5, v4);
      else
        v20 = 0i64;
      if ( !v20 )
      {
        ExFreePoolWithTag(v10, 0);
        v3 = -1073741670;
      }
    }
    ExReleaseFastMutex(&stru_14002B748);
    result = v3;
  }
  else
  {
    LODWORD(BugCheckParameter3) = -1073741670;
    sub_140006BB4(0x213ui64, 0x6Bui64, 0i64, 0xE03D0047, BugCheckParameter3, (char)v6);
    result = 3221225626i64;
  }
  return result;
}
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 1400284E8: using guessed type __int64 __fastcall PsGetCurrentThreadId(_QWORD, _QWORD, _QWORD);
// 140039641: using guessed type char byte_140039641;

//----- (0000000140020D08) ----------------------------------------------------
void __fastcall sub_140020D08(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rsi
  void **v4; // rdi
  __int64 v5; // rbx

  v2 = a1;
  v3 = a2;
  ExAcquireFastMutex(&stru_14002B748);
  v4 = (void **)off_14002B738;
  while ( v4 != &off_14002B738 )
  {
    v5 = (__int64)(v4 - 2);
    v4 = (void **)*v4;
    if ( !v5 )
      break;
    if ( !v2 || *(_QWORD *)v5 == v2 && (!v3 || *(_QWORD *)(v5 + 8) == v3) )
    {
      sub_140020A18(v5);
      sub_140020AB4((PSLIST_ENTRY)v5);
    }
  }
  ExReleaseFastMutex(&stru_14002B748);
}
// 14002B738: using guessed type void *off_14002B738;

//----- (0000000140020DB0) ----------------------------------------------------
void __fastcall sub_140020DB0(__int64 a1, __int64 a2, char a3)
{
  if ( !a3 )
    sub_140020D08(a1, a2);
}

//----- (0000000140020DC4) ----------------------------------------------------
void sub_140020DC4()
{
  byte_140039641 = 0;
  sub_140020D08(0i64, 0i64);
  if ( byte_140039640 )
    sub_14000E410(0);
  byte_140039640 = 0;
}
// 140039640: using guessed type char byte_140039640;
// 140039641: using guessed type char byte_140039641;

//----- (0000000140020DF4) ----------------------------------------------------
void **__fastcall sub_140020DF4(void *a1, void *a2)
{
  void **v2; // r8
  void **result; // rax

  v2 = (void **)off_14002B738;
  while ( v2 != &off_14002B738 )
  {
    result = v2 - 2;
    v2 = (void **)*v2;
    if ( !result )
      break;
    if ( *result == a1 && result[1] == a2 )
      return result;
  }
  return 0i64;
}
// 14002B738: using guessed type void *off_14002B738;

//----- (0000000140020E24) ----------------------------------------------------
char __fastcall sub_140020E24(PCUNICODE_STRING String2, char a2, _BYTE *a3, _BYTE *a4)
{
  _BYTE *v4; // r14
  _BYTE *v5; // r15
  char v6; // si
  const UNICODE_STRING *v7; // rbp
  void *v8; // rdi
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  void *v12; // rbx
  void **v13; // rax
  __int64 v14; // rbx
  bool v15; // si
  char v16; // di

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = String2;
  v8 = (void *)PsGetCurrentProcessId(String2);
  v12 = (void *)PsGetCurrentThreadId(v10, v9, v11);
  ExAcquireFastMutex(&stru_14002B748);
  v13 = sub_140020DF4(v8, v12);
  v14 = (__int64)v13;
  v15 = v6 != 0 ? v13 != 0i64 : 0;
  if ( v13 && (v16 = 1, RtlEqualUnicodeString((PCUNICODE_STRING)v13[4], v7, 1u)) )
  {
    *v5 = *(_BYTE *)(v14 + 40);
    *v4 = *(_BYTE *)(v14 + 41);
  }
  else
  {
    v16 = 0;
  }
  if ( v15 && v14 )
  {
    sub_140020A18(v14);
    sub_140020AB4((PSLIST_ENTRY)v14);
  }
  ExReleaseFastMutex(&stru_14002B748);
  return v16;
}
// 140028288: using guessed type __int64 __cdecl PsGetCurrentProcessId(_QWORD);
// 1400284E8: using guessed type __int64 __fastcall PsGetCurrentThreadId(_QWORD, _QWORD, _QWORD);

//----- (0000000140020F14) ----------------------------------------------------
signed __int64 __fastcall sub_140020F14(_QWORD *a1, int a2, __int64 a3)
{
  __int64 v3; // rbp
  int v4; // er14
  void *v5; // rbx
  signed __int64 result; // rax
  _QWORD *v7; // rax
  _QWORD *v8; // rdi
  _QWORD *v9; // rsi
  HANDLE *v10; // rcx
  void *v11; // rdi

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( *a1 )
    return 3221226768i64;
  v7 = sub_14000E268(8ui64);
  v8 = v7;
  if ( v7 )
    *v7 = 0i64;
  else
    v8 = 0i64;
  if ( *((_BYTE *)v5 + 8) )
  {
    v9 = (_QWORD *)*((_QWORD *)v5 + 2);
    if ( v8 != v9 )
    {
      if ( v9 )
      {
        sub_14000E1E8(*((HANDLE **)v5 + 2));
        sub_14000AB20(v9);
      }
      *((_BYTE *)v5 + 8) = 0;
    }
  }
  if ( v8 )
  {
    *((_QWORD *)v5 + 2) = v8;
    *((_BYTE *)v5 + 8) = 1;
  }
  v10 = (HANDLE *)*((_QWORD *)v5 + 2);
  if ( !v10 )
    return 3221225495i64;
  *(_QWORD *)v5 = v3;
  *((_DWORD *)v5 + 14) = v4;
  if ( sub_14000E284(v10, (void (__stdcall *)(PVOID))sub_140021010, v5) )
  {
    *((_BYTE *)v5 + 24) = 1;
    result = 0i64;
  }
  else
  {
    if ( *((_BYTE *)v5 + 8) )
    {
      v11 = (void *)*((_QWORD *)v5 + 2);
      if ( v11 )
      {
        sub_14000E1E8(*((HANDLE **)v5 + 2));
        sub_14000AB20(v11);
        *((_BYTE *)v5 + 8) = 0;
      }
    }
    result = 3221225473i64;
  }
  return result;
}
// 140021010: using guessed type __int64 __fastcall sub_140021010();

//----- (0000000140021018) ----------------------------------------------------
void __fastcall sub_140021018(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rdi

  v1 = a1;
  if ( *(_BYTE *)(a1 + 24) )
  {
    KeSetEvent((PRKEVENT)(a1 + 32), 0, 0);
    if ( *(_BYTE *)(v1 + 8) )
    {
      v2 = *(void **)(v1 + 16);
      if ( v2 )
      {
        sub_14000E1E8(*(HANDLE **)(v1 + 16));
        sub_14000AB20(v2);
        *(_BYTE *)(v1 + 8) = 0;
      }
    }
    *(_BYTE *)(v1 + 24) = 0;
    KeClearEvent((PRKEVENT)(v1 + 32));
  }
}

//----- (000000014002108C) ----------------------------------------------------
NTSTATUS __fastcall sub_14002108C(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  void *v3; // rcx
  NTSTATUS result; // eax

  v1 = *(unsigned int *)(a1 + 56);
  v2 = a1;
  v3 = (void *)(a1 + 32);
  stru_140039648.QuadPart = -10000 * v1;
  while ( 1 )
  {
    result = KeWaitForSingleObject(v3, 0, 0, 0, &stru_140039648);
    if ( !result )
      break;
    sub_140021A40(***(__int64 (****)(void))v2);
    stru_140039648.QuadPart = -10000i64 * *(unsigned int *)(v2 + 56);
    v3 = (void *)(v2 + 32);
  }
  return result;
}

//----- (0000000140021110) ----------------------------------------------------
__int64 __fastcall sub_140021110(__int64 a1, __int64 *a2)
{
  __int64 *v2; // rdi
  __int64 v3; // rbx
  __int64 result; // rax
  __int64 v5; // rdx
  __int64 v6; // rcx
  _QWORD *v7; // rax
  unsigned int v8; // esi
  unsigned int v9; // ebx
  __int64 v10; // rbx
  __int64 v11; // [rsp+40h] [rbp+8h]

  v2 = a2;
  v3 = a1;
  result = FltAllocateContext(*(_QWORD *)(a1 + 8), 32i64, 40i64, 1i64, &v11);
  if ( (signed int)result >= 0 )
  {
    v5 = v11;
    v6 = *(_QWORD *)(v3 + 40);
    *(_QWORD *)(v11 + 24) = *(_QWORD *)(v3 + 24);
    v7 = (_QWORD *)(v5 + 8);
    *(_BYTE *)v5 = 0;
    *(_QWORD *)(v5 + 32) = v6;
    v7[1] = v7;
    *v7 = v7;
    v8 = FltSetTransactionContext(*(_QWORD *)(v3 + 24), *(_QWORD *)(v3 + 40), 1i64, v11, 0i64);
    if ( (v8 & 0x80000000) == 0 )
    {
      v9 = FltEnlistInTransaction(*(_QWORD *)(v3 + 24), *(_QWORD *)(v3 + 40), v11, 15i64);
      if ( (v9 & 0x80000000) == 0 )
      {
        v10 = v11;
        if ( *v2 )
          ((void (*)(void))FltReleaseContext)();
        *v2 = v10;
        result = 0i64;
      }
      else
      {
        FltDeleteContext(v11);
        FltReleaseContext(v11);
        result = v9;
      }
    }
    else
    {
      FltReleaseContext(v11);
      result = v8;
    }
  }
  return result;
}
// 14002153E: using guessed type __int64 __fastcall FltDeleteContext(_QWORD);
// 140021556: using guessed type __int64 __fastcall FltReleaseContext(_QWORD);
// 140021652: using guessed type __int64 __fastcall FltAllocateContext(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 14002174E: using guessed type __int64 __fastcall FltSetTransactionContext(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140021766: using guessed type __int64 __fastcall FltEnlistInTransaction(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140021200) ----------------------------------------------------
__int64 __fastcall sub_140021200(__int64 a1, __int64 a2)
{
  int v2; // eax
  __int64 v3; // rcx
  __int64 v5; // [rsp+40h] [rbp+18h]

  v2 = FltGetTransactionContext(a1, a2, &v5);
  v3 = v5;
  if ( v2 < 0 )
    v3 = 0i64;
  return v3;
}
// 14002175A: using guessed type __int64 __fastcall FltGetTransactionContext(_QWORD, _QWORD, _QWORD);

//----- (0000000140021230) ----------------------------------------------------
void __fastcall sub_140021230(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 8) != a1 + 8 )
    sub_14001F880(a1, 1);
}

//----- (0000000140021250) ----------------------------------------------------
__int64 __fastcall sub_140021250(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // rax
  char v4; // dl

  v3 = a2;
  if ( a3 & 2 )
  {
    v4 = 0;
LABEL_5:
    sub_14001F880(v3, v4);
    return 0i64;
  }
  if ( a3 & 8 )
  {
    v4 = 1;
    goto LABEL_5;
  }
  return 0i64;
}

//----- (0000000140021278) ----------------------------------------------------
char __fastcall sub_140021278(const char *a1, unsigned __int64 a2)
{
  const char *v2; // rbx
  signed __int64 v3; // rax
  unsigned __int64 v4; // rdi
  unsigned __int64 v5; // rbp
  unsigned __int64 v6; // rsi

  v2 = a1;
  if ( a1 && a2 >= 5 )
  {
    v3 = 1024i64;
    if ( a2 <= 0x400 )
      v3 = a2;
    v4 = 0i64;
    v5 = v3 - 5;
    if ( v3 != 5 )
    {
      v6 = v3 - 4;
      do
      {
        while ( *v2 != 60 && v4 < v6 )
        {
          ++v2;
          ++v4;
        }
        ++v2;
        if ( ++v4 >= v6 )
          break;
        if ( !strncmp(v2, "HTML", 4ui64)
          || !strncmp(v2, "HEAD", 4ui64)
          || !strncmp(v2, "BODY", 4ui64)
          || !strncmp(v2, "SCRI", 4ui64)
          || !strncmp(v2, "FRAM", 4ui64) )
        {
          return 1;
        }
      }
      while ( v4 < v5 );
    }
  }
  return 0;
}

//----- (0000000140021380) ----------------------------------------------------
char __fastcall sub_140021380(const wchar_t *a1, unsigned __int64 a2)
{
  const wchar_t *v2; // rbx
  signed __int64 v3; // rax
  unsigned __int64 v4; // rdi
  unsigned __int64 v5; // rbp
  unsigned __int64 v6; // rsi

  v2 = a1;
  if ( a1 && a2 >= 0xA )
  {
    v3 = 1024i64;
    if ( a2 <= 0x400 )
      v3 = a2;
    v4 = 0i64;
    v5 = v3 - 10;
    if ( v3 != 10 )
    {
      v6 = v3 - 8;
      do
      {
        while ( *v2 != 60 && v4 < v6 )
        {
          ++v2;
          v4 += 2i64;
        }
        ++v2;
        v4 += 2i64;
        if ( v4 >= v6 )
          break;
        if ( !wcsncmp(v2, L"HTML", 4ui64)
          || !wcsncmp(v2, L"HEAD", 4ui64)
          || !wcsncmp(v2, L"BODY", 4ui64)
          || !wcsncmp(v2, L"SCRI", 4ui64)
          || !wcsncmp(v2, L"FRAM", 4ui64) )
        {
          return 1;
        }
      }
      while ( v4 < v5 );
    }
  }
  return 0;
}

//----- (000000014002148C) ----------------------------------------------------
bool __fastcall sub_14002148C(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rdi
  const wchar_t *v3; // rbx

  v2 = a2;
  v3 = (const wchar_t *)a1;
  return a2 >= 8
      && (*(_DWORD *)a1 == -535703600 && *(_DWORD *)(a1 + 4) == -518344287
       || *(_WORD *)a1 == 23117
       || *(_WORD *)a1 == 19802
       || sub_140021278((const char *)a1, a2)
       || sub_140021380(v3, v2));
}

//----- (00000001400217B0) ----------------------------------------------------
void __fastcall __noreturn sub_1400217B0(ULONG_PTR BugCheckParameter1)
{
  KeBugCheckEx(0xF7u, BugCheckParameter1, _security_cookie, BugCheckParameter3, 0i64);
}

//----- (0000000140021800) ----------------------------------------------------
__int64 __fastcall sub_140021800(unsigned __int64 a1, __int64 a2, _DWORD *a3)
{
  __int64 v3; // r9
  unsigned __int64 v4; // r10
  __int64 result; // rax
  unsigned __int8 v6; // dl
  __int64 v7; // r9

  v3 = a1;
  v4 = a1;
  if ( *a3 & 4 )
    v4 = -a3[2] & (a1 + (signed int)a3[1]);
  result = *(_QWORD *)(a2 + 8);
  v6 = *(_BYTE *)(*(unsigned int *)(*(_QWORD *)(a2 + 16) + 8i64) + result + 3);
  if ( v6 & 0xF )
  {
    result = v6 & 0xF0;
    v3 = result + a1;
  }
  v7 = *(_QWORD *)((signed int)(*a3 & 0xFFFFFFF8) + v4) ^ v3;
  return result;
}

//----- (0000000140021880) ----------------------------------------------------
__int64 __fastcall sub_140021880(unsigned __int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rdx
  bool v4; // cf
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // r9

  v3 = a2 - (_QWORD)a1;
  if ( a3 < 8 )
    goto LABEL_6;
  for ( ; (unsigned __int8)a1 & 7; --a3 )
  {
    v4 = *(_BYTE *)a1 < *((_BYTE *)a1 + v3);
    if ( *(_BYTE *)a1 != *((_BYTE *)a1 + v3) )
      return -v4 - ((unsigned int)v4 - 1);
    a1 = (unsigned __int64 *)((char *)a1 + 1);
  }
  if ( !(a3 >> 3) )
  {
LABEL_6:
    if ( !a3 )
      return 0i64;
    while ( 1 )
    {
      v4 = *(_BYTE *)a1 < *((_BYTE *)a1 + v3);
      if ( *(_BYTE *)a1 != *((_BYTE *)a1 + v3) )
        break;
      a1 = (unsigned __int64 *)((char *)a1 + 1);
      if ( !--a3 )
        return 0i64;
    }
    return -v4 - ((unsigned int)v4 - 1);
  }
  v6 = a3 >> 5;
  if ( a3 >> 5 )
  {
    while ( 1 )
    {
      v7 = *a1;
      if ( *a1 != *(unsigned __int64 *)((char *)a1 + v3) )
        break;
      v7 = a1[1];
      if ( v7 != *(unsigned __int64 *)((char *)a1 + v3 + 8) )
        goto LABEL_24;
      v7 = a1[2];
      if ( v7 != *(unsigned __int64 *)((char *)a1 + v3 + 16) )
        goto LABEL_23;
      v7 = a1[3];
      if ( v7 != *(unsigned __int64 *)((char *)a1 + v3 + 24) )
      {
        ++a1;
LABEL_23:
        ++a1;
LABEL_24:
        ++a1;
        break;
      }
      a1 += 4;
      if ( !--v6 )
      {
        a3 &= 0x1Fu;
        goto LABEL_18;
      }
    }
  }
  else
  {
LABEL_18:
    v8 = a3 >> 3;
    if ( !(a3 >> 3) )
      goto LABEL_6;
    while ( 1 )
    {
      v7 = *a1;
      if ( *a1 != *(unsigned __int64 *)((char *)a1 + v3) )
        break;
      ++a1;
      if ( !--v8 )
      {
        a3 &= 7u;
        goto LABEL_6;
      }
    }
  }
  v4 = _byteswap_uint64(v7) < _byteswap_uint64(*(unsigned __int64 *)((char *)a1 + v3));
  return -v4 - ((unsigned int)v4 - 1);
}

//----- (0000000140021A40) ----------------------------------------------------
__int64 __usercall sub_140021A40@<rax>(__int64 (*a1)(void)@<rax>)
{
  return a1();
}

//----- (0000000140021A80) ----------------------------------------------------
__m128i *__fastcall sub_140021A80(__m128i *_RCX, unsigned __int64 a2, unsigned __int64 a3)
{
  __m128i *v3; // r11
  bool v4; // cf
  unsigned __int64 k; // r9
  __int64 v7; // rax
  unsigned __int64 l; // r8
  __int8 v9; // al
  __m128i *result; // rax
  unsigned int v11; // ecx
  unsigned __int64 v12; // r9
  __m128i v13; // xmm0
  __m128i v14; // xmm1
  signed int v15; // eax
  signed int v16; // eax
  __m128i v17; // xmm1
  __m128i v18; // xmm1
  unsigned __int64 i; // r9
  __int64 v21; // rax
  unsigned __int64 j; // r8
  char v23; // al
  __m128i *v24; // rax
  signed __int64 v25; // rcx
  unsigned __int64 v26; // r9
  __m128i v27; // xmm0
  __m128i v28; // xmm1
  signed int v29; // eax
  signed int v30; // eax
  __m128i v31; // xmm1
  __m128i v32; // xmm1
  void *retaddr; // [rsp+0h] [rbp+0h]

  v3 = _RCX;
  v4 = a2 < (unsigned __int64)_RCX;
  _RDX = a2 - (_QWORD)_RCX;
  if ( v4 )
  {
    _RCX = (__m128i *)((char *)_RCX + a3);
    if ( a3 >= 0x4F )
    {
      if ( _RDX > 0xFFFFFFFFFFFFFFF0ui64 )
      {
        for ( ; (unsigned __int8)_RCX & 0xF; LOBYTE(_RCX->m128i_i64[0]) = *((_BYTE *)_RCX->m128i_i64 + _RDX) )
        {
          _RCX = (__m128i *)((char *)_RCX - 1);
          --a3;
        }
      }
      else
      {
        v24 = _RCX;
        v25 = (unsigned __int8)_RCX & 0xF;
        if ( (_DWORD)v25 )
        {
          a3 -= (unsigned int)v25;
          v25 = -(signed __int64)(unsigned int)v25;
          _mm_storeu_si128(v24 - 1, _mm_loadu_si128((__m128i *)((char *)v24 + _RDX - 16)));
        }
        _RCX = (__m128i *)((char *)v24 + v25);
      }
      v26 = a3 >> 5;
      if ( a3 >> 5 <= 0x2000 || _RDX > 0xFFFFFFFFFFFFFE00ui64 )
        goto LABEL_54;
      do
      {
        v29 = 4;
        do
        {
          _RCX -= 8;
          __asm
          {
            prefetchnta byte ptr [rcx+rdx]
            prefetchnta byte ptr [rcx+rdx+40h]
          }
          --v29;
        }
        while ( v29 );
        _RCX += 32;
        v30 = 8;
        do
        {
          v31 = _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX - 32));
          _mm_stream_si128(_RCX - 1, _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX - 16)));
          _mm_stream_si128(_RCX - 2, v31);
          _RCX -= 4;
          v32 = _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX));
          _mm_stream_si128(_RCX + 1, _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX + 16)));
          _mm_stream_si128(_RCX, v32);
          --v30;
        }
        while ( v30 );
        a3 -= 512i64;
      }
      while ( a3 >= 0x200 );
      _InterlockedOr8((volatile signed __int8 *)&retaddr, 0);
      v26 = a3 >> 5;
      if ( a3 >> 5 )
      {
LABEL_54:
        a3 &= 0x1Fu;
        do
        {
          v27 = _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX - 16));
          v28 = _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX - 32));
          _RCX -= 2;
          _mm_store_si128(_RCX + 1, v27);
          _mm_store_si128(_RCX, v28);
          --v26;
        }
        while ( v26 );
      }
    }
    for ( i = a3 >> 3; i; _RCX->m128i_i64[0] = v21 )
    {
      v21 = *(__int64 *)((char *)&_RCX->m128i_i64[-1] + _RDX);
      _RCX = (__m128i *)((char *)_RCX - 8);
      --i;
    }
    for ( j = a3 & 7; j; LOBYTE(_RCX->m128i_i64[0]) = v23 )
    {
      v23 = *((_BYTE *)_RCX->m128i_i64 + _RDX - 1);
      _RCX = (__m128i *)((char *)_RCX - 1);
      --j;
    }
    result = v3;
  }
  else
  {
    if ( a3 >= 0x4F )
    {
      if ( _RDX < 0x10 )
      {
        for ( ; (unsigned __int8)_RCX & 0xF; _RCX = (__m128i *)((char *)_RCX + 1) )
        {
          --a3;
          LOBYTE(_RCX->m128i_i64[0]) = *((_BYTE *)_RCX->m128i_i64 + _RDX);
        }
      }
      else
      {
        v11 = -(signed int)_RCX & 0xF;
        if ( v11 )
        {
          a3 -= v11;
          _mm_storeu_si128(v3, _mm_loadu_si128((__m128i *)((char *)v3 + _RDX)));
        }
        _RCX = (__m128i *)((char *)v3 + v11);
      }
      v12 = a3 >> 5;
      if ( a3 >> 5 <= 0x2000 || _RDX < 0x200 )
        goto LABEL_55;
      do
      {
        v15 = 4;
        do
        {
          __asm
          {
            prefetchnta byte ptr [rcx+rdx]
            prefetchnta byte ptr [rcx+rdx+40h]
          }
          _RCX += 8;
          --v15;
        }
        while ( v15 );
        _RCX -= 32;
        v16 = 8;
        do
        {
          v17 = _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX + 16));
          _mm_stream_si128(_RCX, _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX)));
          _mm_stream_si128(_RCX + 1, v17);
          _RCX += 4;
          v18 = _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX - 16));
          _mm_stream_si128(_RCX - 2, _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX - 32)));
          _mm_stream_si128(_RCX - 1, v18);
          --v16;
        }
        while ( v16 );
        a3 -= 512i64;
      }
      while ( a3 >= 0x200 );
      _InterlockedOr8((volatile signed __int8 *)&retaddr, 0);
      v12 = a3 >> 5;
      if ( a3 >> 5 )
      {
LABEL_55:
        a3 &= 0x1Fu;
        do
        {
          v13 = _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX));
          v14 = _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX + 16));
          _RCX += 2;
          _mm_store_si128(_RCX - 2, v13);
          _mm_store_si128(_RCX - 1, v14);
          --v12;
        }
        while ( v12 );
      }
    }
    for ( k = a3 >> 3; k; _RCX[-1].m128i_i64[1] = v7 )
    {
      v7 = *(__int64 *)((char *)_RCX->m128i_i64 + _RDX);
      _RCX = (__m128i *)((char *)_RCX + 8);
      --k;
    }
    for ( l = a3 & 7; l; _RCX[-1].m128i_i8[15] = v9 )
    {
      v9 = *((_BYTE *)_RCX->m128i_i64 + _RDX);
      _RCX = (__m128i *)((char *)_RCX + 1);
      --l;
    }
    result = v3;
  }
  return result;
}

//----- (0000000140021DC0) ----------------------------------------------------
__m128 *__fastcall sub_140021DC0(__m128 *a1, unsigned __int8 a2, unsigned __int64 a3)
{
  __m128 *result; // rax
  signed __int64 v4; // rdx
  unsigned __int64 v5; // r9
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // r8
  unsigned __int64 i; // r8
  __m128 v9; // xmm0
  char *v10; // r8
  char *v11; // rcx
  unsigned __int64 v12; // r8
  unsigned __int64 v13; // r9
  unsigned __int64 j; // r9
  unsigned __int64 v15; // r8

  result = a1;
  if ( a3 < 8 )
  {
    for ( i = a3 & 7; i; --i )
      *((_BYTE *)a1->m128_u64 + i - 1) = a2;
  }
  else
  {
    v4 = 72340172838076673i64 * a2;
    if ( a3 >= 0x4F )
    {
      v9 = _mm_movelh_ps((__m128)(unsigned __int64)v4, (__m128)(unsigned __int64)v4);
      *a1 = v9;
      v10 = (char *)a1 + a3;
      v11 = (char *)((unsigned __int64)&a1[1] & 0xFFFFFFFFFFFFFFF0ui64);
      v12 = v10 - v11;
      v13 = v12 >> 7;
      if ( v12 >> 7 )
      {
        do
        {
          *(__m128 *)v11 = v9;
          *((__m128 *)v11 + 1) = v9;
          v11 += 128;
          *((__m128 *)v11 - 6) = v9;
          *((__m128 *)v11 - 5) = v9;
          --v13;
          *((__m128 *)v11 - 4) = v9;
          *((__m128 *)v11 - 3) = v9;
          *((__m128 *)v11 - 2) = v9;
          *((__m128 *)v11 - 1) = v9;
        }
        while ( v13 );
        v12 &= 0x7Fu;
      }
      for ( j = v12 >> 4; j; --j )
      {
        *(__m128 *)v11 = v9;
        v11 += 16;
      }
      v15 = v12 & 0xF;
      if ( v15 )
        *(__m128 *)&v11[v15 - 16] = v9;
    }
    else
    {
      v5 = a3 & 0xFFFFFFFFFFFFFFF8ui64;
      v6 = (unsigned __int64)a1 + (a3 & 0xFFFFFFFFFFFFFFF8ui64);
      do
      {
        *(unsigned __int64 *)((char *)&result->m128_u64[-1] + v5) = v4;
        v5 -= 8i64;
      }
      while ( v5 );
      v7 = a3 & 7;
      if ( v7 )
        *(_QWORD *)(v6 + v7 - 8) = v4;
    }
  }
  return result;
}

//----- (00000001400277F0) ----------------------------------------------------
void sub_1400277F0()
{
  ExDeletePagedLookasideList(&SListHead);
}

//----- (0000000140027810) ----------------------------------------------------
void sub_140027810()
{
  ExDeleteNPagedLookasideList(&ListHead);
}

//----- (0000000140027830) ----------------------------------------------------
__int64 **sub_140027830()
{
  return sub_140001FF4((__int64)&unk_14002B880, 0);
}

//----- (0000000140027840) ----------------------------------------------------
void sub_140027840()
{
  ExDeletePagedLookasideList(&stru_140030480);
}

//----- (0000000140027860) ----------------------------------------------------
void sub_140027860()
{
  ExDeletePagedLookasideList(&stru_14002B980);
}

//----- (0000000140027880) ----------------------------------------------------
void sub_140027880()
{
  sub_140002920((__int64)&unk_14002F7E0);
}

//----- (0000000140027890) ----------------------------------------------------
void sub_140027890()
{
  signed __int64 v0; // rbx
  PVOID *v1; // rdi

  v0 = 293i64;
  v1 = (PVOID *)&unk_14002F7F0;
  do
  {
    v1 -= 5;
    --v0;
    if ( *v1 )
      ExFreePoolWithTag(*v1, 0x65634349u);
  }
  while ( v0 );
}

//----- (00000001400278E0) ----------------------------------------------------
_QWORD *sub_1400278E0()
{
  _QWORD *v0; // rbx
  signed __int64 v1; // rsi
  struct _SLIST_ENTRY *v2; // rdi
  _QWORD *result; // rax

  v0 = &unk_14002BA00;
  v1 = 257i64;
  do
  {
    while ( 1 )
    {
      result = (_QWORD *)*v0;
      if ( (_QWORD *)*v0 == v0 )
        break;
      v2 = (struct _SLIST_ENTRY *)(result - 3);
      if ( result != (_QWORD *)24 )
      {
        sub_140002990((__int64)(result - 3));
        sub_140002B1C(v2);
      }
    }
    v0 += 2;
    --v1;
  }
  while ( v1 );
  return result;
}

//----- (0000000140027940) ----------------------------------------------------
void sub_140027940()
{
  ExDeletePagedLookasideList(&stru_140030540);
}

//----- (0000000140027960) ----------------------------------------------------
_QWORD *sub_140027960()
{
  return sub_140004650((__int64)&unk_1400305C0);
}

//----- (0000000140027970) ----------------------------------------------------
void sub_140027970()
{
  ExDeletePagedLookasideList(&stru_140030640);
}

//----- (0000000140027990) ----------------------------------------------------
void sub_140027990()
{
  sub_14000577C((__int64)&Destination);
}

//----- (00000001400279A0) ----------------------------------------------------
void sub_1400279A0()
{
  ExDeletePagedLookasideList(&stru_140036A00);
}

//----- (00000001400279C0) ----------------------------------------------------
void sub_1400279C0()
{
  ExDeletePagedLookasideList(&stru_140036AC0);
}

//----- (00000001400279E0) ----------------------------------------------------
__int64 sub_1400279E0()
{
  __int64 v0; // rcx
  __int64 result; // rax

  v0 = qword_140036B40;
  result = qword_140036B48;
  if ( *(__int64 **)(qword_140036B40 + 8) != &qword_140036B40 || *(__int64 **)qword_140036B48 != &qword_140036B40 )
    __fastfail(3u);
  *(_QWORD *)qword_140036B48 = qword_140036B40;
  *(_QWORD *)(v0 + 8) = result;
  return result;
}
// 140036B40: using guessed type __int64 qword_140036B40;
// 140036B48: using guessed type __int64 qword_140036B48;

//----- (0000000140027A10) ----------------------------------------------------
void sub_140027A10()
{
  ExDeletePagedLookasideList(&stru_140036BC0);
}

//----- (0000000140027A30) ----------------------------------------------------
void sub_140027A30()
{
  ExDeletePagedLookasideList(&stru_140037C80);
}

//----- (0000000140027A50) ----------------------------------------------------
_QWORD *sub_140027A50()
{
  FltDeletePushLock(&unk_140037C70);
  return sub_14000CDE8((struct _SLIST_ENTRY **)&unk_140036C50);
}
// 140021502: using guessed type __int64 __fastcall FltDeletePushLock(_QWORD);

//----- (0000000140027A70) ----------------------------------------------------
void sub_140027A70()
{
  ExDeleteNPagedLookasideList(&stru_140037DC0);
}

//----- (0000000140027A90) ----------------------------------------------------
void **sub_140027A90()
{
  return sub_140020724((__int64)&unk_140037D80);
}

//----- (0000000140027AA0) ----------------------------------------------------
void sub_140027AA0()
{
  void *v0; // rbx

  sub_140021018((__int64)&unk_140037D40);
  if ( byte_140037D48 )
  {
    v0 = (void *)qword_140037D50;
    if ( qword_140037D50 )
    {
      sub_14000E1E8((HANDLE *)qword_140037D50);
      sub_14000AB20(v0);
    }
  }
}
// 140037D48: using guessed type char byte_140037D48;
// 140037D50: using guessed type __int64 qword_140037D50;

//----- (0000000140027AE0) ----------------------------------------------------
void sub_140027AE0()
{
  ExDeletePagedLookasideList(&stru_140037E80);
}

//----- (0000000140027B00) ----------------------------------------------------
void sub_140027B00()
{
  ExDeletePagedLookasideList(&stru_140037F00);
}

//----- (0000000140027B20) ----------------------------------------------------
__int64 sub_140027B20()
{
  return sub_140013490((__int64)&unk_140037F80);
}

//----- (0000000140027B30) ----------------------------------------------------
__int64 sub_140027B30()
{
  return sub_140013490((__int64)&unk_140037FF0);
}

//----- (0000000140027B40) ----------------------------------------------------
__int64 sub_140027B40()
{
  return sub_140013490((__int64)&unk_140037FB8);
}

//----- (0000000140027B50) ----------------------------------------------------
__int64 sub_140027B50()
{
  return sub_140013490((__int64)&unk_140038028);
}

//----- (0000000140027B60) ----------------------------------------------------
void sub_140027B60()
{
  ExDeleteNPagedLookasideList(&stru_1400380C0);
}

//----- (0000000140027B80) ----------------------------------------------------
void sub_140027B80()
{
  ExDeleteNPagedLookasideList(&stru_140038140);
}

//----- (0000000140027BA0) ----------------------------------------------------
void sub_140027BA0()
{
  if ( qword_1400381C8 )
  {
    ExFreePoolWithTag(qword_1400381C8, 0x61664349u);
    _mm_storeu_si128((__m128i *)&unk_1400381C0, (__m128i)xmmword_140028C50);
  }
}
// 140028C50: using guessed type __int128 xmmword_140028C50;

//----- (0000000140027BE0) ----------------------------------------------------
__int64 sub_140027BE0()
{
  return FltDeletePushLock(&unk_140038288);
}
// 140021502: using guessed type __int64 __fastcall FltDeletePushLock(_QWORD);

//----- (0000000140027BF0) ----------------------------------------------------
void sub_140027BF0()
{
  ExDeletePagedLookasideList(&stru_1400394C0);
}

//----- (0000000140027C10) ----------------------------------------------------
_QWORD *sub_140027C10()
{
  FltDeletePushLock(&unk_1400394B0);
  return sub_14001D828((struct _SLIST_ENTRY **)&unk_140038490);
}
// 140021502: using guessed type __int64 __fastcall FltDeletePushLock(_QWORD);

//----- (0000000140027C30) ----------------------------------------------------
void sub_140027C30()
{
  if ( stru_140039550.Buffer )
  {
    ExFreePoolWithTag(stru_140039550.Buffer, 0x72735352u);
    _mm_storeu_si128((__m128i *)&stru_140039550, (__m128i)xmmword_140029010);
  }
  byte_140039570 = 0;
}
// 140029010: using guessed type __int128 xmmword_140029010;
// 140039570: using guessed type char byte_140039570;

//----- (0000000140027C70) ----------------------------------------------------
void sub_140027C70()
{
  sub_1400116CC(&DeviceObject);
}

//----- (0000000140027C80) ----------------------------------------------------
void sub_140027C80()
{
  ExDeletePagedLookasideList(&stru_1400395C0);
}

//----- (000000014003C000) ----------------------------------------------------
char __fastcall sub_14003C000(void *a1)
{
  IoObject = a1;
  KeInitializeMutex(&Object, 0);
  return sub_140006E84();
}

//----- (000000014003C030) ----------------------------------------------------
NTSTATUS __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
  PUNICODE_STRING v2; // rbx
  PDRIVER_OBJECT v3; // rdi

  v2 = RegistryPath;
  v3 = DriverObject;
  _security_init_cookie();
  return sub_14001F588(v3, &v2->Length);
}
// 14003C05C: using guessed type __int64 _security_init_cookie(void);

// ALL OK, 783 function(s) have been successfully decompiled
