/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 sub_140001000();
__int64 __fastcall sub_140001030(); // weak
__int64 sub_140001040();
__int64 __fastcall DriverEntry(__int64 a1, const UNICODE_STRING *a2);
void *__fastcall sub_1400011D0(__int64 a1);
__int64 __fastcall sub_140001250(__int64 a1);
__int64 (*sub_1400012E0())(void);
__int64 sub_140001350();
__int64 sub_140001380();
__int64 sub_1400013B0();
__int64 sub_1400013D0();
__int64 sub_1400013F0();
__int64 sub_140001410();
__int64 sub_140001440();
__int64 sub_140001480();
__int64 sub_1400014B0();
__int64 sub_1400014E0();
__int64 sub_140001510();
__int64 sub_140001540();
__int64 sub_140001580();
__int64 sub_1400015C8();
__int64 sub_1400015F4();
__int64 sub_140001620();
__int64 sub_14000164C();
__int64 sub_140001680();
__int64 sub_1400016B0();
__int64 sub_1400016E0();
__int64 sub_140001720();
__int64 sub_140001760();
__int64 sub_140001790();
__int64 sub_1400017C0();
__int64 sub_1400017F0();
__int64 sub_140001820();
__int64 sub_140001840();
__int64 sub_140001870();
__int64 sub_1400018A0();
__int64 sub_1400018D0();
__int64 sub_1400018F0();
NTSTATUS __fastcall sub_140001910(HANDLE *a1);
NTSTATUS __fastcall sub_14000197C(void *a1, int a2, void *a3);
// __int64 __fastcall unknown_libname_1(_QWORD); weak
PVOID *__fastcall sub_140001AB8(PVOID *a1, SIZE_T a2);
void __fastcall sub_140001AE0(void **a1);
void **__fastcall sub_140001AFC(void **a1, void **a2);
__int64 __fastcall sub_140001B3C(__int64 a1);
char __fastcall sub_140001B40(_WORD *a1, _DWORD *a2, _DWORD *a3, unsigned __int64 a4);
__int16 __fastcall sub_140001BD4(__int16 a1);
void *__fastcall sub_140001BE4(_DWORD *a1);
char __fastcall sub_140001BF8(__int64 a1, __m128i *a2);
char __fastcall sub_140001D30(_DWORD *a1, unsigned __int16 *a2, unsigned __int16 *a3, __int64 a4, __int16 a5, __int16 *a6);
bool __fastcall sub_140001EFC(unsigned __int16 *a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4);
bool __fastcall sub_140001F40(__int16 *a1, _WORD *a2);
char __fastcall sub_140001F64(unsigned __int16 *a1, unsigned __int16 *a2);
__int64 __fastcall sub_140002050(__int64 *a1);
char __fastcall sub_140002058(__m128i *a1, _WORD *a2, _WORD *a3, __int64 a4, _WORD *a5, _WORD *a6, _DWORD *a7);
__int16 __fastcall sub_1400021A4(__m128i *a1, char a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int16 __fastcall sub_1400022E8(__int16 *a1, __int64 a2, __int64 a3);
char __fastcall sub_1400023AC(_WORD *a1, _WORD *a2, unsigned int *a3);
char __fastcall sub_140002424(unsigned __int16 *a1);
char __fastcall sub_1400024A8(unsigned __int16 *a1);
char __fastcall sub_1400024F4(__int64 a1);
bool __fastcall sub_14000255C(unsigned __int16 a1);
__m128 *__fastcall sub_140002584(__m128 *a1, unsigned __int64 a2);
_DWORD *__fastcall sub_140002590(int a1);
__int64 __fastcall sub_1400025E4(PCWSTR SourceString, unsigned __int64 a2, int a3);
bool __fastcall sub_140002838(__m128i *a1);
char __fastcall sub_140002950(__m128i *a1, int a2);
// void __fastcall CAMSchedule::CAdvisePacket::InsertAfter(CAMSchedule::CAdvisePacket *__hidden this, struct CAMSchedule::CAdvisePacket *); idb
__int64 __fastcall sub_140002A8C(int a1);
int __fastcall sub_140002B10(__int16 *a1, __int64 a2, char a3);
__int64 __fastcall sub_140002B58(__int64 a1, __int64 a2, __int16 a3);
char __fastcall sub_140002B68(unsigned __int16 *a1, _BYTE *a2, _WORD *a3);
void __fastcall sub_140002CAC(int a1);
void sub_140002D10();
_DWORD *sub_140002D1C();
__int64 __fastcall sub_140002D28(char a1);
__int64 __fastcall sub_140002D44(_QWORD); // weak
__int64 __fastcall sub_140002D4C(_BYTE *a1);
__int64 __fastcall sub_140002D6C(_BYTE *a1);
__int64 sub_140002D8C(void); // weak
__int64 __fastcall sub_140002D94(PCWSTR SourceString); // idb
__int64 sub_140002D9C();
void __fastcall sub_140002DA8(__int64 a1, __int64 a2, int a3);
__int64 sub_140002DB4();
__int64 __fastcall sub_140002DD4(const wchar_t *a1, __int64 a2, __int64 a3, __int64 a4, int a5);
void **__fastcall sub_140002E18(const wchar_t *a1, __int64 a2, int a3);
__int64 __fastcall sub_140002E58(const wchar_t *a1, int a2, int a3, __int64 a4, int a5);
void __fastcall sub_140002EA0(__int64 a1, int a2, char a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7);
__int64 __fastcall sub_140002FA0(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4);
__int64 __fastcall sub_140002FB8(_QWORD *a1);
__int64 __fastcall sub_140002FE0(_QWORD *a1, __int64 a2, __int64 a3, int a4, __int64 a5);
bool __fastcall sub_140003030(__int64 a1, unsigned __int8 a2, __int64 a3);
__int64 sub_140003060(_QWORD *a1, __int64 a2, __int64 a3, const wchar_t *a4, ...);
__int64 sub_14000318C(_QWORD *a1, __int64 a2, __int64 a3, const wchar_t *a4, ...);
void *__fastcall sub_1400032C0(_QWORD *a1, char a2);
__int64 __fastcall sub_140003300(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140003370(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400033D0(__int64 a1);
char __fastcall sub_140003410(__int64 a1, __int64 a2);
void *__fastcall sub_140003480(void *a1, char a2);
void *__fastcall sub_1400034C0(_QWORD *a1, char a2);
__int64 __fastcall sub_140003500(__int64 a1, __int64 a2, _BYTE *a3);
__int64 __fastcall sub_140003570(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400035D0(__int64 a1);
char __fastcall sub_140003620(__int64 a1, __int64 a2);
void *__fastcall sub_140003690(_QWORD *a1, __int64 a2);
char __fastcall sub_1400036C4(__int64 a1, __int64 a2, UNICODE_STRING *a3);
char __fastcall sub_14000371C(__int64 a1, __int64 a2, _BYTE *a3);
bool __fastcall sub_140003780(__int64 a1, __int64 a2, UNICODE_STRING *a3);
bool __fastcall sub_1400037D8(__int64 a1, __int64 a2, _BYTE *a3);
__int64 __fastcall sub_140003830(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_14000383C(_BYTE *a1, _BYTE *a2);
char __fastcall sub_140003844(__int64 a1, int *a2);
__int64 __fastcall sub_14000388C(__int64 a1, __int64 a2, char a3);
_QWORD *__fastcall sub_1400038BC(__int64 a1);
_QWORD *__fastcall sub_1400038EC(__int64 a1);
_QWORD *__fastcall sub_14000391C(_QWORD *a1, __int64 a2);
PLIST_ENTRY __fastcall sub_140003940(PLIST_ENTRY ListHead);
__int64 __fastcall sub_1400039B0(__int64 a1);
__int64 __fastcall sub_1400039D8(__int64 a1);
// __int64 __fastcall unknown_libname_2(_QWORD); weak
// __int64 __fastcall unknown_libname_3(_QWORD); weak
__m128 *__fastcall sub_140003A1C(__m128 *a1);
__m128 *__fastcall sub_140003A48(__m128 *a1);
struct _NPAGED_LOOKASIDE_LIST *__fastcall sub_140003A70(struct _NPAGED_LOOKASIDE_LIST *a1, SIZE_T a2, ULONG a3);
__int64 __fastcall sub_140003AA0(__int64 a1, int a2);
__int64 __fastcall sub_140003AD0(__int64 a1);
__int64 __fastcall sub_140003AF8(char *a1);
__int64 __fastcall sub_140003B08(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_140003B2C(_QWORD); // weak
__int64 __fastcall sub_140003B34(__int64 *a1);
__int64 __fastcall sub_140003B40(_QWORD); // weak
__int64 __fastcall sub_140003B48(_QWORD); // weak
__int64 __fastcall sub_140003B50(_QWORD *a1);
__int64 __fastcall sub_140003B64(_QWORD *a1);
void __fastcall sub_140003B78(__int64 a1);
void __fastcall sub_140003B88(__int64 a1);
// void __stdcall ExDeleteNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside);
void __fastcall sub_140003B9C(__int64 a1);
__int64 __fastcall sub_140003BBC(__int64 a1);
__int64 __fastcall sub_140003BD4(__int64 a1);
PSLIST_ENTRY __fastcall sub_140003BEC(struct _SLIST_ENTRY *a1);
PSLIST_ENTRY __fastcall sub_140003BFC(struct _SLIST_ENTRY *a1);
__int64 __fastcall sub_140003C0C(__int64 a1);
char __fastcall sub_140003C10(int *a1, __int64 a2, __int64 a3);
struct _SLIST_ENTRY *__fastcall sub_140003C1C(__int64 a1, char a2);
__int64 __fastcall sub_140003C60(_QWORD); // weak
signed __int64 __fastcall sub_140003C68(__int64 a1, unsigned __int16 a2);
void __fastcall sub_140003CB8(struct _LIST_ENTRY *a1);
void __fastcall sub_140003D20(struct _LIST_ENTRY *a1);
__int64 __fastcall sub_140003D80(int a1);
__int64 __fastcall sub_140003DA4(PUNICODE_STRING DestinationString, PCUNICODE_STRING SourceString); // idb
__int64 __fastcall sub_140003DE8(int a1, __int64 a2, __int64 a3, int a4, UNICODE_STRING *a5);
__int64 __fastcall sub_140003F40(__int64 a1, int a2, UNICODE_STRING *a3);
void sub_140003FF8();
struct _SLIST_ENTRY *__fastcall sub_140004170(__int64 a1, _QWORD *a2);
PSLIST_ENTRY __fastcall sub_1400041E0(__int64 a1, _QWORD *a2);
PSLIST_ENTRY __fastcall sub_14000424C(struct _SLIST_HEADER *a1, struct _SLIST_ENTRY *a2);
__int64 __fastcall sub_140004260(__int64 a1);
__int64 __fastcall sub_140004264(const UNICODE_STRING *a1, UNICODE_STRING *a2);
signed __int64 __fastcall sub_140004270(__int64 a1, UNICODE_STRING *a2, UNICODE_STRING *a3);
void *__fastcall sub_14000458C(int a1);
__int64 __fastcall sub_1400045A0(PCUNICODE_STRING SourceString, PUNICODE_STRING DestinationString); // idb
_QWORD *__fastcall sub_140004628(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_14000467C(PUNICODE_STRING DestinationString, __int64 a2);
__int64 __fastcall sub_1400046D0(_QWORD); // weak
_QWORD *__fastcall sub_1400046D8(__int64 a1, unsigned int a2, _QWORD *a3);
signed __int64 __fastcall sub_140004704(__int64 a1);
// __int64 __fastcall ExAcquireSpinLockExclusive(_QWORD); weak
// __int64 __fastcall ExAcquireSpinLockShared(_QWORD); weak
void __fastcall sub_140004730(__int64 a1, __int64 a2, char a3);
__int64 __fastcall sub_140004858(__int64 a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_140004960(__int64 a1, _QWORD *a2, _BYTE *a3);
void __fastcall sub_140004A60(__int64 a1, int a2);
__int64 __fastcall sub_140004A64(PUNICODE_STRING DestinationString, PCUNICODE_STRING SourceString, PCUNICODE_STRING SourceString); // idb
void __fastcall sub_140004A9C(__int64 a1, __int16 a2, __int16 a3, __int64 a4);
char __fastcall sub_140004AEC(__int64 a1, int a2);
__int64 __fastcall sub_140004B20(__int64 a1, int a2);
void __fastcall sub_140004B60(__int64 a1);
char __fastcall sub_140004BF8(__int64 a1, __int64 a2);
__int64 __fastcall nullsub_1(_QWORD, _QWORD); // weak
__int64 __fastcall sub_140004C94(int a1);
__int64 __fastcall sub_140004CAC(__int64 a1);
PSLIST_ENTRY __fastcall sub_140004CE0(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry);
void __fastcall sub_140004D28(struct _NPAGED_LOOKASIDE_LIST *a1, PVOID (__stdcall *a2)(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag), void (__stdcall *a3)(PVOID Buffer), int a4, SIZE_T a5, ULONG a6, USHORT a7);
void __noreturn sub_140004D40();
__int64 __fastcall sub_140004D50(unsigned int a1);
__int64 sub_140004D54();
// void __stdcall InitializeListHead(PLIST_ENTRY ListHead);
_QWORD *__fastcall sub_140004DE4(__int64 a1, _QWORD *a2);
char __fastcall sub_140004E14(__int64 a1);
// __int64 __fastcall IsListEmpty(_QWORD); weak
bool __fastcall sub_140004E4C(__int64 a1, UNICODE_STRING *a2, char a3, int a4);
bool __fastcall sub_140004F14(_QWORD *a1);
__int64 *__fastcall sub_140004F48(__int64 **a1);
// __int64 __fastcall RtlFailFast(_QWORD); weak
__int64 sub_140004F7C();
__int64 *sub_140004FB0();
char sub_140005010();
__int64 sub_140005034();
char __fastcall sub_140005078(int a1);
__int64 sub_1400050B8();
__int64 __fastcall sub_140005154(__int64 a1);
__int64 __fastcall sub_1400051FC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6, int a7, __int64 a8, __int64 a9, __m128i *a10, __m128i *a11, __m128i *a12);
__int64 __fastcall sub_140005334(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6, int a7, __m128i *a8, __int64 a9, __int64 a10, __m128i *a11, __m128i *a12, __m128i *a13);
__int64 __fastcall sub_1400054F4(__int16 *a1, __int64 a2, __int16 a3, __int64 a4, int a5, int a6);
void __fastcall sub_140005630(__int64 *a1, __int64 a2);
__int16 __fastcall sub_140005688(__int16 a1);
__int64 __fastcall sub_140005698(__int16 *a1, __int16 a2, __int64 a3);
void __fastcall sub_140005770(_QWORD *a1);
__int64 __fastcall sub_1400057DC(int a1, _DWORD *a2);
signed __int64 __fastcall sub_14000580C(__int64 a1, unsigned __int64 a2);
_DWORD *__fastcall sub_140005878(__int16 a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6);
_DWORD *__fastcall sub_1400058B0(__int16 a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9);
bool __fastcall sub_1400059F8(unsigned __int16 *a1);
bool __fastcall sub_140005A04(unsigned __int16 *a1, int a2);
bool __fastcall sub_140005A5C(__int64 a1);
bool __fastcall sub_140005ACC(__int16 a1, __int64 a2);
bool __fastcall sub_140005B48(unsigned __int16 *a1);
bool __fastcall sub_140005B54(unsigned __int16 *a1);
char __fastcall sub_140005B60(char *a1);
bool __fastcall sub_140005C60(char a1);
signed __int64 __fastcall sub_140005C74(_QWORD *a1, __m128i *a2);
char __fastcall sub_140005DB8(char *a1, unsigned __int64 a2, signed __int64 *a3);
signed __int64 __fastcall sub_140005E8C(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, __int64 a5, __m128i *a6, __m128i *a7, __int64 a8, __int64 a9, __int64 a10);
signed __int64 __fastcall sub_140005FF0(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, int a9, __m128i *a10, __int64 a11, __int64 a12, __m128i *a13, __m128i *a14, __m128i *a15, __int64 a16, __int64 a17, __int64 a18);
signed __int64 __fastcall sub_140006260(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, int a8, __m128i *a9, __int64 a10, __m128i *a11, __m128i *a12, __m128i *a13, __int64 a14, __int64 a15, __int64 a16);
__int64 __fastcall sub_140006340(__int64 a1, __int64 a2, __m128i *a3, __int64 a4, __int64 a5);
void __fastcall sub_140006454(__int64 a1, int a2);
__int64 __fastcall sub_1400064C0(__int64 a1, _QWORD *a2);
void __fastcall sub_1400064E0(int a1);
signed __int64 __fastcall sub_140006520(int a1, __int64 a2, __int64 a3);
void __fastcall sub_1400065D4(__int64 a1, int a2);
_QWORD *__fastcall sub_1400065EC(_QWORD *a1);
_QWORD *__fastcall sub_140006614(_QWORD *a1);
_QWORD *__fastcall sub_14000663C(_QWORD *a1);
_QWORD *__fastcall sub_140006664(_QWORD *a1);
__int64 (__fastcall **__fastcall sub_140006678(_QWORD *a1))();
__int64 (__fastcall **__fastcall sub_140006684(__int64 a1))();
__int64 (__fastcall **__fastcall sub_1400066B0(__int64 a1))();
_QWORD *__fastcall sub_1400066E0(_QWORD *a1, char a2);
__int64 __fastcall sub_140006720(__int64 a1, char a2);
__int64 __fastcall sub_140006760(__int64 a1, char a2);
__int64 __fastcall sub_1400067A0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140006820(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140006890(__int64 a1, __int64 a2);
__int64 sub_140006910();
const wchar_t *sub_140006920();
const wchar_t *sub_140006930();
__int64 __fastcall sub_140006938(__int64 a1);
__int64 __fastcall sub_140006960(__int64 a1);
__int64 __fastcall sub_140006988(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_140006990(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_140006998(_QWORD *a1, char *a2);
signed __int64 __fastcall sub_140006BE0(__int64 *a1, __int64 *a2, __int64 a3);
_QWORD *__fastcall sub_140006D50(_QWORD *a1, __int64 *a2);
void **__fastcall sub_140006D8C(void **a1, __int64 a2);
PVOID *__fastcall sub_140006DAC(PVOID *a1, SIZE_T a2);
void __fastcall sub_140006E08(void **a1);
void **__fastcall sub_140006E24(void **a1, void **a2);
void **__fastcall sub_140006E64(void **a1, __int64 *a2);
bool __fastcall sub_140006EAC(_QWORD *a1);
__m128 *__fastcall sub_140006EB4(__int64 *a1, __m128 *a2, __int64 a3, unsigned int a4);
__m128 *__fastcall sub_140006ED4(__m128 *a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_140007028(__int64 a1, __int64 a2);
void __fastcall sub_1400070EC(_QWORD *a1);
void *__fastcall sub_1400071E8(__int64 a1);
void __fastcall sub_140007284(_QWORD *a1, __int64 a2, int a3);
__int64 __fastcall sub_14000737C(__int64 a1, __int64 a2);
__int64 __fastcall sub_140007428(__int64 a1);
__int64 __fastcall sub_140007450(__int64 a1, int a2, char a3, __int16 *a4);
__int64 __fastcall sub_1400074BC(__int64 a1, unsigned __int64 a2, int a3, int a4);
_DWORD *__fastcall sub_1400074FC(_DWORD *a1, __int64 a2, __m128i *a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_140007598(__int64 a1);
_QWORD *__fastcall sub_1400075B8(_QWORD *a1);
__int128 *__fastcall sub_1400075EC(__int128 *a1, __int64 a2);
__int64 __fastcall sub_140007634(__int64 a1);
void __fastcall sub_140007668(void **a1);
void __fastcall sub_140007690(unsigned int *a1);
__int64 __fastcall sub_1400076D8(_QWORD); // weak
__int64 __fastcall sub_1400076E0(__int64 a1);
void __fastcall sub_140007714(void *a1);
bool __fastcall sub_140007720(_DWORD *a1);
__int64 __fastcall sub_140007728(__int64 a1, __int64 a2, __int64 a3, __int64 (*a4)(void));
char __fastcall sub_140007780(_QWORD *a1, __m128i *a2);
char __fastcall sub_1400077EC(__int64 a1, __m128i *a2, unsigned __int64 a3);
PVOID __fastcall sub_140007870(__int64 a1, unsigned __int64 a2);
char __fastcall sub_140007894(__int64 a1, __int64 a2);
__int64 sub_140007904();
__int64 __fastcall sub_140007A74(__int64 a1, char a2);
bool __fastcall sub_140007D54(_QWORD *a1, __int64 a2);
void __fastcall sub_140007D60(__int64 a1);
char *__fastcall sub_140007D68(unsigned int a1);
char __fastcall sub_140007D80(__int16 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, _DWORD *a7);
char __fastcall sub_140007E30(unsigned __int16 *a1, int *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, _DWORD *a7);
void __fastcall sub_140007F00(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_140007F38(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_140008200(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140008240(int a1, __int64 a2, __int64 a3);
// __int64 __fastcall unknown_libname_4(_QWORD, _QWORD); weak
char __fastcall sub_1400082A4(__int64 a1);
char __fastcall sub_1400082E0(_QWORD *a1, __int64 a2, _QWORD *a3);
void __fastcall sub_140008358(__int64 a1, unsigned __int64 a2);
char __fastcall sub_1400083B4(__m128i *a1, unsigned __int64 a2);
__int64 __fastcall sub_1400083C8(__int64 a1);
__int64 __fastcall sub_1400083D0(__int64 a1);
__int64 __fastcall sub_1400083D4(__int64 a1);
__int64 __fastcall sub_1400083F4(_QWORD); // weak
signed __int64 __fastcall sub_1400083FC(_QWORD *a1);
char __fastcall sub_140008408(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_1400084A4(__int64 a1, __int64 a2, __int64 *a3);
__int64 __fastcall sub_14000850C(__int64 a1, __int64 a2);
__int64 __fastcall sub_140008568(__int64 a1);
signed __int64 __fastcall sub_140008608(_QWORD *a1, __int64 a2);
void __fastcall sub_140008630(__int64 a1, unsigned int *a2);
char __fastcall sub_140008640(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_140008650(__int64 a1, unsigned int *a2);
char __fastcall sub_140008660(__int64 a1, unsigned int *a2);
NTSTATUS sub_140008670();
char __fastcall sub_140008680(__int64 a1, unsigned int *a2);
PVOID *__fastcall sub_140008690(PVOID *a1, SIZE_T a2);
struct _LIST_ENTRY *__fastcall sub_1400086B8(struct _LIST_ENTRY *a1);
_QWORD *__fastcall sub_1400086DC(_QWORD *a1);
_QWORD *__fastcall sub_140008718(_QWORD *a1, _QWORD *a2);
__int64 *__fastcall sub_140008730(__int64 *a1, __int64 a2);
_QWORD *__fastcall sub_14000875C(_QWORD *a1);
PHANDLE __fastcall sub_14000876C(PHANDLE FileHandle, __int64 a2);
PVOID *__fastcall sub_140008820(PVOID *Object, HANDLE Handle, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode);
_QWORD *__fastcall sub_140008864(_QWORD *a1);
_QWORD *__fastcall sub_140008890(_QWORD *a1);
__int64 __fastcall sub_1400088D0(__int64 a1);
_QWORD *__fastcall sub_14000896C(_QWORD *a1);
__int64 __fastcall sub_140008988(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400089B4(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3);
int *__fastcall sub_1400089D4(__int64 a1, int a2, unsigned __int8 *a3, unsigned __int64 a4);
__int64 *__fastcall sub_140008A6C(__int64 *a1, __int64 a2);
void __fastcall sub_140008AE4(void **a1);
__int64 __fastcall sub_140008B00(_QWORD); // weak
__int64 __fastcall sub_140008B08(_QWORD); // weak
__int64 __fastcall sub_140008B10(_QWORD); // weak
__int64 __fastcall sub_140008B18(_QWORD); // weak
__int64 __fastcall sub_140008B20(__int64 a1);
__int64 __fastcall sub_140008B4C(__int64 a1);
__int64 __fastcall sub_140008B78(__int64 a1);
__int64 __fastcall sub_140008BA4(__int64 a1);
void __fastcall sub_140008BD0(__int64 *a1);
NTSTATUS __fastcall sub_140008BF0(__int64 a1);
LONG_PTR __fastcall sub_140008C08(__int64 a1);
__int64 __fastcall sub_140008C20(__int64 a1);
__int64 __fastcall sub_140008C58(__int64 a1);
void __fastcall sub_140008C7C(__int64 a1);
__int64 __fastcall sub_140008C98(_QWORD); // weak
void __fastcall sub_140008CA0(__int64 *a1);
__int64 __fastcall sub_140008CB8(__int64 a1, __int64 a2);
PSLIST_ENTRY __fastcall sub_140008CBC(struct _SLIST_ENTRY *a1);
PSLIST_ENTRY __fastcall sub_140008CCC(struct _SLIST_ENTRY *a1);
PSLIST_ENTRY __fastcall sub_140008CDC(struct _SLIST_ENTRY *a1);
PSLIST_ENTRY __fastcall sub_140008CEC(struct _SLIST_ENTRY *a1);
__int64 __fastcall sub_140008CFC(__int64 a1, __int64 a2);
bool __fastcall sub_140008DBC(_QWORD *a1, __int64 a2);
void (__fastcall *sub_140008DC4())(__int64 a1, unsigned int *a2);
char (__fastcall *sub_140008DCC())(__int64 a1, __int64 a2, __int64 a3);
char (__fastcall *sub_140008DD4())(__int64 a1, unsigned int *a2);
char (__fastcall *sub_140008DDC())(__int64 a1, unsigned int *a2);
NTSTATUS (*sub_140008DE4())();
char (__fastcall *sub_140008DEC())(__int64 a1, unsigned int *a2);
__int16 __fastcall sub_140008DF4(unsigned __int8 *a1);
__int64 __fastcall sub_140008E08(__int64 a1);
bool __fastcall sub_140008E10(__int64 a1);
bool __fastcall sub_140008E1C(__int64 a1);
bool __fastcall sub_140008E28(__int64 a1);
void __fastcall sub_140008E30(__int64 a1, __int64 a2, unsigned int *a3);
char __fastcall sub_140008E88(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140008EA8(__int64 a1, __int64 a2, unsigned int *a3);
char __fastcall sub_140008EC4(__int64 a1, __int64 a2, unsigned int *a3);
NTSTATUS sub_140008F58();
__int64 __fastcall sub_140008FA4(__int64 a1, char a2);
__int64 __fastcall sub_140008FCC(__int64 a1, char a2);
__int64 __fastcall sub_140009008(__int64 a1);
void __fastcall sub_1400090DC(__int64 a1);
signed __int64 __fastcall sub_1400090E4(unsigned int a1);
__int64 __fastcall sub_140009118(__int64 a1);
__int64 __fastcall sub_140009140(__int64 a1);
__int64 __fastcall sub_140009184(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400091F4(__int64 a1, int a2);
char __fastcall sub_14000939C(unsigned int *a1, unsigned int a2, __int64 a3);
__int64 __fastcall sub_140009460(__int64 *a1);
__int64 __fastcall sub_1400094A8(__int64 *a1);
__int64 __fastcall sub_1400094F0(__int64 *a1);
__int64 __fastcall sub_140009538(__int64 *a1);
char __fastcall sub_140009580(__int64 *a1);
__int64 __fastcall sub_1400096A4(unsigned __int8 *a1);
signed __int64 __fastcall sub_1400096B8(__int64 a1);
signed __int64 __fastcall sub_1400096C0(unsigned int *a1);
void __fastcall sub_1400096CC(__int64 a1);
__int64 __fastcall sub_1400096F4(__int64 a1);
__int64 __fastcall sub_14000970C(__int64 *a1);
void __fastcall sub_140009714(__int64 a1, void *a2);
__int64 __fastcall sub_140009724(__int64 a1, __int64 a2);
void *__fastcall sub_1400097C4(int a1);
__int64 *__fastcall sub_1400097D4(__int64 a1, __int64 *a2);
__int64 __fastcall sub_140009838(unsigned __int8 *a1);
void *sub_140009878();
__m128 *sub_1400098B4();
void *sub_1400098BC();
__int64 __fastcall sub_1400098F8(unsigned __int8 *a1);
__int64 __fastcall sub_140009938(_QWORD); // weak
__m128 *__fastcall sub_140009940(__int64 a1);
__int64 *__fastcall sub_140009998(__int64 *a1);
char __fastcall sub_1400099B8(unsigned __int8 *a1);
signed __int64 __fastcall sub_1400099CC(_BYTE *a1, unsigned __int64 a2, int a3, _DWORD *a4);
signed __int64 __fastcall sub_140009AC8(int a1, unsigned __int8 *a2, unsigned __int64 a3, _DWORD *a4);
__int64 sub_140009B58();
__int64 __fastcall sub_140009B64(_QWORD *a1);
__int64 __fastcall sub_140009BD0(__int64 a1);
bool __fastcall sub_140009BF0(_DWORD *a1);
char sub_140009BFC();
void sub_140009E30();
__int64 __fastcall sub_140009E44(__int64 a1);
__int64 __fastcall sub_140009E4C(__int64 *a1, __int64 a2, unsigned __int64 a3, __int64 (*a4)(void));
signed __int32 *sub_140009F04();
volatile signed __int32 *__fastcall sub_140009F20(volatile signed __int32 *a1);
void __fastcall sub_140009F2C(__int64 a1);
__int64 __fastcall sub_140009F34(__int64 a1, __int64 a2);
void __fastcall sub_140009F44(volatile signed __int32 **a1);
_QWORD *__fastcall sub_140009F6C(_QWORD *a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_14000A020(__int64 a1, __int64 (*a2)(void));
__int64 __fastcall sub_14000A078(__int64 *a1, __int64 a2);
unsigned __int64 __fastcall sub_14000A100(__int64 a1, unsigned int a2);
char __fastcall sub_14000A10C(__int64 a1);
__int64 __fastcall sub_14000A194(unsigned __int8 *a1);
__int64 __fastcall sub_14000A1A8(unsigned __int8 *a1);
void __fastcall sub_14000A1BC(int a1, int a2);
__int64 __fastcall sub_14000A25C(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000A2CC(__int64 a1);
char __fastcall sub_14000A31C(unsigned __int8 *a1);
signed __int64 __fastcall sub_14000A368(unsigned __int8 *a1);
__int64 __fastcall sub_14000A3E4(__int64 a1);
__int64 __fastcall sub_14000A3F0(__int64 a1);
char sub_14000A4D0();
__int64 __fastcall sub_14000A504(__int64 a1);
signed __int64 __fastcall sub_14000A59C(__int64 a1);
void __fastcall sub_14000A660(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4);
void __fastcall sub_14000AD60(_QWORD *a1);
signed __int64 __fastcall sub_14000AD68(__m128 *a1);
__int64 sub_14000AD94();
__int64 __fastcall sub_14000ADD8(__int64 a1);
__int64 __fastcall sub_14000ADF4(__int64 a1);
__int64 __fastcall sub_14000AE0C(__int64 a1);
__int64 sub_14000AE28();
__int64 sub_14000AE54();
__int64 __fastcall sub_14000AE80(__int64 a1);
__int64 __fastcall sub_14000AE9C(__int64 a1);
__int64 __fastcall sub_14000AEB4(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000AED8(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000AF00(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000AF2C(__int64 a1, __int64 a2);
bool __fastcall sub_14000AF5C(__int64 a1, __int64 a2);
bool __fastcall sub_14000AFE8(CMediaType *this, CMediaType *a2);
char __fastcall sub_14000B074(__int64 a1, _DWORD *a2, unsigned __int8 a3, char a4, __int16 a5, __int16 a6);
char __fastcall sub_14000B144(__int64 a1, __m128i *a2, unsigned __int8 a3, char a4, __int16 a5, __int16 a6);
signed __int64 __fastcall sub_14000B220(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_14000B294(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_14000B308(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_14000B37C(__int64 a1, __int64 a2);
_DWORD *__fastcall sub_14000B3F0(_DWORD *a1, _DWORD *a2, unsigned __int8 a3);
__m128i *__fastcall sub_14000B478(__m128i *a1, __m128i *a2, unsigned __int8 a3);
_WORD *__fastcall sub_14000B508(_WORD *a1, _DWORD *a2, char a3, __int16 a4, __int16 a5);
_WORD *__fastcall sub_14000B574(_WORD *a1, __m128i *a2, char a3, __int16 a4, __int16 a5);
volatile signed __int32 **__fastcall sub_14000B5E4(volatile signed __int32 **a1, volatile signed __int32 **a2, volatile signed __int32 *a3);
__int64 __fastcall sub_14000B60C(__int64 a1);
_QWORD *__fastcall sub_14000B628(_QWORD *a1, __int64 a2, __int64 a3);
_WORD *__fastcall sub_14000B634(_WORD *a1, _DWORD *a2, unsigned __int8 a3, char a4, __int16 a5, __int16 a6);
_WORD *__fastcall sub_14000B6A4(_WORD *a1, __m128i *a2, unsigned __int8 a3, char a4, __int16 a5, __int16 a6);
__int64 __fastcall sub_14000B714(__int64 a1, int a2, __int64 a3);
_DWORD *__fastcall sub_14000B720(_DWORD *a1);
__int64 __fastcall sub_14000B728(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000B73C(__int64 a1, int a2, __int16 a3);
volatile signed __int32 **__fastcall sub_14000B748(volatile signed __int32 **a1, volatile signed __int32 **a2);
volatile signed __int32 **__fastcall sub_14000B76C(volatile signed __int32 **a1, volatile signed __int32 *a2);
__int64 __fastcall sub_14000B790(_QWORD); // weak
__int64 __fastcall sub_14000B798(__int64 a1);
__int64 __fastcall sub_14000B7B0(__int64 a1);
__int64 __fastcall sub_14000B7C8(__int64 a1);
__int64 __fastcall sub_14000B7E0(__int64 a1);
__int64 *__fastcall sub_14000B7F8(__int64 *a1, __m128i *a2);
__int64 *__fastcall sub_14000B858(__int64 *a1, __m128i *a2);
__int64 *__fastcall sub_14000B8B8(__int64 *a1, __m128i *a2);
__int64 *__fastcall sub_14000B918(__int64 *a1, __m128i *a2);
volatile signed __int32 **__fastcall sub_14000B978(volatile signed __int32 **a1, volatile signed __int32 **a2);
char __fastcall sub_14000B9C0(_QWORD *a1, _QWORD *a2);
bool __fastcall sub_14000B9F8(_QWORD *a1, _QWORD *a2);
bool __fastcall sub_14000BA10(_DWORD *a1, _DWORD *a2);
char __fastcall sub_14000BA18(__int64 a1, _DWORD *a2);
bool __fastcall sub_14000BA3C(_QWORD *a1, _QWORD *a2);
char __fastcall sub_14000BA48(_QWORD *a1, _QWORD *a2);
bool __fastcall sub_14000BA58(_QWORD *a1, _QWORD *a2);
bool __fastcall sub_14000BA68(_DWORD *a1, _DWORD *a2);
char __fastcall sub_14000BA78(__int64 a1, _DWORD *a2);
signed __int64 __fastcall sub_14000BA88(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_14000BA94(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_14000BAA0(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_14000BAAC(__int64 a1, __int64 a2);
char __fastcall sub_14000BAB8(_QWORD *a1);
__int64 __fastcall sub_14000BAF8(__int64 a1);
signed __int64 __fastcall sub_14000BB00(__int64 a1);
signed __int64 __fastcall sub_14000BB20(__int64 a1);
signed __int64 __fastcall sub_14000BB40(__int64 a1);
signed __int64 __fastcall sub_14000BB60(__int64 a1);
__int64 __fastcall sub_14000BB80(__int64 a1);
__int64 __fastcall sub_14000BB98(__int64 a1);
__m128i *__fastcall sub_14000BBA0(__m128i *a1, __m128 *a2);
__int64 __fastcall sub_14000BBE0(__int64 a1);
__int64 __fastcall sub_14000BBF0(__int64 a1);
bool __fastcall sub_14000BC00(__int64 a1, __int64 a2);
bool __fastcall sub_14000BC74(__int64 a1, __int64 a2);
bool __fastcall sub_14000BCE8(__int64 a1, __int64 a2);
bool __fastcall sub_14000BD5C(__int64 a1, __int64 a2);
bool __fastcall sub_14000BDD0(unsigned int *a1);
bool __fastcall sub_14000BDF0(__int64 a1, unsigned int *a2);
char __fastcall sub_14000BE70(__int64 a1, __int64 a2);
char __fastcall sub_14000BED4(__int64 a1, __int64 a2);
char __fastcall sub_14000BF38(__int64 a1, __int64 a2);
char __fastcall sub_14000BF9C(__int64 a1, __int64 a2);
volatile signed __int32 *__fastcall sub_14000C000(volatile signed __int32 *a1);
PVOID __fastcall sub_14000C008(__int64 a1);
PVOID __fastcall sub_14000C05C(__int64 a1);
PVOID __fastcall sub_14000C0B0(__int64 a1);
PVOID __fastcall sub_14000C104(__int64 a1);
PVOID __fastcall sub_14000C158(__int64 a1, SIZE_T a2);
_DWORD *__fastcall sub_14000C16C(unsigned int *a1, _DWORD *a2);
__m128i *__fastcall sub_14000C1A8(unsigned int *a1, __m128i *a2);
signed __int64 __fastcall sub_14000C1E8(__int64 a1);
signed __int64 __fastcall sub_14000C1F8(__int64 a1);
signed __int64 __fastcall sub_14000C204(__int64 a1);
signed __int64 __fastcall sub_14000C214(__int64 a1);
char __fastcall sub_14000C224(__int64 *a1);
char __fastcall sub_14000C34C(__int64 *a1);
char __fastcall sub_14000C474(__int64 *a1);
char __fastcall sub_14000C59C(__int64 *a1);
__int64 __fastcall sub_14000C6C4(__int64 a1);
__int64 __fastcall sub_14000C724(__int64 a1);
__int64 __fastcall sub_14000C784(__int64 a1);
__int64 __fastcall sub_14000C7E4(__int64 a1);
bool __fastcall sub_14000C844(__int64 a1);
bool __fastcall sub_14000C8EC(__int64 a1, unsigned int *a2);
bool __fastcall sub_14000C92C(unsigned int *a1, __int64 a2);
__int64 __fastcall sub_14000C96C(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000C9CC(__int64 a1, __int64 a2);
__m128 *__fastcall sub_14000CA24(__int64 a1, __m128 *a2, __m128i *a3);
__m128 *__fastcall sub_14000CA88(__int64 a1, __m128 *a2, __m128i *a3);
__m128 *__fastcall sub_14000CAEC(__int64 a1, __m128 *a2, __m128i *a3);
__m128 *__fastcall sub_14000CB50(__int64 a1, __m128 *a2, __m128i *a3);
__int64 __fastcall sub_14000CBB4(__int64 *a1);
signed __int64 __fastcall sub_14000CBC8(__int64 a1);
signed __int64 __fastcall sub_14000CBD0(__int64 a1);
volatile signed __int32 **__fastcall sub_14000CBD8(__int64 a1, __m128 *a2);
__m128 *__fastcall sub_14000CC58(__int64 a1, __m128 *a2);
signed __int64 sub_14000CC70();
signed __int64 sub_14000CC78();
__int64 __fastcall sub_14000CC80(__int64 a1);
signed __int64 __fastcall sub_14000CC84(__int64 a1);
bool __fastcall sub_14000CC8C(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_14000CDCC(__int64 a1, __int64 a2, int a3);
signed __int64 __fastcall sub_14000D2B4(__int64 a1);
// const struct _GUID *__fastcall CMediaType::Subtype(CMediaType *__hidden this); idb
__int64 __fastcall sub_14000D2C4(__int64 a1, int a2);
volatile signed __int32 **__fastcall sub_14000D2F0(__int64 a1, volatile signed __int32 **a2, __int64 a3);
volatile signed __int32 **__fastcall sub_14000D3A0(__int64 a1, volatile signed __int32 **a2, __int64 a3);
__int64 __fastcall sub_14000D450(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000D4CC(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000D548(__int64 a1);
__int64 __fastcall sub_14000D9CC(__int64 a1);
__int64 __fastcall sub_14000DE50(__int64 a1);
__int64 __fastcall sub_14000E2D4(__int64 a1);
__int64 __fastcall sub_14000E758(unsigned int a1);
signed __int64 __fastcall sub_14000E760(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_14000E7B8(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_14000E814(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_14000E874(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000E8D8(__int64 a1, int a2);
__m128i *__fastcall sub_14000E904(__int64 a1, __m128 *a2, __int64 a3);
__int64 __fastcall sub_14000E958(__int64 a1);
__int64 __fastcall sub_14000E98C(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000E9EC(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000EA40(unsigned int *a1);
_QWORD *__fastcall sub_14000EA44(__int64 *a1, _QWORD *a2);
volatile signed __int32 **__fastcall sub_14000EA64(__int64 a1, volatile signed __int32 **a2);
bool __fastcall sub_14000EA98(__int64 a1);
bool __fastcall sub_14000EAAC(__int64 a1);
bool __fastcall sub_14000EAB8(__int64 a1);
_QWORD *__fastcall sub_14000EACC(__int64 a1, _QWORD *a2);
volatile signed __int32 **__fastcall sub_14000EAEC(__int64 a1, volatile signed __int32 **a2);
__int64 __fastcall sub_14000EB80(__int64 a1);
__int64 __fastcall sub_14000EB88(__int64 a1, int a2);
__int64 __fastcall sub_14000EC10(_QWORD *a1);
__int64 __fastcall sub_14000EC28(_QWORD *a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_14000ED60(_QWORD *a1);
__int64 __fastcall sub_14000ED80(__int64 a1, __int64 a2, __int64 a3, __int64 (*a4)(void));
void __fastcall sub_14000EDD0(_QWORD *a1);
__int64 __fastcall sub_14000EE20(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000EE30(__int64 a1, char *a2);
__m128i *__fastcall sub_14000EE6C(__m128i *a1, __int64 a2, __int32 a3, __int32 a4, __int32 a5, __m128i *a6, __int64 a7);
void **__fastcall sub_14000EEF0(_QWORD *a1);
// __int64 __fastcall CPullPin::~CPullPin(CPullPin *__hidden this); idb
PSLIST_ENTRY __fastcall sub_14000EF28(struct _SLIST_ENTRY *a1);
__int64 __fastcall sub_14000EF38(_QWORD, _QWORD); // weak
__int64 __fastcall sub_14000EF40(_QWORD, _QWORD); // weak
__int64 (__fastcall *sub_14000EF48())(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000EF50(__int64 a1, __int64 a2, __int64 a3);
void *__fastcall sub_14000EF70(_QWORD *a1, char a2);
struct _SLIST_ENTRY *__fastcall sub_14000EFB0(CPullPin *a1, char a2);
PVOID __fastcall sub_14000EFF4(__int64 a1, __int64 a2);
void __fastcall sub_14000F020(__int64 a1);
__int64 *__fastcall sub_14000F17C(__int64 *a1, __int16 a2);
void __fastcall sub_14000F1AC(__int64 a1);
__int64 __fastcall sub_14000F1B8(__int64 a1, int a2);
__int64 __fastcall sub_14000F29C(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000F2D0(__int64 a1, __int64 a2);
void __fastcall sub_14000F2E0(__int64 a1);
void __fastcall sub_14000F310(_BYTE *a1);
void __fastcall sub_14000F338(__int64 a1, void *a2);
__int64 __fastcall sub_14000F348(__int64 _RCX);
signed __int64 __fastcall sub_14000F368(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000F394(__int64 a1);
__m128i *__fastcall sub_14000F3A0(__m128i *a1, __m128i *a2);
bool __fastcall sub_14000F3B0(__int64 a1);
void __fastcall sub_14000F3BC(__int64 *a1);
__int64 __fastcall sub_14000F454(__int64 a1);
signed __int64 __fastcall sub_14000F458(__int64 *a1, __int64 a2);
__int64 __fastcall sub_14000F49C(__int64 *a1);
_QWORD *__fastcall sub_14000F4B8(_QWORD *a1);
_QWORD *__fastcall sub_14000F500(_QWORD *a1);
char __fastcall sub_14000F544(__int64 *a1);
char __fastcall sub_14000F568(__int64 *a1);
char __fastcall sub_14000F588(__int64 *a1);
char __fastcall sub_14000F5AC(__int64 *a1);
char __fastcall sub_14000F5CC(__int64 *a1);
__int64 __fastcall sub_14000F5EC(__int64 a1);
__int64 __fastcall sub_14000F604(__int64 a1);
__int64 __fastcall sub_14000F61C(__int64 a1);
__int64 __fastcall sub_14000F638(__int64 a1);
__int64 __fastcall sub_14000F650(__int64 a1);
__int64 __fastcall sub_14000F66C(__int64 a1);
__int64 __fastcall sub_14000F688(__int64 a1);
__int64 __fastcall sub_14000F6A0(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_14000F6F0(__int64 a1, __int64 a2, int a3);
struct _MDL **__fastcall sub_14000F738(struct _MDL **a1, void *a2, ULONG a3);
__int64 __fastcall sub_14000F77C(_QWORD *a1);
__int64 __fastcall CAMEvent::~CAMEvent(CAMEvent *this); // idb
_QWORD *__fastcall sub_14000F7A0(_QWORD *a1, _QWORD *a2);
CAMEvent *__fastcall sub_14000F7F0(CAMEvent *a1, CAMEvent *a2);
PVOID __fastcall sub_14000F824(SIZE_T *a1);
char __fastcall sub_14000F868(__int64 *a1, __int64 a2, unsigned __int64 a3);
char __fastcall sub_14000F908(__int64 *a1, __int64 a2, unsigned __int64 a3);
void __fastcall sub_14000F9A8(_QWORD *a1);
// __int64 __fastcall CAMEvent::~CAMEvent(CAMEvent *__hidden this); idb
__int64 __fastcall sub_14000FA44(SIZE_T *a1);
PVOID __fastcall sub_14000FB70(struct _MDL *a1, KPROCESSOR_MODE a2, MEMORY_CACHING_TYPE a3, void *a4, ULONG a5, int a6);
// PVOID __stdcall RtlSecureZeroMemory(PVOID ptr, SIZE_T cnt);
_QWORD *__fastcall sub_14000FBA0(_QWORD *a1);
__int64 __fastcall sub_14000FBC8(_QWORD *a1);
__int64 __fastcall sub_14000FBE0(_QWORD *a1);
__int64 __fastcall sub_14000FBF8(__int64 a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_14000FCFC(__int64 *a1, __int64 a2);
__m128 *sub_14000FD60();
void *sub_14000FD68();
__int64 __fastcall sub_14000FD70(__int64 a1);
PVOID __fastcall sub_14000FD78(__int64 a1, int a2);
void __fastcall sub_14000FDA4(_QWORD *a1);
__int64 __fastcall sub_14000FE4C(__int64 a1, int a2, unsigned int *a3, __int16 a4);
__int64 __fastcall sub_14000FEA0(__int64 a1, __int64 a2, unsigned __int64 a3);
char __fastcall sub_14000FEFC(unsigned int *a1, unsigned int *a2);
bool __fastcall sub_14000FFCC(unsigned int *a1, unsigned int *a2);
__int64 __fastcall sub_14001009C(__int64 a1, int a2, unsigned int *a3, __int16 a4);
void __fastcall sub_1400100D8(_DWORD *a1, __int16 *a2);
__int16 __fastcall sub_1400102AC(__int64 a1, __int64 a2, unsigned __int64 a3);
signed __int64 __fastcall sub_140010498(__int16 a1);
bool __fastcall sub_1400104D8(_DWORD *a1, _DWORD *a2, int a3, int a4);
bool __fastcall sub_140010544(_DWORD *a1, _DWORD *a2, int a3);
bool __fastcall sub_140010588(__int64 a1, __int64 a2);
bool __fastcall sub_140010594(__int64 a1, __int64 a2, int a3);
bool __fastcall sub_1400105F0(_DWORD *a1, unsigned __int16 a2, _DWORD *a3, unsigned __int16 a4);
bool __fastcall sub_140010608(_DWORD *a1, unsigned __int16 a2, _DWORD *a3, unsigned __int16 a4);
__int64 __fastcall sub_140010640(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_140010680(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400106F4(__int64 a1, int a2, _OWORD *a3);
__int64 __fastcall sub_140010744(__int64 a1);
__int64 __fastcall sub_140010750(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_140010894(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_1400108CC(_QWORD); // weak
__int64 __fastcall sub_1400108D4(__int64 a1);
__int64 __fastcall sub_140010900(_QWORD); // weak
__int64 sub_140010908(void); // weak
__int64 __fastcall sub_140010910(__int64 a1);
PSLIST_ENTRY __fastcall sub_140010928(struct _SLIST_ENTRY *a1);
__int64 *__fastcall sub_140010938(__int64 *a1, __m128i *a2);
signed __int64 __fastcall sub_140010998(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400109A4(unsigned __int64 a1);
signed __int64 __fastcall sub_1400109EC(__int64 a1);
bool __fastcall sub_140010A0C(__int64 a1, __int64 a2);
void *__fastcall sub_140010A1C(void *a1, char a2);
char __fastcall sub_140010A50(__int64 a1, __int64 a2);
char __fastcall sub_140010AB4(__int64 a1, __int64 a2);
PVOID __fastcall sub_140010AD0(__int64 a1);
signed __int64 __fastcall sub_140010B24(__int64 a1);
char __fastcall sub_140010B34(__int64 *a1);
char __fastcall sub_140010C5C(__int64 a1, int a2);
signed __int64 __fastcall sub_140010C78(__int64 a1, __int64 a2, char a3);
__int64 __fastcall sub_140010EF4(__int64 a1, __int64 a2, unsigned int a3, __int64 a4);
__int64 __fastcall sub_140011020(__int64 *a1);
char __fastcall sub_140011068(__int64 a1);
__m128 *__fastcall sub_140011070(__int64 a1, __m128 *a2, __m128i *a3);
volatile signed __int32 **__fastcall sub_1400110D4(__int64 a1, volatile signed __int32 **a2, __int64 a3);
__int64 __fastcall sub_1400111B8(__int64 a1);
__int64 __fastcall sub_1400111BC(__int64 a1);
char __fastcall sub_1400111C8(__int64 a1);
__int64 __fastcall sub_1400111D0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140011244(__int64 a1);
__int64 __fastcall sub_1400116C8(__int64 *a1);
signed __int64 __fastcall sub_140011790(__int64 a1, __int64 a2);
char __fastcall sub_140011804(__int64 a1, __int64 a2);
__int64 __fastcall sub_140011868(__int64 a1, _OWORD *a2);
char __fastcall sub_140011900(__int64 a1, __int64 a2);
void __fastcall sub_14001190C(__int64 a1, int a2);
__int64 __fastcall sub_140011914(__int64 a1, unsigned int a2);
void __fastcall sub_140011924(__int64 a1, char a2);
void __fastcall sub_140011928(__int64 a1, unsigned int a2);
void __fastcall sub_140011958(__int64 a1, __int64 a2);
__int64 __fastcall sub_140011960(__int64 a1);
// __int64 __fastcall std::ios_base::precision(std::ios_base *__hidden this); idb
void *__fastcall sub_1400119A0(__int64 a1);
__int64 __fastcall sub_1400119C0(__int64 a1);
volatile signed __int32 **__fastcall sub_1400119D8(__int64 a1, volatile signed __int32 **a2);
__int64 __fastcall sub_140011A0C(__int64 a1);
__int64 __fastcall sub_140011A8C(_QWORD); // weak
__int64 __fastcall sub_140011A94(__int64 a1);
__int64 __fastcall sub_140011AA0(_QWORD *a1, __int64 a2);
__int64 sub_140011AB8();
__int64 __fastcall sub_140011AE0(__int64 a1);
void **__fastcall sub_140011AF8(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_140011C64(_QWORD *a1, unsigned int a2);
__int64 __fastcall sub_140011CB4(_QWORD); // weak
void __fastcall sub_140011CBC(__int64 a1);
void __fastcall sub_140011CD8(void **a1);
_QWORD *__fastcall sub_140011CFC(_QWORD *a1, _QWORD *a2);
_QWORD *__fastcall sub_140011D10(_QWORD *a1, __int64 a2, int *a3);
__m128i *__fastcall sub_140011D38(__m128i *a1, __m128i *a2);
signed __int64 __fastcall sub_140011D50(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_140011DD0(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_140011E60(__int64 a1, __int64 a2);
struct _LIST_ENTRY *__fastcall sub_140011EC8(struct _LIST_ENTRY *a1);
__int64 **__fastcall sub_140011EEC(__int64 **a1, __int64 *a2);
signed __int64 *__fastcall sub_140011F0C(signed __int64 *a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_140011F30(__int64 a1, __int64 a2, int a3);
_DWORD *__fastcall sub_140011F40(_DWORD *a1);
__int64 __fastcall sub_140011F4C(__int64 a1, volatile signed __int32 *a2);
_QWORD *__fastcall sub_140011F6C(_QWORD *a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_140011FEC(_QWORD); // weak
char __fastcall sub_140011FF4(__int64 **a1);
void __fastcall sub_140011FFC(__int64 a1);
char __fastcall sub_140012014(__int64 a1);
__int64 __fastcall sub_1400120F0(__int64 a1);
__int64 __fastcall sub_140012108(__int64 a1);
__int64 __fastcall sub_140012120(__int64 a1);
PSLIST_ENTRY __fastcall sub_140012138(struct _SLIST_ENTRY *a1);
PSLIST_ENTRY __fastcall sub_140012148(struct _SLIST_ENTRY *a1);
PSLIST_ENTRY __fastcall sub_140012158(struct _SLIST_ENTRY *a1);
// __int64 __fastcall unknown_libname_5(_QWORD, _QWORD); weak
bool __fastcall sub_14001217C(_QWORD *a1, _QWORD *a2);
char __fastcall sub_14001218C(__int64 a1);
__int64 __fastcall sub_140012190(__int64 a1);
char *__fastcall sub_1400121A8(__int64 *a1, unsigned __int64 a2);
char __fastcall sub_1400121B0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140012288(__int64 a1);
bool __fastcall sub_14001229C(volatile signed __int32 *a1);
__int64 __fastcall sub_1400122AC(__int64 *a1);
__int64 __fastcall sub_1400122F4(__int64 *a1);
__int64 __fastcall sub_14001233C(__int64 *a1);
// void __fastcall CPullPin::Process(CPullPin *__hidden this); idb
// __int64 __fastcall sub_14001252C(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall sub_1400126F4(_QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_140012758(__int64 *a1);
void __fastcall sub_140012760(__int64 *a1, __int64 a2, __int64 a3);
char __fastcall sub_140012768(__int64 a1, __int64 a2);
char __fastcall sub_1400128AC(__int64 a1);
__int64 __fastcall sub_140012914(__int64 a1);
void __fastcall sub_140012920(_DWORD *a1);
_DWORD *__fastcall sub_140012928(unsigned int *a1);
bool __fastcall sub_140012944(__int64 a1);
_QWORD *__fastcall sub_140012B34(__int64 a1, __int64 a2);
void __fastcall sub_140012B54(_DWORD *a1);
char __fastcall sub_140012B5C(__int64 a1, __int64 a2);
__int64 __fastcall sub_140012CF0(__int64 *a1, _QWORD *a2);
__int64 __fastcall sub_140012D10(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_140012D30(__int64 a1, __int64 a2, __m128i *a3);
__int64 __fastcall sub_140012D9C(__int64 a1);
__int64 __fastcall sub_140012DD4(_QWORD); // weak
void *sub_140012DDC();
PVOID __fastcall sub_140012DF0(__int64 a1, unsigned int a2);
__int64 __fastcall sub_140012E0C(unsigned int *a1, unsigned int *a2);
__int64 __fastcall sub_140012E60(__int64 a1, unsigned int *a2, unsigned int *a3);
void __fastcall sub_140012E70(__int64 a1, void *a2);
__int64 __fastcall sub_140012E90(__int64 a1);
__int64 __fastcall sub_140012EB8(__int64 a1, __int64 a2);
bool sub_140012EE8();
// __int64 __fastcall RtlLookupElementGenericTableAvl(_QWORD, _QWORD); weak
char __fastcall sub_140012F04(__int64 a1, __int64 a2, __int64 a3, __int64 *a4);
// __int64 RtlNumberGenericTableElementsAvl(void); weak
// __int64 __fastcall RtlDeleteElementGenericTableAvl(_QWORD, _QWORD); weak
signed __int64 __fastcall sub_140012F5C(__int64 *a1, __int64 a2, __int64 *a3, __int64 a4);
__int64 __fastcall sub_140012F8C(char *a1, __int64 a2, __int64 a3);
_DWORD *__fastcall sub_14001301C(_DWORD *a1, int a2);
_DWORD *__fastcall sub_140013028(_DWORD *a1, int a2);
char __fastcall sub_14001304C(unsigned int a1, unsigned int a2);
__int64 __fastcall sub_1400130C4(_DWORD *a1);
signed __int64 sub_1400130E0();
__int64 sub_1400130E8();
__int64 __fastcall sub_140013160(_QWORD *a1);
void __fastcall sub_140013170(_DWORD *a1);
void *sub_140013188();
__int64 sub_140013190();
__int64 __fastcall sub_140013284(__int64 a1, unsigned __int8 *a2);
__int64 *__fastcall sub_1400132DC(__int64 a1, unsigned __int16 *a2);
__int64 __fastcall sub_1400133C8(__int64 a1, unsigned __int64 a2);
__int64 *__fastcall sub_140013490(__int64 *a1, int *a2);
__int64 __fastcall sub_140013548(__int64 a1, unsigned int *a2);
__int64 *__fastcall sub_1400135BC(__int64 a1, unsigned int *a2);
__int64 __fastcall sub_14001361C(__int64 a1, __int64 a2);
__int64 __fastcall sub_140013960(__int64 a1, unsigned int *a2);
__int64 __fastcall sub_1400139C4(__int64 a1, unsigned int a2);
__int64 __fastcall sub_140013A7C(__int64 a1, unsigned int a2);
signed __int64 __fastcall sub_140013AF0(unsigned int a1);
signed __int64 __fastcall sub_140013B18(unsigned __int64 a1);
signed __int64 __fastcall sub_140013B4C(unsigned int a1);
signed __int64 __fastcall sub_140013B64(unsigned __int64 a1);
__int64 __fastcall sub_140013B7C(__int64 a1);
__int64 __fastcall sub_140013B88(__int64 a1);
__int64 __fastcall sub_140013B98(__int64 a1);
__int64 __fastcall sub_140013BAC(__int64 a1);
__int64 __fastcall sub_140013BC4(__int64 a1, unsigned int a2);
__int64 __fastcall sub_140013D10(__int64 a1, unsigned __int64 a2);
_DWORD *__fastcall sub_140013E70(_DWORD *a1, int a2, int a3);
_QWORD *__fastcall sub_140013E7C(_QWORD *a1);
__m128i *__fastcall sub_140013E8C(__m128i *a1, __int64 a2, __int32 a3, __int32 a4, __m128i *a5);
_DWORD *__fastcall sub_140013F08(_DWORD *a1, int a2);
__int64 *__fastcall sub_140013F10(__int64 *a1, char a2);
__int64 __fastcall sub_140013F18(_QWORD, _QWORD); // weak
__int64 __fastcall sub_140013F20(_QWORD, _QWORD); // weak
__int64 __fastcall sub_140013F30(__int64 a1);
__int64 __fastcall sub_140013F40(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_140013FFC(__int64 a1);
_DWORD *__fastcall sub_140014034(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_140014070(__int64 a1);
__int64 sub_140014088(void); // weak
__int64 __fastcall sub_140014090(__int64 a1);
signed __int64 sub_1400140A0();
__int16 __fastcall sub_1400140B0(unsigned __int16 a1);
__m128i *__fastcall sub_1400140C0(__int64 a1, unsigned int *a2);
__int64 __fastcall sub_140014170(__int64 a1);
__int64 __fastcall sub_14001419C(__int64 a1);
void __fastcall sub_1400141B0(__int64 a1);
char __fastcall sub_1400141B8(__int64 a1, char a2);
void __fastcall sub_1400141C0(__int64 a1, __int16 a2);
void __fastcall sub_1400141C8(__int64 a1, int a2);
_QWORD *__fastcall sub_1400141CC(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_1400141EC(_QWORD *a1, unsigned int a2, unsigned int a3);
_QWORD *__fastcall sub_140014290(_QWORD *a1);
void __fastcall sub_1400142A0(PKSPIN_LOCK *a1);
void **__fastcall sub_1400142B0(_QWORD *a1, __int64 a2);
void **__fastcall sub_140014314(_QWORD *a1);
_QWORD *__fastcall sub_140014320(_QWORD *a1, __int64 a2);
signed __int64 __fastcall sub_14001435C(__int64 a1, unsigned __int64 a2);
void __fastcall sub_1400143F4(__int64 *a1);
__int64 __fastcall sub_14001445C(__int64 a1);
unsigned __int64 __fastcall sub_1400145A0(__int64 a1, __m128i *a2, unsigned __int64 a3);
__int64 __fastcall sub_140014630(__int64 a1, __m128i *a2, unsigned __int64 a3, int a4);
signed __int64 __fastcall sub_14001470C(__int64 a1);
__int64 sub_14001478C(__int64 a1, _QWORD *a2, unsigned __int64 a3, ...);
__int64 __fastcall sub_1400147C0(__int64 a1, _QWORD *a2, unsigned __int64 a3);
__int64 __fastcall sub_1400147E0(__int64 a1, _QWORD *a2, unsigned __int64 a3);
__int64 __fastcall sub_14001489C(__int64 a1, _QWORD *a2, unsigned __int64 a3, __int64 a4);
void __fastcall sub_140014990(_QWORD *a1);
__int64 sub_1400149DC();
unsigned __int64 __fastcall sub_1400149E8(__int64 a1, __m128i *a2, unsigned __int64 a3, unsigned __int64 a4);
__int64 sub_140014A78(_QWORD *a1, __int64 a2, __int64 a3, int a4, ...);
_QWORD *__fastcall sub_140014B00(_QWORD *a1);
char __fastcall sub_140014B10(signed int *a1, signed int a2);
void __fastcall sub_140014B2C(signed int a1);
__int64 __fastcall sub_140014B64(signed int a1, __m128i *a2, unsigned __int64 a3, int a4);
signed __int64 __fastcall sub_140014BC8(signed int a1);
__int64 __fastcall sub_140014C04(signed int a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, __int64 a11);
void __fastcall sub_140014D44(signed int a1);
char __fastcall sub_140014D7C(signed int a1);
_QWORD *__fastcall sub_140014DB4(_QWORD *a1);
_QWORD *__fastcall sub_140014DCC(_QWORD *a1, __int64 a2);
__int64 (__fastcall **__fastcall sub_140014E00(_QWORD *a1))();
void *__fastcall sub_140014E10(_QWORD *a1, char a2);
__int64 __fastcall sub_140014E44(PCUNICODE_STRING SourceString, PCUNICODE_STRING Source, PUNICODE_STRING DestinationString); // idb
__int64 __fastcall sub_140014F1C(__int64 (***a1)(void), UNICODE_STRING *a2);
__int64 __fastcall sub_140015040(__int64 a1, _QWORD *a2);
NTSTATUS __fastcall sub_1400150A8(HANDLE LinkHandle, PUNICODE_STRING LinkTarget, __int16 a3);
// __int64 __fastcall std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::_Getint(PUNICODE_STRING Destination); idb
// __int64 __fastcall sub_14001539C(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall sub_1400153D4(_QWORD); weak
// __int64 __fastcall sub_1400153DC(_QWORD); weak
// __int64 sub_1400153E4(void); weak
// __int64 __fastcall sub_1400153F0(_QWORD); weak
// __int64 __fastcall sub_140015400(_QWORD); weak
// __int64 sub_140015410(void); weak
// __int64 __fastcall sub_140015444(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall sub_14001545C(_QWORD); weak
__int64 __fastcall sub_1400154CC(__int64 a1);
NTSTATUS sub_1400154D4();
__int64 __fastcall sub_1400154E0(__int64 a1);
void __fastcall sub_1400154F0(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_1400154FC(__int8 a1, __int64 a2, __int64 a3, unsigned __int64 a4, unsigned __int32 a5, __int64 a6, __int64 a7);
__int64 __fastcall sub_140015718(__int64 a1, PVOID *a2);
signed __int64 __fastcall sub_140015910(__int64 a1);
__int64 __fastcall sub_140015A08(__int64 a1);
void __fastcall sub_140015B50(_QWORD **a1, char a2);
char __fastcall sub_140015BA0(unsigned __int16 *a1, int *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, _DWORD *a7);
_LIST_ENTRY *__fastcall sub_140015F00(_LIST_ENTRY **a1, _BYTE *a2);
char __fastcall sub_140015F84(__int64 *a1, _BYTE *a2);
void __fastcall sub_140015FB0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, _DWORD *a7);
void __fastcall sub_1400164C0(_QWORD *a1, __int64 a2);
void __fastcall sub_1400164F0(PVOID StartContext);
__int64 __fastcall j_unknown_libname_6(_QWORD); // weak
char __fastcall sub_1400169B0(__int64 a1, __int64 a2);
void __fastcall sub_1400169E0(_WORD *a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 a5, __int64 a6, _DWORD *a7);
char sub_140016F00();
void __fastcall sub_140016F08(char a1, __int64 a2);
signed __int64 __fastcall sub_140017008(signed int a1, signed int *a2);
void __fastcall sub_140017120(__int64 a1);
signed __int64 sub_1400171AC();
__int64 __fastcall sub_1400171B4(__int64 a1);
char sub_1400171C0();
void sub_1400171C8();
__int64 __fastcall sub_1400172C8(_QWORD *a1, __int64 a2, __int64 a3, const wchar_t *a4);
signed __int64 __fastcall sub_140017358(__int64 *a1, __int64 a2, int *a3, __int64 a4);
signed __int64 __fastcall sub_140017474(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_1400175DC(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_140017800(__int64 a1, __int64 a2);
void sub_140017914();
void __fastcall sub_140017930(signed int a1);
LONG __fastcall sub_140017980(int a1);
char sub_1400179D0();
signed __int64 __fastcall sub_1400179D8(__int64 *a1, __int64 a2);
__int64 sub_140017C28();
__int64 sub_140017C54();
__int64 sub_140017C80();
__int64 __fastcall sub_140017CA8(__int64 a1);
signed __int64 __fastcall sub_140017CC0(__int64 a1, unsigned int a2);
bool __fastcall sub_140017CE0(__int64 a1, unsigned int a2);
bool __fastcall sub_140017D08(wchar_t *Str2);
__int64 __fastcall sub_140017E18(__int64 a1, _QWORD *a2, _DWORD *a3, __int64 a4);
_QWORD *__fastcall sub_140017E6C(_QWORD *a1, void *a2);
void __fastcall sub_140017E9C(__int64 a1);
LONG __fastcall sub_140017ECC(PRKMUTEX *a1);
__int64 __fastcall sub_140017ED8(_QWORD **a1);
_QWORD *__fastcall sub_140017EFC(_QWORD *a1);
__int64 __fastcall sub_140017F14(__int64 a1);
KIRQL __fastcall sub_140017F2C(KSPIN_LOCK *a1);
__int64 sub_140017F44(void); // weak
// __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD, _QWORD); weak
__int64 __fastcall sub_140017F54(_QWORD); // weak
__int64 __fastcall sub_140017F84(unsigned __int16 *a1);
char __fastcall sub_140017FAC(__int64 a1, unsigned int a2, _WORD *a3, unsigned int a4);
char __fastcall sub_140018018(__int64 a1, __int64 a2);
__m128 *__fastcall sub_1400181F8(unsigned __int64 a1, __int64 a2);
__int64 __fastcall sub_140018390(__int64 a1);
void __fastcall sub_1400183C4(__int64 a1);
void sub_1400184C0();
void sub_14001859C();
char __fastcall sub_1400185F8(__int64 a1, __int64 a2);
void __fastcall sub_14001881C(__int64 a1);
void __fastcall sub_140018990(__int64 a1);
void __fastcall sub_140018AB0(__int64 a1);
void __fastcall sub_140018B38(__int64 a1);
void sub_140018BC0();
__int64 __fastcall sub_140018BC8(_DWORD *a1, __int64 a2);
__int64 __fastcall sub_140018CAC(_DWORD *a1, __int64 a2);
void __fastcall sub_140018D18(__int64 a1);
signed __int64 __fastcall sub_140018E38(_DWORD *a1, __int64 a2);
__int64 __fastcall sub_140018EF0(__int64 a1);
void __fastcall StartRoutine(PVOID StartContext);
NTSTATUS __fastcall sub_140018F0C(__int64 a1);
void __fastcall sub_140019058(__int64 a1, __int64 a2);
void __fastcall sub_1400190D8(int a1);
signed __int64 __fastcall sub_1400191E8(_DWORD *a1, unsigned __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_140019278(_DWORD *a1, __int64 a2);
LONG_PTR __fastcall sub_140019398(_DWORD *a1);
__int64 sub_140019408();
void sub_140019438();
void __fastcall sub_14001944C(__int64 (**a1)(void), unsigned __int64 a2);
__int64 __fastcall sub_1400194B0(__int64 a1);
NTSTATUS __fastcall sub_1400194D4(__int64 a1, PVOID *a2, _DWORD *a3);
bool sub_140019690();
bool __fastcall sub_14001969C(int a1, __m128i *a2);
char __fastcall sub_140019714(int a1);
void sub_1400197DC();
_QWORD *__fastcall sub_140019828(_QWORD *a1, int a2, __int64 a3);
int sub_140019900();
__m128i *__fastcall sub_140019988(unsigned __int64 a1, __m128i *a2);
__m128i *__fastcall sub_14001999C(unsigned __int64 a1, char a2);
void sub_1400199C0();
signed __int64 sub_140019A1C();
signed __int64 __fastcall sub_140019A3C(__int64 a1);
__int64 sub_140019D34();
_DWORD *__fastcall sub_140019D80(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, _DWORD *a7);
__int64 sub_140019DF8(void); // weak
LONG __fastcall sub_140019E00(char a1);
__int64 __fastcall sub_140019E4C(unsigned __int64 a1, __int64 a2);
void sub_140019F90();
__int64 __fastcall sub_140019FA0(__int64 a1);
__int64 sub_14001A144();
__int64 __fastcall sub_14001A22C(__int64 a1, __int16 a2, int a3, char a4, __int64 a5, __int16 a6, __int64 a7, __int64 a8, __int64 a9, char a10, unsigned __int8 a11, __int64 a12, __int64 a13, __int64 a14);
void __fastcall sub_14001A6C0(__int64 a1);
void *__fastcall sub_14001A6E0(__int64 a1, char a2);
__int64 __fastcall sub_14001A714(__int64 a1, __m128i *a2, _DWORD *a3, char a4, _DWORD *a5);
__int64 __fastcall sub_14001A7C0(__int64 a1, __m128i *a2, __m128i **a3, __int8 a4, __m128i *a5);
__int64 __fastcall sub_14001A850(__int64 a1, __int64 a2, __int64 a3, __m128i *a4, __int64 a5, unsigned __int8 *a6, unsigned __int8 a7, _QWORD *a8);
__int64 __fastcall sub_14001AADC(__int64 a1, __int64 a2, __m128i *a3);
__int64 __fastcall sub_14001AF08(__int64 a1, __int64 a2, __m128i *a3, _QWORD *a4, unsigned __int8 *a5);
void __fastcall sub_14001B028(__int64 a1);
__int64 __fastcall sub_14001B088(__int64 a1);
void sub_14001B0D8();
void sub_14001B0E0();
signed __int64 __fastcall sub_14001B144(unsigned __int64 a1, __int64 a2);
__int64 __fastcall sub_14001B350(__int64 a1, char a2);
__int64 __fastcall sub_14001B420(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5);
void sub_14001BE38();
void __fastcall sub_14001BE54(char a1);
void __fastcall sub_14001BE90(__int64 a1);
__int64 __fastcall sub_14001BF50(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14001BFD0(); // weak
__int64 __fastcall sub_14001BFE0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14001C000(__int64 a1);
void __fastcall sub_14001C0E8(_DWORD *a1);
__int64 __fastcall sub_14001C11C(__int64 a1, __m128 *a2, char a3);
__int64 sub_14001C1C4();
signed __int64 sub_14001C258();
__int64 __fastcall sub_14001C278(_QWORD *a1, __int64 a2, __int64 a3);
void sub_14001C2B4();
__int64 __fastcall sub_14001C2D0(__int64 a1, unsigned __int64 a2, __int64 a3);
__int64 __fastcall sub_14001C32C(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_14001C368(_WORD *a1, __int64 a2, signed __int64 *a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_14001C3DC(_WORD *a1, __int64 a2, _QWORD *a3);
__int64 __fastcall sub_14001C41C(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
// __int64 __fastcall unknown_libname_7(_QWORD, _QWORD, _QWORD); weak
__int64 sub_14001C460();
__int64 __fastcall sub_14001C5FC(__int64 *a1, __int64 a2, __int64 *a3, char a4);
signed __int64 __fastcall sub_14001C854(__int64 a1, int a2);
signed __int64 __fastcall sub_14001D170(int a1);
void __fastcall sub_14001D230(int a1);
signed __int64 __fastcall sub_14001D318(__int64 *a1, int a2, __int64 (*a3)(void));
__int64 __fastcall sub_14001D398(_QWORD *a1, __int64 a2);
void __fastcall sub_14001D3B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__m128 *__fastcall sub_14001D3D4(__m128 *a1, int a2);
__int64 __fastcall sub_14001D418(__int64 a1);
__int64 __fastcall sub_14001D434(__int64 a1);
__int64 sub_14001D44C();
__int64 __fastcall sub_14001D474(__int64 a1);
__int64 __fastcall sub_14001D490(__int64 a1);
__int64 __fastcall sub_14001D4AC(__int64 a1);
__int64 sub_14001D4C4();
__int64 __fastcall sub_14001D4EC(__int64 a1);
__int64 sub_14001D508();
__int64 __fastcall sub_14001D530(__int64 a1);
__int64 sub_14001D54C();
__int64 sub_14001D584();
void __fastcall sub_14001D5B0(_DWORD *a1, int a2);
void sub_14001D5C0();
__int64 __fastcall sub_14001D5D4(__int64 a1);
int __fastcall sub_14001D640(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, _DWORD *a7);
int __fastcall sub_14001D720(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, _DWORD *a7);
void sub_14001D7F8();
signed __int64 sub_14001D808();
signed __int64 __fastcall sub_14001D894(__int64 a1, __int64 a2, unsigned __int64 a3);
// __int64 __fastcall NdisRetreatNetBufferDataStart(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall NdisAdvanceNetBufferDataStart(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall NdisCopySendNetBufferListInfo(_QWORD, _QWORD); weak
// __int64 __fastcall NdisCopyReceiveNetBufferListInfo(_QWORD, _QWORD); weak
// __int64 __fastcall NdisAllocateGenericObject(_QWORD, _QWORD, _QWORD); weak
// __int64 NdisFreeGenericObject(void); weak
// __int64 __fastcall NdisAllocateNetBufferListPool(_QWORD, _QWORD); weak
// __int64 NdisFreeNetBufferListPool(void); weak
// __int64 __fastcall NdisFreeMdl(_QWORD); weak
// __int64 __fastcall FwpsCalloutRegister1(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpsCalloutUnregisterById0(_QWORD); weak
// __int64 __fastcall FwpsCompleteOperation0(_QWORD, _QWORD); weak
// __int64 __fastcall FwpsReferenceNetBufferList0(_QWORD, _QWORD); weak
// __int64 __fastcall FwpsDereferenceNetBufferList0(_QWORD, _QWORD); weak
// __int64 __fastcall FwpmFreeMemory0(_QWORD); weak
// __int64 __fastcall FwpmEngineOpen0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpmEngineClose0(_QWORD); weak
// __int64 __fastcall FwpmProviderAdd0(_QWORD, _QWORD, _QWORD); weak
// __int64 FwpmProviderDeleteByKey0(void); weak
// __int64 __fastcall FwpmSubLayerAdd0(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpmSubLayerGetByKey0(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpmCalloutAdd0(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpmCalloutDeleteById0(_QWORD, _QWORD); weak
// __int64 __fastcall FwpmFilterAdd0(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpmFilterDeleteById0(_QWORD, _QWORD); weak
// __int64 __fastcall FwpsQueryPacketInjectionState0(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpmEngineGetSecurityInfo0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpmEngineSetSecurityInfo0(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpsInjectionHandleCreate0(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpsInjectionHandleDestroy0(_QWORD); weak
// __int64 __fastcall FwpsAllocateCloneNetBufferList0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpsFreeCloneNetBufferList0(_QWORD, _QWORD); weak
// __int64 __fastcall FwpsFreeNetBufferList0(_QWORD); weak
// __int64 __fastcall FwpsPendOperation0(_QWORD, _QWORD); weak
// __int64 __fastcall FwpsInjectTransportSendAsync1(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpsCopyStreamDataToBuffer0(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpmTransactionBegin0(_QWORD, _QWORD); weak
// __int64 __fastcall FwpmTransactionCommit0(_QWORD); weak
// __int64 __fastcall FwpmTransactionAbort0(_QWORD); weak
// __int64 __fastcall FwpmSubLayerDeleteByKey0(_QWORD, _QWORD); weak
void __fastcall __noreturn sub_14001DD70(ULONG_PTR BugCheckParameter1); // idb
void __noreturn sub_14001DDA0();
void __fastcall __noreturn sub_14001DDB0(ULONG_PTR BugCheckParameter1); // idb
__int64 __fastcall sub_14001DE30(unsigned __int64 a1, __int64 a2, _DWORD *a3);
// int __cdecl wcsncmp(const wchar_t *Str1, const wchar_t *Str2, size_t MaxCount);
// int __cdecl wcsnicmp(const wchar_t *Str1, const wchar_t *Str2, size_t MaxCount);
// __int64 __fastcall PcwRegister(_QWORD, _QWORD); weak
// __int64 __fastcall PcwUnregister(_QWORD); weak
// __int64 __fastcall PcwAddInstance(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __cdecl stricmp(const char *Str1, const char *Str2);
// __int64 __fastcall RtlImageDirectoryEntryToData(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall RtlIsNtDdiVersionAvailable(_QWORD); weak
// ULONG DbgPrint(PCH Format, ...);
// int __cdecl wcsicmp(const wchar_t *Str1, const wchar_t *Str2);
// __int64 __fastcall WdfVersionUnbind(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall WdfVersionBind(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall WdfVersionBindClass(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall WdfVersionUnbindClass(_QWORD, _QWORD, _QWORD); weak
// __int64 __usercall sub_14001E1B0@<rax>(__int64 (*a1)(void)@<rax>);
__m128 *__fastcall sub_14001E1C0(__m128 *a1, unsigned __int8 a2, unsigned __int64 a3);
__m128i *__fastcall sub_14001E2C0(__m128i *_RCX, unsigned __int64 a2, unsigned __int64 a3);
void sub_140027E40();
void sub_140027E50();
__int64 __fastcall sub_140027E60(__int64 a1, __int64 a2);
__int64 sub_140027E70();
__int64 sub_140027E80();
void sub_140027E90();
__int64 sub_140027EA0();
__int64 sub_140027EC0();
void sub_140027EE0();
void sub_140027EF0();
void sub_140027F00();
void sub_140027F10();
void sub_140027F20();
__int64 __fastcall sub_140027F30(__int64 a1, __int64 a2);
__int64 (__fastcall **sub_140027F40())();
__int64 (__fastcall **sub_140027F50())();
__int64 sub_140027F60();
__int64 sub_140027F70();
void sub_140027F80();
void sub_140027F90();
void sub_140027FA0();
void sub_140027FB0();
__int64 sub_140027FC0();
void sub_140027FE0();
__int64 sub_140027FF0();
__int64 sub_140028000();
void sub_140028010();
void sub_140028020();
void sub_140028030();
void sub_140028040();
__int64 sub_140028050();
void sub_140028060();
__int64 sub_140028070();
__int64 sub_140028090();
__int64 __fastcall sub_1400280A0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400280B0(__int64 a1, __int64 a2);
__int64 sub_1400280C0();
void sub_1400280E0();
// __int64 __fastcall SecLookupAccountName(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// NTSTATUS __stdcall ObReferenceObjectByHandle(HANDLE Handle, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PVOID *Object, POBJECT_HANDLE_INFORMATION HandleInformation);
// LONG_PTR __stdcall ObfDereferenceObject(PVOID Object);
// NTSTATUS __stdcall ZwCreateFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);
// void __stdcall RtlInitUnicodeString(PUNICODE_STRING DestinationString, PCWSTR SourceString);
// PVOID __stdcall ExAllocatePoolWithTag(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag);
// void __stdcall ExFreePoolWithTag(PVOID P, ULONG Tag);
// __int64 __fastcall ExAcquireSpinLockShared(_QWORD); weak
// __int64 __fastcall ExReleaseSpinLockShared(_QWORD); weak
// __int64 __fastcall ExAcquireSpinLockExclusive(_QWORD); weak
// __int64 __fastcall ExReleaseSpinLockExclusive(_QWORD); weak
// __int64 EtwRegister(void); weak
// __int64 EtwUnregister(void); weak
// __int64 __fastcall EtwWriteTransfer(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// void __stdcall RtlCopyUnicodeString(PUNICODE_STRING DestinationString, PCUNICODE_STRING SourceString);
// USHORT __stdcall ExQueryDepthSList(PSLIST_HEADER SListHead);
// PSLIST_ENTRY __stdcall ExpInterlockedPopEntrySList(PSLIST_HEADER ListHead);
// PSLIST_ENTRY __stdcall ExpInterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry);
// void __stdcall ExInitializeNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside, PALLOCATE_FUNCTION Allocate, PFREE_FUNCTION Free, ULONG Flags, SIZE_T Size, ULONG Tag, USHORT Depth);
// void __stdcall ExDeleteNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside);
// PVOID __stdcall MmGetSystemRoutineAddress(PUNICODE_STRING SystemRoutineName);
// NTSTATUS __stdcall ZwClose(HANDLE Handle);
// __int64 __fastcall IoQueryFileDosDeviceName(_QWORD, _QWORD); weak
// __int64 __fastcall PsSetCreateProcessNotifyRoutine(_QWORD, _QWORD); weak
// __int64 __fastcall ZwOpenProcess(_QWORD, _QWORD, _QWORD, _QWORD); weak
// NTSTATUS __stdcall KeWaitForSingleObject(PVOID Object, KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
// SIZE_T __stdcall RtlCompareMemory(const void *Source1, const void *Source2, SIZE_T Length);
// void __stdcall KeInitializeEvent(PRKEVENT Event, EVENT_TYPE Type, BOOLEAN State);
// __int64 __fastcall RtlEqualSid(_QWORD, _QWORD); weak
// __int64 __fastcall RtlLengthSid(_QWORD); weak
// __int64 __fastcall RtlConvertSidToUnicodeString(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall RtlCreateAcl(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall RtlAddAce(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall RtlDeleteAce(_QWORD, _QWORD); weak
// __int64 __fastcall RtlGetAce(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall RtlAddAccessAllowedAce(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD); weak
// __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD); weak
// NTSTATUS __stdcall KeDelayExecutionThread(KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Interval);
// __int64 PsGetCurrentProcessId(void); weak
// NTSTATUS __stdcall IofCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp);
// void __stdcall MmBuildMdlForNonPagedPool(PMDL MemoryDescriptorList);
// PVOID __stdcall MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList, KPROCESSOR_MODE AccessMode, MEMORY_CACHING_TYPE CacheType, PVOID BaseAddress, ULONG BugCheckOnFailure, MM_PAGE_PRIORITY Priority);
// void __stdcall MmUnmapLockedPages(PVOID BaseAddress, PMDL MemoryDescriptorList);
// PMDL __stdcall IoAllocateMdl(PVOID VirtualAddress, ULONG Length, BOOLEAN SecondaryBuffer, BOOLEAN ChargeQuota, PIRP Irp);
// __int64 __cdecl RtlInitializeGenericTableAvl(_QWORD); weak
// __int64 __fastcall RtlInsertElementGenericTableAvl(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall RtlDeleteElementGenericTableAvl(_QWORD, _QWORD); weak
// __int64 __fastcall RtlEnumerateGenericTableAvl(_QWORD, _QWORD); weak
// __int64 __fastcall RtlGetVersion(_QWORD); weak
// NTSTATUS __stdcall RtlAppendUnicodeStringToString(PUNICODE_STRING Destination, PCUNICODE_STRING Source);
// NTSTATUS __stdcall ZwQuerySymbolicLinkObject(HANDLE LinkHandle, PUNICODE_STRING LinkTarget, PULONG ReturnedLength);
// __int64 __fastcall RtlDowncaseUnicodeString(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall ZwSetInformationThread(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall ObOpenObjectByPointer(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall ZwOpenProcessTokenEx(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall ZwOpenThreadTokenEx(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall ZwDuplicateToken(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// void __stdcall KeClearEvent(PRKEVENT Event);
// LONG __stdcall KeSetEvent(PRKEVENT Event, KPRIORITY Increment, BOOLEAN Wait);
// NTSTATUS __stdcall PsTerminateSystemThread(NTSTATUS ExitStatus);
// __int64 PsGetCurrentThreadId(void); weak
// void __stdcall KeInitializeSemaphore(PRKSEMAPHORE Semaphore, LONG Count, LONG Limit);
// LONG __stdcall KeReleaseSemaphore(PRKSEMAPHORE Semaphore, KPRIORITY Increment, LONG Adjustment, BOOLEAN Wait);
// NTSTATUS __stdcall KeWaitForMultipleObjects(ULONG Count, PVOID Object[], WAIT_TYPE WaitType, KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PKWAIT_BLOCK WaitBlockArray);
// KIRQL __stdcall KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock);
// void __stdcall KeReleaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL NewIrql);
// __int64 __fastcall PsIsThreadTerminating(_QWORD); weak
// LONG __stdcall KeReleaseMutex(PRKMUTEX Mutex, BOOLEAN Wait);
// void __stdcall ExInitializePagedLookasideList(PPAGED_LOOKASIDE_LIST Lookaside, PALLOCATE_FUNCTION Allocate, PFREE_FUNCTION Free, ULONG Flags, SIZE_T Size, ULONG Tag, USHORT Depth);
// void __stdcall ExDeletePagedLookasideList(PPAGED_LOOKASIDE_LIST Lookaside);
// NTSTATUS __stdcall PsCreateSystemThread(PHANDLE ThreadHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PKSTART_ROUTINE StartRoutine, PVOID StartContext);
// NTSTATUS __stdcall RtlCreateSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Revision);
// BOOLEAN __stdcall RtlValidSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor);
// NTSTATUS __stdcall RtlSetDaclSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor, BOOLEAN DaclPresent, PACL Dacl, BOOLEAN DaclDefaulted);
// __int64 __fastcall RtlSetOwnerSecurityDescriptor(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall RtlSetGroupSecurityDescriptor(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall RtlAbsoluteToSelfRelativeSD(_QWORD, _QWORD, _QWORD); weak
// void __stdcall KeInitializeMutex(PRKMUTEX Mutex, ULONG Level);
// void __stdcall ExAcquireFastMutex(PFAST_MUTEX FastMutex);
// void __stdcall ExReleaseFastMutex(PFAST_MUTEX FastMutex);
// void __stdcall __noreturn KeBugCheckEx(ULONG BugCheckCode, ULONG_PTR BugCheckParameter1, ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter3, ULONG_PTR BugCheckParameter4);
// PDEVICE_OBJECT __stdcall IoGetAttachedDeviceReference(PDEVICE_OBJECT DeviceObject);
// PIRP __stdcall IoBuildDeviceIoControlRequest(ULONG IoControlCode, PDEVICE_OBJECT DeviceObject, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, BOOLEAN InternalDeviceIoControl, PKEVENT Event, PIO_STATUS_BLOCK IoStatusBlock);
// __int64 __fastcall DbgPrintEx(_QWORD, _QWORD, _QWORD, _QWORD);
// LONG __stdcall RtlCompareUnicodeString(PCUNICODE_STRING String1, PCUNICODE_STRING String2, BOOLEAN CaseInSensitive);
__int64 __fastcall sub_14003B000(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14003B048(__int64 a1, __int64 a2);
__int64 __fastcall sub_14003B0C4(__int64 a1, __int64 a2);
__int64 sub_14003B140();
__int64 sub_14003B14C();
__int64 sub_14003C000();
__int64 sub_14003C414();
// __int64 _security_init_cookie(void); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_1400090F8; // weak
__int128 xmmword_14001EC50 = 0x53007900720065007500510077005Ai64; // weak
__int128 xmmword_14001EC60 = 0x66006E0049006D0065007400730079i64; // weak
__int128 xmmword_14001EC70 = 0x6E006F006900740061006D0072006Fi64; // weak
__int64 qword_14001F460[2] = { -3689348818172361401i64, -3689348814741910324i64 }; // weak
__int64 qword_14001F4B0[2] = { -3689348818172357296i64, -3689348814741910324i64 }; // weak
__int128 xmmword_14001FA90 = 0x49005600520045005300200054004Ei64; // weak
__int128 xmmword_14001FAA0 = 0x5300700074006E0053005C00450043i64; // weak
__int64 qword_1400209D0[2] = { -3689348814741962720i64, -3689348814741910324i64 }; // weak
__int64 qword_1400209E0[2] = { -3689348818173858784i64, -3689348814741910324i64 }; // weak
__int64 qword_1400209F0[2] = { -3689348818173856992i64, -3689348814741910324i64 }; // weak
__int64 qword_140020A00[2] = { -3689348818173860820i64, -3689348814741910324i64 }; // weak
__int64 qword_140020A30[2] = { -3689348814755315936i64, -3689348814741910324i64 }; // weak
__int64 qword_140020A40[2] = { -3689348814741962689i64, -3689348814741910324i64 }; // weak
__int64 qword_140020AB0[2] = { -3689348814741962694i64, -3689348814741910324i64 }; // weak
__int64 qword_140020AC0[2] = { -3689348814741962706i64, -3689348814741910324i64 }; // weak
__int64 qword_140020AE0[2] = { -3689348814755317190i64, -3689348814741910324i64 }; // weak
__int64 qword_140020B00[2] = { -3689348818172624044i64, -3689348814741910324i64 }; // weak
__int64 qword_140020B10[2] = { -3689348818172623787i64, -3689348814741910324i64 }; // weak
__int64 qword_140020B30[2] = { -3689348818173857701i64, -3689348814741910324i64 }; // weak
__int64 qword_140020B40[2] = { -3689348814741962659i64, -3689348814741910324i64 }; // weak
__int64 qword_140020B70[2] = { -3689348818172620223i64, -3689348814741910324i64 }; // weak
__int64 qword_140020B80[2] = { -3689348814741962661i64, -3689348814741910324i64 }; // weak
__int64 qword_1400228E0[2] = { -3689348818177884160i64, -3689348814741910324i64 }; // weak
__int64 qword_140022D10[2] = { -3689348814741962752i64, -3689348814741910324i64 }; // weak
__int64 qword_140022DA0[2] = { -3689348814741910528i64, -3689348814741910324i64 }; // weak
__int128 xmmword_140025720 = 0x740073006F0068006300760073005Ci64; // weak
__int128 xmmword_140027A70 = 0x47003B003B004100280050003A0044i64; // weak
__int128 xmmword_140027A80 = 0x290053004C003B003B003B0041i64; // weak
// extern POBJECT_TYPE *IoFileObjectType;
// extern _UNKNOWN SeTokenObjectType; weak
// extern _UNKNOWN SeExports; weak
_UNKNOWN unk_1400294E0; // weak
_UNKNOWN unk_1400295B8; // weak
_UNKNOWN unk_140029890; // weak
_UNKNOWN unk_140029948; // weak
_UNKNOWN unk_140029DE0; // weak
_UNKNOWN unk_140029DF0; // weak
_UNKNOWN unk_140029E00; // weak
_UNKNOWN unk_140029E10; // weak
_UNKNOWN unk_140029E20; // weak
_UNKNOWN unk_140029E30; // weak
_UNKNOWN unk_140029E40; // weak
_UNKNOWN unk_140029E50; // weak
_UNKNOWN unk_140029E60; // weak
_UNKNOWN unk_140029E70; // weak
__int64 (__fastcall *off_140029EC8)() = &sub_1400032C0; // weak
__int64 (__fastcall *off_140029EF0[6])() =
{
  &sub_140003480,
  &sub_140003300,
  &sub_140003370,
  &sub_1400033D0,
  &sub_140003410,
  &sub_1400034C0
}; // weak
__int64 (__fastcall *off_140029F18)() = &sub_1400034C0; // weak
__int64 (__fastcall *off_140029F40[5])() =
{
  &sub_140003690,
  &sub_140003500,
  &sub_140003570,
  &sub_1400035D0,
  &sub_140003620
}; // weak
_UNKNOWN unk_140029FB8; // weak
_UNKNOWN unk_140029FC8; // weak
_UNKNOWN unk_140029FD8; // weak
_UNKNOWN unk_140029FE8; // weak
_UNKNOWN unk_140029FF8; // weak
_UNKNOWN unk_14002A008; // weak
_UNKNOWN unk_14002A018; // weak
_UNKNOWN unk_14002A028; // weak
_UNKNOWN unk_14002A038; // weak
_UNKNOWN unk_14002A048; // weak
_UNKNOWN unk_14002A058; // weak
_UNKNOWN unk_14002A068; // weak
_UNKNOWN unk_14002A078; // weak
_UNKNOWN unk_14002A088; // weak
_UNKNOWN unk_14002A098; // weak
_UNKNOWN unk_14002A0A8; // weak
_UNKNOWN unk_14002A0B8; // weak
_UNKNOWN unk_14002A0C8; // weak
_UNKNOWN unk_14002A0D8; // weak
_UNKNOWN unk_14002A0F8; // weak
_UNKNOWN unk_14002A108; // weak
_UNKNOWN unk_14002A118; // weak
_UNKNOWN unk_14002CF70; // weak
_UNKNOWN unk_14002CF90; // weak
_UNKNOWN unk_14002D0F0; // weak
_UNKNOWN unk_14002D110; // weak
_UNKNOWN unk_14002D130; // weak
_UNKNOWN unk_14002D150; // weak
_UNKNOWN unk_14002D1C0; // weak
_UNKNOWN unk_14002D350; // weak
_UNKNOWN unk_14002D360; // weak
_UNKNOWN unk_14002D3F0; // weak
__int128 xmmword_14002D4A0 = 0x122F0EC25A41A6924B4D3A70408F2ED4i64; // weak
_UNKNOWN unk_14002D630; // weak
_UNKNOWN unk_14002D640; // weak
__int128 xmmword_14002D790 = 0x409F34EEBEAA1980492B225546EA1551i64; // weak
__int128 xmmword_14002D7A0 = 0xE34A5DC658577D934759C0E3AB3033C9i64; // weak
__int128 xmmword_14002D860 = 0xA7B906B8796EB18C4F9A623E3971EF2Bi64; // weak
__int128 xmmword_14002D870 = 0x5B77AC91F7A822AF453F57650C1BA1AFi64; // weak
__int128 xmmword_14002D880 = 0x4B67EE74F668B4914E1AD22BC35A604Di64; // weak
_UNKNOWN unk_14002D8F0; // weak
__int128 xmmword_14002D960 = 0x71C9EFEC09D837944EA58644D78E1E87i64; // weak
__int128 xmmword_14002D980 = 0x666EAF7103C99C974F86B34DAF043A0Ai64; // weak
__int64 (__fastcall *off_14002E100)() = &sub_1400066E0; // weak
__int64 (__fastcall *off_14002E128[10])() =
{
  &sub_140006720,
  &sub_140006920,
  &sub_140006910,
  &sub_140006890,
  &sub_1400067A0,
  &sub_140006760,
  &sub_140006930,
  &sub_140006910,
  &sub_140006890,
  &sub_140006820
}; // weak
__int64 (__fastcall *off_14002E150[5])() =
{
  &sub_140006760,
  &sub_140006930,
  &sub_140006910,
  &sub_140006890,
  &sub_140006820
}; // weak
_UNKNOWN unk_14002E178; // weak
_UNKNOWN unk_14002E188; // weak
_UNKNOWN unk_14002E1C8; // weak
_UNKNOWN unk_14002E1D8; // weak
_UNKNOWN unk_14002E1E8; // weak
_UNKNOWN unk_14002E1F8; // weak
_UNKNOWN unk_14002E208; // weak
_UNKNOWN unk_14002E218; // weak
_UNKNOWN unk_14002E268; // weak
_UNKNOWN unk_14002E278; // weak
wchar_t *off_14002E2A0[2] =
{
  L"\\Program Files\\Sophos\\Sophos Network Threat Protection\\SophosNtpService.exe",
  L"\\Program Files\\Sophos\\Sophos Network Threat Protection\\SophosIPS.exe"
}; // weak
void *off_14002E2B0 = &purecall; // weak
__int64 (__fastcall *off_14002E310)() = &sub_14000EF70; // weak
__int64 (__fastcall *off_14002E378[13])() =
{
  &sub_14000EFB0,
  &sub_14000F020,
  &sub_14000F310,
  &sub_1400140A0,
  &sub_140013F30,
  &sub_140014170,
  &sub_14000CC80,
  &sub_14000F3B0,
  &nullsub_1,
  &sub_1400140C0,
  &sub_1400083D0,
  &sub_140013F40,
  &sub_14000F3A0
}; // weak
void *off_14002E408 = &purecall; // weak
__int64 (__fastcall *off_14002E420)(__int64) = &sub_1400147C0; // weak
void *off_14002E440 = &purecall; // weak
__int64 (__fastcall *off_14002E448[2])() = { &sub_140015040, &sub_140014E10 }; // weak
_UNKNOWN unk_14002E468; // weak
_UNKNOWN unk_14002E488; // weak
_UNKNOWN unk_14002E4A8; // weak
OBJECT_ATTRIBUTES ObjectAttributes = { 48u, NULL, &aBd_0, 576u, NULL, NULL }; // idb
_UNKNOWN unk_140030040; // weak
void *off_1400300A0 = &unk_140030088; // weak
_DWORD dword_1400300B0[8] = { 1, 2, 4, 8, 16, 32, 64, 0 }; // idb
void *off_140030110 = &unk_1400300F8; // weak
_UNKNOWN unk_140030120; // weak
_UNKNOWN unk_140030130; // weak
__int64 qword_140030140 = -1i64; // weak
void *off_140030160 = &unk_140030148; // weak
_UNKNOWN unk_140030170; // weak
char byte_140030180 = '\x01'; // weak
_UNKNOWN unk_140030188; // weak
int dword_1400301C0[] = { 8 }; // weak
struct _PAGED_LOOKASIDE_LIST Lookaside =
{
  {
    { 0ui64, 0ui64 },
    0u,
    0u,
    0u,
    { 0u },
    0u,
    { 0u },
    NonPagedPool,
    0u,
    0u,
    NULL,
    NULL,
    { NULL, NULL },
    0u,
    { 0u },
    { 0u, 0u }
  }
}; // idb
int dword_140030280 = 16; // weak
int dword_140030340[] = { 44 }; // weak
struct _NPAGED_LOOKASIDE_LIST stru_140030380 =
{
  {
    { 0ui64, 0ui64 },
    0u,
    0u,
    0u,
    { 0u },
    0u,
    { 0u },
    NonPagedPool,
    0u,
    0u,
    NULL,
    NULL,
    { NULL, NULL },
    0u,
    { 0u },
    { 0u, 0u }
  }
}; // idb
int dword_140030700 = 321; // weak
_UNKNOWN unk_1400307C0; // weak
PVOID off_1400307D0[] = { &stru_140035158 }; // idb
void *off_1400307E0 = &unk_140035140; // weak
HANDLE Handle = (HANDLE)0xFFFFFFFFFFFFFFFFi64; // idb
__int64 qword_1400307F8 = -1i64; // weak
_UNKNOWN unk_140030800; // weak
char byte_140030810 = '\x04'; // weak
__int64 qword_140030818 = 1048576i64; // weak
__int64 qword_140030820 = 65536i64; // weak
__int64 qword_140030828 = -1i64; // weak
ULONG_PTR _security_cookie = 47936899621426ui64; // idb
ULONG_PTR BugCheckParameter3 = 18446696136809930189ui64; // idb
_UNKNOWN unk_140030840; // weak
_UNKNOWN unk_140030870; // weak
_UNKNOWN unk_140030880; // weak
void *off_140030888 = &unk_140030870; // weak
_UNKNOWN unk_1400308A0; // weak
_UNKNOWN unk_1400308C0; // weak
_UNKNOWN unk_1400308D8; // weak
_UNKNOWN unk_1400308F0; // weak
_UNKNOWN unk_1400308F4; // weak
_UNKNOWN unk_140030900; // weak
_UNKNOWN unk_140031930; // weak
_UNKNOWN unk_140032960; // weak
struct _NPAGED_LOOKASIDE_LIST stru_1400341C0; // idb
struct _NPAGED_LOOKASIDE_LIST stru_140034240; // idb
char byte_1400342C0; // weak
_QWORD qword_1400342C8[5]; // idb
__int64 qword_1400342F0; // weak
_QWORD qword_140034300[15]; // idb
int dword_140034378[16]; // idb
_DWORD dword_1400343B8[15]; // idb
__int16 word_1400343F4; // weak
__int64 qword_1400343F8; // weak
__int64 qword_140034400; // weak
char byte_140034440; // weak
__int64 qword_140034448; // weak
void *qword_140034450[6]; // idb
struct _NPAGED_LOOKASIDE_LIST stru_140034480; // idb
_UNKNOWN unk_140034500; // weak
_UNKNOWN unk_140034508; // weak
_UNKNOWN unk_140034510; // weak
_UNKNOWN unk_140034518; // weak
_UNKNOWN unk_140034520; // weak
_UNKNOWN unk_140034528; // weak
int dword_140034530; // weak
_UNKNOWN unk_140034540; // weak
_UNKNOWN unk_140034548; // weak
_UNKNOWN unk_140034550; // weak
_UNKNOWN unk_140034558; // weak
_UNKNOWN unk_140034560; // weak
_UNKNOWN unk_140034568; // weak
_UNKNOWN unk_140034570; // weak
_UNKNOWN unk_140034578; // weak
_UNKNOWN unk_140034580; // weak
_UNKNOWN unk_1400345C0; // weak
signed __int32 dword_140034600[8]; // idb
signed __int32 dword_140034620[18]; // idb
int dword_140034668; // weak
char byte_14003466C; // weak
char byte_14003466D; // weak
__m128 stru_140034670[18]; // idb
__int64 qword_140034798[4]; // idb
_UNKNOWN unk_1400347B8; // weak
int dword_1400347D8; // weak
_UNKNOWN unk_1400347E0; // weak
int dword_140034800; // weak
__m128 stru_140034810[7]; // idb
int dword_140034880; // weak
struct _NPAGED_LOOKASIDE_LIST stru_1400348C0; // idb
struct _NPAGED_LOOKASIDE_LIST stru_140034940; // idb
struct _NPAGED_LOOKASIDE_LIST stru_1400349C0; // idb
struct _NPAGED_LOOKASIDE_LIST stru_140034A40; // idb
_UNKNOWN unk_140034AC0; // weak
_UNKNOWN unk_140034AD0; // weak
__m128 stru_140034AD8[2]; // idb
struct _NPAGED_LOOKASIDE_LIST stru_140034B00; // idb
struct _NPAGED_LOOKASIDE_LIST stru_140034B80; // idb
struct _NPAGED_LOOKASIDE_LIST stru_140034C00; // idb
struct _NPAGED_LOOKASIDE_LIST stru_140034C80; // idb
_UNKNOWN unk_140034D00; // weak
_UNKNOWN unk_140034D70; // weak
_UNKNOWN unk_140034D78; // weak
_UNKNOWN unk_140034D80; // weak
__int64 qword_140034D88; // weak
int dword_140034D90; // weak
int dword_140034DC0; // weak
struct _NPAGED_LOOKASIDE_LIST stru_140034E00; // idb
__int64 qword_140034E80[33]; // idb
char byte_140034F88; // weak
char byte_140034F89; // weak
char byte_140034F8A; // weak
__int64 qword_140034F90; // weak
_UNKNOWN unk_140034F98; // weak
__int64 qword_140034FD0; // weak
int dword_140034FE0; // weak
struct _KSEMAPHORE Semaphore; // idb
struct _KEVENT Event; // idb
char byte_140035020; // weak
__int64 qword_140035028; // weak
__int64 qword_140035030; // weak
int dword_140035038; // weak
int dword_140035040; // weak
struct _KSEMAPHORE stru_140035048; // idb
struct _KEVENT stru_140035068; // idb
char byte_140035080; // weak
__int64 qword_140035088; // weak
__int64 qword_140035090; // weak
int dword_140035098; // weak
int dword_1400350A0; // weak
struct _KSEMAPHORE stru_1400350A8; // idb
struct _KEVENT stru_1400350C8; // idb
char byte_1400350E0; // weak
__int64 qword_1400350E8; // weak
__int64 qword_1400350F0; // weak
int dword_1400350F8; // weak
_UNKNOWN unk_140035100; // weak
struct _KSEMAPHORE stru_140035120; // idb
_UNKNOWN unk_140035140; // weak
struct _KEVENT stru_140035158; // idb
__int64 qword_140035170; // weak
PVOID qword_140035178; // idb
_UNKNOWN unk_140035180; // weak
struct _LIST_ENTRY ListHead; // idb
_UNKNOWN unk_1400351A0; // weak
_UNKNOWN unk_1400351A8; // weak
_QWORD qword_1400351B0[128]; // idb
int dword_1400355B0; // weak
__int64 qword_1400355B8; // weak
_UNKNOWN unk_1400355C0; // weak
char byte_1400355F8; // weak
char byte_1400355F9; // weak
char byte_1400355FA; // weak
_QWORD qword_140035600[255]; // idb
char byte_140035DF8; // weak
char byte_140035DF9; // weak
char byte_140035DFA; // weak
_QWORD qword_140035E00[16]; // idb
PVOID P; // idb
UNICODE_STRING stru_140035E88; // idb
int dword_140035E98; // weak
_UNKNOWN unk_140035EA0; // weak
_UNKNOWN unk_140036060; // weak
_UNKNOWN unk_140036220; // weak
_UNKNOWN unk_1400363E0; // weak
_UNKNOWN unk_1400365A0; // weak
int dword_140036760; // weak
int dword_140036764; // weak
char byte_140036768; // weak
char byte_140036769; // weak
_UNKNOWN unk_140036770; // weak
_UNKNOWN unk_1400367A8; // weak
int dword_1400367B0; // weak
int dword_1400367B4; // weak
_UNKNOWN unk_1400367B8; // weak
int dword_1400367C0; // weak
int dword_1400367C4; // weak
__int64 qword_140036898; // weak
__int64 qword_1400368A8; // weak
__int64 qword_1400368C8; // weak
__int64 qword_140036980; // weak
__int64 qword_1400369E0; // weak
__int64 qword_1400369E8; // weak
__int64 qword_140036A00; // weak
__int64 qword_140036A08; // weak
__int64 qword_140036A10; // weak
__int64 qword_140036A28; // weak
__int64 qword_140036A50; // weak
__int64 qword_140036B70; // weak
__int64 qword_140036C90; // weak
__int64 qword_140036E18; // weak
__int64 qword_140036E20; // weak
__int64 qword_140036E28; // weak
__int64 qword_140036E38; // weak
__int64 qword_140036E40; // weak
__int64 qword_140036E50; // weak
__int64 qword_140036FD0; // weak
__int64 qword_140036FD8; // weak
__int64 qword_140037008; // weak
__int64 qword_140037018; // weak
__int64 qword_140037038; // weak
__int64 qword_140037040; // weak
__int64 qword_140037068; // weak
__int64 qword_140037078; // weak
__int64 qword_140037190; // weak
__int64 qword_140037198; // weak
__int64 qword_1400371A0; // weak
__int64 qword_1400371A8; // weak
__int64 qword_1400371B0; // weak
__int64 qword_1400371B8; // weak
__int64 qword_1400373A8; // weak
__int64 qword_1400373B0; // weak
__int64 qword_140037418; // weak
UNICODE_STRING DestinationString; // idb
__int64 (*qword_140037448)(void); // weak
__int64 qword_140037450; // weak
__int64 qword_140037458; // weak
__int64 qword_140037460; // weak
_UNKNOWN unk_140037470; // weak
__int64 qword_140037678; // weak
struct _KMUTANT Mutex; // idb
struct _FAST_MUTEX FastMutex; // idb
PVOID qword_1400376F8; // idb
__int64 qword_140037700; // weak
struct _KEVENT Object; // idb
_UNKNOWN unk_140037758; // weak
struct _LIST_ENTRY stru_140037760; // idb
_UNKNOWN unk_140037770; // weak
struct _LIST_ENTRY stru_140037780; // idb


//----- (0000000140001000) ----------------------------------------------------
__int64 sub_140001000()
{
  sub_1400011D0((__int64)&unk_140030840);
  return WdfVersionUnbind(&DestinationString, &unk_140030840, qword_140037458);
}
// 14001E160: using guessed type __int64 __fastcall WdfVersionUnbind(_QWORD, _QWORD, _QWORD);
// 140037458: using guessed type __int64 qword_140037458;

//----- (0000000140001040) ----------------------------------------------------
__int64 sub_140001040()
{
  if ( qword_140037448 && (char *)qword_140037448 != (char *)sub_140001040 )
    qword_140037448();
  return sub_140001000();
}
// 140037448: using guessed type __int64 (*qword_140037448)(void);

//----- (0000000140001070) ----------------------------------------------------
__int64 __fastcall DriverEntry(__int64 a1, const UNICODE_STRING *a2)
{
  __int64 v2; // rdi
  __int64 result; // rax
  signed int v4; // ebx
  __int64 (*v5)(void); // rax

  v2 = a1;
  if ( !a1 )
    return sub_14003C000();
  qword_140037460 = a1;
  DestinationString.MaximumLength = 520;
  DestinationString.Length = 0;
  DestinationString.Buffer = (PWSTR)&unk_140037470;
  RtlCopyUnicodeString(&DestinationString, a2);
  result = WdfVersionBind(v2, &DestinationString, &unk_140030840, &qword_140037458);
  if ( (signed int)result >= 0 )
  {
    v4 = sub_140001250((__int64)&unk_140030840);
    if ( v4 < 0 || (sub_1400012E0(), v4 = sub_14003C000(), v4 < 0) )
    {
      sub_140001000();
      result = (unsigned int)v4;
    }
    else
    {
      if ( *(_BYTE *)(qword_140037458 + 48) )
      {
        v5 = qword_140037448;
        if ( *(_QWORD *)(v2 + 104) )
          v5 = *(__int64 (**)(void))(v2 + 104);
        qword_140037448 = v5;
        *(_QWORD *)(v2 + 104) = sub_140001040;
      }
      else if ( *(_BYTE *)(qword_140037458 + 8) & 2 )
      {
        qword_140037450 = qword_140036E18;
        qword_140036E18 = (__int64)sub_140001030;
      }
      result = 0i64;
    }
  }
  return result;
}
// 140001030: using guessed type __int64 __fastcall sub_140001030();
// 14001E170: using guessed type __int64 __fastcall WdfVersionBind(_QWORD, _QWORD, _QWORD, _QWORD);
// 140036E18: using guessed type __int64 qword_140036E18;
// 140037448: using guessed type __int64 (*qword_140037448)(void);
// 140037450: using guessed type __int64 qword_140037450;
// 140037458: using guessed type __int64 qword_140037458;
// 140037460: using guessed type __int64 qword_140037460;

//----- (00000001400011D0) ----------------------------------------------------
void *__fastcall sub_1400011D0(__int64 a1)
{
  void *result; // rax
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  __int64 (__fastcall *v4)(__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD), __int64, __int64, _QWORD *); // rax

  result = off_140030888;
  v2 = a1;
  v3 = &unk_140030880;
  if ( off_140030888 != &unk_140030870 && &unk_140030880 <= off_140030888 )
  {
    do
    {
      v4 = (__int64 (__fastcall *)(__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD), __int64, __int64, _QWORD *))v3[8];
      if ( v4 )
        result = (void *)v4(WdfVersionUnbindClass, v2, qword_140037458, v3);
      else
        result = (void *)WdfVersionUnbindClass(v2, qword_140037458, v3);
      v3 += 10;
    }
    while ( v3 <= off_140030888 );
  }
  return result;
}
// 14001E190: using guessed type __int64 __fastcall WdfVersionUnbindClass(_QWORD, _QWORD, _QWORD);
// 140030888: using guessed type void *off_140030888;
// 140037458: using guessed type __int64 qword_140037458;

//----- (0000000140001250) ----------------------------------------------------
__int64 __fastcall sub_140001250(__int64 a1)
{
  __int64 v1; // rdi
  __int64 result; // rax
  _QWORD *i; // rbx
  __int64 (__fastcall *v4)(__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD), __int64, __int64, _QWORD *); // rax

  v1 = a1;
  result = 0i64;
  for ( i = &unk_140030880; i < (_QWORD *)&unk_140030880; i += 10 )
  {
    if ( *(_DWORD *)i != 80 )
      return 3221225476i64;
    v4 = (__int64 (__fastcall *)(__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD), __int64, __int64, _QWORD *))i[7];
    off_140030888 = i;
    if ( v4 )
      result = v4(WdfVersionBindClass, v1, qword_140037458, i);
    else
      result = WdfVersionBindClass(v1, qword_140037458, i);
    if ( (signed int)result < 0 )
      return result;
  }
  return result;
}
// 14001E180: using guessed type __int64 __fastcall WdfVersionBindClass(_QWORD, _QWORD, _QWORD);
// 140030888: using guessed type void *off_140030888;
// 140037458: using guessed type __int64 qword_140037458;

//----- (00000001400012E0) ----------------------------------------------------
__int64 (*sub_1400012E0())(void)
{
  __int64 (*result)(void); // rax
  __int64 (**v1)(void); // rbx
  unsigned __int64 v2; // rdi

  result = (__int64 (*)(void))&unk_1400308A0;
  if ( &unk_1400308A0 < &unk_1400308A0 )
  {
    v1 = (__int64 (**)(void))&unk_1400308C0;
    v2 = ((unsigned __int64)(0xFFFFFFFFFFFFFFFFui64 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 5) + 1;
    do
    {
      result = *v1;
      if ( *v1 )
      {
        result = (__int64 (*)(void))result();
        *(v1 - 1) = result;
      }
      v1 += 5;
      --v2;
    }
    while ( v2 );
  }
  return result;
}

//----- (0000000140001350) ----------------------------------------------------
__int64 sub_140001350()
{
  sub_140003A70(&stru_140034240, 0x50ui64, 0x74684349u);
  return sub_1400194B0((__int64)sub_140027E40);
}

//----- (0000000140001380) ----------------------------------------------------
__int64 sub_140001380()
{
  sub_140003A70(&stru_1400341C0, 0x30ui64, 0x74684349u);
  return sub_1400194B0((__int64)sub_140027E50);
}

//----- (00000001400013B0) ----------------------------------------------------
__int64 sub_1400013B0()
{
  sub_1400038BC((__int64)&unk_140032960);
  return sub_1400194B0((__int64)sub_140027E60);
}

//----- (00000001400013D0) ----------------------------------------------------
__int64 sub_1400013D0()
{
  sub_1400038EC((__int64)&unk_140031930);
  return sub_1400194B0((__int64)sub_140027E70);
}

//----- (00000001400013F0) ----------------------------------------------------
__int64 sub_1400013F0()
{
  sub_1400038EC((__int64)&unk_140030900);
  return sub_1400194B0((__int64)sub_140027E80);
}

//----- (0000000140001410) ----------------------------------------------------
__int64 sub_140001410()
{
  sub_140003A70(&stru_140034480, 0x60ui64, 0x36737049u);
  return sub_1400194B0((__int64)sub_140027E90);
}

//----- (0000000140001440) ----------------------------------------------------
__int64 sub_140001440()
{
  sub_140002584((__m128 *)qword_140034450, 0x28ui64);
  sub_1400075B8(qword_140034450);
  return sub_1400194B0((__int64)sub_140027EE0);
}

//----- (0000000140001480) ----------------------------------------------------
__int64 sub_140001480()
{
  sub_140003A70(&stru_140034940, 0x20ui64, 0x45737049u);
  return sub_1400194B0((__int64)sub_140027EF0);
}

//----- (00000001400014B0) ----------------------------------------------------
__int64 sub_1400014B0()
{
  sub_140003A70(&stru_1400348C0, 0x28ui64, 0x45737049u);
  return sub_1400194B0((__int64)sub_140027F00);
}

//----- (00000001400014E0) ----------------------------------------------------
__int64 sub_1400014E0()
{
  sub_140003A70(&stru_140034A40, 0x20ui64, 0x45737049u);
  return sub_1400194B0((__int64)sub_140027F10);
}

//----- (0000000140001510) ----------------------------------------------------
__int64 sub_140001510()
{
  sub_140003A70(&stru_1400349C0, 0x38ui64, 0x45737049u);
  return sub_1400194B0((__int64)sub_140027F20);
}

//----- (0000000140001540) ----------------------------------------------------
__int64 sub_140001540()
{
  sub_140002584((__m128 *)qword_140034798, 0x20ui64);
  sub_140008864(qword_140034798);
  return sub_1400194B0((__int64)sub_140027F30);
}

//----- (0000000140001580) ----------------------------------------------------
__int64 sub_140001580()
{
  sub_140002584(stru_140034670, 0x128ui64);
  sub_14001E1C0(stru_140034670, 0, 0x128ui64);
  sub_140008890(stru_140034670);
  return sub_1400194B0((__int64)sub_140027F70);
}

//----- (00000001400015C8) ----------------------------------------------------
__int64 sub_1400015C8()
{
  sub_140003A70(&stru_140034940, 0x20ui64, 0x45737049u);
  return sub_1400194B0((__int64)sub_140027F80);
}

//----- (00000001400015F4) ----------------------------------------------------
__int64 sub_1400015F4()
{
  sub_140003A70(&stru_1400348C0, 0x28ui64, 0x45737049u);
  return sub_1400194B0((__int64)sub_140027F90);
}

//----- (0000000140001620) ----------------------------------------------------
__int64 sub_140001620()
{
  sub_140003A70(&stru_140034A40, 0x20ui64, 0x45737049u);
  return sub_1400194B0((__int64)sub_140027FA0);
}

//----- (000000014000164C) ----------------------------------------------------
__int64 sub_14000164C()
{
  sub_140003A70(&stru_1400349C0, 0x38ui64, 0x45737049u);
  return sub_1400194B0((__int64)sub_140027FB0);
}

//----- (0000000140001680) ----------------------------------------------------
__int64 sub_140001680()
{
  sub_14000ED80((__int64)&unk_140034AC0, 8i64, 2i64, (__int64 (*)(void))unknown_libname_1);
  return sub_1400194B0((__int64)sub_140027FC0);
}
// 140001AB0: using guessed type __int64 __fastcall unknown_libname_1(_QWORD);

//----- (00000001400016B0) ----------------------------------------------------
__int64 sub_1400016B0()
{
  sub_140003A70(&stru_140034480, 0x60ui64, 0x36737049u);
  return sub_1400194B0((__int64)sub_140027FE0);
}

//----- (00000001400016E0) ----------------------------------------------------
__int64 sub_1400016E0()
{
  sub_140002584(stru_140034AD8, 8ui64);
  sub_14000FBA0(stru_140034AD8);
  return sub_1400194B0((__int64)sub_140027FF0);
}

//----- (0000000140001720) ----------------------------------------------------
__int64 sub_140001720()
{
  sub_140002584((__m128 *)&unk_140034AD0, 8ui64);
  unknown_libname_1(&unk_140034AD0);
  return sub_1400194B0((__int64)sub_140028000);
}
// 140001AB0: using guessed type __int64 __fastcall unknown_libname_1(_QWORD);

//----- (0000000140001760) ----------------------------------------------------
__int64 sub_140001760()
{
  sub_140003A70(&stru_140034B00, 0x68ui64, 0x45737049u);
  return sub_1400194B0((__int64)sub_140028010);
}

//----- (0000000140001790) ----------------------------------------------------
__int64 sub_140001790()
{
  sub_140003A70(&stru_140034C00, 0x18ui64, 0x45737049u);
  return sub_1400194B0((__int64)sub_140028020);
}

//----- (00000001400017C0) ----------------------------------------------------
__int64 sub_1400017C0()
{
  sub_140003A70(&stru_140034B80, 0x20ui64, 0x45737049u);
  return sub_1400194B0((__int64)sub_140028030);
}

//----- (00000001400017F0) ----------------------------------------------------
__int64 sub_1400017F0()
{
  sub_140003A70(&stru_140034C80, 0x28ui64, 0x45737049u);
  return sub_1400194B0((__int64)sub_140028040);
}

//----- (0000000140001820) ----------------------------------------------------
__int64 sub_140001820()
{
  sub_140012D9C((__int64)&unk_140034D00);
  return sub_1400194B0((__int64)sub_140028050);
}

//----- (0000000140001840) ----------------------------------------------------
__int64 sub_140001840()
{
  sub_140003A70(&stru_140034E00, 0x58ui64, 0x45767442u);
  return sub_1400194B0((__int64)sub_140028060);
}

//----- (0000000140001870) ----------------------------------------------------
__int64 sub_140001870()
{
  sub_14000ED80((__int64)qword_140034E80, 88i64, 3i64, (__int64 (*)(void))sub_140014B00);
  return sub_1400194B0((__int64)sub_140028070);
}

//----- (00000001400018A0) ----------------------------------------------------
__int64 sub_1400018A0()
{
  sub_14001539C(&unk_140034F98, 1i64, 128i64);
  return sub_1400194B0((__int64)sub_140028090);
}
// 14001539C: using guessed type __int64 __fastcall sub_14001539C(_QWORD, _QWORD, _QWORD);

//----- (00000001400018D0) ----------------------------------------------------
__int64 sub_1400018D0()
{
  sub_140017EFC(&unk_1400351A0);
  return sub_1400194B0((__int64)sub_1400280A0);
}

//----- (00000001400018F0) ----------------------------------------------------
__int64 sub_1400018F0()
{
  sub_140017EFC(&unk_1400351A8);
  return sub_1400194B0((__int64)sub_1400280B0);
}

//----- (0000000140001910) ----------------------------------------------------
NTSTATUS __fastcall sub_140001910(HANDLE *a1)
{
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+60h] [rbp-28h]

  return ZwCreateFile(a1, 0x100000u, &ObjectAttributes, &IoStatusBlock, 0i64, 0, 0, 1u, 0x20u, 0i64, 0);
}

//----- (000000014000197C) ----------------------------------------------------
NTSTATUS __fastcall sub_14000197C(void *a1, int a2, void *a3)
{
  void *v3; // rsi
  int v4; // ebx
  NTSTATUS result; // eax
  struct _DEVICE_OBJECT *v6; // rdi
  struct _IRP *v7; // rax
  NTSTATUS v8; // ebx
  PVOID Object; // [rsp+50h] [rbp-58h]
  int InputBuffer; // [rsp+58h] [rbp-50h]
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+60h] [rbp-48h]
  struct _KEVENT Event; // [rsp+70h] [rbp-38h]

  Object = 0i64;
  v3 = a3;
  v4 = a2;
  result = ObReferenceObjectByHandle(a1, 0, (POBJECT_TYPE)IoFileObjectType, 0, &Object, 0i64);
  if ( result >= 0 )
  {
    v6 = IoGetAttachedDeviceReference(*((PDEVICE_OBJECT *)Object + 1));
    ObfDereferenceObject(Object);
    KeInitializeEvent(&Event, 0, 0);
    InputBuffer = v4;
    v7 = IoBuildDeviceIoControlRequest(0x8A932004, v6, &InputBuffer, 4u, v3, 8u, 1u, &Event, &IoStatusBlock);
    if ( v7 )
    {
      v8 = IofCallDriver(v6, v7);
      if ( v8 == 259 )
      {
        KeWaitForSingleObject(&Event, 0, 0, 0, 0i64);
        v8 = IoStatusBlock.Status;
      }
    }
    else
    {
      v8 = -1073741670;
    }
    ObfDereferenceObject(v6);
    result = v8;
  }
  return result;
}

//----- (0000000140001AB8) ----------------------------------------------------
PVOID *__fastcall sub_140001AB8(PVOID *a1, SIZE_T a2)
{
  PVOID *v2; // rbx

  v2 = a1;
  *a1 = ExAllocatePoolWithTag((POOL_TYPE)512, a2, 0x78654E53u);
  return v2;
}

//----- (0000000140001AE0) ----------------------------------------------------
void __fastcall sub_140001AE0(void **a1)
{
  void *v1; // rcx

  v1 = *a1;
  if ( v1 )
    ExFreePoolWithTag(v1, 0x78654E53u);
}

//----- (0000000140001AFC) ----------------------------------------------------
void **__fastcall sub_140001AFC(void **a1, void **a2)
{
  void **v2; // rdi
  void **v3; // rbx
  void *v4; // rcx

  v2 = a2;
  v3 = a1;
  if ( a2 != a1 )
  {
    v4 = *a1;
    if ( v4 )
      ExFreePoolWithTag(v4, 0x78654E53u);
    *v3 = *v2;
    *v2 = 0i64;
  }
  return v3;
}

//----- (0000000140001B3C) ----------------------------------------------------
__int64 __fastcall sub_140001B3C(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000140001B40) ----------------------------------------------------
char __fastcall sub_140001B40(_WORD *a1, _DWORD *a2, _DWORD *a3, unsigned __int64 a4)
{
  _WORD *v4; // r11
  int v5; // ebx
  unsigned int v6; // er10

  v4 = a1;
  v5 = 0;
  v6 = 0;
  if ( !a2 || !a3 || !a1 || a4 < 6 )
    return 0;
  do
  {
    if ( !*v4 )
      break;
    ++v5;
    while ( (unsigned __int64)v6 + 2 <= a4 && *v4 )
    {
      v6 += 2;
      ++v4;
    }
    if ( (unsigned __int64)v6 + 2 > a4 )
      return 0;
    v6 += 2;
    ++v4;
  }
  while ( (unsigned __int64)v6 + 2 <= a4 );
  if ( (unsigned __int64)v6 + 2 > a4 )
    return 0;
  *a2 = v5;
  *a3 = v6 + 2;
  return 1;
}

//----- (0000000140001BD4) ----------------------------------------------------
__int16 __fastcall sub_140001BD4(__int16 a1)
{
  __int16 result; // ax

  result = a1 - 32;
  if ( (unsigned __int16)(a1 - 97) > 0x19u )
    result = a1;
  return result;
}

//----- (0000000140001BE4) ----------------------------------------------------
void *__fastcall sub_140001BE4(_DWORD *a1)
{
  void *result; // rax

  result = &unk_1400308D8;
  if ( *a1 != 1 )
    result = &unk_1400308C0;
  return result;
}

//----- (0000000140001BF8) ----------------------------------------------------
char __fastcall sub_140001BF8(__int64 a1, __m128i *a2)
{
  __m128i *v2; // r10
  __int64 v3; // rdx
  _WORD *v4; // r9
  unsigned __int16 v5; // r8
  unsigned __int16 v6; // cx
  unsigned __int16 v7; // r11
  unsigned __int64 v8; // rax
  signed __int64 v9; // r11
  _WORD *v10; // rbx
  _WORD *v11; // rdi
  unsigned __int16 *v12; // rbp
  _WORD *v13; // r14
  unsigned __int16 *v14; // rsi

  v2 = a2;
  v3 = a1;
  if ( LOWORD(v2->m128i_i64[0]) >= 1u )
  {
    v4 = (_WORD *)v2->m128i_i64[1];
    if ( v4 )
    {
      if ( *v4 )
      {
        v5 = LOWORD(v2->m128i_i64[0]) >> 1;
        v6 = 0;
        if ( v5 <= 0u )
        {
LABEL_8:
          v10 = (_WORD *)(v3 + 56);
          v11 = (_WORD *)(v3 + 8);
          v12 = (unsigned __int16 *)(v3 + 40);
          v13 = (_WORD *)(v3 + 72);
          v14 = (unsigned __int16 *)(v3 + 24);
          if ( sub_140002058(
                 v2,
                 (_WORD *)(v3 + 24),
                 (_WORD *)(v3 + 40),
                 v3 + 8,
                 (_WORD *)(v3 + 72),
                 (_WORD *)(v3 + 56),
                 (_DWORD *)v3)
            && (*v14 <= 0u || sub_140002424(v14))
            && (*v12 <= 0u || sub_140002424(v12))
            && (*v11 <= 0u || sub_1400024F4((__int64)v11))
            && (*v10 <= 0u || sub_1400024F4((__int64)v10))
            && (!*v13 || (unsigned __int16)(*v13 - 65) <= 0x19u) )
          {
            return 1;
          }
        }
        else
        {
          while ( 1 )
          {
            v7 = v4[v6];
            if ( v7 <= 0x3Eu )
            {
              v8 = v7;
              v9 = 5764748260522590209i64;
              if ( _bittest64(&v9, v8) )
                break;
            }
            if ( ++v6 >= v5 )
              goto LABEL_8;
          }
        }
      }
    }
  }
  return 0;
}

//----- (0000000140001D30) ----------------------------------------------------
char __fastcall sub_140001D30(_DWORD *a1, unsigned __int16 *a2, unsigned __int16 *a3, __int64 a4, __int16 a5, __int16 *a6)
{
  _WORD *v6; // rdi
  __int64 v7; // rsi
  bool v8; // bl
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  unsigned __int16 v12; // cx
  __int64 v13; // rdx
  int v14; // er8
  __int64 v15; // rax
  unsigned __int16 v16; // ax
  __int16 v17; // ax
  __int16 v19; // ax
  __int16 v22; // [rsp+20h] [rbp-18h]
  __int16 v23; // [rsp+22h] [rbp-16h]
  unsigned __int64 v24; // [rsp+28h] [rbp-10h]

  v6 = a1;
  v7 = a4;
  v8 = 0;
  v9 = *a1 - 1;
  if ( !v9 )
    return sub_140001EFC(a2, a3, v6 + 12, v6 + 20);
  v10 = v9 - 1;
  if ( !v10 )
  {
    v8 = sub_140001EFC(a2, a3, v6 + 12, v6 + 20);
    if ( !v8 )
      return v8;
    v8 = sub_140001F40((__int16 *)v7, v6 + 4);
    if ( !v8 )
      return v8;
    v19 = v6[36];
    if ( v19 )
      return v19 == a5;
    if ( v6[28] <= 0u )
      return 1;
    return sub_140001F40(a6, v6 + 28);
  }
  v11 = v10 - 1;
  if ( v11 )
  {
    if ( v11 == 1 )
    {
      v8 = sub_140001EFC(a2, a3, v6 + 12, v6 + 20);
      if ( v8 )
      {
        v12 = *(_WORD *)v7;
        v8 = 0;
        if ( *(_WORD *)v7 >= 2u )
        {
          v13 = (__int64)(v6 + 4);
          v14 = (unsigned __int16)v6[4];
          if ( v12 - 2 >= v14 )
          {
            v23 = v6[4];
            v15 = *(_QWORD *)(v7 + 8);
            v22 = v14;
            v24 = v15 + 2 * (((unsigned __int64)v12 >> 1) - ((unsigned __int64)(unsigned int)v14 >> 1));
            return sub_140002B10(&v22, v13, 1) == 0;
          }
        }
      }
    }
  }
  else
  {
    v16 = v6[4];
    if ( *(_WORD *)a4 >= v16 && *(_WORD *)(*(_QWORD *)(a4 + 8) + 2 * ((unsigned __int64)v16 >> 1) - 2) == 92 )
    {
      v17 = v6[36];
      if ( (!v17 || v17 == a5) && (v6[28] <= 0u || sub_140001F40(a6, v6 + 28)) )
      {
        v13 = (__int64)(v6 + 4);
        v23 = v6[4];
        v22 = v23;
        v24 = *(_QWORD *)(v7 + 8);
        return sub_140002B10(&v22, v13, 1) == 0;
      }
    }
  }
  return v8;
}

//----- (0000000140001EFC) ----------------------------------------------------
bool __fastcall sub_140001EFC(unsigned __int16 *a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  unsigned __int16 *v4; // rdi
  unsigned __int16 *v5; // rbx

  v4 = a1;
  v5 = a3;
  return sub_140001F64(a2, a4) && sub_140001F64(v4, v5);
}

//----- (0000000140001F40) ----------------------------------------------------
bool __fastcall sub_140001F40(__int16 *a1, _WORD *a2)
{
  return *a1 == *a2 && !sub_140002B10(a1, (__int64)a2, 1);
}

//----- (0000000140001F64) ----------------------------------------------------
char __fastcall sub_140001F64(unsigned __int16 *a1, unsigned __int16 *a2)
{
  unsigned __int16 v2; // si
  unsigned __int16 *v3; // r14
  unsigned __int16 *v4; // r12
  unsigned __int16 v6; // bp
  char v7; // bl
  unsigned __int16 v8; // di
  __int64 v9; // rax
  __int16 v10; // r13
  unsigned __int16 v11; // si
  __int64 v12; // [rsp+58h] [rbp+10h]

  v2 = *a2;
  v3 = a2;
  v4 = a1;
  if ( *a2 == 2 && **((_WORD **)a2 + 1) == 42 )
    return 1;
  v6 = *a1;
  if ( *a1 > v2 )
    return 0;
  v7 = 1;
  v8 = 0;
  if ( (unsigned __int16)(v6 >> 1) > 0u )
  {
    v9 = *((_QWORD *)a2 + 1);
    v12 = *((_QWORD *)a2 + 1);
    do
    {
      v10 = *(_WORD *)(v9 + 2i64 * v8);
      if ( v10 != 63 )
      {
        if ( v10 != sub_140001BD4(*(_WORD *)(*((_QWORD *)v4 + 1) + 2i64 * v8)) )
          return 0;
        v9 = v12;
      }
      ++v8;
    }
    while ( v8 < (unsigned __int16)(v6 >> 1) );
  }
  if ( v2 > v6 )
  {
    v11 = v2 >> 1;
    if ( v8 < v11 )
    {
      while ( *(_WORD *)(*((_QWORD *)v3 + 1) + 2i64 * v8) == 63 )
      {
        if ( ++v8 >= v11 )
          return v7;
      }
      v7 = 0;
    }
  }
  return v7;
}

//----- (0000000140002050) ----------------------------------------------------
__int64 __fastcall sub_140002050(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  *a1 = 0i64;
  return result;
}

//----- (0000000140002058) ----------------------------------------------------
char __fastcall sub_140002058(__m128i *a1, _WORD *a2, _WORD *a3, __int64 a4, _WORD *a5, _WORD *a6, _DWORD *a7)
{
  _WORD *v7; // r14
  _WORD *v8; // rbx
  __m128i v9; // xmm0
  _WORD *v10; // rdi
  _WORD *v11; // r8
  __int64 v12; // rsi
  _WORD *v13; // rbp
  unsigned __int16 v14; // cx
  __m128i v16[2]; // [rsp+30h] [rbp-28h]

  v7 = a5;
  v8 = a3;
  v9 = *a1;
  v10 = a2;
  v11 = a5;
  *a5 = 0;
  v12 = a4;
  LOBYTE(a5) = 0;
  _mm_storeu_si128(v16, v9);
  if ( sub_140002B68((unsigned __int16 *)v16, &a5, v11) )
  {
    v13 = a6;
    sub_1400021A4(v16, (char)a5, (__int64)v10, (__int64)v8, v12, (__int64)a6);
    v14 = *(_WORD *)v12;
    if ( *(_WORD *)v12 >= 2u && **(_WORD **)(v12 + 8) == 92 )
    {
      if ( *v10 || *v8 )
      {
        *a7 = 2;
        return 1;
      }
      if ( !*v10 && !*v8 )
      {
        *a7 = 3;
        return 1;
      }
    }
    if ( !*v7 && !*v13 )
    {
      if ( v14 >= 2u && **(_WORD **)(v12 + 8) != 92 && (*v10 || *v8) )
      {
        *a7 = 4;
        return 1;
      }
      if ( !v14 && (*v10 || *v8) )
      {
        *a7 = 1;
        return 1;
      }
    }
  }
  return 0;
}

//----- (00000001400021A4) ----------------------------------------------------
__int16 __fastcall sub_1400021A4(__m128i *a1, char a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __m128i v6; // xmm0
  __int64 v7; // rsi
  __int64 v8; // r14
  __m128i *v9; // r10
  unsigned __int16 v10; // dx
  __int16 *v11; // rdi
  unsigned int v12; // er8
  __int16 v13; // cx
  int v14; // eax
  __int16 v15; // ax
  signed int v16; // ecx
  signed __int64 v17; // rax
  __int16 v18; // dx
  signed __int64 v19; // rbx
  __int16 result; // ax
  __int128 v21; // [rsp+20h] [rbp-20h]
  __int64 v22; // [rsp+30h] [rbp-10h]
  __int16 *v23; // [rsp+38h] [rbp-8h]

  v6 = *a1;
  v7 = a4;
  v22 = 0i64;
  v23 = 0i64;
  v8 = a3;
  v9 = a1;
  _mm_storeu_si128((__m128i *)&v21, v6);
  if ( a2 )
  {
    v10 = v21;
    v12 = 0;
    v11 = (__int16 *)*((_QWORD *)&v21 + 1);
    if ( (_WORD)v21 )
    {
      do
      {
        if ( v12 >= 3 )
          break;
        v13 = *v11;
        v10 -= 2;
        ++v11;
        v14 = v12 + 1;
        if ( v13 != 92 )
          v14 = v12;
        v12 = v14;
      }
      while ( v10 );
      *((_QWORD *)&v21 + 1) = v11;
      if ( v12 == 3 )
      {
        --v11;
        *((_QWORD *)&v21 + 1) = v11;
        v10 += 2;
      }
    }
    *(_QWORD *)(a6 + 8) = v9->m128i_i64[1];
    v15 = 2 * (unsigned __int64)((signed __int64)(unsigned int)(DWORD2(v21) - LODWORD(v9->m128i_i64[1])) >> 1);
    *(_WORD *)(a6 + 2) = v15;
    *(_WORD *)a6 = v15;
  }
  else
  {
    sub_140002B58(a6, (__int64)&unk_1400308F0, 0);
    v10 = v21;
    v11 = (__int16 *)*((_QWORD *)&v21 + 1);
  }
  v16 = (unsigned int)v10 >> 1;
  do
    --v16;
  while ( v16 >= 0 && v11[v16] != 92 );
  v17 = v16 + 1i64;
  v18 = v10 - 2 * v16;
  WORD1(v22) = v18 - 2;
  v19 = (signed __int64)&v11[v17];
  LOWORD(v22) = v18 - 2;
  v23 = &v11[v17];
  result = sub_1400022E8((__int16 *)&v22, v8, v7);
  LOWORD(v19) = 2 * (unsigned __int64)((v19 - (signed __int64)v11) >> 1);
  *(_WORD *)(a5 + 2) = v19;
  *(_WORD *)a5 = v19;
  *(_QWORD *)(a5 + 8) = v11;
  return result;
}

//----- (00000001400022E8) ----------------------------------------------------
__int16 __fastcall sub_1400022E8(__int16 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 v4; // r9
  __int16 *v5; // r10
  __int64 v6; // r11
  __int64 v7; // rax
  int v8; // ecx
  signed __int64 v9; // rax
  _WORD *v10; // rdx
  __int16 v11; // ax
  signed __int64 v12; // rdx

  LOWORD(v3) = *a1;
  v4 = a2;
  v5 = a1;
  if ( *a1 && (v6 = *((_QWORD *)a1 + 1)) != 0 )
  {
    v7 = (unsigned int)(unsigned __int16)v3 >> 1;
    v8 = v7 - 1;
    if ( (signed int)v7 - 1 >= 0 )
    {
      v9 = v7 - 1;
      v10 = (_WORD *)(v6 + 2 * v9);
      do
      {
        if ( *v10 == 46 )
          break;
        --v8;
        --v10;
        --v9;
      }
      while ( v9 >= 0 );
    }
    if ( v8 == -1 )
    {
      *(_DWORD *)a3 = 0;
      *(_QWORD *)(a3 + 8) = 0i64;
      v11 = *v5;
      *(_WORD *)(v4 + 2) = *v5;
      *(_WORD *)v4 = v11;
      v3 = *((_QWORD *)v5 + 1);
      *(_QWORD *)(v4 + 8) = v3;
    }
    else
    {
      *(_QWORD *)(v4 + 8) = v6;
      v12 = 2i64 * v8;
      *(_WORD *)(v4 + 2) = v12;
      *(_WORD *)v4 = v12;
      *(_QWORD *)(a3 + 8) = v12 + *((_QWORD *)v5 + 1) + 2i64;
      LOWORD(v3) = *v5 - v12 - 2;
      *(_WORD *)(a3 + 2) = v3;
      *(_WORD *)a3 = v3;
    }
  }
  else
  {
    *(_DWORD *)a2 = 0;
    *(_DWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0i64;
    *(_QWORD *)(a2 + 8) = 0i64;
  }
  return v3;
}

//----- (00000001400023AC) ----------------------------------------------------
char __fastcall sub_1400023AC(_WORD *a1, _WORD *a2, unsigned int *a3)
{
  unsigned int v3; // eax
  unsigned __int128 v4; // di
  __int64 v6; // rbp

  v3 = (unsigned __int16)*a2;
  v4 = __PAIR__((unsigned __int64)a1, (unsigned __int64)a2);
  if ( v3 > *a3 )
    return 0;
  a1[1] = v3;
  v6 = 0i64;
  *a1 = v3;
  *a3 -= (unsigned __int16)*a2;
  if ( *a2 & 0xFFFE )
  {
    do
    {
      *(_WORD *)(*(_QWORD *)(*((_QWORD *)&v4 + 1) + 8i64) + 2 * v6) = sub_140001BD4(*(_WORD *)(*(_QWORD *)(v4 + 8)
                                                                                             + 2 * v6));
      v6 = (unsigned int)(v6 + 1);
    }
    while ( (unsigned int)v6 < (unsigned int)*(unsigned __int16 *)v4 >> 1 );
  }
  return 1;
}

//----- (0000000140002424) ----------------------------------------------------
char __fastcall sub_140002424(unsigned __int16 *a1)
{
  unsigned __int16 v1; // r10
  char v2; // r9
  unsigned __int16 v3; // r8
  unsigned __int16 v4; // dx
  __int64 v5; // r11
  __int16 v6; // cx
  signed __int64 v7; // rbx

  v1 = *a1;
  v2 = 0;
  v3 = *a1 >> 1;
  v4 = 0;
  if ( v3 > 0u )
  {
    v5 = *((_QWORD *)a1 + 1);
    do
    {
      v6 = *(_WORD *)(v5 + 2i64 * v4);
      if ( v6 == 42 )
      {
        v2 = 1;
      }
      else
      {
        if ( (unsigned __int16)(v6 - 47) <= 0x2Du )
        {
          v7 = 35184372131841i64;
          if ( _bittest64(&v7, (unsigned __int16)(v6 - 47)) )
            return 0;
        }
        if ( v6 == 124 )
          return 0;
      }
      ++v4;
    }
    while ( v4 < v3 );
    if ( v2 && v1 != 2 )
      return 0;
  }
  return 1;
}

//----- (00000001400024A8) ----------------------------------------------------
char __fastcall sub_1400024A8(unsigned __int16 *a1)
{
  unsigned int v1; // eax
  unsigned __int16 *v2; // rdi
  __int64 v3; // rbx
  __int64 v4; // rsi

  v1 = (unsigned int)*a1 >> 1;
  if ( !v1 )
    return 1;
  v2 = (unsigned __int16 *)*((_QWORD *)a1 + 1);
  v3 = 0i64;
  v4 = v1;
  while ( sub_14000255C(*v2) )
  {
    ++v3;
    ++v2;
    if ( v3 >= v4 )
      return 1;
  }
  return 0;
}

//----- (00000001400024F4) ----------------------------------------------------
char __fastcall sub_1400024F4(__int64 a1)
{
  unsigned __int16 v1; // r9
  char v2; // dl
  unsigned __int16 v3; // r8
  __int64 v4; // r10
  unsigned __int16 v5; // cx

  v1 = *(_WORD *)a1 >> 1;
  v2 = 1;
  v3 = 0;
  if ( v1 > 0u )
  {
    v4 = *(_QWORD *)(a1 + 8);
    do
    {
      v5 = *(_WORD *)(v4 + 2i64 * v3);
      if ( !((v5 - 42) & 0xFFED) && v5 != 44 || v5 > 0x3Du && (v5 <= 0x3Fu || v5 == 124) )
        v2 = 0;
      if ( !v2 )
        break;
      ++v3;
    }
    while ( v3 < v1 );
  }
  return v2;
}

//----- (000000014000255C) ----------------------------------------------------
bool __fastcall sub_14000255C(unsigned __int16 a1)
{
  signed __int64 v1; // rdx
  bool result; // al

  result = (a1 > 0x3Eu || (v1 = 5764748277702459392i64, !_bittest64(&v1, a1))) && a1 != 124;
  return result;
}

//----- (0000000140002584) ----------------------------------------------------
__m128 *__fastcall sub_140002584(__m128 *a1, unsigned __int64 a2)
{
  return sub_14001E1C0(a1, 0, a2);
}

//----- (0000000140002590) ----------------------------------------------------
_DWORD *__fastcall sub_140002590(int a1)
{
  _DWORD *result; // rax
  int v2; // [rsp+20h] [rbp-18h]

  v2 = a1;
  if ( a1 == 2 )
  {
    sub_140002590(1i64);
    v2 = 0;
  }
  result = sub_140001BE4(&v2);
  *(_QWORD *)result = 0i64;
  result[2] = 0;
  *((_QWORD *)result + 2) = 0i64;
  return result;
}

//----- (00000001400025E4) ----------------------------------------------------
__int64 __fastcall sub_1400025E4(PCWSTR SourceString, unsigned __int64 a2, int a3)
{
  WCHAR *v3; // r14
  unsigned __int64 v4; // rsi
  PVOID *v5; // r13
  unsigned int v6; // edi
  __int64 v7; // rbx
  int v8; // esi
  signed __int64 v9; // r12
  __m128 *v10; // rax
  __int64 v11; // r15
  signed int v12; // eax
  signed __int64 v13; // r12
  _WORD *v14; // r12
  unsigned int v15; // eax
  int v16; // er8
  unsigned int v18; // [rsp+20h] [rbp-50h]
  void *v19; // [rsp+28h] [rbp-48h]
  SIZE_T v20; // [rsp+30h] [rbp-40h]
  __int64 v21; // [rsp+38h] [rbp-38h]
  __int64 v22; // [rsp+40h] [rbp-30h]
  UNICODE_STRING DestinationString; // [rsp+48h] [rbp-28h]
  char v24; // [rsp+58h] [rbp-18h]

  v3 = (WCHAR *)SourceString;
  *(_DWORD *)&DestinationString.Length = a3;
  v4 = a2;
  v5 = (PVOID *)sub_140001BE4(&DestinationString);
  sub_140002584((__m128 *)&v19, 8ui64);
  unknown_libname_1(&v19);
  v6 = 0;
  *(_DWORD *)&DestinationString.Length = 0;
  v7 = 0i64;
  v22 = 0i64;
  v18 = 0;
  if ( !v3 || !sub_140001B40(v3, &DestinationString, &v18, v4) )
  {
LABEL_22:
    v12 = -1073741811;
    goto LABEL_23;
  }
  v8 = *(_DWORD *)&DestinationString.Length;
  if ( !*(_DWORD *)&DestinationString.Length )
    goto LABEL_19;
  v9 = 88i64 * *(unsigned int *)&DestinationString.Length;
  v20 = 88i64 * *(unsigned int *)&DestinationString.Length + v18;
  sub_140001AB8((PVOID *)&DestinationString, v20);
  sub_140001AFC(&v19, (void **)&DestinationString);
  sub_140001AE0((void **)&DestinationString);
  v10 = (__m128 *)sub_140001B3C((__int64)&v19);
  v11 = (__int64)v10;
  if ( !v10 )
  {
    v12 = -1073741670;
LABEL_23:
    v6 = v12;
    goto LABEL_24;
  }
  sub_14001E1C0(v10, 0, v20);
  v13 = v11 + v9;
  if ( !*v3 )
    goto LABEL_19;
  do
  {
    *(_QWORD *)&DestinationString.Length = 0i64;
    DestinationString.Buffer = 0i64;
    v20 = 0i64;
    v21 = 0i64;
    RtlInitUnicodeString(&DestinationString, v3);
    if ( sub_1400024A8(&DestinationString.Length) )
    {
      LOWORD(v20) = DestinationString.Length;
      WORD1(v20) = DestinationString.Length;
      v21 = v13;
      if ( !sub_1400023AC(&v20, &DestinationString, &v18) )
        goto LABEL_22;
      v14 = (_WORD *)(v13 + 2 * ((unsigned __int64)(unsigned __int16)v20 >> 1));
      v15 = v18;
      if ( v18 < 2 )
        goto LABEL_22;
      *v14 = 0;
      v18 = v15 - 2;
      v13 = (signed __int64)(v14 + 1);
      if ( sub_140001BF8(v11, (__m128i *)&v20) )
      {
        CAMSchedule::CAdvisePacket::InsertAfter(
          (CAMSchedule::CAdvisePacket *)&v22,
          (struct CAMSchedule::CAdvisePacket *)(v11 + 80));
        v11 += 88i64;
        goto LABEL_16;
      }
      v16 = 576;
    }
    else
    {
      v16 = 594;
    }
    sub_140002E18(
      DestinationString.Buffer,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\exclusions.cpp",
      v16);
    if ( !v8 )
      goto LABEL_22;
    --v8;
    do
LABEL_16:
      ++v3;
    while ( *v3 );
    ++v3;
  }
  while ( *v3 );
  v7 = v22;
LABEL_19:
  v24 = 0;
  sub_140002D6C(&v24);
  if ( *v5 )
    ExFreePoolWithTag(*v5, 0);
  *v5 = (PVOID)sub_140002050((__int64 *)&v19);
  v5[2] = (PVOID)v7;
  *((_DWORD *)v5 + 2) = v8;
  sub_140002D28(1);
LABEL_24:
  sub_140001AE0(&v19);
  return v6;
}
// 140001AB0: using guessed type __int64 __fastcall unknown_libname_1(_QWORD);

//----- (0000000140002838) ----------------------------------------------------
bool __fastcall sub_140002838(__m128i *a1)
{
  __m128i v1; // xmm0
  __int128 v3; // [rsp+20h] [rbp-10h]
  char v4; // [rsp+40h] [rbp+10h]
  __int16 v5; // [rsp+48h] [rbp+18h]

  v1 = *a1;
  v4 = 0;
  v5 = 0;
  _mm_storeu_si128((__m128i *)&v3, v1);
  return sub_140002B68((unsigned __int16 *)&v3, &v4, &v5)
      && (!v5 || v5 == 67)
      && (sub_140001F40((__int16 *)&v3, &unk_140029890)
       || sub_140001F40((__int16 *)&v3, &unk_140029948)
       || sub_140001F40((__int16 *)&v3, "")
       || sub_140001F40((__int16 *)&v3, L"jl")
       || sub_140001F40((__int16 *)&v3, L"bd")
       || sub_140001F40((__int16 *)&v3, L"|~")
       || sub_140001F40((__int16 *)&v3, L"df")
       || sub_140001F40((__int16 *)&v3, L"vx")
       || sub_140001F40((__int16 *)&v3, L"xz"));
}
// 140029AA8: using guessed type wchar_t aJl[3];
// 140029B30: using guessed type wchar_t aBd[3];
// 140029BA8: using guessed type wchar_t asc_140029BA8[3];
// 140029C40: using guessed type wchar_t aDf[3];
// 140029CB8: using guessed type wchar_t aVx[3];
// 140029D48: using guessed type wchar_t aXz[3];

//----- (0000000140002950) ----------------------------------------------------
char __fastcall sub_140002950(__m128i *a1, int a2)
{
  __m128i *v2; // rbx
  _DWORD *v3; // rax
  __m128i v4; // xmm0
  char v5; // bl
  _DWORD *v6; // rdi
  _QWORD *v7; // rdi
  _QWORD *v8; // rax
  __int16 v9; // si
  char v11; // [rsp+30h] [rbp-29h]
  __int64 v12; // [rsp+38h] [rbp-21h]
  __int64 v13; // [rsp+40h] [rbp-19h]
  __int64 v14; // [rsp+48h] [rbp-11h]
  __int64 v15; // [rsp+50h] [rbp-9h]
  __int64 v16; // [rsp+58h] [rbp-1h]
  __int64 v17; // [rsp+60h] [rbp+7h]
  __int64 v18; // [rsp+68h] [rbp+Fh]
  __int64 v19; // [rsp+70h] [rbp+17h]
  __int128 v20; // [rsp+78h] [rbp+1Fh]
  char v21; // [rsp+88h] [rbp+2Fh]
  int v22; // [rsp+90h] [rbp+37h]

  v2 = a1;
  v22 = a2;
  v3 = sub_140001BE4(&v22);
  v4 = *v2;
  v5 = 0;
  v6 = v3;
  v11 = 0;
  _mm_storeu_si128((__m128i *)&v20, v4);
  LOWORD(v22) = 0;
  v18 = 0i64;
  v19 = 0i64;
  v16 = 0i64;
  v17 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  v12 = 0i64;
  v13 = 0i64;
  if ( !v3[2] || !sub_140002B68((unsigned __int16 *)&v20, &v11, &v22) )
    return 0;
  sub_1400021A4((__m128i *)&v20, v11, (__int64)&v18, (__int64)&v16, (__int64)&v14, (__int64)&v12);
  v21 = 0;
  sub_140002D4C(&v21);
  v7 = v6 + 4;
  v8 = (_QWORD *)*v7;
  if ( *v7 )
  {
    v9 = v22;
    while ( !sub_140001D30(
               (_DWORD *)v8 - 20,
               (unsigned __int16 *)&v18,
               (unsigned __int16 *)&v16,
               (__int64)&v14,
               v9,
               (__int16 *)&v12) )
    {
      v7 = (_QWORD *)*v7;
      v8 = (_QWORD *)*v7;
      if ( !*v7 )
        goto LABEL_9;
    }
    v5 = 1;
  }
LABEL_9:
  sub_140002D28(0);
  return v5;
}

//----- (0000000140002A8C) ----------------------------------------------------
__int64 __fastcall sub_140002A8C(int a1)
{
  PVOID *v1; // rbx
  char v3; // [rsp+20h] [rbp-28h]
  int v4; // [rsp+28h] [rbp-20h]

  v4 = a1;
  if ( a1 == 2 )
  {
    sub_140002A8C(1i64);
    v4 = 0;
  }
  v3 = 0;
  v1 = (PVOID *)sub_140001BE4(&v4);
  sub_140002D6C(&v3);
  if ( *v1 )
    ExFreePoolWithTag(*v1, 0);
  *v1 = 0i64;
  v1[2] = 0i64;
  *((_DWORD *)v1 + 2) = 0;
  return sub_140002D28(1);
}

//----- (0000000140002B10) ----------------------------------------------------
int __fastcall sub_140002B10(__int16 *a1, __int64 a2, char a3)
{
  int result; // eax
  char v4; // r10
  unsigned __int16 v5; // r9
  const wchar_t *v6; // rdx
  const wchar_t *v7; // rcx
  unsigned __int64 v8; // r8

  result = -1;
  v4 = a3;
  if ( a1 )
  {
    if ( a2 )
    {
      v5 = *a1;
      if ( *a1 == *(_WORD *)a2 )
      {
        v6 = *(const wchar_t **)(a2 + 8);
        v7 = (const wchar_t *)*((_QWORD *)a1 + 1);
        v8 = (unsigned __int64)v5 >> 1;
        if ( v4 )
          result = wcsnicmp(v7, v6, v8);
        else
          result = wcsncmp(v7, v6, v8);
      }
    }
  }
  return result;
}

//----- (0000000140002B58) ----------------------------------------------------
__int64 __fastcall sub_140002B58(__int64 a1, __int64 a2, __int16 a3)
{
  __int64 result; // rax

  result = 0i64;
  *(_QWORD *)a1 = 0i64;
  *(_WORD *)(a1 + 2) = a3;
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

//----- (0000000140002B68) ----------------------------------------------------
char __fastcall sub_140002B68(unsigned __int16 *a1, _BYTE *a2, _WORD *a3)
{
  _BYTE *v3; // rdi
  unsigned __int16 *v4; // rbx
  _WORD *v5; // rsi
  unsigned __int16 v6; // cx
  _WORD *v7; // rax
  signed __int64 v8; // rax
  unsigned __int16 v9; // cx
  unsigned __int16 v11; // cx
  __int16 *v12; // rax
  __int16 v13; // dx
  __int16 v14; // r9
  int v15; // [rsp+20h] [rbp-28h]
  __int64 v16; // [rsp+28h] [rbp-20h]
  int v17; // [rsp+30h] [rbp-18h]
  const wchar_t *v18; // [rsp+38h] [rbp-10h]

  v3 = a2;
  *a2 = 0;
  v4 = a1;
  *a3 = 0;
  v5 = a3;
  v6 = *a1;
  if ( v6 >= 8u )
  {
    v7 = (_WORD *)*((_QWORD *)v4 + 1);
    if ( v7[2] == 63 && *v7 == 92 && v7[1] == 92 && v7[3] == 92 )
    {
      if ( v6 == 8 )
        return 0;
      v8 = (signed __int64)(v7 + 4);
      v9 = v6 - 8;
      *((_QWORD *)v4 + 1) = v8;
      *v4 = v9;
      if ( v9 >= 8u )
      {
        v17 = 524296;
        v18 = L"unc\\";
        v15 = 524296;
        v16 = v8;
        if ( !sub_140002B10((__int16 *)&v17, (__int64)&v15, 1) )
        {
          *v3 = 1;
          *((_QWORD *)v4 + 1) += 6i64;
          *v4 -= 6;
        }
      }
      if ( !*v3 && (*v4 < 4u || *(_WORD *)(*((_QWORD *)v4 + 1) + 2i64) != 58) )
        return 0;
    }
  }
  v11 = *v4;
  if ( *v4 >= 4u )
  {
    v12 = (__int16 *)*((_QWORD *)v4 + 1);
    v13 = *v12;
    v14 = v12[1];
    if ( v14 == 58 )
    {
      *v5 = v13;
      *((_QWORD *)v4 + 1) += 4i64;
      *v4 -= 4;
    }
    else if ( v13 == 92 && v14 == 92 )
    {
      *((_QWORD *)v4 + 1) = v12 + 1;
      *v4 = v11 - 2;
      *v3 = 1;
    }
  }
  return 1;
}
// 14001E6A0: using guessed type wchar_t aUnc[5];

//----- (0000000140002CAC) ----------------------------------------------------
void __fastcall sub_140002CAC(int a1)
{
  PVOID *v1; // rbx
  int v2; // [rsp+20h] [rbp-18h]

  v2 = a1;
  if ( a1 == 2 )
  {
    sub_140002CAC(1i64);
    v2 = 0;
  }
  v1 = (PVOID *)sub_140001BE4(&v2);
  if ( *v1 )
  {
    ExFreePoolWithTag(*v1, 0);
    *v1 = 0i64;
  }
}

//----- (0000000140002D10) ----------------------------------------------------
void sub_140002D10()
{
  sub_140002CAC(2);
}

//----- (0000000140002D1C) ----------------------------------------------------
_DWORD *sub_140002D1C()
{
  return sub_140002590(2);
}

//----- (0000000140002D28) ----------------------------------------------------
__int64 __fastcall sub_140002D28(char a1)
{
  __int64 result; // rax

  if ( a1 )
    result = ExReleaseSpinLockExclusive(&unk_1400308F4);
  else
    result = ExReleaseSpinLockShared(&unk_1400308F4);
  return result;
}
// 1400291D8: using guessed type __int64 __fastcall ExReleaseSpinLockShared(_QWORD);
// 1400291E8: using guessed type __int64 __fastcall ExReleaseSpinLockExclusive(_QWORD);

//----- (0000000140002D4C) ----------------------------------------------------
__int64 __fastcall sub_140002D4C(_BYTE *a1)
{
  _BYTE *v1; // rbx
  __int64 result; // rax

  v1 = a1;
  result = ExAcquireSpinLockShared(&unk_1400308F4);
  *v1 = result;
  return result;
}
// 1400291D0: using guessed type __int64 __fastcall ExAcquireSpinLockShared(_QWORD);

//----- (0000000140002D6C) ----------------------------------------------------
__int64 __fastcall sub_140002D6C(_BYTE *a1)
{
  _BYTE *v1; // rbx
  __int64 result; // rax

  v1 = a1;
  result = ExAcquireSpinLockExclusive(&unk_1400308F4);
  *v1 = result;
  return result;
}
// 1400291E0: using guessed type __int64 __fastcall ExAcquireSpinLockExclusive(_QWORD);

//----- (0000000140002D9C) ----------------------------------------------------
__int64 sub_140002D9C()
{
  return sub_140002FB8(&unk_140030040);
}

//----- (0000000140002DA8) ----------------------------------------------------
void __fastcall sub_140002DA8(__int64 a1, __int64 a2, int a3)
{
  *(_DWORD *)(a1 + 12) = 0;
  *(_QWORD *)a1 = a2;
  *(_DWORD *)(a1 + 8) = a3;
}

//----- (0000000140002DB4) ----------------------------------------------------
__int64 sub_140002DB4()
{
  return sub_140002FA0((__int64)&unk_140029DE0, (__int64)sub_140002EA0, (__int64)&unk_140030040, &unk_140030040);
}

//----- (0000000140002DD4) ----------------------------------------------------
__int64 __fastcall sub_140002DD4(const wchar_t *a1, __int64 a2, __int64 a3, __int64 a4, int a5)
{
  __int64 result; // rax
  _QWORD v6[2]; // [rsp+38h] [rbp-10h]

  if ( byte_140034440 & 4 )
  {
    LODWORD(v6[0]) = a5;
    result = sub_14000318C(&unk_140030040, (__int64)&unk_140029E20, 0i64, a1, a2, a3, a4, v6[0]);
  }
  return result;
}
// 140034440: using guessed type char byte_140034440;

//----- (0000000140002E18) ----------------------------------------------------
void **__fastcall sub_140002E18(const wchar_t *a1, __int64 a2, int a3)
{
  void **result; // rax
  __int64 v4; // [rsp+20h] [rbp-28h]
  __int64 v5; // [rsp+28h] [rbp-20h]
  __int64 v6; // [rsp+38h] [rbp-10h]
  void *retaddr; // [rsp+48h] [rbp+0h]

  result = &retaddr;
  if ( byte_140034440 & 2 )
  {
    LODWORD(v6) = a3;
    LODWORD(v5) = 0;
    LODWORD(v4) = 0;
    result = (void **)sub_140003060(&unk_140030040, (__int64)&unk_140029E70, 0i64, a1, v4, v5, a2, v6);
  }
  return result;
}
// 140034440: using guessed type char byte_140034440;

//----- (0000000140002E58) ----------------------------------------------------
__int64 __fastcall sub_140002E58(const wchar_t *a1, int a2, int a3, __int64 a4, int a5)
{
  __int64 result; // rax
  __int64 v6; // [rsp+20h] [rbp-28h]
  __int64 v7; // [rsp+28h] [rbp-20h]
  _QWORD v8[2]; // [rsp+38h] [rbp-10h]

  if ( byte_140034440 & 2 )
  {
    LODWORD(v8[0]) = a5;
    LODWORD(v7) = a3;
    LODWORD(v6) = a2;
    result = sub_140003060(&unk_140030040, (__int64)&unk_140029E10, 0i64, a1, v6, v7, a4, v8[0]);
  }
  return result;
}
// 140034440: using guessed type char byte_140034440;

//----- (0000000140002EA0) ----------------------------------------------------
void __fastcall sub_140002EA0(__int64 a1, int a2, char a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  unsigned int v7; // esi
  signed int v8; // edi
  int *v9; // r14
  int v10; // ebp
  int v11; // edi
  unsigned __int16 v12; // ax

  if ( a7 )
  {
    if ( a2 )
    {
      if ( a2 == 1 )
      {
        v7 = 0;
        *(_QWORD *)(a7 + 24) = a5;
        *(_BYTE *)(a7 + 40) = a3;
        *(_QWORD *)(a7 + 16) = a4;
        for ( *(_DWORD *)(a7 + 36) = 1; v7 < *(unsigned __int16 *)(a7 + 42); ++v7 )
        {
          v8 = 1 << (v7 & 0x1F);
          v9 = (int *)(*(_QWORD *)(a7 + 48) + 4 * ((unsigned __int64)v7 >> 5));
          v10 = *v9;
          if ( sub_140003030(a7, *(_BYTE *)(*(_QWORD *)(a7 + 64) + v7), *(_QWORD *)(*(_QWORD *)(a7 + 56) + 8i64 * v7)) )
            v11 = v10 | v8;
          else
            v11 = v10 & ~v8;
          *v9 = v11;
        }
      }
    }
    else
    {
      v12 = *(_WORD *)(a7 + 42);
      *(_DWORD *)(a7 + 36) = 0;
      *(_BYTE *)(a7 + 40) = 0;
      *(_QWORD *)(a7 + 16) = 0i64;
      *(_QWORD *)(a7 + 24) = 0i64;
      if ( v12 )
        sub_14001E1C0(*(__m128 **)(a7 + 48), 0, 4i64 * ((v12 - 1) / 32 + 1));
    }
  }
}

//----- (0000000140002FA0) ----------------------------------------------------
__int64 __fastcall sub_140002FA0(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  __int64 result; // rax

  result = 0i64;
  if ( !*a4 )
    result = EtwRegister();
  return result;
}
// 1400291F0: using guessed type __int64 EtwRegister(void);

//----- (0000000140002FB8) ----------------------------------------------------
__int64 __fastcall sub_140002FB8(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 result; // rax

  v1 = a1;
  if ( !*a1 )
    return 0i64;
  result = EtwUnregister();
  *v1 = 0i64;
  return result;
}
// 1400291F8: using guessed type __int64 EtwUnregister(void);

//----- (0000000140002FE0) ----------------------------------------------------
__int64 __fastcall sub_140002FE0(_QWORD *a1, __int64 a2, __int64 a3, int a4, __int64 a5)
{
  unsigned __int16 *v5; // r11
  signed int v6; // eax
  int v7; // ebx
  int v8; // er9

  v5 = (unsigned __int16 *)a1[1];
  v6 = 0;
  v7 = a4;
  if ( v5 )
  {
    *(_QWORD *)a5 = v5;
    v6 = 2;
    v8 = *v5;
  }
  else
  {
    *(_QWORD *)a5 = 0i64;
    v8 = 0;
  }
  *(_DWORD *)(a5 + 8) = v8;
  *(_DWORD *)(a5 + 12) = v6;
  return EtwWriteTransfer(*a1, a2, a3, 0i64, v7, a5);
}
// 140029200: using guessed type __int64 __fastcall EtwWriteTransfer(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140003030) ----------------------------------------------------
bool __fastcall sub_140003030(__int64 a1, unsigned __int8 a2, __int64 a3)
{
  unsigned __int8 v3; // al

  v3 = *(_BYTE *)(a1 + 40);
  return (a2 <= v3 || !v3) && (!a3 || *(_QWORD *)(a1 + 16) & a3 && (a3 & *(_QWORD *)(a1 + 24)) == *(_QWORD *)(a1 + 24));
}

//----- (0000000140003060) ----------------------------------------------------
__int64 sub_140003060(_QWORD *a1, __int64 a2, __int64 a3, const wchar_t *a4, ...)
{
  signed __int64 v4; // rbx
  __int64 v5; // rbp
  __int64 v6; // rsi
  _QWORD *v7; // rdi
  signed __int64 v8; // rax
  int v9; // er8
  const wchar_t *v10; // rdx
  int v11; // ebx
  const char *v12; // rdx
  char v14; // [rsp+30h] [rbp-98h]
  char v15; // [rsp+40h] [rbp-88h]
  char v16; // [rsp+50h] [rbp-78h]
  char v17; // [rsp+60h] [rbp-68h]
  char v18; // [rsp+70h] [rbp-58h]
  char v19; // [rsp+80h] [rbp-48h]
  __int64 v20; // [rsp+F0h] [rbp+28h]
  va_list va; // [rsp+F0h] [rbp+28h]
  char v22; // [rsp+F8h] [rbp+30h]
  va_list va1; // [rsp+F8h] [rbp+30h]
  const char *v24; // [rsp+100h] [rbp+38h]
  va_list va2; // [rsp+108h] [rbp+40h]

  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  v20 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  *(_QWORD *)&v22 = va_arg(va2, _QWORD);
  v24 = va_arg(va2, const char *);
  v4 = -1i64;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( a4 )
  {
    v8 = -1i64;
    do
      ++v8;
    while ( a4[v8] );
    v9 = 2 * v8 + 2;
  }
  else
  {
    v9 = 10;
  }
  v10 = L"NULL";
  if ( a4 )
    v10 = a4;
  sub_140002DA8((__int64)&v15, (__int64)v10, v9);
  sub_140002DA8((__int64)&v16, (__int64)va, 4);
  sub_140002DA8((__int64)&v17, (__int64)va1, 4);
  if ( v24 )
  {
    do
      ++v4;
    while ( v24[v4] );
    v11 = v4 + 1;
  }
  else
  {
    v11 = 5;
  }
  v12 = "NULL";
  if ( v24 )
    v12 = v24;
  sub_140002DA8((__int64)&v18, (__int64)v12, v11);
  sub_140002DA8((__int64)&v19, (__int64)va2, 4);
  return sub_140002FE0(v7, v6, v5, 6, (__int64)&v14);
}
// 14001E6B0: using guessed type wchar_t aNull[5];

//----- (000000014000318C) ----------------------------------------------------
__int64 sub_14000318C(_QWORD *a1, __int64 a2, __int64 a3, const wchar_t *a4, ...)
{
  signed __int64 v4; // rbx
  __int64 v5; // rbp
  __int64 v6; // rsi
  _QWORD *v7; // rdi
  signed __int64 v8; // rax
  int v9; // er8
  const wchar_t *v10; // rdx
  int v11; // ebx
  const char *v12; // rdx
  char v14; // [rsp+30h] [rbp-98h]
  char v15; // [rsp+40h] [rbp-88h]
  char v16; // [rsp+50h] [rbp-78h]
  char v17; // [rsp+60h] [rbp-68h]
  char v18; // [rsp+70h] [rbp-58h]
  char v19; // [rsp+80h] [rbp-48h]
  __int64 v20; // [rsp+F0h] [rbp+28h]
  va_list va; // [rsp+F0h] [rbp+28h]
  char v22; // [rsp+F8h] [rbp+30h]
  va_list va1; // [rsp+F8h] [rbp+30h]
  const char *v24; // [rsp+100h] [rbp+38h]
  va_list va2; // [rsp+108h] [rbp+40h]

  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  v20 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  *(_QWORD *)&v22 = va_arg(va2, _QWORD);
  v24 = va_arg(va2, const char *);
  v4 = -1i64;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( a4 )
  {
    v8 = -1i64;
    do
      ++v8;
    while ( a4[v8] );
    v9 = 2 * v8 + 2;
  }
  else
  {
    v9 = 10;
  }
  v10 = L"NULL";
  if ( a4 )
    v10 = a4;
  sub_140002DA8((__int64)&v15, (__int64)v10, v9);
  sub_140002DA8((__int64)&v16, (__int64)va, 8);
  sub_140002DA8((__int64)&v17, (__int64)va1, 8);
  if ( v24 )
  {
    do
      ++v4;
    while ( v24[v4] );
    v11 = v4 + 1;
  }
  else
  {
    v11 = 5;
  }
  v12 = "NULL";
  if ( v24 )
    v12 = v24;
  sub_140002DA8((__int64)&v18, (__int64)v12, v11);
  sub_140002DA8((__int64)&v19, (__int64)va2, 4);
  return sub_140002FE0(v7, v6, v5, 6, (__int64)&v14);
}
// 14001E6B0: using guessed type wchar_t aNull[5];

//----- (00000001400032C0) ----------------------------------------------------
void *__fastcall sub_1400032C0(_QWORD *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140003B50(a1);
  if ( v2 & 1 )
    sub_140007714(v3);
  return v3;
}

//----- (0000000140003300) ----------------------------------------------------
__int64 __fastcall sub_140003300(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  char v6; // [rsp+20h] [rbp-28h]
  __int64 v7; // [rsp+30h] [rbp-18h]

  v7 = a2;
  v3 = a3;
  v4 = a1;
  sub_14000388C((__int64)&v6, a1 + 4136, 1);
  LODWORD(v4) = sub_140004858(v4 + 8, &v7, v3);
  sub_140003AF8(&v6);
  return (unsigned int)v4;
}

//----- (0000000140003370) ----------------------------------------------------
__int64 __fastcall sub_140003370(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  char v4; // [rsp+20h] [rbp-28h]
  __int64 v5; // [rsp+30h] [rbp-18h]

  v5 = a2;
  v2 = a1;
  sub_14000388C((__int64)&v4, a1 + 4136, 1);
  sub_140004170(v2 + 8, &v5);
  return sub_140003AF8(&v4);
}

//----- (00000001400033D0) ----------------------------------------------------
__int64 __fastcall sub_1400033D0(__int64 a1)
{
  __int64 v1; // rbx
  char v3; // [rsp+20h] [rbp-18h]

  v1 = a1;
  sub_14000388C((__int64)&v3, a1 + 4136, 1);
  sub_140003CB8((struct _LIST_ENTRY *)(v1 + 8));
  return sub_140003AF8(&v3);
}

//----- (0000000140003410) ----------------------------------------------------
char __fastcall sub_140003410(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  char v4; // [rsp+20h] [rbp-28h]
  __int64 v5; // [rsp+30h] [rbp-18h]

  v5 = a2;
  v2 = a1;
  sub_14000388C((__int64)&v4, a1 + 4136, 0);
  LOBYTE(v2) = sub_140004628(v2 + 8, &v5) != 0i64;
  sub_140003AF8(&v4);
  return v2;
}

//----- (0000000140003480) ----------------------------------------------------
void *__fastcall sub_140003480(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140003B2C(a1);
  if ( v2 & 1 )
    sub_140007714(v3);
  return v3;
}
// 140003B2C: using guessed type __int64 __fastcall sub_140003B2C(_QWORD);

//----- (00000001400034C0) ----------------------------------------------------
void *__fastcall sub_1400034C0(_QWORD *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140003B64(a1);
  if ( v2 & 1 )
    sub_140007714(v3);
  return v3;
}

//----- (0000000140003500) ----------------------------------------------------
__int64 __fastcall sub_140003500(__int64 a1, __int64 a2, _BYTE *a3)
{
  __int64 v3; // rbx
  _BYTE *v4; // rdi
  __int64 v6; // [rsp+20h] [rbp-38h]
  __int64 v7[4]; // [rsp+28h] [rbp-30h]

  v6 = a2;
  v3 = a1;
  v4 = a3;
  sub_14000391C(v7, a1 + 4136);
  LODWORD(v3) = sub_140004960(v3 + 8, &v6, v4);
  sub_140003B34(v7);
  return (unsigned int)v3;
}

//----- (0000000140003570) ----------------------------------------------------
__int64 __fastcall sub_140003570(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v4; // [rsp+20h] [rbp-38h]
  __int64 v5[4]; // [rsp+28h] [rbp-30h]

  v4 = a2;
  v2 = a1;
  sub_14000391C(v5, a1 + 4136);
  sub_1400041E0(v2 + 8, &v4);
  return sub_140003B34(v5);
}

//----- (00000001400035D0) ----------------------------------------------------
__int64 __fastcall sub_1400035D0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v3[4]; // [rsp+20h] [rbp-38h]

  v1 = a1;
  sub_14000391C(v3, a1 + 4136);
  sub_140003D20((struct _LIST_ENTRY *)(v1 + 8));
  return sub_140003B34(v3);
}

//----- (0000000140003620) ----------------------------------------------------
char __fastcall sub_140003620(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v4; // [rsp+20h] [rbp-38h]
  __int64 v5[4]; // [rsp+28h] [rbp-30h]

  v4 = a2;
  v2 = a1;
  sub_14000391C(v5, a1 + 4136);
  LOBYTE(v2) = sub_140004628(v2 + 8, &v4) != 0i64;
  sub_140003B34(v5);
  return v2;
}

//----- (0000000140003690) ----------------------------------------------------
void *__fastcall sub_140003690(_QWORD *a1, __int64 a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140003B08(a1, a2);
  if ( v2 & 1 )
    sub_140007714(v3);
  return v3;
}

//----- (00000001400036C4) ----------------------------------------------------
char __fastcall sub_1400036C4(__int64 a1, __int64 a2, UNICODE_STRING *a3)
{
  __int64 v3; // rdi
  UNICODE_STRING *v4; // rbx
  __int64 v5; // rsi
  char v7; // [rsp+20h] [rbp-18h]

  v3 = a2;
  v4 = a3;
  v5 = a1;
  sub_14000388C((__int64)&v7, a1 + 4136, 0);
  LOBYTE(v4) = sub_140003780(v5, v3, v4);
  sub_140003AF8(&v7);
  return (char)v4;
}

//----- (000000014000371C) ----------------------------------------------------
char __fastcall sub_14000371C(__int64 a1, __int64 a2, _BYTE *a3)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  _BYTE *v5; // rsi
  __int64 v7[4]; // [rsp+20h] [rbp-48h]

  v3 = a2;
  v4 = a1;
  v5 = a3;
  sub_14000391C(v7, a1 + 4136);
  LOBYTE(v4) = sub_1400037D8(v4, v3, v5);
  sub_140003B34(v7);
  return v4;
}

//----- (0000000140003780) ----------------------------------------------------
bool __fastcall sub_140003780(__int64 a1, __int64 a2, UNICODE_STRING *a3)
{
  UNICODE_STRING *v3; // rbx
  _QWORD *v4; // rax
  __int64 v6; // [rsp+20h] [rbp-18h]

  v6 = a2;
  v3 = a3;
  v4 = sub_140004628(a1 + 8, &v6);
  return v4 && (signed int)sub_14000467C(v3, (__int64)v4) >= 0;
}

//----- (00000001400037D8) ----------------------------------------------------
bool __fastcall sub_1400037D8(__int64 a1, __int64 a2, _BYTE *a3)
{
  _BYTE *v3; // rbx
  _BYTE *v4; // rax
  __int64 v6; // [rsp+20h] [rbp-18h]

  v6 = a2;
  v3 = a3;
  v4 = sub_140004628(a1 + 8, &v6);
  return v4 && (signed int)sub_14000383C(v3, v4) >= 0;
}

//----- (0000000140003830) ----------------------------------------------------
__int64 __fastcall sub_140003830(_QWORD *a1, _QWORD *a2)
{
  *a1 = *a2;
  return 0i64;
}

//----- (000000014000383C) ----------------------------------------------------
__int64 __fastcall sub_14000383C(_BYTE *a1, _BYTE *a2)
{
  *a1 = *a2;
  return 0i64;
}

//----- (0000000140003844) ----------------------------------------------------
char __fastcall sub_140003844(__int64 a1, int *a2)
{
  signed __int64 v2; // rdi
  int *v3; // rsi
  _QWORD *i; // rbx
  char result; // al

  v2 = a1 + 4112;
  v3 = a2;
  for ( i = *(_QWORD **)(a1 + 4112); i != (_QWORD *)v2; i = (_QWORD *)*i )
    result = sub_140003C10(v3, i[2], (__int64)(i + 3));
  return result;
}

//----- (000000014000388C) ----------------------------------------------------
__int64 __fastcall sub_14000388C(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // rbx
  char v4; // al

  *(_BYTE *)a1 = a3;
  v3 = a1;
  *(_QWORD *)(a1 + 8) = a2;
  if ( a3 )
    v4 = ExAcquireSpinLockExclusive(a2);
  else
    v4 = ExAcquireSpinLockShared(a2);
  *(_BYTE *)(v3 + 1) = v4;
  return v3;
}
// 140004720: using guessed type __int64 __fastcall ExAcquireSpinLockExclusive(_QWORD);
// 140004728: using guessed type __int64 __fastcall ExAcquireSpinLockShared(_QWORD);

//----- (00000001400038BC) ----------------------------------------------------
_QWORD *__fastcall sub_1400038BC(__int64 a1)
{
  _QWORD *v1; // rbx

  v1 = (_QWORD *)a1;
  sub_1400039D8(a1);
  *v1 = off_140029F40;
  sub_140017EFC(v1 + 517);
  return v1;
}
// 140029F40: using guessed type __int64 (__fastcall *off_140029F40[5])();

//----- (00000001400038EC) ----------------------------------------------------
_QWORD *__fastcall sub_1400038EC(__int64 a1)
{
  _QWORD *v1; // rbx

  v1 = (_QWORD *)a1;
  sub_1400039B0(a1);
  *v1 = off_140029EF0;
  unknown_libname_3(v1 + 517);
  return v1;
}
// 140003A10: using guessed type __int64 __fastcall unknown_libname_3(_QWORD);
// 140029EF0: using guessed type __int64 (__fastcall *off_140029EF0[6])();

//----- (000000014000391C) ----------------------------------------------------
_QWORD *__fastcall sub_14000391C(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rbx

  *a1 = a2;
  v2 = a1;
  KeAcquireInStackQueuedSpinLock(a2, a1 + 1);
  return v2;
}
// 140017F4C: using guessed type __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD, _QWORD);

//----- (0000000140003940) ----------------------------------------------------
PLIST_ENTRY __fastcall sub_140003940(PLIST_ENTRY ListHead)
{
  PLIST_ENTRY v1; // rdi
  struct _LIST_ENTRY *v2; // rsi
  struct _LIST_ENTRY *v3; // rbx
  signed __int64 v4; // rbp

  v1 = ListHead;
  sub_14001E1C0((__m128 *)ListHead, 0, 0x1010ui64);
  v2 = v1 + 257;
  v2->Flink = 0i64;
  v3 = v1;
  v2->Blink = 0i64;
  v4 = 257i64;
  do
  {
    InitializeListHead(v3);
    ++v3;
    --v4;
  }
  while ( v4 );
  InitializeListHead(v1 + 257);
  return v1;
}

//----- (00000001400039B0) ----------------------------------------------------
__int64 __fastcall sub_1400039B0(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  *(_QWORD *)a1 = &off_140029EC8;
  sub_140003940((PLIST_ENTRY)(a1 + 8));
  return v1;
}
// 140029EC8: using guessed type __int64 (__fastcall *off_140029EC8)();

//----- (00000001400039D8) ----------------------------------------------------
__int64 __fastcall sub_1400039D8(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  *(_QWORD *)a1 = &off_140029F18;
  sub_140003940((PLIST_ENTRY)(a1 + 8));
  return v1;
}
// 140029F18: using guessed type __int64 (__fastcall *off_140029F18)();

//----- (0000000140003A1C) ----------------------------------------------------
__m128 *__fastcall sub_140003A1C(__m128 *a1)
{
  __m128 *v1; // rbx

  v1 = a1;
  sub_14001E1C0(a1, 0, 0x20ui64);
  v1[2].m128_u64[0] = 0i64;
  sub_140003AD0((__int64)&v1[2].m128_i64[1]);
  return v1;
}

//----- (0000000140003A48) ----------------------------------------------------
__m128 *__fastcall sub_140003A48(__m128 *a1)
{
  __m128 *v1; // rbx
  __m128 *result; // rax

  v1 = a1;
  sub_14001E1C0(a1, 0, 0x20ui64);
  v1[2].m128_u64[0] = 0i64;
  result = v1;
  v1[2].m128_i8[8] = 0;
  return result;
}

//----- (0000000140003A70) ----------------------------------------------------
struct _NPAGED_LOOKASIDE_LIST *__fastcall sub_140003A70(struct _NPAGED_LOOKASIDE_LIST *a1, SIZE_T a2, ULONG a3)
{
  struct _NPAGED_LOOKASIDE_LIST *v3; // rbx

  v3 = a1;
  sub_140004D28(a1, 0i64, 0i64, 0, a2, a3, 0);
  return v3;
}

//----- (0000000140003AA0) ----------------------------------------------------
__int64 __fastcall sub_140003AA0(__int64 a1, int a2)
{
  int v2; // ebx
  __int64 v3; // rdi

  v2 = a2;
  v3 = a1;
  ((void (*)(void))unknown_libname_2)();
  unknown_libname_2(v3 + 16);
  *(_DWORD *)(v3 + 32) = v2;
  return v3;
}
// 140003A00: using guessed type __int64 __fastcall unknown_libname_2(_QWORD);

//----- (0000000140003AD0) ----------------------------------------------------
__int64 __fastcall sub_140003AD0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 result; // rax

  v1 = a1;
  unknown_libname_2(a1);
  unknown_libname_2(v1 + 16);
  result = v1;
  *(_DWORD *)(v1 + 32) = 1;
  return result;
}
// 140003A00: using guessed type __int64 __fastcall unknown_libname_2(_QWORD);

//----- (0000000140003AF8) ----------------------------------------------------
__int64 __fastcall sub_140003AF8(char *a1)
{
  char v1; // r8
  char v2; // dl
  __int64 v3; // rcx
  __int64 result; // rax

  v1 = a1[1];
  v2 = *a1;
  v3 = *((_QWORD *)a1 + 1);
  if ( v2 )
    result = ExReleaseSpinLockExclusive(v3);
  else
    result = ExReleaseSpinLockShared(v3);
  return result;
}
// 1400291D8: using guessed type __int64 __fastcall ExReleaseSpinLockShared(_QWORD);
// 1400291E8: using guessed type __int64 __fastcall ExReleaseSpinLockExclusive(_QWORD);

//----- (0000000140003B08) ----------------------------------------------------
__int64 __fastcall sub_140003B08(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  nullsub_1(a1 + 517, a2);
  return sub_140003B64(v2);
}
// 140004C90: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);

//----- (0000000140003B34) ----------------------------------------------------
__int64 __fastcall sub_140003B34(__int64 *a1)
{
  signed __int64 v1; // rdx
  __int64 v2; // rcx

  v1 = (signed __int64)(a1 + 1);
  v2 = *a1;
  return KeReleaseInStackQueuedSpinLock(v1);
}
// 1400292F0: using guessed type __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD);

//----- (0000000140003B50) ----------------------------------------------------
__int64 __fastcall sub_140003B50(_QWORD *a1)
{
  *a1 = &off_140029EC8;
  return sub_140003B40(a1 + 1);
}
// 140003B40: using guessed type __int64 __fastcall sub_140003B40(_QWORD);
// 140029EC8: using guessed type __int64 (__fastcall *off_140029EC8)();

//----- (0000000140003B64) ----------------------------------------------------
__int64 __fastcall sub_140003B64(_QWORD *a1)
{
  *a1 = &off_140029F18;
  return sub_140003B48(a1 + 1);
}
// 140003B48: using guessed type __int64 __fastcall sub_140003B48(_QWORD);
// 140029F18: using guessed type __int64 (__fastcall *off_140029F18)();

//----- (0000000140003B78) ----------------------------------------------------
void __fastcall sub_140003B78(__int64 a1)
{
  sub_140004A9C(a1, 0, 0, 0i64);
}

//----- (0000000140003B88) ----------------------------------------------------
void __fastcall sub_140003B88(__int64 a1)
{
  sub_140003B9C(a1 + 40);
}

//----- (0000000140003B9C) ----------------------------------------------------
void __fastcall sub_140003B9C(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  sub_140003B78(a1 + 16);
  sub_140003B78(v1);
}

//----- (0000000140003BBC) ----------------------------------------------------
__int64 __fastcall sub_140003BBC(__int64 a1)
{
  __int64 result; // rax

  if ( a1 == 80 )
    result = sub_140003C60(&stru_140034240);
  else
    result = 0i64;
  return result;
}
// 140003C60: using guessed type __int64 __fastcall sub_140003C60(_QWORD);

//----- (0000000140003BD4) ----------------------------------------------------
__int64 __fastcall sub_140003BD4(__int64 a1)
{
  __int64 result; // rax

  if ( a1 == 48 )
    result = sub_140003C60(&stru_1400341C0);
  else
    result = 0i64;
  return result;
}
// 140003C60: using guessed type __int64 __fastcall sub_140003C60(_QWORD);

//----- (0000000140003BEC) ----------------------------------------------------
PSLIST_ENTRY __fastcall sub_140003BEC(struct _SLIST_ENTRY *a1)
{
  return sub_14000424C(&stru_140034240.L.ListHead, a1);
}

//----- (0000000140003BFC) ----------------------------------------------------
PSLIST_ENTRY __fastcall sub_140003BFC(struct _SLIST_ENTRY *a1)
{
  return sub_14000424C(&stru_1400341C0.L.ListHead, a1);
}

//----- (0000000140003C0C) ----------------------------------------------------
__int64 __fastcall sub_140003C0C(__int64 a1)
{
  return a1;
}

//----- (0000000140003C10) ----------------------------------------------------
char __fastcall sub_140003C10(int *a1, __int64 a2, __int64 a3)
{
  return sub_140004AEC(a3, *a1);
}

//----- (0000000140003C1C) ----------------------------------------------------
struct _SLIST_ENTRY *__fastcall sub_140003C1C(__int64 a1, char a2)
{
  char v2; // di
  struct _SLIST_ENTRY *v3; // rbx

  v2 = a2;
  v3 = (struct _SLIST_ENTRY *)a1;
  sub_140003B88(a1);
  if ( v2 & 1 )
  {
    if ( v2 & 4 )
      nullsub_1(v3, 80i64);
    else
      sub_140003BEC(v3);
  }
  return v3;
}
// 140004C90: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);

//----- (0000000140003C68) ----------------------------------------------------
signed __int64 __fastcall sub_140003C68(__int64 a1, unsigned __int16 a2)
{
  __int16 v2; // bx
  __int64 v3; // rdi
  PVOID v4; // rax

  v2 = a2;
  v3 = a1;
  v4 = ExAllocatePoolWithTag((POOL_TYPE)512, a2, 0x53554349u);
  if ( !v4 )
    return 3221225626i64;
  sub_140004A9C(v3, 0, v2, (__int64)v4);
  return 0i64;
}

//----- (0000000140003CB8) ----------------------------------------------------
void __fastcall sub_140003CB8(struct _LIST_ENTRY *a1)
{
  struct _LIST_ENTRY *v1; // rdi
  __int64 **v2; // rbx
  signed __int64 v3; // rsi
  __int64 *v4; // rax

  v1 = a1;
  v2 = (__int64 **)a1;
  v3 = 257i64;
  do
  {
    while ( !(unsigned __int8)IsListEmpty(v2) )
    {
      v4 = sub_140004F48(v2);
      if ( v4 )
        sub_140003C1C((__int64)v4, 1);
    }
    v2 += 2;
    --v3;
  }
  while ( v3 );
  InitializeListHead(v1 + 257);
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);

//----- (0000000140003D20) ----------------------------------------------------
void __fastcall sub_140003D20(struct _LIST_ENTRY *a1)
{
  struct _LIST_ENTRY *v1; // rdi
  __int64 **v2; // rbx
  signed __int64 v3; // rsi
  __int64 *v4; // rax

  v1 = a1;
  v2 = (__int64 **)a1;
  v3 = 257i64;
  do
  {
    while ( !(unsigned __int8)IsListEmpty(v2) )
    {
      v4 = sub_140004F48(v2);
      sub_140003BFC((struct _SLIST_ENTRY *)v4);
    }
    v2 += 2;
    --v3;
  }
  while ( v3 );
  InitializeListHead(v1 + 257);
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);

//----- (0000000140003D80) ----------------------------------------------------
__int64 __fastcall sub_140003D80(int a1)
{
  void *v1; // rax

  v1 = sub_14000458C(a1);
  return sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v1 + 24i64));
}

//----- (0000000140003DA4) ----------------------------------------------------
__int64 __fastcall sub_140003DA4(PUNICODE_STRING DestinationString, PCUNICODE_STRING SourceString)
{
  const UNICODE_STRING *v2; // rbx
  UNICODE_STRING *v3; // rdi
  __int64 result; // rax

  v2 = SourceString;
  v3 = DestinationString;
  if ( !SourceString )
    return 3221225485i64;
  result = sub_140003C68((__int64)DestinationString, SourceString->MaximumLength);
  if ( (signed int)result >= 0 )
  {
    RtlCopyUnicodeString(v3, v2);
    result = 0i64;
  }
  return result;
}

//----- (0000000140003DE8) ----------------------------------------------------
__int64 __fastcall sub_140003DE8(int a1, __int64 a2, __int64 a3, int a4, UNICODE_STRING *a5)
{
  __int64 v5; // rbx
  int v6; // ebp
  unsigned int v7; // esi
  int v8; // er15
  __int64 v9; // rdi
  __m128i *v10; // rbx
  const UNICODE_STRING *v11; // rax
  void *v12; // rax
  int v13; // eax
  UNICODE_STRING DestinationString; // [rsp+30h] [rbp-68h]

  v5 = a2;
  v6 = a1;
  v7 = 1;
  v8 = a4;
  v9 = a3;
  sub_140003AA0((__int64)&DestinationString, 1);
  v10 = (__m128i *)sub_140003C0C(v5);
  v11 = (const UNICODE_STRING *)sub_140003C0C(v9);
  if ( (signed int)sub_140004A64(&DestinationString, (PCUNICODE_STRING)v10, v11) >= 0 )
  {
    if ( sub_140002950(v10, v8) )
      sub_140004A60((__int64)&DestinationString, 0);
    v12 = sub_14000458C(v8);
    if ( (signed int)sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v12 + 8i64)) < 0 )
      sub_140002E58(
        L"CreateExclusionRecordForPid: Failed to create or update record collection for PID:.",
        0,
        v6,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\processexclusions.cpp",
        70);
    if ( a5 )
    {
      v13 = sub_140004264(&DestinationString, a5);
      if ( v13 < 0 )
        sub_140002E58(
          L"CreateExclusionRecordForPid: Failed to get unicode string from record:.",
          0,
          v13,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\processexclusions.cpp",
          78);
    }
    v7 = sub_140004260((__int64)&DestinationString);
  }
  else
  {
    sub_140002E58(
      L"CreateExclusionRecordForPid: Failed to set the filename in the process exclusion record for PID:",
      0,
      v6,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\processexclusions.cpp",
      55);
  }
  sub_140003B9C((__int64)&DestinationString);
  return v7;
}
// 14001ED60: using guessed type wchar_t aCreateexclusio_0[97];
// 14001EE30: using guessed type wchar_t aCreateexclusio_1[84];
// 14001EEE0: using guessed type wchar_t aCreateexclusio_2[72];

//----- (0000000140003F40) ----------------------------------------------------
__int64 __fastcall sub_140003F40(__int64 a1, int a2, UNICODE_STRING *a3)
{
  __int64 v3; // rbx
  UNICODE_STRING *v4; // rsi
  int v5; // edi
  unsigned int v6; // ebx
  char v8; // [rsp+30h] [rbp-48h]
  char v9; // [rsp+40h] [rbp-38h]

  v3 = a1;
  v4 = a3;
  v5 = a2;
  unknown_libname_2(&v9);
  unknown_libname_2(&v8);
  if ( (signed int)sub_140004270(v3, (UNICODE_STRING *)&v9, (UNICODE_STRING *)&v8) >= 0 )
  {
    v6 = sub_140003DE8(v3, (__int64)&v9, (__int64)&v8, v5, v4);
  }
  else
  {
    sub_140002E58(
      L"CreateExclusionRecordForPid: Unable to get the process image name from the PID.",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\processexclusions.cpp",
      97);
    v6 = 1;
  }
  sub_140003B78((__int64)&v8);
  sub_140003B78((__int64)&v9);
  return v6;
}
// 140003A00: using guessed type __int64 __fastcall unknown_libname_2(_QWORD);
// 14001EF70: using guessed type wchar_t aCreateexclusio[80];

//----- (0000000140003FF8) ----------------------------------------------------
void sub_140003FF8()
{
  __int64 (*v0)(void); // rax
  UNICODE_STRING SystemRoutineName; // [rsp+38h] [rbp-11h]
  __int128 v13; // [rsp+48h] [rbp-1h]
  __int128 v14; // [rsp+58h] [rbp+Fh]
  __int128 v15; // [rsp+68h] [rbp+1Fh]
  __int16 v16; // [rsp+78h] [rbp+2Fh]

  v16 = 0;
  v13 = xmmword_14001EC50;
  *(_DWORD *)&SystemRoutineName.Length = 3276848;
  v14 = xmmword_14001EC60;
  SystemRoutineName.Buffer = (PWSTR)&v13;
  v15 = xmmword_14001EC70;
  v0 = (__int64 (*)(void))MmGetSystemRoutineAddress(&SystemRoutineName);
  if ( v0 )
    (unsigned int)sub_14001E1B0(v0) != -1073741820;
}
// 14001EC50: using guessed type __int128 xmmword_14001EC50;
// 14001EC60: using guessed type __int128 xmmword_14001EC60;
// 14001EC70: using guessed type __int128 xmmword_14001EC70;

//----- (0000000140004170) ----------------------------------------------------
struct _SLIST_ENTRY *__fastcall sub_140004170(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  unsigned int v4; // eax
  struct _SLIST_ENTRY *result; // rax
  struct _SLIST_ENTRY *v6; // rbx

  v2 = a1;
  v3 = a2;
  v4 = sub_1400046D0(*a2);
  result = (struct _SLIST_ENTRY *)sub_1400046D8(v2, v4 % 0x101, v3);
  v6 = result;
  if ( result )
  {
    sub_140004F14(&result[1].Next);
    sub_140004F14(v6);
    result = sub_140003C1C((__int64)v6, 1);
  }
  return result;
}
// 1400046D0: using guessed type __int64 __fastcall sub_1400046D0(_QWORD);

//----- (00000001400041E0) ----------------------------------------------------
PSLIST_ENTRY __fastcall sub_1400041E0(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  unsigned int v4; // eax
  PSLIST_ENTRY result; // rax
  struct _SLIST_ENTRY *v6; // rbx

  v2 = a1;
  v3 = a2;
  v4 = sub_1400046D0(*a2);
  result = (PSLIST_ENTRY)sub_1400046D8(v2, v4 % 0x101, v3);
  v6 = result;
  if ( result )
  {
    sub_140004F14(&result[1].Next);
    sub_140004F14(v6);
    result = sub_140003BFC(v6);
  }
  return result;
}
// 1400046D0: using guessed type __int64 __fastcall sub_1400046D0(_QWORD);

//----- (000000014000424C) ----------------------------------------------------
PSLIST_ENTRY __fastcall sub_14000424C(struct _SLIST_HEADER *a1, struct _SLIST_ENTRY *a2)
{
  PSLIST_ENTRY result; // rax

  if ( a2 )
    result = sub_140004CE0(a1, a2);
  return result;
}

//----- (0000000140004260) ----------------------------------------------------
__int64 __fastcall sub_140004260(__int64 a1)
{
  return *(unsigned int *)(a1 + 32);
}

//----- (0000000140004264) ----------------------------------------------------
__int64 __fastcall sub_140004264(const UNICODE_STRING *a1, UNICODE_STRING *a2)
{
  return sub_1400045A0(a1 + 1, a2);
}

//----- (0000000140004270) ----------------------------------------------------
signed __int64 __fastcall sub_140004270(__int64 a1, UNICODE_STRING *a2, UNICODE_STRING *a3)
{
  UNICODE_STRING *v3; // r15
  UNICODE_STRING *v4; // r14
  __int64 v5; // rsi
  UNICODE_STRING *v6; // rbx
  signed __int64 result; // rax
  int v8; // eax
  signed int v9; // edi
  NTSTATUS v10; // ebx
  HANDLE FileHandle; // [rsp+68h] [rbp-41h]
  PVOID Object; // [rsp+70h] [rbp-39h]
  PVOID P; // [rsp+78h] [rbp-31h]
  OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+80h] [rbp-29h]
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+B0h] [rbp+7h]

  v3 = a2;
  v4 = a3;
  v5 = a1;
  v6 = (UNICODE_STRING *)ExAllocatePoolWithTag((POOL_TYPE)512, 0x200ui64, 0x45504349u);
  if ( !v6 )
  {
    sub_140002E58(
      L"GetProcessImageFileNameFromProcessHandle: Failed to allocate memory.",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\processexclusionutils.h",
      46);
    return 3221225626i64;
  }
  v8 = sub_140005154(v5);
  v9 = v8;
  if ( v8 < 0 )
  {
    if ( v8 == -1073741820 )
    {
      ExFreePoolWithTag(v6, 0);
      v6 = (UNICODE_STRING *)ExAllocatePoolWithTag((POOL_TYPE)512, 0i64, 0x45504349u);
      if ( !v6 )
      {
        sub_140002E58(
          L"GetProcessImageFileNameFromProcessHandle: Failed to allocate memory.",
          0,
          0,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\processexclusionutils.h",
          61);
        return 3221225626i64;
      }
      v9 = sub_140005154(v5);
    }
    if ( v9 < 0 )
    {
      sub_140002E58(
        L"GetProcessImageFileNameFromProcessHandle: Failed to get the process image file name.",
        0,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\processexclusionutils.h",
        71);
LABEL_11:
      ExFreePoolWithTag(v6, 0);
      return (unsigned int)v9;
    }
  }
  if ( v6->Buffer && v6->MaximumLength )
  {
    v9 = sub_140003DA4(v4, v6);
    if ( v9 < 0 )
    {
      sub_140002E58(
        L"GetProcessImageFileNameFromProcessHandle: Failed to set native file name.",
        0,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\processexclusionutils.h",
        87);
      goto LABEL_11;
    }
    FileHandle = 0i64;
    Object = 0i64;
    ObjectAttributes.Length = 48;
    ObjectAttributes.RootDirectory = 0i64;
    ObjectAttributes.Attributes = 576;
    ObjectAttributes.ObjectName = v6;
    _mm_storeu_si128((__m128i *)&ObjectAttributes.SecurityDescriptor, (__m128i)0i64);
    v9 = ZwCreateFile(&FileHandle, 0x80u, &ObjectAttributes, &IoStatusBlock, 0i64, 0x80u, 7u, 1u, 0x140u, 0i64, 0);
    ExFreePoolWithTag(v6, 0);
    if ( v9 < 0 || v9 == 264 )
    {
      sub_140002E58(
        L"GetProcessImageFileNameFromProcessHandle: Failed to open the executable file for the process.",
        0,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\processexclusionutils.h",
        105);
      return (unsigned int)v9;
    }
    v10 = ObReferenceObjectByHandle(FileHandle, 0x80u, 0i64, 0, &Object, 0i64);
    if ( v10 < 0 )
    {
      ZwClose(FileHandle);
      sub_140002E58(
        L"GetProcessImageFileNameFromProcessHandle: Failed to open reference file object.",
        0,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\processexclusionutils.h",
        113);
      return (unsigned int)v10;
    }
    P = 0i64;
    v10 = IoQueryFileDosDeviceName(Object, &P);
    ZwClose(FileHandle);
    ObfDereferenceObject(Object);
    if ( v10 < 0 )
    {
      sub_140002E58(
        L"GetProcessImageFileNameFromProcessHandle: Failed to query the dos device name for the process.",
        0,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\processexclusionutils.h",
        124);
      return (unsigned int)v10;
    }
    v10 = sub_140003DA4(v3, (PCUNICODE_STRING)P);
    ExFreePoolWithTag(P, 0);
    if ( v10 < 0 )
    {
      sub_140002E58(
        L"GetProcessImageFileNameFromProcessHandle: Failed to copy the filename.",
        0,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\processexclusionutils.h",
        132);
      return (unsigned int)v10;
    }
    result = 0i64;
  }
  else
  {
    sub_140002E58(
      L"GetProcessImageFileNameFromProcessHandle: Process image file name is empty.",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\processexclusionutils.h",
      79);
    ExFreePoolWithTag(v6, 0);
    result = 3221225473i64;
  }
  return result;
}
// 14001E720: using guessed type wchar_t aGetprocessimag_2[69];
// 14001E7B0: using guessed type wchar_t aGetprocessimag_3[85];
// 14001E860: using guessed type wchar_t aGetprocessimag_6[76];
// 14001E900: using guessed type wchar_t aGetprocessimag_4[74];
// 14001E9A0: using guessed type wchar_t aGetprocessimag_5[94];
// 14001EA60: using guessed type wchar_t aGetprocessimag[80];
// 14001EB00: using guessed type wchar_t aGetprocessimag_0[95];
// 14001EBC0: using guessed type wchar_t aGetprocessimag_1[71];
// 140029250: using guessed type __int64 __fastcall IoQueryFileDosDeviceName(_QWORD, _QWORD);

//----- (000000014000458C) ----------------------------------------------------
void *__fastcall sub_14000458C(int a1)
{
  void *result; // rax

  result = &unk_140031930;
  if ( a1 != 1 )
    result = &unk_140030900;
  return result;
}

//----- (00000001400045A0) ----------------------------------------------------
__int64 __fastcall sub_1400045A0(PCUNICODE_STRING SourceString, PUNICODE_STRING DestinationString)
{
  PUNICODE_STRING v2; // rbx
  PCUNICODE_STRING v3; // rdi
  WCHAR *v5; // rax

  v2 = DestinationString;
  v3 = SourceString;
  if ( !DestinationString || DestinationString->Buffer )
    return 3221225485i64;
  if ( (unsigned int)sub_140004704((__int64)SourceString) )
    return 3221225473i64;
  v5 = (WCHAR *)ExAllocatePoolWithTag((POOL_TYPE)512, v3->MaximumLength, 0x53554349u);
  if ( !v5 )
    return 3221225626i64;
  v2->Buffer = v5;
  v2->Length = 0;
  v2->MaximumLength = v3->MaximumLength;
  RtlCopyUnicodeString(v2, v3);
  return 0i64;
}

//----- (0000000140004628) ----------------------------------------------------
_QWORD *__fastcall sub_140004628(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  unsigned int v4; // eax
  _QWORD *result; // rax

  v2 = a1;
  v3 = a2;
  v4 = sub_1400046D0(*a2);
  result = sub_1400046D8(v2, v4 % 0x101, v3);
  if ( result )
    result += 5;
  return result;
}
// 1400046D0: using guessed type __int64 __fastcall sub_1400046D0(_QWORD);

//----- (000000014000467C) ----------------------------------------------------
__int64 __fastcall sub_14000467C(PUNICODE_STRING DestinationString, __int64 a2)
{
  PUNICODE_STRING v2; // rdi
  __int64 v3; // rbx
  const UNICODE_STRING *v4; // rax
  __int64 result; // rax
  const UNICODE_STRING *v6; // rax

  v2 = DestinationString;
  v3 = a2;
  v4 = (const UNICODE_STRING *)sub_140003C0C(a2);
  result = sub_140003DA4(v2, v4);
  if ( (signed int)result >= 0 )
  {
    v6 = (const UNICODE_STRING *)sub_140003C0C(v3 + 16);
    result = sub_140003DA4(v2 + 1, v6);
    if ( (signed int)result >= 0 )
    {
      *(_DWORD *)&v2[2].Length = *(_DWORD *)(v3 + 32);
      result = 0i64;
    }
  }
  return result;
}

//----- (00000001400046D8) ----------------------------------------------------
_QWORD *__fastcall sub_1400046D8(__int64 a1, unsigned int a2, _QWORD *a3)
{
  _QWORD *v3; // rdx
  _QWORD *i; // rcx

  v3 = (_QWORD *)(a1 + 16i64 * a2);
  for ( i = (_QWORD *)*v3; ; i = (_QWORD *)*i )
  {
    if ( i == v3 || !i )
      return 0i64;
    if ( i[4] == *a3 )
      break;
  }
  return i;
}

//----- (0000000140004704) ----------------------------------------------------
signed __int64 __fastcall sub_140004704(__int64 a1)
{
  signed __int64 result; // rax

  result = 0i64;
  if ( !*(_QWORD *)(a1 + 8) || !*(_WORD *)a1 || !*(_WORD *)(a1 + 2) )
    result = 1i64;
  return result;
}

//----- (0000000140004730) ----------------------------------------------------
void __fastcall sub_140004730(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // rbx
  void *v4; // rax
  void *v5; // rax
  char v6; // [rsp+30h] [rbp-38h]
  char v7; // [rsp+40h] [rbp-28h]

  v3 = a2;
  if ( a3 )
  {
    unknown_libname_2(&v6);
    unknown_libname_2(&v7);
    if ( (signed int)sub_140004270(v3, (UNICODE_STRING *)&v6, (UNICODE_STRING *)&v7) < 0 )
    {
      sub_140002E58(
        L"ProcExclusionProcessNotificationCallback: Unable to get the process image name from the PID.",
        0,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\processexclusions.cpp",
        167);
    }
    else
    {
      sub_140003DE8(v3, (__int64)&v6, (__int64)&v7, 1, 0i64);
      sub_140003DE8(v3, (__int64)&v6, (__int64)&v7, 0, 0i64);
    }
    sub_140004BF8(v3, (__int64)&v6);
    sub_140003B78((__int64)&v7);
    sub_140003B78((__int64)&v6);
  }
  else
  {
    v4 = sub_14000458C(0);
    sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v4 + 16i64));
    v5 = sub_14000458C(1);
    sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v5 + 16i64));
    sub_140003570((__int64)&unk_140032960, v3);
  }
}
// 140003A00: using guessed type __int64 __fastcall unknown_libname_2(_QWORD);
// 14001F220: using guessed type wchar_t aProcexclusionp[93];

//----- (0000000140004858) ----------------------------------------------------
__int64 __fastcall sub_140004858(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rbp
  _QWORD *v5; // rdi
  unsigned int v6; // eax
  unsigned int v7; // er14
  _QWORD *v8; // rax
  __m128 *v9; // rax
  __m128 *v10; // rbx
  __int64 result; // rax
  signed int v12; // edi

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v6 = sub_1400046D0(*a2);
  v7 = v6 % 0x101;
  v8 = sub_1400046D8(v3, v6 % 0x101, v5);
  if ( v8 )
  {
    result = sub_14000467C((PUNICODE_STRING)(v8 + 5), v4);
    if ( (signed int)result < 0 )
      return result;
  }
  else
  {
    v9 = (__m128 *)sub_140003BBC(80i64);
    if ( v9 )
      v10 = sub_140003A1C(v9);
    else
      v10 = 0i64;
    if ( !v10 )
      return 3221225626i64;
    v12 = sub_140003830((__m128 *)v10[2].m128_u64, v5);
    if ( v12 < 0 || (v12 = sub_14000467C((PUNICODE_STRING)&v10[2].m128_u16[4], v4), v12 < 0) )
    {
      sub_140003C1C((__int64)v10, 1);
      return (unsigned int)v12;
    }
    sub_140004DE4(v3 + 16i64 * v7, v10);
    sub_140004DE4(v3 + 4112, (__m128 *)v10[1].m128_u64);
  }
  return 0i64;
}
// 1400046D0: using guessed type __int64 __fastcall sub_1400046D0(_QWORD);

//----- (0000000140004960) ----------------------------------------------------
__int64 __fastcall sub_140004960(__int64 a1, _QWORD *a2, _BYTE *a3)
{
  __int64 v3; // rsi
  _BYTE *v4; // rbp
  _QWORD *v5; // rdi
  unsigned int v6; // eax
  unsigned int v7; // er14
  _QWORD *v8; // rax
  __m128 *v9; // rax
  __m128 *v10; // rbx
  __int64 result; // rax
  signed int v12; // edi

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v6 = sub_1400046D0(*a2);
  v7 = v6 % 0x101;
  v8 = sub_1400046D8(v3, v6 % 0x101, v5);
  if ( v8 )
  {
    result = sub_14000383C((_BYTE *)v8 + 40, v4);
    if ( (signed int)result < 0 )
      return result;
  }
  else
  {
    v9 = (__m128 *)sub_140003BD4(48i64);
    if ( v9 )
      v10 = sub_140003A48(v9);
    else
      v10 = 0i64;
    if ( !v10 )
      return 3221225626i64;
    v12 = sub_140003830((__m128 *)v10[2].m128_u64, v5);
    if ( v12 < 0 || (v12 = sub_14000383C(&v10[2].m128_i8[8], v4), v12 < 0) )
    {
      sub_140003BFC((struct _SLIST_ENTRY *)v10);
      return (unsigned int)v12;
    }
    sub_140004DE4(v3 + 16i64 * v7, v10);
    sub_140004DE4(v3 + 4112, (__m128 *)v10[1].m128_u64);
  }
  return 0i64;
}
// 1400046D0: using guessed type __int64 __fastcall sub_1400046D0(_QWORD);

//----- (0000000140004A60) ----------------------------------------------------
void __fastcall sub_140004A60(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 32) = a2;
}

//----- (0000000140004A64) ----------------------------------------------------
__int64 __fastcall sub_140004A64(PUNICODE_STRING DestinationString, PCUNICODE_STRING SourceString, PCUNICODE_STRING a3)
{
  const UNICODE_STRING *v3; // rdi
  UNICODE_STRING *v4; // rbx
  __int64 result; // rax

  v3 = SourceString;
  v4 = DestinationString;
  result = sub_140003DA4(DestinationString + 1, a3);
  if ( (signed int)result >= 0 )
    result = sub_140003DA4(v4, v3);
  return result;
}

//----- (0000000140004A9C) ----------------------------------------------------
void __fastcall sub_140004A9C(__int64 a1, __int16 a2, __int16 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  void *v6; // rcx

  v4 = a1;
  *(_WORD *)a1 = a2;
  *(_WORD *)(a1 + 2) = a3;
  v5 = a4;
  v6 = *(void **)(a1 + 8);
  if ( v6 )
    ExFreePoolWithTag(v6, 0);
  *(_QWORD *)(v4 + 8) = v5;
}

//----- (0000000140004AEC) ----------------------------------------------------
char __fastcall sub_140004AEC(__int64 a1, int a2)
{
  int v2; // ebx
  __int64 v3; // rdi
  __m128i *v4; // rax
  char result; // al

  v2 = a2;
  v3 = a1;
  v4 = (__m128i *)sub_140003C0C(a1);
  result = sub_140002950(v4, v2);
  *(_DWORD *)(v3 + 32) = result == 0;
  return result;
}

//----- (0000000140004B20) ----------------------------------------------------
__int64 __fastcall sub_140004B20(__int64 a1, int a2)
{
  __int64 v2; // rbx
  char v4; // [rsp+20h] [rbp-18h]
  int v5; // [rsp+48h] [rbp+10h]

  v5 = a2;
  v2 = a1;
  sub_14000388C((__int64)&v4, a1 + 4136, 1);
  sub_140003844(v2 + 8, &v5);
  return sub_140003AF8(&v4);
}

//----- (0000000140004B60) ----------------------------------------------------
void __fastcall sub_140004B60(__int64 a1)
{
  __int64 v1; // rbx
  char v2; // [rsp+30h] [rbp-38h]
  char v3; // [rsp+40h] [rbp-28h]

  v1 = a1;
  unknown_libname_2(&v2);
  unknown_libname_2(&v3);
  if ( (signed int)sub_140004270(v1, (UNICODE_STRING *)&v2, (UNICODE_STRING *)&v3) < 0 )
    sub_140002E58(
      L"UpdateFallbackSophosProcessExclusions: Unable to get the process image name from the PID.",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\processexclusions.cpp",
      146);
  else
    sub_140004BF8(v1, (__int64)&v2);
  sub_140003B78((__int64)&v3);
  sub_140003B78((__int64)&v2);
}
// 140003A00: using guessed type __int64 __fastcall unknown_libname_2(_QWORD);
// 14001F160: using guessed type wchar_t aUpdatefallback[90];

//----- (0000000140004BF8) ----------------------------------------------------
char __fastcall sub_140004BF8(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  int v4; // eax
  __m128i *v5; // rax
  int v6; // eax
  char v8; // [rsp+50h] [rbp+18h]

  v2 = a2;
  v3 = a1;
  LOBYTE(v4) = sub_140019690();
  if ( !(_BYTE)v4 )
  {
    v4 = sub_140004704(v2);
    if ( !v4 )
    {
      v5 = (__m128i *)sub_140003C0C(v2);
      LOBYTE(v4) = sub_140002838(v5);
      if ( (_BYTE)v4 )
      {
        v6 = sub_140003500((__int64)&unk_140032960, v3, &v8);
        if ( v6 >= 0 )
          LOBYTE(v4) = sub_140002DD4(
                         L"UpdateFallbackSophosProcessExclusions: Added exclusion for Sophos process",
                         v3,
                         0i64,
                         (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\processexclusions.cpp",
                         130);
        else
          LOBYTE(v4) = sub_140002E58(
                         L"UpdateFallbackSophosProcessExclusions: Failed to create or update record for PID",
                         v6,
                         v3,
                         (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\processexclusions.cpp",
                         126);
      }
    }
  }
  return v4;
}
// 14001F010: using guessed type wchar_t aUpdatefallback_0[81];
// 14001F0C0: using guessed type wchar_t aUpdatefallback_1[74];

//----- (0000000140004C94) ----------------------------------------------------
__int64 __fastcall sub_140004C94(int a1)
{
  void *v1; // rax
  int v2; // edx

  v1 = sub_14000458C(a1);
  return sub_140004B20((__int64)v1, v2);
}

//----- (0000000140004CAC) ----------------------------------------------------
__int64 __fastcall sub_140004CAC(__int64 a1)
{
  __int64 v1; // rbx
  __int64 result; // rax
  __int64 v3; // rdx
  __int64 v4; // r8
  __int64 v5; // rcx

  ++*(_DWORD *)(a1 + 20);
  v1 = a1;
  result = (__int64)ExpInterlockedPopEntrySList((PSLIST_HEADER)a1);
  if ( !result )
  {
    ++*(_DWORD *)(v1 + 24);
    v3 = *(unsigned int *)(v1 + 44);
    v4 = *(unsigned int *)(v1 + 40);
    v5 = *(unsigned int *)(v1 + 36);
    result = sub_14001E1B0(*(__int64 (**)(void))(v1 + 48));
  }
  return result;
}

//----- (0000000140004CE0) ----------------------------------------------------
PSLIST_ENTRY __fastcall sub_140004CE0(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
{
  struct _SLIST_ENTRY *v2; // rdi
  PSLIST_HEADER v3; // rbx

  ++HIDWORD(ListHead[1].Region);
  v2 = ListEntry;
  v3 = ListHead;
  if ( ExQueryDepthSList(ListHead) < LOWORD(ListHead[1].Alignment) )
    return ExpInterlockedPushEntrySList(v3, v2);
  ++LODWORD(v3[2].Alignment);
  return (PSLIST_ENTRY)sub_14001E1B0((__int64 (*)(void))v3[3].Region);
}

//----- (0000000140004D28) ----------------------------------------------------
void __fastcall sub_140004D28(struct _NPAGED_LOOKASIDE_LIST *a1, PVOID (__stdcall *a2)(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag), void (__stdcall *a3)(PVOID Buffer), int a4, SIZE_T a5, ULONG a6, USHORT a7)
{
  ExInitializeNPagedLookasideList(a1, a2, a3, a4 | 0x200, a5, a6, a7);
}

//----- (0000000140004D40) ----------------------------------------------------
void __noreturn sub_140004D40()
{
  RtlFailFast(3i64);
}
// 140004F74: using guessed type __int64 __fastcall RtlFailFast(_QWORD);

//----- (0000000140004D50) ----------------------------------------------------
__int64 __fastcall sub_140004D50(unsigned int a1)
{
  return a1;
}

//----- (0000000140004D54) ----------------------------------------------------
__int64 sub_140004D54()
{
  int v0; // eax
  unsigned int v1; // ebx
  __int64 result; // rax

  v0 = sub_140005034();
  v1 = v0;
  if ( v0 >= 0 )
  {
    sub_140003FF8();
    result = 0i64;
  }
  else
  {
    sub_140002E58(
      L"InitProcessExclusions: Call to ActivateProcessCreationAndTerminationFilter failed with status code: 0x.",
      0,
      v0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\processexclusions.cpp",
      197);
    result = v1;
  }
  return result;
}
// 14001F2E0: using guessed type wchar_t aInitprocessexc[104];

//----- (0000000140004DE4) ----------------------------------------------------
_QWORD *__fastcall sub_140004DE4(__int64 a1, _QWORD *a2)
{
  _QWORD *result; // rax

  result = *(_QWORD **)(a1 + 8);
  if ( *result != a1 )
    sub_140004D40();
  *a2 = a1;
  a2[1] = result;
  *result = a2;
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

//----- (0000000140004E14) ----------------------------------------------------
char __fastcall sub_140004E14(__int64 a1)
{
  __int64 v1; // rbx
  char result; // al
  char v3; // [rsp+38h] [rbp+10h]

  v1 = a1;
  if ( sub_140019714(a1) )
    result = 1;
  else
    result = sub_14000371C((__int64)&unk_140032960, v1, &v3);
  return result;
}

//----- (0000000140004E4C) ----------------------------------------------------
bool __fastcall sub_140004E4C(__int64 a1, UNICODE_STRING *a2, char a3, int a4)
{
  __int64 v4; // rbx
  int v5; // ebp
  char v6; // r14
  UNICODE_STRING *v7; // rsi
  void *v8; // rax
  bool v9; // di
  int v10; // ebx
  bool v11; // zf
  char v13; // [rsp+30h] [rbp-58h]

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  sub_140003AD0((__int64)&v13);
  v8 = sub_14000458C(v5);
  v9 = 0;
  if ( sub_1400036C4((__int64)v8, v4, (UNICODE_STRING *)&v13) )
  {
    v10 = sub_140004260((__int64)&v13);
    sub_140004264((const UNICODE_STRING *)&v13, v7);
    v11 = v10 == 0;
LABEL_5:
    v9 = v11;
    goto LABEL_6;
  }
  sub_140002E58(
    L"IsProcessExcluded: No process record found for PID",
    0,
    v4,
    (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\processexclusions.cpp",
    248);
  if ( v6 )
  {
    v11 = (unsigned int)sub_140003F40(v4, v5, v7) == 0;
    goto LABEL_5;
  }
LABEL_6:
  sub_140003B9C((__int64)&v13);
  return v9;
}
// 14001F3B0: using guessed type wchar_t aIsprocessexclu[51];

//----- (0000000140004F14) ----------------------------------------------------
bool __fastcall sub_140004F14(_QWORD *a1)
{
  _QWORD *v1; // r8
  _QWORD *v2; // rdx
  _QWORD *v3; // rcx

  v1 = (_QWORD *)*a1;
  v2 = a1;
  v3 = (_QWORD *)a1[1];
  if ( (_QWORD *)v1[1] != v2 || (_QWORD *)*v3 != v2 )
    sub_140004D40();
  *v3 = v1;
  v1[1] = v3;
  return v3 == v1;
}

//----- (0000000140004F48) ----------------------------------------------------
__int64 *__fastcall sub_140004F48(__int64 **a1)
{
  __int64 *v1; // rdx
  __int64 v2; // r8
  __int64 *result; // rax

  v1 = *a1;
  v2 = **a1;
  if ( (__int64 **)(*a1)[1] != a1 || *(__int64 **)(v2 + 8) != v1 )
    sub_140004D40();
  *a1 = (__int64 *)v2;
  result = v1;
  *(_QWORD *)(v2 + 8) = a1;
  return result;
}

//----- (0000000140004F7C) ----------------------------------------------------
__int64 sub_140004F7C()
{
  sub_140005078(4);
  sub_140003D80(1);
  sub_140003D80(0);
  return sub_1400035D0((__int64)&unk_140032960);
}

//----- (0000000140004FB0) ----------------------------------------------------
__int64 *sub_140004FB0()
{
  __int64 (**v0)(void); // rbx
  __int64 *result; // rax

  v0 = (__int64 (**)(void))qword_1400342C8;
  do
  {
    if ( *v0 )
      sub_14001E1B0(*v0);
    ++v0;
    result = &qword_1400342F0;
  }
  while ( (signed __int64)v0 < (signed __int64)&qword_1400342F0 );
  return result;
}
// 1400342F0: using guessed type __int64 qword_1400342F0;

//----- (0000000140005010) ----------------------------------------------------
char sub_140005010()
{
  _QWORD *v0; // rax

  v0 = qword_1400342C8;
  while ( !*v0 )
  {
    ++v0;
    if ( (signed __int64)v0 >= (signed __int64)&qword_1400342F0 )
      return 0;
  }
  return 1;
}
// 1400342F0: using guessed type __int64 qword_1400342F0;

//----- (0000000140005034) ----------------------------------------------------
__int64 sub_140005034()
{
  char v0; // al
  unsigned int v1; // er10
  __int64 v2; // rdx
  __int64 v3; // r9

  v0 = sub_140005010();
  qword_1400342C8[v3] = v2;
  if ( !v0 )
  {
    v1 = PsSetCreateProcessNotifyRoutine(sub_140004FB0, 0i64);
    byte_1400342C0 = (v1 & 0x80000000) == 0;
  }
  return v1;
}
// 140029258: using guessed type __int64 __fastcall PsSetCreateProcessNotifyRoutine(_QWORD, _QWORD);
// 1400342C0: using guessed type char byte_1400342C0;

//----- (0000000140005078) ----------------------------------------------------
char __fastcall sub_140005078(int a1)
{
  char result; // al
  __int64 v2; // rdx

  qword_1400342C8[a1] = 0i64;
  result = sub_140005010();
  if ( !result )
  {
    LOBYTE(v2) = 1;
    byte_1400342C0 = 0;
    result = PsSetCreateProcessNotifyRoutine(sub_140004FB0, v2);
  }
  return result;
}
// 140029258: using guessed type __int64 __fastcall PsSetCreateProcessNotifyRoutine(_QWORD, _QWORD);
// 1400342C0: using guessed type char byte_1400342C0;

//----- (00000001400050B8) ----------------------------------------------------
__int64 sub_1400050B8()
{
  __int64 (*v0)(void); // rax
  __int64 result; // rax
  UNICODE_STRING SystemRoutineName; // [rsp+30h] [rbp-48h]

  v0 = (__int64 (*)(void))qword_1400342F0;
  if ( qword_1400342F0
    || (*(_DWORD *)&SystemRoutineName.Length = 3407922,
        SystemRoutineName.Buffer = L"ZwQueryInformationProcess",
        v0 = (__int64 (*)(void))MmGetSystemRoutineAddress(&SystemRoutineName),
        (qword_1400342F0 = (__int64)v0) != 0) )
  {
    result = sub_14001E1B0(v0);
  }
  else
  {
    result = 3221225473i64;
  }
  return result;
}
// 14001F420: using guessed type wchar_t aZwqueryinforma[26];
// 1400342F0: using guessed type __int64 qword_1400342F0;

//----- (0000000140005154) ----------------------------------------------------
__int64 __fastcall sub_140005154(__int64 a1)
{
  __int64 result; // rax
  unsigned int v2; // ebx
  HANDLE Handle; // [rsp+30h] [rbp-19h]
  __int64 v4; // [rsp+38h] [rbp-11h]
  __int64 v5; // [rsp+40h] [rbp-9h]
  int v6; // [rsp+48h] [rbp-1h]
  __int64 v7; // [rsp+50h] [rbp+7h]
  __int64 v8; // [rsp+58h] [rbp+Fh]
  int v9; // [rsp+60h] [rbp+17h]
  __int128 v10; // [rsp+68h] [rbp+1Fh]

  v5 = 0i64;
  v7 = 0i64;
  v8 = 0i64;
  v4 = a1;
  v6 = 48;
  v9 = 512;
  _mm_storeu_si128((__m128i *)&v10, (__m128i)0i64);
  result = ZwOpenProcess(&Handle, 0i64, &v6, &v4);
  if ( (signed int)result >= 0 )
  {
    v2 = sub_1400050B8();
    ZwClose(Handle);
    result = v2;
  }
  return result;
}
// 140029260: using guessed type __int64 __fastcall ZwOpenProcess(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400051FC) ----------------------------------------------------
__int64 __fastcall sub_1400051FC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6, int a7, __int64 a8, __int64 a9, __m128i *a10, __m128i *a11, __m128i *a12)
{
  __int64 v12; // r15
  __int64 v13; // rbx
  __m128i *v14; // r14
  __int64 v15; // r12
  __m128i *v16; // rdi
  __m128i *v17; // rsi
  bool v18; // zf
  __m128i v19; // xmm0
  int v20; // eax
  __int64 v22; // [rsp+20h] [rbp-E0h]
  __int64 v23; // [rsp+28h] [rbp-D8h]
  char v24; // [rsp+30h] [rbp-D0h]
  __int64 v25; // [rsp+40h] [rbp-C0h]
  __int64 v26; // [rsp+48h] [rbp-B8h]
  __int64 v27; // [rsp+58h] [rbp-A8h]
  __int128 v28; // [rsp+70h] [rbp-90h]
  __int128 v29; // [rsp+80h] [rbp-80h]
  int v30; // [rsp+90h] [rbp-70h]
  int *v31; // [rsp+98h] [rbp-68h]
  int v32; // [rsp+A0h] [rbp-60h]
  __int64 v33; // [rsp+A8h] [rbp-58h]
  int v34; // [rsp+B0h] [rbp-50h]
  __int128 v35; // [rsp+B4h] [rbp-4Ch]

  v12 = a3;
  v13 = a8;
  v14 = a10;
  v15 = a4;
  v16 = a11;
  v17 = a12;
  v22 = a2;
  v23 = a1;
  sub_14001E1C0((__m128 *)&v24, 0, 0xC8ui64);
  if ( !v12 || !v13 || !v14 || !v16 )
    return 3221225473i64;
  v25 = v15;
  v26 = a5;
  v34 = a6;
  _mm_storeu_si128((__m128i *)&v28, *v14);
  if ( v17 )
    _mm_storeu_si128((__m128i *)&v35, *v17);
  v18 = *(_QWORD *)&a7 == 0i64;
  v19 = *v16;
  v20 = a9;
  v33 = v13;
  _mm_storeu_si128((__m128i *)&v29, v19);
  v32 = v20;
  if ( v18 )
  {
    v30 = 0;
  }
  else
  {
    v30 = 4;
    v31 = &a7;
  }
  v27 = v22;
  return FwpmFilterAdd0(v23, &v24, 0i64, v12);
}
// 14001DCB4: using guessed type __int64 __fastcall FwpmFilterAdd0(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140005334) ----------------------------------------------------
__int64 __fastcall sub_140005334(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6, int a7, __m128i *a8, __int64 a9, __int64 a10, __m128i *a11, __m128i *a12, __m128i *a13)
{
  __int64 v13; // rsi
  __int64 v14; // rdi
  __int64 v15; // rbx
  __int64 v16; // rbp
  __m128i v17; // xmm0
  signed __int64 v18; // r11
  char *v19; // rcx
  bool v20; // zf
  int v21; // eax
  __int64 v23; // [rsp+40h] [rbp-C8h]
  char v24; // [rsp+60h] [rbp-A8h]
  char v25; // [rsp+78h] [rbp-90h]

  v13 = a2;
  v14 = a1;
  v15 = a3;
  v16 = a4;
  sub_14001E1C0((__m128 *)&v24, 0, 0x50ui64);
  if ( !a8 || !a9 || !(_DWORD)v15 || (_DWORD)v15 == 15 || (unsigned __int8)a10 > 2u )
    return 3221225473i64;
  if ( (_BYTE)a10 )
  {
    v17 = *a8;
    v18 = 0i64;
    v19 = &v25;
    do
    {
      *((_DWORD *)v19 - 2) = 0;
      v20 = a8->m128i_i64[0] == (_QWORD)xmmword_14002D860;
      _mm_storeu_si128((__m128i *)(v19 - 24), v17);
      if ( v20 && a8->m128i_i64[1] == *((_QWORD *)&xmmword_14002D860 + 1) )
      {
        *(_DWORD *)v19 = 1;
      }
      else if ( *a8 != xmmword_14002D880 && *a8 != xmmword_14002D870 )
      {
        *(_DWORD *)v19 = 3;
      }
      else
      {
        *(_DWORD *)v19 = 2;
      }
      v21 = *(_DWORD *)(a9 + 4 * v18++);
      *((_DWORD *)v19 + 2) = v21;
      v19 += 40;
    }
    while ( v18 < (unsigned __int8)a10 );
  }
  LODWORD(v23) = (unsigned __int8)a10;
  return sub_1400051FC(v14, v13, (__int64)&qword_140034300[v15], v16, a5, a6, a7, (__int64)&v24, v23, a11, a12, a13);
}
// 14002D860: using guessed type __int128 xmmword_14002D860;
// 14002D870: using guessed type __int128 xmmword_14002D870;
// 14002D880: using guessed type __int128 xmmword_14002D880;

//----- (00000001400054F4) ----------------------------------------------------
__int64 __fastcall sub_1400054F4(__int16 *a1, __int64 a2, __int16 a3, __int64 a4, int a5, int a6)
{
  __int16 v6; // bp
  __int64 v7; // rdi
  __int16 *v8; // r14
  __int64 v9; // rsi
  __m128 *v10; // rax
  __int64 v11; // rbx
  __int64 result; // rax
  __int64 v13; // rdx
  bool v14; // zf
  __m128i *v15; // rax

  v6 = a3;
  v7 = a2;
  v8 = a1;
  v9 = a4;
  v10 = (__m128 *)ExAllocatePoolWithTag((POOL_TYPE)512, 0xB8ui64, 0x6B707044u);
  v11 = (__int64)v10;
  if ( !v10 )
    return 0i64;
  sub_14001E1C0(v10, 0, 0xB8ui64);
  *(_DWORD *)(v11 + 28) = a5;
  *(_DWORD *)(v11 + 32) = a6;
  *(_WORD *)(v11 + 24) = v6;
  sub_140005698(v8, v6, v11);
  if ( v9 )
  {
    LOBYTE(v13) = 1;
    *(_QWORD *)(v11 + 64) = v9;
    FwpsReferenceNetBufferList0(v9, v13);
  }
  v14 = *(_DWORD *)(v11 + 32) == 0;
  *(_DWORD *)(v11 + 72) = *(_DWORD *)(v7 + 80);
  *(_QWORD *)(v11 + 16) = *(_QWORD *)(v7 + 32);
  if ( v14 )
  {
    if ( v9 )
    {
      *(_QWORD *)(v11 + 96) = *(_QWORD *)(v7 + 112);
      *(_DWORD *)(v11 + 120) = *(_DWORD *)(v7 + 120);
      if ( *(_DWORD *)v7 & 0x10000 )
      {
        v15 = (__m128i *)ExAllocatePoolWithTag((POOL_TYPE)512, *(unsigned int *)(v7 + 136), 0x64636444u);
        *(_QWORD *)(v11 + 128) = v15;
        if ( !v15 )
        {
          sub_140005770((_QWORD *)v11);
          return 0i64;
        }
        sub_14001E2C0(v15, *(_QWORD *)(v7 + 128), *(unsigned int *)(v7 + 136));
        *(_DWORD *)(v11 + 136) = *(_DWORD *)(v7 + 136);
      }
    }
  }
  *(_QWORD *)(v11 + 48) = *(_QWORD *)(v7 + 56);
  result = v11;
  *(_BYTE *)(v11 + 180) = 0;
  return result;
}
// 14001DC72: using guessed type __int64 __fastcall FwpsReferenceNetBufferList0(_QWORD, _QWORD);

//----- (0000000140005630) ----------------------------------------------------
void __fastcall sub_140005630(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rbx
  __int64 v3; // rcx
  int v4; // eax

  if ( a1 )
  {
    v2 = a1;
    v3 = *a1;
    if ( v3 != -1 )
    {
      if ( a2 )
      {
        FwpmProviderDeleteByKey0();
        v3 = *v2;
      }
      v4 = FwpmEngineClose0(v3);
      if ( v4 < 0 )
        sub_140002E58(
          L"Failed to close engine handle",
          0,
          v4,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\utils.c",
          729);
      *v2 = -1i64;
    }
  }
}
// 14001DC8A: using guessed type __int64 __fastcall FwpmEngineClose0(_QWORD);
// 14001DC96: using guessed type __int64 FwpmProviderDeleteByKey0(void);
// 14001F7B0: using guessed type wchar_t aFailedToCloseE[30];

//----- (0000000140005688) ----------------------------------------------------
__int16 __fastcall sub_140005688(__int16 a1)
{
  __int16 result; // ax

  result = a1 + 32;
  if ( (unsigned __int16)(a1 - 65) > 0x19u )
    result = a1;
  return result;
}

//----- (0000000140005698) ----------------------------------------------------
__int64 __fastcall sub_140005698(__int16 *a1, __int16 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int16 v4; // bx
  __int16 *v5; // rsi
  __int64 v6; // rcx
  __m128i *v7; // rax
  signed __int64 v8; // rcx
  __int64 result; // rax
  unsigned int v10; // [rsp+30h] [rbp-18h]
  unsigned int v11; // [rsp+70h] [rbp+28h]
  unsigned int v12; // [rsp+78h] [rbp+30h]
  unsigned int v13; // [rsp+80h] [rbp+38h]
  unsigned int v14; // [rsp+88h] [rbp+40h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  sub_140005878(*a1, &v12, &v11, &v13, &v14, &v10);
  v6 = *((_QWORD *)v5 + 1);
  if ( v4 == 2 )
  {
    *(_DWORD *)(v3 + 76) = _byteswap_ulong(*(_DWORD *)(v6 + 16i64 * v12 + 8));
    *(_DWORD *)(v3 + 104) = _byteswap_ulong(*(_DWORD *)(*((_QWORD *)v5 + 1) + 16i64 * v11 + 8));
  }
  else
  {
    v7 = *(__m128i **)(v6 + 16i64 * v12 + 8);
    v8 = 2i64 * v11;
    _mm_storeu_si128((__m128i *)(v3 + 76), *v7);
    _mm_storeu_si128((__m128i *)(v3 + 104), *(__m128i *)*(_QWORD *)(*((_QWORD *)v5 + 1) + 8 * v8 + 8));
  }
  *(_WORD *)(v3 + 92) = __ROR2__(*(_WORD *)(*((_QWORD *)v5 + 1) + 16i64 * v13 + 8), 8);
  *(_WORD *)(v3 + 94) = __ROR2__(*(_WORD *)(*((_QWORD *)v5 + 1) + 16i64 * v14 + 8), 8);
  result = *((_QWORD *)v5 + 1);
  *(_BYTE *)(v3 + 56) = *(_BYTE *)(result + 16i64 * v10 + 8);
  return result;
}

//----- (0000000140005770) ----------------------------------------------------
void __fastcall sub_140005770(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rcx
  void *v3; // rcx
  void *v4; // rcx
  __int64 v5; // rcx

  v1 = a1;
  v2 = a1[8];
  if ( v2 )
    FwpsDereferenceNetBufferList0(v2, 0i64);
  v3 = (void *)v1[16];
  if ( v3 )
    ExFreePoolWithTag(v3, 0x64636444u);
  v4 = (void *)v1[21];
  if ( v4 )
    ExFreePoolWithTag(v4, 0x74737050u);
  v5 = v1[5];
  if ( v5 )
    FwpsCompleteOperation0(v5, 0i64);
  ExFreePoolWithTag(v1, 0x6B707044u);
}
// 14001DC6C: using guessed type __int64 __fastcall FwpsCompleteOperation0(_QWORD, _QWORD);
// 14001DC78: using guessed type __int64 __fastcall FwpsDereferenceNetBufferList0(_QWORD, _QWORD);

//----- (00000001400057DC) ----------------------------------------------------
__int64 __fastcall sub_1400057DC(int a1, _DWORD *a2)
{
  __int64 result; // rax

  result = (unsigned int)(a1 - 44);
  if ( ((_WORD)a1 - 44) & 0xFFFD )
  {
    if ( (_WORD)a1 == 48 || (_WORD)a1 == 50 )
      *a2 = 12;
    else
      *a2 = -1;
  }
  else
  {
    *a2 = 11;
  }
  return result;
}

//----- (000000014000580C) ----------------------------------------------------
signed __int64 __fastcall sub_14000580C(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // r8
  unsigned __int64 v4; // rdx
  signed __int64 result; // rax

  v2 = 0i64;
  if ( a2 < 5 || (v3 = 0i64, a2 == 3) )
  {
LABEL_8:
    if ( a2 >= 3 && (v4 = a2 - 1) != 0 )
    {
      while ( *(_BYTE *)(v2 + a1) != 10 || *(_BYTE *)(v2 + a1 + 1) != 10 )
      {
        if ( ++v2 >= v4 )
          goto LABEL_13;
      }
      result = v2 + 2;
    }
    else
    {
LABEL_13:
      result = 0i64;
    }
  }
  else
  {
    while ( *(_BYTE *)(v3 + a1) != 13
         || *(_BYTE *)(v3 + a1 + 1) != 10
         || *(_BYTE *)(v3 + a1 + 2) != 13
         || *(_BYTE *)(v3 + a1 + 3) != 10 )
    {
      if ( ++v3 >= a2 - 3 )
        goto LABEL_8;
    }
    result = v3 + 4;
  }
  return result;
}

//----- (0000000140005878) ----------------------------------------------------
_DWORD *__fastcall sub_140005878(__int16 a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  return sub_1400058B0(a1, a2, a3, a4, a5, a6, 0i64, 0i64, 0i64);
}

//----- (00000001400058B0) ----------------------------------------------------
_DWORD *__fastcall sub_1400058B0(__int16 a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9)
{
  _DWORD *result; // rax

  switch ( a1 )
  {
    case 44:
    case 46:
      *a2 = 2;
      *a3 = 6;
      *a4 = 4;
      *a5 = 7;
      *a6 = 5;
      if ( a7 )
        *a7 = 27;
      if ( a8 )
        *a8 = 28;
      break;
    case 48:
    case 50:
      *a2 = 2;
      *a3 = 6;
      *a4 = 4;
      *a5 = 7;
      *a6 = 5;
      if ( a7 )
        *a7 = 26;
      if ( a8 )
        *a8 = 27;
      break;
    case 64:
    case 65:
      *a2 = 2;
      *a3 = 6;
      *a4 = 4;
      *a5 = 7;
      *a6 = 5;
      break;
    default:
      *a2 = -1;
      *a3 = -1;
      *a4 = -1;
      *a5 = -1;
      *a6 = -1;
      if ( a7 )
        *a7 = 0;
      if ( a8 )
        *a8 = 0;
      result = a9;
      if ( a9 )
        *a9 = 0;
      return result;
  }
  result = a9;
  if ( a9 )
    *a9 = 1;
  return result;
}

//----- (00000001400059F8) ----------------------------------------------------
bool __fastcall sub_1400059F8(unsigned __int16 *a1)
{
  return sub_140005A04(a1, 4);
}

//----- (0000000140005A04) ----------------------------------------------------
bool __fastcall sub_140005A04(unsigned __int16 *a1, int a2)
{
  int v2; // edi
  unsigned __int16 *v3; // rbx
  unsigned int v5; // [rsp+30h] [rbp+8h]

  v2 = a2;
  v3 = a1;
  sub_1400057DC(*a1, &v5);
  return v5 != -1 && v2 & *(_DWORD *)(*((_QWORD *)v3 + 1) + 16i64 * v5 + 8);
}

//----- (0000000140005A5C) ----------------------------------------------------
bool __fastcall sub_140005A5C(__int64 a1)
{
  __int64 v1; // rax
  bool result; // al
  int v3; // [rsp+20h] [rbp-38h]
  __int64 v4; // [rsp+28h] [rbp-30h]
  int v5; // [rsp+30h] [rbp-28h]
  const wchar_t *v6; // [rsp+38h] [rbp-20h]

  result = 0;
  if ( *(_WORD *)a1 >= 0x16u )
  {
    v5 = 1441814;
    v6 = L"\\device\\harddiskvolume";
    v1 = *(_QWORD *)(a1 + 8);
    v3 = 1441814;
    v4 = v1;
    if ( !RtlCompareUnicodeString((PCUNICODE_STRING)&v5, (PCUNICODE_STRING)&v3, 1u) )
      result = 1;
  }
  return result;
}
// 14001F7F0: using guessed type wchar_t aDeviceHarddisk[23];

//----- (0000000140005ACC) ----------------------------------------------------
bool __fastcall sub_140005ACC(__int16 a1, __int64 a2)
{
  __int64 v4; // rdx
  __int64 Source1; // [rsp+20h] [rbp-20h]
  int v6; // [rsp+28h] [rbp-18h]
  int v7; // [rsp+2Ch] [rbp-14h]

  if ( a1 == 2 )
    return (*(_DWORD *)(*(_QWORD *)(a2 + 8) + 104i64) & 0xFF000000) == 2130706432;
  if ( a1 == 23 )
  {
    v4 = *(_QWORD *)(a2 + 8);
    v7 = 0x1000000;
    Source1 = 0i64;
    v6 = 0;
    return RtlCompareMemory(&Source1, *(const void **)(v4 + 104), 0x10ui64) == 16;
  }
  return 0;
}

//----- (0000000140005B48) ----------------------------------------------------
bool __fastcall sub_140005B48(unsigned __int16 *a1)
{
  return sub_140005A04(a1, 0x2000000);
}

//----- (0000000140005B54) ----------------------------------------------------
bool __fastcall sub_140005B54(unsigned __int16 *a1)
{
  return sub_140005A04(a1, 0x200000);
}

//----- (0000000140005B60) ----------------------------------------------------
char __fastcall sub_140005B60(char *a1)
{
  unsigned __int64 v1; // rax
  char *v2; // r9
  signed __int64 v3; // rdx
  unsigned int v4; // er10
  __int64 **v5; // r11
  char *v6; // rax
  int v7; // er8
  int v8; // ecx
  __int64 *v10; // [rsp+0h] [rbp-60h]
  const char *v11; // [rsp+8h] [rbp-58h]
  const char *v12; // [rsp+10h] [rbp-50h]
  const char *v13; // [rsp+18h] [rbp-48h]
  const char *v14; // [rsp+20h] [rbp-40h]
  __int64 *v15; // [rsp+28h] [rbp-38h]
  const char *v16; // [rsp+30h] [rbp-30h]
  const char *v17; // [rsp+38h] [rbp-28h]
  const char *v18; // [rsp+40h] [rbp-20h]
  const char *v19; // [rsp+48h] [rbp-18h]
  const char *v20; // [rsp+50h] [rbp-10h]
  const char *v21; // [rsp+58h] [rbp-8h]

  v1 = -1i64;
  v2 = a1;
  v3 = -1i64;
  do
    ++v3;
  while ( a1[v3] );
  if ( !v3 )
    return 0;
  do
    ++v1;
  while ( a1[v1] );
  if ( v1 < 3 )
    return 0;
  v4 = 0;
  v10 = qword_14001F460;
  v5 = &v10;
  v11 = "POST";
  v12 = "HEAD";
  v13 = "OPTIONS";
  v14 = "CONNECT";
  v15 = qword_14001F4B0;
  v16 = "DELETE";
  v17 = "LINK";
  v18 = "UNLINK";
  v19 = "TRACE";
  v20 = "TRACK";
  v21 = "PATCH";
  while ( 1 )
  {
    v6 = v2;
    do
    {
      v7 = (unsigned __int8)v6[(char *)*v5 - v2];
      v8 = (unsigned __int8)*v6 - v7;
      if ( (unsigned __int8)*v6 != v7 )
        break;
      ++v6;
    }
    while ( v7 );
    if ( !v8 )
      break;
    ++v4;
    ++v5;
    if ( v4 >= 0xC )
      return 0;
  }
  return 1;
}
// 14001F460: using guessed type __int64 qword_14001F460[2];
// 14001F4B0: using guessed type __int64 qword_14001F4B0[2];

//----- (0000000140005C60) ----------------------------------------------------
bool __fastcall sub_140005C60(char a1)
{
  return a1 == 32 || (unsigned __int8)(a1 - 9) <= 4u;
}

//----- (0000000140005C74) ----------------------------------------------------
signed __int64 __fastcall sub_140005C74(_QWORD *a1, __m128i *a2)
{
  __m128i *v2; // rsi
  _QWORD *v3; // rbx
  int v4; // eax
  unsigned int v5; // edi
  __m128i v7; // xmm0
  __int64 v8; // rcx
  __int128 v9; // [rsp+30h] [rbp-A8h]
  const wchar_t *v10; // [rsp+40h] [rbp-98h]
  char v11; // [rsp+70h] [rbp-68h]
  int v12; // [rsp+90h] [rbp-48h]

  v2 = a2;
  v3 = a1;
  sub_14001E1C0((__m128 *)&v11, 0, 0x48ui64);
  if ( v3 )
  {
    if ( *v3 != -1i64 )
      return 0i64;
    if ( v2 )
    {
      v12 = 1;
      v4 = FwpmEngineOpen0(0i64, 10i64, 0i64, &v11, v3);
      v5 = v4;
      if ( v4 < 0 )
      {
        *v3 = -1i64;
        sub_140002E58(
          L"Unable to open filter engine session",
          v4,
          0,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\utils.c",
          659);
        return v5;
      }
      sub_14001E1C0((__m128 *)&v9, 0, 0x40ui64);
      v7 = *v2;
      v8 = *v3;
      v10 = L"Sophos Network Threat Protection Provider";
      _mm_storeu_si128((__m128i *)&v9, v7);
      v5 = FwpmProviderAdd0(v8, &v9, 0i64);
      if ( v5 && v5 != -2144206839 && v5 != -1071513590 )
      {
        FwpmEngineClose0(*v3);
        *v3 = -1i64;
        sub_140002E58(
          L"Unable to add provider",
          0,
          v5,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\utils.c",
          679);
        return v5;
      }
      return 0i64;
    }
  }
  return 3221225473i64;
}
// 14001DC84: using guessed type __int64 __fastcall FwpmEngineOpen0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 14001DC8A: using guessed type __int64 __fastcall FwpmEngineClose0(_QWORD);
// 14001DC90: using guessed type __int64 __fastcall FwpmProviderAdd0(_QWORD, _QWORD, _QWORD);
// 14001F6D0: using guessed type wchar_t aUnableToOpenFi[37];
// 14001F720: using guessed type wchar_t aSophosNetworkT[42];
// 14001F780: using guessed type wchar_t aUnableToAddPro[23];

//----- (0000000140005DB8) ----------------------------------------------------
char __fastcall sub_140005DB8(char *a1, unsigned __int64 a2, signed __int64 *a3)
{
  signed __int64 *v3; // r15
  unsigned __int64 v4; // rbp
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // rbx
  char *v7; // rsi
  char v9[16]; // [rsp+20h] [rbp-48h]

  *a3 = 0i64;
  v3 = a3;
  v4 = a2;
  v5 = (unsigned __int64)a1;
  if ( !a1 || !a2 )
    return 0;
  v6 = 0i64;
  if ( !sub_140005C60(*a1) )
  {
    v7 = (char *)v5;
    do
    {
      if ( v6 >= 0xA )
        break;
      if ( v4 <= (unsigned __int64)&v7[2 - v5] )
        return 0;
      ++v7;
      ++v6;
    }
    while ( !sub_140005C60(*v7) );
  }
  sub_14001E2C0((__m128i *)v9, v5, v6);
  if ( v6 >= 0xB )
    sub_14001DDA0();
  v9[v6] = 0;
  if ( !sub_140005B60(v9) )
    return 0;
  *v3 = sub_14000580C(v5, v4);
  return 1;
}
// 140005DB8: using guessed type char var_48[16];

//----- (0000000140005E8C) ----------------------------------------------------
signed __int64 __fastcall sub_140005E8C(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, __int64 a5, __m128i *a6, __m128i *a7, __int64 a8, __int64 a9, __int64 a10)
{
  _DWORD *v10; // rdi
  __int64 v11; // r13
  __m128i v12; // xmm0
  int v13; // eax
  unsigned int v14; // ebx
  __m128i v15; // xmm0
  int v16; // eax
  __int64 v18; // [rsp+30h] [rbp-C1h]
  __int64 v19; // [rsp+40h] [rbp-B1h]
  __int128 v20; // [rsp+48h] [rbp-A9h]
  __int64 v21; // [rsp+58h] [rbp-99h]
  __int64 v22; // [rsp+60h] [rbp-91h]
  __int64 v23; // [rsp+68h] [rbp-89h]
  __int64 v24; // [rsp+70h] [rbp-81h]
  __int128 v25; // [rsp+80h] [rbp-71h]
  __int64 v26; // [rsp+90h] [rbp-61h]
  __int64 v27; // [rsp+98h] [rbp-59h]
  __int128 v28; // [rsp+C0h] [rbp-31h]

  v10 = a3;
  v11 = a1;
  v21 = 0i64;
  v24 = 0i64;
  v19 = a2;
  v18 = a4;
  sub_14001E1C0((__m128 *)&v25, 0, 0x58ui64);
  if ( !a6 || !a7 )
    return 3221225473i64;
  v12 = *a7;
  v22 = a8;
  v23 = a9;
  _mm_storeu_si128((__m128i *)&v20, v12);
  v13 = FwpsCalloutRegister1(a10, &v20, v10);
  v14 = v13;
  if ( v13 >= 0 )
  {
    _mm_storeu_si128((__m128i *)&v25, *a7);
    v26 = v18;
    v15 = *a6;
    v27 = a5;
    _mm_storeu_si128((__m128i *)&v28, v15);
    v16 = FwpmCalloutAdd0(v11, &v25, 0i64, v19);
    v14 = v16;
    if ( v16 < 0 )
    {
      sub_140002E58(
        L"Unable to add callout",
        v16,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\utils.c",
        390);
      FwpsCalloutUnregisterById0((unsigned int)*v10);
      *v10 = 0;
    }
  }
  else
  {
    sub_140002E58(
      L"Unable to register callout",
      v13,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\utils.c",
      372);
  }
  return v14;
}
// 14001DC60: using guessed type __int64 __fastcall FwpsCalloutRegister1(_QWORD, _QWORD, _QWORD);
// 14001DC66: using guessed type __int64 __fastcall FwpsCalloutUnregisterById0(_QWORD);
// 14001DCA8: using guessed type __int64 __fastcall FwpmCalloutAdd0(_QWORD, _QWORD, _QWORD, _QWORD);
// 14001F560: using guessed type wchar_t aUnableToRegist[27];
// 14001F5A0: using guessed type wchar_t aUnableToAddCal[22];

//----- (0000000140005FF0) ----------------------------------------------------
signed __int64 __fastcall sub_140005FF0(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, int a9, __m128i *a10, __int64 a11, __int64 a12, __m128i *a13, __m128i *a14, __m128i *a15, __int64 a16, __int64 a17, __int64 a18)
{
  __int64 v18; // r12
  __int64 v19; // rbx
  __m128i v20; // xmm0
  _DWORD *v21; // rsi
  __int64 v22; // rdi
  int v23; // eax
  unsigned int v24; // ebx
  __m128i v25; // xmm0
  int *v26; // r14
  int v27; // eax
  int v28; // eax
  __int64 v30; // [rsp+28h] [rbp-D8h]
  __int64 v31; // [rsp+48h] [rbp-B8h]
  __int64 v32; // [rsp+80h] [rbp-80h]
  __int64 v33; // [rsp+B8h] [rbp-48h]
  __int128 v34; // [rsp+C0h] [rbp-40h]
  __int64 v35; // [rsp+D0h] [rbp-30h]
  __int64 v36; // [rsp+D8h] [rbp-28h]
  __int64 v37; // [rsp+E0h] [rbp-20h]
  __int64 v38; // [rsp+E8h] [rbp-18h]
  __int128 v39; // [rsp+F0h] [rbp-10h]
  __int64 v40; // [rsp+100h] [rbp+0h]
  __int64 v41; // [rsp+108h] [rbp+8h]
  __int128 v42; // [rsp+130h] [rbp+30h]

  v18 = a1;
  v35 = 0i64;
  v38 = 0i64;
  v33 = a2;
  v19 = a3;
  v32 = a4;
  sub_14001E1C0((__m128 *)&v39, 0, 0x58ui64);
  if ( a13 && a15 && a11 )
  {
    v20 = *a15;
    v37 = a17;
    v36 = a16;
    v21 = &dword_1400343B8[v19];
    v22 = v19;
    _mm_storeu_si128((__m128i *)&v34, v20);
    v23 = FwpsCalloutRegister1(a18, &v34, &dword_1400343B8[v19]);
    v24 = v23;
    if ( v23 < 0 )
    {
      sub_140002E58(
        L"Unable to register callout with FilterID",
        v23,
        v22,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\utils.c",
        458);
      return v24;
    }
    v25 = *a15;
    v40 = v32;
    v41 = a5;
    _mm_storeu_si128((__m128i *)&v39, v25);
    v26 = &dword_140034378[v22];
    _mm_storeu_si128((__m128i *)&v42, *a13);
    v27 = FwpmCalloutAdd0(v18, &v39, 0i64, &dword_140034378[v22]);
    v24 = v27;
    if ( v27 >= 0 )
    {
      LOBYTE(v31) = a12;
      LODWORD(v30) = a8;
      v28 = sub_140005334(v18, v33, v22, a6, a7, v30, a9, a10, a11, v31, a13, a14, a15);
      v24 = v28;
      if ( v28 >= 0 )
        return v24;
      sub_140002E58(
        L"Unable to add filter with FilterID",
        v28,
        v22,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\utils.c",
        498);
      FwpmCalloutDeleteById0(v18, (unsigned int)*v26);
      *v26 = 0;
    }
    else
    {
      sub_140002E58(
        L"Unable to add callout with FilterID",
        v27,
        v22,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\utils.c",
        476);
    }
    FwpsCalloutUnregisterById0((unsigned int)*v21);
    *v21 = 0;
    return v24;
  }
  return 3221225473i64;
}
// 14001DC60: using guessed type __int64 __fastcall FwpsCalloutRegister1(_QWORD, _QWORD, _QWORD);
// 14001DC66: using guessed type __int64 __fastcall FwpsCalloutUnregisterById0(_QWORD);
// 14001DCA8: using guessed type __int64 __fastcall FwpmCalloutAdd0(_QWORD, _QWORD, _QWORD, _QWORD);
// 14001DCAE: using guessed type __int64 __fastcall FwpmCalloutDeleteById0(_QWORD, _QWORD);
// 14001F5D0: using guessed type wchar_t aUnableToRegist_0[41];
// 14001F630: using guessed type wchar_t aUnableToAddCal_0[36];
// 14001F680: using guessed type wchar_t aUnableToAddFil[35];

//----- (0000000140006260) ----------------------------------------------------
signed __int64 __fastcall sub_140006260(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, int a8, __m128i *a9, __int64 a10, __m128i *a11, __m128i *a12, __m128i *a13, __int64 a14, __int64 a15, __int64 a16)
{
  __int64 v17; // [rsp+38h] [rbp-90h]
  __int64 v18; // [rsp+58h] [rbp-70h]

  LOBYTE(v18) = 1;
  LODWORD(v17) = a8;
  return sub_140005FF0(a1, a2, a3, a4, a5, a6, a7, v17, 0, a9, (__int64)&a10, v18, a11, a12, a13, a14, a15, a16);
}

//----- (0000000140006340) ----------------------------------------------------
__int64 __fastcall sub_140006340(__int64 a1, __int64 a2, __m128i *a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r15
  __m128i *v6; // r14
  __int64 v7; // rsi
  __int64 v8; // rdi
  signed __int16 v9; // bx
  __m128i v10; // xmm0
  __int64 v12; // [rsp+20h] [rbp-61h]
  __int128 v13; // [rsp+30h] [rbp-51h]
  __int64 v14; // [rsp+40h] [rbp-41h]
  __int64 v15; // [rsp+48h] [rbp-39h]
  int v16; // [rsp+50h] [rbp-31h]
  __int64 v17; // [rsp+58h] [rbp-29h]
  __int16 v18; // [rsp+70h] [rbp-11h]

  v12 = 0i64;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  if ( a1 == -1 || !a3 || !a2 )
    return 3221225473i64;
  v9 = word_1400343F4;
  if ( !word_1400343F4 )
  {
    if ( (signed int)FwpmSubLayerGetByKey0(a1, &unk_14002D3F0, &v12) >= 0 && v12 )
    {
      word_1400343F4 = *(_WORD *)(v12 + 64);
      FwpmFreeMemory0(&v12);
      v9 = word_1400343F4;
    }
    else
    {
      v9 = -32768;
      word_1400343F4 = -32768;
    }
  }
  sub_14001E1C0((__m128 *)&v13, 0, 0x48ui64);
  v10 = *v6;
  v14 = v5;
  v15 = a5;
  v17 = v7;
  v16 = 0;
  _mm_storeu_si128((__m128i *)&v13, v10);
  v18 = v9 - 1;
  return FwpmSubLayerAdd0(v8, &v13, 0i64);
}
// 14001DC7E: using guessed type __int64 __fastcall FwpmFreeMemory0(_QWORD);
// 14001DC9C: using guessed type __int64 __fastcall FwpmSubLayerAdd0(_QWORD, _QWORD, _QWORD);
// 14001DCA2: using guessed type __int64 __fastcall FwpmSubLayerGetByKey0(_QWORD, _QWORD, _QWORD);
// 1400343F4: using guessed type __int16 word_1400343F4;

//----- (0000000140006454) ----------------------------------------------------
void __fastcall sub_140006454(__int64 a1, int a2)
{
  __int64 v2; // rsi
  __int64 v3; // rbx

  v2 = a2;
  v3 = a1;
  sub_1400064C0(a1, &qword_140034300[a2]);
  if ( (signed int)FwpmCalloutDeleteById0(v3, (unsigned int)dword_140034378[v2]) >= 0 )
    dword_140034378[v2] = 0;
  sub_1400064E0(v2);
}
// 14001DCAE: using guessed type __int64 __fastcall FwpmCalloutDeleteById0(_QWORD, _QWORD);

//----- (00000001400064C0) ----------------------------------------------------
__int64 __fastcall sub_1400064C0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  __int64 result; // rax

  v2 = a2;
  result = FwpmFilterDeleteById0(a1, *a2);
  if ( (signed int)result >= 0 )
    *v2 = 0i64;
  return result;
}
// 14001DCBA: using guessed type __int64 __fastcall FwpmFilterDeleteById0(_QWORD, _QWORD);

//----- (00000001400064E0) ----------------------------------------------------
void __fastcall sub_1400064E0(int a1)
{
  __int64 v1; // rbx
  __int64 v2; // rcx

  v1 = a1;
  v2 = (unsigned int)dword_1400343B8[a1];
  if ( (_DWORD)v2 )
  {
    if ( (signed int)FwpsCalloutUnregisterById0(v2) >= 0 )
      dword_1400343B8[v1] = 0;
  }
}
// 14001DC66: using guessed type __int64 __fastcall FwpsCalloutUnregisterById0(_QWORD);

//----- (0000000140006520) ----------------------------------------------------
signed __int64 __fastcall sub_140006520(int a1, __int64 a2, __int64 a3)
{
  int v3; // ebx
  __int64 v4; // rdi
  __int64 v5; // rbp
  int v6; // esi
  const WCHAR *v8; // rax
  int v9; // esi
  int v10; // eax
  __int64 v11; // rdx
  UNICODE_STRING DestinationString; // [rsp+30h] [rbp-38h]

  v3 = 0;
  v4 = a3;
  v5 = a2;
  v6 = a1;
  if ( !a3 )
    return 3221225473i64;
  v8 = (const WCHAR *)sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)a3 + 8i64));
  RtlInitUnicodeString(&DestinationString, v8);
  v9 = v6 - 2;
  if ( !v9 )
  {
    v11 = *(_QWORD *)(v5 + 24);
    v10 = sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v4 + 24i64));
    goto LABEL_7;
  }
  if ( v9 == 1 )
  {
    v10 = sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v4 + 32i64));
LABEL_7:
    v3 = v10;
  }
  return (v3 >> 31) & 0xC0000001;
}

//----- (00000001400065D4) ----------------------------------------------------
void __fastcall sub_1400065D4(__int64 a1, int a2)
{
  if ( a2 )
  {
    if ( a2 == 1 )
      _InterlockedIncrement64((volatile signed __int64 *)(a1 + 16));
  }
  else
  {
    _InterlockedIncrement64((volatile signed __int64 *)(a1 + 8));
  }
}

//----- (00000001400065EC) ----------------------------------------------------
_QWORD *__fastcall sub_1400065EC(_QWORD *a1)
{
  _QWORD *v1; // rbx

  v1 = a1;
  *a1 = &off_14002E100;
  sub_140006664(a1 + 1);
  return v1;
}
// 14002E100: using guessed type __int64 (__fastcall *off_14002E100)();

//----- (0000000140006614) ----------------------------------------------------
_QWORD *__fastcall sub_140006614(_QWORD *a1)
{
  _QWORD *v1; // rbx

  v1 = a1;
  sub_1400065EC(a1);
  *((_BYTE *)v1 + 24) = 0;
  *v1 = off_14002E128;
  return v1;
}
// 14002E128: using guessed type __int64 (__fastcall *off_14002E128[10])();

//----- (000000014000663C) ----------------------------------------------------
_QWORD *__fastcall sub_14000663C(_QWORD *a1)
{
  _QWORD *v1; // rbx

  v1 = a1;
  sub_1400065EC(a1);
  *((_BYTE *)v1 + 24) = 0;
  *v1 = off_14002E150;
  return v1;
}
// 14002E150: using guessed type __int64 (__fastcall *off_14002E150[5])();

//----- (0000000140006664) ----------------------------------------------------
_QWORD *__fastcall sub_140006664(_QWORD *a1)
{
  _QWORD *result; // rax

  *a1 = 0i64;
  result = a1;
  a1[1] = 0i64;
  return result;
}

//----- (0000000140006678) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_140006678(_QWORD *a1))()
{
  __int64 (__fastcall **result)(); // rax

  result = &off_14002E100;
  *a1 = &off_14002E100;
  return result;
}
// 14002E100: using guessed type __int64 (__fastcall *off_14002E100)();

//----- (0000000140006684) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_140006684(__int64 a1))()
{
  bool v1; // zf
  _QWORD *v2; // rbx

  v1 = *(_BYTE *)(a1 + 24) == 0;
  *(_QWORD *)a1 = off_14002E128;
  v2 = (_QWORD *)a1;
  if ( !v1 )
    sub_14003B140();
  return sub_140006678(v2);
}
// 14002E128: using guessed type __int64 (__fastcall *off_14002E128[10])();

//----- (00000001400066B0) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_1400066B0(__int64 a1))()
{
  bool v1; // zf
  _QWORD *v2; // rbx

  v1 = *(_BYTE *)(a1 + 24) == 0;
  *(_QWORD *)a1 = off_14002E150;
  v2 = (_QWORD *)a1;
  if ( !v1 )
    sub_14003B14C();
  return sub_140006678(v2);
}
// 14002E150: using guessed type __int64 (__fastcall *off_14002E150[5])();

//----- (00000001400066E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400066E0(_QWORD *a1, char a2)
{
  char v2; // di
  _QWORD *v3; // rbx

  v2 = a2;
  v3 = a1;
  sub_140006678(a1);
  if ( v2 & 1 && v2 & 4 )
    nullsub_1(v3, 24i64);
  return v3;
}
// 140004C90: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);

//----- (0000000140006720) ----------------------------------------------------
__int64 __fastcall sub_140006720(__int64 a1, char a2)
{
  char v2; // di
  __int64 v3; // rbx

  v2 = a2;
  v3 = a1;
  sub_140006684(a1);
  if ( v2 & 1 && v2 & 4 )
    nullsub_1(v3, 32i64);
  return v3;
}
// 140004C90: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);

//----- (0000000140006760) ----------------------------------------------------
__int64 __fastcall sub_140006760(__int64 a1, char a2)
{
  char v2; // di
  __int64 v3; // rbx

  v2 = a2;
  v3 = a1;
  sub_1400066B0(a1);
  if ( v2 & 1 && v2 & 4 )
    nullsub_1(v3, 32i64);
  return v3;
}
// 140004C90: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);

//----- (00000001400067A0) ----------------------------------------------------
__int64 __fastcall sub_1400067A0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  const WCHAR *v5; // rax
  unsigned int v6; // eax
  UNICODE_STRING DestinationString; // [rsp+20h] [rbp-28h]

  v3 = a3;
  v4 = a1;
  v5 = (const WCHAR *)sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)a1 + 8i64));
  RtlInitUnicodeString(&DestinationString, v5);
  v6 = sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v4 + 16i64));
  return sub_14003B000(*(_QWORD *)(v3 + 24), (__int64)&DestinationString, v6, v4 + 8);
}

//----- (0000000140006820) ----------------------------------------------------
__int64 __fastcall sub_140006820(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  const WCHAR *v5; // rax
  UNICODE_STRING DestinationString; // [rsp+20h] [rbp-28h]

  v3 = a3;
  v4 = a1;
  v5 = (const WCHAR *)sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)a1 + 8i64));
  RtlInitUnicodeString(&DestinationString, v5);
  return sub_14003B000(*(_QWORD *)(v3 + 24), (__int64)&DestinationString, 0i64, v4 + 8);
}

//----- (0000000140006890) ----------------------------------------------------
__int64 __fastcall sub_140006890(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  const WCHAR *v4; // rax
  unsigned int v5; // eax
  UNICODE_STRING DestinationString; // [rsp+20h] [rbp-28h]

  v2 = a2;
  v3 = a1;
  v4 = (const WCHAR *)sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)a1 + 8i64));
  RtlInitUnicodeString(&DestinationString, v4);
  v5 = sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v3 + 16i64));
  return sub_14003B000(v2, (__int64)&DestinationString, v5, 0i64);
}

//----- (0000000140006910) ----------------------------------------------------
__int64 sub_140006910()
{
  return 0i64;
}

//----- (0000000140006920) ----------------------------------------------------
const wchar_t *sub_140006920()
{
  return L"Incoming packets";
}
// 14001F820: using guessed type wchar_t aIncomingPacket[17];

//----- (0000000140006930) ----------------------------------------------------
const wchar_t *sub_140006930()
{
  return L"Outgoing packets";
}
// 14001F850: using guessed type wchar_t aOutgoingPacket[17];

//----- (0000000140006938) ----------------------------------------------------
__int64 __fastcall sub_140006938(__int64 a1)
{
  __int64 v1; // rbx
  __int64 result; // rax

  v1 = a1;
  result = sub_14003B048((__int64)sub_140006520, a1);
  *(_BYTE *)(v1 + 24) = (signed int)result >= 0;
  return result;
}

//----- (0000000140006960) ----------------------------------------------------
__int64 __fastcall sub_140006960(__int64 a1)
{
  __int64 v1; // rbx
  __int64 result; // rax

  v1 = a1;
  result = sub_14003B0C4((__int64)sub_140006520, a1);
  *(_BYTE *)(v1 + 24) = (signed int)result >= 0;
  return result;
}

//----- (0000000140006988) ----------------------------------------------------
__int64 __fastcall sub_140006988(__int64 a1, __int64 a2)
{
  return a1 + a2;
}

//----- (0000000140006990) ----------------------------------------------------
_QWORD *__fastcall sub_140006990(_QWORD *a1, __int64 a2)
{
  *a1 = a2;
  return a1;
}

//----- (0000000140006998) ----------------------------------------------------
__int64 __fastcall sub_140006998(_QWORD *a1, char *a2)
{
  _QWORD *v2; // r13
  __int64 v3; // r14
  __m128 *v4; // rdi
  __int64 (*v5)(void); // rax
  __int64 (*v6)(void); // r15
  signed int v7; // ebx
  unsigned int v8; // ecx
  signed int v9; // eax
  signed int v10; // esi
  __m128 *v11; // rax
  signed __int64 v12; // r15
  unsigned int i; // esi
  signed __int64 v14; // r12
  signed int v15; // eax
  signed int v17; // [rsp+30h] [rbp-B8h]
  __m128 *v18; // [rsp+38h] [rbp-B0h]
  char *Str2; // [rsp+48h] [rbp-A0h]
  _QWORD *v20; // [rsp+50h] [rbp-98h]
  char v21; // [rsp+58h] [rbp-90h]
  SIZE_T NumberOfBytes; // [rsp+60h] [rbp-88h]
  UNICODE_STRING SystemRoutineName; // [rsp+68h] [rbp-80h]
  __int128 v24; // [rsp+78h] [rbp-70h]
  __int128 v25; // [rsp+88h] [rbp-60h]
  __int128 v26; // [rsp+98h] [rbp-50h]
  __int16 v27; // [rsp+A8h] [rbp-40h]

  Str2 = a2;
  v2 = a1;
  v20 = a1;
  *a1 = *sub_140006990(&v21, 0i64);
  v3 = 0i64;
  v4 = 0i64;
  v18 = 0i64;
  LODWORD(NumberOfBytes) = 0;
  v24 = xmmword_14001EC50;
  v25 = xmmword_14001EC60;
  v26 = xmmword_14001EC70;
  v27 = 0;
  *(_DWORD *)&SystemRoutineName.Length = 3276848;
  SystemRoutineName.Buffer = (PWSTR)&v24;
  v5 = (__int64 (*)(void))MmGetSystemRoutineAddress(&SystemRoutineName);
  v6 = v5;
  if ( v5 )
  {
    v9 = sub_14001E1B0(v5);
    v7 = 0;
    v8 = NumberOfBytes;
    if ( !(_DWORD)NumberOfBytes )
      v7 = v9;
    v17 = v7;
  }
  else
  {
    v7 = -1073741511;
    v17 = -1073741511;
    v8 = NumberOfBytes;
  }
  v10 = v7;
  if ( v7 >= 0 )
  {
    v11 = (__m128 *)ExAllocatePoolWithTag((POOL_TYPE)512, v8, 0x38737049u);
    v4 = v11;
    v18 = v11;
    v7 = -1073741801;
    if ( v11 )
      v7 = v10;
    v17 = v7;
    if ( v7 >= 0 )
    {
      sub_14001E1C0(v11, 0, (unsigned int)NumberOfBytes);
      v7 = sub_14001E1B0(v6);
      v17 = v7;
    }
  }
  if ( v7 >= 0 )
  {
    v12 = (signed __int64)&v4->m128_i64[1];
    if ( v4 != (__m128 *)-8i64 )
    {
      for ( i = 0; i < LODWORD(v4->m128_u64[0]); ++i )
      {
        v14 = 296i64 * i;
        if ( !stricmp((const char *)(v12 + v14 + *(unsigned __int16 *)(v14 + v12 + 38) + 40i64), Str2) )
        {
          _mm_lfence();
          v3 = *(_QWORD *)(v14 + v12 + 16);
          v7 = v17;
          v4 = v18;
          break;
        }
      }
    }
    v15 = -1073741275;
    if ( v3 )
      v15 = v7;
    v7 = v15;
  }
  if ( v7 >= 0 )
    *v2 = *sub_140006990(&Str2, v3);
  if ( v4 )
    ExFreePoolWithTag(v4, 0);
  return (unsigned int)v7;
}
// 14001EC50: using guessed type __int128 xmmword_14001EC50;
// 14001EC60: using guessed type __int128 xmmword_14001EC60;
// 14001EC70: using guessed type __int128 xmmword_14001EC70;

//----- (0000000140006BE0) ----------------------------------------------------
signed __int64 __fastcall sub_140006BE0(__int64 *a1, __int64 *a2, __int64 a3)
{
  __int64 v3; // r12
  __int64 *v4; // r14
  __int64 *v5; // r15
  __int64 v7; // rcx
  __int64 v8; // rbp
  _DWORD *v9; // rdi
  int v10; // esi
  unsigned int v11; // ebx
  __int64 v12; // r15
  __int64 v13; // rax
  unsigned int v14; // ecx
  unsigned int v15; // er13
  __int64 v16; // r10
  unsigned __int8 *v17; // rax
  __int64 v18; // r9
  int v19; // er8
  int v20; // edx
  __int64 v21; // [rsp+20h] [rbp-68h]
  __int64 v22; // [rsp+28h] [rbp-60h]
  __int64 v23; // [rsp+30h] [rbp-58h]
  int v24; // [rsp+38h] [rbp-50h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !*a1 )
    return 3221225860i64;
  if ( !a2 || !a3 )
    return 3221225485i64;
  *a2 = 0i64;
  v7 = *a1;
  LOBYTE(a2) = 1;
  v24 = 0;
  v8 = 0i64;
  v9 = (_DWORD *)RtlImageDirectoryEntryToData(v7, a2, 0i64, &v24);
  v10 = -1073741275;
  v11 = v9 == 0i64 ? 0xC0000225 : 0;
  if ( v9 )
  {
    v12 = *v5;
    v21 = sub_140006988(v12, (unsigned int)v9[9]);
    v22 = sub_140006988(v12, (unsigned int)v9[8]);
    v13 = sub_140006988(v12, (unsigned int)v9[7]);
    v14 = 0;
    v23 = v13;
    v15 = v9[6];
    if ( v15 )
    {
      do
      {
        v16 = *(unsigned __int16 *)(v21 + 2i64 * v14);
        if ( (unsigned int)v16 >= v9[5] )
          break;
        v17 = (unsigned __int8 *)(v12 + *(unsigned int *)(v22 + 4i64 * v14));
        v18 = v3 - (_QWORD)v17;
        do
        {
          v19 = v17[v18];
          v20 = *v17 - v19;
          if ( *v17 != v19 )
            break;
          ++v17;
        }
        while ( v19 );
        if ( !v20 )
        {
          v8 = sub_140006988(v12, *(unsigned int *)(v23 + 4 * v16));
          break;
        }
        ++v14;
      }
      while ( v14 < v15 );
    }
    if ( v8 )
      v10 = v9 == 0i64 ? 0xC0000225 : 0;
    v11 = v10;
    if ( v10 >= 0 )
      *v4 = v8;
  }
  return v11;
}
// 14001DF5E: using guessed type __int64 __fastcall RtlImageDirectoryEntryToData(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140006D50) ----------------------------------------------------
_QWORD *__fastcall sub_140006D50(_QWORD *a1, __int64 *a2)
{
  _QWORD *v2; // rbx
  __int64 *v3; // rdi
  bool v4; // al
  void *v5; // r8

  v2 = a1;
  v3 = a2;
  v4 = sub_140006EAC(a2);
  v5 = 0i64;
  if ( v4 )
    v5 = sub_1400071E8(*v3);
  *v2 = v5;
  return v2;
}

//----- (0000000140006D8C) ----------------------------------------------------
void **__fastcall sub_140006D8C(void **a1, __int64 a2)
{
  void **v2; // rbx

  v2 = a1;
  *a1 = sub_1400071E8(a2);
  return v2;
}

//----- (0000000140006DAC) ----------------------------------------------------
PVOID *__fastcall sub_140006DAC(PVOID *a1, SIZE_T a2)
{
  PVOID *v2; // rbx
  unsigned int v3; // edi
  PVOID v4; // rax

  v2 = a1;
  v3 = a2;
  v4 = ExAllocatePoolWithTag(PagedPool, a2, 0x33737049u);
  *v2 = v4;
  if ( v4 && (signed int)RtlCreateAcl(v4, v3, 4i64) < 0 )
  {
    ExFreePoolWithTag(*v2, 0);
    *v2 = 0i64;
  }
  return v2;
}
// 1400292C0: using guessed type __int64 __fastcall RtlCreateAcl(_QWORD, _QWORD, _QWORD);

//----- (0000000140006E08) ----------------------------------------------------
void __fastcall sub_140006E08(void **a1)
{
  void *v1; // rcx

  v1 = *a1;
  if ( v1 )
    ExFreePoolWithTag(v1, 0);
}

//----- (0000000140006E24) ----------------------------------------------------
void **__fastcall sub_140006E24(void **a1, void **a2)
{
  void **v2; // rdi
  void **v3; // rbx
  void *v4; // rcx

  v2 = a2;
  v3 = a1;
  if ( a2 != a1 )
  {
    v4 = *a1;
    if ( v4 )
      ExFreePoolWithTag(v4, 0);
    *v3 = *v2;
    *v2 = 0i64;
  }
  return v3;
}

//----- (0000000140006E64) ----------------------------------------------------
void **__fastcall sub_140006E64(void **a1, __int64 *a2)
{
  __int64 *v2; // rdi
  void **v3; // rbx
  void *v4; // rcx

  v2 = a2;
  v3 = a1;
  if ( a1 != (void **)a2 )
  {
    v4 = *a1;
    if ( v4 )
    {
      ExFreePoolWithTag(v4, 0);
      *v3 = 0i64;
    }
    if ( *v2 )
      *v3 = sub_1400071E8(*v2);
  }
  return v3;
}

//----- (0000000140006EAC) ----------------------------------------------------
bool __fastcall sub_140006EAC(_QWORD *a1)
{
  return *a1 != 0i64;
}

//----- (0000000140006EB4) ----------------------------------------------------
__m128 *__fastcall sub_140006EB4(__int64 *a1, __m128 *a2, __int64 a3, unsigned int a4)
{
  __m128 *v4; // rbx

  v4 = a2;
  sub_140006ED4(a2, *a1, a3, a4);
  return v4;
}

//----- (0000000140006ED4) ----------------------------------------------------
__m128 *__fastcall sub_140006ED4(__m128 *a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __m128 *v4; // rdi
  unsigned int v5; // ebp
  __int64 v6; // rsi
  __int64 v7; // r14
  unsigned __int64 v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rax
  void **v11; // rax
  int v12; // ebx
  __int64 v13; // rax
  int v14; // ebx
  __int64 v15; // rax
  __int64 v17; // [rsp+30h] [rbp-38h]

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = (unsigned int)RtlLengthSid(a3) + (unsigned __int64)*(unsigned __int16 *)(a2 + 2);
  sub_140002584(v4, 8ui64);
  sub_140006DAC((PVOID *)v4, v8 + 8);
  if ( sub_140001B3C((__int64)v4) )
  {
    v9 = sub_140001B3C((__int64)v4);
    if ( (signed int)sub_140007028(v9, v7) >= 0 )
    {
      sub_140007284(v4, v6, v5);
      v10 = sub_140001B3C((__int64)v4);
      if ( (signed int)RtlAddAccessAllowedAce(v10, 4i64, v5, v6) >= 0 )
      {
        v17 = 0i64;
        v12 = *(unsigned __int16 *)(sub_140001B3C((__int64)v4) + 4);
        v13 = sub_140001B3C((__int64)v4);
        v14 = RtlGetAce(v13, (unsigned int)(v12 - 1), &v17);
        if ( v14 >= 0 )
        {
          *(_BYTE *)(v17 + 1) = 3;
        }
        else
        {
          v15 = sub_140001B3C((__int64)v4);
          sub_140002E58(
            L"Unexpected failure to get ACE %d",
            v14,
            *(unsigned __int16 *)(v15 + 4) - 1,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsacl.cpp",
            172);
        }
      }
      else
      {
        v11 = (void **)unknown_libname_1(&v17);
        sub_140006E24((void **)v4, v11);
        sub_140006E08((void **)&v17);
      }
    }
  }
  return v4;
}
// 140001AB0: using guessed type __int64 __fastcall unknown_libname_1(_QWORD);
// 14001F950: using guessed type wchar_t aUnexpectedFail[33];
// 1400292B0: using guessed type __int64 __fastcall RtlLengthSid(_QWORD);
// 1400292D8: using guessed type __int64 __fastcall RtlGetAce(_QWORD, _QWORD, _QWORD);
// 1400292E0: using guessed type __int64 __fastcall RtlAddAccessAllowedAce(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140007028) ----------------------------------------------------
__int64 __fastcall sub_140007028(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rbp
  int v4; // ebx
  int v5; // edi
  int v6; // ST20_4
  int v7; // eax
  __int64 v9; // [rsp+30h] [rbp-28h]

  v2 = a2;
  v3 = a1;
  v4 = 0;
  v5 = 0;
  if ( *(_WORD *)(a2 + 4) > 0u )
  {
    do
    {
      v9 = 0i64;
      v4 = RtlGetAce(v2, (unsigned int)v5, &v9);
      if ( v4 >= 0 )
      {
        v6 = *(unsigned __int16 *)(v9 + 2);
        v7 = RtlAddAce(v3, 4i64, 0xFFFFFFFFi64);
        v4 = v7;
        if ( v7 < 0 )
          sub_140002E58(
            L"Unable to copy ACE %d",
            v7,
            v5,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsacl.cpp",
            40);
      }
      ++v5;
    }
    while ( v5 < *(unsigned __int16 *)(v2 + 4) );
  }
  return (unsigned int)v4;
}
// 14001F8E0: using guessed type wchar_t aUnableToCopyAc[22];
// 1400292C8: using guessed type __int64 __fastcall RtlAddAce(_QWORD, _QWORD, _QWORD);
// 1400292D8: using guessed type __int64 __fastcall RtlGetAce(_QWORD, _QWORD, _QWORD);

//----- (00000001400070EC) ----------------------------------------------------
void __fastcall sub_1400070EC(_QWORD *a1)
{
  _QWORD *v1; // rsi
  __int64 v2; // rcx
  unsigned int v3; // ebx
  unsigned int v4; // edi
  int v5; // ST28_4
  __int64 v6; // [rsp+30h] [rbp-358h]
  int v7; // [rsp+38h] [rbp-350h]
  char *v8; // [rsp+40h] [rbp-348h]
  char v9; // [rsp+50h] [rbp-338h]

  v1 = a1;
  v2 = *a1;
  v3 = 0;
  if ( *(_WORD *)(v2 + 4) > 0u )
  {
    do
    {
      if ( (signed int)RtlGetAce(v2, v3, &v6) >= 0 )
      {
        if ( !*(_BYTE *)v6 )
        {
          v4 = 43;
LABEL_7:
          v7 = 52428800;
          v8 = &v9;
          if ( (signed int)RtlConvertSidToUnicodeString(&v7, v6 + 8, 0i64) >= 0 )
          {
            v5 = *(_DWORD *)(v6 + 4);
            DbgPrintEx(80i64, 2i64, "%c %wZ: 0x%x\n", v4);
          }
          goto LABEL_9;
        }
        if ( *(_BYTE *)v6 == 1 )
        {
          v4 = 45;
          goto LABEL_7;
        }
      }
LABEL_9:
      v2 = *v1;
      ++v3;
    }
    while ( v3 < *(unsigned __int16 *)(*v1 + 4i64) );
  }
}
// 1400292B8: using guessed type __int64 __fastcall RtlConvertSidToUnicodeString(_QWORD, _QWORD, _QWORD);
// 1400292D8: using guessed type __int64 __fastcall RtlGetAce(_QWORD, _QWORD, _QWORD);

//----- (00000001400071E8) ----------------------------------------------------
void *__fastcall sub_1400071E8(__int64 a1)
{
  __int64 v1; // rsi
  PVOID v2; // rax
  void *v3; // rbx
  int v4; // eax
  int v5; // edi

  v1 = a1;
  v2 = ExAllocatePoolWithTag(PagedPool, *(unsigned __int16 *)(a1 + 2), 0x33737049u);
  v3 = v2;
  if ( v2 )
  {
    v4 = RtlCreateAcl(v2, *(unsigned __int16 *)(v1 + 2), 4i64);
    v5 = v4;
    if ( v4 >= 0 )
      v5 = sub_140007028((__int64)v3, v1);
    else
      sub_140002E58(
        L"Failed to construct an ACL",
        v4,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsacl.cpp",
        55);
    if ( v5 < 0 )
    {
      ExFreePoolWithTag(v3, 0);
      v3 = 0i64;
    }
  }
  return v3;
}
// 14001F910: using guessed type wchar_t aFailedToConstr[27];
// 1400292C0: using guessed type __int64 __fastcall RtlCreateAcl(_QWORD, _QWORD, _QWORD);

//----- (0000000140007284) ----------------------------------------------------
void __fastcall sub_140007284(_QWORD *a1, __int64 a2, int a3)
{
  _QWORD *v3; // rdi
  __int64 v4; // rcx
  int v5; // esi
  __int64 v6; // rbp
  unsigned int v7; // ebx
  int v8; // eax
  __int64 v9; // [rsp+30h] [rbp-28h]

  v3 = a1;
  v4 = *a1;
  v5 = a3;
  v6 = a2;
  v7 = 0;
  if ( *(_WORD *)(v4 + 4) > 0u )
  {
    do
    {
      if ( (signed int)RtlGetAce(v4, v7, &v9) >= 0 && *(_BYTE *)v9 <= 1u )
      {
        if ( (unsigned __int8)RtlEqualSid(v9 + 8, v6) )
        {
          *(_DWORD *)(v9 + 4) &= ~v5;
          if ( !*(_DWORD *)(v9 + 4) )
          {
            v8 = RtlDeleteAce(*v3, v7);
            if ( v8 >= 0 )
              --v7;
            else
              sub_140002E58(
                L"Failed to delete ACE at offet %d",
                v8,
                v7,
                (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsacl.cpp",
                210);
          }
        }
      }
      v4 = *v3;
      ++v7;
    }
    while ( v7 < *(unsigned __int16 *)(*v3 + 4i64) );
  }
}
// 14001F9A0: using guessed type wchar_t aFailedToDelete[33];
// 1400292A8: using guessed type __int64 __fastcall RtlEqualSid(_QWORD, _QWORD);
// 1400292D0: using guessed type __int64 __fastcall RtlDeleteAce(_QWORD, _QWORD);
// 1400292D8: using guessed type __int64 __fastcall RtlGetAce(_QWORD, _QWORD, _QWORD);

//----- (000000014000737C) ----------------------------------------------------
__int64 __fastcall sub_14000737C(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  unsigned __int64 v4; // rsi
  char v6; // [rsp+20h] [rbp-128h]

  v2 = a2;
  v3 = a1;
  sub_140007634(a1);
  *(_BYTE *)(v3 + 48) = 0;
  *(_QWORD *)(v3 + 56) = 0i64;
  *(_QWORD *)(v3 + 64) = 0i64;
  sub_14001E1C0((__m128 *)&v6, 0, 0x100ui64);
  v4 = sub_14000FD70(v2);
  if ( v4 > 0x100 )
    v4 = 256i64;
  if ( !(unsigned int)sub_14000FBF8(v2, (__int64)&v6, v4) )
    sub_1400102AC(v3, (__int64)&v6, v4);
  return v3;
}

//----- (0000000140007428) ----------------------------------------------------
__int64 __fastcall sub_140007428(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  sub_140007634(a1);
  *(_BYTE *)(v1 + 48) = 0;
  *(_QWORD *)(v1 + 56) = 0i64;
  *(_QWORD *)(v1 + 64) = 0i64;
  return v1;
}

//----- (0000000140007450) ----------------------------------------------------
__int64 __fastcall sub_140007450(__int64 a1, int a2, char a3, __int16 *a4)
{
  __int16 *v4; // rdi
  char v5; // bl
  int v6; // ebp
  __int64 v7; // rsi

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  sub_140007634(a1);
  *(_BYTE *)(v7 + 48) = v5;
  *(_QWORD *)(v7 + 56) = 0i64;
  *(_QWORD *)(v7 + 64) = 0i64;
  sub_1400100D8((_DWORD *)v7, v4);
  if ( sub_140019690() )
    sub_14001969C(v6, (__m128i *)(v7 + 56));
  return v7;
}

//----- (00000001400074BC) ----------------------------------------------------
__int64 __fastcall sub_1400074BC(__int64 a1, unsigned __int64 a2, int a3, int a4)
{
  __int64 v4; // rbx

  *(_QWORD *)a1 = 0i64;
  v4 = a1;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 24) = a3;
  *(_DWORD *)(a1 + 28) = a4;
  if ( !a2 )
  {
    a2 = 4i64;
    *(_QWORD *)(a1 + 8) = 4i64;
  }
  *(_QWORD *)a1 = sub_140007870(a1, a2);
  return v4;
}

//----- (00000001400074FC) ----------------------------------------------------
_DWORD *__fastcall sub_1400074FC(_DWORD *a1, __int64 a2, __m128i *a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rbp
  __m128i *v6; // rsi
  _DWORD *v7; // rbx
  __int64 (**v8)(void); // rax
  __int64 (*v9)(void); // rax
  __m128i v10; // xmm0
  __int128 v12; // [rsp+20h] [rbp-68h]
  int v13; // [rsp+30h] [rbp-58h]
  int v14; // [rsp+34h] [rbp-54h]
  __int64 v15; // [rsp+38h] [rbp-50h]
  __int64 v16; // [rsp+40h] [rbp-48h]
  __int64 v17; // [rsp+48h] [rbp-40h]

  v5 = a4;
  *a1 = 0;
  v6 = a3;
  a1[1] = -1073741823;
  v7 = a1;
  v8 = (__int64 (**)(void))sub_140013188();
  if ( v8 )
  {
    v9 = *v8;
    if ( v9 )
    {
      v10 = *v6;
      v14 = 0;
      v17 = 0i64;
      v13 = 0;
      _mm_storeu_si128((__m128i *)&v12, v10);
      v15 = v5;
      v16 = a5;
      v7[1] = sub_14001E1B0(v9);
    }
  }
  return v7;
}

//----- (0000000140007598) ----------------------------------------------------
__int64 __fastcall sub_140007598(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  unknown_libname_2(a1);
  *(_WORD *)(v1 + 16) = 0;
  return v1;
}
// 140003A00: using guessed type __int64 __fastcall unknown_libname_2(_QWORD);

//----- (00000001400075B8) ----------------------------------------------------
_QWORD *__fastcall sub_1400075B8(_QWORD *a1)
{
  _QWORD *v1; // rbx

  v1 = a1;
  *a1 = 0i64;
  sub_1400074BC((__int64)(a1 + 1), 0xCui64, 512, 1952671062);
  return v1;
}

//----- (00000001400075EC) ----------------------------------------------------
__int128 *__fastcall sub_1400075EC(__int128 *a1, __int64 a2)
{
  __int128 *v2; // rbx
  __int128 v3; // xmm0
  __int128 v4; // xmm1

  v2 = a1;
  *(_QWORD *)a1 = 0i64;
  *((_QWORD *)a1 + 1) = 0i64;
  *((_QWORD *)a1 + 2) = 0i64;
  v3 = *a1;
  *((_BYTE *)a1 + 24) = 1;
  v4 = *((unsigned __int64 *)a1 + 2);
  KeAcquireInStackQueuedSpinLock(a2);
  return v2;
}
// 1400292E8: using guessed type __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD);

//----- (0000000140007634) ----------------------------------------------------
__int64 __fastcall sub_140007634(__int64 a1)
{
  __int64 v1; // rbx
  __int64 result; // rax

  *(_DWORD *)a1 = 0;
  v1 = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  sub_140007598(a1 + 10);
  sub_140007598(v1 + 28);
  result = v1;
  *(_BYTE *)(v1 + 46) = 0;
  return result;
}

//----- (0000000140007668) ----------------------------------------------------
void __fastcall sub_140007668(void **a1)
{
  void *v1; // rcx

  v1 = *a1;
  if ( v1 )
    sub_140007714(v1);
}

//----- (0000000140007690) ----------------------------------------------------
void __fastcall sub_140007690(unsigned int *a1)
{
  int v1; // eax

  if ( (a1[1] & 0x80000000) == 0 )
  {
    v1 = FwpsCalloutUnregisterById0(*a1);
    if ( v1 < 0 )
      sub_140002E58(
        L"Failed to unregister callout",
        v1,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipscallout.cpp",
        144);
  }
}
// 14001DC66: using guessed type __int64 __fastcall FwpsCalloutUnregisterById0(_QWORD);
// 14001FA50: using guessed type wchar_t aFailedToUnregi[29];

//----- (00000001400076E0) ----------------------------------------------------
__int64 __fastcall sub_1400076E0(__int64 a1)
{
  __int64 result; // rax

  if ( a1 == 96 )
    result = sub_140003C60(&stru_140034480);
  else
    result = 0i64;
  return result;
}
// 140003C60: using guessed type __int64 __fastcall sub_140003C60(_QWORD);

//----- (0000000140007714) ----------------------------------------------------
void __fastcall sub_140007714(void *a1)
{
  ExFreePoolWithTag(a1, 0);
}

//----- (0000000140007720) ----------------------------------------------------
bool __fastcall sub_140007720(_DWORD *a1)
{
  return *a1 != 0;
}

//----- (0000000140007728) ----------------------------------------------------
__int64 __fastcall sub_140007728(__int64 a1, __int64 a2, __int64 a3, __int64 (*a4)(void))
{
  __int64 (*v4)(void); // rbp
  __int64 v5; // rbx
  __int64 v6; // rsi
  __int64 v7; // rdi
  __int64 result; // rax

  if ( a3 )
  {
    v4 = a4;
    v5 = a3;
    v6 = a2;
    v7 = a1 + a3 * a2;
    do
    {
      v7 -= v6;
      result = sub_14001E1B0(v4);
      --v5;
    }
    while ( v5 );
  }
  return result;
}

//----- (0000000140007780) ----------------------------------------------------
char __fastcall sub_140007780(_QWORD *a1, __m128i *a2)
{
  unsigned __int64 v2; // rax
  _QWORD *v3; // rbx
  unsigned __int64 v4; // rcx
  char v5; // di
  __m128i *v6; // rsi
  bool v7; // cf

  v2 = a1[2];
  v3 = a1;
  v4 = a1[1];
  v5 = 0;
  v6 = a2;
  v7 = v2 < v4;
  if ( v2 == v4 )
  {
    sub_140008358((__int64)v3, 2 * v4);
    v2 = v3[2];
    v7 = v2 < v3[1];
  }
  if ( v7 && *v3 )
  {
    v5 = 1;
    _mm_storeu_si128((__m128i *)(*v3 + 16 * v2), *v6);
    ++v3[2];
  }
  return v5;
}

//----- (00000001400077EC) ----------------------------------------------------
char __fastcall sub_1400077EC(__int64 a1, __m128i *a2, unsigned __int64 a3)
{
  _QWORD *v3; // rbp
  volatile signed __int64 *v4; // rbx
  unsigned __int64 v5; // r14
  __m128i *v6; // rsi
  unsigned __int64 v7; // rdi

  v3 = (_QWORD *)(a1 + 8);
  v4 = (volatile signed __int64 *)a1;
  v5 = a3;
  v6 = a2;
  sub_140007D60(a1 + 8);
  if ( !v6 )
    return 1;
  v7 = 0i64;
  if ( !v5 )
  {
LABEL_5:
    _InterlockedIncrement64(v4);
    return 1;
  }
  while ( sub_140007780(v3, v6) )
  {
    ++v7;
    ++v6;
    if ( v7 >= v5 )
      goto LABEL_5;
  }
  sub_140007D60((__int64)v3);
  return 0;
}

//----- (0000000140007870) ----------------------------------------------------
PVOID __fastcall sub_140007870(__int64 a1, unsigned __int64 a2)
{
  ULONG v3; // er8
  SIZE_T v4; // rax

  v3 = *(_DWORD *)(a1 + 28);
  v4 = 16 * a2;
  if ( !is_mul_ok(a2, 0x10ui64) )
    v4 = -1i64;
  if ( !v3 )
    v3 = 2003127881;
  return ExAllocatePoolWithTag((POOL_TYPE)*(_DWORD *)(a1 + 24), v4, v3);
}

//----- (0000000140007894) ----------------------------------------------------
char __fastcall sub_140007894(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rbp
  char v4; // si
  __int64 v5; // rdi
  signed __int64 v6; // rbx

  v2 = (_QWORD *)(a1 + 8);
  v3 = a2;
  v4 = 0;
  v5 = sub_140001B3C(a1 + 8);
  v6 = sub_1400083FC(v2);
  if ( v5 != v6 )
  {
    while ( !(unsigned int)unknown_libname_4(v5, v3) )
    {
      v5 += 16i64;
      if ( v5 == v6 )
        return v4;
    }
    v4 = 1;
  }
  return v4;
}
// 140008288: using guessed type __int64 __fastcall unknown_libname_4(_QWORD, _QWORD);

//----- (0000000140007904) ----------------------------------------------------
__int64 sub_140007904()
{
  unsigned int v0; // ebx
  __int64 v1; // rax
  int v2; // eax
  int v4; // [rsp+30h] [rbp-19h]
  __int128 *v5; // [rsp+38h] [rbp-11h]
  __m128 v6; // [rsp+40h] [rbp-9h]
  __m128 v7; // [rsp+50h] [rbp+7h]
  __int128 v8; // [rsp+60h] [rbp+17h]
  __int128 v9; // [rsp+70h] [rbp+27h]
  __int64 v10; // [rsp+80h] [rbp+37h]
  int v11; // [rsp+88h] [rbp+3Fh]
  __int16 v12; // [rsp+8Ch] [rbp+43h]

  v11 = 6619235;
  v0 = -1073741823;
  v8 = xmmword_14001FA90;
  v12 = 0;
  v10 = 29555379368231013i64;
  v5 = &v8;
  v9 = xmmword_14001FAA0;
  v4 = 2883628;
  sub_140002584(&v7, 0x10ui64);
  sub_140011AF8((__int64)&v7, (__int64)&v4);
  if ( sub_140006EAC(&v7) )
  {
    sub_140002584(&v6, 0x10ui64);
    sub_14000EB88((__int64)&v6, 0);
    if ( sub_140006EAC(&v6) )
    {
      v1 = sub_140001B3C((__int64)&v7);
      v2 = sub_14000EC28(&v6, v1, 0x1008Fu);
      v0 = v2;
      if ( v2 < 0 )
        sub_140002E58(
          L"Failed to grant SntpService access to WFP filter",
          v2,
          0,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipscallout.cpp",
          193);
    }
    else
    {
      v0 = sub_1400083D0((__int64)&v6);
      sub_140002E58(
        L"Failed to open WFP engine",
        v0,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipscallout.cpp",
        179);
    }
    sub_14000EC10(&v6);
  }
  else
  {
    sub_140002E58(
      L"Failed to get current process SID",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipscallout.cpp",
      199);
  }
  sub_140011CB4(&v7);
  return v0;
}
// 140011CB4: using guessed type __int64 __fastcall sub_140011CB4(_QWORD);
// 14001FA90: using guessed type __int128 xmmword_14001FA90;
// 14001FAA0: using guessed type __int128 xmmword_14001FAA0;
// 14001FAC0: using guessed type wchar_t aFailedToOpenWf[26];
// 14001FB00: using guessed type wchar_t aFailedToGrantS[49];
// 14001FB70: using guessed type wchar_t aFailedToGetCur[34];

//----- (0000000140007A74) ----------------------------------------------------
__int64 __fastcall sub_140007A74(__int64 a1, char a2)
{
  char v2; // bl
  __int64 v3; // rdi
  int v4; // eax
  __int64 v5; // rax
  char *v6; // rbx
  __int64 result; // rax
  __int64 v8; // rdx
  unsigned __int64 v9; // r8

  v2 = a2;
  v3 = a1;
  v4 = sub_140007904();
  if ( v4 < 0 )
    sub_140002E58(
      L"Failed to bless sntpservice; it probably won't be able to intercept network traffic.",
      v4,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipscallout.cpp",
      312);
  v5 = sub_140008568(v3);
  qword_140034448 = v5;
  if ( v2 )
  {
    v6 = (char *)&unk_140034500;
    if ( !(dword_140034530 & 1) )
    {
      dword_140034530 |= 1u;
      sub_1400074FC(&unk_140034500, v5, (__m128i *)&unk_14002E1E8, (__int64)sub_140007E30, (__int64)sub_140008240);
      sub_1400074FC(
        &unk_140034508,
        qword_140034448,
        (__m128i *)&unk_14002E1F8,
        (__int64)sub_140007E30,
        (__int64)sub_140008240);
      sub_1400074FC(
        &unk_140034510,
        qword_140034448,
        (__m128i *)&unk_14002E208,
        (__int64)sub_140007E30,
        (__int64)sub_140008240);
      sub_1400074FC(
        &unk_140034518,
        qword_140034448,
        (__m128i *)&unk_14002E218,
        (__int64)sub_140007E30,
        (__int64)sub_140008240);
      sub_1400074FC(
        &unk_140034520,
        qword_140034448,
        (__m128i *)&unk_14002E268,
        (__int64)sub_140007D80,
        (__int64)sub_140008240);
      sub_1400074FC(
        &unk_140034528,
        qword_140034448,
        (__m128i *)&unk_14002E278,
        (__int64)sub_140007D80,
        (__int64)sub_140008240);
      sub_1400194B0((__int64)sub_140027EA0);
    }
  }
  else
  {
    v6 = (char *)&unk_140034540;
    if ( !(dword_140034530 & 2) )
    {
      dword_140034530 |= 2u;
      sub_1400074FC(&unk_140034540, v5, (__m128i *)&unk_14002E1C8, (__int64)sub_140007F00, (__int64)sub_140008240);
      sub_1400074FC(
        &unk_140034548,
        qword_140034448,
        (__m128i *)&unk_14002E1D8,
        (__int64)sub_140008200,
        (__int64)sub_140008240);
      sub_1400074FC(
        &unk_140034550,
        qword_140034448,
        (__m128i *)&unk_14002E1E8,
        (__int64)sub_140007E30,
        (__int64)sub_140008240);
      sub_1400074FC(
        &unk_140034558,
        qword_140034448,
        (__m128i *)&unk_14002E1F8,
        (__int64)sub_140007E30,
        (__int64)sub_140008240);
      sub_1400074FC(
        &unk_140034560,
        qword_140034448,
        (__m128i *)&unk_14002E208,
        (__int64)sub_140007E30,
        (__int64)sub_140008240);
      sub_1400074FC(
        &unk_140034568,
        qword_140034448,
        (__m128i *)&unk_14002E218,
        (__int64)sub_140007E30,
        (__int64)sub_140008240);
      sub_1400074FC(
        &unk_140034570,
        qword_140034448,
        (__m128i *)&unk_14002E268,
        (__int64)sub_140007D80,
        (__int64)sub_140008240);
      sub_1400074FC(
        &unk_140034578,
        qword_140034448,
        (__m128i *)&unk_14002E278,
        (__int64)sub_140007D80,
        (__int64)sub_140008240);
      sub_1400194B0((__int64)sub_140027EC0);
    }
  }
  do
  {
    result = sub_1400083C8((__int64)v6);
    if ( (signed int)result < 0 )
      break;
    v6 += 8;
  }
  while ( v8 + 1 < v9 );
  return result;
}
// 14001FBC0: using guessed type wchar_t aFailedToBlessS[85];
// 140034448: using guessed type __int64 qword_140034448;
// 140034530: using guessed type int dword_140034530;

//----- (0000000140007D54) ----------------------------------------------------
bool __fastcall sub_140007D54(_QWORD *a1, __int64 a2)
{
  return a2 == *a1;
}

//----- (0000000140007D60) ----------------------------------------------------
void __fastcall sub_140007D60(__int64 a1)
{
  *(_QWORD *)(a1 + 16) = 0i64;
}

//----- (0000000140007D68) ----------------------------------------------------
char *__fastcall sub_140007D68(unsigned int a1)
{
  return (char *)&unk_140034AC0 + 8 * a1;
}

//----- (0000000140007D80) ----------------------------------------------------
char __fastcall sub_140007D80(__int16 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, _DWORD *a7)
{
  __int64 v7; // rsi
  __int16 *v8; // rdi
  int v9; // eax
  void *v10; // rax
  char v12; // [rsp+20h] [rbp-68h]

  v7 = a2;
  v8 = a1;
  LOBYTE(v9) = sub_140007D54(qword_140034450, *(_QWORD *)(a5 + 48));
  if ( (_BYTE)v9 )
  {
    v9 = sub_140009B58();
    if ( v9 )
    {
      sub_140007450((__int64)&v12, *(_QWORD *)(v7 + 64), 0, v8);
      LOBYTE(v9) = sub_1400083F4(&v12);
      if ( (_BYTE)v9 )
      {
        v10 = sub_140012DDC();
        LOBYTE(v9) = sub_14000850C((__int64)v10, (__int64)&v12);
      }
    }
  }
  *a7 = 4098;
  return v9;
}
// 1400083F4: using guessed type __int64 __fastcall sub_1400083F4(_QWORD);

//----- (0000000140007E30) ----------------------------------------------------
char __fastcall sub_140007E30(unsigned __int16 *a1, int *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, _DWORD *a7)
{
  int *v7; // rbx
  unsigned __int16 *v8; // rdi
  int v9; // eax
  char v10; // al
  void *v11; // rax
  char v13; // [rsp+20h] [rbp-68h]

  v7 = a2;
  v8 = a1;
  LOBYTE(v9) = sub_140007D54(qword_140034450, *(_QWORD *)(a5 + 48));
  if ( (_BYTE)v9 )
  {
    v9 = sub_140009B58();
    if ( v9 )
    {
      LOBYTE(v9) = sub_1400059F8(v8);
      if ( !(_BYTE)v9 )
      {
        v9 = *v7;
        if ( *v7 & 0x20 )
        {
          v10 = sub_1400082A4(*((_QWORD *)v7 + 8));
          sub_140007450((__int64)&v13, *((_QWORD *)v7 + 8), v10, (__int16 *)v8);
          LOBYTE(v9) = sub_1400083F4(&v13);
          if ( (_BYTE)v9 )
          {
            v11 = sub_140012DDC();
            LOBYTE(v9) = sub_1400084A4((__int64)v11, (__int64)&v13, 0i64);
          }
        }
      }
    }
  }
  *a7 = 4098;
  return v9;
}
// 1400083F4: using guessed type __int64 __fastcall sub_1400083F4(_QWORD);

//----- (0000000140007F00) ----------------------------------------------------
void __fastcall sub_140007F00(__int64 a1, __int64 a2, __int64 a3)
{
  sub_140007F38(a1, a2, a3);
}

//----- (0000000140007F38) ----------------------------------------------------
void __fastcall sub_140007F38(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // ebx
  char v4; // r14
  __int64 v5; // r15
  __int64 v6; // rsi
  char *v7; // rax
  __int64 v8; // rax
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  _DWORD *v12; // rax
  __int32 v13; // er12
  void *v14; // rax
  __m128i v15; // xmm6
  __m128 *v16; // rax
  __m128i *v17; // rsi
  __m128i *v18; // rsi
  __int64 v19; // rax
  __int32 v20; // [rsp+40h] [rbp-88h]
  __m128i v21; // [rsp+50h] [rbp-78h]
  __m128i v22; // [rsp+60h] [rbp-68h]
  char v23; // [rsp+78h] [rbp-50h]
  __int64 v24; // [rsp+148h] [rbp+80h]
  _DWORD *retaddr; // [rsp+158h] [rbp+90h]
  int v26; // [rsp+160h] [rbp+98h]

  v3 = 1;
  v4 = 0;
  v5 = a3;
  v6 = a1;
  if ( retaddr[6] & 1 )
  {
    v7 = sub_140007D68(1u);
    v8 = sub_140001B3C((__int64)v7);
    if ( ((unsigned int)FwpsQueryPacketInjectionState0(v8, v5, 0i64) - 1) & 0xFFFFFFFD )
    {
      v9 = sub_1400091F4(v5, v26);
      if ( !v9 )
      {
        v3 = 2;
        goto LABEL_29;
      }
      v10 = v9 - 1;
      if ( !v10 )
      {
        v3 = 7;
        goto LABEL_34;
      }
      v11 = v10 - 1;
      if ( v11 )
      {
        if ( v11 == 1 )
        {
LABEL_7:
          v3 = 6;
          goto LABEL_34;
        }
      }
      else
      {
        sub_14000A1BC(0, v26);
        if ( !sub_140007D54(qword_140034450, *(_QWORD *)(v24 + 48)) || !(unsigned int)sub_140009B58() )
          goto LABEL_7;
        v12 = *(_DWORD **)(v6 + 8);
        if ( v12[16] != 3 )
          goto LABEL_34;
        v20 = v12[18];
        if ( v20 == -1 )
          goto LABEL_34;
        if ( v12[20] != 3 )
          goto LABEL_34;
        v13 = v12[22];
        if ( v13 == -1 )
          goto LABEL_34;
        sub_14000737C((__int64)&v23, v5);
        sub_14001E1C0((__m128 *)&v22, 0, 0x48ui64);
        sub_140007428((__int64)&v22);
        v21 = 0ui64;
        v14 = sub_140012DDC();
        if ( sub_140008408((__int64)v14, (__int64)&v23, (__int64)&v22) )
        {
          v15 = v22;
          if ( v21.m128i_i8[8] )
          {
            v3 = 3;
            goto LABEL_34;
          }
        }
        else
        {
          v15 = v21;
        }
        v16 = (__m128 *)sub_1400076E0(96i64);
        v17 = (__m128i *)v16;
        if ( v16 )
        {
          sub_140002584(v16, 0x60ui64);
          _mm_store_si128(&v21, v15);
          v18 = sub_14000EE6C(v17, v5, v26, v20, v13, &v21, 0i64);
        }
        else
        {
          v18 = 0i64;
        }
        if ( !v18 )
        {
          sub_140002DD4(
            L"Failed to construct Intercept object",
            0i64,
            0i64,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipscallout.cpp",
            470);
          goto LABEL_34;
        }
        if ( (unsigned __int8)sub_14001E1B0(*(__int64 (**)(void))(v18->m128i_i64[0] + 56)) )
          v4 = sub_14000A10C((__int64)v18);
        else
          sub_140002DD4(
            L"Intercept object not valid",
            0i64,
            0i64,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipscallout.cpp",
            464);
        sub_14001E1B0(*(__int64 (**)(void))(v18->m128i_i64[0] + 40));
      }
    }
    else
    {
      v3 = 4;
    }
    if ( !v4 )
    {
LABEL_34:
      v19 = v24;
      *retaddr = 4098;
      if ( *(_BYTE *)(v19 + 26) & 1 )
        retaddr[6] &= 0xFFFFFFFE;
LABEL_30:
      sub_14000A1BC(v3, 0);
      return;
    }
LABEL_29:
    retaddr[6] &= 0xFFFFFFFE;
    retaddr[7] |= 1u;
    *retaddr = 4097;
    if ( v4 )
      return;
    goto LABEL_30;
  }
}
// 14001DCC0: using guessed type __int64 __fastcall FwpsQueryPacketInjectionState0(_QWORD, _QWORD, _QWORD);
// 14001FC70: using guessed type wchar_t aInterceptObjec[27];
// 14001FCB0: using guessed type wchar_t aFailedToConstr_0[37];

//----- (0000000140008200) ----------------------------------------------------
void __fastcall sub_140008200(__int64 a1, __int64 a2, __int64 a3)
{
  sub_140007F38(a1, a2, a3);
}

//----- (0000000140008240) ----------------------------------------------------
__int64 __fastcall sub_140008240(int a1, __int64 a2, __int64 a3)
{
  unsigned int v3; // er9

  v3 = -1073741823;
  if ( !a1 )
  {
    if ( !a2 || !sub_1400082E0(qword_140034450, a2, (_QWORD *)(a3 + 48)) )
      return (unsigned int)-1073741692;
    goto LABEL_6;
  }
  if ( a1 == 1 )
  {
    *(_QWORD *)(a3 + 48) = 0i64;
LABEL_6:
    v3 = 0;
  }
  return v3;
}

//----- (00000001400082A4) ----------------------------------------------------
char __fastcall sub_1400082A4(__int64 a1)
{
  __int64 v1; // rdi
  char v2; // bl

  v1 = a1;
  v2 = 0;
  if ( sub_140004E14(a1) || sub_140004E4C(v1, 0i64, 0, 1) )
    v2 = 1;
  return v2;
}

//----- (00000001400082E0) ----------------------------------------------------
char __fastcall sub_1400082E0(_QWORD *a1, __int64 a2, _QWORD *a3)
{
  __int64 v3; // rsi
  _QWORD *v4; // rdi
  _QWORD *v5; // r14
  char v6; // bl
  __int64 v8; // [rsp+20h] [rbp-38h]
  __int64 v9; // [rsp+28h] [rbp-30h]

  v3 = a2;
  v4 = a1;
  v8 = 0i64;
  v9 = 0i64;
  v5 = a3;
  v6 = 0;
  if ( !(unsigned int)unknown_libname_4(a2, &v8) && sub_140007894((__int64)v4, v3) )
  {
    v6 = 1;
    *v5 = *v4;
  }
  return v6;
}
// 140008288: using guessed type __int64 __fastcall unknown_libname_4(_QWORD, _QWORD);

//----- (0000000140008358) ----------------------------------------------------
void __fastcall sub_140008358(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  unsigned __int64 *v3; // rbx
  __m128i *v4; // rax
  __m128i *v5; // rdi

  v2 = a2;
  v3 = (unsigned __int64 *)a1;
  v4 = (__m128i *)sub_140007870(a1, a2);
  v5 = v4;
  if ( v4 )
  {
    sub_14001E2C0(v4, *v3, 16 * v3[2]);
    sub_140007714((void *)*v3);
    *v3 = (unsigned __int64)v5;
    v3[1] = v2;
  }
}

//----- (00000001400083B4) ----------------------------------------------------
char __fastcall sub_1400083B4(__m128i *a1, unsigned __int64 a2)
{
  return sub_1400077EC((__int64)qword_140034450, a1, a2);
}

//----- (00000001400083C8) ----------------------------------------------------
__int64 __fastcall sub_1400083C8(__int64 a1)
{
  return *(unsigned int *)(a1 + 4);
}

//----- (00000001400083D0) ----------------------------------------------------
__int64 __fastcall sub_1400083D0(__int64 a1)
{
  return *(unsigned int *)(a1 + 8);
}

//----- (00000001400083D4) ----------------------------------------------------
__int64 __fastcall sub_1400083D4(__int64 a1)
{
  __int64 v1; // rbx
  __int64 result; // rax

  v1 = a1;
  if ( *(_BYTE *)(a1 + 24) )
  {
    result = KeReleaseInStackQueuedSpinLock(a1);
    *(_BYTE *)(v1 + 24) = 0;
  }
  return result;
}
// 1400292F0: using guessed type __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD);

//----- (00000001400083FC) ----------------------------------------------------
signed __int64 __fastcall sub_1400083FC(_QWORD *a1)
{
  return *a1 + 16i64 * a1[2];
}

//----- (0000000140008408) ----------------------------------------------------
char __fastcall sub_140008408(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rsi
  char v6; // bp
  __int64 v7; // rax
  char v9; // [rsp+20h] [rbp-48h]

  v3 = a2;
  v4 = a1;
  v5 = a3;
  v6 = 0;
  sub_1400075EC((__int128 *)&v9, a1 + 104);
  v7 = RtlLookupElementGenericTableAvl(v4, v3);
  if ( v7 )
  {
    v6 = 1;
    *(_OWORD *)v5 = *(_OWORD *)v7;
    *(_OWORD *)(v5 + 16) = *(_OWORD *)(v7 + 16);
    *(_OWORD *)(v5 + 32) = *(_OWORD *)(v7 + 32);
    *(_OWORD *)(v5 + 48) = *(_OWORD *)(v7 + 48);
    *(_QWORD *)(v5 + 64) = *(_QWORD *)(v7 + 64);
  }
  sub_1400076D8(&v9);
  return v6;
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);
// 140012EFC: using guessed type __int64 __fastcall RtlLookupElementGenericTableAvl(_QWORD, _QWORD);

//----- (00000001400084A4) ----------------------------------------------------
char __fastcall sub_1400084A4(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 v3; // rsi
  __int64 v4; // rdi
  __int64 *v5; // rbx
  char v7; // [rsp+20h] [rbp-48h]

  v3 = a2;
  v4 = a1;
  v5 = a3;
  sub_1400075EC((__int128 *)&v7, a1 + 104);
  LOBYTE(v5) = sub_140012F04(v4, v3, 72i64, v5);
  sub_1400076D8(&v7);
  return (char)v5;
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);

//----- (000000014000850C) ----------------------------------------------------
__int64 __fastcall sub_14000850C(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  char v5; // [rsp+20h] [rbp-38h]

  v2 = a2;
  v3 = a1;
  sub_1400075EC((__int128 *)&v5, a1 + 104);
  RtlDeleteElementGenericTableAvl(v3, v2);
  return sub_1400076D8(&v5);
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);
// 140012F54: using guessed type __int64 __fastcall RtlDeleteElementGenericTableAvl(_QWORD, _QWORD);

//----- (0000000140008568) ----------------------------------------------------
__int64 __fastcall sub_140008568(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_1400368C8);
}
// 1400368C8: using guessed type __int64 qword_1400368C8;
// 140037458: using guessed type __int64 qword_140037458;

//----- (0000000140008608) ----------------------------------------------------
signed __int64 __fastcall sub_140008608(_QWORD *a1, __int64 a2)
{
  signed __int64 result; // rax

  if ( !a1 )
    return 0i64;
  a1[1] = 0i64;
  result = (signed __int64)(a1 + 3);
  a1[2] = 0i64;
  *a1 = a2;
  return result;
}

//----- (0000000140008630) ----------------------------------------------------
void __fastcall sub_140008630(__int64 a1, unsigned int *a2)
{
  sub_140008E30(0i64, a1, a2);
}

//----- (0000000140008640) ----------------------------------------------------
char __fastcall sub_140008640(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_140008E88(0i64, a1, a2, a3);
}

//----- (0000000140008650) ----------------------------------------------------
char __fastcall sub_140008650(__int64 a1, unsigned int *a2)
{
  return sub_140008EA8(0i64, a1, a2);
}

//----- (0000000140008660) ----------------------------------------------------
char __fastcall sub_140008660(__int64 a1, unsigned int *a2)
{
  return sub_140008EC4(0i64, a1, a2);
}

//----- (0000000140008670) ----------------------------------------------------
NTSTATUS sub_140008670()
{
  return sub_140008F58();
}

//----- (0000000140008680) ----------------------------------------------------
char __fastcall sub_140008680(__int64 a1, unsigned int *a2)
{
  return sub_14000939C(a2, 0, a1 + 40);
}

//----- (0000000140008690) ----------------------------------------------------
PVOID *__fastcall sub_140008690(PVOID *a1, SIZE_T a2)
{
  PVOID *v2; // rbx

  v2 = a1;
  *a1 = ExAllocatePoolWithTag(PagedPool, a2, 0x46737049u);
  return v2;
}

//----- (00000001400086B8) ----------------------------------------------------
struct _LIST_ENTRY *__fastcall sub_1400086B8(struct _LIST_ENTRY *a1)
{
  struct _LIST_ENTRY *v1; // rbx

  v1 = a1;
  a1->Flink = 0i64;
  a1->Blink = 0i64;
  a1[1].Flink = 0i64;
  InitializeListHead(a1);
  return v1;
}

//----- (00000001400086DC) ----------------------------------------------------
_QWORD *__fastcall sub_1400086DC(_QWORD *a1)
{
  _QWORD *v1; // rbx

  v1 = a1;
  sub_14000896C(a1);
  unknown_libname_1(v1 + 1);
  sub_14000896C(v1 + 2);
  sub_1400086B8((struct _LIST_ENTRY *)(v1 + 3));
  sub_1400086B8((struct _LIST_ENTRY *)v1 + 3);
  return v1;
}
// 140001AB0: using guessed type __int64 __fastcall unknown_libname_1(_QWORD);

//----- (0000000140008718) ----------------------------------------------------
_QWORD *__fastcall sub_140008718(_QWORD *a1, _QWORD *a2)
{
  _QWORD *result; // rax

  *a1 = *a2;
  a1[1] = a2[1];
  result = a1;
  a2[1] = 0i64;
  return result;
}

//----- (0000000140008730) ----------------------------------------------------
__int64 *__fastcall sub_140008730(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rbx
  __int64 v3; // rax

  *a1 = a2;
  v2 = a1;
  v3 = *(_QWORD *)(a2 + 24);
  a1[1] = v3;
  if ( v3 )
    sub_1400090DC(a2);
  return v2;
}

//----- (000000014000875C) ----------------------------------------------------
_QWORD *__fastcall sub_14000875C(_QWORD *a1)
{
  _QWORD *result; // rax

  *a1 = 0i64;
  result = a1;
  a1[1] = 0i64;
  return result;
}

//----- (000000014000876C) ----------------------------------------------------
PHANDLE __fastcall sub_14000876C(PHANDLE FileHandle, __int64 a2)
{
  PHANDLE v2; // rbx
  __int64 v4; // [rsp+60h] [rbp-58h]
  __int64 v5; // [rsp+68h] [rbp-50h]
  __int64 v6; // [rsp+70h] [rbp-48h]
  __int64 v7; // [rsp+78h] [rbp-40h]
  __int64 v8; // [rsp+80h] [rbp-38h]
  __int64 v9; // [rsp+90h] [rbp-28h]
  __int64 v10; // [rsp+98h] [rbp-20h]

  v2 = FileHandle;
  v6 = a2;
  v4 = 48i64;
  *FileHandle = 0i64;
  *((_DWORD *)FileHandle + 2) = 0;
  v5 = 0i64;
  v7 = 576i64;
  _mm_storeu_si128((__m128i *)&v8, (__m128i)0i64);
  v9 = 0i64;
  v10 = 0i64;
  *((_DWORD *)FileHandle + 2) = ZwCreateFile(
                                  FileHandle,
                                  0x80u,
                                  (POBJECT_ATTRIBUTES)&v4,
                                  (PIO_STATUS_BLOCK)&v9,
                                  0i64,
                                  0x80u,
                                  7u,
                                  1u,
                                  0x140u,
                                  0i64,
                                  0);
  return v2;
}

//----- (0000000140008820) ----------------------------------------------------
PVOID *__fastcall sub_140008820(PVOID *Object, HANDLE Handle, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode)
{
  PVOID *v5; // rbx

  v5 = Object;
  *Object = 0i64;
  *((_DWORD *)Object + 2) = 0;
  *((_DWORD *)Object + 2) = ObReferenceObjectByHandle(Handle, DesiredAccess, ObjectType, AccessMode, Object, 0i64);
  return v5;
}

//----- (0000000140008864) ----------------------------------------------------
_QWORD *__fastcall sub_140008864(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *result; // rax

  *a1 = 0i64;
  v1 = a1;
  sub_14000896C(a1 + 1);
  v1[3] = 0i64;
  result = v1;
  *((_DWORD *)v1 + 4) = 0;
  return result;
}

//----- (0000000140008890) ----------------------------------------------------
_QWORD *__fastcall sub_140008890(_QWORD *a1)
{
  _QWORD *v1; // rbx

  v1 = a1;
  sub_1400086DC(a1);
  sub_1400086DC(v1 + 9);
  sub_1400086DC(v1 + 18);
  sub_1400086DC(v1 + 27);
  *((_WORD *)v1 + 144) = 0;
  return v1;
}

//----- (00000001400088D0) ----------------------------------------------------
__int64 __fastcall sub_1400088D0(__int64 a1)
{
  __int64 v1; // rdi
  _QWORD *v2; // rbx
  __int64 v3; // rax

  v1 = a1;
  sub_14000F6F0(a1, 10485760i64, 1);
  v2 = sub_14000F824((SIZE_T *)v1);
  v3 = sub_140001B3C(v1);
  sub_140011F6C((_QWORD *)(v1 + 40), v2, v3);
  *(_DWORD *)(v1 + 120) = 0;
  *(_BYTE *)(v1 + 124) = 1;
  sub_14000896C((_QWORD *)(v1 + 128));
  *(_QWORD *)(v1 + 136) = 0i64;
  if ( !sub_14000FA44((SIZE_T *)v1) )
  {
    *(_DWORD *)(v1 + 120) = -1073741670;
    sub_140002E58(
      L"Failed to allocate shared memory for UKIF",
      -1073741670,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsdevice.cpp",
      265);
  }
  return v1;
}
// 14001FD50: using guessed type wchar_t aFailedToAlloca_2[42];

//----- (000000014000896C) ----------------------------------------------------
_QWORD *__fastcall sub_14000896C(_QWORD *a1)
{
  _QWORD *v1; // rbx

  *a1 = 0i64;
  v1 = a1;
  sub_14000AD60(a1);
  return v1;
}

//----- (0000000140008988) ----------------------------------------------------
__int64 __fastcall sub_140008988(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  *(_QWORD *)a1 = 0i64;
  *(_DWORD *)(a1 + 8) = 0;
  v2 = a1;
  *(_DWORD *)(a1 + 8) = IoQueryFileDosDeviceName(a2, a1);
  return v2;
}
// 140029250: using guessed type __int64 __fastcall IoQueryFileDosDeviceName(_QWORD, _QWORD);

//----- (00000001400089B4) ----------------------------------------------------
__int64 __fastcall sub_1400089B4(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  __int64 v3; // rbx

  v3 = a1;
  sub_1400089D4(a1, 0, a2, a3);
  return v3;
}

//----- (00000001400089D4) ----------------------------------------------------
int *__fastcall sub_1400089D4(__int64 a1, int a2, unsigned __int8 *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rsi
  __int64 v5; // rbp
  int *v6; // rdi
  unsigned int v7; // eax
  unsigned __int64 v8; // rsi
  _BYTE *v9; // rax

  *(_DWORD *)(a1 + 20) = 0;
  v4 = a4;
  *(_DWORD *)(a1 + 28) = 0;
  v5 = (__int64)a3;
  *(_DWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = a4;
  v6 = (int *)a1;
  *(_QWORD *)a1 = a3;
  *(_DWORD *)(a1 + 24) = a2;
  v7 = sub_140009AC8(a2, a3, a4, (_DWORD *)(a1 + 16));
  v6[7] = v7;
  if ( v7 )
  {
    v8 = v4 - v7;
    v9 = (_BYTE *)sub_140006988(v5, v7);
    v6[8] = v6[7] + (unsigned __int64)sub_1400099CC(v9, v8, v6[4], v6 + 5);
  }
  return v6;
}

//----- (0000000140008A6C) ----------------------------------------------------
__int64 *__fastcall sub_140008A6C(__int64 *a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 *v3; // rdi
  __m128 v5; // [rsp+20h] [rbp-18h]

  a1[1] = 0i64;
  v2 = a2;
  *a1 = a2;
  v3 = a1;
  sub_140002584(&v5, 0x10ui64);
  sub_1400097D4(v2, (__int64 *)&v5);
  if ( sub_140008E08((__int64)&v5) )
  {
    sub_1400090DC(*v3);
    v3[1] = sub_140008E08((__int64)&v5) + 40;
  }
  sub_140008BD0((__int64 *)&v5);
  return v3;
}

//----- (0000000140008AE4) ----------------------------------------------------
void __fastcall sub_140008AE4(void **a1)
{
  void *v1; // rcx

  v1 = *a1;
  if ( v1 )
    ExFreePoolWithTag(v1, 0x46737049u);
}

//----- (0000000140008B20) ----------------------------------------------------
__int64 __fastcall sub_140008B20(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  sub_140008B00(a1 + 48);
  sub_140008B00(v1 + 24);
  return sub_140008C98(v1 + 8);
}
// 140008B00: using guessed type __int64 __fastcall sub_140008B00(_QWORD);
// 140008C98: using guessed type __int64 __fastcall sub_140008C98(_QWORD);

//----- (0000000140008B4C) ----------------------------------------------------
__int64 __fastcall sub_140008B4C(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  sub_140008B08(a1 + 48);
  sub_140008B08(v1 + 24);
  return sub_140008C98(v1 + 8);
}
// 140008B08: using guessed type __int64 __fastcall sub_140008B08(_QWORD);
// 140008C98: using guessed type __int64 __fastcall sub_140008C98(_QWORD);

//----- (0000000140008B78) ----------------------------------------------------
__int64 __fastcall sub_140008B78(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  sub_140008B10(a1 + 48);
  sub_140008B10(v1 + 24);
  return sub_140008C98(v1 + 8);
}
// 140008B10: using guessed type __int64 __fastcall sub_140008B10(_QWORD);
// 140008C98: using guessed type __int64 __fastcall sub_140008C98(_QWORD);

//----- (0000000140008BA4) ----------------------------------------------------
__int64 __fastcall sub_140008BA4(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  sub_140008B18(a1 + 48);
  sub_140008B18(v1 + 24);
  return sub_140008C98(v1 + 8);
}
// 140008B18: using guessed type __int64 __fastcall sub_140008B18(_QWORD);
// 140008C98: using guessed type __int64 __fastcall sub_140008C98(_QWORD);

//----- (0000000140008BD0) ----------------------------------------------------
void __fastcall sub_140008BD0(__int64 *a1)
{
  __int64 v1; // rcx

  if ( a1[1] )
  {
    v1 = *a1;
    if ( v1 )
      sub_140009F2C(v1);
  }
}

//----- (0000000140008BF0) ----------------------------------------------------
NTSTATUS __fastcall sub_140008BF0(__int64 a1)
{
  NTSTATUS result; // eax

  if ( *(_DWORD *)(a1 + 8) >= 0 )
    result = ZwClose(*(HANDLE *)a1);
  return result;
}

//----- (0000000140008C08) ----------------------------------------------------
LONG_PTR __fastcall sub_140008C08(__int64 a1)
{
  LONG_PTR result; // rax

  if ( *(_DWORD *)(a1 + 8) >= 0 )
    result = ObfDereferenceObject(*(PVOID *)a1);
  return result;
}

//----- (0000000140008C20) ----------------------------------------------------
__int64 __fastcall sub_140008C20(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  sub_140008B4C(a1 + 216);
  sub_140008B20(v1 + 144);
  sub_140008BA4(v1 + 72);
  return sub_140008B78(v1);
}

//----- (0000000140008C58) ----------------------------------------------------
__int64 __fastcall sub_140008C58(__int64 a1)
{
  _QWORD *v1; // rbx

  v1 = (_QWORD *)a1;
  sub_140009118(a1);
  sub_140012014((__int64)(v1 + 5));
  return sub_14000F77C(v1);
}

//----- (0000000140008C7C) ----------------------------------------------------
void __fastcall sub_140008C7C(__int64 a1)
{
  if ( *(_DWORD *)(a1 + 8) >= 0 )
    ExFreePoolWithTag(*(PVOID *)a1, 0);
}

//----- (0000000140008CA0) ----------------------------------------------------
void __fastcall sub_140008CA0(__int64 *a1)
{
  __int64 v1; // rcx

  v1 = *a1;
  if ( v1 )
    sub_140009F2C(v1);
}

//----- (0000000140008CB8) ----------------------------------------------------
__int64 __fastcall sub_140008CB8(__int64 a1, __int64 a2)
{
  return a2;
}

//----- (0000000140008CBC) ----------------------------------------------------
PSLIST_ENTRY __fastcall sub_140008CBC(struct _SLIST_ENTRY *a1)
{
  return sub_14000424C(&stru_140034940.L.ListHead, a1);
}

//----- (0000000140008CCC) ----------------------------------------------------
PSLIST_ENTRY __fastcall sub_140008CCC(struct _SLIST_ENTRY *a1)
{
  return sub_14000424C(&stru_1400348C0.L.ListHead, a1);
}

//----- (0000000140008CDC) ----------------------------------------------------
PSLIST_ENTRY __fastcall sub_140008CDC(struct _SLIST_ENTRY *a1)
{
  return sub_14000424C(&stru_140034A40.L.ListHead, a1);
}

//----- (0000000140008CEC) ----------------------------------------------------
PSLIST_ENTRY __fastcall sub_140008CEC(struct _SLIST_ENTRY *a1)
{
  return sub_14000424C(&stru_1400349C0.L.ListHead, a1);
}

//----- (0000000140008CFC) ----------------------------------------------------
__int64 __fastcall sub_140008CFC(__int64 a1, __int64 a2)
{
  _DWORD *v2; // r8
  __int64 v3; // r10
  signed __int64 v4; // r9
  _DWORD *v5; // r8
  signed __int64 v6; // r9

  v2 = (_DWORD *)(a1 + 128);
  v3 = a2 - a1;
  v4 = 8i64;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  do
  {
    *v2 = *(_DWORD *)((char *)v2 + v3);
    ++v2;
    --v4;
  }
  while ( v4 );
  v5 = (_DWORD *)(a1 + 160);
  v6 = 11i64;
  do
  {
    *v5 = *(_DWORD *)((char *)v5 + v3);
    ++v5;
    --v6;
  }
  while ( v6 );
  *(_QWORD *)(a1 + 208) = *(_QWORD *)(a2 + 208);
  *(_DWORD *)(a1 + 216) = *(_DWORD *)(a2 + 216);
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a2 + 220);
  *(_QWORD *)(a1 + 224) = *(_QWORD *)(a2 + 224);
  return a1;
}

//----- (0000000140008DBC) ----------------------------------------------------
bool __fastcall sub_140008DBC(_QWORD *a1, __int64 a2)
{
  return a2 != *a1;
}

//----- (0000000140008DC4) ----------------------------------------------------
void (__fastcall *sub_140008DC4())(__int64 a1, unsigned int *a2)
{
  return sub_140008630;
}

//----- (0000000140008DCC) ----------------------------------------------------
char (__fastcall *sub_140008DCC())(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_140008640;
}

//----- (0000000140008DD4) ----------------------------------------------------
char (__fastcall *sub_140008DD4())(__int64 a1, unsigned int *a2)
{
  return sub_140008650;
}

//----- (0000000140008DDC) ----------------------------------------------------
char (__fastcall *sub_140008DDC())(__int64 a1, unsigned int *a2)
{
  return sub_140008660;
}

//----- (0000000140008DE4) ----------------------------------------------------
NTSTATUS (*sub_140008DE4())()
{
  return sub_140008670;
}

//----- (0000000140008DEC) ----------------------------------------------------
char (__fastcall *sub_140008DEC())(__int64 a1, unsigned int *a2)
{
  return sub_140008680;
}

//----- (0000000140008DF4) ----------------------------------------------------
__int16 __fastcall sub_140008DF4(unsigned __int8 *a1)
{
  return a1[1] + (*a1 << 8);
}

//----- (0000000140008E08) ----------------------------------------------------
__int64 __fastcall sub_140008E08(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (0000000140008E10) ----------------------------------------------------
bool __fastcall sub_140008E10(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) != 0i64;
}

//----- (0000000140008E1C) ----------------------------------------------------
bool __fastcall sub_140008E1C(__int64 a1)
{
  return *(_DWORD *)(a1 + 8) >= 0;
}

//----- (0000000140008E28) ----------------------------------------------------
bool __fastcall sub_140008E28(__int64 a1)
{
  return *(_DWORD *)(a1 + 28) != 0;
}

//----- (0000000140008E30) ----------------------------------------------------
void __fastcall sub_140008E30(__int64 a1, __int64 a2, unsigned int *a3)
{
  CPullPin *v3; // rbx

  v3 = (CPullPin *)(a2 + 40);
  sub_14000939C(a3, 1u, a2 + 40);
  CPullPin::Process(v3);
}

//----- (0000000140008E88) ----------------------------------------------------
char __fastcall sub_140008E88(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  if ( a4 )
    sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)a4 + 8i64));
  return 1;
}

//----- (0000000140008EA8) ----------------------------------------------------
char __fastcall sub_140008EA8(__int64 a1, __int64 a2, unsigned int *a3)
{
  sub_14000939C(a3, 2u, a2 + 40);
  return 1;
}

//----- (0000000140008EC4) ----------------------------------------------------
char __fastcall sub_140008EC4(__int64 a1, __int64 a2, unsigned int *a3)
{
  unsigned int *v3; // rsi
  __int64 v4; // rdi
  signed __int64 v5; // rbx
  __int64 v6; // rax
  char v8; // [rsp+20h] [rbp-48h]

  v3 = a3;
  v4 = a2;
  v5 = sub_1400096C0(a3);
  v6 = sub_1400096B8((__int64)v3);
  sub_14000FEA0((__int64)&v8, v6, v5);
  if ( sub_140009BF0(v3) && sub_14000FEFC(*(unsigned int **)(v4 + 8), (unsigned int *)&v8) )
    sub_1400121B0(*(_QWORD *)v4, (__int64)v3);
  return 1;
}

//----- (0000000140008F58) ----------------------------------------------------
NTSTATUS sub_140008F58()
{
  LARGE_INTEGER Interval; // [rsp+20h] [rbp-18h]

  Interval.QuadPart = -1i64;
  return KeDelayExecutionThread(0, 0, &Interval);
}

//----- (0000000140008FA4) ----------------------------------------------------
__int64 __fastcall sub_140008FA4(__int64 a1, char a2)
{
  __int64 v2; // rbx

  v2 = a1;
  if ( a2 & 1 && a2 & 4 )
    nullsub_1(a1, 24i64);
  return v2;
}
// 140004C90: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);

//----- (0000000140008FCC) ----------------------------------------------------
__int64 __fastcall sub_140008FCC(__int64 a1, char a2)
{
  char v2; // di
  __int64 v3; // rbx

  v2 = a2;
  v3 = a1;
  sub_140008C58(a1);
  if ( v2 & 1 && v2 & 4 )
    nullsub_1(v3, 144i64);
  return v3;
}
// 140004C90: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);

//----- (0000000140009008) ----------------------------------------------------
__int64 __fastcall sub_140009008(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax
  char v5; // [rsp+28h] [rbp-50h]
  __int64 (__fastcall *v6)(__int64); // [rsp+30h] [rbp-48h]
  void *v7; // [rsp+58h] [rbp-20h]

  v1 = sub_14000A3E4(a1);
  if ( v1
    || (sub_14000AD68((__m128 *)&v5), v7 = off_1400300A0, v6 = sub_140009BD0, (signed int)sub_14000AD94() >= 0)
    && ((v2 = sub_140008CB8(144i64, 0i64)) == 0 ? (v1 = 0i64) : (v1 = sub_1400088D0(v2)), v1) )
  {
    if ( !*(_BYTE *)(v1 + 124) )
    {
      v3 = sub_140008CB8(144i64, v1);
      if ( v3 )
        v1 = sub_1400088D0(v3);
      else
        v1 = 0i64;
    }
  }
  return v1;
}
// 1400300A0: using guessed type void *off_1400300A0;

//----- (00000001400090DC) ----------------------------------------------------
void __fastcall sub_1400090DC(__int64 a1)
{
  _InterlockedIncrement((volatile signed __int32 *)(a1 + 16));
}

//----- (00000001400090E4) ----------------------------------------------------
signed __int64 __fastcall sub_1400090E4(unsigned int a1)
{
  signed __int64 result; // rax
  __int64 v2; // r9

  result = 0i64;
  v2 = 0i64;
  while ( a1 > dword_1400300B0[v2] )
  {
    result = (unsigned int)(result + 1);
    v2 = (unsigned int)result;
    if ( (unsigned int)result >= 7ui64 )
      return 7i64;
  }
  return result;
}

//----- (0000000140009118) ----------------------------------------------------
__int64 __fastcall sub_140009118(__int64 a1)
{
  __int64 result; // rax

  result = sub_140009724(a1, 0i64);
  if ( result )
    result = sub_14000ADD8(result);
  return result;
}

//----- (0000000140009140) ----------------------------------------------------
__int64 __fastcall sub_140009140(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 result; // rax

  v1 = a1;
  v2 = sub_14000ADF4(a1);
  if ( v2 && (v3 = sub_14000A3E4(v2)) != 0 )
    result = sub_140009184(v3, v1);
  else
    result = sub_14000ADD8(v1);
  return result;
}

//----- (0000000140009184) ----------------------------------------------------
__int64 __fastcall sub_140009184(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  char v5; // [rsp+20h] [rbp-38h]

  v2 = a2;
  v3 = a1;
  sub_1400075EC((__int128 *)&v5, a1 + 128);
  if ( v2 == *(_QWORD *)(v3 + 136) )
    *(_QWORD *)(v3 + 136) = 0i64;
  sub_14000ADD8(v2);
  return sub_1400076D8(&v5);
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);

//----- (00000001400091F4) ----------------------------------------------------
__int64 __fastcall sub_1400091F4(__int64 a1, int a2)
{
  int v2; // esi
  __int64 v3; // r14
  unsigned int v4; // ebx
  unsigned __int64 v5; // rdi
  __m128 *v6; // rax
  __m128 *v7; // rax
  int v8; // eax
  __m128 v10; // [rsp+30h] [rbp-D0h]
  char v11; // [rsp+40h] [rbp-C0h]
  char v12; // [rsp+68h] [rbp-98h]
  __m128 v13[16]; // [rsp+A0h] [rbp-60h]

  v2 = a2;
  v3 = a1;
  v4 = 2;
  sub_140002584(&v10, 0x10ui64);
  sub_1400097D4((__int64)qword_140034798, (__int64 *)&v10);
  if ( sub_140008E10((__int64)&v10) )
  {
    sub_14001E1C0(v13, 0, 0x100ui64);
    v5 = sub_14000FD70(v3);
    if ( v5 > 0x100 )
      v5 = 256i64;
    if ( !(unsigned int)sub_14000FBF8(v3, (__int64)v13, v5) )
    {
      sub_140002584((__m128 *)&v11, 0x28ui64);
      sub_1400089B4((__int64)&v11, (unsigned __int8 *)v13, v5);
      if ( sub_140008E28((__int64)&v11) )
      {
        v6 = sub_1400098B4();
        if ( sub_14000CDCC((__int64)v6, (__int64)&v11, v2) )
        {
          v4 = 1;
        }
        else
        {
          sub_14000FEA0((__int64)&v12, (__int64)v13, v5);
          if ( sub_140007720(&v12) )
          {
            v7 = sub_140009940(0i64);
            v8 = sub_140010C78((__int64)v7, (__int64)&v11, v2 == 1);
            if ( v8 )
            {
              if ( v8 == 1 )
              {
                v4 = 0;
                sub_140002DD4(
                  L"Packet stream blacklisted!",
                  0i64,
                  0i64,
                  (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsdevice.cpp",
                  1296);
              }
            }
            else
            {
              v4 = 1;
              sub_140002DD4(
                L"Packet stream whitelisted",
                0i64,
                0i64,
                (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsdevice.cpp",
                1300);
            }
          }
        }
      }
      else
      {
        v4 = 3;
      }
    }
  }
  sub_140008BD0((__int64 *)&v10);
  return v4;
}
// 1400202C0: using guessed type wchar_t aPacketStreamBl[27];
// 140020300: using guessed type wchar_t aPacketStreamWh[26];

//----- (000000014000939C) ----------------------------------------------------
char __fastcall sub_14000939C(unsigned int *a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // rdi
  unsigned int v4; // ebp
  unsigned int *v5; // rsi
  signed __int64 v6; // rbx
  __int64 v7; // rax
  int v8; // eax
  __m128 *v9; // rbx
  __int64 v10; // rax
  char (__fastcall *v11)(__int64, unsigned int *); // rax
  __int64 v13; // [rsp+28h] [rbp-60h]
  char *v14; // [rsp+30h] [rbp-58h]
  char v15; // [rsp+38h] [rbp-50h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = sub_1400096C0(a1);
  v7 = sub_1400096B8((__int64)v5);
  sub_14000FEA0((__int64)&v15, v7, v6);
  LOBYTE(v8) = sub_140007720(&v15);
  if ( (_BYTE)v8 )
  {
    v9 = sub_140009940(0i64);
    v10 = sub_1400096C0(v5);
    v8 = sub_140010EF4((__int64)v9, (__int64)&v15, v4, v10);
    if ( !v8 )
    {
      v13 = v3;
      v14 = &v15;
      v11 = sub_140008DDC();
      LOBYTE(v8) = sub_14001252C(v3, v11, &v13, 0i64);
    }
  }
  return v8;
}
// 14001252C: using guessed type __int64 __fastcall sub_14001252C(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140009460) ----------------------------------------------------
__int64 __fastcall sub_140009460(__int64 *a1)
{
  __int64 *i; // rdi
  struct _SLIST_ENTRY *v2; // rbx
  __int64 result; // rax

  for ( i = a1; ; a1 = i )
  {
    result = IsListEmpty(a1);
    if ( (_BYTE)result )
      break;
    v2 = (struct _SLIST_ENTRY *)sub_14000970C(i);
    sub_140004F48((__int64 **)i);
    sub_140008CBC(v2);
  }
  i[2] = 0i64;
  return result;
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);

//----- (00000001400094A8) ----------------------------------------------------
__int64 __fastcall sub_1400094A8(__int64 *a1)
{
  __int64 *i; // rdi
  struct _SLIST_ENTRY *v2; // rbx
  __int64 result; // rax

  for ( i = a1; ; a1 = i )
  {
    result = IsListEmpty(a1);
    if ( (_BYTE)result )
      break;
    v2 = (struct _SLIST_ENTRY *)sub_14000970C(i);
    sub_140004F48((__int64 **)i);
    sub_140008CCC(v2);
  }
  i[2] = 0i64;
  return result;
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);

//----- (00000001400094F0) ----------------------------------------------------
__int64 __fastcall sub_1400094F0(__int64 *a1)
{
  __int64 *i; // rdi
  struct _SLIST_ENTRY *v2; // rbx
  __int64 result; // rax

  for ( i = a1; ; a1 = i )
  {
    result = IsListEmpty(a1);
    if ( (_BYTE)result )
      break;
    v2 = (struct _SLIST_ENTRY *)sub_14000970C(i);
    sub_140004F48((__int64 **)i);
    sub_140008CDC(v2);
  }
  i[2] = 0i64;
  return result;
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);

//----- (0000000140009538) ----------------------------------------------------
__int64 __fastcall sub_140009538(__int64 *a1)
{
  __int64 *i; // rdi
  struct _SLIST_ENTRY *v2; // rbx
  __int64 result; // rax

  for ( i = a1; ; a1 = i )
  {
    result = IsListEmpty(a1);
    if ( (_BYTE)result )
      break;
    v2 = (struct _SLIST_ENTRY *)sub_14000970C(i);
    sub_140004F48((__int64 **)i);
    sub_140008CEC(v2);
  }
  i[2] = 0i64;
  return result;
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);

//----- (0000000140009580) ----------------------------------------------------
char __fastcall sub_140009580(__int64 *a1)
{
  __int64 *v1; // rdi
  __int64 v2; // rax
  __int64 v3; // rbx
  __int128 v5; // [rsp+28h] [rbp-38h]
  __int64 v6; // [rsp+38h] [rbp-28h]
  unsigned int v7; // [rsp+40h] [rbp-20h]
  __int64 v8; // [rsp+48h] [rbp-18h]

  v1 = a1;
  LOBYTE(v2) = sub_1400128AC((__int64)(a1 + 5));
  if ( (_BYTE)v2 )
  {
    v2 = sub_140009724((__int64)v1, 0i64);
    v3 = v2;
    if ( v2 )
    {
      v8 = 0i64;
      v5 = 0ui64;
      v6 = 0i64;
      v7 = 0;
      LODWORD(v2) = sub_14000AE54();
      if ( (signed int)v2 >= 0 )
      {
        if ( sub_140012768((__int64)(v1 + 5), (__int64)&v5) )
        {
          sub_14000F908(v1, (__int64)&v5, 3ui64);
          _InterlockedIncrement(&dword_140034600[(unsigned int)sub_1400090E4(v7)]);
          MEMORY[0] = v5;
          MEMORY[0x10] = v6;
          MEMORY[0x18] = v7;
          LOBYTE(v2) = sub_14000AE80(v3);
        }
        else
        {
          v2 = sub_140009724((__int64)v1, v3);
          v3 = v2;
        }
      }
      if ( v3 )
        LOBYTE(v2) = sub_14000ADD8(v3);
    }
  }
  return v2;
}

//----- (00000001400096A4) ----------------------------------------------------
__int64 __fastcall sub_1400096A4(unsigned __int8 *a1)
{
  return sub_140008DF4(a1) & 3;
}

//----- (00000001400096B8) ----------------------------------------------------
signed __int64 __fastcall sub_1400096B8(__int64 a1)
{
  return a1 + 48;
}

//----- (00000001400096C0) ----------------------------------------------------
signed __int64 __fastcall sub_1400096C0(unsigned int *a1)
{
  __int64 v1; // rax

  v1 = *a1;
  LODWORD(v1) = v1 & 0x7FFFFFFF;
  return v1 - 48;
}

//----- (00000001400096CC) ----------------------------------------------------
void __fastcall sub_1400096CC(__int64 a1)
{
  void *v1; // rbx
  char v2; // [rsp+30h] [rbp+8h]

  if ( a1 )
  {
    v1 = (void *)a1;
    sub_140008FA4(a1, 0);
    sub_140009714((__int64)&v2, v1);
  }
}

//----- (00000001400096F4) ----------------------------------------------------
__int64 __fastcall sub_1400096F4(__int64 a1)
{
  return (unsigned __int16)sub_140008DF4((unsigned __int8 *)(a1 + 4));
}

//----- (000000014000970C) ----------------------------------------------------
__int64 __fastcall sub_14000970C(__int64 *a1)
{
  return sub_140009E44(*a1);
}

//----- (0000000140009714) ----------------------------------------------------
void __fastcall sub_140009714(__int64 a1, void *a2)
{
  ExFreePoolWithTag(a2, 0x6970734Cu);
}

//----- (0000000140009724) ----------------------------------------------------
__int64 __fastcall sub_140009724(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 v4; // rax
  char v6; // [rsp+20h] [rbp-38h]

  v2 = a2;
  v3 = a1;
  sub_1400075EC((__int128 *)&v6, a1 + 128);
  if ( !v2 || (unsigned int)sub_14000AE0C(v2) != -1073741536 )
  {
    v4 = sub_140009F34(v3, v2);
    v2 = v4;
    if ( v4 && (unsigned int)sub_14000AE9C(v4) == -1073741536 )
      v2 = 0i64;
  }
  sub_1400076D8(&v6);
  return v2;
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);

//----- (00000001400097C4) ----------------------------------------------------
void *__fastcall sub_1400097C4(int a1)
{
  JUMPOUT(a1, 1, sub_140009878);
  return sub_1400098BC();
}

//----- (00000001400097D4) ----------------------------------------------------
__int64 *__fastcall sub_1400097D4(__int64 a1, __int64 *a2)
{
  __int64 *v2; // rdi
  __int64 v3; // rbx
  char v5; // [rsp+20h] [rbp-38h]

  v2 = a2;
  v3 = a1;
  sub_1400075EC((__int128 *)&v5, a1 + 8);
  sub_140008730(v2, v3);
  sub_1400076D8(&v5);
  return v2;
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);

//----- (0000000140009838) ----------------------------------------------------
__int64 __fastcall sub_140009838(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // rbx
  __int64 v3; // rax

  v1 = a1;
  if ( (unsigned int)sub_14000A1A8(a1) != 2 && (unsigned int)sub_14000A1A8(v1) )
    return 0i64;
  v3 = sub_14000A368(v1);
  return sub_140006988((__int64)v1, v3);
}

//----- (0000000140009878) ----------------------------------------------------
void *sub_140009878()
{
  if ( !(dword_1400347D8 & 1) )
  {
    dword_1400347D8 |= 1u;
    sub_140006614(&unk_1400347B8);
    sub_1400194B0((__int64)sub_140027F40);
  }
  return &unk_1400347B8;
}
// 1400347D8: using guessed type int dword_1400347D8;

//----- (00000001400098B4) ----------------------------------------------------
__m128 *sub_1400098B4()
{
  return stru_140034670;
}

//----- (00000001400098BC) ----------------------------------------------------
void *sub_1400098BC()
{
  if ( !(dword_140034800 & 1) )
  {
    dword_140034800 |= 1u;
    sub_14000663C(&unk_1400347E0);
    sub_1400194B0((__int64)sub_140027F50);
  }
  return &unk_1400347E0;
}
// 140034800: using guessed type int dword_140034800;

//----- (00000001400098F8) ----------------------------------------------------
__int64 __fastcall sub_1400098F8(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // rbx
  _BYTE *v2; // rax
  signed __int64 v3; // rax

  v1 = a1;
  v2 = (_BYTE *)sub_140009838(a1);
  if ( !v2 || *v2 != -86 || v2[1] != -86 )
    return 0i64;
  v3 = sub_14000A368(v1);
  return sub_140006988((__int64)v1, v3 + 2);
}

//----- (0000000140009940) ----------------------------------------------------
__m128 *__fastcall sub_140009940(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  if ( !(dword_140034880 & 1) )
  {
    dword_140034880 |= 1u;
    sub_140002584(stru_140034810, 0x70ui64);
    sub_140010750(stru_140034810, v1);
    sub_1400194B0((__int64)sub_140027F60);
  }
  return stru_140034810;
}
// 140034880: using guessed type int dword_140034880;

//----- (0000000140009998) ----------------------------------------------------
__int64 *__fastcall sub_140009998(__int64 *a1)
{
  __int64 *v1; // rbx

  v1 = a1;
  sub_140008A6C(a1, (__int64)qword_140034798);
  return v1;
}

//----- (00000001400099B8) ----------------------------------------------------
char __fastcall sub_1400099B8(unsigned __int8 *a1)
{
  return (unsigned __int8)sub_140008DF4(a1) >> 7;
}

//----- (00000001400099CC) ----------------------------------------------------
signed __int64 __fastcall sub_1400099CC(_BYTE *a1, unsigned __int64 a2, int a3, _DWORD *a4)
{
  _BYTE *v4; // rsi
  unsigned __int64 v5; // rbp
  __int64 v6; // rdi
  unsigned __int64 v7; // rbx
  unsigned int v8; // ecx
  int v9; // ecx
  signed __int64 v10; // rax
  unsigned __int8 v11; // cl
  unsigned int v13; // ecx
  signed __int64 v14; // rax

  v4 = a4;
  v5 = a2;
  v6 = (__int64)a1;
  if ( a3 != 2048 )
  {
    if ( a3 == 34525 )
    {
      v7 = 40i64;
      if ( a2 >= 0x28 )
      {
        *a4 = (unsigned __int8)a1[6];
        while ( 1 )
        {
          v8 = (unsigned __int8)*v4;
          if ( v8 > 0x33 )
            break;
          if ( v8 >= 0x32 )
            goto LABEL_15;
          if ( !*v4 )
            goto LABEL_15;
          v9 = v8 - 43;
          if ( !v9 )
            goto LABEL_15;
          if ( v9 != 1 )
            return v7;
          v10 = 8i64;
LABEL_17:
          v7 += v10;
          *(_DWORD *)v4 = *(unsigned __int8 *)sub_140006988(v6, v7);
          if ( v5 < v7 )
            return 0i64;
        }
        if ( v8 != 60 && (v8 <= 0x8A || v8 > 0x8C && v8 - 253 > 1) )
          return v7;
LABEL_15:
        v11 = *(_BYTE *)(sub_140006988(v6, v7) + 1);
        if ( !v11 )
          return 0i64;
        v10 = v11;
        goto LABEL_17;
      }
    }
    return 0i64;
  }
  if ( a2 < 0x14 )
    return 0i64;
  v13 = *a1 & 0xF;
  *a4 = *(unsigned __int8 *)(v6 + 9);
  v14 = 5i64;
  if ( (unsigned __int8)v13 > 5u )
    v14 = v13;
  return 4 * v14;
}

//----- (0000000140009AC8) ----------------------------------------------------
signed __int64 __fastcall sub_140009AC8(int a1, unsigned __int8 *a2, unsigned __int64 a3, _DWORD *a4)
{
  _DWORD *v4; // rsi
  unsigned __int8 *v5; // rdi
  __int64 v6; // rax
  signed __int64 result; // rax
  int v8; // ecx

  v4 = a4;
  v5 = a2;
  if ( a1 )
  {
    if ( a1 == 16 && a3 > 0x1E && a3 > sub_14000A368(a2) + 8 )
    {
      v6 = sub_140009938(v5);
      if ( v6 )
      {
        *v4 = sub_1400096F4(v6);
        return sub_14000A368(v5) + 8;
      }
    }
  }
  else if ( a3 > 0xE )
  {
    v8 = (unsigned __int16)sub_140008DF4(a2 + 12);
    result = 14i64;
    *v4 = v8;
    return result;
  }
  *v4 = 0;
  return 0i64;
}
// 140009938: using guessed type __int64 __fastcall sub_140009938(_QWORD);

//----- (0000000140009B58) ----------------------------------------------------
__int64 sub_140009B58()
{
  return sub_140009B64(qword_140034798);
}

//----- (0000000140009B64) ----------------------------------------------------
__int64 __fastcall sub_140009B64(_QWORD *a1)
{
  _QWORD *v1; // rdi
  unsigned int v2; // ebx
  char v4; // [rsp+20h] [rbp-38h]

  v1 = a1;
  sub_1400075EC((__int128 *)&v4, (__int64)(a1 + 1));
  v2 = 0;
  if ( *v1 && v1[3] )
    v2 = 1;
  sub_1400076D8(&v4);
  return v2;
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);

//----- (0000000140009BD0) ----------------------------------------------------
__int64 __fastcall sub_140009BD0(__int64 a1)
{
  __int64 result; // rax

  result = sub_14000A3E4(a1);
  if ( result )
    result = sub_140008FCC(result, 0);
  return result;
}

//----- (0000000140009BF0) ----------------------------------------------------
bool __fastcall sub_140009BF0(_DWORD *a1)
{
  return *a1 >= 0;
}

//----- (0000000140009BFC) ----------------------------------------------------
char sub_140009BFC()
{
  char v0; // bl
  int v1; // eax
  __int64 v2; // rdi
  void *v3; // rdi
  __int64 v4; // rdi
  unsigned __int16 *v5; // rax
  const wchar_t **v6; // rsi
  void **v7; // rdi
  char result; // al
  PVOID v9; // [rsp+30h] [rbp-50h]
  unsigned int v10; // [rsp+38h] [rbp-48h]
  char v11; // [rsp+3Ch] [rbp-44h]
  __int16 v12; // [rsp+40h] [rbp-40h]
  char v13; // [rsp+48h] [rbp-38h]
  PVOID Object; // [rsp+58h] [rbp-28h]
  HANDLE FileHandle; // [rsp+68h] [rbp-18h]

  v0 = 0;
  v10 = 0;
  v1 = sub_1400050B8();
  if ( v1 == -1073741820 && v10 )
  {
    sub_140002584((__m128 *)&v9, 8ui64);
    sub_140008690(&v9, v10);
    v2 = sub_140001B3C((__int64)&v9);
    if ( v2 )
    {
      if ( (signed int)sub_1400050B8() >= 0 )
      {
        sub_140002584((__m128 *)&FileHandle, 0x10ui64);
        sub_14000876C(&FileHandle, v2);
        v3 = (void *)sub_140001B3C((__int64)&FileHandle);
        if ( v3 )
        {
          sub_140002584((__m128 *)&Object, 0x10ui64);
          sub_140008820(&Object, v3, 0x80u, 0i64, 0);
          v4 = sub_140001B3C((__int64)&Object);
          if ( v4 )
          {
            sub_140002584((__m128 *)&v13, 0x10ui64);
            sub_140008988((__int64)&v13, v4);
            if ( sub_140008E1C((__int64)&v13) )
            {
              v5 = (unsigned __int16 *)sub_140001B3C((__int64)&v13);
              v11 = 0;
              v12 = 0;
              v6 = (const wchar_t **)v5;
              if ( sub_140002B68(v5, &v11, &v12) )
              {
                if ( !v12 || v12 == 67 )
                {
                  v7 = (void **)off_14002E2A0;
                  while ( wcsnicmp(v6[1], (const wchar_t *)*v7, (unsigned __int64)*(unsigned __int16 *)v6 >> 1) )
                  {
                    ++v7;
                    if ( v7 == &off_14002E2B0 )
                      goto LABEL_17;
                  }
                  v0 = 1;
                }
              }
            }
LABEL_17:
            sub_140008C7C((__int64)&v13);
          }
          sub_140008C08((__int64)&Object);
        }
        sub_140008BF0((__int64)&FileHandle);
      }
    }
    else
    {
      sub_140002E58(
        L"Failed to allocate buffer for process image file name",
        -1073741820,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsdevice.cpp",
        790);
    }
    sub_140008AE4(&v9);
    result = v0;
  }
  else
  {
    sub_140002E58(
      L"Could not get process image file name",
      v1,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsdevice.cpp",
      783);
    result = 0;
  }
  return result;
}
// 14001FFD0: using guessed type wchar_t aCouldNotGetPro[38];
// 140020020: using guessed type wchar_t aFailedToAlloca[54];
// 14002E2A0: using guessed type wchar_t *off_14002E2A0[2];
// 14002E2B0: using guessed type void *off_14002E2B0;

//----- (0000000140009E30) ----------------------------------------------------
void sub_140009E30()
{
  JUMPOUT(&loc_1400090F8);
}

//----- (0000000140009E44) ----------------------------------------------------
__int64 __fastcall sub_140009E44(__int64 a1)
{
  return sub_140006988(a1, 0i64);
}

//----- (0000000140009E4C) ----------------------------------------------------
__int64 __fastcall sub_140009E4C(__int64 *a1, __int64 a2, unsigned __int64 a3, __int64 (*a4)(void))
{
  __int64 (*v4)(void); // r15
  __int64 *v5; // rbp
  signed int v6; // edi
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // rsi
  __int64 v9; // rdx
  __int64 v11; // [rsp+20h] [rbp-48h]
  unsigned __int64 v12; // [rsp+28h] [rbp-40h]

  v4 = a4;
  v5 = a1;
  v6 = -1073741789;
  if ( a3 >= 8 )
  {
    v7 = 0i64;
    v6 = sub_14000AE28();
    if ( v6 >= 0 )
    {
      v8 = v12 >> 3;
      if ( sub_14000F868(v5, v11, v12 >> 3) )
      {
        if ( v8 )
        {
          do
          {
            v9 = *(_QWORD *)(v11 + 8 * v7);
            sub_14001E1B0(v4);
            ++v7;
          }
          while ( v7 < v8 );
        }
      }
      else
      {
        v6 = -1073741823;
      }
    }
  }
  return (unsigned int)v6;
}

//----- (0000000140009F04) ----------------------------------------------------
signed __int32 *sub_140009F04()
{
  unsigned int v0; // eax
  __int64 v1; // rcx
  signed __int32 *result; // rax

  sub_140009E30();
  v1 = v0;
  result = dword_140034620;
  _InterlockedIncrement(&dword_140034620[v1]);
  return result;
}

//----- (0000000140009F20) ----------------------------------------------------
volatile signed __int32 *__fastcall sub_140009F20(volatile signed __int32 *a1)
{
  volatile signed __int32 *result; // rax

  result = 0i64;
  if ( !_InterlockedAdd(a1, 0xFFFFFFFF) )
    result = a1;
  return result;
}

//----- (0000000140009F2C) ----------------------------------------------------
void __fastcall sub_140009F2C(__int64 a1)
{
  _InterlockedDecrement((volatile signed __int32 *)(a1 + 16));
}

//----- (0000000140009F34) ----------------------------------------------------
__int64 __fastcall sub_140009F34(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 136);
  *(_QWORD *)(a1 + 136) = a2;
  return result;
}

//----- (0000000140009F44) ----------------------------------------------------
void __fastcall sub_140009F44(volatile signed __int32 **a1)
{
  volatile signed __int32 **v1; // rbx
  volatile signed __int32 *v2; // rcx
  volatile signed __int32 *v3; // rax

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    v3 = sub_140009F20(v2);
    sub_1400096CC((__int64)v3);
    *v1 = 0i64;
  }
}

//----- (0000000140009F6C) ----------------------------------------------------
_QWORD *__fastcall sub_140009F6C(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  _QWORD *v3; // rdi
  _QWORD *v4; // rsi
  __int64 v5; // rbx
  __m128 v7; // [rsp+20h] [rbp-48h]
  char v8; // [rsp+30h] [rbp-38h]

  v3 = a2;
  v4 = a1;
  v5 = a3;
  sub_1400075EC((__int128 *)&v8, (__int64)(a1 + 1));
  if ( *v4 == v5 )
  {
    sub_140002584(&v7, 0x10ui64);
    sub_140008730((__int64 *)&v7, (__int64)v4);
    *v4 = 0i64;
    v4[3] = 0i64;
    sub_140008718(v3, &v7);
    sub_140008BD0((__int64 *)&v7);
  }
  else
  {
    sub_14000875C(v3);
  }
  sub_1400076D8(&v8);
  return v3;
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);

//----- (000000014000A020) ----------------------------------------------------
__int64 __fastcall sub_14000A020(__int64 a1, __int64 (*a2)(void))
{
  __int64 (*v2)(void); // rsi
  __int64 v3; // rbx

  v2 = a2;
  if ( !*(_BYTE *)(a1 + 24) )
    return sub_14001E1B0(a2);
  v3 = *(_QWORD *)(a1 + 8);
  KeReleaseInStackQueuedSpinLock(a1);
  sub_14001E1B0(v2);
  return KeAcquireInStackQueuedSpinLock(v3);
}
// 1400292E8: using guessed type __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD);
// 1400292F0: using guessed type __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD);

//----- (000000014000A078) ----------------------------------------------------
__int64 __fastcall sub_14000A078(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rbx
  __int64 v3; // rsi
  __int64 v4; // rdi
  __int64 v5; // rbp
  char v7; // [rsp+20h] [rbp-48h]

  v2 = a1;
  v3 = a2;
  v4 = 0i64;
  v5 = sub_140009008(a2);
  if ( v5 )
  {
    sub_1400075EC((__int128 *)&v7, (__int64)(v2 + 1));
    v4 = *v2;
    *v2 = 0i64;
    sub_14000A25C((__int64)v2, (__int64)&v7);
    *v2 = v3;
    v2[3] = v5;
    sub_1400076D8(&v7);
  }
  return v4;
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);

//----- (000000014000A100) ----------------------------------------------------
unsigned __int64 __fastcall sub_14000A100(__int64 a1, unsigned int a2)
{
  unsigned __int64 result; // rax

  result = (unsigned __int64)a2 << 10;
  *(_QWORD *)(a1 + 80) = result;
  return result;
}

//----- (000000014000A10C) ----------------------------------------------------
char __fastcall sub_14000A10C(__int64 a1)
{
  __int64 v1; // rsi
  char v2; // bl
  __int64 *v3; // rdi
  __m128 v5; // [rsp+20h] [rbp-18h]

  v1 = a1;
  v2 = 0;
  sub_140002584(&v5, 0x10ui64);
  sub_1400097D4((__int64)qword_140034798, (__int64 *)&v5);
  if ( sub_140008E08((__int64)&v5) )
  {
    v3 = (__int64 *)sub_140008E08((__int64)&v5);
    v2 = sub_140012B5C((__int64)(v3 + 5), v1);
    if ( v2 )
      sub_140009580(v3);
  }
  sub_140008BD0((__int64 *)&v5);
  return v2;
}

//----- (000000014000A194) ----------------------------------------------------
__int64 __fastcall sub_14000A194(unsigned __int8 *a1)
{
  return (unsigned int)(unsigned __int16)sub_140008DF4(a1) >> 12;
}

//----- (000000014000A1A8) ----------------------------------------------------
__int64 __fastcall sub_14000A1A8(unsigned __int8 *a1)
{
  unsigned int v1; // eax

  LOWORD(v1) = sub_140008DF4(a1);
  return (v1 >> 10) & 3;
}

//----- (000000014000A1BC) ----------------------------------------------------
void __fastcall sub_14000A1BC(int a1, int a2)
{
  int v2; // edi
  volatile signed __int64 *v3; // rbx
  void *v4; // rax
  int v5; // edi
  int v6; // edi
  int v7; // edi
  int v8; // edi
  int v9; // edi
  int v10; // edi
  int v11; // edx

  v2 = a1;
  v3 = (volatile signed __int64 *)&unk_1400345C0;
  if ( a2 == 1 )
    v3 = (volatile signed __int64 *)&unk_140034580;
  v4 = sub_1400097C4(a2);
  if ( !v2 )
  {
    _InterlockedIncrement64(v3);
    return;
  }
  v5 = v2 - 1;
  if ( !v5 )
  {
    _InterlockedIncrement64(v3 + 2);
    goto LABEL_18;
  }
  v6 = v5 - 1;
  if ( !v6 )
  {
    _InterlockedIncrement64(v3 + 1);
    v11 = 1;
LABEL_19:
    sub_1400065D4((__int64)v4, v11);
    return;
  }
  v7 = v6 - 1;
  if ( !v7 )
  {
    _InterlockedIncrement64(v3 + 5);
    goto LABEL_18;
  }
  v8 = v7 - 1;
  if ( !v8 )
  {
    _InterlockedIncrement64(v3 + 3);
LABEL_18:
    v11 = 0;
    goto LABEL_19;
  }
  v9 = v8 - 1;
  if ( v9 )
  {
    v10 = v9 - 1;
    if ( v10 )
    {
      if ( v10 == 1 )
        _InterlockedIncrement64(v3 + 6);
    }
    else
    {
      _InterlockedIncrement64(v3 + 7);
    }
  }
  else
  {
    _InterlockedIncrement64(v3 + 4);
  }
}

//----- (000000014000A25C) ----------------------------------------------------
__int64 __fastcall sub_14000A25C(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rdi
  __int64 result; // rax
  signed __int64 v5; // rbx
  NTSTATUS (*v6)(); // rsi

  v2 = a2;
  v3 = a1;
  result = sub_1400130E8();
  v5 = result + 1000;
  if ( *(_DWORD *)(v3 + 16) > 0 )
  {
    v6 = sub_140008DE4();
    do
    {
      sub_14000A020(v2, (__int64 (*)(void))v6);
      result = sub_1400130E8();
    }
    while ( result <= v5 && *(_DWORD *)(v3 + 16) > 0 );
  }
  return result;
}

//----- (000000014000A2CC) ----------------------------------------------------
__int64 __fastcall sub_14000A2CC(__int64 a1)
{
  __int64 v1; // rbx
  char v3; // [rsp+20h] [rbp-38h]

  v1 = a1;
  sub_1400075EC((__int128 *)&v3, a1 + 8);
  sub_14000A25C(v1, (__int64)&v3);
  return sub_1400076D8(&v3);
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);

//----- (000000014000A31C) ----------------------------------------------------
char __fastcall sub_14000A31C(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // rdi
  char v2; // bl

  v1 = a1;
  v2 = 0;
  if ( !(unsigned int)sub_14000A1A8(a1)
    || (unsigned int)sub_14000A1A8(v1) == 2 && sub_14000A194(v1) & 8 && sub_1400099B8(v1) )
  {
    v2 = 1;
  }
  return v2;
}

//----- (000000014000A368) ----------------------------------------------------
signed __int64 __fastcall sub_14000A368(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // rsi
  signed __int64 v2; // rdi
  int v3; // eax
  signed __int64 v4; // rbx
  int v5; // eax

  v1 = a1;
  v2 = 30i64;
  v3 = sub_14000A1A8(a1);
  if ( !v3 )
    return 32i64;
  if ( v3 == 2 )
  {
    v4 = 4i64 * (unsigned __int8)sub_14000A31C(v1) + 30;
    v2 = v4 + 2;
    if ( !(sub_14000A194(v1) & 8) )
      v2 = v4;
    v5 = sub_1400096A4(v1);
    if ( v5 == 2 || v5 == 1 )
      v2 -= 6i64;
  }
  return v2;
}

//----- (000000014000A3E4) ----------------------------------------------------
__int64 __fastcall sub_14000A3E4(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_140036E20);
}
// 140036E20: using guessed type __int64 qword_140036E20;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014000A3F0) ----------------------------------------------------
__int64 __fastcall sub_14000A3F0(__int64 a1)
{
  __int64 v1; // rdi
  __int64 result; // rax
  int v3; // eax
  char *v4; // rax
  char *v5; // rax
  _QWORD *v6; // rax
  __int64 *v7; // rbx
  __m128 *v8; // rax
  __int64 v9; // rax
  char v10; // al

  v1 = a1;
  if ( !sub_14000A4D0() )
    return 3221225659i64;
  if ( !sub_140019690() || (v3 = PsGetCurrentProcessId(), sub_140019714(v3)) || sub_140009BFC() )
  {
    v4 = sub_140007D68(1u);
    sub_14000EDD0(v4);
    v5 = sub_140007D68(0);
    sub_14000EDD0(v5);
    v6 = sub_14000FD68();
    if ( !sub_140006EAC(v6) )
    {
      v7 = (__int64 *)sub_14000FD68();
      v8 = sub_14000FD60();
      v9 = sub_140001B3C((__int64)v8);
      sub_14000FCFC(v7, v9);
    }
    v10 = RtlIsNtDdiVersionAvailable(100794368i64);
    result = sub_140007A74(v1, v10 == 0);
  }
  else
  {
    sub_140002E58(
      L"Denying access to non-Sophos process",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsdevice.cpp",
      859);
    result = 3221225506i64;
  }
  return result;
}
// 14001E025: using guessed type __int64 __fastcall RtlIsNtDdiVersionAvailable(_QWORD);
// 140020090: using guessed type wchar_t aDenyingAccessT[37];
// 140029308: using guessed type __int64 PsGetCurrentProcessId(void);

//----- (000000014000A4D0) ----------------------------------------------------
char sub_14000A4D0()
{
  char result; // al

  if ( byte_14003466C )
    return byte_14003466D;
  result = RtlIsNtDdiVersionAvailable(100794368i64);
  byte_14003466D = result;
  byte_14003466C = 1;
  return result;
}
// 14001E025: using guessed type __int64 __fastcall RtlIsNtDdiVersionAvailable(_QWORD);
// 14003466C: using guessed type char byte_14003466C;
// 14003466D: using guessed type char byte_14003466D;

//----- (000000014000A504) ----------------------------------------------------
__int64 __fastcall sub_14000A504(__int64 a1)
{
  __int64 v1; // rbx
  char (__fastcall *v2)(__int64, __int64, __int64); // rbx
  __int64 v3; // rax
  __m128 v5; // [rsp+30h] [rbp-18h]

  v1 = a1;
  sub_14000A660(0i64, 0i64, 0i64, 0i64);
  sub_140002584(&v5, 0x10ui64);
  sub_140009F6C(qword_140034798, &v5, v1);
  if ( sub_140008E08((__int64)&v5) )
  {
    v2 = sub_140008DCC();
    v3 = sub_140008E08((__int64)&v5);
    sub_14001252C(v3 + 40, v2, 0i64, 0i64);
  }
  sub_140008BD0((__int64 *)&v5);
  return sub_14000A2CC((__int64)qword_140034798);
}
// 14001252C: using guessed type __int64 __fastcall sub_14001252C(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014000A59C) ----------------------------------------------------
signed __int64 __fastcall sub_14000A59C(__int64 a1)
{
  __int64 v1; // rbx
  int v3; // ebx
  void *v4; // rax
  int v5; // eax
  void *v6; // rax

  v1 = a1;
  if ( !sub_14000A4D0() )
    return 3221225659i64;
  sub_140009940(v1);
  v3 = sub_140013190();
  if ( v3 >= 0 )
  {
    v4 = sub_140009878();
    v5 = sub_140006938((__int64)v4);
    if ( v5 < 0 )
    {
      if ( (v5 & 0xC0000000) == -1073741824 )
        sub_140002E58(
          L"IPS: failed to initialize IPS performance counters",
          v3,
          0,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsdevice.cpp",
          726);
    }
    else
    {
      v6 = sub_1400098BC();
      sub_140006960((__int64)v6);
    }
  }
  else
  {
    sub_140002E58(
      L"Unable to init WfpBinder",
      v3,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsdevice.cpp",
      713);
  }
  if ( (v3 & 0xC0000000) == -1073741824 )
    sub_140002E58(
      L"IPS: failed to initialize IPS",
      v3,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsdevice.cpp",
      732);
  return (unsigned int)v3;
}
// 14001FDB0: using guessed type wchar_t aUnableToInitWf[25];
// 14001FDF0: using guessed type wchar_t aIpsFailedToIni[51];
// 14001FE60: using guessed type wchar_t aIpsFailedToIni_0[30];

//----- (000000014000A660) ----------------------------------------------------
void __fastcall sub_14000A660(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // r14
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 v7; // r15
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 *v10; // r15
  __int64 (*v11)(void); // rax
  __int64 *v12; // rbx
  unsigned __int64 v13; // rbx
  __int64 *v14; // r14
  __int64 v15; // rax
  __int64 *v16; // r14
  __int64 v17; // rax
  char (__fastcall *v18)(__int64, unsigned int *); // rax
  unsigned __int64 v19; // rdx
  unsigned __int64 v20; // rbx
  __m128 *v21; // rax
  unsigned int v22; // eax
  __m128 *v23; // rax
  __m128 *v24; // rax
  unsigned int v25; // edx
  __int64 v26; // rbx
  __m128 *v27; // rax
  __int64 v28; // r8
  __m128 *v29; // rax
  int v30; // eax
  int v31; // eax
  __int64 v32; // rdi
  __m128i v33; // [rsp+38h] [rbp-A0h]
  __m128 v34; // [rsp+50h] [rbp-88h]
  __int128 v35; // [rsp+60h] [rbp-78h]
  __int128 v36; // [rsp+70h] [rbp-68h]
  __int128 v37; // [rsp+80h] [rbp-58h]
  __int128 v38; // [rsp+90h] [rbp-48h]
  __int128 v39; // [rsp+A0h] [rbp-38h]
  __int128 v40; // [rsp+B0h] [rbp-28h]
  __int128 v41; // [rsp+C0h] [rbp-18h]
  __int128 v42; // [rsp+D0h] [rbp-8h]
  __int128 v43; // [rsp+E0h] [rbp+8h]
  __int128 v44; // [rsp+F0h] [rbp+18h]
  __int64 v45; // [rsp+100h] [rbp+28h]
  __int64 v46; // [rsp+108h] [rbp+30h]
  char v47[24]; // [rsp+110h] [rbp+38h]
  __int128 v48; // [rsp+128h] [rbp+50h]
  __int128 v49; // [rsp+138h] [rbp+60h]
  __int128 v50; // [rsp+148h] [rbp+70h]
  __int128 v51; // [rsp+158h] [rbp+80h]
  __int128 v52; // [rsp+168h] [rbp+90h]
  __int128 v53; // [rsp+178h] [rbp+A0h]
  __int128 v54; // [rsp+188h] [rbp+B0h]
  __int128 v55; // [rsp+198h] [rbp+C0h]
  __int128 v56; // [rsp+1A8h] [rbp+D0h]
  __int128 v57; // [rsp+1B8h] [rbp+E0h]
  __int128 v58; // [rsp+1C8h] [rbp+F0h]
  __int128 v59; // [rsp+1D8h] [rbp+100h]
  __int128 v60; // [rsp+1E8h] [rbp+110h]
  __int64 v61; // [rsp+1F8h] [rbp+120h]
  PCWSTR SourceString; // [rsp+200h] [rbp+128h]
  unsigned __int64 v63; // [rsp+208h] [rbp+130h]
  void *retaddr; // [rsp+278h] [rbp+1A0h]

  v4 = a4;
  v5 = a2;
  switch ( (_DWORD)retaddr )
  {
    case 0x12E012:
      SourceString = 0i64;
      v63 = 0i64;
      v30 = sub_14000AE28();
      if ( v30 >= 0 && v63 )
      {
        v31 = sub_140002D94(SourceString);
        v32 = v31;
        if ( v31 >= 0 )
        {
          sub_140004C94(1);
          sub_140002DD4(
            L"SNTP_SET_EXCLUSION_LIST: Successfully added exclusions.",
            v32,
            0i64,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsdevice.cpp",
            976);
        }
        else
        {
          sub_140002E58(
            L"SNTP_SET_EXCLUSION_LIST: Failed to update exclusions list",
            v31,
            0,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsdevice.cpp",
            971);
        }
      }
      else
      {
        sub_140002E58(
          L"SNTP_SET_EXCLUSION_LIST: Failed to retrieve input buffer from IOCTL",
          v30,
          0,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsdevice.cpp",
          964);
      }
      break;
    case 0x12E016:
      sub_140002D44(1i64);
      sub_140004C94(1);
      sub_140002DD4(
        L"SNTP_RESET_EXCLUSION_LIST: Exclusions reset.",
        0i64,
        0i64,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsdevice.cpp",
        987);
      break;
    case 0x12E01A:
      SourceString = 0i64;
      v63 = 0i64;
      if ( a4 && (signed int)sub_14000AE28() >= 0 && v63 )
      {
        v27 = sub_1400098B4();
        sub_14000CC8C((__int64)v27, (__int64)SourceString, v28);
      }
      else
      {
        v29 = sub_1400098B4();
        sub_14000E958((__int64)v29);
      }
      break;
    case 0x12E01D:
      if ( a4 == 16 )
      {
        SourceString = 0i64;
        v63 = 0i64;
        if ( (signed int)sub_14000AE28() >= 0 && v63 == 16 )
        {
          v33 = *(__m128i *)SourceString;
          v24 = sub_140009940(0i64);
          v25 = _mm_cvtsi128_si32(v33);
          v26 = (__int64)v24;
          if ( v25 )
            sub_140011928((__int64)v24, v25);
          if ( v33.m128i_i32[1] )
            sub_14000A100(v26, v33.m128i_u32[1]);
          if ( v33.m128i_i32[2] )
            sub_140011914(v26, v33.m128i_u32[2]);
          sub_140011924(v26, v33.m128i_i32[3] != 0);
        }
      }
      break;
    case 0x12E0A2:
      if ( a3 >= 0xE8 )
      {
        v63 = 0i64;
        SourceString = 0i64;
        if ( (signed int)sub_14000AE54() >= 0 )
        {
          v20 = v63;
          sub_140008CFC(v63, (__int64)&unk_140034580);
          *((_QWORD *)&v44 + 1) = 0i64;
          v45 = 0i64;
          v46 = 0i64;
          sub_14001E1C0(&v34, 0, 0x80ui64);
          sub_14001E1C0((__m128 *)((char *)&v39 + 8), 0, 0x20ui64);
          sub_14001E1C0((__m128 *)((char *)&v41 + 8), 0, 0x2Cui64);
          *(__m128 *)&v47[8] = v34;
          v48 = v35;
          v49 = v36;
          v50 = v37;
          v51 = v38;
          v52 = v39;
          v53 = v40;
          v54 = v41;
          v55 = v42;
          v56 = v43;
          v57 = v44;
          v58 = *(_OWORD *)&v45;
          v59 = *(_OWORD *)v47;
          v60 = *(_OWORD *)&v47[16];
          v61 = *((_QWORD *)&v35 + 1);
          sub_140008CFC((__int64)&unk_140034580, (__int64)&v34);
          *(_QWORD *)(v20 + 208) = 0i64;
          v21 = sub_140009940(0i64);
          v22 = sub_140011A8C(v21);
          if ( dword_140034668 < v22 )
            dword_140034668 = v22;
          *(_DWORD *)(v20 + 216) = v22;
          *(_DWORD *)(v20 + 220) = dword_140034668;
          v23 = sub_140009940(0i64);
          *(_QWORD *)(v20 + 224) = sub_140011960((__int64)v23);
        }
      }
      break;
    case 0x12E0A6:
      SourceString = 0i64;
      v63 = 0i64;
      if ( !a4 )
        goto LABEL_77;
      if ( (signed int)sub_14000AE28() < 0 )
        break;
      if ( v63 )
        v19 = v63 >> 4;
      else
LABEL_77:
        v19 = 0i64;
      sub_1400083B4((__m128i *)SourceString, v19);
      break;
    default:
      v6 = sub_14000ADF4(a2);
      v7 = v6;
      if ( !v6 )
        break;
      if ( (_DWORD)retaddr == 1237162 && sub_140008DBC(qword_140034798, v6) )
      {
        v8 = sub_14000A078(qword_140034798, v7);
        if ( v8 )
        {
          v9 = sub_14000A3E4(v8);
          if ( v9 )
            sub_140009118(v9);
        }
      }
      sub_140002584((__m128 *)&v33, 0x10ui64);
      sub_1400097D4((__int64)qword_140034798, v33.m128i_i64);
      v10 = (__int64 *)sub_140008E08((__int64)&v33);
      if ( !v10 )
        goto LABEL_38;
      if ( (_DWORD)retaddr == 1237162 )
      {
        v15 = sub_140008E08((__int64)&v33);
        v16 = (__int64 *)v15;
        v17 = sub_140009724(v15, v5);
        v5 = v17;
        if ( v17 )
        {
          sub_14000ADD8(v17);
          v5 = 0i64;
        }
        v18 = sub_140008DD4();
        sub_14001252C(v16 + 5, v18, v10, 1i64);
        if ( sub_140012944((__int64)(v16 + 5)) )
          sub_140009580(v16);
        goto LABEL_38;
      }
      if ( (_DWORD)retaddr == 1237165 )
      {
        if ( v4 >= 8 && (signed int)sub_14000AE28() >= 0 )
        {
          v13 = (unsigned __int64)SourceString >> 3;
          v14 = (__int64 *)sub_140008E08((__int64)&v33);
          if ( sub_14000F868(v14, v63, v13) )
            CPullPin::Process((CPullPin *)(v14 + 5));
        }
        goto LABEL_38;
      }
      if ( (_DWORD)retaddr != 1237169 )
      {
        switch ( (_DWORD)retaddr )
        {
          case 0x12E0B5:
            if ( v4 >= 8 && (signed int)sub_14000AE28() >= 0 && v63 > 8 )
            {
              v12 = (__int64 *)sub_140008E08((__int64)&v33);
              if ( sub_14000F868(v12, (__int64)SourceString, 1ui64) )
              {
                if ( *(_QWORD *)SourceString )
                  sub_1400121B0((__int64)(v12 + 5), *(_QWORD *)SourceString);
              }
            }
            break;
          case 0x12E0B9:
            v11 = (__int64 (*)(void))sub_140008DEC();
            goto LABEL_21;
          case 0x12E0BD:
            v11 = (__int64 (*)(void))sub_140008DC4();
LABEL_21:
            sub_140009E4C(v10, v5, v4, v11);
            break;
        }
      }
LABEL_38:
      sub_140008BD0(v33.m128i_i64);
      break;
  }
  if ( v5 )
    sub_14000ADD8(v5);
}
// 140002D44: using guessed type __int64 __fastcall sub_140002D44(_QWORD);
// 140011A8C: using guessed type __int64 __fastcall sub_140011A8C(_QWORD);
// 14001252C: using guessed type __int64 __fastcall sub_14001252C(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400200E0: using guessed type wchar_t aSntpSetExclusi_1[68];
// 140020170: using guessed type wchar_t aSntpSetExclusi[58];
// 1400201F0: using guessed type wchar_t aSntpSetExclusi_0[56];
// 140020260: using guessed type wchar_t aSntpResetExclu[45];
// 140034668: using guessed type int dword_140034668;

//----- (000000014000AD60) ----------------------------------------------------
void __fastcall sub_14000AD60(_QWORD *a1)
{
  *a1 = 0i64;
}

//----- (000000014000AD68) ----------------------------------------------------
signed __int64 __fastcall sub_14000AD68(__m128 *a1)
{
  __m128 *v1; // rbx
  signed __int64 result; // rax

  v1 = a1;
  sub_14001E1C0(a1, 0, 0x38ui64);
  result = 1i64;
  LODWORD(v1->m128_u64[0]) = 56;
  v1[1].m128_i32[2] = 1;
  v1[1].m128_i32[3] = 1;
  return result;
}

//----- (000000014000AD94) ----------------------------------------------------
__int64 sub_14000AD94()
{
  return sub_14001E1B0((__int64 (*)(void))qword_140036E28);
}
// 140036E28: using guessed type __int64 qword_140036E28;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014000ADD8) ----------------------------------------------------
__int64 __fastcall sub_14000ADD8(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_140037008);
}
// 140037008: using guessed type __int64 qword_140037008;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014000ADF4) ----------------------------------------------------
__int64 __fastcall sub_14000ADF4(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_140037078);
}
// 140037078: using guessed type __int64 qword_140037078;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014000AE0C) ----------------------------------------------------
__int64 __fastcall sub_14000AE0C(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_140037418);
}
// 140037418: using guessed type __int64 qword_140037418;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014000AE28) ----------------------------------------------------
__int64 sub_14000AE28()
{
  return sub_14001E1B0((__int64 (*)(void))qword_140037038);
}
// 140037038: using guessed type __int64 qword_140037038;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014000AE54) ----------------------------------------------------
__int64 sub_14000AE54()
{
  return sub_14001E1B0((__int64 (*)(void))qword_140037040);
}
// 140037040: using guessed type __int64 qword_140037040;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014000AE80) ----------------------------------------------------
__int64 __fastcall sub_14000AE80(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_140037068);
}
// 140037068: using guessed type __int64 qword_140037068;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014000AE9C) ----------------------------------------------------
__int64 __fastcall sub_14000AE9C(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_140036FD0);
}
// 140036FD0: using guessed type __int64 qword_140036FD0;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014000AEB4) ----------------------------------------------------
__int64 __fastcall sub_14000AEB4(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)a2;
  *(_WORD *)(a1 + 24) = *(_WORD *)(a2 + 8);
  *(_BYTE *)(a1 + 26) = *(_BYTE *)(a2 + 10);
  return a1;
}

//----- (000000014000AED8) ----------------------------------------------------
__int64 __fastcall sub_14000AED8(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 16);
  *(_WORD *)(a1 + 36) = *(_WORD *)(a2 + 20);
  *(_BYTE *)(a1 + 38) = *(_BYTE *)(a2 + 22);
  return a1;
}

//----- (000000014000AF00) ----------------------------------------------------
__int64 __fastcall sub_14000AF00(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)a2;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 8);
  *(_WORD *)(a1 + 28) = *(_WORD *)(a2 + 12);
  *(_BYTE *)(a1 + 30) = *(_BYTE *)(a2 + 14);
  return a1;
}

//----- (000000014000AF2C) ----------------------------------------------------
__int64 __fastcall sub_14000AF2C(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 32);
  *(_WORD *)(a1 + 52) = *(_WORD *)(a2 + 36);
  *(_BYTE *)(a1 + 54) = *(_BYTE *)(a2 + 38);
  return a1;
}

//----- (000000014000AF5C) ----------------------------------------------------
bool __fastcall sub_14000AF5C(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rsi
  unsigned int *v4; // rbx
  unsigned int *v5; // rax
  unsigned int *v7; // rax

  v2 = a1;
  v3 = a2;
  v4 = (unsigned int *)sub_140003C0C(a2);
  v5 = (unsigned int *)sub_140003C0C(v2);
  if ( sub_14000BDD0(v5) )
    return 1;
  if ( sub_14000BDD0(v4) )
    return 0;
  sub_14000D2B4(v3);
  v7 = (unsigned int *)sub_14000D2B4(v2);
  return sub_14000BDD0(v7);
}

//----- (000000014000AFE8) ----------------------------------------------------
bool __fastcall sub_14000AFE8(CMediaType *this, CMediaType *a2)
{
  CMediaType *v2; // rbp
  CMediaType *v3; // rsi
  unsigned int *v4; // rbx
  unsigned int *v5; // rdi
  struct _GUID *v7; // rbx
  const struct _GUID *v8; // rax

  v2 = this;
  v3 = a2;
  v4 = (unsigned int *)sub_140003C0C((__int64)a2);
  v5 = (unsigned int *)sub_140003C0C((__int64)v2);
  if ( sub_14000BDF0((__int64)v5, v4) )
    return 1;
  if ( sub_14000BDF0((__int64)v4, v5) )
    return 0;
  v7 = (struct _GUID *)CMediaType::Subtype(v3);
  v8 = CMediaType::Subtype(v2);
  return sub_14000BDF0((__int64)v8, &v7->Data1);
}

//----- (000000014000B074) ----------------------------------------------------
char __fastcall sub_14000B074(__int64 a1, _DWORD *a2, unsigned __int8 a3, char a4, __int16 a5, __int16 a6)
{
  char v6; // si
  unsigned __int8 v7; // bl
  _DWORD *v8; // rdi
  __int64 v9; // rbp
  _DWORD *v10; // rax
  _WORD *v11; // rbx
  __int64 v12; // rax
  char result; // al
  _WORD *v14; // rbx
  __int64 v15; // rax
  char v16; // [rsp+30h] [rbp-18h]
  __int64 v17; // [rsp+60h] [rbp+18h]

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( a3 & 0xDF || (v10 = sub_14000B720(&v17), !sub_14000BA68(v8, v10)) )
  {
    v14 = sub_14000B634(&v16, v8, v7, v6, a5, a6);
    v15 = sub_140003C0C(v9);
    result = sub_14000BF38(v15, (__int64)v14);
  }
  else
  {
    v11 = sub_14000B508(&v16, v8, v6, a5, a6);
    v12 = sub_14000CBC8(v9);
    result = sub_14000BE70(v12, (__int64)v11);
  }
  return result;
}

//----- (000000014000B144) ----------------------------------------------------
char __fastcall sub_14000B144(__int64 a1, __m128i *a2, unsigned __int8 a3, char a4, __int16 a5, __int16 a6)
{
  char v6; // si
  unsigned __int8 v7; // bl
  __m128i *v8; // rdi
  __int64 v9; // rbp
  _DWORD *v10; // rax
  _WORD *v11; // rbx
  __int64 v12; // rax
  char result; // al
  _WORD *v14; // rbx
  __int64 v15; // rax
  char v16; // [rsp+30h] [rbp-38h]

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( a3 & 0x7F || (v10 = (_DWORD *)unknown_libname_2(&v16), !sub_14000BA78((__int64)v8, v10)) )
  {
    v14 = sub_14000B6A4(&v16, v8, v7, v6, a5, a6);
    v15 = sub_14000CC84(v9);
    result = sub_14000BF9C(v15, (__int64)v14);
  }
  else
  {
    v11 = sub_14000B574(&v16, v8, v6, a5, a6);
    v12 = sub_14000CBD0(v9);
    result = sub_14000BED4(v12, (__int64)v11);
  }
  return result;
}
// 140003A00: using guessed type __int64 __fastcall unknown_libname_2(_QWORD);

//----- (000000014000B220) ----------------------------------------------------
signed __int64 __fastcall sub_14000B220(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rbx
  __int64 v5; // rax
  _QWORD *v6; // rbx

  v2 = a1;
  v3 = a2;
  v4 = sub_14000B798(32i64);
  if ( v4 )
  {
    v5 = sub_140003C0C(v3);
    v6 = (_QWORD *)sub_14000AEB4(v4, v5);
  }
  else
  {
    v6 = 0i64;
  }
  if ( v6 )
  {
    ++*(_QWORD *)(v2 + 16);
    sub_140004DE4(v2, v6);
  }
  return (unsigned __int64)(v6 + 2) & -(signed __int64)(v6 != 0i64);
}

//----- (000000014000B294) ----------------------------------------------------
signed __int64 __fastcall sub_14000B294(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rbx
  __int64 v5; // rax
  _QWORD *v6; // rbx

  v2 = a1;
  v3 = a2;
  v4 = sub_14000B7B0(40i64);
  if ( v4 )
  {
    v5 = sub_140003C0C(v3);
    v6 = (_QWORD *)sub_14000AED8(v4, v5);
  }
  else
  {
    v6 = 0i64;
  }
  if ( v6 )
  {
    ++*(_QWORD *)(v2 + 16);
    sub_140004DE4(v2, v6);
  }
  return (unsigned __int64)(v6 + 2) & -(signed __int64)(v6 != 0i64);
}

//----- (000000014000B308) ----------------------------------------------------
signed __int64 __fastcall sub_14000B308(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rbx
  __int64 v5; // rax
  _QWORD *v6; // rbx

  v2 = a1;
  v3 = a2;
  v4 = sub_14000B7C8(32i64);
  if ( v4 )
  {
    v5 = sub_140003C0C(v3);
    v6 = (_QWORD *)sub_14000AF00(v4, v5);
  }
  else
  {
    v6 = 0i64;
  }
  if ( v6 )
  {
    ++*(_QWORD *)(v2 + 16);
    sub_140004DE4(v2, v6);
  }
  return (unsigned __int64)(v6 + 2) & -(signed __int64)(v6 != 0i64);
}

//----- (000000014000B37C) ----------------------------------------------------
signed __int64 __fastcall sub_14000B37C(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rbx
  __int64 v5; // rax
  _QWORD *v6; // rbx

  v2 = a1;
  v3 = a2;
  v4 = sub_14000B7E0(56i64);
  if ( v4 )
  {
    v5 = sub_140003C0C(v3);
    v6 = (_QWORD *)sub_14000AF2C(v4, v5);
  }
  else
  {
    v6 = 0i64;
  }
  if ( v6 )
  {
    ++*(_QWORD *)(v2 + 16);
    sub_140004DE4(v2, v6);
  }
  return (unsigned __int64)(v6 + 2) & -(signed __int64)(v6 != 0i64);
}

//----- (000000014000B3F0) ----------------------------------------------------
_DWORD *__fastcall sub_14000B3F0(_DWORD *a1, _DWORD *a2, unsigned __int8 a3)
{
  _DWORD *v3; // rdi
  unsigned __int8 v4; // si
  _DWORD *v5; // rbx
  _DWORD *v6; // rax
  signed int v7; // edx
  unsigned __int64 i; // rcx
  char v9; // al
  char v11; // [rsp+30h] [rbp+8h]

  v3 = a1;
  *a1 = *a2;
  v4 = a3;
  v5 = a2;
  a1[1] = *a2;
  v6 = sub_14000B720(&v11);
  if ( sub_14000BA10(v5, v6) )
  {
    v4 = 0;
  }
  else if ( (unsigned __int8)(v4 - 1) > 0x1Eu )
  {
    return v3;
  }
  v7 = 255 >> (v4 & 7);
  for ( i = (unsigned __int64)v4 >> 3; i < 4; ++i )
  {
    *((_BYTE *)v3 + i + 4) |= v7;
    v9 = ~(_BYTE)v7;
    LOBYTE(v7) = -1;
    *((_BYTE *)v3 + i) &= v9;
  }
  return v3;
}

//----- (000000014000B478) ----------------------------------------------------
__m128i *__fastcall sub_14000B478(__m128i *a1, __m128i *a2, unsigned __int8 a3)
{
  __m128i *v3; // rdi
  unsigned __int8 v4; // si
  __int64 v5; // rbx
  _DWORD *v6; // rax
  signed int v7; // edx
  unsigned __int64 i; // rcx
  char v9; // al
  char v11; // [rsp+20h] [rbp-18h]

  v3 = a1;
  v4 = a3;
  v5 = (__int64)a2;
  _mm_storeu_si128(a1, *a2);
  _mm_storeu_si128(a1 + 1, *a2);
  v6 = (_DWORD *)unknown_libname_2(&v11);
  if ( sub_14000BA18(v5, v6) )
  {
    v4 = 0;
  }
  else if ( (unsigned __int8)(v4 - 1) > 0x7Eu )
  {
    return v3;
  }
  v7 = 255 >> (v4 & 7);
  for ( i = (unsigned __int64)v4 >> 3; i < 0x10; ++i )
  {
    v3[1].m128i_i8[i] |= v7;
    v9 = ~(_BYTE)v7;
    LOBYTE(v7) = -1;
    *((_BYTE *)v3->m128i_i64 + i) &= v9;
  }
  return v3;
}
// 140003A00: using guessed type __int64 __fastcall unknown_libname_2(_QWORD);

//----- (000000014000B508) ----------------------------------------------------
_WORD *__fastcall sub_14000B508(_WORD *a1, _DWORD *a2, char a3, __int16 a4, __int16 a5)
{
  _WORD *v5; // r15
  __int16 v6; // si
  char v7; // bl
  _DWORD *v8; // r14

  v5 = a1;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  *a1 = sub_14000CC70();
  *(_WORD *)((char *)v5 + 5) = a5;
  *((_BYTE *)v5 + 2) = v7;
  *(_WORD *)((char *)v5 + 3) = v6;
  *(_DWORD *)((char *)v5 + 7) = *v8;
  return v5;
}

//----- (000000014000B574) ----------------------------------------------------
_WORD *__fastcall sub_14000B574(_WORD *a1, __m128i *a2, char a3, __int16 a4, __int16 a5)
{
  _WORD *v5; // r14
  __int16 v6; // si
  char v7; // bl
  __m128i *v8; // rbp
  _WORD *result; // rax

  v5 = a1;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  *a1 = sub_14000CC78();
  *(_WORD *)((char *)v5 + 5) = a5;
  result = v5;
  *((_BYTE *)v5 + 2) = v7;
  *(_WORD *)((char *)v5 + 3) = v6;
  _mm_storeu_si128((__m128i *)((char *)v5 + 7), *v8);
  return result;
}

//----- (000000014000B5E4) ----------------------------------------------------
volatile signed __int32 **__fastcall sub_14000B5E4(volatile signed __int32 **a1, volatile signed __int32 **a2, volatile signed __int32 *a3)
{
  volatile signed __int32 *v3; // rdi
  volatile signed __int32 **v4; // rbx
  volatile signed __int32 **result; // rax

  v3 = a3;
  v4 = a1;
  sub_14000B748(a1, a2);
  result = v4;
  v4[1] = v3;
  return result;
}

//----- (000000014000B60C) ----------------------------------------------------
__int64 __fastcall sub_14000B60C(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  unknown_libname_1(a1);
  *(_QWORD *)(v1 + 8) = 0i64;
  return v1;
}
// 140001AB0: using guessed type __int64 __fastcall unknown_libname_1(_QWORD);

//----- (000000014000B628) ----------------------------------------------------
_QWORD *__fastcall sub_14000B628(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *result; // rax

  *a1 = a2;
  result = a1;
  a1[1] = a3;
  return result;
}

//----- (000000014000B634) ----------------------------------------------------
_WORD *__fastcall sub_14000B634(_WORD *a1, _DWORD *a2, unsigned __int8 a3, char a4, __int16 a5, __int16 a6)
{
  _WORD *v6; // r14
  char v7; // bl
  unsigned __int8 v8; // di
  _DWORD *v9; // rsi

  v6 = a1;
  v7 = a4;
  v8 = a3;
  v9 = a2;
  *a1 = sub_14000CC70();
  *(_WORD *)((char *)v6 + 3) = a5;
  *(_WORD *)((char *)v6 + 5) = a6;
  *((_BYTE *)v6 + 2) = v7;
  sub_14000B3F0((_WORD *)((char *)v6 + 7), v9, v8);
  return v6;
}

//----- (000000014000B6A4) ----------------------------------------------------
_WORD *__fastcall sub_14000B6A4(_WORD *a1, __m128i *a2, unsigned __int8 a3, char a4, __int16 a5, __int16 a6)
{
  _WORD *v6; // r14
  char v7; // bl
  unsigned __int8 v8; // di
  __m128i *v9; // rsi

  v6 = a1;
  v7 = a4;
  v8 = a3;
  v9 = a2;
  *a1 = sub_14000CC78();
  *(_WORD *)((char *)v6 + 3) = a5;
  *(_WORD *)((char *)v6 + 5) = a6;
  *((_BYTE *)v6 + 2) = v7;
  sub_14000B478((__m128i *)((char *)v6 + 7), v9, v8);
  return v6;
}

//----- (000000014000B714) ----------------------------------------------------
__int64 __fastcall sub_14000B714(__int64 a1, int a2, __int64 a3)
{
  __int64 result; // rax

  *(_DWORD *)a1 = a2;
  result = a1;
  *(_QWORD *)(a1 + 8) = a3;
  return result;
}

//----- (000000014000B720) ----------------------------------------------------
_DWORD *__fastcall sub_14000B720(_DWORD *a1)
{
  *a1 = 0;
  return a1;
}

//----- (000000014000B728) ----------------------------------------------------
__int64 __fastcall sub_14000B728(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_QWORD *)(a1 + 8) = 0i64;
  result = a1;
  *(_DWORD *)a1 = 0;
  *(_QWORD *)(a1 + 16) = a2;
  return result;
}

//----- (000000014000B73C) ----------------------------------------------------
__int64 __fastcall sub_14000B73C(__int64 a1, int a2, __int16 a3)
{
  __int64 result; // rax

  *(_DWORD *)a1 = a2;
  result = a1;
  *(_WORD *)(a1 + 4) = a3;
  return result;
}

//----- (000000014000B748) ----------------------------------------------------
volatile signed __int32 **__fastcall sub_14000B748(volatile signed __int32 **a1, volatile signed __int32 **a2)
{
  volatile signed __int32 **v2; // rbx
  volatile signed __int32 *v3; // rcx

  v2 = a1;
  v3 = *a2;
  *v2 = *a2;
  if ( v3 )
    sub_14000C000(v3);
  return v2;
}

//----- (000000014000B76C) ----------------------------------------------------
volatile signed __int32 **__fastcall sub_14000B76C(volatile signed __int32 **a1, volatile signed __int32 *a2)
{
  volatile signed __int32 **v2; // rbx

  *a1 = a2;
  v2 = a1;
  if ( a2 )
    sub_14000C000(a2);
  return v2;
}

//----- (000000014000B798) ----------------------------------------------------
__int64 __fastcall sub_14000B798(__int64 a1)
{
  __int64 result; // rax

  if ( a1 == 32 )
    result = sub_140003C60(&stru_140034940);
  else
    result = 0i64;
  return result;
}
// 140003C60: using guessed type __int64 __fastcall sub_140003C60(_QWORD);

//----- (000000014000B7B0) ----------------------------------------------------
__int64 __fastcall sub_14000B7B0(__int64 a1)
{
  __int64 result; // rax

  if ( a1 == 40 )
    result = sub_140003C60(&stru_1400348C0);
  else
    result = 0i64;
  return result;
}
// 140003C60: using guessed type __int64 __fastcall sub_140003C60(_QWORD);

//----- (000000014000B7C8) ----------------------------------------------------
__int64 __fastcall sub_14000B7C8(__int64 a1)
{
  __int64 result; // rax

  if ( a1 == 32 )
    result = sub_140003C60(&stru_140034A40);
  else
    result = 0i64;
  return result;
}
// 140003C60: using guessed type __int64 __fastcall sub_140003C60(_QWORD);

//----- (000000014000B7E0) ----------------------------------------------------
__int64 __fastcall sub_14000B7E0(__int64 a1)
{
  __int64 result; // rax

  if ( a1 == 56 )
    result = sub_140003C60(&stru_1400349C0);
  else
    result = 0i64;
  return result;
}
// 140003C60: using guessed type __int64 __fastcall sub_140003C60(_QWORD);

//----- (000000014000B7F8) ----------------------------------------------------
__int64 *__fastcall sub_14000B7F8(__int64 *a1, __m128i *a2)
{
  __m128i *v2; // rdi
  __int64 *v3; // rbx

  v2 = a2;
  v3 = a1;
  if ( a1 != (__int64 *)a2 )
  {
    sub_140009460(a1);
    if ( !(unsigned __int8)IsListEmpty(v2) )
    {
      _mm_storeu_si128((__m128i *)v3, *v2);
      *(_QWORD *)(*v3 + 8) = v3;
      *(_QWORD *)v3[1] = v3;
      v3[2] = v2[1].m128i_i64[0];
      InitializeListHead((PLIST_ENTRY)v2);
      v2[1].m128i_i64[0] = 0i64;
    }
  }
  return v3;
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);

//----- (000000014000B858) ----------------------------------------------------
__int64 *__fastcall sub_14000B858(__int64 *a1, __m128i *a2)
{
  __m128i *v2; // rdi
  __int64 *v3; // rbx

  v2 = a2;
  v3 = a1;
  if ( a1 != (__int64 *)a2 )
  {
    sub_1400094A8(a1);
    if ( !(unsigned __int8)IsListEmpty(v2) )
    {
      _mm_storeu_si128((__m128i *)v3, *v2);
      *(_QWORD *)(*v3 + 8) = v3;
      *(_QWORD *)v3[1] = v3;
      v3[2] = v2[1].m128i_i64[0];
      InitializeListHead((PLIST_ENTRY)v2);
      v2[1].m128i_i64[0] = 0i64;
    }
  }
  return v3;
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);

//----- (000000014000B8B8) ----------------------------------------------------
__int64 *__fastcall sub_14000B8B8(__int64 *a1, __m128i *a2)
{
  __m128i *v2; // rdi
  __int64 *v3; // rbx

  v2 = a2;
  v3 = a1;
  if ( a1 != (__int64 *)a2 )
  {
    sub_1400094F0(a1);
    if ( !(unsigned __int8)IsListEmpty(v2) )
    {
      _mm_storeu_si128((__m128i *)v3, *v2);
      *(_QWORD *)(*v3 + 8) = v3;
      *(_QWORD *)v3[1] = v3;
      v3[2] = v2[1].m128i_i64[0];
      InitializeListHead((PLIST_ENTRY)v2);
      v2[1].m128i_i64[0] = 0i64;
    }
  }
  return v3;
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);

//----- (000000014000B918) ----------------------------------------------------
__int64 *__fastcall sub_14000B918(__int64 *a1, __m128i *a2)
{
  __m128i *v2; // rdi
  __int64 *v3; // rbx

  v2 = a2;
  v3 = a1;
  if ( a1 != (__int64 *)a2 )
  {
    sub_140009538(a1);
    if ( !(unsigned __int8)IsListEmpty(v2) )
    {
      _mm_storeu_si128((__m128i *)v3, *v2);
      *(_QWORD *)(*v3 + 8) = v3;
      *(_QWORD *)v3[1] = v3;
      v3[2] = v2[1].m128i_i64[0];
      InitializeListHead((PLIST_ENTRY)v2);
      v2[1].m128i_i64[0] = 0i64;
    }
  }
  return v3;
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);

//----- (000000014000B978) ----------------------------------------------------
volatile signed __int32 **__fastcall sub_14000B978(volatile signed __int32 **a1, volatile signed __int32 **a2)
{
  volatile signed __int32 **v2; // rdi
  volatile signed __int32 **v3; // rbx
  volatile signed __int32 *v4; // rcx
  volatile signed __int32 *v5; // rax
  volatile signed __int32 *v6; // rcx

  v2 = a2;
  v3 = a1;
  if ( a1 != a2 )
  {
    v4 = *a1;
    if ( v4 )
    {
      v5 = sub_140009F20(v4);
      sub_1400096CC((__int64)v5);
    }
    v6 = *v2;
    *v3 = *v2;
    if ( v6 )
      sub_14000C000(v6);
  }
  return v3;
}

//----- (000000014000B9C0) ----------------------------------------------------
char __fastcall sub_14000B9C0(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  _QWORD *v3; // rdi
  bool v4; // al
  char v5; // r8

  v2 = a2;
  v3 = a1;
  v4 = sub_14000BA3C(a1, a2);
  v5 = 0;
  if ( v4 && v3[1] == v2[1] )
    v5 = 1;
  return v5;
}

//----- (000000014000B9F8) ----------------------------------------------------
bool __fastcall sub_14000B9F8(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

//----- (000000014000BA10) ----------------------------------------------------
bool __fastcall sub_14000BA10(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2;
}

//----- (000000014000BA18) ----------------------------------------------------
char __fastcall sub_14000BA18(__int64 a1, _DWORD *a2)
{
  unsigned int v2; // er9
  __int64 v3; // rcx

  v2 = 0;
  v3 = a1 - (_QWORD)a2;
  while ( *(_DWORD *)((char *)a2 + v3) == *a2 )
  {
    ++v2;
    ++a2;
    if ( v2 >= 4 )
      return 1;
  }
  return 0;
}

//----- (000000014000BA3C) ----------------------------------------------------
bool __fastcall sub_14000BA3C(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2;
}

//----- (000000014000BA48) ----------------------------------------------------
char __fastcall sub_14000BA48(_QWORD *a1, _QWORD *a2)
{
  return sub_14000B9C0(a1, a2) ^ 1;
}

//----- (000000014000BA58) ----------------------------------------------------
bool __fastcall sub_14000BA58(_QWORD *a1, _QWORD *a2)
{
  return !sub_14000B9F8(a1, a2);
}

//----- (000000014000BA68) ----------------------------------------------------
bool __fastcall sub_14000BA68(_DWORD *a1, _DWORD *a2)
{
  return !sub_14000BA10(a1, a2);
}

//----- (000000014000BA78) ----------------------------------------------------
char __fastcall sub_14000BA78(__int64 a1, _DWORD *a2)
{
  return sub_14000BA18(a1, a2) ^ 1;
}

//----- (000000014000BA88) ----------------------------------------------------
signed __int64 __fastcall sub_14000BA88(__int64 a1, __int64 a2)
{
  return a1 + 11 * a2 + 24;
}

//----- (000000014000BA94) ----------------------------------------------------
signed __int64 __fastcall sub_14000BA94(__int64 a1, __int64 a2)
{
  return a1 + 23 * a2 + 24;
}

//----- (000000014000BAA0) ----------------------------------------------------
signed __int64 __fastcall sub_14000BAA0(__int64 a1, __int64 a2)
{
  return a1 + 15 * a2 + 24;
}

//----- (000000014000BAAC) ----------------------------------------------------
signed __int64 __fastcall sub_14000BAAC(__int64 a1, __int64 a2)
{
  return a1 + 39 * a2 + 24;
}

//----- (000000014000BAB8) ----------------------------------------------------
char __fastcall sub_14000BAB8(_QWORD *a1)
{
  __int64 v1; // rdi
  char v2; // bl
  __int64 v3; // rax

  v1 = (__int64)a1;
  v2 = 0;
  if ( sub_140006EAC(a1) )
  {
    v3 = sub_140001B3C(v1);
    if ( *(_QWORD *)(v1 + 8) < (unsigned __int64)sub_140008E08(v3) )
      v2 = 1;
  }
  return v2;
}

//----- (000000014000BAF8) ----------------------------------------------------
__int64 __fastcall sub_14000BAF8(__int64 a1)
{
  return *(unsigned __int16 *)(a1 + 4);
}

//----- (000000014000BB00) ----------------------------------------------------
signed __int64 __fastcall sub_14000BB00(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax

  v1 = a1;
  v2 = sub_140001B3C(a1);
  return sub_14000BA88(v2, *(_QWORD *)(v1 + 8));
}

//----- (000000014000BB20) ----------------------------------------------------
signed __int64 __fastcall sub_14000BB20(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax

  v1 = a1;
  v2 = sub_140001B3C(a1);
  return sub_14000BA94(v2, *(_QWORD *)(v1 + 8));
}

//----- (000000014000BB40) ----------------------------------------------------
signed __int64 __fastcall sub_14000BB40(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax

  v1 = a1;
  v2 = sub_140001B3C(a1);
  return sub_14000BAA0(v2, *(_QWORD *)(v1 + 8));
}

//----- (000000014000BB60) ----------------------------------------------------
signed __int64 __fastcall sub_14000BB60(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax

  v1 = a1;
  v2 = sub_140001B3C(a1);
  return sub_14000BAAC(v2, *(_QWORD *)(v1 + 8));
}

//----- (000000014000BB80) ----------------------------------------------------
__int64 __fastcall sub_14000BB80(__int64 a1)
{
  return sub_140009E44(*(_QWORD *)(a1 + 8)) + 16;
}

//----- (000000014000BB98) ----------------------------------------------------
__int64 __fastcall sub_14000BB98(__int64 a1)
{
  ++*(_QWORD *)(a1 + 8);
  return a1;
}

//----- (000000014000BBA0) ----------------------------------------------------
__m128i *__fastcall sub_14000BBA0(__m128i *a1, __m128 *a2)
{
  __m128i *v2; // rdi
  __m128i *v3; // rbx
  __m128i *result; // rax

  v2 = (__m128i *)a2;
  v3 = a1;
  sub_140002584(a2, 0x10ui64);
  _mm_storeu_si128(v2, *v3);
  result = v2;
  v3->m128i_i64[1] = *(_QWORD *)v3->m128i_i64[1];
  return result;
}

//----- (000000014000BBE0) ----------------------------------------------------
__int64 __fastcall sub_14000BBE0(__int64 a1)
{
  __int64 result; // rax

  result = a1;
  *(_QWORD *)(a1 + 8) = **(_QWORD **)(a1 + 8);
  return result;
}

//----- (000000014000BBF0) ----------------------------------------------------
__int64 __fastcall sub_14000BBF0(__int64 a1)
{
  __int64 result; // rax

  result = a1;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8i64);
  return result;
}

//----- (000000014000BC00) ----------------------------------------------------
bool __fastcall sub_14000BC00(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // cx

  v2 = a2;
  v3 = a1;
  if ( !sub_14000BDD0((unsigned int *)(a1 + 7)) )
  {
    if ( sub_14000BDD0((unsigned int *)(v2 + 7)) )
      return 0;
    v4 = *(_WORD *)(v3 + 3);
    v5 = *(_WORD *)(v2 + 3);
    if ( v4 >= v5 )
    {
      if ( v4 <= v5 )
        return *(_WORD *)(v3 + 5) < *(_WORD *)(v2 + 5);
      return 0;
    }
  }
  return 1;
}

//----- (000000014000BC74) ----------------------------------------------------
bool __fastcall sub_14000BC74(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // cx

  v2 = a2;
  v3 = a1;
  if ( !sub_14000BDF0(a1 + 7, (unsigned int *)(a2 + 7)) )
  {
    if ( sub_14000BDF0(v2 + 7, (unsigned int *)(v3 + 7)) )
      return 0;
    v4 = *(_WORD *)(v3 + 3);
    v5 = *(_WORD *)(v2 + 3);
    if ( v4 >= v5 )
    {
      if ( v4 <= v5 )
        return *(_WORD *)(v3 + 5) < *(_WORD *)(v2 + 5);
      return 0;
    }
  }
  return 1;
}

//----- (000000014000BCE8) ----------------------------------------------------
bool __fastcall sub_14000BCE8(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // cx

  v2 = a2;
  v3 = a1;
  if ( !sub_14000AF5C(a1 + 7, a2 + 7) )
  {
    if ( sub_14000AF5C(v2 + 7, v3 + 7) )
      return 0;
    v4 = *(_WORD *)(v3 + 3);
    v5 = *(_WORD *)(v2 + 3);
    if ( v4 >= v5 )
    {
      if ( v4 <= v5 )
        return *(_WORD *)(v3 + 5) < *(_WORD *)(v2 + 5);
      return 0;
    }
  }
  return 1;
}

//----- (000000014000BD5C) ----------------------------------------------------
bool __fastcall sub_14000BD5C(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // cx

  v2 = a2;
  v3 = a1;
  if ( !sub_14000AFE8((CMediaType *)(a1 + 7), (CMediaType *)(a2 + 7)) )
  {
    if ( sub_14000AFE8((CMediaType *)(v2 + 7), (CMediaType *)(v3 + 7)) )
      return 0;
    v4 = *(_WORD *)(v3 + 3);
    v5 = *(_WORD *)(v2 + 3);
    if ( v4 >= v5 )
    {
      if ( v4 <= v5 )
        return *(_WORD *)(v3 + 5) < *(_WORD *)(v2 + 5);
      return 0;
    }
  }
  return 1;
}

//----- (000000014000BDD0) ----------------------------------------------------
bool __fastcall sub_14000BDD0(unsigned int *a1)
{
  unsigned int *v1; // rdx
  unsigned int v2; // er8

  sub_14000E758(*a1);
  return v2 < (unsigned int)sub_14000E758(*v1);
}

//----- (000000014000BDF0) ----------------------------------------------------
bool __fastcall sub_14000BDF0(__int64 a1, unsigned int *a2)
{
  __int64 v2; // r10
  __int64 v3; // rbx
  unsigned int *v4; // r9
  unsigned int v5; // edi
  unsigned int v6; // esi
  int v7; // er8
  __int64 v8; // r9
  int v9; // edx
  __int64 v10; // r8
  unsigned int v11; // edx
  __int64 v12; // r8
  __int64 v13; // r11
  unsigned int v14; // ecx

  v2 = a1 - (_QWORD)a2;
  v3 = a1;
  v4 = a2;
  while ( 1 )
  {
    v5 = *(unsigned int *)((char *)v4 + v2);
    v6 = *v4;
    sub_14000E758(*(unsigned int *)((char *)v4 + v2));
    if ( v9 != (unsigned int)sub_14000E758(v6) )
      break;
    v10 = (unsigned int)(v7 + 1);
    v4 = (unsigned int *)(v8 + 4);
    if ( (unsigned int)v10 >= 3 )
    {
      sub_14000E758(*(_DWORD *)(v3 + 4 * v10));
      v14 = *(_DWORD *)(v13 + 4 * v12);
      return v11 < (unsigned int)sub_14000E758(v14);
    }
  }
  sub_14000E758(v5);
  v14 = v6;
  return v11 < (unsigned int)sub_14000E758(v14);
}

//----- (000000014000BE70) ----------------------------------------------------
char __fastcall sub_14000BE70(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  char v5; // [rsp+20h] [rbp-38h]

  v2 = a2;
  v3 = a1;
  sub_1400075EC((__int128 *)&v5, a1 + 16);
  LOBYTE(v3) = sub_14000B220(v3 + 24, v2) != 0;
  sub_1400076D8(&v5);
  return v3;
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);

//----- (000000014000BED4) ----------------------------------------------------
char __fastcall sub_14000BED4(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  char v5; // [rsp+20h] [rbp-38h]

  v2 = a2;
  v3 = a1;
  sub_1400075EC((__int128 *)&v5, a1 + 16);
  LOBYTE(v3) = sub_14000B294(v3 + 24, v2) != 0;
  sub_1400076D8(&v5);
  return v3;
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);

//----- (000000014000BF38) ----------------------------------------------------
char __fastcall sub_14000BF38(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  char v5; // [rsp+20h] [rbp-38h]

  v2 = a2;
  v3 = a1;
  sub_1400075EC((__int128 *)&v5, a1 + 16);
  LOBYTE(v3) = sub_14000B308(v3 + 24, v2) != 0;
  sub_1400076D8(&v5);
  return v3;
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);

//----- (000000014000BF9C) ----------------------------------------------------
char __fastcall sub_14000BF9C(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  char v5; // [rsp+20h] [rbp-38h]

  v2 = a2;
  v3 = a1;
  sub_1400075EC((__int128 *)&v5, a1 + 16);
  LOBYTE(v3) = sub_14000B37C(v3 + 24, v2) != 0;
  sub_1400076D8(&v5);
  return v3;
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);

//----- (000000014000C000) ----------------------------------------------------
volatile signed __int32 *__fastcall sub_14000C000(volatile signed __int32 *a1)
{
  _InterlockedIncrement(a1);
  return a1;
}

//----- (000000014000C008) ----------------------------------------------------
PVOID __fastcall sub_14000C008(__int64 a1)
{
  __int64 v1; // rdi
  PVOID v2; // rax
  PVOID v3; // rbx
  __int64 v4; // rax
  char v6; // [rsp+30h] [rbp+8h]

  v1 = a1;
  v2 = sub_14000C158((__int64)&v6, 11 * a1 + 24);
  v3 = v2;
  if ( v2 )
  {
    v4 = sub_140008CB8(24i64, (__int64)v2);
    if ( v4 )
      sub_14000B728(v4, v1);
  }
  return v3;
}

//----- (000000014000C05C) ----------------------------------------------------
PVOID __fastcall sub_14000C05C(__int64 a1)
{
  __int64 v1; // rdi
  PVOID v2; // rax
  PVOID v3; // rbx
  __int64 v4; // rax
  char v6; // [rsp+30h] [rbp+8h]

  v1 = a1;
  v2 = sub_14000C158((__int64)&v6, 23 * a1 + 24);
  v3 = v2;
  if ( v2 )
  {
    v4 = sub_140008CB8(24i64, (__int64)v2);
    if ( v4 )
      sub_14000B728(v4, v1);
  }
  return v3;
}

//----- (000000014000C0B0) ----------------------------------------------------
PVOID __fastcall sub_14000C0B0(__int64 a1)
{
  __int64 v1; // rdi
  PVOID v2; // rax
  PVOID v3; // rbx
  __int64 v4; // rax
  char v6; // [rsp+30h] [rbp+8h]

  v1 = a1;
  v2 = sub_14000C158((__int64)&v6, 15 * a1 + 24);
  v3 = v2;
  if ( v2 )
  {
    v4 = sub_140008CB8(24i64, (__int64)v2);
    if ( v4 )
      sub_14000B728(v4, v1);
  }
  return v3;
}

//----- (000000014000C104) ----------------------------------------------------
PVOID __fastcall sub_14000C104(__int64 a1)
{
  __int64 v1; // rdi
  PVOID v2; // rax
  PVOID v3; // rbx
  __int64 v4; // rax
  char v6; // [rsp+30h] [rbp+8h]

  v1 = a1;
  v2 = sub_14000C158((__int64)&v6, 39 * a1 + 24);
  v3 = v2;
  if ( v2 )
  {
    v4 = sub_140008CB8(24i64, (__int64)v2);
    if ( v4 )
      sub_14000B728(v4, v1);
  }
  return v3;
}

//----- (000000014000C158) ----------------------------------------------------
PVOID __fastcall sub_14000C158(__int64 a1, SIZE_T a2)
{
  return ExAllocatePoolWithTag((POOL_TYPE)512, a2, 0x6970734Cu);
}

//----- (000000014000C16C) ----------------------------------------------------
_DWORD *__fastcall sub_14000C16C(unsigned int *a1, _DWORD *a2)
{
  _DWORD *v2; // rbx
  unsigned int *v3; // rdi

  v2 = a2;
  v3 = a1;
  if ( (unsigned int)sub_14000EA40(a1) == 2048 )
    *v2 = **((_DWORD **)v3 + 1);
  else
    sub_14000B720(v2);
  return v2;
}

//----- (000000014000C1A8) ----------------------------------------------------
__m128i *__fastcall sub_14000C1A8(unsigned int *a1, __m128i *a2)
{
  __m128i *v2; // rbx
  unsigned int *v3; // rdi

  v2 = a2;
  v3 = a1;
  if ( (unsigned int)sub_14000EA40(a1) == 34525 )
    _mm_storeu_si128(v2, *(__m128i *)*((_QWORD *)v3 + 1));
  else
    unknown_libname_2(v2);
  return v2;
}
// 140003A00: using guessed type __int64 __fastcall unknown_libname_2(_QWORD);

//----- (000000014000C1E8) ----------------------------------------------------
signed __int64 __fastcall sub_14000C1E8(__int64 a1)
{
  return a1 + 11i64 * *(_QWORD *)(a1 + 8) + 13;
}

//----- (000000014000C1F8) ----------------------------------------------------
signed __int64 __fastcall sub_14000C1F8(__int64 a1)
{
  return a1 + 23i64 * *(_QWORD *)(a1 + 8) + 1;
}

//----- (000000014000C204) ----------------------------------------------------
signed __int64 __fastcall sub_14000C204(__int64 a1)
{
  return a1 + 15i64 * *(_QWORD *)(a1 + 8) + 9;
}

//----- (000000014000C214) ----------------------------------------------------
signed __int64 __fastcall sub_14000C214(__int64 a1)
{
  return a1 + 39i64 * *(_QWORD *)(a1 + 8) - 15;
}

//----- (000000014000C224) ----------------------------------------------------
char __fastcall sub_14000C224(__int64 *a1)
{
  void **v1; // rax
  __int64 *v2; // rdi
  char v3; // si
  __int64 v4; // rbx
  __int64 v5; // rax
  char v7; // [rsp+20h] [rbp-30h]
  _QWORD *v8; // [rsp+28h] [rbp-28h]
  char v9; // [rsp+30h] [rbp-20h]
  __int64 v10; // [rsp+38h] [rbp-18h]
  __m128 v11; // [rsp+40h] [rbp-10h]
  void *retaddr; // [rsp+58h] [rbp+8h]

  v1 = &retaddr;
  v2 = a1;
  if ( (unsigned __int64)a1[2] >= 2 )
  {
    sub_140002584(&v11, 0x10ui64);
    sub_14000EACC((__int64)v2, &v11);
    while ( 1 )
    {
      v3 = 0;
      sub_140002584((__m128 *)&v7, 0x10ui64);
      sub_14000EA44(v2, &v7);
      sub_140002584((__m128 *)&v9, 0x10ui64);
      sub_14000BBA0((__m128i *)&v7, (__m128 *)&v9);
      LOBYTE(v1) = sub_14000B9F8(&v7, &v11);
      if ( (_BYTE)v1 )
        break;
      do
      {
        v4 = sub_14000BB80((__int64)&v9);
        v5 = sub_14000BB80((__int64)&v7);
        if ( sub_14000BC00(v5, v4) )
        {
          sub_140004F14(v8);
          sub_140004DE4(v10, v8);
          v3 = 1;
        }
        sub_140002584((__m128 *)&v9, 0x10ui64);
        sub_14000BBA0((__m128i *)&v7, (__m128 *)&v9);
        LOBYTE(v1) = sub_14000B9F8(&v7, &v11);
      }
      while ( !(_BYTE)v1 );
      if ( !v3 )
        break;
      sub_14000BBF0((__int64)&v11);
    }
  }
  return (char)v1;
}

//----- (000000014000C34C) ----------------------------------------------------
char __fastcall sub_14000C34C(__int64 *a1)
{
  void **v1; // rax
  __int64 *v2; // rdi
  char v3; // si
  __int64 v4; // rbx
  __int64 v5; // rax
  char v7; // [rsp+20h] [rbp-30h]
  _QWORD *v8; // [rsp+28h] [rbp-28h]
  char v9; // [rsp+30h] [rbp-20h]
  __int64 v10; // [rsp+38h] [rbp-18h]
  __m128 v11; // [rsp+40h] [rbp-10h]
  void *retaddr; // [rsp+58h] [rbp+8h]

  v1 = &retaddr;
  v2 = a1;
  if ( (unsigned __int64)a1[2] >= 2 )
  {
    sub_140002584(&v11, 0x10ui64);
    sub_14000EACC((__int64)v2, &v11);
    while ( 1 )
    {
      v3 = 0;
      sub_140002584((__m128 *)&v7, 0x10ui64);
      sub_14000EA44(v2, &v7);
      sub_140002584((__m128 *)&v9, 0x10ui64);
      sub_14000BBA0((__m128i *)&v7, (__m128 *)&v9);
      LOBYTE(v1) = sub_14000B9F8(&v7, &v11);
      if ( (_BYTE)v1 )
        break;
      do
      {
        v4 = sub_14000BB80((__int64)&v9);
        v5 = sub_14000BB80((__int64)&v7);
        if ( sub_14000BC74(v5, v4) )
        {
          sub_140004F14(v8);
          sub_140004DE4(v10, v8);
          v3 = 1;
        }
        sub_140002584((__m128 *)&v9, 0x10ui64);
        sub_14000BBA0((__m128i *)&v7, (__m128 *)&v9);
        LOBYTE(v1) = sub_14000B9F8(&v7, &v11);
      }
      while ( !(_BYTE)v1 );
      if ( !v3 )
        break;
      sub_14000BBF0((__int64)&v11);
    }
  }
  return (char)v1;
}

//----- (000000014000C474) ----------------------------------------------------
char __fastcall sub_14000C474(__int64 *a1)
{
  void **v1; // rax
  __int64 *v2; // rdi
  char v3; // si
  __int64 v4; // rbx
  __int64 v5; // rax
  char v7; // [rsp+20h] [rbp-30h]
  _QWORD *v8; // [rsp+28h] [rbp-28h]
  char v9; // [rsp+30h] [rbp-20h]
  __int64 v10; // [rsp+38h] [rbp-18h]
  __m128 v11; // [rsp+40h] [rbp-10h]
  void *retaddr; // [rsp+58h] [rbp+8h]

  v1 = &retaddr;
  v2 = a1;
  if ( (unsigned __int64)a1[2] >= 2 )
  {
    sub_140002584(&v11, 0x10ui64);
    sub_14000EACC((__int64)v2, &v11);
    while ( 1 )
    {
      v3 = 0;
      sub_140002584((__m128 *)&v7, 0x10ui64);
      sub_14000EA44(v2, &v7);
      sub_140002584((__m128 *)&v9, 0x10ui64);
      sub_14000BBA0((__m128i *)&v7, (__m128 *)&v9);
      LOBYTE(v1) = sub_14000B9F8(&v7, &v11);
      if ( (_BYTE)v1 )
        break;
      do
      {
        v4 = sub_14000BB80((__int64)&v9);
        v5 = sub_14000BB80((__int64)&v7);
        if ( sub_14000BCE8(v5, v4) )
        {
          sub_140004F14(v8);
          sub_140004DE4(v10, v8);
          v3 = 1;
        }
        sub_140002584((__m128 *)&v9, 0x10ui64);
        sub_14000BBA0((__m128i *)&v7, (__m128 *)&v9);
        LOBYTE(v1) = sub_14000B9F8(&v7, &v11);
      }
      while ( !(_BYTE)v1 );
      if ( !v3 )
        break;
      sub_14000BBF0((__int64)&v11);
    }
  }
  return (char)v1;
}

//----- (000000014000C59C) ----------------------------------------------------
char __fastcall sub_14000C59C(__int64 *a1)
{
  void **v1; // rax
  __int64 *v2; // rdi
  char v3; // si
  __int64 v4; // rbx
  __int64 v5; // rax
  char v7; // [rsp+20h] [rbp-30h]
  _QWORD *v8; // [rsp+28h] [rbp-28h]
  char v9; // [rsp+30h] [rbp-20h]
  __int64 v10; // [rsp+38h] [rbp-18h]
  __m128 v11; // [rsp+40h] [rbp-10h]
  void *retaddr; // [rsp+58h] [rbp+8h]

  v1 = &retaddr;
  v2 = a1;
  if ( (unsigned __int64)a1[2] >= 2 )
  {
    sub_140002584(&v11, 0x10ui64);
    sub_14000EACC((__int64)v2, &v11);
    while ( 1 )
    {
      v3 = 0;
      sub_140002584((__m128 *)&v7, 0x10ui64);
      sub_14000EA44(v2, &v7);
      sub_140002584((__m128 *)&v9, 0x10ui64);
      sub_14000BBA0((__m128i *)&v7, (__m128 *)&v9);
      LOBYTE(v1) = sub_14000B9F8(&v7, &v11);
      if ( (_BYTE)v1 )
        break;
      do
      {
        v4 = sub_14000BB80((__int64)&v9);
        v5 = sub_14000BB80((__int64)&v7);
        if ( sub_14000BD5C(v5, v4) )
        {
          sub_140004F14(v8);
          sub_140004DE4(v10, v8);
          v3 = 1;
        }
        sub_140002584((__m128 *)&v9, 0x10ui64);
        sub_14000BBA0((__m128i *)&v7, (__m128 *)&v9);
        LOBYTE(v1) = sub_14000B9F8(&v7, &v11);
      }
      while ( !(_BYTE)v1 );
      if ( !v3 )
        break;
      sub_14000BBF0((__int64)&v11);
    }
  }
  return (char)v1;
}

//----- (000000014000C6C4) ----------------------------------------------------
__int64 __fastcall sub_14000C6C4(__int64 a1)
{
  __int64 v1; // rbx
  char v3; // [rsp+20h] [rbp-38h]

  v1 = a1;
  sub_1400075EC((__int128 *)&v3, a1);
  sub_140009F44((volatile signed __int32 **)(v1 + 8));
  sub_140009460((__int64 *)(v1 + 24));
  sub_140009460((__int64 *)(v1 + 48));
  return sub_1400076D8(&v3);
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);

//----- (000000014000C724) ----------------------------------------------------
__int64 __fastcall sub_14000C724(__int64 a1)
{
  __int64 v1; // rbx
  char v3; // [rsp+20h] [rbp-38h]

  v1 = a1;
  sub_1400075EC((__int128 *)&v3, a1);
  sub_140009F44((volatile signed __int32 **)(v1 + 8));
  sub_1400094A8((__int64 *)(v1 + 24));
  sub_1400094A8((__int64 *)(v1 + 48));
  return sub_1400076D8(&v3);
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);

//----- (000000014000C784) ----------------------------------------------------
__int64 __fastcall sub_14000C784(__int64 a1)
{
  __int64 v1; // rbx
  char v3; // [rsp+20h] [rbp-38h]

  v1 = a1;
  sub_1400075EC((__int128 *)&v3, a1);
  sub_140009F44((volatile signed __int32 **)(v1 + 8));
  sub_1400094F0((__int64 *)(v1 + 24));
  sub_1400094F0((__int64 *)(v1 + 48));
  return sub_1400076D8(&v3);
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);

//----- (000000014000C7E4) ----------------------------------------------------
__int64 __fastcall sub_14000C7E4(__int64 a1)
{
  __int64 v1; // rbx
  char v3; // [rsp+20h] [rbp-38h]

  v1 = a1;
  sub_1400075EC((__int128 *)&v3, a1);
  sub_140009F44((volatile signed __int32 **)(v1 + 8));
  sub_140009538((__int64 *)(v1 + 24));
  sub_140009538((__int64 *)(v1 + 48));
  return sub_1400076D8(&v3);
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);

//----- (000000014000C844) ----------------------------------------------------
bool __fastcall sub_14000C844(__int64 a1)
{
  __int64 v1; // rdi
  char v2; // bl
  bool v3; // zf
  char v4; // al
  bool result; // al

  v1 = a1;
  sub_14000DE50(a1);
  sub_14000E2D4(v1 + 72);
  sub_14000D548(v1 + 144);
  sub_14000D9CC(v1 + 216);
  v2 = 0;
  if ( !sub_14000EAAC(v1) || (v3 = sub_14000EAAC(v1 + 144) == 0, v4 = 0, v3) )
    v4 = 1;
  *(_BYTE *)(v1 + 288) = v4;
  result = sub_14000EAAC(v1 + 72);
  if ( !result || (result = sub_14000EAAC(v1 + 216)) == 0 )
    v2 = 1;
  *(_BYTE *)(v1 + 289) = v2;
  return result;
}

//----- (000000014000C8EC) ----------------------------------------------------
bool __fastcall sub_14000C8EC(__int64 a1, unsigned int *a2)
{
  __int64 v2; // rdi

  v2 = a1;
  return !sub_14000BDD0(a2) && !sub_14000BDD0((unsigned int *)(v2 + 4));
}

//----- (000000014000C92C) ----------------------------------------------------
bool __fastcall sub_14000C92C(unsigned int *a1, __int64 a2)
{
  unsigned int *v2; // rbx
  unsigned int *v3; // rdi

  v2 = (unsigned int *)a2;
  v3 = a1;
  return !sub_14000BDF0(a2, a1) && !sub_14000BDF0((__int64)(v3 + 4), v2);
}

//----- (000000014000C96C) ----------------------------------------------------
__int64 __fastcall sub_14000C96C(__int64 a1, __int64 a2)
{
  int v2; // ebx
  __int64 v3; // rdi
  __int64 v4; // r8

  v2 = *(_DWORD *)(a1 + 16);
  v3 = a2;
  if ( v2 == 2048 )
  {
    v4 = sub_140006988(*(_QWORD *)a1, *(unsigned int *)(a1 + 28)) + 16;
  }
  else if ( v2 == 34525 )
  {
    v4 = sub_140006988(*(_QWORD *)a1, *(unsigned int *)(a1 + 28)) + 24;
  }
  else
  {
    v4 = 0i64;
  }
  sub_14000B714(v3, v2, v4);
  return v3;
}

//----- (000000014000C9CC) ----------------------------------------------------
__int64 __fastcall sub_14000C9CC(__int64 a1, __int64 a2)
{
  int v2; // eax
  __int64 v3; // rbx
  __int64 v4; // rdi
  __int16 v5; // r8
  int v6; // edx
  __int64 v7; // rax
  __int16 v8; // ax

  v2 = *(_DWORD *)(a1 + 20);
  v3 = a2;
  v4 = a1;
  if ( v2 == 6 || v2 == 17 )
  {
    v7 = sub_140006988(*(_QWORD *)a1, *(unsigned int *)(a1 + 32));
    v8 = sub_140008DF4((unsigned __int8 *)(v7 + 2));
    v6 = *(_DWORD *)(v4 + 16);
    v5 = v8;
  }
  else
  {
    v5 = 0;
    v6 = 0;
  }
  sub_14000B73C(v3, v6, v5);
  return v3;
}

//----- (000000014000CA24) ----------------------------------------------------
__m128 *__fastcall sub_14000CA24(__int64 a1, __m128 *a2, __m128i *a3)
{
  __m128 *v3; // rsi
  __int64 v4; // rbx
  __m128i *v5; // rdi
  struct _SLIST_ENTRY *v6; // rax
  __int128 v8; // [rsp+20h] [rbp-18h]

  v3 = a2;
  v4 = a1;
  v5 = a3;
  sub_140002584(a2, 0x10ui64);
  _mm_storeu_si128((__m128i *)&v8, *v5);
  sub_14000E904(v4, v3, (__int64)&v8);
  v6 = (struct _SLIST_ENTRY *)sub_140009E44(v5->m128i_i64[1]);
  sub_140008CBC(v6);
  return v3;
}

//----- (000000014000CA88) ----------------------------------------------------
__m128 *__fastcall sub_14000CA88(__int64 a1, __m128 *a2, __m128i *a3)
{
  __m128 *v3; // rsi
  __int64 v4; // rbx
  __m128i *v5; // rdi
  struct _SLIST_ENTRY *v6; // rax
  __int128 v8; // [rsp+20h] [rbp-18h]

  v3 = a2;
  v4 = a1;
  v5 = a3;
  sub_140002584(a2, 0x10ui64);
  _mm_storeu_si128((__m128i *)&v8, *v5);
  sub_14000E904(v4, v3, (__int64)&v8);
  v6 = (struct _SLIST_ENTRY *)sub_140009E44(v5->m128i_i64[1]);
  sub_140008CCC(v6);
  return v3;
}

//----- (000000014000CAEC) ----------------------------------------------------
__m128 *__fastcall sub_14000CAEC(__int64 a1, __m128 *a2, __m128i *a3)
{
  __m128 *v3; // rsi
  __int64 v4; // rbx
  __m128i *v5; // rdi
  struct _SLIST_ENTRY *v6; // rax
  __int128 v8; // [rsp+20h] [rbp-18h]

  v3 = a2;
  v4 = a1;
  v5 = a3;
  sub_140002584(a2, 0x10ui64);
  _mm_storeu_si128((__m128i *)&v8, *v5);
  sub_14000E904(v4, v3, (__int64)&v8);
  v6 = (struct _SLIST_ENTRY *)sub_140009E44(v5->m128i_i64[1]);
  sub_140008CDC(v6);
  return v3;
}

//----- (000000014000CB50) ----------------------------------------------------
__m128 *__fastcall sub_14000CB50(__int64 a1, __m128 *a2, __m128i *a3)
{
  __m128 *v3; // rsi
  __int64 v4; // rbx
  __m128i *v5; // rdi
  struct _SLIST_ENTRY *v6; // rax
  __int128 v8; // [rsp+20h] [rbp-18h]

  v3 = a2;
  v4 = a1;
  v5 = a3;
  sub_140002584(a2, 0x10ui64);
  _mm_storeu_si128((__m128i *)&v8, *v5);
  sub_14000E904(v4, v3, (__int64)&v8);
  v6 = (struct _SLIST_ENTRY *)sub_140009E44(v5->m128i_i64[1]);
  sub_140008CEC(v6);
  return v3;
}

//----- (000000014000CBB4) ----------------------------------------------------
__int64 __fastcall sub_14000CBB4(__int64 *a1)
{
  return sub_14000970C(a1) + 16;
}

//----- (000000014000CBC8) ----------------------------------------------------
signed __int64 __fastcall sub_14000CBC8(__int64 a1)
{
  return a1 + 144;
}

//----- (000000014000CBD0) ----------------------------------------------------
signed __int64 __fastcall sub_14000CBD0(__int64 a1)
{
  return a1 + 216;
}

//----- (000000014000CBD8) ----------------------------------------------------
volatile signed __int32 **__fastcall sub_14000CBD8(__int64 a1, __m128 *a2)
{
  volatile signed __int32 **v2; // rdi
  __int64 v3; // rbx
  char v5; // [rsp+20h] [rbp-38h]

  v2 = (volatile signed __int32 **)a2;
  v3 = a1;
  sub_140002584(a2, 8ui64);
  unknown_libname_1(v2);
  sub_1400075EC((__int128 *)&v5, v3);
  if ( sub_140006EAC((_QWORD *)(v3 + 8)) )
    sub_14000B978(v2, (volatile signed __int32 **)(v3 + 8));
  sub_1400076D8(&v5);
  return v2;
}
// 140001AB0: using guessed type __int64 __fastcall unknown_libname_1(_QWORD);
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);

//----- (000000014000CC58) ----------------------------------------------------
__m128 *__fastcall sub_14000CC58(__int64 a1, __m128 *a2)
{
  __m128 *v2; // rbx

  v2 = a2;
  sub_14000CBD8(a1, a2);
  return v2;
}

//----- (000000014000CC70) ----------------------------------------------------
signed __int64 sub_14000CC70()
{
  return 2048i64;
}

//----- (000000014000CC78) ----------------------------------------------------
signed __int64 sub_14000CC78()
{
  return 34525i64;
}

//----- (000000014000CC80) ----------------------------------------------------
__int64 __fastcall sub_14000CC80(__int64 a1)
{
  return *(unsigned int *)(a1 + 16);
}

//----- (000000014000CC84) ----------------------------------------------------
signed __int64 __fastcall sub_14000CC84(__int64 a1)
{
  return a1 + 72;
}

//----- (000000014000CC8C) ----------------------------------------------------
bool __fastcall sub_14000CC8C(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  __int64 v5; // rsi
  unsigned __int64 v6; // rax
  unsigned __int8 *v7; // r8
  unsigned __int64 v8; // rbx
  __int16 v9; // cx
  __int64 v10; // rdx
  _DWORD *v11; // rax
  __m128i *v12; // rax
  char v14; // [rsp+30h] [rbp-18h]
  char v15; // [rsp+58h] [rbp+10h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  sub_14000E958(a1);
  v6 = sub_140006988(v4, v3);
  v7 = (unsigned __int8 *)(v4 + 7);
  v8 = v6;
  if ( v4 + 7 < v6 )
  {
    while ( 1 )
    {
      v9 = *(_WORD *)v4;
      if ( !*(_WORD *)v4 )
      {
        v11 = sub_14000B720(&v15);
        sub_14000B074(v5, v11, 0, *(_BYTE *)(v4 + 2), *(_WORD *)(v4 + 3), *(_WORD *)(v4 + 5));
        v12 = (__m128i *)unknown_libname_2(&v14);
        sub_14000B144(v5, v12, 0, *(_BYTE *)(v4 + 2), *(_WORD *)(v4 + 3), *(_WORD *)(v4 + 5));
        v10 = 9i64;
        goto LABEL_9;
      }
      if ( v9 == 2 )
        break;
      if ( v9 == 23 )
      {
        sub_14000B144(v5, (__m128i *)(v4 + 8), *v7, *(_BYTE *)(v4 + 2), *(_WORD *)(v4 + 3), *(_WORD *)(v4 + 5));
        v10 = 24i64;
LABEL_9:
        v4 = sub_140006988(v4, v10);
        goto LABEL_10;
      }
      v4 = v8;
LABEL_10:
      v7 = (unsigned __int8 *)(v4 + 7);
      if ( v4 + 7 >= v8 )
        return sub_14000C844(v5);
    }
    sub_14000B074(v5, (_DWORD *)(v4 + 8), *v7, *(_BYTE *)(v4 + 2), *(_WORD *)(v4 + 3), *(_WORD *)(v4 + 5));
    v10 = 12i64;
    goto LABEL_9;
  }
  return sub_14000C844(v5);
}
// 140003A00: using guessed type __int64 __fastcall unknown_libname_2(_QWORD);

//----- (000000014000CDCC) ----------------------------------------------------
char __fastcall sub_14000CDCC(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // r14
  int v4; // edi
  __int64 v5; // rsi
  int v6; // eax
  unsigned int *v7; // rax
  __m128i *v8; // rdx
  signed __int64 v9; // r15
  char v10; // al
  __int16 v11; // r12
  __int16 v12; // r15
  __int64 v13; // r14
  signed __int64 v14; // rax
  __int128 v15; // xmm0
  __int16 v16; // cx
  __int128 v17; // xmm1
  __int16 v18; // ax
  __int16 v19; // ax
  unsigned int *v20; // rax
  int *v21; // rdx
  signed __int64 v22; // r15
  char v23; // al
  __int16 v24; // r12
  __int16 v25; // r15
  signed __int64 v26; // rax
  unsigned __int64 v27; // xmm0_8
  __int16 v28; // cx
  unsigned __int64 v29; // rcx
  __int16 v30; // ax
  __int16 v31; // ax
  char v33; // [rsp+30h] [rbp-49h]
  unsigned __int64 v34; // [rsp+38h] [rbp-41h]
  int v35; // [rsp+40h] [rbp-39h]
  __int16 v36; // [rsp+44h] [rbp-35h]
  char v37; // [rsp+46h] [rbp-33h]
  volatile signed __int32 *v38[2]; // [rsp+48h] [rbp-31h]
  int v39; // [rsp+58h] [rbp-21h]
  __int128 v40; // [rsp+60h] [rbp-19h]
  __int128 v41; // [rsp+70h] [rbp-9h]
  __int128 v42; // [rsp+80h] [rbp+7h]
  int v43; // [rsp+90h] [rbp+17h]
  __int16 v44; // [rsp+94h] [rbp+1Bh]
  char v45; // [rsp+96h] [rbp+1Dh]

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v6 = sub_14000CC80(a2);
  if ( v6 == 2048 )
  {
    if ( *(_BYTE *)(v3 + 288) )
    {
      if ( v4 == 1 )
      {
        v20 = (unsigned int *)sub_14000E98C(v5, (__int64)&v41);
        v21 = &v39;
      }
      else
      {
        v20 = (unsigned int *)sub_14000C96C(v5, (__int64)&v40);
        v21 = (int *)&v33;
      }
      v39 = *sub_14000C16C(v20, v21);
      sub_14000B508(&v34, &v39, 2, 0, 0);
      if ( !sub_14000EAAC(v3 + 144) )
      {
        sub_140002584((__m128 *)v38, 0x10ui64);
        sub_14000D2F0(v3 + 144, v38, (__int64)&v34);
        while ( 1 )
        {
          if ( !sub_14000BAB8(v38) || (v22 = sub_14000BB00((__int64)v38), !sub_14000BA10((_DWORD *)(v22 + 7), &v39)) )
          {
            sub_14000B790(v38);
            goto LABEL_49;
          }
          v23 = *(_BYTE *)(v22 + 2);
          if ( v23 == 2 || v23 == (_BYTE)v4 )
          {
            v24 = *(_WORD *)(v22 + 3);
            if ( !v24 || v24 == (unsigned __int16)sub_14000D2C4(v5, v4) )
            {
              v25 = *(_WORD *)(v22 + 5);
              if ( !v25 || v25 == (unsigned __int16)sub_14000E8D8(v5, v4) )
                break;
            }
          }
          sub_14000BB98((__int64)v38);
        }
        sub_14000B790(v38);
        return 1;
      }
LABEL_49:
      if ( !sub_14000EAAC(v3) )
      {
        sub_140002584((__m128 *)v38, 0x10ui64);
        sub_14000EA64(v3, v38);
        sub_140002584((__m128 *)&v40, 0x10ui64);
        sub_14000EAEC(v3, (volatile signed __int32 **)&v40);
        while ( sub_14000BA48(v38, &v40) )
        {
          v26 = sub_14000BB40((__int64)v38);
          v27 = *(_QWORD *)v26;
          v35 = *(_DWORD *)(v26 + 8);
          v28 = *(_WORD *)(v26 + 12);
          LOBYTE(v26) = *(_BYTE *)(v26 + 14);
          v36 = v28;
          v34 = v27;
          v37 = v26;
          if ( sub_14000C8EC((__int64)&v34 + 7, (unsigned int *)&v39) )
          {
            v29 = v34 >> 16;
            if ( BYTE2(v34) == 2 || (_BYTE)v29 == (_BYTE)v4 )
            {
              if ( !(unsigned __int16)(v34 >> 24) || (v30 = sub_14000D2C4(v5, v4), *(_WORD *)((char *)&v34 + 3) == v30) )
              {
                if ( !*(_WORD *)((char *)&v34 + 5) || (v31 = sub_14000E8D8(v5, v4), *(_WORD *)((char *)&v34 + 5) == v31) )
                {
                  sub_14000B790(&v40);
                  sub_14000B790(v38);
                  return 1;
                }
              }
            }
          }
          sub_14000BB98((__int64)v38);
        }
        sub_14000B790(&v40);
        sub_14000B790(v38);
      }
    }
  }
  else if ( v6 == 34525 && *(_BYTE *)(v3 + 289) )
  {
    if ( v4 == 1 )
    {
      v7 = (unsigned int *)sub_14000E98C(v5, (__int64)&v40);
      v8 = (__m128i *)v38;
    }
    else
    {
      v7 = (unsigned int *)sub_14000C96C(v5, (__int64)&v34);
      v8 = (__m128i *)&v41;
    }
    _mm_storeu_si128((__m128i *)&v40, *sub_14000C1A8(v7, v8));
    sub_14000B574(&v41, (__m128i *)&v40, 2, 0, 0);
    if ( !sub_14000EAAC(v3 + 216) )
    {
      sub_140002584((__m128 *)&v34, 0x10ui64);
      sub_14000D3A0(v3 + 216, (volatile signed __int32 **)&v34, (__int64)&v41);
      while ( 1 )
      {
        if ( !sub_14000BAB8(&v34) || (v9 = sub_14000BB20((__int64)&v34), !sub_14000BA18(v9 + 7, &v40)) )
        {
          sub_14000B790(&v34);
          goto LABEL_19;
        }
        v10 = *(_BYTE *)(v9 + 2);
        if ( v10 == 2 || v10 == (_BYTE)v4 )
        {
          v11 = *(_WORD *)(v9 + 3);
          if ( !v11 || v11 == (unsigned __int16)sub_14000D2C4(v5, v4) )
          {
            v12 = *(_WORD *)(v9 + 5);
            if ( !v12 || v12 == (unsigned __int16)sub_14000E8D8(v5, v4) )
              break;
          }
        }
        sub_14000BB98((__int64)&v34);
      }
      sub_14000B790(&v34);
      return 1;
    }
LABEL_19:
    v13 = v3 + 72;
    if ( !sub_14000EAAC(v13) )
    {
      sub_140002584((__m128 *)&v34, 0x10ui64);
      sub_14000EA64(v13, (volatile signed __int32 **)&v34);
      sub_140002584((__m128 *)v38, 0x10ui64);
      sub_14000EAEC(v13, v38);
      while ( sub_14000BA48(&v34, v38) )
      {
        v14 = sub_14000BB60((__int64)&v34);
        v15 = *(_OWORD *)v14;
        v43 = *(_DWORD *)(v14 + 32);
        v16 = *(_WORD *)(v14 + 36);
        v17 = *(_OWORD *)(v14 + 16);
        LOBYTE(v14) = *(_BYTE *)(v14 + 38);
        v44 = v16;
        v41 = v15;
        v45 = v14;
        v42 = v17;
        if ( sub_14000C92C((unsigned int *)((char *)&v41 + 7), (__int64)&v40)
          && (BYTE2(v41) == 2 || BYTE2(v41) == (_BYTE)v4) )
        {
          if ( !(unsigned __int16)((unsigned __int64)v41 >> 24)
            || (v18 = sub_14000D2C4(v5, v4), *(_WORD *)((char *)&v41 + 3) == v18) )
          {
            if ( !*(_WORD *)((char *)&v41 + 5) || (v19 = sub_14000E8D8(v5, v4), *(_WORD *)((char *)&v41 + 5) == v19) )
            {
              sub_14000B790(v38);
              sub_14000B790(&v34);
              return 1;
            }
          }
        }
        sub_14000BB98((__int64)&v34);
      }
      sub_14000B790(v38);
      sub_14000B790(&v34);
    }
  }
  return 0;
}
// 14000B790: using guessed type __int64 __fastcall sub_14000B790(_QWORD);

//----- (000000014000D2B4) ----------------------------------------------------
signed __int64 __fastcall sub_14000D2B4(__int64 a1)
{
  return a1 + 4;
}

//----- (000000014000D2C4) ----------------------------------------------------
__int64 __fastcall sub_14000D2C4(__int64 a1, int a2)
{
  __int64 v2; // rax
  char v4; // [rsp+40h] [rbp+18h]
  char v5; // [rsp+48h] [rbp+20h]

  if ( a2 == 1 )
    v2 = sub_14000C9CC(a1, (__int64)&v4);
  else
    v2 = sub_14000E9EC(a1, (__int64)&v5);
  return sub_14000BAF8(v2);
}

//----- (000000014000D2F0) ----------------------------------------------------
volatile signed __int32 **__fastcall sub_14000D2F0(__int64 a1, volatile signed __int32 **a2, __int64 a3)
{
  volatile signed __int32 **v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rax
  volatile signed __int32 *v10; // [rsp+20h] [rbp-28h]

  v3 = a2;
  v4 = a1;
  v5 = a3;
  sub_140002584((__m128 *)&v10, 8ui64);
  sub_14000CC58(v4, (__m128 *)&v10);
  if ( sub_140006EAC(&v10) )
  {
    v6 = sub_140001B3C((__int64)&v10);
    v7 = v6;
    LODWORD(v8) = sub_14000D450(v6, v5);
    if ( (signed int)v8 >= 0 )
      v8 = (signed int)v8;
    else
      v8 = sub_140008E08(v7);
    sub_14000B5E4(v3, &v10, (volatile signed __int32 *)v8);
  }
  else
  {
    sub_14000B60C((__int64)v3);
  }
  sub_140008C98(&v10);
  return v3;
}
// 140008C98: using guessed type __int64 __fastcall sub_140008C98(_QWORD);

//----- (000000014000D3A0) ----------------------------------------------------
volatile signed __int32 **__fastcall sub_14000D3A0(__int64 a1, volatile signed __int32 **a2, __int64 a3)
{
  volatile signed __int32 **v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rax
  volatile signed __int32 *v10; // [rsp+20h] [rbp-28h]

  v3 = a2;
  v4 = a1;
  v5 = a3;
  sub_140002584((__m128 *)&v10, 8ui64);
  sub_14000CC58(v4, (__m128 *)&v10);
  if ( sub_140006EAC(&v10) )
  {
    v6 = sub_140001B3C((__int64)&v10);
    v7 = v6;
    LODWORD(v8) = sub_14000D4CC(v6, v5);
    if ( (signed int)v8 >= 0 )
      v8 = (signed int)v8;
    else
      v8 = sub_140008E08(v7);
    sub_14000B5E4(v3, &v10, (volatile signed __int32 *)v8);
  }
  else
  {
    sub_14000B60C((__int64)v3);
  }
  sub_140008C98(&v10);
  return v3;
}
// 140008C98: using guessed type __int64 __fastcall sub_140008C98(_QWORD);

//----- (000000014000D450) ----------------------------------------------------
__int64 __fastcall sub_14000D450(__int64 a1, __int64 a2)
{
  signed __int64 v2; // r15
  unsigned int v3; // edi
  int v4; // ebp
  int v5; // esi
  __int64 v6; // r14
  __int64 v7; // rbx
  bool v8; // cl
  int v9; // eax

  v2 = a1 + 24;
  v3 = -1;
  v4 = 0;
  v5 = *(_DWORD *)(a1 + 8) - 1;
  v6 = a2;
  if ( v5 >= 0 )
  {
    do
    {
      v7 = (v5 + v4) / 2;
      v8 = sub_14000BC00(v2 + 11 * v7, v6);
      if ( !v8 )
        v5 = v7 - 1;
      if ( !v8 )
        v3 = v7;
      v9 = v7 + 1;
      if ( !v8 )
        v9 = v4;
      v4 = v9;
    }
    while ( v9 <= v5 );
  }
  return v3;
}

//----- (000000014000D4CC) ----------------------------------------------------
__int64 __fastcall sub_14000D4CC(__int64 a1, __int64 a2)
{
  signed __int64 v2; // r15
  unsigned int v3; // edi
  int v4; // ebp
  int v5; // esi
  __int64 v6; // r14
  __int64 v7; // rbx
  bool v8; // cl
  int v9; // eax

  v2 = a1 + 24;
  v3 = -1;
  v4 = 0;
  v5 = *(_DWORD *)(a1 + 8) - 1;
  v6 = a2;
  if ( v5 >= 0 )
  {
    do
    {
      v7 = (v5 + v4) / 2;
      v8 = sub_14000BC74(v2 + 23 * v7, v6);
      if ( !v8 )
        v5 = v7 - 1;
      if ( !v8 )
        v3 = v7;
      v9 = v7 + 1;
      if ( !v8 )
        v9 = v4;
      v4 = v9;
    }
    while ( v9 <= v5 );
  }
  return v3;
}

//----- (000000014000D548) ----------------------------------------------------
__int64 __fastcall sub_14000D548(__int64 a1)
{
  __int64 v1; // rdi
  __m128i *v2; // rax
  __m128i *v3; // rax
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rbx
  volatile signed __int32 *v7; // rax
  unsigned __int64 v8; // rsi
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rax
  __int64 v13; // r14
  __int64 v14; // rbx
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rsi
  __int64 v20; // rbx
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rbx
  volatile signed __int32 *v24; // rax
  __int64 v25; // rbx
  __int64 v26; // rax
  __int64 v27; // rax
  volatile signed __int32 *v29; // [rsp+20h] [rbp-89h]
  __m128 v30; // [rsp+28h] [rbp-81h]
  __m128 v31; // [rsp+38h] [rbp-71h]
  __int128 v32; // [rsp+50h] [rbp-59h]
  char v33; // [rsp+60h] [rbp-49h]
  char v34; // [rsp+70h] [rbp-39h]
  struct _LIST_ENTRY v35; // [rsp+78h] [rbp-31h]
  struct _LIST_ENTRY v36; // [rsp+90h] [rbp-19h]
  __m128 v37[2]; // [rsp+A8h] [rbp-1h]
  char v38; // [rsp+C8h] [rbp+1Fh]

  v1 = a1;
  sub_1400086B8(&v36);
  sub_1400086B8(&v35);
  sub_1400075EC((__int128 *)v37, v1 + 16);
  v2 = (__m128i *)sub_140003C0C(v1 + 24);
  sub_14000B7F8((__int64 *)&v36, v2);
  v3 = (__m128i *)sub_140003C0C(v1 + 48);
  sub_14000B7F8((__int64 *)&v35, v3);
  sub_1400076D8(v37);
  sub_14000C224((__int64 *)&v36);
  sub_14000C224((__int64 *)&v35);
  sub_140002584((__m128 *)&v34, 8ui64);
  sub_14000CBD8(v1, (__m128 *)&v34);
  if ( !sub_140006EAC(&v34) )
  {
    v23 = sub_14000EB80((__int64)&v36);
    if ( !v23 )
      goto LABEL_35;
    sub_140002584((__m128 *)&v29, 8ui64);
    v24 = (volatile signed __int32 *)sub_14000C008(v23);
    sub_14000B76C(&v29, v24);
    if ( sub_140006EAC(&v29) )
    {
      sub_140002584(&v30, 0x10ui64);
      sub_14000EA44((__int64 *)&v36, &v30);
      sub_140002584(&v31, 0x10ui64);
      sub_14000EACC((__int64)&v36, &v31);
      if ( sub_14000BA58(&v30, &v31) )
      {
        v25 = sub_140001B3C((__int64)&v29);
        do
        {
          v26 = sub_14000BB80((__int64)&v30);
          v27 = sub_140003C0C(v26);
          sub_14000E760(v25, v27);
          sub_14000BBE0((__int64)&v30);
        }
        while ( sub_14000BA58(&v30, &v31) );
      }
      goto LABEL_33;
    }
LABEL_34:
    sub_140008C98(&v29);
    goto LABEL_35;
  }
  v4 = sub_140001B3C((__int64)&v34);
  v5 = sub_140008E08(v4);
  v6 = sub_14000EB80((__int64)&v36) + v5;
  if ( v6 )
  {
    sub_140002584((__m128 *)&v29, 8ui64);
    v7 = (volatile signed __int32 *)sub_14000C008(v6);
    sub_14000B76C(&v29, v7);
    if ( sub_140006EAC(&v29) )
    {
      v8 = 0i64;
      sub_140002584(&v30, 0x10ui64);
      sub_14000EA44((__int64 *)&v36, &v30);
      sub_140002584(&v31, 0x10ui64);
      sub_14000EACC((__int64)&v36, &v31);
      v9 = sub_140001B3C((__int64)&v34);
      if ( sub_140008E08(v9) )
      {
        do
        {
          v10 = sub_140001B3C((__int64)&v34);
          v11 = sub_14000BA88(v10, v8);
          while ( !sub_14000EA98((__int64)&v35) )
          {
            v12 = sub_14000CBB4((__int64 *)&v35);
            if ( !sub_14000BC00(v12, v11) )
              break;
            _mm_storeu_si128((__m128i *)&v32, *(__m128i *)sub_14000EA44((__int64 *)&v35, &v33));
            sub_14000CA24((__int64)&v35, v37, (__m128i *)&v32);
          }
          if ( sub_14000BA58(&v30, &v31) && (v13 = sub_14000BB80((__int64)&v30), sub_14000BC00(v13, v11)) )
          {
            v14 = sub_140001B3C((__int64)&v29);
            if ( sub_14000EAB8(v14) || (v15 = sub_14000C1E8(v14), sub_14000BC00(v15, v13)) )
              sub_14000E760(v14, v13);
            sub_14000BBE0((__int64)&v30);
          }
          else
          {
            if ( sub_14000EA98((__int64)&v35) || (v16 = sub_14000CBB4((__int64 *)&v35), sub_14000BC00(v11, v16)) )
            {
              v17 = sub_140001B3C((__int64)&v29);
              sub_14000E760(v17, v11);
            }
            ++v8;
          }
          v18 = sub_140001B3C((__int64)&v34);
        }
        while ( v8 < sub_140008E08(v18) );
      }
      if ( sub_14000BA58(&v30, &v31) )
      {
        v19 = sub_140001B3C((__int64)&v29);
        do
        {
          if ( sub_14000EAB8(v19)
            || (v20 = sub_14000C1E8(v19), v21 = sub_14000BB80((__int64)&v30), sub_14000BC00(v20, v21)) )
          {
            v22 = sub_14000BB80((__int64)&v30);
            sub_14000E760(v19, v22);
          }
          sub_14000BBE0((__int64)&v30);
        }
        while ( sub_14000BA58(&v30, &v31) );
      }
LABEL_33:
      sub_1400075EC((__int128 *)&v38, v1);
      sub_14000B978((volatile signed __int32 **)(v1 + 8), &v29);
      sub_1400076D8(&v38);
      goto LABEL_34;
    }
    goto LABEL_34;
  }
  sub_1400075EC((__int128 *)v37, v1);
  sub_140009F44((volatile signed __int32 **)(v1 + 8));
  sub_1400076D8(v37);
LABEL_35:
  sub_140008C98(&v34);
  sub_140008B00(&v35);
  return sub_140008B00(&v36);
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);
// 140008B00: using guessed type __int64 __fastcall sub_140008B00(_QWORD);
// 140008C98: using guessed type __int64 __fastcall sub_140008C98(_QWORD);

//----- (000000014000D9CC) ----------------------------------------------------
__int64 __fastcall sub_14000D9CC(__int64 a1)
{
  __int64 v1; // rdi
  __m128i *v2; // rax
  __m128i *v3; // rax
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rbx
  volatile signed __int32 *v7; // rax
  unsigned __int64 v8; // rsi
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rax
  __int64 v13; // r14
  __int64 v14; // rbx
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rsi
  __int64 v20; // rbx
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rbx
  volatile signed __int32 *v24; // rax
  __int64 v25; // rbx
  __int64 v26; // rax
  __int64 v27; // rax
  volatile signed __int32 *v29; // [rsp+20h] [rbp-89h]
  __m128 v30; // [rsp+28h] [rbp-81h]
  __m128 v31; // [rsp+38h] [rbp-71h]
  __int128 v32; // [rsp+50h] [rbp-59h]
  char v33; // [rsp+60h] [rbp-49h]
  char v34; // [rsp+70h] [rbp-39h]
  struct _LIST_ENTRY v35; // [rsp+78h] [rbp-31h]
  struct _LIST_ENTRY v36; // [rsp+90h] [rbp-19h]
  __m128 v37[2]; // [rsp+A8h] [rbp-1h]
  char v38; // [rsp+C8h] [rbp+1Fh]

  v1 = a1;
  sub_1400086B8(&v36);
  sub_1400086B8(&v35);
  sub_1400075EC((__int128 *)v37, v1 + 16);
  v2 = (__m128i *)sub_140003C0C(v1 + 24);
  sub_14000B858((__int64 *)&v36, v2);
  v3 = (__m128i *)sub_140003C0C(v1 + 48);
  sub_14000B858((__int64 *)&v35, v3);
  sub_1400076D8(v37);
  sub_14000C34C((__int64 *)&v36);
  sub_14000C34C((__int64 *)&v35);
  sub_140002584((__m128 *)&v34, 8ui64);
  sub_14000CBD8(v1, (__m128 *)&v34);
  if ( !sub_140006EAC(&v34) )
  {
    v23 = sub_14000EB80((__int64)&v36);
    if ( !v23 )
      goto LABEL_35;
    sub_140002584((__m128 *)&v29, 8ui64);
    v24 = (volatile signed __int32 *)sub_14000C05C(v23);
    sub_14000B76C(&v29, v24);
    if ( sub_140006EAC(&v29) )
    {
      sub_140002584(&v30, 0x10ui64);
      sub_14000EA44((__int64 *)&v36, &v30);
      sub_140002584(&v31, 0x10ui64);
      sub_14000EACC((__int64)&v36, &v31);
      if ( sub_14000BA58(&v30, &v31) )
      {
        v25 = sub_140001B3C((__int64)&v29);
        do
        {
          v26 = sub_14000BB80((__int64)&v30);
          v27 = sub_140003C0C(v26);
          sub_14000E7B8(v25, v27);
          sub_14000BBE0((__int64)&v30);
        }
        while ( sub_14000BA58(&v30, &v31) );
      }
      goto LABEL_33;
    }
LABEL_34:
    sub_140008C98(&v29);
    goto LABEL_35;
  }
  v4 = sub_140001B3C((__int64)&v34);
  v5 = sub_140008E08(v4);
  v6 = sub_14000EB80((__int64)&v36) + v5;
  if ( v6 )
  {
    sub_140002584((__m128 *)&v29, 8ui64);
    v7 = (volatile signed __int32 *)sub_14000C05C(v6);
    sub_14000B76C(&v29, v7);
    if ( sub_140006EAC(&v29) )
    {
      v8 = 0i64;
      sub_140002584(&v30, 0x10ui64);
      sub_14000EA44((__int64 *)&v36, &v30);
      sub_140002584(&v31, 0x10ui64);
      sub_14000EACC((__int64)&v36, &v31);
      v9 = sub_140001B3C((__int64)&v34);
      if ( sub_140008E08(v9) )
      {
        do
        {
          v10 = sub_140001B3C((__int64)&v34);
          v11 = sub_14000BA94(v10, v8);
          while ( !sub_14000EA98((__int64)&v35) )
          {
            v12 = sub_14000CBB4((__int64 *)&v35);
            if ( !sub_14000BC74(v12, v11) )
              break;
            _mm_storeu_si128((__m128i *)&v32, *(__m128i *)sub_14000EA44((__int64 *)&v35, &v33));
            sub_14000CA88((__int64)&v35, v37, (__m128i *)&v32);
          }
          if ( sub_14000BA58(&v30, &v31) && (v13 = sub_14000BB80((__int64)&v30), sub_14000BC74(v13, v11)) )
          {
            v14 = sub_140001B3C((__int64)&v29);
            if ( sub_14000EAB8(v14) || (v15 = sub_14000C1F8(v14), sub_14000BC74(v15, v13)) )
              sub_14000E7B8(v14, v13);
            sub_14000BBE0((__int64)&v30);
          }
          else
          {
            if ( sub_14000EA98((__int64)&v35) || (v16 = sub_14000CBB4((__int64 *)&v35), sub_14000BC74(v11, v16)) )
            {
              v17 = sub_140001B3C((__int64)&v29);
              sub_14000E7B8(v17, v11);
            }
            ++v8;
          }
          v18 = sub_140001B3C((__int64)&v34);
        }
        while ( v8 < sub_140008E08(v18) );
      }
      if ( sub_14000BA58(&v30, &v31) )
      {
        v19 = sub_140001B3C((__int64)&v29);
        do
        {
          if ( sub_14000EAB8(v19)
            || (v20 = sub_14000C1F8(v19), v21 = sub_14000BB80((__int64)&v30), sub_14000BC74(v20, v21)) )
          {
            v22 = sub_14000BB80((__int64)&v30);
            sub_14000E7B8(v19, v22);
          }
          sub_14000BBE0((__int64)&v30);
        }
        while ( sub_14000BA58(&v30, &v31) );
      }
LABEL_33:
      sub_1400075EC((__int128 *)&v38, v1);
      sub_14000B978((volatile signed __int32 **)(v1 + 8), &v29);
      sub_1400076D8(&v38);
      goto LABEL_34;
    }
    goto LABEL_34;
  }
  sub_1400075EC((__int128 *)v37, v1);
  sub_140009F44((volatile signed __int32 **)(v1 + 8));
  sub_1400076D8(v37);
LABEL_35:
  sub_140008C98(&v34);
  sub_140008B08(&v35);
  return sub_140008B08(&v36);
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);
// 140008B08: using guessed type __int64 __fastcall sub_140008B08(_QWORD);
// 140008C98: using guessed type __int64 __fastcall sub_140008C98(_QWORD);

//----- (000000014000DE50) ----------------------------------------------------
__int64 __fastcall sub_14000DE50(__int64 a1)
{
  __int64 v1; // rdi
  __m128i *v2; // rax
  __m128i *v3; // rax
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rbx
  volatile signed __int32 *v7; // rax
  unsigned __int64 v8; // rsi
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rax
  __int64 v13; // r14
  __int64 v14; // rbx
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rsi
  __int64 v20; // rbx
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rbx
  volatile signed __int32 *v24; // rax
  __int64 v25; // rbx
  __int64 v26; // rax
  __int64 v27; // rax
  volatile signed __int32 *v29; // [rsp+20h] [rbp-89h]
  __m128 v30; // [rsp+28h] [rbp-81h]
  __m128 v31; // [rsp+38h] [rbp-71h]
  __int128 v32; // [rsp+50h] [rbp-59h]
  char v33; // [rsp+60h] [rbp-49h]
  char v34; // [rsp+70h] [rbp-39h]
  struct _LIST_ENTRY v35; // [rsp+78h] [rbp-31h]
  struct _LIST_ENTRY v36; // [rsp+90h] [rbp-19h]
  __m128 v37[2]; // [rsp+A8h] [rbp-1h]
  char v38; // [rsp+C8h] [rbp+1Fh]

  v1 = a1;
  sub_1400086B8(&v36);
  sub_1400086B8(&v35);
  sub_1400075EC((__int128 *)v37, v1 + 16);
  v2 = (__m128i *)sub_140003C0C(v1 + 24);
  sub_14000B8B8((__int64 *)&v36, v2);
  v3 = (__m128i *)sub_140003C0C(v1 + 48);
  sub_14000B8B8((__int64 *)&v35, v3);
  sub_1400076D8(v37);
  sub_14000C474((__int64 *)&v36);
  sub_14000C474((__int64 *)&v35);
  sub_140002584((__m128 *)&v34, 8ui64);
  sub_14000CBD8(v1, (__m128 *)&v34);
  if ( !sub_140006EAC(&v34) )
  {
    v23 = sub_14000EB80((__int64)&v36);
    if ( !v23 )
      goto LABEL_35;
    sub_140002584((__m128 *)&v29, 8ui64);
    v24 = (volatile signed __int32 *)sub_14000C0B0(v23);
    sub_14000B76C(&v29, v24);
    if ( sub_140006EAC(&v29) )
    {
      sub_140002584(&v30, 0x10ui64);
      sub_14000EA44((__int64 *)&v36, &v30);
      sub_140002584(&v31, 0x10ui64);
      sub_14000EACC((__int64)&v36, &v31);
      if ( sub_14000BA58(&v30, &v31) )
      {
        v25 = sub_140001B3C((__int64)&v29);
        do
        {
          v26 = sub_14000BB80((__int64)&v30);
          v27 = sub_140003C0C(v26);
          sub_14000E814(v25, v27);
          sub_14000BBE0((__int64)&v30);
        }
        while ( sub_14000BA58(&v30, &v31) );
      }
      goto LABEL_33;
    }
LABEL_34:
    sub_140008C98(&v29);
    goto LABEL_35;
  }
  v4 = sub_140001B3C((__int64)&v34);
  v5 = sub_140008E08(v4);
  v6 = sub_14000EB80((__int64)&v36) + v5;
  if ( v6 )
  {
    sub_140002584((__m128 *)&v29, 8ui64);
    v7 = (volatile signed __int32 *)sub_14000C0B0(v6);
    sub_14000B76C(&v29, v7);
    if ( sub_140006EAC(&v29) )
    {
      v8 = 0i64;
      sub_140002584(&v30, 0x10ui64);
      sub_14000EA44((__int64 *)&v36, &v30);
      sub_140002584(&v31, 0x10ui64);
      sub_14000EACC((__int64)&v36, &v31);
      v9 = sub_140001B3C((__int64)&v34);
      if ( sub_140008E08(v9) )
      {
        do
        {
          v10 = sub_140001B3C((__int64)&v34);
          v11 = sub_14000BAA0(v10, v8);
          while ( !sub_14000EA98((__int64)&v35) )
          {
            v12 = sub_14000CBB4((__int64 *)&v35);
            if ( !sub_14000BCE8(v12, v11) )
              break;
            _mm_storeu_si128((__m128i *)&v32, *(__m128i *)sub_14000EA44((__int64 *)&v35, &v33));
            sub_14000CAEC((__int64)&v35, v37, (__m128i *)&v32);
          }
          if ( sub_14000BA58(&v30, &v31) && (v13 = sub_14000BB80((__int64)&v30), sub_14000BCE8(v13, v11)) )
          {
            v14 = sub_140001B3C((__int64)&v29);
            if ( sub_14000EAB8(v14) || (v15 = sub_14000C204(v14), sub_14000BCE8(v15, v13)) )
              sub_14000E814(v14, v13);
            sub_14000BBE0((__int64)&v30);
          }
          else
          {
            if ( sub_14000EA98((__int64)&v35) || (v16 = sub_14000CBB4((__int64 *)&v35), sub_14000BCE8(v11, v16)) )
            {
              v17 = sub_140001B3C((__int64)&v29);
              sub_14000E814(v17, v11);
            }
            ++v8;
          }
          v18 = sub_140001B3C((__int64)&v34);
        }
        while ( v8 < sub_140008E08(v18) );
      }
      if ( sub_14000BA58(&v30, &v31) )
      {
        v19 = sub_140001B3C((__int64)&v29);
        do
        {
          if ( sub_14000EAB8(v19)
            || (v20 = sub_14000C204(v19), v21 = sub_14000BB80((__int64)&v30), sub_14000BCE8(v20, v21)) )
          {
            v22 = sub_14000BB80((__int64)&v30);
            sub_14000E814(v19, v22);
          }
          sub_14000BBE0((__int64)&v30);
        }
        while ( sub_14000BA58(&v30, &v31) );
      }
LABEL_33:
      sub_1400075EC((__int128 *)&v38, v1);
      sub_14000B978((volatile signed __int32 **)(v1 + 8), &v29);
      sub_1400076D8(&v38);
      goto LABEL_34;
    }
    goto LABEL_34;
  }
  sub_1400075EC((__int128 *)v37, v1);
  sub_140009F44((volatile signed __int32 **)(v1 + 8));
  sub_1400076D8(v37);
LABEL_35:
  sub_140008C98(&v34);
  sub_140008B10(&v35);
  return sub_140008B10(&v36);
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);
// 140008B10: using guessed type __int64 __fastcall sub_140008B10(_QWORD);
// 140008C98: using guessed type __int64 __fastcall sub_140008C98(_QWORD);

//----- (000000014000E2D4) ----------------------------------------------------
__int64 __fastcall sub_14000E2D4(__int64 a1)
{
  __int64 v1; // rdi
  __m128i *v2; // rax
  __m128i *v3; // rax
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rbx
  volatile signed __int32 *v7; // rax
  unsigned __int64 v8; // rsi
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rax
  __int64 v13; // r14
  __int64 v14; // rbx
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rsi
  __int64 v20; // rbx
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rbx
  volatile signed __int32 *v24; // rax
  __int64 v25; // rbx
  __int64 v26; // rax
  __int64 v27; // rax
  volatile signed __int32 *v29; // [rsp+20h] [rbp-89h]
  __m128 v30; // [rsp+28h] [rbp-81h]
  __m128 v31; // [rsp+38h] [rbp-71h]
  __int128 v32; // [rsp+50h] [rbp-59h]
  char v33; // [rsp+60h] [rbp-49h]
  char v34; // [rsp+70h] [rbp-39h]
  struct _LIST_ENTRY v35; // [rsp+78h] [rbp-31h]
  struct _LIST_ENTRY v36; // [rsp+90h] [rbp-19h]
  __m128 v37[2]; // [rsp+A8h] [rbp-1h]
  char v38; // [rsp+C8h] [rbp+1Fh]

  v1 = a1;
  sub_1400086B8(&v36);
  sub_1400086B8(&v35);
  sub_1400075EC((__int128 *)v37, v1 + 16);
  v2 = (__m128i *)sub_140003C0C(v1 + 24);
  sub_14000B918((__int64 *)&v36, v2);
  v3 = (__m128i *)sub_140003C0C(v1 + 48);
  sub_14000B918((__int64 *)&v35, v3);
  sub_1400076D8(v37);
  sub_14000C59C((__int64 *)&v36);
  sub_14000C59C((__int64 *)&v35);
  sub_140002584((__m128 *)&v34, 8ui64);
  sub_14000CBD8(v1, (__m128 *)&v34);
  if ( !sub_140006EAC(&v34) )
  {
    v23 = sub_14000EB80((__int64)&v36);
    if ( !v23 )
      goto LABEL_35;
    sub_140002584((__m128 *)&v29, 8ui64);
    v24 = (volatile signed __int32 *)sub_14000C104(v23);
    sub_14000B76C(&v29, v24);
    if ( sub_140006EAC(&v29) )
    {
      sub_140002584(&v30, 0x10ui64);
      sub_14000EA44((__int64 *)&v36, &v30);
      sub_140002584(&v31, 0x10ui64);
      sub_14000EACC((__int64)&v36, &v31);
      if ( sub_14000BA58(&v30, &v31) )
      {
        v25 = sub_140001B3C((__int64)&v29);
        do
        {
          v26 = sub_14000BB80((__int64)&v30);
          v27 = sub_140003C0C(v26);
          sub_14000E874(v25, v27);
          sub_14000BBE0((__int64)&v30);
        }
        while ( sub_14000BA58(&v30, &v31) );
      }
      goto LABEL_33;
    }
LABEL_34:
    sub_140008C98(&v29);
    goto LABEL_35;
  }
  v4 = sub_140001B3C((__int64)&v34);
  v5 = sub_140008E08(v4);
  v6 = sub_14000EB80((__int64)&v36) + v5;
  if ( v6 )
  {
    sub_140002584((__m128 *)&v29, 8ui64);
    v7 = (volatile signed __int32 *)sub_14000C104(v6);
    sub_14000B76C(&v29, v7);
    if ( sub_140006EAC(&v29) )
    {
      v8 = 0i64;
      sub_140002584(&v30, 0x10ui64);
      sub_14000EA44((__int64 *)&v36, &v30);
      sub_140002584(&v31, 0x10ui64);
      sub_14000EACC((__int64)&v36, &v31);
      v9 = sub_140001B3C((__int64)&v34);
      if ( sub_140008E08(v9) )
      {
        do
        {
          v10 = sub_140001B3C((__int64)&v34);
          v11 = sub_14000BAAC(v10, v8);
          while ( !sub_14000EA98((__int64)&v35) )
          {
            v12 = sub_14000CBB4((__int64 *)&v35);
            if ( !sub_14000BD5C(v12, v11) )
              break;
            _mm_storeu_si128((__m128i *)&v32, *(__m128i *)sub_14000EA44((__int64 *)&v35, &v33));
            sub_14000CB50((__int64)&v35, v37, (__m128i *)&v32);
          }
          if ( sub_14000BA58(&v30, &v31) && (v13 = sub_14000BB80((__int64)&v30), sub_14000BD5C(v13, v11)) )
          {
            v14 = sub_140001B3C((__int64)&v29);
            if ( sub_14000EAB8(v14) || (v15 = sub_14000C214(v14), sub_14000BD5C(v15, v13)) )
              sub_14000E874(v14, v13);
            sub_14000BBE0((__int64)&v30);
          }
          else
          {
            if ( sub_14000EA98((__int64)&v35) || (v16 = sub_14000CBB4((__int64 *)&v35), sub_14000BD5C(v11, v16)) )
            {
              v17 = sub_140001B3C((__int64)&v29);
              sub_14000E874(v17, v11);
            }
            ++v8;
          }
          v18 = sub_140001B3C((__int64)&v34);
        }
        while ( v8 < sub_140008E08(v18) );
      }
      if ( sub_14000BA58(&v30, &v31) )
      {
        v19 = sub_140001B3C((__int64)&v29);
        do
        {
          if ( sub_14000EAB8(v19)
            || (v20 = sub_14000C214(v19), v21 = sub_14000BB80((__int64)&v30), sub_14000BD5C(v20, v21)) )
          {
            v22 = sub_14000BB80((__int64)&v30);
            sub_14000E874(v19, v22);
          }
          sub_14000BBE0((__int64)&v30);
        }
        while ( sub_14000BA58(&v30, &v31) );
      }
LABEL_33:
      sub_1400075EC((__int128 *)&v38, v1);
      sub_14000B978((volatile signed __int32 **)(v1 + 8), &v29);
      sub_1400076D8(&v38);
      goto LABEL_34;
    }
    goto LABEL_34;
  }
  sub_1400075EC((__int128 *)v37, v1);
  sub_140009F44((volatile signed __int32 **)(v1 + 8));
  sub_1400076D8(v37);
LABEL_35:
  sub_140008C98(&v34);
  sub_140008B18(&v35);
  return sub_140008B18(&v36);
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);
// 140008B18: using guessed type __int64 __fastcall sub_140008B18(_QWORD);
// 140008C98: using guessed type __int64 __fastcall sub_140008C98(_QWORD);

//----- (000000014000E758) ----------------------------------------------------
__int64 __fastcall sub_14000E758(unsigned int a1)
{
  return _byteswap_ulong(a1);
}

//----- (000000014000E760) ----------------------------------------------------
signed __int64 __fastcall sub_14000E760(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // rbx
  signed __int64 v4; // rdi
  __int64 v5; // rax

  v2 = *(_QWORD *)(a1 + 8);
  v3 = a2;
  v4 = a1 + 11 * v2;
  *(_QWORD *)(a1 + 8) = v2 + 1;
  v5 = sub_140008CB8(11i64, v4 + 24);
  if ( v5 )
  {
    *(_QWORD *)v5 = *(_QWORD *)v3;
    *(_WORD *)(v5 + 8) = *(_WORD *)(v3 + 8);
    *(_BYTE *)(v5 + 10) = *(_BYTE *)(v3 + 10);
  }
  return v4 + 24;
}

//----- (000000014000E7B8) ----------------------------------------------------
signed __int64 __fastcall sub_14000E7B8(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // rbx
  signed __int64 v4; // rdi
  __int64 v5; // rax

  v2 = *(_QWORD *)(a1 + 8);
  v3 = a2;
  v4 = a1 + 23 * v2;
  *(_QWORD *)(a1 + 8) = v2 + 1;
  v5 = sub_140008CB8(23i64, v4 + 24);
  if ( v5 )
  {
    *(_OWORD *)v5 = *(_OWORD *)v3;
    *(_DWORD *)(v5 + 16) = *(_DWORD *)(v3 + 16);
    *(_WORD *)(v5 + 20) = *(_WORD *)(v3 + 20);
    *(_BYTE *)(v5 + 22) = *(_BYTE *)(v3 + 22);
  }
  return v4 + 24;
}

//----- (000000014000E814) ----------------------------------------------------
signed __int64 __fastcall sub_14000E814(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // rbx
  signed __int64 v4; // rdi
  __int64 v5; // rax

  v2 = *(_QWORD *)(a1 + 8);
  v3 = a2;
  v4 = a1 + 15 * v2;
  *(_QWORD *)(a1 + 8) = v2 + 1;
  v5 = sub_140008CB8(15i64, v4 + 24);
  if ( v5 )
  {
    *(_QWORD *)v5 = *(_QWORD *)v3;
    *(_DWORD *)(v5 + 8) = *(_DWORD *)(v3 + 8);
    *(_WORD *)(v5 + 12) = *(_WORD *)(v3 + 12);
    *(_BYTE *)(v5 + 14) = *(_BYTE *)(v3 + 14);
  }
  return v4 + 24;
}

//----- (000000014000E874) ----------------------------------------------------
signed __int64 __fastcall sub_14000E874(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // rbx
  signed __int64 v4; // rdi
  __int64 v5; // rax

  v2 = *(_QWORD *)(a1 + 8);
  v3 = a2;
  v4 = a1 + 39 * v2;
  *(_QWORD *)(a1 + 8) = v2 + 1;
  v5 = sub_140008CB8(39i64, v4 + 24);
  if ( v5 )
  {
    *(_OWORD *)v5 = *(_OWORD *)v3;
    *(_OWORD *)(v5 + 16) = *(_OWORD *)(v3 + 16);
    *(_DWORD *)(v5 + 32) = *(_DWORD *)(v3 + 32);
    *(_WORD *)(v5 + 36) = *(_WORD *)(v3 + 36);
    *(_BYTE *)(v5 + 38) = *(_BYTE *)(v3 + 38);
  }
  return v4 + 24;
}

//----- (000000014000E8D8) ----------------------------------------------------
__int64 __fastcall sub_14000E8D8(__int64 a1, int a2)
{
  __int64 v2; // rax
  char v4; // [rsp+40h] [rbp+18h]
  char v5; // [rsp+48h] [rbp+20h]

  if ( a2 == 1 )
    v2 = sub_14000E9EC(a1, (__int64)&v4);
  else
    v2 = sub_14000C9CC(a1, (__int64)&v5);
  return sub_14000BAF8(v2);
}

//----- (000000014000E904) ----------------------------------------------------
__m128i *__fastcall sub_14000E904(__int64 a1, __m128 *a2, __int64 a3)
{
  __m128i *v3; // rsi
  __int64 v4; // rdi
  __int64 v5; // rbx

  v3 = (__m128i *)a2;
  v4 = a1;
  v5 = a3;
  sub_140002584(a2, 0x10ui64);
  _mm_storeu_si128(v3, *(__m128i *)v5);
  sub_14000BBE0((__int64)v3);
  sub_140004F14(*(_QWORD **)(v5 + 8));
  --*(_QWORD *)(v4 + 16);
  return v3;
}

//----- (000000014000E958) ----------------------------------------------------
__int64 __fastcall sub_14000E958(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  sub_14000C784(a1);
  sub_14000C7E4(v1 + 72);
  sub_14000C6C4(v1 + 144);
  return sub_14000C724(v1 + 216);
}

//----- (000000014000E98C) ----------------------------------------------------
__int64 __fastcall sub_14000E98C(__int64 a1, __int64 a2)
{
  int v2; // ebx
  __int64 v3; // rdi
  __int64 v4; // r8

  v2 = *(_DWORD *)(a1 + 16);
  v3 = a2;
  if ( v2 == 2048 )
  {
    v4 = sub_140006988(*(_QWORD *)a1, *(unsigned int *)(a1 + 28)) + 12;
  }
  else if ( v2 == 34525 )
  {
    v4 = sub_140006988(*(_QWORD *)a1, *(unsigned int *)(a1 + 28)) + 8;
  }
  else
  {
    v4 = 0i64;
  }
  sub_14000B714(v3, v2, v4);
  return v3;
}

//----- (000000014000E9EC) ----------------------------------------------------
__int64 __fastcall sub_14000E9EC(__int64 a1, __int64 a2)
{
  int v2; // eax
  __int64 v3; // rbx
  __int64 v4; // rdi
  __int16 v5; // r8
  int v6; // edx
  unsigned __int8 *v7; // rax
  __int16 v8; // ax

  v2 = *(_DWORD *)(a1 + 20);
  v3 = a2;
  v4 = a1;
  if ( v2 == 6 || v2 == 17 )
  {
    v7 = (unsigned __int8 *)sub_140006988(*(_QWORD *)a1, *(unsigned int *)(a1 + 32));
    v8 = sub_140008DF4(v7);
    v6 = *(_DWORD *)(v4 + 16);
    v5 = v8;
  }
  else
  {
    v5 = 0;
    v6 = 0;
  }
  sub_14000B73C(v3, v6, v5);
  return v3;
}

//----- (000000014000EA40) ----------------------------------------------------
__int64 __fastcall sub_14000EA40(unsigned int *a1)
{
  return *a1;
}

//----- (000000014000EA44) ----------------------------------------------------
_QWORD *__fastcall sub_14000EA44(__int64 *a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  v2 = a2;
  sub_14000B628(a2, (__int64)a1, *a1);
  return v2;
}

//----- (000000014000EA64) ----------------------------------------------------
volatile signed __int32 **__fastcall sub_14000EA64(__int64 a1, volatile signed __int32 **a2)
{
  volatile signed __int32 **v2; // rbx
  volatile signed __int32 **v3; // rax
  char v5; // [rsp+38h] [rbp+10h]

  v2 = a2;
  v3 = (volatile signed __int32 **)sub_14000CC58(a1, (__m128 *)&v5);
  sub_14000B5E4(v2, v3, 0i64);
  sub_140008C98(&v5);
  return v2;
}
// 140008C98: using guessed type __int64 __fastcall sub_140008C98(_QWORD);

//----- (000000014000EA98) ----------------------------------------------------
bool __fastcall sub_14000EA98(__int64 a1)
{
  return (unsigned __int8)IsListEmpty(a1) != 0;
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);

//----- (000000014000EAAC) ----------------------------------------------------
bool __fastcall sub_14000EAAC(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) == 0i64;
}

//----- (000000014000EAB8) ----------------------------------------------------
bool __fastcall sub_14000EAB8(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) == 0i64;
}

//----- (000000014000EACC) ----------------------------------------------------
_QWORD *__fastcall sub_14000EACC(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx

  v2 = a2;
  sub_14000B628(a2, a1, a1);
  return v2;
}

//----- (000000014000EAEC) ----------------------------------------------------
volatile signed __int32 **__fastcall sub_14000EAEC(__int64 a1, volatile signed __int32 **a2)
{
  volatile signed __int32 **v2; // rdi
  __int64 v3; // rbx
  bool v4; // al
  volatile signed __int32 *v5; // r8
  __int64 v6; // rax
  volatile signed __int32 *v8; // [rsp+20h] [rbp-18h]

  v2 = a2;
  v3 = a1;
  sub_140002584((__m128 *)&v8, 8ui64);
  sub_14000CC58(v3, (__m128 *)&v8);
  v4 = sub_140006EAC(&v8);
  v5 = 0i64;
  if ( v4 )
  {
    v6 = sub_140001B3C((__int64)&v8);
    v5 = (volatile signed __int32 *)sub_140008E08(v6);
  }
  sub_14000B5E4(v2, &v8, v5);
  sub_140008C98(&v8);
  return v2;
}
// 140008C98: using guessed type __int64 __fastcall sub_140008C98(_QWORD);

//----- (000000014000EB80) ----------------------------------------------------
__int64 __fastcall sub_14000EB80(__int64 a1)
{
  return *(_QWORD *)(a1 + 16);
}

//----- (000000014000EB88) ----------------------------------------------------
__int64 __fastcall sub_14000EB88(__int64 a1, int a2)
{
  int v2; // ebx
  __int64 v3; // rdi
  int v4; // eax
  char v6; // [rsp+30h] [rbp-68h]
  int v7; // [rsp+50h] [rbp-48h]

  *(_QWORD *)a1 = 0i64;
  v2 = a2;
  *(_DWORD *)(a1 + 8) = 0;
  v3 = a1;
  sub_14001E1C0((__m128 *)&v6, 0, 0x48ui64);
  v7 = v2;
  v4 = FwpmEngineOpen0(0i64, 0xFFFFFFFFi64, 0i64, &v6, v3);
  *(_DWORD *)(v3 + 8) = v4;
  if ( v4 < 0 )
    *(_QWORD *)v3 = 0i64;
  return v3;
}
// 14001DC84: using guessed type __int64 __fastcall FwpmEngineOpen0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014000EC10) ----------------------------------------------------
__int64 __fastcall sub_14000EC10(_QWORD *a1)
{
  __int64 v1; // rcx
  __int64 result; // rax

  v1 = *a1;
  if ( v1 )
    result = FwpmEngineClose0(v1);
  return result;
}
// 14001DC8A: using guessed type __int64 __fastcall FwpmEngineClose0(_QWORD);

//----- (000000014000EC28) ----------------------------------------------------
__int64 __fastcall sub_14000EC28(_QWORD *a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // er15
  __int64 v4; // r14
  _QWORD *v5; // rsi
  signed int v6; // ebx
  __int64 v8; // [rsp+40h] [rbp-40h]
  __int64 v9; // [rsp+48h] [rbp-38h]
  __int64 v10; // [rsp+50h] [rbp-30h]
  __int64 v11; // [rsp+58h] [rbp-28h]
  __int64 v12; // [rsp+60h] [rbp-20h]
  void *v13; // [rsp+68h] [rbp-18h]

  v12 = 0i64;
  v11 = 0i64;
  v8 = 0i64;
  v3 = a3;
  v10 = 0i64;
  v9 = 0i64;
  v4 = a2;
  v5 = a1;
  v6 = FwpmEngineGetSecurityInfo0(*a1, 4i64, &v12, &v11, &v8, &v10, &v9);
  if ( v6 >= 0 && v8 )
  {
    sub_140002584((__m128 *)&v13, 8ui64);
    sub_140006ED4((__m128 *)&v13, v8, v4, v3);
    FwpmFreeMemory0(&v9);
    if ( sub_140001B3C((__int64)&v13) )
    {
      sub_140001B3C((__int64)&v13);
      v6 = FwpmEngineSetSecurityInfo0(*v5, 4i64, 0i64);
    }
    else
    {
      v6 = -1073741823;
      sub_140002E58(
        L"Failed to add SID to WFP ACL",
        0,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsfwpmengine.cpp",
        59);
    }
    sub_140006E08(&v13);
  }
  return (unsigned int)v6;
}
// 14001DC7E: using guessed type __int64 __fastcall FwpmFreeMemory0(_QWORD);
// 14001DCC6: using guessed type __int64 __fastcall FwpmEngineGetSecurityInfo0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 14001DCCC: using guessed type __int64 __fastcall FwpmEngineSetSecurityInfo0(_QWORD, _QWORD, _QWORD);
// 140020390: using guessed type wchar_t aFailedToAddSid[29];

//----- (000000014000ED60) ----------------------------------------------------
__int64 __fastcall sub_14000ED60(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rcx
  __int64 result; // rax

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    result = FwpsInjectionHandleDestroy0(v2);
    *v1 = 0i64;
  }
  return result;
}
// 14001DCD8: using guessed type __int64 __fastcall FwpsInjectionHandleDestroy0(_QWORD);

//----- (000000014000ED80) ----------------------------------------------------
__int64 __fastcall sub_14000ED80(__int64 a1, __int64 a2, __int64 a3, __int64 (*a4)(void))
{
  __int64 (*v4)(void); // rsi
  __int64 v5; // rbx
  __int64 v6; // rbp
  __int64 v7; // rdi
  __int64 result; // rax

  if ( a3 )
  {
    v4 = a4;
    v5 = a3;
    v6 = a2;
    v7 = a1;
    do
    {
      result = sub_14001E1B0(v4);
      v7 += v6;
      --v5;
    }
    while ( v5 );
  }
  return result;
}

//----- (000000014000EDD0) ----------------------------------------------------
void __fastcall sub_14000EDD0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  int v2; // eax

  v1 = a1;
  if ( !*a1 )
  {
    v2 = FwpsInjectionHandleCreate0(0i64, 16i64, a1);
    if ( v2 < 0 )
    {
      sub_140002E58(
        L"Unable to create injection handle",
        v2,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsinjectionhandle.cpp",
        39);
      *v1 = 0i64;
    }
  }
}
// 14001DCD2: using guessed type __int64 __fastcall FwpsInjectionHandleCreate0(_QWORD, _QWORD, _QWORD);
// 140020420: using guessed type wchar_t aUnableToCreate[34];

//----- (000000014000EE20) ----------------------------------------------------
__int64 __fastcall sub_14000EE20(__int64 a1, __int64 a2)
{
  return sub_14000EF50(0i64, a1, a2);
}

//----- (000000014000EE30) ----------------------------------------------------
__int64 __fastcall sub_14000EE30(__int64 a1, char *a2)
{
  unsigned __int16 v2; // ax
  char *v3; // rbx
  __int64 v4; // rdi

  v2 = *a2;
  v3 = a2;
  v4 = a1;
  while ( v2 )
  {
    sub_14000EF38(v4, v2);
    v2 = *++v3;
  }
  return v4;
}
// 14000EF38: using guessed type __int64 __fastcall sub_14000EF38(_QWORD, _QWORD);

//----- (000000014000EE6C) ----------------------------------------------------
__m128i *__fastcall sub_14000EE6C(__m128i *a1, __int64 a2, __int32 a3, __int32 a4, __int32 a5, __m128i *a6, __int64 a7)
{
  int v7; // ebx
  __int64 v8; // rdi
  __m128i *v9; // rsi
  __m128i *result; // rax
  __int128 v11; // [rsp+30h] [rbp-18h]

  v7 = a3;
  v8 = a2;
  v9 = a1;
  _mm_storeu_si128((__m128i *)&v11, *a6);
  sub_140013E8C(a1, a2, a3, a4, (__m128i *)&v11);
  v9->m128i_i64[0] = (__int64)off_14002E378;
  v9[4].m128i_i32[0] = a5;
  v9[4].m128i_i64[1] = a7;
  v9[5].m128i_i64[0] = sub_14000F1B8(v8, v7);
  result = v9;
  v9[5].m128i_i8[8] = 0;
  return result;
}
// 14002E378: using guessed type __int64 (__fastcall *off_14002E378[13])();

//----- (000000014000EEF0) ----------------------------------------------------
void **__fastcall sub_14000EEF0(_QWORD *a1)
{
  void **result; // rax

  *a1 = &off_14002E310;
  result = &off_14002E2B0;
  *a1 = &off_14002E2B0;
  return result;
}
// 14002E2B0: using guessed type void *off_14002E2B0;
// 14002E310: using guessed type __int64 (__fastcall *off_14002E310)();

//----- (000000014000EF28) ----------------------------------------------------
PSLIST_ENTRY __fastcall sub_14000EF28(struct _SLIST_ENTRY *a1)
{
  return sub_14000424C(&stru_140034480.L.ListHead, a1);
}

//----- (000000014000EF48) ----------------------------------------------------
__int64 (__fastcall *sub_14000EF48())(__int64 a1, __int64 a2)
{
  return sub_14000EE20;
}

//----- (000000014000EF50) ----------------------------------------------------
__int64 __fastcall sub_14000EF50(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax

  if ( a3 )
    result = FwpsFreeCloneNetBufferList0(a3, 0i64);
  return result;
}
// 14001DCE4: using guessed type __int64 __fastcall FwpsFreeCloneNetBufferList0(_QWORD, _QWORD);

//----- (000000014000EF70) ----------------------------------------------------
void *__fastcall sub_14000EF70(_QWORD *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_14000EEF0(a1);
  if ( v2 & 1 )
    sub_140007714(v3);
  return v3;
}

//----- (000000014000EFB0) ----------------------------------------------------
struct _SLIST_ENTRY *__fastcall sub_14000EFB0(CPullPin *a1, char a2)
{
  char v2; // di
  struct _SLIST_ENTRY *v3; // rbx

  v2 = a2;
  v3 = (struct _SLIST_ENTRY *)a1;
  CPullPin::~CPullPin(a1);
  if ( v2 & 1 )
  {
    if ( v2 & 4 )
      nullsub_1(v3, 96i64);
    else
      sub_14000EF28(v3);
  }
  return v3;
}
// 140004C90: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);

//----- (000000014000EFF4) ----------------------------------------------------
PVOID __fastcall sub_14000EFF4(__int64 a1, __int64 a2)
{
  return ExAllocatePoolWithTag((POOL_TYPE)512, 2 * a2, 0x69707354u);
}

//----- (000000014000F020) ----------------------------------------------------
void __fastcall sub_14000F020(__int64 a1)
{
  void *v2; // rbx
  unsigned int v3; // eax
  bool v4; // r12
  __int64 (*v5)(void); // r15
  int v8; // edi
  char *v9; // rax
  __int64 v10; // rdx
  int v11; // ebx
  const wchar_t *v12; // rcx

  _R14 = a1;
  if ( !*(_BYTE *)(a1 + 88) )
  {
    v2 = sub_140013188();
    v3 = sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)_R14 + 48i64));
    if ( v3 <= 1 )
    {
      v4 = v3 == 0;
      if ( v3 )
        v5 = (__int64 (*)(void))*((_QWORD *)v2 + 1);
      else
        v5 = (__int64 (*)(void))*((_QWORD *)v2 + 2);
      _RBP = 0i64;
      __asm { xchg    rbp, [r14+50h] }
      if ( _RBP )
      {
        v8 = *(_DWORD *)(_R14 + 64);
        sub_14000F454(_R14);
        v9 = sub_140007D68(1u);
        sub_140001B3C((__int64)v9);
        sub_14000EF48();
        v10 = *(_QWORD *)(_R14 + 72);
        v11 = sub_14001E1B0(v5);
        if ( v11 < 0 )
        {
          FwpsFreeCloneNetBufferList0(_RBP, 0i64);
          v12 = L"Failed to re-inject received packet";
          if ( v4 )
            v12 = L"Failed to re-inject sent packet";
          sub_140002E58(
            v12,
            v11,
            0,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsinterceptwfp.cpp",
            162);
        }
        else
        {
          *(_BYTE *)(_R14 + 88) = 1;
        }
        sub_140013FFC(_R14);
        sub_140009F04();
      }
    }
    else
    {
      sub_140002E58(
        L"Unable to re-inject packet because direction makes no sense '%d'",
        0,
        v3,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsinterceptwfp.cpp",
        169);
    }
  }
}
// 14001DCE4: using guessed type __int64 __fastcall FwpsFreeCloneNetBufferList0(_QWORD, _QWORD);
// 1400204D0: using guessed type wchar_t aFailedToReInje_0[32];
// 140020510: using guessed type wchar_t aFailedToReInje[36];
// 140020560: using guessed type wchar_t aUnableToReInje[65];

//----- (000000014000F17C) ----------------------------------------------------
__int64 *__fastcall sub_14000F17C(__int64 *a1, __int16 a2)
{
  __int16 v2; // di
  __int64 *v3; // rbx
  _WORD *v4; // rax

  v2 = a2;
  v3 = a1;
  v4 = (_WORD *)sub_14000F458(a1, 1i64);
  if ( v4 )
    *v4 = v2;
  return v3;
}

//----- (000000014000F1AC) ----------------------------------------------------
void __fastcall sub_14000F1AC(__int64 a1)
{
  *(_QWORD *)(a1 + 256) = 0i64;
}

//----- (000000014000F1B8) ----------------------------------------------------
__int64 __fastcall sub_14000F1B8(__int64 a1, int a2)
{
  int v2; // ebp
  __int64 v3; // rbx
  __int64 v4; // rcx
  signed int v5; // esi
  unsigned int v6; // edi
  int v7; // er14
  __int64 v9; // [rsp+30h] [rbp-28h]

  v9 = 0i64;
  v2 = a2;
  v3 = a1;
  if ( a1 )
  {
    v4 = *(_QWORD *)(a1 + 8);
    v5 = -1073741823;
    v6 = *(_DWORD *)(v4 + 40);
    if ( v6 )
      v5 = NdisRetreatNetBufferDataStart(v4, v6, 0i64, 0i64);
    v7 = FwpsAllocateCloneNetBufferList0(v3, 0i64, 0i64, 0i64, &v9);
    if ( v5 >= 0 )
      NdisAdvanceNetBufferDataStart(*(_QWORD *)(v3 + 8), v6, 0i64, 0i64);
    if ( v7 >= 0 )
    {
      if ( v5 >= 0 )
        NdisAdvanceNetBufferDataStart(*(_QWORD *)(v9 + 8), v6, 0i64, 0i64);
      if ( v2 )
        NdisCopyReceiveNetBufferListInfo(v9, v3);
      else
        NdisCopySendNetBufferListInfo(v9, v3);
    }
  }
  return v9;
}
// 14001DC24: using guessed type __int64 __fastcall NdisRetreatNetBufferDataStart(_QWORD, _QWORD, _QWORD, _QWORD);
// 14001DC2A: using guessed type __int64 __fastcall NdisAdvanceNetBufferDataStart(_QWORD, _QWORD, _QWORD, _QWORD);
// 14001DC30: using guessed type __int64 __fastcall NdisCopySendNetBufferListInfo(_QWORD, _QWORD);
// 14001DC36: using guessed type __int64 __fastcall NdisCopyReceiveNetBufferListInfo(_QWORD, _QWORD);
// 14001DCDE: using guessed type __int64 __fastcall FwpsAllocateCloneNetBufferList0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014000F29C) ----------------------------------------------------
__int64 __fastcall sub_14000F29C(__int64 a1, __int64 a2)
{
  unsigned int v2; // er8
  __int64 v3; // r9
  __int64 result; // rax

  v2 = 0;
  if ( *(_QWORD *)(a1 + 256) )
  {
    v3 = 0i64;
    do
    {
      result = *(unsigned __int16 *)(a1 + 2 * v3);
      ++v2;
      *(_WORD *)(a2 + 2 * v3) = result;
      v3 = v2;
    }
    while ( (unsigned __int64)v2 < *(_QWORD *)(a1 + 256) );
  }
  return result;
}

//----- (000000014000F2D0) ----------------------------------------------------
__int64 __fastcall sub_14000F2D0(__int64 a1, __int64 a2)
{
  return sub_14000EF40(a2, "[intercept]");
}
// 14000EF40: using guessed type __int64 __fastcall sub_14000EF40(_QWORD, _QWORD);

//----- (000000014000F2E0) ----------------------------------------------------
void __fastcall sub_14000F2E0(__int64 a1)
{
  void *v1; // rdx
  __int64 v2; // rbx
  char v3; // [rsp+30h] [rbp+8h]

  v1 = *(void **)(a1 + 8);
  v2 = a1;
  if ( v1 )
  {
    sub_14000F338((__int64)&v3, v1);
    *(_QWORD *)(v2 + 8) = 0i64;
  }
}

//----- (000000014000F310) ----------------------------------------------------
void __fastcall sub_14000F310(_BYTE *a1)
{
  int v1; // eax

  if ( !a1[88] )
  {
    v1 = sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)a1 + 48i64));
    sub_14000A1BC(2, v1);
  }
}

//----- (000000014000F338) ----------------------------------------------------
void __fastcall sub_14000F338(__int64 a1, void *a2)
{
  ExFreePoolWithTag(a2, 0x69707354u);
}

//----- (000000014000F348) ----------------------------------------------------
__int64 __fastcall sub_14000F348(__int64 _RCX)
{
  __int64 result; // rax

  _RAX = 0i64;
  __asm { xchg    rax, [rcx+50h] }
  if ( result )
    result = FwpsFreeCloneNetBufferList0(result, 0i64);
  return result;
}
// 14001DCE4: using guessed type __int64 __fastcall FwpsFreeCloneNetBufferList0(_QWORD, _QWORD);

//----- (000000014000F368) ----------------------------------------------------
signed __int64 __fastcall sub_14000F368(__int64 a1, __int64 a2)
{
  __int64 v2; // r9
  signed __int64 v3; // r8

  v2 = *(_QWORD *)(a1 + 256);
  v3 = 0i64;
  if ( (unsigned __int64)(v2 + a2 + 1) <= 0x80 )
  {
    v3 = a1 + 2 * v2;
    *(_QWORD *)(a1 + 256) = v2 + a2;
  }
  return v3;
}

//----- (000000014000F394) ----------------------------------------------------
__int64 __fastcall sub_14000F394(__int64 a1)
{
  return *(_QWORD *)(a1 + 256);
}

//----- (000000014000F3A0) ----------------------------------------------------
__m128i *__fastcall sub_14000F3A0(__m128i *a1, __m128i *a2)
{
  __m128i *result; // rax

  result = a2;
  _mm_storeu_si128(a2, a1[2]);
  return result;
}

//----- (000000014000F3B0) ----------------------------------------------------
bool __fastcall sub_14000F3B0(__int64 a1)
{
  return *(_QWORD *)(a1 + 80) != 0i64;
}

//----- (000000014000F3BC) ----------------------------------------------------
void __fastcall sub_14000F3BC(__int64 *a1)
{
  __int64 *v1; // rbx
  __int64 v2; // rsi
  _WORD *v3; // rdi
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // rdx

  v1 = a1;
  v2 = sub_14000F49C(a1);
  v3 = sub_14000EFF4((__int64)v1, v2 + 1);
  if ( v3 )
  {
    v4 = v1[2];
    v5 = 0i64;
    if ( v4 )
    {
      do
      {
        v3[v5] = *(_WORD *)(v1[1] + 2 * v5);
        ++v5;
        v4 = v1[2];
      }
      while ( v5 < v4 );
    }
    sub_14000F29C(*v1, (__int64)&v3[v4]);
    v3[v2] = 0;
    sub_14000F1AC(*v1);
    v1[2] = v2;
    sub_14000F2E0((__int64)v1);
    v1[1] = (__int64)v3;
  }
}

//----- (000000014000F454) ----------------------------------------------------
__int64 __fastcall sub_14000F454(__int64 a1)
{
  return *(unsigned int *)(a1 + 48);
}

//----- (000000014000F458) ----------------------------------------------------
signed __int64 __fastcall sub_14000F458(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rbx
  signed __int64 result; // rax
  __int64 v4; // rcx
  __int64 v5; // rdi

  v2 = a1;
  result = 0i64;
  v4 = *a1;
  v5 = a2;
  if ( v4 )
  {
    result = sub_14000F368(v4, a2);
    if ( !result )
    {
      sub_14000F3BC(v2);
      result = sub_14000F368(*v2, v5);
    }
  }
  return result;
}

//----- (000000014000F49C) ----------------------------------------------------
__int64 __fastcall sub_14000F49C(__int64 *a1)
{
  return a1[2] + sub_14000F394(*a1);
}

//----- (000000014000F4B8) ----------------------------------------------------
_QWORD *__fastcall sub_14000F4B8(_QWORD *a1)
{
  _QWORD *v1; // rbx
  int v2; // eax

  *a1 = 0i64;
  v1 = a1;
  v2 = sub_14000F61C(0i64);
  if ( v2 < 0 )
  {
    sub_140002E58(
      L"Failed to create spinlock",
      v2,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipslock.cpp",
      20);
    *v1 = 0i64;
  }
  return v1;
}
// 140020640: using guessed type wchar_t aFailedToCreate_1[26];

//----- (000000014000F500) ----------------------------------------------------
_QWORD *__fastcall sub_14000F500(_QWORD *a1)
{
  _QWORD *v1; // rbx
  int v2; // eax

  v1 = a1;
  v2 = sub_14000F66C(0i64);
  if ( v2 < 0 )
  {
    sub_140002E58(
      L"Failed to create spinlock",
      v2,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipslock.cpp",
      57);
    *v1 = 0i64;
  }
  return v1;
}
// 140020640: using guessed type wchar_t aFailedToCreate_1[26];

//----- (000000014000F544) ----------------------------------------------------
char __fastcall sub_14000F544(__int64 *a1)
{
  __int64 *v1; // rbx
  char result; // al

  v1 = a1;
  result = sub_140006EAC(a1);
  if ( result )
  {
    result = sub_14000F5EC(*v1);
    *v1 = 0i64;
  }
  return result;
}

//----- (000000014000F568) ----------------------------------------------------
char __fastcall sub_14000F568(__int64 *a1)
{
  __int64 *v1; // rbx
  char result; // al

  v1 = a1;
  result = sub_140006EAC(a1);
  if ( result )
    result = sub_14000F604(*v1);
  return result;
}

//----- (000000014000F588) ----------------------------------------------------
char __fastcall sub_14000F588(__int64 *a1)
{
  __int64 *v1; // rbx
  char result; // al

  v1 = a1;
  result = sub_140006EAC(a1);
  if ( result )
    result = sub_14000F650(*v1);
  return result;
}

//----- (000000014000F5AC) ----------------------------------------------------
char __fastcall sub_14000F5AC(__int64 *a1)
{
  __int64 *v1; // rbx
  char result; // al

  v1 = a1;
  result = sub_140006EAC(a1);
  if ( result )
    result = sub_14000F638(*v1);
  return result;
}

//----- (000000014000F5CC) ----------------------------------------------------
char __fastcall sub_14000F5CC(__int64 *a1)
{
  __int64 *v1; // rbx
  char result; // al

  v1 = a1;
  result = sub_140006EAC(a1);
  if ( result )
    result = sub_14000F688(*v1);
  return result;
}

//----- (000000014000F5EC) ----------------------------------------------------
__int64 __fastcall sub_14000F5EC(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_140036E50);
}
// 140036E50: using guessed type __int64 qword_140036E50;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014000F604) ----------------------------------------------------
__int64 __fastcall sub_14000F604(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_1400371B0);
}
// 1400371B0: using guessed type __int64 qword_1400371B0;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014000F61C) ----------------------------------------------------
__int64 __fastcall sub_14000F61C(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_1400371A8);
}
// 1400371A8: using guessed type __int64 qword_1400371A8;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014000F638) ----------------------------------------------------
__int64 __fastcall sub_14000F638(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_1400371B8);
}
// 1400371B8: using guessed type __int64 qword_1400371B8;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014000F650) ----------------------------------------------------
__int64 __fastcall sub_14000F650(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_140037198);
}
// 140037198: using guessed type __int64 qword_140037198;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014000F66C) ----------------------------------------------------
__int64 __fastcall sub_14000F66C(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_140037190);
}
// 140037190: using guessed type __int64 qword_140037190;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014000F688) ----------------------------------------------------
__int64 __fastcall sub_14000F688(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_1400371A0);
}
// 1400371A0: using guessed type __int64 qword_1400371A0;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014000F6A0) ----------------------------------------------------
__int64 __fastcall sub_14000F6A0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  __int64 result; // rax

  v2 = a1;
  *(_QWORD *)a1 = *(_QWORD *)a2;
  v3 = a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  unknown_libname_1(a1 + 32);
  *(_QWORD *)(v3 + 8) = 0i64;
  result = v2;
  *(_QWORD *)(v3 + 16) = 0i64;
  return result;
}
// 140001AB0: using guessed type __int64 __fastcall unknown_libname_1(_QWORD);

//----- (000000014000F6F0) ----------------------------------------------------
_QWORD *__fastcall sub_14000F6F0(__int64 a1, __int64 a2, int a3)
{
  _QWORD *v3; // rbx

  *(_QWORD *)(a1 + 8) = 0i64;
  v3 = (_QWORD *)a1;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = a2;
  *(_BYTE *)(a1 + 24) = a3 == 0;
  unknown_libname_1(a1 + 32);
  *v3 = ((*v3 - 1i64) & 0xFFFFFFFFFFFFF000ui64) + 4096;
  return v3;
}
// 140001AB0: using guessed type __int64 __fastcall unknown_libname_1(_QWORD);

//----- (000000014000F738) ----------------------------------------------------
struct _MDL **__fastcall sub_14000F738(struct _MDL **a1, void *a2, ULONG a3)
{
  struct _MDL **v3; // rbx
  struct _MDL *v4; // rax

  *a1 = 0i64;
  v3 = a1;
  v4 = IoAllocateMdl(a2, a3, 0, 0, 0i64);
  *v3 = v4;
  if ( v4 )
    MmBuildMdlForNonPagedPool(v4);
  return v3;
}

//----- (000000014000F77C) ----------------------------------------------------
__int64 __fastcall sub_14000F77C(_QWORD *a1)
{
  _QWORD *v1; // rbx

  v1 = a1;
  sub_14000F9A8(a1);
  return CAMEvent::~CAMEvent((CAMEvent *)(v1 + 4));
}

//----- (000000014000F7A0) ----------------------------------------------------
_QWORD *__fastcall sub_14000F7A0(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rdi
  _QWORD *v3; // rbx

  v2 = a2;
  v3 = a1;
  if ( a2 != a1 )
  {
    sub_14000F9A8(a1);
    *v3 = *v2;
    v3[1] = v2[1];
    v3[2] = v2[2];
    *((_BYTE *)v3 + 24) = *((_BYTE *)v2 + 24);
    v2[1] = 0i64;
    v2[2] = 0i64;
  }
  return v3;
}

//----- (000000014000F7F0) ----------------------------------------------------
CAMEvent *__fastcall sub_14000F7F0(CAMEvent *a1, CAMEvent *a2)
{
  CAMEvent *v2; // rdi
  CAMEvent *v3; // rbx

  v2 = a2;
  v3 = a1;
  if ( a2 != a1 )
  {
    CAMEvent::~CAMEvent(a1);
    *(_QWORD *)v3 = *(_QWORD *)v2;
    *(_QWORD *)v2 = 0i64;
  }
  return v3;
}

//----- (000000014000F824) ----------------------------------------------------
PVOID __fastcall sub_14000F824(SIZE_T *a1)
{
  PVOID result; // rax
  SIZE_T *v2; // rbx

  result = (PVOID)a1[1];
  v2 = a1;
  if ( !result )
  {
    result = ExAllocatePoolWithTag((POOL_TYPE)512, *a1, 0x30737049u);
    v2[1] = (SIZE_T)result;
    if ( result )
    {
      RtlSecureZeroMemory(result, *v2);
      result = (PVOID)v2[1];
    }
  }
  return result;
}

//----- (000000014000F868) ----------------------------------------------------
char __fastcall sub_14000F868(__int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rdi
  char v4; // bl
  unsigned __int64 v5; // r14
  __int64 v6; // r15
  __int64 *v7; // rsi
  __int64 v8; // rbp
  __int64 v9; // rbp
  unsigned __int64 v10; // r12
  __int64 v11; // rdi
  unsigned __int64 v12; // rax

  v3 = a1[2];
  v4 = 0;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( v3 )
  {
    v8 = a1[1];
    if ( v8 )
    {
      v9 = v8 - v3;
      v10 = sub_140006988(a1[1], *a1);
      v11 = 0i64;
      v4 = 1;
      if ( v5 )
      {
        while ( 1 )
        {
          v12 = sub_140006988(*(_QWORD *)(v6 + 8 * v11), v9);
          *(_QWORD *)(v6 + 8 * v11) = v12;
          if ( v12 < v7[1] || v12 >= v10 )
            break;
          if ( ++v11 >= v5 )
            return v4;
        }
        v4 = 0;
      }
    }
  }
  return v4;
}

//----- (000000014000F908) ----------------------------------------------------
char __fastcall sub_14000F908(__int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rbp
  char v4; // bl
  unsigned __int64 v5; // r15
  __int64 v6; // r14
  __int64 *v7; // rdi
  __int64 v8; // rsi
  __int64 v9; // rbp
  unsigned __int64 v10; // r12
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rcx

  v3 = a1[2];
  v4 = 0;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( v3 )
  {
    v8 = a1[1];
    if ( v8 )
    {
      v9 = v3 - v8;
      v10 = sub_140006988(a1[1], *a1);
      v11 = 0i64;
      v4 = 1;
      if ( v5 )
      {
        while ( 1 )
        {
          v12 = *(_QWORD *)(v6 + 8 * v11);
          if ( v12 < v7[1] || v12 >= v10 )
            break;
          *(_QWORD *)(v6 + 8 * v11++) = sub_140006988(v12, v9);
          if ( v11 >= v5 )
            return v4;
        }
        v4 = 0;
      }
    }
  }
  return v4;
}

//----- (000000014000F9A8) ----------------------------------------------------
void __fastcall sub_14000F9A8(_QWORD *a1)
{
  _QWORD *v1; // rdi
  void *v2; // rcx
  void *v3; // rsi
  struct _MDL *v4; // rax
  char v5; // [rsp+30h] [rbp+8h]

  v1 = a1;
  v2 = (void *)a1[1];
  if ( v2 )
  {
    v3 = (void *)v1[2];
    if ( v3 )
    {
      v4 = (struct _MDL *)sub_140001B3C((__int64)(v1 + 4));
      MmUnmapLockedPages(v3, v4);
      unknown_libname_1(&v5);
      sub_14000F7F0((CAMEvent *)(v1 + 4), (CAMEvent *)&v5);
      CAMEvent::~CAMEvent((CAMEvent *)&v5);
      v1[2] = 0i64;
      v2 = (void *)v1[1];
    }
    ExFreePoolWithTag(v2, 0);
    v1[1] = 0i64;
  }
}
// 140001AB0: using guessed type __int64 __fastcall unknown_libname_1(_QWORD);

//----- (000000014000FA44) ----------------------------------------------------
__int64 __fastcall sub_14000FA44(SIZE_T *a1)
{
  SIZE_T *v1; // rbx
  signed __int64 v2; // rdi
  CAMEvent *v4; // rsi
  struct _MDL **v5; // rax
  int v6; // ebx
  struct _MDL *v7; // rax
  SIZE_T *v8; // [rsp+50h] [rbp+8h]
  struct _MDL *v9; // [rsp+58h] [rbp+10h]
  SIZE_T *v10; // [rsp+60h] [rbp+18h]
  SIZE_T *v11; // [rsp+68h] [rbp+20h]

  v8 = a1;
  v1 = a1;
  v2 = (signed __int64)(a1 + 2);
  v10 = a1 + 2;
  if ( !a1[2] )
  {
    if ( !a1[1] && !sub_14000F824(a1) )
    {
      DbgPrint("Failed to allocate non-paged memory\n");
      return 0i64;
    }
    v4 = (CAMEvent *)(v1 + 4);
    v11 = v1 + 4;
    v5 = sub_14000F738(&v9, (void *)v1[1], *v1);
    sub_14000F7F0((CAMEvent *)(v1 + 4), (CAMEvent *)v5);
    CAMEvent::~CAMEvent((CAMEvent *)&v9);
    if ( sub_140001B3C((__int64)(v1 + 4)) )
    {
      v6 = *((_BYTE *)v1 + 24) != 0 ? -1073741808 : 1073741840;
      v7 = (struct _MDL *)sub_140001B3C((__int64)v4);
      *(_QWORD *)v2 = sub_14000FB70(v7, 1, 0, 0i64, 0, v6);
      if ( !*(_QWORD *)v2 )
      {
        DbgPrint("Failed to map memory to make it accessible to userspace");
        unknown_libname_1(&v8);
        sub_14000F7F0(v4, (CAMEvent *)&v8);
        CAMEvent::~CAMEvent((CAMEvent *)&v8);
      }
    }
    else
    {
      DbgPrint("Failed to create a MDL to describe the mapped memory.\n");
    }
  }
  return *(_QWORD *)v2;
}
// 140001AB0: using guessed type __int64 __fastcall unknown_libname_1(_QWORD);

//----- (000000014000FB70) ----------------------------------------------------
PVOID __fastcall sub_14000FB70(struct _MDL *a1, KPROCESSOR_MODE a2, MEMORY_CACHING_TYPE a3, void *a4, ULONG a5, int a6)
{
  return MmMapLockedPagesSpecifyCache(a1, a2, a3, a4, a5, (MM_PAGE_PRIORITY)(a6 | 0x40000000));
}

//----- (000000014000FBA0) ----------------------------------------------------
_QWORD *__fastcall sub_14000FBA0(_QWORD *a1)
{
  _QWORD *v1; // rbx

  v1 = a1;
  *a1 = NdisAllocateGenericObject(0i64, 1098084425i64, 32i64);
  return v1;
}
// 14001DC3C: using guessed type __int64 __fastcall NdisAllocateGenericObject(_QWORD, _QWORD, _QWORD);

//----- (000000014000FBC8) ----------------------------------------------------
__int64 __fastcall sub_14000FBC8(_QWORD *a1)
{
  __int64 result; // rax

  if ( *a1 )
    result = NdisFreeGenericObject();
  return result;
}
// 14001DC42: using guessed type __int64 NdisFreeGenericObject(void);

//----- (000000014000FBE0) ----------------------------------------------------
__int64 __fastcall sub_14000FBE0(_QWORD *a1)
{
  __int64 result; // rax

  if ( *a1 )
    result = NdisFreeNetBufferListPool();
  return result;
}
// 14001DC4E: using guessed type __int64 NdisFreeNetBufferListPool(void);

//----- (000000014000FBF8) ----------------------------------------------------
__int64 __fastcall sub_14000FBF8(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // r13
  unsigned int v4; // esi
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // r14
  __int64 v7; // r15
  bool v8; // zf
  PVOID v9; // rax
  __int64 v10; // r12
  unsigned int v11; // ebp
  int v12; // ebx
  __m128i *v13; // rax
  __int64 v15; // [rsp+68h] [rbp+10h]

  v15 = a2;
  v3 = *(_QWORD *)(a1 + 8);
  v4 = -1073741823;
  if ( v3 )
  {
    v5 = *(unsigned int *)(v3 + 24);
    v6 = 0i64;
    v7 = *(_QWORD *)(v3 + 32);
    if ( v5 > a3 )
      v5 = a3;
    while ( v7 )
    {
      v8 = v6 == v5;
      if ( v6 >= v5 )
        goto LABEL_16;
      v9 = sub_14000FD78(v7, -1073741808);
      v10 = (__int64)v9;
      if ( !v9 )
      {
        sub_140002DD4(
          L"Failed to get address from mdl",
          0i64,
          0i64,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipsnbl.cpp",
          47);
        break;
      }
      v11 = *(_DWORD *)(v7 + 40);
      if ( v7 == *(_QWORD *)(v3 + 8) )
      {
        v12 = *(_DWORD *)(v3 + 16);
        v10 = sub_140006988((__int64)v9, *(unsigned int *)(v3 + 16));
        v11 -= v12;
      }
      if ( v6 + v11 > v5 )
        v11 = v5 - v6;
      v13 = (__m128i *)sub_140006988(v15, v6);
      sub_14001E2C0(v13, v10, v11);
      v7 = *(_QWORD *)v7;
      v6 += v11;
    }
    v8 = v6 == v5;
LABEL_16:
    if ( v8 )
      v4 = 0;
  }
  return v4;
}
// 1400207B0: using guessed type wchar_t aFailedToGetAdd[31];

//----- (000000014000FCFC) ----------------------------------------------------
__int64 __fastcall sub_14000FCFC(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rbx
  __int64 result; // rax
  int v4; // [rsp+20h] [rbp-20h]
  int v5; // [rsp+24h] [rbp-1Ch]
  __int64 v6; // [rsp+28h] [rbp-18h]

  v2 = a1;
  v4 = 1048960;
  v5 = 256;
  v6 = 1098084425i64;
  result = NdisAllocateNetBufferListPool(a2, &v4);
  *v2 = result;
  return result;
}
// 14001DC48: using guessed type __int64 __fastcall NdisAllocateNetBufferListPool(_QWORD, _QWORD);

//----- (000000014000FD60) ----------------------------------------------------
__m128 *sub_14000FD60()
{
  return stru_140034AD8;
}

//----- (000000014000FD68) ----------------------------------------------------
void *sub_14000FD68()
{
  return &unk_140034AD0;
}

//----- (000000014000FD70) ----------------------------------------------------
__int64 __fastcall sub_14000FD70(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 8) + 24i64);
}

//----- (000000014000FD78) ----------------------------------------------------
PVOID __fastcall sub_14000FD78(__int64 a1, int a2)
{
  PVOID result; // rax

  if ( *(_BYTE *)(a1 + 10) & 5 )
    result = *(PVOID *)(a1 + 24);
  else
    result = sub_14000FB70((struct _MDL *)a1, 0, MmCached, 0i64, 0, a2);
  return result;
}

//----- (000000014000FDA4) ----------------------------------------------------
void __fastcall sub_14000FDA4(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rbp
  _QWORD *v3; // rdi
  _QWORD *v4; // rsi
  _QWORD *v5; // r14
  PVOID v6; // rax

  if ( a1 )
  {
    v1 = a1;
    do
    {
      v2 = (_QWORD *)*v1;
      *v1 = 0i64;
      v3 = (_QWORD *)v1[1];
      while ( v3 )
      {
        v4 = (_QWORD *)v3[4];
        v3[4] = 0i64;
        v3 = (_QWORD *)*v3;
        if ( v4 )
        {
          do
          {
            v5 = (_QWORD *)*v4;
            *v4 = 0i64;
            v6 = sub_14000FD78((__int64)v4, 32);
            if ( v6 )
              ExFreePoolWithTag(v6, 0);
            NdisFreeMdl(v4);
            v4 = v5;
          }
          while ( v5 );
        }
      }
      FwpsFreeNetBufferList0(v1);
      v1 = v2;
    }
    while ( v2 );
  }
}
// 14001DC54: using guessed type __int64 __fastcall NdisFreeMdl(_QWORD);
// 14001DCEA: using guessed type __int64 __fastcall FwpsFreeNetBufferList0(_QWORD);

//----- (000000014000FE4C) ----------------------------------------------------
__int64 __fastcall sub_14000FE4C(__int64 a1, int a2, unsigned int *a3, __int16 a4)
{
  __int16 v4; // bx
  unsigned int *v5; // rdi
  int v6; // esi
  __int64 v7; // rbp

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  unknown_libname_2(a1);
  *(_WORD *)(v7 + 16) = 0;
  sub_14001009C(v7, v6, v5, v4);
  return v7;
}
// 140003A00: using guessed type __int64 __fastcall unknown_libname_2(_QWORD);

//----- (000000014000FEA0) ----------------------------------------------------
__int64 __fastcall sub_14000FEA0(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rsi
  unsigned __int64 v4; // rbx
  __int64 v5; // rdi

  *(_DWORD *)a1 = 0;
  v3 = a1;
  *(_DWORD *)(a1 + 4) = 0;
  v4 = a3;
  *(_BYTE *)(a1 + 8) = 0;
  v5 = a2;
  sub_140007598(a1 + 10);
  sub_140007598(v3 + 28);
  *(_BYTE *)(v3 + 46) = 0;
  sub_1400102AC(v3, v5, v4);
  return v3;
}

//----- (000000014000FEFC) ----------------------------------------------------
char __fastcall sub_14000FEFC(unsigned int *a1, unsigned int *a2)
{
  unsigned int *v2; // r14
  __int64 v3; // rbp
  int v4; // esi
  char v5; // di
  int v6; // ebx
  bool v7; // bl
  int v8; // eax
  int v9; // eax
  bool v10; // al

  v2 = a2;
  v3 = (__int64)a1;
  v4 = sub_14000EA40(a1);
  v5 = 1;
  v7 = 0;
  if ( v4 == (unsigned int)sub_14000EA40(v2) )
  {
    v6 = sub_1400083C8((__int64)v2);
    if ( (unsigned int)sub_1400083C8(v3) == v6 )
      v7 = 1;
  }
  v10 = 1;
  if ( v4 == 2048 || v4 == 34525 )
  {
    v8 = sub_1400083C8(v3);
    if ( !sub_1400104D8((_DWORD *)(v3 + 10), (unsigned int *)((char *)v2 + 10), v4, v8)
      || (v9 = sub_1400083C8(v3), !sub_1400104D8((_DWORD *)(v3 + 28), v2 + 7, v4, v9)) )
    {
      v10 = 0;
    }
  }
  if ( !v7 || !v10 )
    v5 = 0;
  return v5;
}

//----- (000000014000FFCC) ----------------------------------------------------
bool __fastcall sub_14000FFCC(unsigned int *a1, unsigned int *a2)
{
  unsigned int *v2; // rdi
  __int64 v3; // rbp
  int v4; // esi
  signed int v5; // ebx
  signed int v6; // ebx

  v2 = a2;
  v3 = (__int64)a1;
  v4 = sub_14000EA40(a1);
  if ( v4 < (signed int)sub_14000EA40(v2) )
    return 1;
  if ( (signed int)sub_14000EA40(v2) < v4 )
    return 0;
  v5 = sub_1400083C8((__int64)v2);
  if ( (signed int)sub_1400083C8(v3) < v5 )
    return 1;
  v6 = sub_1400083C8((__int64)v2);
  if ( v6 < (signed int)sub_1400083C8(v3) )
    return 0;
  if ( !sub_140010594(v3 + 10, (__int64)v2 + 10, v4) )
  {
    if ( !sub_140010594((__int64)v2 + 10, v3 + 10, v4) )
      return sub_140010594(v3 + 28, (__int64)(v2 + 7), v4);
    return 0;
  }
  return 1;
}

//----- (000000014001009C) ----------------------------------------------------
__int64 __fastcall sub_14001009C(__int64 a1, int a2, unsigned int *a3, __int16 a4)
{
  char *v4; // r8
  signed __int64 v5; // rdx
  __int64 result; // rax

  *(_WORD *)(a1 + 16) = a4;
  if ( a2 == 2048 )
  {
    result = *a3;
    *(_DWORD *)a1 = result;
  }
  else if ( a2 == 34525 && a3 )
  {
    v4 = (char *)a3 - a1;
    v5 = 4i64;
    do
    {
      result = *(unsigned int *)&v4[a1];
      *(_DWORD *)a1 = result;
      a1 += 4i64;
      --v5;
    }
    while ( v5 );
  }
  return result;
}

//----- (00000001400100D8) ----------------------------------------------------
void __fastcall sub_1400100D8(_DWORD *a1, __int16 *a2)
{
  __int16 *v2; // r14
  _DWORD *v3; // rsi
  __int64 v4; // rcx
  __int16 v5; // r15
  __int16 v6; // r12
  signed __int64 v7; // rax
  __int64 v8; // rdx
  bool v9; // al
  bool v10; // bl
  int v11; // er10
  unsigned int *v12; // r8
  __int64 v13; // rdi
  signed __int64 v14; // r10
  signed __int64 v15; // rdi
  __int64 v16; // rax
  unsigned int *v17; // rdi
  bool v18; // al
  unsigned int *v19; // r10
  int v20; // er11
  unsigned int v21; // [rsp+30h] [rbp-20h]
  unsigned int v22; // [rsp+34h] [rbp-1Ch]
  unsigned int v23; // [rsp+38h] [rbp-18h]
  unsigned int v24; // [rsp+3Ch] [rbp-14h]
  unsigned int v25; // [rsp+40h] [rbp-10h]

  v2 = a2;
  *a1 = 0;
  v3 = a1;
  v21 = 0;
  v22 = 0;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  if ( a2 )
  {
    sub_140005878(*a2, &v21, &v22, &v24, &v25, &v23);
    v4 = *((_QWORD *)v2 + 1);
    v5 = *(_WORD *)(v4 + 16i64 * v24 + 8);
    v6 = *(_WORD *)(v4 + 16i64 * v25 + 8);
    if ( (unsigned __int16)sub_140010498(*v2) == 2 )
    {
      v7 = 2i64 * v21;
      *v3 = 2048;
      v8 = *((_QWORD *)v2 + 1);
      v25 = _byteswap_ulong(*(_DWORD *)(v8 + 8 * v7 + 8));
      v24 = _byteswap_ulong(*(_DWORD *)(v8 + 16i64 * v22 + 8));
      v9 = sub_1400105F0(&v25, v5, &v24, v6);
      v10 = !v9;
      *((_BYTE *)v3 + 8) = !v9;
      sub_14001009C((__int64)v3 + (v9 != 1 ? 28i64 : 10i64), v11, &v25, v5);
      v12 = &v24;
    }
    else
    {
      v13 = v22;
      v14 = 2i64 * v21;
      *v3 = 34525;
      v15 = 2 * v13;
      v16 = *((_QWORD *)v2 + 1);
      if ( !*(_DWORD *)(v16 + 8 * v14) || !*(_DWORD *)(v16 + 8 * v15) )
      {
        *v3 = 0;
        goto LABEL_9;
      }
      v17 = *(unsigned int **)(v16 + 8 * v15 + 8);
      v18 = sub_140010608(*(_DWORD **)(v16 + 8 * v14 + 8), v5, v17, v6);
      v10 = !v18;
      *((_BYTE *)v3 + 8) = !v18;
      sub_14001009C((__int64)v3 + (v18 != 1 ? 28i64 : 10i64), v20, v19, v5);
      v12 = v17;
    }
    sub_14001009C((__int64)v3 + (-(signed __int64)(v10 != 0) & 0xFFFFFFFFFFFFFFEEui64) + 28, *v3, v12, v6);
LABEL_9:
    v3[1] = *(unsigned __int8 *)(*((_QWORD *)v2 + 1) + 16i64 * v23 + 8);
  }
}

//----- (00000001400102AC) ----------------------------------------------------
__int16 __fastcall sub_1400102AC(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int8 *v3; // rax
  unsigned __int64 v4; // rsi
  __int64 v5; // rbp
  __int64 v6; // rbx
  int v7; // er14
  unsigned int *v8; // rax
  unsigned int *v9; // r13
  int v10; // edi
  unsigned __int8 *v11; // r15
  __int16 v12; // si
  __int16 v13; // bp
  int v14; // edi
  int v15; // edi
  unsigned int *v16; // rdi
  unsigned int *v17; // r14
  bool v18; // al
  int v19; // er10
  int v20; // eax
  int v21; // eax
  void *retaddr; // [rsp+48h] [rbp+0h]
  int v24; // [rsp+60h] [rbp+18h]

  v3 = (unsigned __int8 *)&retaddr;
  v4 = a3;
  v5 = a2;
  v6 = a1;
  if ( a3 < 0xE )
    goto LABEL_19;
  v24 = 0;
  v7 = (unsigned __int16)sub_140008DF4((unsigned __int8 *)(a2 + 12));
  v8 = (unsigned int *)sub_140006988(v5, 14i64);
  v9 = v8;
  v3 = (unsigned __int8 *)sub_1400099CC(v8, v4 - 14, v7, &v24);
  v10 = v24;
  *(_DWORD *)(v6 + 4) = v24;
  if ( !v3 || v4 < (unsigned __int64)(v3 + 12) )
    goto LABEL_19;
  v3 = (unsigned __int8 *)sub_140006988(v5, (__int64)(v3 + 14));
  v11 = v3;
  v12 = 0;
  v13 = 0;
  v14 = v10 - 1;
  if ( !v14 )
    goto LABEL_8;
  v15 = v14 - 5;
  if ( v15 )
  {
    if ( v15 != 11 )
    {
LABEL_19:
      *(_DWORD *)v6 = 0;
      return (signed __int16)v3;
    }
  }
  v12 = sub_140008DF4(v3);
  LOWORD(v3) = sub_140008DF4(v11 + 2);
  v13 = (signed __int16)v3;
LABEL_8:
  if ( v7 == 2048 )
  {
    *(_DWORD *)v6 = 2048;
    v16 = v9 + 4;
    v17 = v9 + 3;
    sub_14000EA40((unsigned int *)v6);
    v18 = sub_1400105F0(v9 + 3, v12, v9 + 4, v13);
  }
  else
  {
    if ( v7 != 34525 )
      return (signed __int16)v3;
    *(_DWORD *)v6 = 34525;
    v16 = v9 + 6;
    v17 = v9 + 2;
    sub_14000EA40((unsigned int *)v6);
    v18 = sub_140010608(v9 + 2, v12, v9 + 6, v13);
  }
  if ( v18 )
  {
    sub_14001009C(v6 + 10, v19, v17, v12);
    v20 = sub_14000EA40((unsigned int *)v6);
    LOWORD(v3) = sub_14001009C(v6 + 28, v20, v16, v13);
  }
  else
  {
    sub_14001009C(v6 + 28, v19, v17, v12);
    v21 = sub_14000EA40((unsigned int *)v6);
    LOWORD(v3) = sub_14001009C(v6 + 10, v21, v16, v13);
    *(_BYTE *)(v6 + 8) = 1;
  }
  return (signed __int16)v3;
}

//----- (0000000140010498) ----------------------------------------------------
signed __int64 __fastcall sub_140010498(__int16 a1)
{
  signed __int64 result; // rax

  result = 2i64;
  if ( a1 != 44 )
  {
    switch ( a1 )
    {
      case 46:
        goto LABEL_11;
      case 48:
        return result;
      case 50:
        goto LABEL_11;
      case 64:
        return result;
      case 65:
LABEL_11:
        result = 23i64;
        break;
      default:
        result = 0i64;
        break;
    }
  }
  return result;
}

//----- (00000001400104D8) ----------------------------------------------------
bool __fastcall sub_1400104D8(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  char v4; // bl
  int v5; // ebp
  _DWORD *v6; // rdi
  _DWORD *v7; // rsi

  v4 = 1;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( a4 == 1 || a4 == 58 )
    return sub_140010544(a1, a2, a3);
  if ( !sub_140010588((__int64)a1, (__int64)a2) || !sub_140010544(v7, v6, v5) )
    v4 = 0;
  return v4;
}

//----- (0000000140010544) ----------------------------------------------------
bool __fastcall sub_140010544(_DWORD *a1, _DWORD *a2, int a3)
{
  char v3; // r9

  v3 = 0;
  if ( a3 == 2048 )
    return *a1 == *a2;
  if ( a3 == 34525 && *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3] )
    v3 = 1;
  return v3;
}

//----- (0000000140010588) ----------------------------------------------------
bool __fastcall sub_140010588(__int64 a1, __int64 a2)
{
  return *(_WORD *)(a1 + 16) == *(_WORD *)(a2 + 16);
}

//----- (0000000140010594) ----------------------------------------------------
bool __fastcall sub_140010594(__int64 a1, __int64 a2, int a3)
{
  unsigned __int16 v3; // ax
  unsigned __int16 v4; // r9
  unsigned int v5; // eax
  unsigned int v6; // eax

  v3 = *(_WORD *)(a1 + 16);
  v4 = *(_WORD *)(a2 + 16);
  if ( v3 >= v4 )
  {
    if ( v4 < v3 )
      return 0;
    if ( a3 == 2048 )
      return *(_DWORD *)a1 < *(_DWORD *)a2;
    if ( a3 != 34525 )
      return 0;
    if ( *(_DWORD *)a1 >= *(_DWORD *)a2 )
    {
      if ( *(_DWORD *)a1 > *(_DWORD *)a2 )
        return 0;
      v5 = *(_DWORD *)(a1 + 4);
      if ( v5 < *(_DWORD *)(a2 + 4) )
        return 1;
      if ( v5 > *(_DWORD *)(a2 + 4) )
        return 0;
      v6 = *(_DWORD *)(a1 + 8);
      if ( v6 >= *(_DWORD *)(a2 + 8) )
      {
        if ( v6 <= *(_DWORD *)(a2 + 8) )
          return *(_DWORD *)(a1 + 12) < *(_DWORD *)(a2 + 12);
        return 0;
      }
    }
  }
  return 1;
}

//----- (00000001400105F0) ----------------------------------------------------
bool __fastcall sub_1400105F0(_DWORD *a1, unsigned __int16 a2, _DWORD *a3, unsigned __int16 a4)
{
  if ( a2 < a4 )
    return 1;
  if ( a2 <= a4 )
    return *a1 < *a3;
  return 0;
}

//----- (0000000140010608) ----------------------------------------------------
bool __fastcall sub_140010608(_DWORD *a1, unsigned __int16 a2, _DWORD *a3, unsigned __int16 a4)
{
  unsigned int v4; // eax
  unsigned int v5; // eax

  if ( a2 < a4 )
    return 1;
  if ( a2 > a4 )
    return 0;
  if ( *a1 < *a3 )
    return 1;
  if ( *a1 > *a3 )
    return 0;
  v4 = a1[1];
  if ( v4 < a3[1] )
    return 1;
  if ( v4 > a3[1] )
    return 0;
  v5 = a1[2];
  if ( v5 >= a3[2] )
  {
    if ( v5 <= a3[2] )
      return a1[3] < a3[3];
    return 0;
  }
  return 1;
}

//----- (0000000140010640) ----------------------------------------------------
__int64 __fastcall sub_140010640(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  result = a1;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 80);
  return result;
}

//----- (0000000140010680) ----------------------------------------------------
signed __int64 __fastcall sub_140010680(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rbx
  __int64 v5; // rax
  _QWORD *v6; // rbx

  v2 = a1;
  v3 = a2;
  v4 = sub_140010910(104i64);
  if ( v4 )
  {
    v5 = sub_140003C0C(v3);
    v6 = (_QWORD *)sub_140010640(v4, v5);
  }
  else
  {
    v6 = 0i64;
  }
  if ( v6 )
  {
    ++*(_QWORD *)(v2 + 16);
    sub_140004DE4(v2, v6);
  }
  return (unsigned __int64)(v6 + 2) & -(signed __int64)(v6 != 0i64);
}

//----- (00000001400106F4) ----------------------------------------------------
__int64 __fastcall sub_1400106F4(__int64 a1, int a2, _OWORD *a3)
{
  __int64 v3; // rbx
  __int64 v4; // rax

  *(_DWORD *)a1 = a2;
  v3 = a1;
  *(_OWORD *)(a1 + 4) = *a3;
  *(_OWORD *)(a1 + 20) = a3[1];
  *(_OWORD *)(a1 + 36) = a3[2];
  v4 = sub_1400130E8();
  *(_QWORD *)(v3 + 64) = 0i64;
  *(_QWORD *)(v3 + 56) = v4;
  sub_140010744(v3 + 72);
  sub_140010744(v3 + 80);
  return v3;
}

//----- (0000000140010744) ----------------------------------------------------
__int64 __fastcall sub_140010744(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)a1 = 0;
  result = a1;
  *(_BYTE *)(a1 + 4) &= 0xFCu;
  return result;
}

//----- (0000000140010750) ----------------------------------------------------
__int64 __fastcall sub_140010750(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  int v4; // eax
  __int64 v5; // rax
  __int64 v6; // rbx
  _QWORD *v7; // rax
  __int64 v9; // [rsp+30h] [rbp-19h]
  __int64 v10; // [rsp+38h] [rbp-11h]
  void *(__fastcall *v11)(__int64); // [rsp+40h] [rbp-9h]
  __int64 v12; // [rsp+48h] [rbp-1h]
  __int64 v13; // [rsp+50h] [rbp+7h]
  __int64 v14; // [rsp+58h] [rbp+Fh]
  void *v15; // [rsp+60h] [rbp+17h]
  __int64 v16; // [rsp+68h] [rbp+1Fh]
  __int64 v17; // [rsp+70h] [rbp+27h]
  __int64 v18; // [rsp+78h] [rbp+2Fh]

  v2 = a2;
  v3 = (__int64)a1;
  sub_1400086DC(a1);
  v9 = 0i64;
  *(_QWORD *)(v3 + 72) = 0i64;
  v10 = 0i64;
  v12 = 0i64;
  v14 = 0i64;
  v16 = 0i64;
  v17 = 0i64;
  v18 = 0i64;
  *(_QWORD *)(v3 + 80) = 0x40000i64;
  *(_QWORD *)(v3 + 88) = 100000i64;
  *(_QWORD *)(v3 + 96) = 3000000000i64;
  *(_BYTE *)(v3 + 104) = 1;
  sub_14000AD68((__m128 *)&v9);
  v15 = off_140030110;
  sub_140011AA0(&v16, (__int64)sub_1400119C0);
  LOBYTE(v18) = 0;
  v11 = sub_1400119A0;
  v13 = v2;
  v4 = sub_140011AB8();
  if ( v4 )
  {
    sub_140002E58(
      L"Failed to create work item for PacketStream",
      v4,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipspacketstreams.cpp",
      150);
  }
  else
  {
    v5 = sub_140011A94(*(_QWORD *)(v3 + 72));
    v6 = v5;
    v7 = (_QWORD *)sub_140008CB8(40i64, v5);
    if ( v7 )
      sub_140010894(v7, v3);
    sub_140011958(v6, 3000000000i64);
  }
  return v3;
}
// 140020840: using guessed type wchar_t aFailedToCreate_2[44];
// 140030110: using guessed type void *off_140030110;

//----- (0000000140010894) ----------------------------------------------------
_QWORD *__fastcall sub_140010894(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_14000F4B8(a1);
  v3[1] = v2;
  v3[2] = 0i64;
  v3[3] = 0i64;
  v3[4] = 0i64;
  return v3;
}

//----- (00000001400108D4) ----------------------------------------------------
__int64 __fastcall sub_1400108D4(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  sub_1400108CC(a1 + 48);
  sub_1400108CC(v1 + 24);
  return sub_140008C98(v1 + 8);
}
// 140008C98: using guessed type __int64 __fastcall sub_140008C98(_QWORD);
// 1400108CC: using guessed type __int64 __fastcall sub_1400108CC(_QWORD);

//----- (0000000140010910) ----------------------------------------------------
__int64 __fastcall sub_140010910(__int64 a1)
{
  __int64 result; // rax

  if ( a1 == 104 )
    result = sub_140003C60(&stru_140034B00);
  else
    result = 0i64;
  return result;
}
// 140003C60: using guessed type __int64 __fastcall sub_140003C60(_QWORD);

//----- (0000000140010928) ----------------------------------------------------
PSLIST_ENTRY __fastcall sub_140010928(struct _SLIST_ENTRY *a1)
{
  return sub_14000424C(&stru_140034B00.L.ListHead, a1);
}

//----- (0000000140010938) ----------------------------------------------------
__int64 *__fastcall sub_140010938(__int64 *a1, __m128i *a2)
{
  __m128i *v2; // rdi
  __int64 *v3; // rbx

  v2 = a2;
  v3 = a1;
  if ( a1 != (__int64 *)a2 )
  {
    sub_140011020(a1);
    if ( !(unsigned __int8)IsListEmpty(v2) )
    {
      _mm_storeu_si128((__m128i *)v3, *v2);
      *(_QWORD *)(*v3 + 8) = v3;
      *(_QWORD *)v3[1] = v3;
      v3[2] = v2[1].m128i_i64[0];
      InitializeListHead((PLIST_ENTRY)v2);
      v2[1].m128i_i64[0] = 0i64;
    }
  }
  return v3;
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);

//----- (0000000140010998) ----------------------------------------------------
signed __int64 __fastcall sub_140010998(__int64 a1, __int64 a2)
{
  return a1 + 88 * a2 + 24;
}

//----- (00000001400109A4) ----------------------------------------------------
__int64 __fastcall sub_1400109A4(unsigned __int64 a1)
{
  unsigned int v1; // er10
  unsigned __int8 *v2; // r11
  signed __int64 v3; // rax
  int v4; // edx

  v1 = 0;
  v2 = (unsigned __int8 *)a1;
  if ( a1 <= a1 + 4 )
  {
    v3 = 32i64;
    do
    {
      v4 = *v2;
      v3 -= 8i64;
      ++v2;
      v1 |= v4 << v3;
    }
    while ( &v2[-a1] != (unsigned __int8 *)(a1 + 4 >= a1 ? 4 : 0) );
  }
  return v1;
}

//----- (00000001400109EC) ----------------------------------------------------
signed __int64 __fastcall sub_1400109EC(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax

  v1 = a1;
  v2 = sub_140001B3C(a1);
  return sub_140010998(v2, *(_QWORD *)(v1 + 8));
}

//----- (0000000140010A0C) ----------------------------------------------------
bool __fastcall sub_140010A0C(__int64 a1, __int64 a2)
{
  return sub_14000FFCC((unsigned int *)(a1 + 4), (unsigned int *)(a2 + 4));
}

//----- (0000000140010A1C) ----------------------------------------------------
void *__fastcall sub_140010A1C(void *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140010908();
  if ( v2 & 1 )
    sub_140007714(v3);
  return v3;
}
// 140010908: using guessed type __int64 sub_140010908(void);

//----- (0000000140010A50) ----------------------------------------------------
char __fastcall sub_140010A50(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  char v5; // [rsp+20h] [rbp-38h]

  v2 = a2;
  v3 = a1;
  sub_1400075EC((__int128 *)&v5, a1 + 16);
  LOBYTE(v3) = sub_140010680(v3 + 24, v2) != 0;
  sub_1400076D8(&v5);
  return v3;
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);

//----- (0000000140010AB4) ----------------------------------------------------
char __fastcall sub_140010AB4(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  char result; // al

  v2 = a1;
  result = sub_140010A50(*(_QWORD *)(a1 + 8), a2);
  ++*(_QWORD *)(v2 + 32);
  return result;
}

//----- (0000000140010AD0) ----------------------------------------------------
PVOID __fastcall sub_140010AD0(__int64 a1)
{
  __int64 v1; // rdi
  PVOID v2; // rax
  PVOID v3; // rbx
  __int64 v4; // rax
  char v6; // [rsp+30h] [rbp+8h]

  v1 = a1;
  v2 = sub_14000C158((__int64)&v6, 88 * a1 + 24);
  v3 = v2;
  if ( v2 )
  {
    v4 = sub_140008CB8(24i64, (__int64)v2);
    if ( v4 )
      sub_14000B728(v4, v1);
  }
  return v3;
}

//----- (0000000140010B24) ----------------------------------------------------
signed __int64 __fastcall sub_140010B24(__int64 a1)
{
  return a1 + 88i64 * *(_QWORD *)(a1 + 8) - 64;
}

//----- (0000000140010B34) ----------------------------------------------------
char __fastcall sub_140010B34(__int64 *a1)
{
  void **v1; // rax
  __int64 *v2; // rdi
  char v3; // si
  __int64 v4; // rbx
  __int64 v5; // rax
  char v7; // [rsp+20h] [rbp-30h]
  _QWORD *v8; // [rsp+28h] [rbp-28h]
  char v9; // [rsp+30h] [rbp-20h]
  __int64 v10; // [rsp+38h] [rbp-18h]
  __m128 v11; // [rsp+40h] [rbp-10h]
  void *retaddr; // [rsp+58h] [rbp+8h]

  v1 = &retaddr;
  v2 = a1;
  if ( (unsigned __int64)a1[2] >= 2 )
  {
    sub_140002584(&v11, 0x10ui64);
    sub_14000EACC((__int64)v2, &v11);
    while ( 1 )
    {
      v3 = 0;
      sub_140002584((__m128 *)&v7, 0x10ui64);
      sub_14000EA44(v2, &v7);
      sub_140002584((__m128 *)&v9, 0x10ui64);
      sub_14000BBA0((__m128i *)&v7, (__m128 *)&v9);
      LOBYTE(v1) = sub_14000B9F8(&v7, &v11);
      if ( (_BYTE)v1 )
        break;
      do
      {
        v4 = sub_14000BB80((__int64)&v9);
        v5 = sub_14000BB80((__int64)&v7);
        if ( sub_140010A0C(v5, v4) )
        {
          sub_140004F14(v8);
          sub_140004DE4(v10, v8);
          v3 = 1;
        }
        sub_140002584((__m128 *)&v9, 0x10ui64);
        sub_14000BBA0((__m128i *)&v7, (__m128 *)&v9);
        LOBYTE(v1) = sub_14000B9F8(&v7, &v11);
      }
      while ( !(_BYTE)v1 );
      if ( !v3 )
        break;
      sub_14000BBF0((__int64)&v11);
    }
  }
  return (char)v1;
}

//----- (0000000140010C5C) ----------------------------------------------------
char __fastcall sub_140010C5C(__int64 a1, int a2)
{
  unsigned __int8 v2; // r8
  unsigned __int8 v3; // al

  v2 = *(_BYTE *)(a1 + 4);
  v3 = v2;
  if ( v2 & 1 && a2 == *(_DWORD *)a1 )
  {
    v3 = v2 | 2;
    *(_BYTE *)(a1 + 4) = v2 | 2;
  }
  return (v3 >> 1) & 1;
}

//----- (0000000140010C78) ----------------------------------------------------
signed __int64 __fastcall sub_140010C78(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // r14
  unsigned int v4; // er12
  __int64 v5; // rdi
  int v6; // eax
  __int64 v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rbx
  signed __int64 v11; // rsi
  __int64 v12; // rax
  __int64 v13; // r13
  char v14; // al
  __int64 v15; // r15
  __int64 v16; // rdi
  int v17; // eax
  __int64 v18; // rcx
  int v19; // eax
  __int64 v20; // rcx
  int v21; // edx
  signed __int64 v22; // rbx
  __int64 v23; // rcx
  __int64 v24; // rax
  char v25; // [rsp+20h] [rbp-99h]
  __int64 v26; // [rsp+24h] [rbp-95h]
  volatile signed __int32 *v27[2]; // [rsp+30h] [rbp-89h]
  _OWORD v28[3]; // [rsp+40h] [rbp-79h]
  char v29; // [rsp+70h] [rbp-49h]
  __int64 v30; // [rsp+A8h] [rbp-11h]

  v3 = a1;
  v25 = a3;
  v4 = 2;
  v5 = a2;
  v6 = sub_1400111B8(a2);
  if ( v6 != 6 && v6 != 17 )
    return 2i64;
  v8 = sub_140008E08(v5);
  v9 = sub_140001B3C(v5);
  sub_14000FEA0((__int64)v28, v9, v8);
  if ( sub_140007720(v28) )
  {
    sub_1400106F4((__int64)&v29, 2, v28);
    v10 = sub_1400130E8();
    sub_140002584((__m128 *)v27, 0x10ui64);
    sub_1400110D4(v3, v27, (__int64)&v29);
    if ( !sub_14000BAB8(v27) )
    {
      if ( (unsigned int)sub_1400111B8(v5) == 6 && *(_BYTE *)(sub_1400111BC(v5) + 13) & 2 )
      {
        v23 = *(_QWORD *)(v3 + 72);
        v30 = v10;
        v24 = sub_140011A94(v23);
        sub_140010AB4(v24, (__int64)&v29);
        sub_140011AE0(*(_QWORD *)(v3 + 72));
      }
      goto LABEL_31;
    }
    v11 = sub_1400109EC((__int64)v27);
    v4 = *(_DWORD *)v11;
    *(_QWORD *)(v11 + 56) = v10;
    if ( (unsigned int)sub_1400111B8(v5) == 6 )
    {
      v12 = sub_1400111BC(v5);
      v13 = v12;
      v14 = *(_BYTE *)(v12 + 13);
      if ( v14 & 2 )
      {
        *(_DWORD *)v11 = 2;
        sub_140010744((__int64)&v26);
        v15 = v11 + 72;
        *(_QWORD *)(v11 + 72) = v26;
        sub_140010744((__int64)&v26);
        v16 = v11 + 80;
        *(_QWORD *)(v11 + 80) = v26;
        v14 = *(_BYTE *)(v13 + 13);
      }
      else
      {
        v15 = v11 + 72;
        v16 = v11 + 80;
      }
      if ( v14 & 1 )
      {
        v17 = sub_1400109A4(v13 + 8);
        v18 = v16;
        if ( v25 )
          v18 = v15;
        sub_14001190C(v18, v17);
        v14 = *(_BYTE *)(v13 + 13);
      }
      if ( v14 & 0x10 )
      {
        v19 = sub_1400109A4(v13 + 4);
        v20 = v15;
        if ( v25 )
          v20 = v16;
        sub_140010C5C(v20, v19);
        if ( sub_140011068(v15) && sub_140011068(v16) )
          sub_140011804(v3, (__int64)&v29);
      }
      if ( *(_BYTE *)(v13 + 13) & 4 )
      {
        v21 = sub_1400109A4(v13 + 8);
        if ( v25 )
          v16 = v15;
        sub_14001190C(v16, v21);
        v22 = v10 - *(_QWORD *)(v3 + 96) + 50000000;
      }
      else
      {
        if ( !sub_1400111C8(v15) || !sub_1400111C8(v16) )
          goto LABEL_31;
        v22 = v10 - *(_QWORD *)(v3 + 96) + 100000000;
      }
      *(_QWORD *)(v11 + 56) = v22;
    }
LABEL_31:
    sub_14000B790(v27);
  }
  return v4;
}
// 14000B790: using guessed type __int64 __fastcall sub_14000B790(_QWORD);

//----- (0000000140010EF4) ----------------------------------------------------
__int64 __fastcall sub_140010EF4(__int64 a1, __int64 a2, unsigned int a3, __int64 a4)
{
  __int64 v4; // rsi
  __int64 v5; // rbp
  unsigned int v6; // edi
  _OWORD *v7; // rbx
  int v8; // eax
  signed __int64 v9; // rax
  signed __int64 v10; // rbx
  unsigned __int64 v11; // rax
  __int64 v12; // rax
  volatile signed __int32 *v14[2]; // [rsp+20h] [rbp-88h]
  char v15; // [rsp+30h] [rbp-78h]

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v7 = (_OWORD *)a2;
  v8 = sub_1400083C8(a2);
  if ( v8 == 6 || v8 == 17 )
  {
    sub_1400106F4((__int64)&v15, v6, v7);
    sub_140002584((__m128 *)v14, 0x10ui64);
    sub_1400110D4(v4, v14, (__int64)&v15);
    if ( sub_14000BAB8(v14) )
    {
      v9 = sub_1400109EC((__int64)v14);
      v10 = v9;
      if ( v6 == 2 )
      {
        if ( *(_DWORD *)v9 == 2 )
        {
          if ( sub_1400130E8() - *(_QWORD *)(v9 + 56) <= *(_QWORD *)(v4 + 88) )
          {
            *(_QWORD *)(v10 + 64) += v5;
            v11 = *(_QWORD *)(v10 + 64);
          }
          else
          {
            *(_QWORD *)(v10 + 64) = 0i64;
            v11 = 0i64;
          }
          if ( *(_BYTE *)(v4 + 104) && v11 > *(_QWORD *)(v4 + 80) )
          {
            v6 = 0;
            *(_DWORD *)v10 = 0;
          }
        }
      }
      else
      {
        *(_DWORD *)v9 = v6;
      }
    }
    else
    {
      v12 = sub_140011A94(*(_QWORD *)(v4 + 72));
      sub_140010AB4(v12, (__int64)&v15);
      sub_140011AE0(*(_QWORD *)(v4 + 72));
    }
    sub_14000B790(v14);
  }
  return v6;
}
// 14000B790: using guessed type __int64 __fastcall sub_14000B790(_QWORD);

//----- (0000000140011020) ----------------------------------------------------
__int64 __fastcall sub_140011020(__int64 *a1)
{
  __int64 *i; // rdi
  struct _SLIST_ENTRY *v2; // rbx
  __int64 result; // rax

  for ( i = a1; ; a1 = i )
  {
    result = IsListEmpty(a1);
    if ( (_BYTE)result )
      break;
    v2 = (struct _SLIST_ENTRY *)sub_14000970C(i);
    sub_140004F48((__int64 **)i);
    sub_140010928(v2);
  }
  i[2] = 0i64;
  return result;
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);

//----- (0000000140011068) ----------------------------------------------------
char __fastcall sub_140011068(__int64 a1)
{
  return (*(_BYTE *)(a1 + 4) >> 1) & 1;
}

//----- (0000000140011070) ----------------------------------------------------
__m128 *__fastcall sub_140011070(__int64 a1, __m128 *a2, __m128i *a3)
{
  __m128 *v3; // rsi
  __int64 v4; // rbx
  __m128i *v5; // rdi
  struct _SLIST_ENTRY *v6; // rax
  __int128 v8; // [rsp+20h] [rbp-18h]

  v3 = a2;
  v4 = a1;
  v5 = a3;
  sub_140002584(a2, 0x10ui64);
  _mm_storeu_si128((__m128i *)&v8, *v5);
  sub_14000E904(v4, v3, (__int64)&v8);
  v6 = (struct _SLIST_ENTRY *)sub_140009E44(v5->m128i_i64[1]);
  sub_140010928(v6);
  return v3;
}

//----- (00000001400110D4) ----------------------------------------------------
volatile signed __int32 **__fastcall sub_1400110D4(__int64 a1, volatile signed __int32 **a2, __int64 a3)
{
  volatile signed __int32 **v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rsi
  __int64 v6; // rax
  int v7; // eax
  __int64 v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  volatile signed __int32 *v14; // [rsp+20h] [rbp-28h]

  v3 = a2;
  v4 = a1;
  v5 = a3;
  sub_140002584((__m128 *)&v14, 8ui64);
  sub_14000CBD8(v4, (__m128 *)&v14);
  if ( sub_140006EAC(&v14) )
  {
    v6 = sub_140001B3C((__int64)&v14);
    v7 = sub_1400111D0(v6, v5);
    v8 = v7;
    if ( v7 < 0 || (v9 = sub_140001B3C((__int64)&v14), v10 = sub_140010998(v9, v8), sub_140010A0C(v5, v10)) )
      LODWORD(v8) = -1;
    if ( (signed int)v8 >= 0 )
    {
      v12 = (signed int)v8;
    }
    else
    {
      v11 = sub_140001B3C((__int64)&v14);
      v12 = sub_140008E08(v11);
    }
    sub_14000B5E4(v3, &v14, (volatile signed __int32 *)v12);
  }
  else
  {
    sub_14000B60C((__int64)v3);
  }
  sub_140008C98(&v14);
  return v3;
}
// 140008C98: using guessed type __int64 __fastcall sub_140008C98(_QWORD);

//----- (00000001400111B8) ----------------------------------------------------
__int64 __fastcall sub_1400111B8(__int64 a1)
{
  return *(unsigned int *)(a1 + 20);
}

//----- (00000001400111BC) ----------------------------------------------------
__int64 __fastcall sub_1400111BC(__int64 a1)
{
  return sub_140006988(*(_QWORD *)a1, *(unsigned int *)(a1 + 32));
}

//----- (00000001400111C8) ----------------------------------------------------
char __fastcall sub_1400111C8(__int64 a1)
{
  return *(_BYTE *)(a1 + 4) & 1;
}

//----- (00000001400111D0) ----------------------------------------------------
__int64 __fastcall sub_1400111D0(__int64 a1, __int64 a2)
{
  signed __int64 v2; // r15
  unsigned int v3; // ebp
  int v4; // esi
  int v5; // ebx
  __int64 v6; // r14
  __int64 v7; // rdi

  v2 = a1 + 24;
  v3 = -1;
  v4 = 0;
  v5 = *(_DWORD *)(a1 + 8) - 1;
  v6 = a2;
  if ( v5 >= 0 )
  {
    do
    {
      v7 = (v5 + v4) / 2;
      if ( sub_140010A0C(v2 + 88 * v7, v6) )
      {
        v4 = v7 + 1;
      }
      else
      {
        v3 = (v5 + v4) / 2;
        v5 = v7 - 1;
      }
    }
    while ( v4 <= v5 );
  }
  return v3;
}

//----- (0000000140011244) ----------------------------------------------------
__int64 __fastcall sub_140011244(__int64 a1)
{
  __int64 v1; // rdi
  __m128i *v2; // rax
  __m128i *v3; // rax
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rbx
  volatile signed __int32 *v7; // rax
  unsigned __int64 v8; // rsi
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rax
  __int64 v13; // r14
  __int64 v14; // rbx
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rsi
  __int64 v20; // rbx
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rbx
  volatile signed __int32 *v24; // rax
  __int64 v25; // rbx
  __int64 v26; // rax
  __int64 v27; // rax
  volatile signed __int32 *v29; // [rsp+20h] [rbp-89h]
  __m128 v30; // [rsp+28h] [rbp-81h]
  __m128 v31; // [rsp+38h] [rbp-71h]
  __int128 v32; // [rsp+50h] [rbp-59h]
  char v33; // [rsp+60h] [rbp-49h]
  char v34; // [rsp+70h] [rbp-39h]
  struct _LIST_ENTRY v35; // [rsp+78h] [rbp-31h]
  struct _LIST_ENTRY v36; // [rsp+90h] [rbp-19h]
  __m128 v37[2]; // [rsp+A8h] [rbp-1h]
  char v38; // [rsp+C8h] [rbp+1Fh]

  v1 = a1;
  sub_1400086B8(&v36);
  sub_1400086B8(&v35);
  sub_1400075EC((__int128 *)v37, v1 + 16);
  v2 = (__m128i *)sub_140003C0C(v1 + 24);
  sub_140010938((__int64 *)&v36, v2);
  v3 = (__m128i *)sub_140003C0C(v1 + 48);
  sub_140010938((__int64 *)&v35, v3);
  sub_1400076D8(v37);
  sub_140010B34((__int64 *)&v36);
  sub_140010B34((__int64 *)&v35);
  sub_140002584((__m128 *)&v34, 8ui64);
  sub_14000CBD8(v1, (__m128 *)&v34);
  if ( !sub_140006EAC(&v34) )
  {
    v23 = sub_14000EB80((__int64)&v36);
    if ( !v23 )
      goto LABEL_35;
    sub_140002584((__m128 *)&v29, 8ui64);
    v24 = (volatile signed __int32 *)sub_140010AD0(v23);
    sub_14000B76C(&v29, v24);
    if ( sub_140006EAC(&v29) )
    {
      sub_140002584(&v30, 0x10ui64);
      sub_14000EA44((__int64 *)&v36, &v30);
      sub_140002584(&v31, 0x10ui64);
      sub_14000EACC((__int64)&v36, &v31);
      if ( sub_14000BA58(&v30, &v31) )
      {
        v25 = sub_140001B3C((__int64)&v29);
        do
        {
          v26 = sub_14000BB80((__int64)&v30);
          v27 = sub_140003C0C(v26);
          sub_140011790(v25, v27);
          sub_14000BBE0((__int64)&v30);
        }
        while ( sub_14000BA58(&v30, &v31) );
      }
      goto LABEL_33;
    }
LABEL_34:
    sub_140008C98(&v29);
    goto LABEL_35;
  }
  v4 = sub_140001B3C((__int64)&v34);
  v5 = sub_140008E08(v4);
  v6 = sub_14000EB80((__int64)&v36) + v5;
  if ( v6 )
  {
    sub_140002584((__m128 *)&v29, 8ui64);
    v7 = (volatile signed __int32 *)sub_140010AD0(v6);
    sub_14000B76C(&v29, v7);
    if ( sub_140006EAC(&v29) )
    {
      v8 = 0i64;
      sub_140002584(&v30, 0x10ui64);
      sub_14000EA44((__int64 *)&v36, &v30);
      sub_140002584(&v31, 0x10ui64);
      sub_14000EACC((__int64)&v36, &v31);
      v9 = sub_140001B3C((__int64)&v34);
      if ( sub_140008E08(v9) )
      {
        do
        {
          v10 = sub_140001B3C((__int64)&v34);
          v11 = sub_140010998(v10, v8);
          while ( !sub_14000EA98((__int64)&v35) )
          {
            v12 = sub_14000CBB4((__int64 *)&v35);
            if ( !sub_140010A0C(v12, v11) )
              break;
            _mm_storeu_si128((__m128i *)&v32, *(__m128i *)sub_14000EA44((__int64 *)&v35, &v33));
            sub_140011070((__int64)&v35, v37, (__m128i *)&v32);
          }
          if ( sub_14000BA58(&v30, &v31) && (v13 = sub_14000BB80((__int64)&v30), sub_140010A0C(v13, v11)) )
          {
            v14 = sub_140001B3C((__int64)&v29);
            if ( sub_14000EAB8(v14) || (v15 = sub_140010B24(v14), sub_140010A0C(v15, v13)) )
              sub_140011790(v14, v13);
            sub_14000BBE0((__int64)&v30);
          }
          else
          {
            if ( sub_14000EA98((__int64)&v35) || (v16 = sub_14000CBB4((__int64 *)&v35), sub_140010A0C(v11, v16)) )
            {
              v17 = sub_140001B3C((__int64)&v29);
              sub_140011790(v17, v11);
            }
            ++v8;
          }
          v18 = sub_140001B3C((__int64)&v34);
        }
        while ( v8 < sub_140008E08(v18) );
      }
      if ( sub_14000BA58(&v30, &v31) )
      {
        v19 = sub_140001B3C((__int64)&v29);
        do
        {
          if ( sub_14000EAB8(v19)
            || (v20 = sub_140010B24(v19), v21 = sub_14000BB80((__int64)&v30), sub_140010A0C(v20, v21)) )
          {
            v22 = sub_14000BB80((__int64)&v30);
            sub_140011790(v19, v22);
          }
          sub_14000BBE0((__int64)&v30);
        }
        while ( sub_14000BA58(&v30, &v31) );
      }
LABEL_33:
      sub_1400075EC((__int128 *)&v38, v1);
      sub_14000B978((volatile signed __int32 **)(v1 + 8), &v29);
      sub_1400076D8(&v38);
      goto LABEL_34;
    }
    goto LABEL_34;
  }
  sub_1400075EC((__int128 *)v37, v1);
  sub_140009F44((volatile signed __int32 **)(v1 + 8));
  sub_1400076D8(v37);
LABEL_35:
  sub_140008C98(&v34);
  sub_1400108CC(&v35);
  return sub_1400108CC(&v36);
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);
// 140008C98: using guessed type __int64 __fastcall sub_140008C98(_QWORD);
// 1400108CC: using guessed type __int64 __fastcall sub_1400108CC(_QWORD);

//----- (00000001400116C8) ----------------------------------------------------
__int64 __fastcall sub_1400116C8(__int64 *a1)
{
  __int64 *v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // rdi
  __int64 v5; // rsi
  __int64 v6; // rax
  volatile signed __int32 *v8[2]; // [rsp+20h] [rbp-28h]

  v1 = a1;
  v2 = sub_1400130E8();
  v3 = v1[2];
  v4 = v2;
  if ( v2 > v3 )
  {
    if ( v3 )
    {
      v5 = v2 - v1[3];
      sub_140002584((__m128 *)v8, 0x10ui64);
      sub_1400119D8(v1[1], v8);
      while ( sub_14000BAB8(v8) )
      {
        v6 = sub_1400109EC((__int64)v8);
        if ( *(_QWORD *)(v6 + 56) < v5 )
          sub_140011804(v1[1], v6);
        sub_14000BB98((__int64)v8);
      }
      sub_14000B790(v8);
    }
    v1[2] = v4 + 100000000;
  }
  return sub_140011244(v1[1]);
}
// 14000B790: using guessed type __int64 __fastcall sub_14000B790(_QWORD);

//----- (0000000140011790) ----------------------------------------------------
signed __int64 __fastcall sub_140011790(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // rbx
  signed __int64 v4; // rdi
  __int64 v5; // rax

  v2 = *(_QWORD *)(a1 + 8);
  v3 = a2;
  v4 = a1 + 88 * v2;
  *(_QWORD *)(a1 + 8) = v2 + 1;
  v5 = sub_140008CB8(88i64, v4 + 24);
  if ( v5 )
  {
    *(_OWORD *)v5 = *(_OWORD *)v3;
    *(_OWORD *)(v5 + 16) = *(_OWORD *)(v3 + 16);
    *(_OWORD *)(v5 + 32) = *(_OWORD *)(v3 + 32);
    *(_OWORD *)(v5 + 48) = *(_OWORD *)(v3 + 48);
    *(_OWORD *)(v5 + 64) = *(_OWORD *)(v3 + 64);
    *(_QWORD *)(v5 + 80) = *(_QWORD *)(v3 + 80);
  }
  return v4 + 24;
}

//----- (0000000140011804) ----------------------------------------------------
char __fastcall sub_140011804(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  char v5; // [rsp+20h] [rbp-38h]

  v2 = a2;
  v3 = a1;
  sub_1400075EC((__int128 *)&v5, a1 + 16);
  LOBYTE(v3) = sub_140010680(v3 + 48, v2) != 0;
  sub_1400076D8(&v5);
  return v3;
}
// 1400076D8: using guessed type __int64 __fastcall sub_1400076D8(_QWORD);

//----- (0000000140011868) ----------------------------------------------------
__int64 __fastcall sub_140011868(__int64 a1, _OWORD *a2)
{
  __int64 v2; // rbx
  volatile signed __int32 *v4[2]; // [rsp+20h] [rbp-88h]
  char v5; // [rsp+30h] [rbp-78h]

  v2 = a1;
  sub_1400106F4((__int64)&v5, 2, a2);
  sub_140002584((__m128 *)v4, 0x10ui64);
  sub_1400110D4(v2, v4, (__int64)&v5);
  if ( sub_14000BAB8(v4) )
  {
    sub_140011804(v2, (__int64)&v5);
    sub_140011AE0(*(_QWORD *)(v2 + 72));
  }
  return sub_14000B790(v4);
}
// 14000B790: using guessed type __int64 __fastcall sub_14000B790(_QWORD);

//----- (0000000140011900) ----------------------------------------------------
char __fastcall sub_140011900(__int64 a1, __int64 a2)
{
  return sub_140011804(*(_QWORD *)(a1 + 8), a2);
}

//----- (000000014001190C) ----------------------------------------------------
void __fastcall sub_14001190C(__int64 a1, int a2)
{
  *(_BYTE *)(a1 + 4) |= 1u;
  *(_DWORD *)a1 = a2;
}

//----- (0000000140011914) ----------------------------------------------------
__int64 __fastcall sub_140011914(__int64 a1, unsigned int a2)
{
  __int64 result; // rax

  result = a2;
  *(_QWORD *)(a1 + 88) = 10000i64 * a2;
  return result;
}

//----- (0000000140011924) ----------------------------------------------------
void __fastcall sub_140011924(__int64 a1, char a2)
{
  *(_BYTE *)(a1 + 104) = a2;
}

//----- (0000000140011928) ----------------------------------------------------
void __fastcall sub_140011928(__int64 a1, unsigned int a2)
{
  __int64 v2; // rbx
  __int64 v3; // rax

  v2 = a2;
  *(_QWORD *)(a1 + 96) = a2;
  v3 = sub_140011A94(*(_QWORD *)(a1 + 72));
  if ( v3 )
    sub_140011958(v3, 10000000 * v2);
}

//----- (0000000140011958) ----------------------------------------------------
void __fastcall sub_140011958(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 24) = a2;
}

//----- (0000000140011960) ----------------------------------------------------
__int64 __fastcall sub_140011960(__int64 a1)
{
  __int64 v1; // rbx
  std::ios_base *v2; // rax

  v1 = 0i64;
  v2 = (std::ios_base *)sub_140011A94(*(_QWORD *)(a1 + 72));
  if ( v2 )
    v1 = std::ios_base::precision(v2);
  return v1;
}

//----- (00000001400119A0) ----------------------------------------------------
void *__fastcall sub_1400119A0(__int64 a1)
{
  void *v1; // rax

  v1 = (void *)sub_140011A94(a1);
  return sub_140010A1C(v1, 0);
}

//----- (00000001400119C0) ----------------------------------------------------
__int64 __fastcall sub_1400119C0(__int64 a1)
{
  __int64 *v1; // rax

  v1 = (__int64 *)sub_140011A94(a1);
  return sub_1400116C8(v1);
}

//----- (00000001400119D8) ----------------------------------------------------
volatile signed __int32 **__fastcall sub_1400119D8(__int64 a1, volatile signed __int32 **a2)
{
  volatile signed __int32 **v2; // rbx
  volatile signed __int32 **v3; // rax
  char v5; // [rsp+38h] [rbp+10h]

  v2 = a2;
  v3 = sub_14000CBD8(a1, (__m128 *)&v5);
  sub_14000B5E4(v2, v3, 0i64);
  sub_140008C98(&v5);
  return v2;
}
// 140008C98: using guessed type __int64 __fastcall sub_140008C98(_QWORD);

//----- (0000000140011A0C) ----------------------------------------------------
__int64 __fastcall sub_140011A0C(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rdi
  __int64 v3; // rax
  char v5; // [rsp+20h] [rbp-18h]

  v1 = a1;
  v2 = 0i64;
  sub_140002584((__m128 *)&v5, 8ui64);
  sub_14000CC58(v1, (__m128 *)&v5);
  if ( sub_140006EAC(&v5) )
  {
    v3 = sub_140001B3C((__int64)&v5);
    v2 = sub_140008E08(v3);
  }
  sub_140008C98(&v5);
  return v2;
}
// 140008C98: using guessed type __int64 __fastcall sub_140008C98(_QWORD);

//----- (0000000140011A94) ----------------------------------------------------
__int64 __fastcall sub_140011A94(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_140036E20);
}
// 140036E20: using guessed type __int64 qword_140036E20;
// 140037458: using guessed type __int64 qword_140037458;

//----- (0000000140011AA0) ----------------------------------------------------
__int64 __fastcall sub_140011AA0(_QWORD *a1, __int64 a2)
{
  __int64 result; // rax

  result = 0i64;
  *a1 = 0i64;
  a1[2] = 0i64;
  *(_DWORD *)a1 = 24;
  a1[1] = a2;
  *((_BYTE *)a1 + 16) = 1;
  return result;
}

//----- (0000000140011AB8) ----------------------------------------------------
__int64 sub_140011AB8()
{
  return sub_14001E1B0((__int64 (*)(void))qword_1400373A8);
}
// 1400373A8: using guessed type __int64 qword_1400373A8;
// 140037458: using guessed type __int64 qword_140037458;

//----- (0000000140011AE0) ----------------------------------------------------
__int64 __fastcall sub_140011AE0(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_1400373B0);
}
// 1400373B0: using guessed type __int64 qword_1400373B0;
// 140037458: using guessed type __int64 qword_140037458;

//----- (0000000140011AF8) ----------------------------------------------------
void **__fastcall sub_140011AF8(__int64 a1, __int64 a2)
{
  signed __int64 v2; // r14
  __int64 v3; // r15
  void **v4; // rdi
  int v5; // ebx
  unsigned int v6; // esi
  void *v7; // r8
  void *v8; // r8
  __int64 v9; // rax
  __int64 v10; // r8
  __int64 v12; // [rsp+30h] [rbp-20h]
  char v13; // [rsp+38h] [rbp-18h]

  *(_QWORD *)a1 = 0i64;
  v2 = a1 + 8;
  *(_DWORD *)(a1 + 8) = 0;
  v3 = a2;
  v4 = (void **)a1;
  v5 = SecLookupAccountName(a2, (char *)&v12 + 4, 0i64, a1 + 8, &v12, 0i64, 0i64);
  v6 = HIDWORD(v12) + 1;
  if ( (signed int)(v5 + 2147483648) < 0 || v5 == -1073741789 )
  {
    *v4 = ExAllocatePoolWithTag(PagedPool, v6, 0x39737049u);
    v5 = 0;
  }
  v7 = *v4;
  if ( !*v4 )
    goto LABEL_12;
  LODWORD(v12) = 0;
  HIDWORD(v12) = v6;
  v5 = SecLookupAccountName(v3, (char *)&v12 + 4, v7, v2, &v12, 0i64, v12);
  if ( (signed int)(v5 + 2147483648) >= 0 && v5 != -1073741789 )
    goto LABEL_12;
  sub_140011C64(&v13, v12);
  v8 = *v4;
  HIDWORD(v12) = v6;
  v9 = sub_140003C0C((__int64)&v13);
  v5 = SecLookupAccountName(v3, (char *)&v12 + 4, v10, v2, &v12, v9, v12);
  sub_140011CBC((__int64)&v13);
  if ( v5 < 0 )
  {
LABEL_12:
    sub_140002E58(
      L"Failed to lookup SID",
      v5,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\ipscommon\\ipssidutils.cpp",
      102);
    sub_140011CD8(v4);
  }
  return v4;
}
// 1400208F0: using guessed type wchar_t aFailedToLookup[21];
// 140029178: using guessed type __int64 __fastcall SecLookupAccountName(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140011C64) ----------------------------------------------------
_QWORD *__fastcall sub_140011C64(_QWORD *a1, unsigned int a2)
{
  __int16 v2; // bx
  _QWORD *v3; // rdi
  PVOID v4; // rax

  v2 = a2;
  *a1 = 0i64;
  v3 = a1;
  a1[1] = 0i64;
  v4 = ExAllocatePoolWithTag(PagedPool, a2, 0x35737049u);
  v3[1] = v4;
  *((_WORD *)v3 + 1) = v4 != 0i64 ? v2 : 0;
  *(_WORD *)v3 = 0;
  return v3;
}

//----- (0000000140011CBC) ----------------------------------------------------
void __fastcall sub_140011CBC(__int64 a1)
{
  void *v1; // rcx

  v1 = *(void **)(a1 + 8);
  if ( v1 )
    ExFreePoolWithTag(v1, 0);
}

//----- (0000000140011CD8) ----------------------------------------------------
void __fastcall sub_140011CD8(void **a1)
{
  void **v1; // rbx
  void *v2; // rcx

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    ExFreePoolWithTag(v2, 0);
    *v1 = 0i64;
  }
}

//----- (0000000140011CFC) ----------------------------------------------------
_QWORD *__fastcall sub_140011CFC(_QWORD *a1, _QWORD *a2)
{
  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = *a2;
  return a1;
}

//----- (0000000140011D10) ----------------------------------------------------
_QWORD *__fastcall sub_140011D10(_QWORD *a1, __int64 a2, int *a3)
{
  _QWORD *v3; // rbx

  v3 = a1;
  *a1 = 0i64;
  a1[1] = 0i64;
  sub_140011F30((__int64)(a1 + 2), a2, *a3);
  return v3;
}

//----- (0000000140011D38) ----------------------------------------------------
__m128i *__fastcall sub_140011D38(__m128i *a1, __m128i *a2)
{
  __m128i *result; // rax

  a1->m128i_i64[0] = 0i64;
  a1->m128i_i64[1] = 0i64;
  result = a1;
  _mm_storeu_si128(a1 + 1, *a2);
  return result;
}

//----- (0000000140011D50) ----------------------------------------------------
signed __int64 __fastcall sub_140011D50(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  __m128 *v4; // rax
  unsigned __int64 *v5; // rbx
  _QWORD *v6; // rax
  _QWORD *v7; // rbx

  v2 = a1;
  v3 = a2;
  v4 = (__m128 *)sub_1400120F0(24i64);
  v5 = (unsigned __int64 *)v4;
  if ( v4 )
  {
    sub_140002584(v4, 0x18ui64);
    v6 = (_QWORD *)sub_140003C0C(v3);
    v7 = sub_140011CFC(v5, v6);
  }
  else
  {
    v7 = 0i64;
  }
  if ( v7 )
  {
    ++*(_QWORD *)(v2 + 16);
    sub_140004DE4(v2, v7);
  }
  return (unsigned __int64)(v7 + 2) & -(signed __int64)(v7 != 0i64);
}

//----- (0000000140011DD0) ----------------------------------------------------
signed __int64 __fastcall sub_140011DD0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rbp
  _QWORD *v6; // rsi
  int *v7; // rbx
  __int64 v8; // rax
  _QWORD *v9; // rbx

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v6 = (_QWORD *)sub_140012120(40i64);
  if ( v6 )
  {
    v7 = (int *)sub_140003C0C(v4);
    v8 = sub_140003C0C(v5);
    v9 = sub_140011D10(v6, v8, v7);
  }
  else
  {
    v9 = 0i64;
  }
  if ( v9 )
  {
    ++*(_QWORD *)(v3 + 16);
    sub_140004DE4(v3, v9);
  }
  return (unsigned __int64)(v9 + 2) & -(signed __int64)(v9 != 0i64);
}

//----- (0000000140011E60) ----------------------------------------------------
signed __int64 __fastcall sub_140011E60(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  __m128i *v4; // rax
  __m128i *v5; // r8
  __m128i *v6; // rbx

  v2 = a1;
  v3 = a2;
  if ( sub_140012108(32i64) )
  {
    v4 = (__m128i *)sub_140003C0C(v3);
    v6 = sub_140011D38(v5, v4);
  }
  else
  {
    v6 = 0i64;
  }
  if ( v6 )
  {
    ++*(_QWORD *)(v2 + 16);
    sub_140004DE4(v2, v6);
  }
  return (unsigned __int64)&v6[1] & -(signed __int64)(v6 != 0i64);
}

//----- (0000000140011EC8) ----------------------------------------------------
struct _LIST_ENTRY *__fastcall sub_140011EC8(struct _LIST_ENTRY *a1)
{
  struct _LIST_ENTRY *v1; // rbx

  v1 = a1;
  a1->Flink = 0i64;
  a1->Blink = 0i64;
  a1[1].Flink = 0i64;
  InitializeListHead(a1);
  return v1;
}

//----- (0000000140011EEC) ----------------------------------------------------
__int64 **__fastcall sub_140011EEC(__int64 **a1, __int64 *a2)
{
  __int64 **v2; // rbx

  v2 = a1;
  *a1 = a2;
  sub_14000F568(a2);
  return v2;
}

//----- (0000000140011F0C) ----------------------------------------------------
signed __int64 *__fastcall sub_140011F0C(signed __int64 *a1, _QWORD *a2, __int64 a3)
{
  signed __int64 *v3; // rbx

  v3 = a1;
  *a1 = sub_140008608(a2, a3);
  return v3;
}

//----- (0000000140011F30) ----------------------------------------------------
__int64 __fastcall sub_140011F30(__int64 a1, __int64 a2, int a3)
{
  __int64 result; // rax

  *(_QWORD *)a1 = 0i64;
  result = a1;
  *(_QWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 16) = a3;
  return result;
}

//----- (0000000140011F40) ----------------------------------------------------
_DWORD *__fastcall sub_140011F40(_DWORD *a1)
{
  *a1 = 1;
  return a1;
}

//----- (0000000140011F4C) ----------------------------------------------------
__int64 __fastcall sub_140011F4C(__int64 a1, volatile signed __int32 *a2)
{
  __int64 v2; // rbx

  v2 = a1;
  *(_QWORD *)a1 = a2;
  *(_BYTE *)(a1 + 8) = sub_14001229C(a2);
  return v2;
}

//----- (0000000140011F6C) ----------------------------------------------------
_QWORD *__fastcall sub_140011F6C(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rbx
  _QWORD *v4; // rsi
  _QWORD *v5; // rdi

  v3 = a3;
  *a1 = a2;
  a1[1] = a3;
  v4 = a1;
  v5 = a2;
  sub_14000F4B8(a1 + 2);
  sub_140011F0C(v4 + 3, v5, v3 - 4);
  v4[4] = 0i64;
  *((_DWORD *)v4 + 10) = 0;
  sub_140011F40((_DWORD *)v4 + 11);
  sub_140011F40((_DWORD *)v4 + 12);
  sub_1400086B8((struct _LIST_ENTRY *)(v4 + 7));
  return v4;
}

//----- (0000000140011FF4) ----------------------------------------------------
char __fastcall sub_140011FF4(__int64 **a1)
{
  return sub_14000F5AC(*a1);
}

//----- (0000000140011FFC) ----------------------------------------------------
void __fastcall sub_140011FFC(__int64 a1)
{
  if ( *(_BYTE *)(a1 + 8) )
    sub_140012B54(*(_DWORD **)a1);
}

//----- (0000000140012014) ----------------------------------------------------
char __fastcall sub_140012014(__int64 a1)
{
  __int64 *v1; // rsi
  __int64 *v2; // rdi
  __int64 v3; // rbx
  __m128 v5; // [rsp+20h] [rbp-20h]
  __m128 v6; // [rsp+30h] [rbp-10h]
  char v7; // [rsp+50h] [rbp+10h]

  v1 = (__int64 *)(a1 + 16);
  v2 = (__int64 *)(a1 + 56);
  sub_140011EEC((__int64 **)&v7, (__int64 *)(a1 + 16));
  sub_140002584(&v5, 0x10ui64);
  sub_14000EA44(v2, &v5);
  sub_140002584(&v6, 0x10ui64);
  sub_14000EACC((__int64)v2, &v6);
  while ( sub_14000BA58(&v5, &v6) )
  {
    v3 = *(_QWORD *)(sub_14000BB80((__int64)&v5) + 8);
    if ( v3 )
    {
      sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v3 + 8i64));
      sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v3 + 40i64));
    }
    sub_14000BBE0((__int64)&v5);
  }
  sub_140011FF4((__int64 **)&v7);
  sub_140011FEC(v2);
  return sub_14000F544(v1);
}
// 140011FEC: using guessed type __int64 __fastcall sub_140011FEC(_QWORD);

//----- (00000001400120F0) ----------------------------------------------------
__int64 __fastcall sub_1400120F0(__int64 a1)
{
  __int64 result; // rax

  if ( a1 == 24 )
    result = sub_140003C60(&stru_140034C00);
  else
    result = 0i64;
  return result;
}
// 140003C60: using guessed type __int64 __fastcall sub_140003C60(_QWORD);

//----- (0000000140012108) ----------------------------------------------------
__int64 __fastcall sub_140012108(__int64 a1)
{
  __int64 result; // rax

  if ( a1 == 32 )
    result = sub_140003C60(&stru_140034B80);
  else
    result = 0i64;
  return result;
}
// 140003C60: using guessed type __int64 __fastcall sub_140003C60(_QWORD);

//----- (0000000140012120) ----------------------------------------------------
__int64 __fastcall sub_140012120(__int64 a1)
{
  __int64 result; // rax

  if ( a1 == 40 )
    result = sub_140003C60(&stru_140034C80);
  else
    result = 0i64;
  return result;
}
// 140003C60: using guessed type __int64 __fastcall sub_140003C60(_QWORD);

//----- (0000000140012138) ----------------------------------------------------
PSLIST_ENTRY __fastcall sub_140012138(struct _SLIST_ENTRY *a1)
{
  return sub_14000424C(&stru_140034C00.L.ListHead, a1);
}

//----- (0000000140012148) ----------------------------------------------------
PSLIST_ENTRY __fastcall sub_140012148(struct _SLIST_ENTRY *a1)
{
  return sub_14000424C(&stru_140034B80.L.ListHead, a1);
}

//----- (0000000140012158) ----------------------------------------------------
PSLIST_ENTRY __fastcall sub_140012158(struct _SLIST_ENTRY *a1)
{
  return sub_14000424C(&stru_140034C80.L.ListHead, a1);
}

//----- (000000014001217C) ----------------------------------------------------
bool __fastcall sub_14001217C(_QWORD *a1, _QWORD *a2)
{
  return !sub_14000B9F8(a1, a2);
}

//----- (000000014001218C) ----------------------------------------------------
char __fastcall sub_14001218C(__int64 a1)
{
  return *(_BYTE *)(a1 + 8);
}

//----- (0000000140012190) ----------------------------------------------------
__int64 __fastcall sub_140012190(__int64 a1)
{
  return sub_140009E44(*(_QWORD *)(a1 + 8)) + 16;
}

//----- (00000001400121A8) ----------------------------------------------------
char *__fastcall sub_1400121A8(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 *v2; // rcx
  unsigned __int64 v3; // r8
  unsigned __int64 v4; // r9
  unsigned __int64 v5; // rax
  __int64 v7; // rcx

  v7 = *a1;
  if ( !v7 || !a2 )
    return 0i64;
  v2 = (unsigned __int64 *)(v7 - 24);
  v3 = v2[2];
  if ( !v3 )
  {
    if ( a2 <= *v2 - 24 )
    {
      v2[1] = 24i64;
      goto LABEL_6;
    }
    return 0i64;
  }
  v4 = v2[1];
  v5 = a2 + v3;
  if ( v3 <= v4 )
  {
    if ( v5 <= v4 )
      goto LABEL_12;
    return 0i64;
  }
  if ( v5 <= *v2 )
    goto LABEL_12;
  if ( a2 + 24 > v4 )
    return 0i64;
LABEL_6:
  v3 = 24i64;
LABEL_12:
  v2[2] = v3 + a2;
  return (char *)v2 + v3;
}

//----- (00000001400121B0) ----------------------------------------------------
char __fastcall sub_1400121B0(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rbx
  __int64 v4; // rdi
  _QWORD *v5; // rax
  char result; // al
  __m128 v7; // [rsp+20h] [rbp-20h]
  __m128 v8; // [rsp+30h] [rbp-10h]
  char v9; // [rsp+50h] [rbp+10h]

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  sub_140011EEC((__int64 **)&v9, (__int64 *)(a1 + 16));
  sub_140002584(&v7, 0x10ui64);
  sub_14000EA44((__int64 *)(v3 + 56), &v7);
  sub_140002584(&v8, 0x10ui64);
  sub_14000EACC(v3 + 56, &v8);
  while ( sub_14000BA58(&v7, &v8) )
  {
    v5 = (_QWORD *)sub_14000BB80((__int64)&v7);
    if ( *v5 == v2 )
    {
      v4 = v5[1];
      v5[1] = 0i64;
      break;
    }
    sub_14000BBE0((__int64)&v7);
  }
  result = sub_140011FF4((__int64 **)&v9);
  if ( v4 )
  {
    sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v4 + 8i64));
    result = sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v4 + 40i64));
  }
  return result;
}

//----- (0000000140012288) ----------------------------------------------------
__int64 __fastcall sub_140012288(__int64 a1)
{
  return sub_140012914(a1) + 16;
}

//----- (000000014001229C) ----------------------------------------------------
bool __fastcall sub_14001229C(volatile signed __int32 *a1)
{
  return _InterlockedExchange(a1, 1) == 1;
}

//----- (00000001400122AC) ----------------------------------------------------
__int64 __fastcall sub_1400122AC(__int64 *a1)
{
  __int64 *i; // rdi
  struct _SLIST_ENTRY *v2; // rbx
  __int64 result; // rax

  for ( i = a1; ; a1 = i )
  {
    result = IsListEmpty(a1);
    if ( (_BYTE)result )
      break;
    v2 = (struct _SLIST_ENTRY *)sub_14000970C(i);
    sub_140004F48((__int64 **)i);
    sub_140012138(v2);
  }
  i[2] = 0i64;
  return result;
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);

//----- (00000001400122F4) ----------------------------------------------------
__int64 __fastcall sub_1400122F4(__int64 *a1)
{
  __int64 *i; // rdi
  struct _SLIST_ENTRY *v2; // rbx
  __int64 result; // rax

  for ( i = a1; ; a1 = i )
  {
    result = IsListEmpty(a1);
    if ( (_BYTE)result )
      break;
    v2 = (struct _SLIST_ENTRY *)sub_140012758(i);
    sub_140004F48((__int64 **)i);
    sub_140012148(v2);
  }
  i[2] = 0i64;
  return result;
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);

//----- (000000014001233C) ----------------------------------------------------
__int64 __fastcall sub_14001233C(__int64 *a1)
{
  __int64 *i; // rdi
  struct _SLIST_ENTRY *v2; // rbx
  __int64 result; // rax

  for ( i = a1; ; a1 = i )
  {
    result = IsListEmpty(a1);
    if ( (_BYTE)result )
      break;
    v2 = (struct _SLIST_ENTRY *)sub_14000970C(i);
    sub_140004F48((__int64 **)i);
    sub_140012158(v2);
  }
  i[2] = 0i64;
  return result;
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);

//----- (0000000140012758) ----------------------------------------------------
__int64 __fastcall sub_140012758(__int64 *a1)
{
  return sub_140009E44(*a1);
}

//----- (0000000140012760) ----------------------------------------------------
void __fastcall sub_140012760(__int64 *a1, __int64 a2, __int64 a3)
{
  signed __int64 v3; // rcx
  signed __int64 v4; // rdx
  __int64 v5; // rcx

  v5 = *a1;
  if ( v5 )
  {
    v3 = v5 - 24;
    v4 = a3 + a2 - v3;
    if ( v4 == *(_QWORD *)(v3 + 16) )
    {
      *(_QWORD *)(v3 + 8) = 0i64;
      *(_QWORD *)(v3 + 16) = 0i64;
    }
    else
    {
      *(_QWORD *)(v3 + 8) = v4;
    }
  }
}

//----- (0000000140012768) ----------------------------------------------------
char __fastcall sub_140012768(__int64 a1, __int64 a2)
{
  __int64 v2; // r14
  __int64 v3; // rdi
  char v4; // si
  _DWORD *v5; // rbx
  int v6; // eax
  __m128 v8; // [rsp+20h] [rbp-40h]
  __int128 v9; // [rsp+30h] [rbp-30h]
  __int64 v10; // [rsp+40h] [rbp-20h]
  char v11; // [rsp+50h] [rbp-10h]
  char v12; // [rsp+80h] [rbp+20h]

  v2 = a2;
  v3 = a1;
  v4 = 0;
  sub_140011F4C((__int64)&v11, (volatile signed __int32 *)(a1 + 48));
  if ( sub_14001218C((__int64)&v11) )
  {
    if ( *(_QWORD *)(v3 + 32) )
      goto LABEL_14;
    sub_140011EEC((__int64 **)&v12, (__int64 *)(v3 + 16));
    *(_DWORD *)(v3 + 40) = 0;
    sub_140002584(&v8, 0x10ui64);
    sub_14000EA44((__int64 *)(v3 + 56), &v8);
    sub_140002584((__m128 *)&v9, 0x10ui64);
    sub_14000EACC(v3 + 56, &v9);
    while ( sub_14000BA58(&v8, &v9) )
    {
      v5 = *(_DWORD **)sub_14000BB80((__int64)&v8);
      if ( !sub_140009BF0(v5) )
        break;
      ++*(_DWORD *)(v3 + 40);
      *(_QWORD *)(v3 + 32) = v5;
      sub_14000BBE0((__int64)&v8);
    }
    sub_140011FF4((__int64 **)&v12);
    if ( *(_QWORD *)(v3 + 32) )
    {
LABEL_14:
      *(_QWORD *)v2 = sub_140001B3C(v3 + 24);
      v4 = 1;
      *(_QWORD *)(v2 + 8) = *(_QWORD *)sub_14000CBB4((__int64 *)(v3 + 56));
      *(_QWORD *)(v2 + 16) = *(_QWORD *)(v3 + 32);
      v6 = *(_DWORD *)(v3 + 40);
    }
    else
    {
      v6 = 0;
      v9 = 0ui64;
      v10 = 0i64;
      *(_OWORD *)v2 = 0ui64;
      *(_QWORD *)(v2 + 16) = 0i64;
    }
    *(_DWORD *)(v2 + 24) = v6;
  }
  sub_140011FFC((__int64)&v11);
  return v4;
}

//----- (00000001400128AC) ----------------------------------------------------
char __fastcall sub_1400128AC(__int64 a1)
{
  __int64 v1; // rdi
  char v2; // bl
  _DWORD **v3; // rax
  char v5; // [rsp+30h] [rbp+8h]

  v1 = a1;
  sub_140011EEC((__int64 **)&v5, (__int64 *)(a1 + 16));
  v2 = 0;
  if ( !sub_14000EA98(v1 + 56) && !*(_QWORD *)(v1 + 32) )
  {
    v3 = (_DWORD **)sub_14000CBB4((__int64 *)(v1 + 56));
    if ( sub_140009BF0(*v3) )
      v2 = 1;
  }
  sub_140011FF4((__int64 **)&v5);
  return v2;
}

//----- (0000000140012914) ----------------------------------------------------
__int64 __fastcall sub_140012914(__int64 a1)
{
  return sub_140009E44(*(_QWORD *)(a1 + 8));
}

//----- (0000000140012920) ----------------------------------------------------
void __fastcall sub_140012920(_DWORD *a1)
{
  *a1 &= 0x7FFFFFFFu;
}

//----- (0000000140012928) ----------------------------------------------------
_DWORD *__fastcall sub_140012928(unsigned int *a1)
{
  __int64 v1; // rdx
  _DWORD *result; // rax

  v1 = *a1;
  LODWORD(v1) = v1 & 0x7FFFFFFF;
  result = (_DWORD *)sub_140006988((__int64)a1, v1);
  *result &= 0x80000000;
  return result;
}

//----- (0000000140012944) ----------------------------------------------------
bool __fastcall sub_140012944(__int64 a1)
{
  __int64 *v1; // rsi
  bool v2; // di
  __int64 v3; // rax
  __int64 v4; // rbx
  __int64 v5; // r15
  __int64 v6; // rbx
  __int64 v7; // rcx
  __m128i v9; // [rsp+20h] [rbp-39h]
  __m128 v10; // [rsp+30h] [rbp-29h]
  char v11; // [rsp+40h] [rbp-19h]
  char v12; // [rsp+48h] [rbp-11h]
  char v13; // [rsp+58h] [rbp-1h]
  struct _LIST_ENTRY v14; // [rsp+68h] [rbp+Fh]

  v1 = (__int64 *)a1;
  sub_140011F4C((__int64)&v12, (volatile signed __int32 *)(a1 + 44));
  v2 = 0;
  if ( sub_14001218C((__int64)&v12) )
  {
    if ( v1[4] )
    {
      sub_1400086B8(&v14);
      sub_140011EEC((__int64 **)&v11, v1 + 2);
      sub_140002584(&v10, 0x10ui64);
      sub_14000EACC((__int64)(v1 + 7), &v10);
      sub_140002584((__m128 *)&v9, 0x10ui64);
      sub_14000EA44(v1 + 7, &v9);
      while ( sub_14000BA58(&v9, &v10) )
      {
        v3 = sub_14000BB80((__int64)&v9);
        v4 = *(_QWORD *)v3;
        v5 = *(unsigned int *)(v3 + 16);
        if ( *(_QWORD *)(v3 + 8) )
        {
          sub_140012D30((__int64)&v14, (__int64)(v1 + 7), &v9);
        }
        else
        {
          _mm_store_si128(&v9, v9);
          _mm_storeu_si128(&v9, *(__m128i *)sub_1400126F4(v1 + 7, &v13, &v9));
        }
        if ( v4 == v1[4] )
        {
          v1[4] = 0i64;
          sub_140012760(v1 + 3, v4, v5);
          break;
        }
      }
      sub_140011FF4((__int64 **)&v11);
      sub_140002584((__m128 *)&v9, 0x10ui64);
      sub_14000EA44((__int64 *)&v14, &v9);
      sub_140002584(&v10, 0x10ui64);
      sub_14000EACC((__int64)&v14, &v10);
      while ( sub_14000BA58(&v9, &v10) )
      {
        v6 = sub_14000BB80((__int64)&v9);
        v7 = *(_QWORD *)(v6 + 8);
        if ( v7 )
        {
          sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v7 + 8i64));
          sub_14001E1B0(*(__int64 (**)(void))(**(_QWORD **)(v6 + 8) + 40i64));
        }
        sub_14000BBE0((__int64)&v9);
      }
      sub_140011FEC(&v14);
    }
    v2 = !sub_14000EA98((__int64)(v1 + 7));
  }
  sub_140011FFC((__int64)&v12);
  return v2;
}
// 140011FEC: using guessed type __int64 __fastcall sub_140011FEC(_QWORD);
// 1400126F4: using guessed type __int64 __fastcall sub_1400126F4(_QWORD, _QWORD, _QWORD);

//----- (0000000140012B34) ----------------------------------------------------
_QWORD *__fastcall sub_140012B34(__int64 a1, __int64 a2)
{
  _QWORD *result; // rax

  if ( *(_QWORD *)(a2 + 8) )
  {
    ++*(_QWORD *)(a1 + 16);
    result = sub_140004DE4(a1, *(_QWORD **)(a2 + 8));
  }
  return result;
}

//----- (0000000140012B54) ----------------------------------------------------
void __fastcall sub_140012B54(_DWORD *a1)
{
  *a1 = 1;
}

//----- (0000000140012B5C) ----------------------------------------------------
char __fastcall sub_140012B5C(__int64 a1, __int64 a2)
{
  __int64 v2; // r14
  __int64 v3; // rdi
  char v4; // si
  int v5; // ebx
  __int64 v6; // rax
  __int64 v7; // xmm1_8
  bool v8; // r13
  __int64 v9; // rax
  _QWORD *v10; // r12
  char *v11; // rax
  char *v12; // rbx
  _QWORD *v13; // rax
  char v15; // [rsp+20h] [rbp-50h]
  __int128 v16; // [rsp+28h] [rbp-48h]
  __int64 v17; // [rsp+38h] [rbp-38h]
  __int128 v18; // [rsp+40h] [rbp-30h]
  char v19; // [rsp+50h] [rbp-20h]
  unsigned int v20; // [rsp+60h] [rbp-10h]

  v2 = a1;
  v3 = a2;
  v4 = 0;
  v5 = sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)a2 + 80i64));
  v20 = (unsigned __int64)sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v3 + 24i64)) + v5;
  sub_140011EEC((__int64 **)&v15, (__int64 *)(v2 + 16));
  v6 = sub_140012288(v2 + 56);
  v7 = *(_QWORD *)(v6 + 16);
  v16 = *(_OWORD *)v6;
  v17 = v7;
  v8 = sub_14000EA98(v2 + 56);
  v9 = sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v3 + 32i64));
  v10 = (_QWORD *)sub_140011DD0(v2 + 56, v9, (__int64)&v20);
  if ( v10 )
  {
    v11 = sub_1400121A8((__int64 *)(v2 + 24), v20);
    v12 = v11;
    if ( v11 )
    {
      *v10 = v11;
      if ( v11 == (char *)sub_140001B3C(v2 + 24) && !v8 )
        sub_140012928((unsigned int *)v16);
      *(_DWORD *)v12 ^= (v20 ^ *(_DWORD *)v12) & 0x7FFFFFFF;
      sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v3 + 72i64));
      sub_140012920(v12);
      v4 = 1;
    }
    else
    {
      sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v3 + 40i64));
      v13 = sub_14000EACC(v2 + 56, &v19);
      _mm_storeu_si128((__m128i *)&v18, *(__m128i *)sub_14000BBF0((__int64)v13));
      sub_1400126F4(v2 + 56, &v16, &v18);
    }
  }
  else
  {
    sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v3 + 40i64));
  }
  sub_140011FF4((__int64 **)&v15);
  return v4;
}
// 1400126F4: using guessed type __int64 __fastcall sub_1400126F4(_QWORD, _QWORD, _QWORD);

//----- (0000000140012CF0) ----------------------------------------------------
__int64 __fastcall sub_140012CF0(__int64 *a1, _QWORD *a2)
{
  __int64 v2; // r9

  sub_14000B628(a2, (__int64)a1, *a1);
  return v2;
}

//----- (0000000140012D10) ----------------------------------------------------
__int64 __fastcall sub_140012D10(__int64 a1, _QWORD *a2)
{
  __int64 v2; // r9

  sub_14000B628(a2, a1, a1);
  return v2;
}

//----- (0000000140012D30) ----------------------------------------------------
__int64 __fastcall sub_140012D30(__int64 a1, __int64 a2, __m128i *a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  __m128i *v5; // rsi
  char v7; // [rsp+20h] [rbp-28h]
  __int128 v8; // [rsp+30h] [rbp-18h]

  v3 = a2;
  v4 = a1;
  v5 = a3;
  sub_140002584((__m128 *)&v7, 0x10ui64);
  _mm_storeu_si128((__m128i *)&v8, *v5);
  sub_14000E904(v3, (__m128 *)&v7, (__int64)&v8);
  sub_140012B34(v4, (__int64)v5);
  return unknown_libname_5(v5, &v7);
}
// 140012168: using guessed type __int64 __fastcall unknown_libname_5(_QWORD, _QWORD);

//----- (0000000140012D9C) ----------------------------------------------------
__int64 __fastcall sub_140012D9C(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  sub_140012E90(a1);
  sub_14000896C((_QWORD *)(v1 + 104));
  return v1;
}

//----- (0000000140012DDC) ----------------------------------------------------
void *sub_140012DDC()
{
  return &unk_140034D00;
}

//----- (0000000140012DF0) ----------------------------------------------------
PVOID __fastcall sub_140012DF0(__int64 a1, unsigned int a2)
{
  PVOID result; // rax

  if ( a2 )
    result = ExAllocatePoolWithTag((POOL_TYPE)512, a2, 0x65657254u);
  else
    result = 0i64;
  return result;
}

//----- (0000000140012E0C) ----------------------------------------------------
__int64 __fastcall sub_140012E0C(unsigned int *a1, unsigned int *a2)
{
  unsigned int *v2; // rbx
  unsigned int *v3; // rdi
  unsigned int v4; // er8

  v2 = a2;
  v3 = a1;
  v4 = 1;
  if ( a2 )
  {
    if ( sub_14000FEFC(a1, a2) )
      v4 = 2;
    else
      v4 = sub_14000FFCC(v3, v2) == 0;
  }
  return v4;
}

//----- (0000000140012E60) ----------------------------------------------------
__int64 __fastcall sub_140012E60(__int64 a1, unsigned int *a2, unsigned int *a3)
{
  return sub_140012E0C(a3, a2);
}

//----- (0000000140012E70) ----------------------------------------------------
void __fastcall sub_140012E70(__int64 a1, void *a2)
{
  if ( a2 )
    ExFreePoolWithTag(a2, 0x65657254u);
}

//----- (0000000140012E90) ----------------------------------------------------
__int64 __fastcall sub_140012E90(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  RtlInitializeGenericTableAvl(a1);
  return v1;
}
// 140029348: using guessed type __int64 __cdecl RtlInitializeGenericTableAvl(_QWORD);

//----- (0000000140012EB8) ----------------------------------------------------
__int64 __fastcall sub_140012EB8(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 result; // rax

  v2 = a1;
  LOBYTE(a2) = 1;
  while ( 1 )
  {
    result = RtlEnumerateGenericTableAvl(a1, a2);
    if ( !result )
      break;
    RtlDeleteElementGenericTableAvl(v2, result);
    a2 = 0i64;
    a1 = v2;
  }
  return result;
}
// 140029358: using guessed type __int64 __fastcall RtlDeleteElementGenericTableAvl(_QWORD, _QWORD);
// 140029368: using guessed type __int64 __fastcall RtlEnumerateGenericTableAvl(_QWORD, _QWORD);

//----- (0000000140012EE8) ----------------------------------------------------
bool sub_140012EE8()
{
  return (unsigned int)RtlNumberGenericTableElementsAvl() == 0;
}
// 140012F4C: using guessed type __int64 RtlNumberGenericTableElementsAvl(void);

//----- (0000000140012F04) ----------------------------------------------------
char __fastcall sub_140012F04(__int64 a1, __int64 a2, __int64 a3, __int64 *a4)
{
  __int64 *v4; // rbx
  __int64 v5; // rax
  char v7; // [rsp+20h] [rbp-18h]

  v4 = a4;
  v7 = 0;
  v5 = RtlInsertElementGenericTableAvl(a1, a2, a3, &v7);
  if ( v4 )
    *v4 = v5;
  return v7;
}
// 140029350: using guessed type __int64 __fastcall RtlInsertElementGenericTableAvl(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140012F5C) ----------------------------------------------------
signed __int64 __fastcall sub_140012F5C(__int64 *a1, __int64 a2, __int64 *a3, __int64 a4)
{
  __int64 *v4; // rbx
  __int64 v5; // rdi
  signed __int64 result; // rax

  v4 = a3;
  v5 = a4;
  result = sub_140006BE0(a1, a3, a2);
  if ( (signed int)result < 0 )
    *v4 = v5;
  return result;
}

//----- (0000000140012F8C) ----------------------------------------------------
__int64 __fastcall sub_140012F8C(char *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  char *v4; // rdi
  __int64 v6; // [rsp+20h] [rbp-28h]
  char v7; // [rsp+28h] [rbp-20h]

  v3 = a2;
  v6 = a3;
  v4 = a1;
  if ( sub_14001304C(6u, 2u) )
  {
    sub_140002584((__m128 *)&v7, 8ui64);
    unknown_libname_1(&v7);
    if ( (signed int)sub_140006998(&v7, v4) >= 0 )
      sub_140006BE0((__int64 *)&v7, &v6, v3);
  }
  return v6;
}
// 140001AB0: using guessed type __int64 __fastcall unknown_libname_1(_QWORD);

//----- (000000014001301C) ----------------------------------------------------
_DWORD *__fastcall sub_14001301C(_DWORD *a1, int a2)
{
  _DWORD *result; // rax

  a1[1] = 0;
  result = a1;
  *a1 = a2;
  return result;
}

//----- (0000000140013028) ----------------------------------------------------
_DWORD *__fastcall sub_140013028(_DWORD *a1, int a2)
{
  int v2; // ebx
  _DWORD *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140013170(a1);
  *v3 = v2;
  return v3;
}

//----- (000000014001304C) ----------------------------------------------------
char __fastcall sub_14001304C(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // edi
  unsigned int v3; // esi
  char v4; // bl
  int v6; // [rsp+20h] [rbp-138h]
  unsigned int v7; // [rsp+24h] [rbp-134h]
  unsigned int v8; // [rsp+28h] [rbp-130h]

  v2 = a1;
  v6 = 276;
  v3 = a2;
  v4 = 0;
  if ( (signed int)RtlGetVersion(&v6) >= 0 && (v7 > v2 || v7 == v2 && v8 >= v3) )
    v4 = 1;
  return v4;
}
// 140029378: using guessed type __int64 __fastcall RtlGetVersion(_QWORD);

//----- (00000001400130C4) ----------------------------------------------------
__int64 __fastcall sub_1400130C4(_DWORD *a1)
{
  _DWORD *v1; // rbx

  v1 = a1;
  sub_140013170(a1);
  return (unsigned int)v1[1];
}

//----- (00000001400130E0) ----------------------------------------------------
signed __int64 sub_1400130E0()
{
  return 3221225860i64;
}

//----- (00000001400130E8) ----------------------------------------------------
__int64 sub_1400130E8()
{
  __int64 (*v0)(void); // rax
  __int64 v2; // [rsp+20h] [rbp-18h]

  if ( dword_140034D90 & 1 )
  {
    v0 = (__int64 (*)(void))qword_140034D88;
  }
  else
  {
    dword_140034D90 |= 1u;
    v0 = (__int64 (*)(void))sub_140012F8C("NtosKrnl.sys", (__int64)"KeQuerySystemTimePrecise", (__int64)sub_140013160);
    qword_140034D88 = (__int64)v0;
  }
  sub_14001E1B0(v0);
  return v2;
}
// 140034D88: using guessed type __int64 qword_140034D88;
// 140034D90: using guessed type int dword_140034D90;

//----- (0000000140013160) ----------------------------------------------------
__int64 __fastcall sub_140013160(_QWORD *a1)
{
  __int64 result; // rax

  result = MEMORY[0xFFFFF78000000014];
  *a1 = MEMORY[0xFFFFF78000000014];
  return result;
}

//----- (0000000140013170) ----------------------------------------------------
void __fastcall sub_140013170(_DWORD *a1)
{
  if ( a1[1] >= 0 )
  {
    if ( *a1 )
      a1[1] = *a1;
  }
}

//----- (0000000140013188) ----------------------------------------------------
void *sub_140013188()
{
  return &unk_140034D70;
}

//----- (0000000140013190) ----------------------------------------------------
__int64 sub_140013190()
{
  int v0; // eax
  int v1; // eax
  int v2; // eax
  int v3; // eax
  unsigned int v5[2]; // [rsp+20h] [rbp-20h]
  char v6; // [rsp+28h] [rbp-18h]

  sub_140002584((__m128 *)&v6, 8ui64);
  unknown_libname_1(&v6);
  v0 = sub_140006998(&v6, "fwpkclnt.sys");
  sub_14001301C(v5, v0);
  if ( (signed int)sub_14000EA40(v5) >= 0 )
  {
    v1 = sub_140012F5C(
           (__int64 *)&v6,
           (__int64)"FwpsCalloutRegister2",
           (__int64 *)&unk_140034D70,
           (__int64)FwpsCalloutRegister1);
    sub_140013028(v5, v1);
    v2 = sub_140012F5C(
           (__int64 *)&v6,
           (__int64)"FwpsInjectMacReceiveAsync0",
           (__int64 *)&unk_140034D78,
           (__int64)sub_1400130E0);
    sub_140013028(v5, v2);
    v3 = sub_140012F5C(
           (__int64 *)&v6,
           (__int64)"FwpsInjectMacSendAsync0",
           (__int64 *)&unk_140034D80,
           (__int64)sub_1400130E0);
    sub_140013028(v5, v3);
  }
  sub_1400130E8();
  return sub_1400130C4(v5);
}
// 140001AB0: using guessed type __int64 __fastcall unknown_libname_1(_QWORD);
// 14001DC60: using guessed type __int64 __fastcall FwpsCalloutRegister1(_QWORD, _QWORD, _QWORD);

//----- (0000000140013284) ----------------------------------------------------
__int64 __fastcall sub_140013284(__int64 a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // rbx
  __int64 *v3; // rax
  __int64 *v4; // rax
  __int64 *v5; // rax
  __int64 *v6; // rax
  __int64 *v7; // rax
  __int64 *v8; // rax

  v2 = a2;
  v3 = (__int64 *)sub_140013F18(a1, *a2);
  v4 = sub_140013F10(v3, 46);
  v5 = (__int64 *)sub_140013F18(v4, v2[1]);
  v6 = sub_140013F10(v5, 46);
  v7 = (__int64 *)sub_140013F18(v6, v2[2]);
  v8 = sub_140013F10(v7, 46);
  return sub_140013F18(v8, v2[3]);
}
// 140013F18: using guessed type __int64 __fastcall sub_140013F18(_QWORD, _QWORD);

//----- (00000001400132DC) ----------------------------------------------------
__int64 *__fastcall sub_1400132DC(__int64 a1, unsigned __int16 *a2)
{
  unsigned __int16 *v2; // r15
  __int64 *v3; // rbx
  char v4; // si
  signed int v5; // edi
  signed __int64 v6; // r14
  unsigned __int16 v7; // cx
  unsigned int v8; // ebp

  v2 = a2;
  v3 = (__int64 *)a1;
  sub_1400141B8(a1, 1);
  v4 = 0;
  v5 = 0;
  v6 = 8i64;
  do
  {
    v7 = *v2;
    ++v2;
    v8 = (unsigned __int16)sub_1400140B0(v7);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        if ( !v8 )
        {
          sub_14000EF40(v3, qword_140020AE0);
          v4 = 0;
          v5 = 2;
          goto LABEL_19;
        }
        if ( v4 )
          sub_14000EF40(v3, qword_140020AB0);
        else
          v4 = 1;
        sub_140013F10(v3, 48);
        v5 = 0;
      }
      else if ( v5 == 2 )
      {
        if ( !v8 )
          goto LABEL_19;
        v5 = 3;
      }
    }
    else if ( !v8 )
    {
      v5 = 1;
      goto LABEL_19;
    }
    if ( v4 )
      sub_140013F10(v3, 58);
    else
      v4 = 1;
    sub_140013F18(v3, v8);
LABEL_19:
    --v6;
  }
  while ( v6 );
  sub_1400141B0((__int64)v3);
  return v3;
}
// 14000EF40: using guessed type __int64 __fastcall sub_14000EF40(_QWORD, _QWORD);
// 140013F18: using guessed type __int64 __fastcall sub_140013F18(_QWORD, _QWORD);
// 140020AB0: using guessed type __int64 qword_140020AB0[2];
// 140020AE0: using guessed type __int64 qword_140020AE0[2];

//----- (00000001400133C8) ----------------------------------------------------
__int64 __fastcall sub_1400133C8(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rdi
  char v3; // bp
  __int64 v4; // rbx
  char v5; // r15
  unsigned __int8 *v6; // r14
  unsigned __int8 v7; // r12

  v2 = a2;
  v3 = 1;
  v4 = a1;
  v5 = sub_1400141B8(a1, 1);
  v6 = (unsigned __int8 *)v2;
  if ( v2 <= v2 + 6 )
  {
    do
    {
      v7 = *v6;
      if ( v3 )
        v3 = 0;
      else
        sub_14000EF40(v4, qword_140020AB0);
      sub_1400141C8(v4, 2);
      sub_1400141C0(v4, 48);
      sub_140013F18(v4, v7);
      ++v6;
    }
    while ( &v6[-v2] != (unsigned __int8 *)(v2 + 6 >= v2 ? 6 : 0) );
  }
  sub_1400141B8(v4, v5);
  return v4;
}
// 14000EF40: using guessed type __int64 __fastcall sub_14000EF40(_QWORD, _QWORD);
// 140013F18: using guessed type __int64 __fastcall sub_140013F18(_QWORD, _QWORD);
// 140020AB0: using guessed type __int64 qword_140020AB0[2];

//----- (0000000140013490) ----------------------------------------------------
__int64 *__fastcall sub_140013490(__int64 *a1, int *a2)
{
  int v2; // edi
  __int64 *v3; // rbx

  v2 = *a2;
  v3 = a1;
  if ( *a2 )
  {
    sub_140013F10(a1, 91);
    if ( v2 & 1 )
      sub_140013F10(v3, 70);
    if ( v2 & 2 )
      sub_140013F10(v3, 83);
    if ( v2 & 4 )
      sub_140013F10(v3, 82);
    if ( v2 & 8 )
      sub_140013F10(v3, 80);
    if ( v2 & 0x10 )
      sub_140013F10(v3, 65);
    if ( v2 & 0x20 )
      sub_140013F10(v3, 85);
    if ( v2 & 0x40 )
      sub_140013F10(v3, 69);
    if ( (v2 & 0x80u) != 0 )
      sub_140013F10(v3, 67);
    sub_140013F10(v3, 93);
  }
  return v3;
}

//----- (0000000140013548) ----------------------------------------------------
__int64 __fastcall sub_140013548(__int64 a1, unsigned int *a2)
{
  __int64 v2; // rbx
  unsigned int *v3; // rdi
  int v4; // eax
  __int64 result; // rax
  __m128i *v6; // rax
  unsigned __int8 *v7; // rax
  char v8; // [rsp+20h] [rbp-18h]
  char v9; // [rsp+50h] [rbp+18h]

  v2 = a1;
  v3 = a2;
  v4 = sub_14000EA40(a2);
  if ( v4 == 2048 )
  {
    v7 = (unsigned __int8 *)sub_14000C16C(v3, &v9);
    result = sub_140013284(v2, v7);
  }
  else if ( v4 == 34525 )
  {
    v6 = sub_14000C1A8(v3, (__m128i *)&v8);
    result = (__int64)sub_1400132DC(v2, (unsigned __int16 *)v6);
  }
  else
  {
    result = sub_14000EF40(v2, "UNSUPPORTED");
  }
  return result;
}
// 14000EF40: using guessed type __int64 __fastcall sub_14000EF40(_QWORD, _QWORD);

//----- (00000001400135BC) ----------------------------------------------------
__int64 *__fastcall sub_1400135BC(__int64 a1, unsigned int *a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 *v5; // rbx
  int v6; // eax
  int *v7; // rax
  char v8; // [rsp+40h] [rbp+18h]

  v2 = a1;
  v3 = (__int64)a2;
  if ( (unsigned int)sub_14000EA40(a2) != 6 )
    return (__int64 *)v2;
  v5 = (__int64 *)sub_14000EF40(v2, qword_1400209D0);
  v6 = sub_1400083C8(v3);
  v7 = sub_140013F08(&v8, v6);
  return sub_140013490(v5, v7);
}
// 14000EF40: using guessed type __int64 __fastcall sub_14000EF40(_QWORD, _QWORD);
// 1400209D0: using guessed type __int64 qword_1400209D0[2];

//----- (000000014001361C) ----------------------------------------------------
__int64 __fastcall sub_14001361C(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  unsigned int v4; // eax
  int v5; // eax
  int v6; // eax
  __int64 v7; // rbx
  unsigned int v8; // eax
  __int64 v9; // rbx
  unsigned int *v10; // rax
  __int64 *v11; // rax
  __int64 v12; // rbx
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rbx
  unsigned int *v16; // rax
  __int64 v17; // rbx
  unsigned int *v18; // rax
  __int64 v19; // rax
  __int64 v20; // rbx
  unsigned int *v21; // rax
  __int64 v22; // rbx
  unsigned int *v23; // rax
  __int64 v25; // rbx
  __int64 v26; // rax
  __int64 v27; // rax
  unsigned __int8 *v28; // rsi
  int v29; // eax
  __int64 v30; // rbx
  unsigned __int16 v31; // ax
  __int64 v32; // rax
  const char *v33; // rdx
  int v34; // eax
  __int64 v35; // rcx
  const char *v36; // rdx
  __int64 v37; // rbx
  __int64 v38; // rax
  __int64 v39; // rax
  __int64 v40; // rbx
  unsigned __int16 *v41; // rax
  __int64 *v42; // rax
  __int64 v43; // rbx
  __int64 v44; // rax
  __int64 v45; // rax
  __int64 v46; // rbx
  unsigned __int16 *v47; // rax
  __int64 v48; // rbx
  __int64 v49; // rax
  __int64 v50; // rax
  __int64 v51; // rbx
  unsigned __int8 *v52; // rax
  __int64 v53; // rax
  __int64 v54; // rbx
  __int64 v55; // rax
  __int64 v56; // rax
  __int64 v57; // rbx
  unsigned __int8 *v58; // rax
  char v59; // [rsp+20h] [rbp-38h]
  char v60; // [rsp+30h] [rbp-28h]
  char v61; // [rsp+60h] [rbp+8h]
  char v62; // [rsp+70h] [rbp+18h]
  char v63; // [rsp+78h] [rbp+20h]

  v2 = a1;
  v3 = a2;
  v4 = sub_14000CC80(a2);
  sub_1400139C4(v2, v4);
  v5 = (unsigned __int64)sub_14000CC80(v3) - 2048;
  if ( !v5 )
    goto LABEL_4;
  v6 = v5 - 6;
  if ( !v6 )
  {
    v25 = sub_140014090(v3);
    v26 = sub_140001B3C(v3);
    v27 = sub_140006988(v26, v25);
    v28 = (unsigned __int8 *)v27;
    v29 = (unsigned __int16)sub_140008DF4((unsigned __int8 *)(v27 + 6)) - 1;
    if ( v29 )
    {
      if ( v29 != 1 )
      {
        v30 = sub_14000EF40(v2, qword_140020A30);
        v31 = sub_140008DF4(v28 + 6);
        v32 = sub_14000EF38(v30, v31);
        v33 = (const char *)qword_140020A40;
        goto LABEL_12;
      }
      v33 = " reply";
    }
    else
    {
      v33 = " request";
    }
    v32 = v2;
LABEL_12:
    sub_14000EF40(v32, v33);
    if ( sub_140008DF4(v28) == 1 )
    {
      v34 = sub_140014070((__int64)v28);
      v35 = v2;
      if ( v34 == 2048 )
      {
        v48 = sub_14000EF40(v2, " sha=");
        v49 = sub_140013B7C((__int64)v28);
        v50 = sub_1400133C8(v48, v49);
        v51 = sub_14000EF40(v50, " spa=");
        v52 = (unsigned __int8 *)sub_140013B88((__int64)v28);
        v53 = sub_140013284(v51, v52);
        v54 = sub_14000EF40(v53, " tha=");
        v55 = sub_140013B98((__int64)v28);
        v56 = sub_1400133C8(v54, v55);
        v57 = sub_14000EF40(v56, " tpa=");
        v58 = (unsigned __int8 *)sub_140013BAC((__int64)v28);
        sub_140013284(v57, v58);
        return v2;
      }
      if ( v34 == 34525 )
      {
        v37 = sub_14000EF40(v2, " sha=");
        v38 = sub_140013B7C((__int64)v28);
        v39 = sub_1400133C8(v37, v38);
        v40 = sub_14000EF40(v39, " spa=");
        v41 = (unsigned __int16 *)sub_140013B88((__int64)v28);
        v42 = sub_1400132DC(v40, v41);
        v43 = sub_14000EF40(v42, " tha=");
        v44 = sub_140013B98((__int64)v28);
        v45 = sub_1400133C8(v43, v44);
        v46 = sub_14000EF40(v45, " tpa=");
        v47 = (unsigned __int16 *)sub_140013BAC((__int64)v28);
        sub_1400132DC(v46, v47);
        return v2;
      }
      v36 = "not IP";
    }
    else
    {
      v36 = "not ethernet";
      v35 = v2;
    }
    sub_14000EF40(v35, v36);
    return v2;
  }
  if ( v6 == 32471 )
  {
LABEL_4:
    v7 = sub_14000EF40(v2, qword_1400209D0);
    v8 = sub_1400111B8(v3);
    v9 = sub_140013A7C(v7, v8);
    v10 = sub_140014034(v3, &v61);
    v11 = sub_1400135BC(v9, v10);
    v12 = sub_14000EF40(v11, qword_1400209E0);
    v13 = sub_140008E08(v3);
    v14 = sub_140013F20(v12, v13);
    v15 = sub_14000EF40(v14, qword_1400209F0);
    v16 = (unsigned int *)sub_14000E98C(v3, (__int64)&v59);
    v17 = sub_140013548(v15, v16);
    v18 = (unsigned int *)sub_14000E9EC(v3, (__int64)&v62);
    v19 = sub_140013960(v17, v18);
    v20 = sub_14000EF40(v19, qword_140020A00);
    v21 = (unsigned int *)sub_14000C96C(v3, (__int64)&v60);
    v22 = sub_140013548(v20, v21);
    v23 = (unsigned int *)sub_14000C9CC(v3, (__int64)&v63);
    sub_140013960(v22, v23);
  }
  return v2;
}
// 14000EF38: using guessed type __int64 __fastcall sub_14000EF38(_QWORD, _QWORD);
// 14000EF40: using guessed type __int64 __fastcall sub_14000EF40(_QWORD, _QWORD);
// 140013F20: using guessed type __int64 __fastcall sub_140013F20(_QWORD, _QWORD);
// 1400209D0: using guessed type __int64 qword_1400209D0[2];
// 1400209E0: using guessed type __int64 qword_1400209E0[2];
// 1400209F0: using guessed type __int64 qword_1400209F0[2];
// 140020A00: using guessed type __int64 qword_140020A00[2];
// 140020A30: using guessed type __int64 qword_140020A30[2];
// 140020A40: using guessed type __int64 qword_140020A40[2];

//----- (0000000140013960) ----------------------------------------------------
__int64 __fastcall sub_140013960(__int64 a1, unsigned int *a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  int v4; // eax
  __int64 *v6; // rdx
  __int64 v7; // rbx
  unsigned __int16 v8; // ax

  v2 = a1;
  v3 = (__int64)a2;
  v4 = sub_14000EA40(a2);
  if ( v4 == 2048 )
  {
    v6 = qword_140020AB0;
  }
  else
  {
    if ( v4 != 34525 )
      return v2;
    v6 = qword_140020AC0;
  }
  v7 = sub_14000EF40(v2, v6);
  v8 = sub_14000BAF8(v3);
  return sub_140013F18(v7, v8);
}
// 14000EF40: using guessed type __int64 __fastcall sub_14000EF40(_QWORD, _QWORD);
// 140013F18: using guessed type __int64 __fastcall sub_140013F18(_QWORD, _QWORD);
// 140020AB0: using guessed type __int64 qword_140020AB0[2];
// 140020AC0: using guessed type __int64 qword_140020AC0[2];

//----- (00000001400139C4) ----------------------------------------------------
__int64 __fastcall sub_1400139C4(__int64 a1, unsigned int a2)
{
  unsigned int v2; // esi
  __int64 v3; // rdi
  char v4; // bl
  __int64 v5; // rax
  __int64 v6; // rax
  const char *v8; // rdx

  v2 = a2;
  v3 = a1;
  switch ( a2 )
  {
    case 0x800u:
      v8 = "ipv4";
      break;
    case 0x806u:
      v8 = (const char *)qword_140020B70;
      break;
    case 0x86DDu:
      v8 = "ipv6";
      break;
    default:
      v4 = sub_1400141B8(a1, 1);
      sub_1400141C0(v3, 48);
      sub_1400141C8(v3, 4);
      v5 = sub_14000EF40(v3, qword_140020B80);
      v6 = sub_140013F18(v5, v2);
      sub_14000EF40(v6, qword_140020B40);
      sub_1400141B8(v3, v4);
      return v3;
  }
  return sub_14000EF40(a1, v8);
}
// 14000EF40: using guessed type __int64 __fastcall sub_14000EF40(_QWORD, _QWORD);
// 140013F18: using guessed type __int64 __fastcall sub_140013F18(_QWORD, _QWORD);
// 140020B40: using guessed type __int64 qword_140020B40[2];
// 140020B70: using guessed type __int64 qword_140020B70[2];
// 140020B80: using guessed type __int64 qword_140020B80[2];

//----- (0000000140013A7C) ----------------------------------------------------
__int64 __fastcall sub_140013A7C(__int64 a1, unsigned int a2)
{
  unsigned int v2; // ebx
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 *v5; // rdx

  v2 = a2;
  switch ( a2 )
  {
    case 1u:
      v5 = (__int64 *)"ICMP";
      break;
    case 6u:
      v5 = qword_140020B00;
      break;
    case 0x11u:
      v5 = qword_140020B10;
      break;
    case 0x3Au:
      v5 = (__int64 *)"ICMPv6";
      break;
    default:
      v3 = sub_14000EF40(a1, qword_140020B30);
      v4 = sub_140013F18(v3, v2);
      v5 = qword_140020B40;
      a1 = v4;
      break;
  }
  return sub_14000EF40(a1, v5);
}
// 14000EF40: using guessed type __int64 __fastcall sub_14000EF40(_QWORD, _QWORD);
// 140013F18: using guessed type __int64 __fastcall sub_140013F18(_QWORD, _QWORD);
// 140020B00: using guessed type __int64 qword_140020B00[2];
// 140020B10: using guessed type __int64 qword_140020B10[2];
// 140020B30: using guessed type __int64 qword_140020B30[2];
// 140020B40: using guessed type __int64 qword_140020B40[2];

//----- (0000000140013AF0) ----------------------------------------------------
signed __int64 __fastcall sub_140013AF0(unsigned int a1)
{
  unsigned int v1; // kr00_4
  signed __int64 v2; // rcx
  unsigned int v3; // edx

  v1 = a1;
  v2 = 1i64;
  v3 = v1 / 0xA;
  while ( v3 )
  {
    v3 /= 0xAu;
    ++v2;
  }
  return v2;
}

//----- (0000000140013B18) ----------------------------------------------------
signed __int64 __fastcall sub_140013B18(unsigned __int64 a1)
{
  unsigned __int128 v1; // ax
  signed __int64 v2; // rcx
  unsigned __int64 v3; // rdx

  v1 = a1 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64;
  v2 = 1i64;
  v3 = *((_QWORD *)&v1 + 1) >> 3;
  while ( v3 )
  {
    v3 = (unsigned __int64)(v3 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 3;
    ++v2;
  }
  return v2;
}

//----- (0000000140013B4C) ----------------------------------------------------
signed __int64 __fastcall sub_140013B4C(unsigned int a1)
{
  unsigned int v1; // ecx
  signed __int64 result; // rax

  v1 = a1 >> 4;
  result = 1i64;
  while ( v1 )
  {
    v1 >>= 4;
    ++result;
  }
  return result;
}

//----- (0000000140013B64) ----------------------------------------------------
signed __int64 __fastcall sub_140013B64(unsigned __int64 a1)
{
  unsigned __int64 v1; // rcx
  signed __int64 result; // rax

  v1 = a1 >> 4;
  result = 1i64;
  while ( v1 )
  {
    v1 >>= 4;
    ++result;
  }
  return result;
}

//----- (0000000140013B7C) ----------------------------------------------------
__int64 __fastcall sub_140013B7C(__int64 a1)
{
  return sub_140006988(a1, 8i64);
}

//----- (0000000140013B88) ----------------------------------------------------
__int64 __fastcall sub_140013B88(__int64 a1)
{
  return sub_140006988(a1, *(unsigned __int8 *)(a1 + 4) + 8i64);
}

//----- (0000000140013B98) ----------------------------------------------------
__int64 __fastcall sub_140013B98(__int64 a1)
{
  return sub_140006988(a1, *(unsigned __int8 *)(a1 + 4) + 8i64 + *(unsigned __int8 *)(a1 + 5));
}

//----- (0000000140013BAC) ----------------------------------------------------
__int64 __fastcall sub_140013BAC(__int64 a1)
{
  return sub_140006988(a1, *(unsigned __int8 *)(a1 + 5) + 8i64 + 2i64 * *(unsigned __int8 *)(a1 + 4));
}

//----- (0000000140013BC4) ----------------------------------------------------
__int64 __fastcall sub_140013BC4(__int64 a1, unsigned int a2)
{
  unsigned int v2; // edi
  __int64 v3; // rbx
  unsigned __int64 v4; // rbp
  unsigned __int64 v5; // rsi
  signed __int64 v6; // rax
  _WORD *v7; // r8
  unsigned __int64 v8; // rsi
  signed __int64 v9; // rax
  _WORD *v10; // rdx
  unsigned __int16 v11; // cx
  __int16 v12; // ax

  v2 = a2;
  v3 = a1;
  if ( a2 )
  {
    v4 = *(unsigned int *)(a1 + 36);
    if ( *(_BYTE *)(a1 + 32) )
    {
      v8 = sub_140013B4C(a2);
      if ( v8 < v4 )
      {
        do
        {
          sub_14000EF38(v3, *(unsigned __int16 *)(v3 + 34));
          --*(_DWORD *)(v3 + 36);
        }
        while ( v8 < *(unsigned int *)(v3 + 36) );
      }
      *(_DWORD *)(v3 + 36) = 0;
      v9 = sub_14000F458((__int64 *)v3, v8);
      if ( v9 && v2 )
      {
        v10 = (_WORD *)(v9 + 2 * v8);
        do
        {
          --v10;
          v11 = v2 & 0xF;
          v12 = -(v11 < 0xAu);
          v2 >>= 4;
          *v10 = v11 + (v12 & 0xFFD9) + 87;
        }
        while ( v2 );
      }
    }
    else
    {
      v5 = sub_140013AF0(a2);
      if ( v5 < v4 )
      {
        do
        {
          sub_14000EF38(v3, *(unsigned __int16 *)(v3 + 34));
          --*(_DWORD *)(v3 + 36);
        }
        while ( v5 < *(unsigned int *)(v3 + 36) );
      }
      *(_DWORD *)(v3 + 36) = 0;
      v6 = sub_14000F458((__int64 *)v3, v5);
      if ( v6 && v2 )
      {
        v7 = (_WORD *)(v6 + 2 * v5);
        do
        {
          --v7;
          *v7 = v2 % 0xA + 48;
          v2 /= 0xAu;
        }
        while ( v2 );
      }
    }
  }
  else
  {
    sub_14000EF38(a1, 48i64);
    while ( *(_DWORD *)(v3 + 36) > 1u )
    {
      sub_14000EF38(v3, 48i64);
      --*(_DWORD *)(v3 + 36);
    }
    *(_DWORD *)(v3 + 36) = 0;
  }
  return v3;
}
// 14000EF38: using guessed type __int64 __fastcall sub_14000EF38(_QWORD, _QWORD);

//----- (0000000140013D10) ----------------------------------------------------
__int64 __fastcall sub_140013D10(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rdi
  __int64 v3; // rbx
  unsigned __int64 v4; // rbp
  unsigned __int64 v5; // rsi
  signed __int64 v6; // rax
  _WORD *v7; // r8
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // rsi
  signed __int64 v10; // rax
  _WORD *v11; // rdx
  unsigned __int16 v12; // cx
  __int16 v13; // ax

  v2 = a2;
  v3 = a1;
  if ( a2 )
  {
    v4 = *(unsigned int *)(a1 + 36);
    if ( *(_BYTE *)(a1 + 32) )
    {
      v9 = sub_140013B64(a2);
      if ( v9 < v4 )
      {
        do
        {
          sub_14000EF38(v3, *(unsigned __int16 *)(v3 + 34));
          --*(_DWORD *)(v3 + 36);
        }
        while ( v9 < *(unsigned int *)(v3 + 36) );
      }
      *(_DWORD *)(v3 + 36) = 0;
      v10 = sub_14000F458((__int64 *)v3, v9);
      if ( v10 && v2 )
      {
        v11 = (_WORD *)(v10 + 2 * v9);
        do
        {
          --v11;
          v12 = v2 & 0xF;
          v13 = -(v12 < 0xAu);
          v2 >>= 4;
          *v11 = v12 + (v13 & 0xFFD9) + 87;
        }
        while ( v2 );
      }
    }
    else
    {
      v5 = sub_140013B18(a2);
      if ( v5 < v4 )
      {
        do
        {
          sub_14000EF38(v3, *(unsigned __int16 *)(v3 + 34));
          --*(_DWORD *)(v3 + 36);
        }
        while ( v5 < *(unsigned int *)(v3 + 36) );
      }
      *(_DWORD *)(v3 + 36) = 0;
      v6 = sub_14000F458((__int64 *)v3, v5);
      if ( v6 && v2 )
      {
        v7 = (_WORD *)(v6 + 2 * v5);
        do
        {
          --v7;
          v8 = (unsigned __int64)(v2 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 3;
          *v7 = v2 - 10 * v8 + 48;
          v2 = (unsigned __int64)(v2 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 3;
        }
        while ( v8 );
      }
    }
  }
  else
  {
    sub_14000EF38(a1, 48i64);
    while ( *(_DWORD *)(v3 + 36) > 1u )
    {
      sub_14000EF38(v3, 48i64);
      --*(_DWORD *)(v3 + 36);
    }
    *(_DWORD *)(v3 + 36) = 0;
  }
  return v3;
}
// 14000EF38: using guessed type __int64 __fastcall sub_14000EF38(_QWORD, _QWORD);

//----- (0000000140013E70) ----------------------------------------------------
_DWORD *__fastcall sub_140013E70(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // rax

  *a1 = a2;
  result = a1;
  a1[1] = a3;
  return result;
}

//----- (0000000140013E7C) ----------------------------------------------------
_QWORD *__fastcall sub_140013E7C(_QWORD *a1)
{
  *a1 = &off_14002E2B0;
  return a1;
}
// 14002E2B0: using guessed type void *off_14002E2B0;

//----- (0000000140013E8C) ----------------------------------------------------
__m128i *__fastcall sub_140013E8C(__m128i *a1, __int64 a2, __int32 a3, __int32 a4, __m128i *a5)
{
  __int32 v5; // ebp
  __int32 v6; // ebx
  __int64 v7; // rdi
  __m128i *v8; // rsi
  __m128i *result; // rax

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  sub_140013E7C(a1);
  v8->m128i_i64[0] = (__int64)&off_14002E310;
  LODWORD(v8->m128i_i64[1]) = sub_14000FD70(v7);
  HIDWORD(v8->m128i_i64[1]) = 1;
  v8[1].m128i_i32[0] = v6;
  v8[1].m128i_i64[1] = sub_140014088();
  v8[3].m128i_i32[0] = v5;
  result = v8;
  _mm_storeu_si128(v8 + 2, *a5);
  v8[3].m128i_i64[1] = v7;
  return result;
}
// 140014088: using guessed type __int64 sub_140014088(void);
// 14002E310: using guessed type __int64 (__fastcall *off_14002E310)();

//----- (0000000140013F08) ----------------------------------------------------
_DWORD *__fastcall sub_140013F08(_DWORD *a1, int a2)
{
  *a1 = a2;
  return a1;
}

//----- (0000000140013F10) ----------------------------------------------------
__int64 *__fastcall sub_140013F10(__int64 *a1, char a2)
{
  return sub_14000F17C(a1, a2);
}

//----- (0000000140013F30) ----------------------------------------------------
__int64 __fastcall sub_140013F30(__int64 a1)
{
  _InterlockedIncrement((volatile signed __int32 *)(a1 + 12));
  return a1;
}

//----- (0000000140013F40) ----------------------------------------------------
__int64 __fastcall sub_140013F40(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  char v7; // [rsp+20h] [rbp-158h]
  __m128 v8[16]; // [rsp+50h] [rbp-128h]

  v2 = a2;
  v3 = a1;
  if ( !*(_QWORD *)(a1 + 56) )
    return sub_14000EF40(a2, "[no NBL]");
  sub_14001E1C0(v8, 0, 0x100ui64);
  v4 = sub_14000FD70(*(_QWORD *)(v3 + 56));
  if ( v4 > 0x100 )
    v4 = 256i64;
  sub_14000FBF8(*(_QWORD *)(v3 + 56), (__int64)v8, v4);
  v5 = sub_1400089B4((__int64)&v7, (unsigned __int8 *)v8, v4);
  return sub_14001361C(v2, v5);
}
// 14000EF40: using guessed type __int64 __fastcall sub_14000EF40(_QWORD, _QWORD);

//----- (0000000140013FFC) ----------------------------------------------------
unsigned __int64 __fastcall sub_140013FFC(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax

  v1 = a1;
  v2 = sub_140014088();
  return ((signed __int64)((unsigned __int128)((v2 - *(_QWORD *)(v1 + 24)) * (signed __int128)7378697629483820647i64) >> 64) >> 2)
       + ((unsigned __int64)((unsigned __int128)((v2 - *(_QWORD *)(v1 + 24)) * (signed __int128)7378697629483820647i64) >> 64) >> 63);
}
// 140014088: using guessed type __int64 sub_140014088(void);

//----- (0000000140014034) ----------------------------------------------------
_DWORD *__fastcall sub_140014034(__int64 a1, _DWORD *a2)
{
  _DWORD *v2; // rbx
  int v3; // er8
  int v4; // edx
  __int64 v5; // rax

  v2 = a2;
  if ( *(_DWORD *)(a1 + 20) == 6 )
  {
    v5 = sub_140006988(*(_QWORD *)a1, *(unsigned int *)(a1 + 32));
    v4 = 6;
    v3 = *(unsigned __int8 *)(v5 + 13);
  }
  else
  {
    v3 = 0;
    v4 = 0;
  }
  sub_140013E70(v2, v4, v3);
  return v2;
}

//----- (0000000140014070) ----------------------------------------------------
__int64 __fastcall sub_140014070(__int64 a1)
{
  return (unsigned __int16)sub_140008DF4((unsigned __int8 *)(a1 + 2));
}

//----- (0000000140014090) ----------------------------------------------------
__int64 __fastcall sub_140014090(__int64 a1)
{
  return *(unsigned int *)(a1 + 28);
}

//----- (00000001400140A0) ----------------------------------------------------
signed __int64 sub_1400140A0()
{
  return 48i64;
}

//----- (00000001400140B0) ----------------------------------------------------
__int16 __fastcall sub_1400140B0(unsigned __int16 a1)
{
  return (a1 << 8) | (a1 >> 8);
}

//----- (00000001400140C0) ----------------------------------------------------
__m128i *__fastcall sub_1400140C0(__int64 a1, unsigned int *a2)
{
  __m128i *result; // rax
  __int64 v3; // rbp
  __int64 v4; // rsi
  signed __int64 v5; // rax
  __int64 v6; // rdi
  unsigned __int64 v7; // rbx
  __int64 v8; // rax
  __m128i v9; // xmm0

  result = *(__m128i **)(a1 + 56);
  v3 = (__int64)a2;
  v4 = a1;
  if ( result )
  {
    v5 = sub_1400096C0(a2);
    v6 = *(_QWORD *)(v4 + 56);
    v7 = v5;
    v8 = sub_1400096B8(v3);
    sub_14000FBF8(v6, v8, v7);
    *(_DWORD *)(v3 + 4) = *(_DWORD *)(v4 + 48);
    *(_DWORD *)(v3 + 8) = sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v4 + 48i64));
    *(_QWORD *)(v3 + 12) = sub_14001419C(v4);
    result = (__m128i *)sub_14001E1B0(*(__int64 (**)(void))(*(_QWORD *)v4 + 96i64));
    v9 = *result;
    *(_DWORD *)(v3 + 44) = 0;
    _mm_storeu_si128((__m128i *)(v3 + 28), v9);
  }
  return result;
}

//----- (0000000140014170) ----------------------------------------------------
__int64 __fastcall sub_140014170(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)_InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 12), 0xFFFFFFFF);
  if ( (_DWORD)result == 1 )
  {
    if ( a1 )
      result = sub_14001E1B0(**(__int64 (***)(void))a1);
  }
  return result;
}

//----- (000000014001419C) ----------------------------------------------------
__int64 __fastcall sub_14001419C(__int64 a1)
{
  return *(_QWORD *)(a1 + 24);
}

//----- (00000001400141B0) ----------------------------------------------------
void __fastcall sub_1400141B0(__int64 a1)
{
  *(_BYTE *)(a1 + 32) = 0;
}

//----- (00000001400141B8) ----------------------------------------------------
char __fastcall sub_1400141B8(__int64 a1, char a2)
{
  char result; // al

  result = *(_BYTE *)(a1 + 32);
  *(_BYTE *)(a1 + 32) = a2;
  return result;
}

//----- (00000001400141C0) ----------------------------------------------------
void __fastcall sub_1400141C0(__int64 a1, __int16 a2)
{
  *(_WORD *)(a1 + 34) = a2;
}

//----- (00000001400141C8) ----------------------------------------------------
void __fastcall sub_1400141C8(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 36) = a2;
}

//----- (00000001400141CC) ----------------------------------------------------
_QWORD *__fastcall sub_1400141CC(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  *a1 = a2;
  sub_140017F54(a2);
  return v2;
}
// 140017F54: using guessed type __int64 __fastcall sub_140017F54(_QWORD);

//----- (00000001400141EC) ----------------------------------------------------
_QWORD *__fastcall sub_1400141EC(_QWORD *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // edi
  _QWORD *v4; // rbx
  unsigned int v5; // esi
  _QWORD *result; // rax

  v3 = a3;
  v4 = a1;
  v5 = a2;
  sub_140014290(a1);
  *v4 = &off_14002E420;
  *((_DWORD *)v4 + 2) = 0;
  v4[3] = 0i64;
  v4[4] = 0i64;
  v4[5] = 0i64;
  v4[6] = 0i64;
  sub_140017F14((__int64)(v4 + 7));
  sub_140017F14((__int64)(v4 + 9));
  sub_140002DD4(
    L"CEventBuffer::CEventBuffer: Creating EventBuffer, minimum and maximum sizes:",
    v5,
    v3,
    (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\eventbuffer.cpp",
    41);
  if ( v5 - 32 > 0x3FFE0 || v3 < v5 || v3 > 0x40000 )
  {
    v5 = 0x4000;
    v3 = 0x40000;
  }
  *((_DWORD *)v4 + 3) = v5;
  result = v4;
  *((_DWORD *)v4 + 4) = v3;
  return result;
}
// 140020BE0: using guessed type wchar_t aCeventbufferCe[77];
// 14002E420: using guessed type __int64 (__fastcall *off_14002E420)(__int64);

//----- (0000000140014290) ----------------------------------------------------
_QWORD *__fastcall sub_140014290(_QWORD *a1)
{
  *a1 = &off_14002E408;
  return a1;
}
// 14002E408: using guessed type void *off_14002E408;

//----- (00000001400142A0) ----------------------------------------------------
void __fastcall sub_1400142A0(PKSPIN_LOCK *a1)
{
  KeReleaseSpinLock(*a1, *((_BYTE *)*a1 + 8));
}

//----- (00000001400142B0) ----------------------------------------------------
void **__fastcall sub_1400142B0(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rdx

  v2 = a1;
  *a1 = &off_14002E420;
  if ( a1[3] )
    sub_1400183C4(a1[3]);
  v2[3] = 0i64;
  v2[4] = 0i64;
  v2[5] = 0i64;
  v2[6] = 0i64;
  nullsub_1(v2 + 9, a2);
  nullsub_1(v2 + 7, v3);
  return sub_140014314(v2);
}
// 140004C90: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);
// 14002E420: using guessed type __int64 (__fastcall *off_14002E420)(__int64);

//----- (0000000140014314) ----------------------------------------------------
void **__fastcall sub_140014314(_QWORD *a1)
{
  void **result; // rax

  result = &off_14002E408;
  *a1 = &off_14002E408;
  return result;
}
// 14002E408: using guessed type void *off_14002E408;

//----- (0000000140014320) ----------------------------------------------------
_QWORD *__fastcall sub_140014320(_QWORD *a1, __int64 a2)
{
  char v2; // di
  _QWORD *v3; // rbx

  v2 = a2;
  v3 = a1;
  sub_1400142B0(a1, a2);
  if ( v2 & 1 && v2 & 4 )
    nullsub_1(v3, 88i64);
  return v3;
}
// 140004C90: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);

//----- (000000014001435C) ----------------------------------------------------
signed __int64 __fastcall sub_14001435C(__int64 a1, unsigned __int64 a2)
{
  unsigned int v2; // ebx
  unsigned __int64 v3; // r8
  _QWORD v5[3]; // [rsp+20h] [rbp-18h]

  v2 = 0;
  if ( !*(_QWORD *)(a1 + 24) || a2 >= *(unsigned int *)(a1 + 12) )
    return 0i64;
  v3 = *(_QWORD *)(a1 + 48) - *(_QWORD *)(a1 + 40);
  if ( (signed __int64)v3 <= 0 )
    v3 += *(unsigned int *)(a1 + 8);
  if ( a2 < v3 )
    return 1i64;
  if ( *(_DWORD *)(a1 + 8) >= *(_DWORD *)(a1 + 16) )
  {
    if ( !_InterlockedCompareExchange(&dword_140034DC0, 1, 0) )
    {
      if ( byte_140034440 & 8 )
      {
        LODWORD(v5[0]) = 294;
        sub_140014A78(&unk_140030040, (__int64)&unk_140029E60, 0i64, -1073741823, v5[0]);
      }
    }
    return 0i64;
  }
  LOBYTE(v2) = (unsigned int)sub_14001445C(a1) != 0;
  return v2;
}
// 140034440: using guessed type char byte_140034440;
// 140034DC0: using guessed type int dword_140034DC0;

//----- (00000001400143F4) ----------------------------------------------------
void __fastcall sub_1400143F4(__int64 *a1)
{
  __int64 *v1; // rbx
  __int64 v2; // rax
  PKSPIN_LOCK v3; // [rsp+30h] [rbp+8h]
  char v4; // [rsp+38h] [rbp+10h]

  v1 = a1;
  sub_1400141CC(&v4, (__int64)(a1 + 9));
  sub_1400141CC(&v3, (__int64)(v1 + 7));
  if ( v1[3] )
  {
    sub_1400183C4(v1[3]);
    v1[3] = 0i64;
    v2 = v1[3];
    v1[6] = v2;
    v1[5] = v2;
  }
  sub_1400142A0(&v3);
  sub_1400142A0((PKSPIN_LOCK *)&v4);
}

//----- (000000014001445C) ----------------------------------------------------
__int64 __fastcall sub_14001445C(__int64 a1)
{
  __int64 v1; // rdi
  __m128 *v2; // rsi
  __int64 result; // rax
  unsigned int v4; // ebx
  unsigned __int64 v5; // rbx
  char *v6; // rax
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // r14
  unsigned __int64 v9; // rax
  __int64 v10; // rcx
  PKSPIN_LOCK v11; // [rsp+40h] [rbp+8h]

  v1 = a1;
  v2 = sub_1400181F8((unsigned int)(2 * *(_DWORD *)(a1 + 8)), (__int64)&unk_140030120);
  if ( v2 )
  {
    sub_1400141CC(&v11, v1 + 56);
    if ( *(_QWORD *)(v1 + 48) == *(_QWORD *)(v1 + 40) )
    {
      *(_QWORD *)(v1 + 40) = v2;
      v4 = 1;
    }
    else
    {
      if ( *(_QWORD *)(v1 + 48) >= *(_QWORD *)(v1 + 40) )
      {
        v7 = *(_QWORD *)(v1 + 32) - *(_QWORD *)(v1 + 48);
        if ( *(_QWORD *)(v1 + 32) != *(_QWORD *)(v1 + 48) )
          sub_14001E2C0((__m128i *)v2, *(_QWORD *)(v1 + 48), v7);
        v8 = *(_QWORD *)(v1 + 40) - *(_QWORD *)(v1 + 24);
        if ( *(_QWORD *)(v1 + 40) != *(_QWORD *)(v1 + 24) )
          sub_14001E2C0((__m128i *)((char *)v2 + v7), *(_QWORD *)(v1 + 24), v8);
        v9 = v8 + v7;
        v4 = 3;
        v6 = (char *)v2 + v9;
      }
      else
      {
        v5 = *(_QWORD *)(v1 + 40) - *(_QWORD *)(v1 + 48);
        sub_14001E2C0((__m128i *)v2, *(_QWORD *)(v1 + 48), v5);
        v6 = (char *)v2 + v5;
        v4 = 2;
      }
      *(_QWORD *)(v1 + 40) = v6;
    }
    *(_QWORD *)(v1 + 48) = v2;
    sub_1400183C4(*(_QWORD *)(v1 + 24));
    *(_DWORD *)(v1 + 8) *= 2;
    v10 = *(unsigned int *)(v1 + 8);
    *(_QWORD *)(v1 + 24) = 0i64;
    *(_QWORD *)(v1 + 24) = v2;
    *(_QWORD *)(v1 + 32) = (char *)v2 + v10;
    sub_1400142A0(&v11);
    result = v4;
  }
  else
  {
    sub_140002E58(
      L"CEventBuffer::ExpandBuffer: Unable to allocate memory for expanded buffer, insufficient memory",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\eventbuffer.cpp",
      194);
    result = 0i64;
  }
  return result;
}
// 140020D10: using guessed type wchar_t aCeventbufferEx[95];

//----- (00000001400145A0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400145A0(__int64 a1, __m128i *a2, unsigned __int64 a3)
{
  __m128i *v3; // rbp
  __int64 v4; // rbx
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // rdi
  __int64 v9; // rax

  v3 = a2;
  v4 = a1;
  v5 = *(_QWORD *)(a1 + 48);
  v6 = *(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 48);
  v7 = a3;
  if ( a3 > v6 )
  {
    sub_14001E2C0(v3, v5, v6);
    v7 -= v6;
    sub_14001E2C0((__m128i *)((char *)v3 + v6), *(_QWORD *)(v4 + 24), v7);
    v9 = *(_QWORD *)(v4 + 24);
  }
  else
  {
    sub_14001E2C0(v3, v5, a3);
    if ( v7 == v6 )
      return *(_QWORD *)(v4 + 24);
    v9 = *(_QWORD *)(v4 + 48);
  }
  return v7 + v9;
}

//----- (0000000140014630) ----------------------------------------------------
__int64 __fastcall sub_140014630(__int64 a1, __m128i *a2, unsigned __int64 a3, int a4)
{
  __m128i *v4; // r12
  __int64 v5; // rbx
  int v6; // er15
  unsigned __int64 v7; // rsi
  unsigned int v8; // ebp
  __int64 v9; // rdi
  PKSPIN_LOCK v11; // [rsp+30h] [rbp-58h]
  unsigned __int16 v12; // [rsp+38h] [rbp-50h]

  v4 = a2;
  v5 = a1;
  v6 = a4;
  v7 = a3;
  v8 = 0;
  sub_1400141CC(&v11, a1 + 56);
  if ( v6 )
  {
    while ( *(_QWORD *)(v5 + 40) != *(_QWORD *)(v5 + 48) )
    {
      sub_1400145A0(v5, (__m128i *)&v12, 2ui64);
      v9 = v12;
      if ( v12 > v7 )
      {
        sub_140002DD4(
          L"CEventBuffer::GetMessage: Cannot retrieve message, message too big for provided buffer, message size; output buffer size:",
          v12,
          v7,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\eventbuffer.cpp",
          494);
        break;
      }
      *(_QWORD *)(v5 + 48) = sub_1400145A0(v5, v4, v12);
      v4 = (__m128i *)((char *)v4 + v9);
      v7 -= v9;
      v8 += (unsigned __int16)v9;
      if ( !--v6 )
        break;
    }
  }
  sub_1400142A0(&v11);
  return v8;
}
// 140020F20: using guessed type wchar_t aCeventbufferGe[122];

//----- (000000014001470C) ----------------------------------------------------
signed __int64 __fastcall sub_14001470C(__int64 a1)
{
  __int64 v1; // rbx
  signed __int64 result; // rax
  __int64 v3; // rax

  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12);
  v1 = a1;
  dword_140034DC0 = 0;
  *(_QWORD *)(a1 + 24) = sub_1400181F8(*(unsigned int *)(a1 + 12), (__int64)&unk_140030130);
  if ( *(_QWORD *)(v1 + 24) )
  {
    *(_QWORD *)(v1 + 32) = *(unsigned int *)(v1 + 12) + *(_QWORD *)(v1 + 24);
    v3 = *(_QWORD *)(v1 + 24);
    *(_QWORD *)(v1 + 48) = v3;
    *(_QWORD *)(v1 + 40) = v3;
    result = 0i64;
  }
  else
  {
    sub_140002E58(
      L"CEventBuffer::Init: Unable to allocate buffer, insufficient memory",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\eventbuffer.cpp",
      77);
    *(_DWORD *)(v1 + 8) = 0;
    result = 3221225626i64;
  }
  return result;
}
// 140020C80: using guessed type wchar_t aCeventbufferIn[67];
// 140034DC0: using guessed type int dword_140034DC0;

//----- (000000014001478C) ----------------------------------------------------
__int64 sub_14001478C(__int64 a1, _QWORD *a2, unsigned __int64 a3, ...)
{
  __int64 result; // rax
  va_list va; // [rsp+48h] [rbp+20h]

  va_start(va, a3);
  if ( a2 && a3 )
    result = sub_14001489C(a1, a2, a3, (__int64)va);
  else
    result = 0i64;
  return result;
}

//----- (00000001400147C0) ----------------------------------------------------
__int64 __fastcall sub_1400147C0(__int64 a1, _QWORD *a2, unsigned __int64 a3)
{
  return sub_14001478C(a1, a2, a3);
}

//----- (00000001400147E0) ----------------------------------------------------
__int64 __fastcall sub_1400147E0(__int64 a1, _QWORD *a2, unsigned __int64 a3)
{
  _QWORD *v3; // r14
  __int64 v4; // rsi
  unsigned __int64 v5; // rdi
  unsigned int v6; // ebx
  const wchar_t *v7; // rcx
  int v8; // eax
  PKSPIN_LOCK v10; // [rsp+40h] [rbp+8h]

  v3 = a2;
  v4 = a1;
  v5 = a3;
  sub_1400141CC(&v10, a1 + 72);
  v6 = 0;
  if ( !v3 || !v5 )
  {
    v7 = L"CEventBuffer::PutSimple: Unable to add message to EventBuffer, nothing to add";
    v8 = 321;
    goto LABEL_7;
  }
  if ( !(unsigned int)sub_14001435C(v4, v5) )
  {
    v7 = L"CEventBuffer::PutSimple: Unable to add message to EventBuffer, not enough free space";
    v8 = 331;
LABEL_7:
    sub_140002E58(v7, 0, 0, (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\eventbuffer.cpp", v8);
    goto LABEL_8;
  }
  *v3 = (unsigned __int16)v5;
  *(_QWORD *)(v4 + 40) = sub_1400149E8(v4, *(__m128i **)(v4 + 40), (unsigned __int64)v3, v5);
  v6 = 1;
LABEL_8:
  sub_1400142A0(&v10);
  return v6;
}
// 140020DD0: using guessed type wchar_t aCeventbufferPu_0[78];
// 140020E70: using guessed type wchar_t aCeventbufferPu[85];

//----- (000000014001489C) ----------------------------------------------------
__int64 __fastcall sub_14001489C(__int64 a1, _QWORD *a2, unsigned __int64 a3, __int64 a4)
{
  unsigned int v4; // ebx
  unsigned __int64 v5; // rbp
  _QWORD *v6; // r15
  __int64 v7; // rsi
  unsigned int *v9; // rdi
  __int64 v10; // r14
  unsigned int *i; // rcx
  unsigned __int64 v12; // r9
  unsigned __int64 v13; // r8
  __m128i *v14; // rdx
  unsigned __int64 v15; // rax
  char v16; // [rsp+58h] [rbp+20h]

  v4 = 0;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !a4 )
    return sub_1400147E0(a1, a2, a3);
  if ( !a2 || !a3 )
    return 0i64;
  v9 = (unsigned int *)(a4 - 8);
  v10 = 0i64;
  for ( i = (unsigned int *)(a4 - 8); *((_QWORD *)i + 1); v10 += *i )
    i += 4;
  sub_1400141CC(&v16, v7 + 72);
  if ( (unsigned int)sub_14001435C(v7, v10 + v5) )
  {
    v12 = v5;
    v13 = (unsigned __int64)v6;
    *v6 = (unsigned __int16)v10 + (unsigned __int64)(unsigned __int16)v5;
    v14 = *(__m128i **)(v7 + 40);
LABEL_10:
    v15 = sub_1400149E8(v7, v14, v13, v12);
    while ( 1 )
    {
      v13 = *((_QWORD *)v9 + 1);
      if ( !v13 )
        break;
      v9 += 4;
      v12 = *v9;
      if ( *v9 )
      {
        v14 = (__m128i *)v15;
        goto LABEL_10;
      }
    }
    *(_QWORD *)(v7 + 40) = v15;
    v4 = 1;
  }
  sub_1400142A0((PKSPIN_LOCK *)&v16);
  return v4;
}

//----- (0000000140014990) ----------------------------------------------------
void __fastcall sub_140014990(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rax
  PKSPIN_LOCK v3; // [rsp+30h] [rbp+8h]
  char v4; // [rsp+38h] [rbp+10h]

  v1 = a1;
  sub_1400141CC(&v4, (__int64)(a1 + 9));
  sub_1400141CC(&v3, (__int64)(v1 + 7));
  v2 = v1[3];
  v1[6] = v2;
  v1[5] = v2;
  sub_1400142A0(&v3);
  sub_1400142A0((PKSPIN_LOCK *)&v4);
}

//----- (00000001400149DC) ----------------------------------------------------
__int64 sub_1400149DC()
{
  return (unsigned int)_InterlockedExchange(&dword_140034DC0, 0);
}
// 140034DC0: using guessed type int dword_140034DC0;

//----- (00000001400149E8) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400149E8(__int64 a1, __m128i *a2, unsigned __int64 a3, unsigned __int64 a4)
{
  __m128i *v4; // rsi
  unsigned __int64 v5; // rdi
  __int64 v6; // rbp
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // r14
  unsigned __int64 result; // rax
  unsigned __int64 v10; // rbx

  v4 = a2;
  v5 = *(_QWORD *)(a1 + 32) - (_QWORD)a2;
  v6 = a1;
  v7 = a4;
  v8 = a3;
  if ( a4 > v5 )
  {
    sub_14001E2C0(a2, a3, v5);
    v10 = v7 - v5;
    sub_14001E2C0(*(__m128i **)(v6 + 24), v5 + v8, v10);
    result = v10 + *(_QWORD *)(v6 + 24);
  }
  else
  {
    sub_14001E2C0(a2, a3, a4);
    if ( v7 == v5 )
      result = *(_QWORD *)(v6 + 24);
    else
      result = (unsigned __int64)v4->m128i_u64 + v7;
  }
  return result;
}

//----- (0000000140014A78) ----------------------------------------------------
__int64 sub_140014A78(_QWORD *a1, __int64 a2, __int64 a3, int a4, ...)
{
  __int64 v4; // rsi
  __int64 v5; // rdi
  _QWORD *v6; // rbx
  char v8; // [rsp+30h] [rbp-58h]
  __int64 v9; // [rsp+40h] [rbp-48h]
  char v10; // [rsp+50h] [rbp-38h]
  int v11; // [rsp+A8h] [rbp+20h]
  va_list va; // [rsp+B0h] [rbp+28h]

  va_start(va, a4);
  v11 = a4;
  v4 = a3;
  v5 = a2;
  v6 = a1;
  sub_140002DA8((__int64)&v9, (__int64)&v11, 4);
  sub_140002DA8((__int64)&v10, (__int64)va, 4);
  return sub_140002FE0(v6, v5, v4, 3, (__int64)&v8);
}

//----- (0000000140014B00) ----------------------------------------------------
_QWORD *__fastcall sub_140014B00(_QWORD *a1)
{
  return sub_1400141EC(a1, 0x4000u, 0x40000u);
}

//----- (0000000140014B10) ----------------------------------------------------
char __fastcall sub_140014B10(signed int *a1, signed int a2)
{
  char result; // al

  if ( a2 >= 3 )
  {
    if ( a1 )
      *a1 = 0;
    result = 0;
  }
  else
  {
    if ( a1 )
      *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (0000000140014B2C) ----------------------------------------------------
void __fastcall sub_140014B2C(signed int a1)
{
  int v1; // [rsp+38h] [rbp+10h]

  v1 = 0;
  if ( sub_140014B10(&v1, a1) )
    sub_1400143F4(&qword_140034E80[11 * v1]);
}

//----- (0000000140014B64) ----------------------------------------------------
__int64 __fastcall sub_140014B64(signed int a1, __m128i *a2, unsigned __int64 a3, int a4)
{
  __m128i *v4; // rsi
  int v5; // ebx
  unsigned __int64 v6; // rdi
  __int64 result; // rax
  int v8; // [rsp+20h] [rbp-18h]

  v8 = 0;
  v4 = a2;
  v5 = a4;
  v6 = a3;
  if ( sub_140014B10(&v8, a1) )
    result = sub_140014630((__int64)&qword_140034E80[11 * v8], v4, v6, v5);
  else
    result = 0i64;
  return result;
}

//----- (0000000140014BC8) ----------------------------------------------------
signed __int64 __fastcall sub_140014BC8(signed int a1)
{
  signed __int64 result; // rax
  int v2; // [rsp+38h] [rbp+10h]

  v2 = 0;
  if ( sub_140014B10(&v2, a1) )
    result = sub_14001470C((__int64)&qword_140034E80[11 * v2]);
  else
    result = 0i64;
  return result;
}

//----- (0000000140014C04) ----------------------------------------------------
__int64 __fastcall sub_140014C04(signed int a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, __int64 a11)
{
  _QWORD *v11; // rdi
  __int64 v12; // rbx
  __int64 v13; // rsi
  signed __int64 v15; // rdx
  unsigned __int64 v16; // r8
  int v17; // [rsp+60h] [rbp-28h]

  v17 = 0;
  v11 = a2;
  v12 = a4;
  v13 = a3;
  if ( !sub_140014B10(&v17, a1) )
    return 0i64;
  v15 = v13 & -(signed __int64)(v11 != 0i64);
  v16 = (a11 & -(signed __int64)(a10 != 0))
      + (a9 & -(signed __int64)(a8 != 0))
      + (a7 & -(signed __int64)(a6 != 0))
      + v15
      + (a5 & -(signed __int64)(v12 != 0));
  if ( v16 > 0x1000 )
  {
    sub_140002E58(
      L"PutComplex: Attempted to log a message greater than the size of the driver/service communication buffer",
      0,
      v16,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\eventbufferforioctl.cpp",
      71);
    return 0i64;
  }
  return sub_14001478C(
           (__int64)&qword_140034E80[11 * v17],
           v11,
           v15,
           v12,
           a5 & -(signed __int64)(v12 != 0),
           a6,
           a7 & -(signed __int64)(a6 != 0),
           a8,
           a9 & -(signed __int64)(a8 != 0),
           a10,
           a11 & -(signed __int64)(a10 != 0),
           0i64);
}
// 140021070: using guessed type wchar_t aPutcomplexAtte[104];

//----- (0000000140014D44) ----------------------------------------------------
void __fastcall sub_140014D44(signed int a1)
{
  int v1; // [rsp+38h] [rbp+10h]

  v1 = 0;
  if ( sub_140014B10(&v1, a1) )
    sub_140014990(&qword_140034E80[11 * v1]);
}

//----- (0000000140014D7C) ----------------------------------------------------
char __fastcall sub_140014D7C(signed int a1)
{
  char result; // al
  int v2; // [rsp+38h] [rbp+10h]

  v2 = 0;
  result = sub_140014B10(&v2, a1);
  if ( result )
    result = sub_1400149DC();
  return result;
}

//----- (0000000140014DB4) ----------------------------------------------------
_QWORD *__fastcall sub_140014DB4(_QWORD *a1)
{
  a1[1] = 0i64;
  a1[2] = 0i64;
  *a1 = &off_14002E440;
  return a1;
}
// 14002E440: using guessed type void *off_14002E440;

//----- (0000000140014DCC) ----------------------------------------------------
_QWORD *__fastcall sub_140014DCC(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140014DB4(a1);
  v3[2] = v2;
  *v3 = off_14002E448;
  return v3;
}
// 14002E448: using guessed type __int64 (__fastcall *off_14002E448[2])();

//----- (0000000140014E00) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_140014E00(_QWORD *a1))()
{
  __int64 (__fastcall **result)(); // rax

  result = off_14002E448;
  *a1 = off_14002E448;
  return result;
}
// 14002E448: using guessed type __int64 (__fastcall *off_14002E448[2])();

//----- (0000000140014E10) ----------------------------------------------------
void *__fastcall sub_140014E10(_QWORD *a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_140014E00(a1);
  if ( v2 & 1 )
    sub_140007714(v3);
  return v3;
}

//----- (0000000140014E44) ----------------------------------------------------
__int64 __fastcall sub_140014E44(PCUNICODE_STRING SourceString, PCUNICODE_STRING Source, PUNICODE_STRING DestinationString)
{
  const UNICODE_STRING *v3; // rbx
  const UNICODE_STRING *v4; // rdi
  UNICODE_STRING *v5; // rsi
  SIZE_T v6; // rdx
  NTSTATUS v8; // ebx
  UNICODE_STRING DestinationStringa; // [rsp+20h] [rbp-38h]

  v3 = SourceString;
  *(_QWORD *)&DestinationStringa.Length = 0i64;
  v4 = Source;
  DestinationStringa.Buffer = 0i64;
  v5 = DestinationString;
  v6 = (unsigned __int16)(SourceString->Length + 2 + Source->Length);
  DestinationStringa.MaximumLength = v6;
  DestinationStringa.Buffer = (PWSTR)ExAllocatePoolWithTag((POOL_TYPE)512, v6, 0x53554349u);
  if ( !DestinationStringa.Buffer )
    return 3221225473i64;
  RtlCopyUnicodeString(&DestinationStringa, v3);
  v8 = RtlAppendUnicodeStringToString(&DestinationStringa, v4);
  if ( v8 >= 0 )
  {
    DestinationStringa.Buffer[((unsigned __int64)DestinationStringa.MaximumLength >> 1) - 1] = 0;
    v8 = sub_140003DA4(v5, &DestinationStringa);
  }
  ExFreePoolWithTag(DestinationStringa.Buffer, 0);
  return (unsigned int)v8;
}

//----- (0000000140014F1C) ----------------------------------------------------
__int64 __fastcall sub_140014F1C(__int64 (***a1)(void), UNICODE_STRING *a2)
{
  UNICODE_STRING *v2; // rdi
  __int64 (***v3)(void); // rbx
  __int64 result; // rax
  NTSTATUS v5; // ebx
  PWSTR v6; // rcx
  UNICODE_STRING SourceString; // [rsp+28h] [rbp-28h]
  UNICODE_STRING DestinationString; // [rsp+38h] [rbp-18h]

  v2 = a2;
  v3 = a1;
  *(_QWORD *)&DestinationString.Length = 0i64;
  DestinationString.Buffer = 0i64;
  RtlInitUnicodeString(&DestinationString, L"\\System32");
  result = sub_14001E1B0(**v3);
  if ( (signed int)result >= 0 )
  {
    v5 = RtlAppendUnicodeStringToString(0i64, &DestinationString);
    if ( v5 >= 0 )
    {
      *(_QWORD *)&SourceString.Length = 0i64;
      *(_DWORD *)&SourceString.MaximumLength = MEMORY[2];
      SourceString.Buffer = (PWSTR)ExAllocatePoolWithTag((POOL_TYPE)512, MEMORY[2], 0x53554349u);
      if ( SourceString.Buffer )
      {
        v5 = RtlDowncaseUnicodeString(&SourceString, 0i64, 0i64);
        if ( v5 >= 0 )
          v5 = sub_140003DA4(v2, &SourceString);
        ExFreePoolWithTag(MEMORY[8], 0);
        v6 = SourceString.Buffer;
        goto LABEL_9;
      }
      v5 = -1073741823;
    }
    v6 = (PWSTR)MEMORY[8];
LABEL_9:
    ExFreePoolWithTag(v6, 0);
    result = (unsigned int)v5;
  }
  return result;
}
// 140029398: using guessed type __int64 __fastcall RtlDowncaseUnicodeString(_QWORD, _QWORD, _QWORD);

//----- (0000000140015040) ----------------------------------------------------
__int64 __fastcall sub_140015040(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rdi
  __int64 v3; // rbx
  __int64 result; // rax

  *a2 = *(_QWORD *)(a1 + 16);
  v2 = a2;
  v3 = a1;
  result = std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::_Getint(*(PUNICODE_STRING *)(a1 + 16));
  if ( (signed int)result >= 0 )
    *v2 = *(_QWORD *)(v3 + 16);
  return result;
}

//----- (00000001400150A8) ----------------------------------------------------
NTSTATUS __fastcall sub_1400150A8(HANDLE LinkHandle, PUNICODE_STRING LinkTarget, __int16 a3)
{
  __int16 v3; // si
  PUNICODE_STRING v4; // rbx
  HANDLE v5; // rdi
  NTSTATUS result; // eax
  SIZE_T v7; // rdx
  WCHAR *v8; // rax
  NTSTATUS v9; // edi
  ULONG ReturnedLength; // [rsp+20h] [rbp-28h]

  v3 = a3;
  ReturnedLength = 0;
  *(_DWORD *)&LinkTarget->Length = 0;
  v4 = LinkTarget;
  LinkTarget->Buffer = 0i64;
  v5 = LinkHandle;
  result = ZwQuerySymbolicLinkObject(LinkHandle, LinkTarget, &ReturnedLength);
  if ( result == -1073741789 && ReturnedLength )
  {
    v7 = (unsigned __int16)(v3 + ReturnedLength);
    v4->MaximumLength = v7;
    v8 = (WCHAR *)ExAllocatePoolWithTag((POOL_TYPE)512, v7, 0x53554349u);
    v4->Buffer = v8;
    if ( !v8 )
    {
      v9 = -1073741823;
LABEL_7:
      *(_DWORD *)&v4->Length = 0;
      return v9;
    }
    v9 = ZwQuerySymbolicLinkObject(v5, v4, &ReturnedLength);
    if ( v9 < 0 )
    {
      ExFreePoolWithTag(v4->Buffer, 0);
      v4->Buffer = 0i64;
      goto LABEL_7;
    }
    result = 0;
  }
  else if ( !result )
  {
    result = -1073741823;
  }
  return result;
}

//----- (00000001400154CC) ----------------------------------------------------
__int64 __fastcall sub_1400154CC(__int64 a1)
{
  return *(_QWORD *)(a1 - 48);
}

//----- (00000001400154D4) ----------------------------------------------------
NTSTATUS sub_1400154D4()
{
  return sub_140018F0C((__int64)&unk_140034F98);
}

//----- (00000001400154E0) ----------------------------------------------------
__int64 __fastcall sub_1400154E0(__int64 a1)
{
  return sub_140019278(&unk_140034F98, a1);
}

//----- (00000001400154F0) ----------------------------------------------------
void __fastcall sub_1400154F0(__int64 a1, __int64 a2, __int64 a3)
{
  *(_QWORD *)(a1 - 40) = a2;
  *(_QWORD *)(a1 - 32) = a3;
}

//----- (00000001400154FC) ----------------------------------------------------
char __fastcall sub_1400154FC(__int8 a1, __int64 a2, __int64 a3, unsigned __int64 a4, unsigned __int32 a5, __int64 a6, __int64 a7)
{
  unsigned __int32 v7; // er14
  unsigned __int64 v8; // r13
  __int64 v9; // rbp
  bool v10; // r12
  unsigned __int64 v11; // rsi
  unsigned int v12; // eax
  unsigned __int64 v13; // r15
  signed __int64 v14; // rbx
  __int64 v15; // r8
  int v16; // eax
  const wchar_t *v17; // rcx
  __m128 *v18; // rax
  __m128i *v19; // rdi
  __int64 v21; // rbx
  __int8 v22; // [rsp+80h] [rbp+8h]
  __int64 v23; // [rsp+88h] [rbp+10h]
  __int64 v24; // [rsp+90h] [rbp+18h]

  v24 = a3;
  v23 = a2;
  v22 = a1;
  v7 = a5;
  v8 = a4;
  v9 = a5;
  v10 = 0;
  v11 = a5 + 264i64;
  v12 = sub_1400171AC();
  v13 = v12;
  if ( v11 > v12 )
  {
    v14 = v12 - 264i64;
    if ( v12 == 264i64 )
    {
      v9 = 264i64;
      v15 = 264i64;
    }
    else
    {
      v15 = v12 - 264i64;
    }
    v16 = 76;
    if ( v13 == 264 )
      v16 = 82;
    v17 = L"httpDataCache::storeHTTPInformation: Process path too long, will be truncated. Path length (original; truncated):";
    if ( !v14 )
      v17 = L"httpDataCache::storeHTTPInformation: Packet size (including header) is greater than maximum buffer size, pro"
             "cess path will not be stored and packet itself may not fit. (packet size; buffer size):";
    sub_140002DD4(
      v17,
      v9,
      v15,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\httpdatacache.cpp",
      v16);
    v7 = v13 - 264;
    v11 = v13;
    v10 = v13 != 264;
    if ( v13 == 264 )
      v7 = 0;
  }
  v18 = sub_1400181F8(v11, (__int64)&unk_140030170);
  v19 = (__m128i *)v18;
  if ( !v18 )
  {
    sub_140002E58(
      L"httpDataCache::storeHTTPInformation: Failed to allocate memory, bufferSize",
      0,
      v11,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\httpdatacache.cpp",
      95);
    return 0;
  }
  v21 = MEMORY[0xFFFFF78000000014];
  sub_14001E1C0(v18, 0, v11);
  v19[9].m128i_i64[1] = 0i64;
  v19->m128i_i64[0] = a6;
  v19->m128i_i64[1] = a7;
  v19[13].m128i_i64[1] = a7;
  v19[7].m128i_i8[6] = v22;
  v19[7].m128i_i64[1] = v23;
  v19[1].m128i_i64[1] = 0i64;
  v19[2].m128i_i64[0] = 0i64;
  v19[2].m128i_i64[1] = 0i64;
  v19[15].m128i_i32[0] = 0;
  v19[4].m128i_i32[2] = 0;
  _mm_storeu_si128(v19 + 8, 0);
  v19[7].m128i_i8[7] = v10;
  v19[9].m128i_i64[0] = v21;
  v19[10].m128i_i16[6] = 0;
  v19[11].m128i_i64[0] = 0i64;
  v19[11].m128i_i32[3] = v7;
  sub_14001E2C0(v19 + 16, v8, v7);
  v19[14].m128i_i64[1] = v24;
  v19[11].m128i_i32[2] = 184;
  v19[14].m128i_i64[0] = 0i64;
  if ( !sub_1400185F8((__int64)&unk_140034F98, (__int64)v19) )
  {
    sub_140002DD4(
      L"httpDataCache::storeHTTPInformation: Failed to add entry to cache",
      0i64,
      0i64,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\httpdatacache.cpp",
      142);
    sub_1400183C4((__int64)v19);
    return 0;
  }
  return 1;
}
// 1400211B0: using guessed type wchar_t aHttpdatacacheS_0[114];
// 1400212A0: using guessed type wchar_t aHttpdatacacheS[196];
// 140021430: using guessed type wchar_t aHttpdatacacheS_1[75];
// 1400214D0: using guessed type wchar_t aHttpdatacacheS_2[66];

//----- (0000000140015718) ----------------------------------------------------
__int64 __fastcall sub_140015718(__int64 a1, PVOID *a2)
{
  PVOID *v2; // rsi
  __int64 v3; // rbx
  unsigned int v4; // ebx
  int v5; // eax
  int v6; // eax
  PVOID *Object; // [rsp+20h] [rbp-29h]
  HANDLE v9; // [rsp+40h] [rbp-9h]
  HANDLE Handle; // [rsp+48h] [rbp-1h]
  int v11; // [rsp+50h] [rbp+7h]
  __int64 v12; // [rsp+58h] [rbp+Fh]
  __int64 v13; // [rsp+60h] [rbp+17h]
  int v14; // [rsp+68h] [rbp+1Fh]
  __int64 v15; // [rsp+70h] [rbp+27h]
  __int64 *v16; // [rsp+78h] [rbp+2Fh]
  __int64 v17; // [rsp+80h] [rbp+37h]
  int v18; // [rsp+88h] [rbp+3Fh]

  v9 = 0i64;
  v2 = a2;
  Handle = 0i64;
  v3 = a1;
  sub_14001E1C0((__m128 *)&v11, 0, 0x30ui64);
  v17 = 0i64;
  v18 = 0;
  if ( v3 )
  {
    v4 = ObOpenObjectByPointer(v3, 512i64, 0i64, 0i64, 0i64, 0, &v9);
    if ( (v4 & 0x80000000) != 0 )
    {
      sub_140002E58(
        L"Impersonation::CreateImpersonationToken: Open Object by Token failed",
        v4,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\impersonation.cpp",
        26);
      return v4;
    }
  }
  else if ( (signed int)ZwOpenThreadTokenEx(-2i64, 2i64, 0i64, 512i64, &v9) < 0 )
  {
    v4 = ZwOpenProcessTokenEx(-1i64, 2i64, 512i64, &v9);
    if ( (v4 & 0x80000000) != 0 )
    {
      sub_140002E58(
        L"Impersonation::CreateImpersonationToken: Open Object by thread/process failed",
        v4,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\impersonation.cpp",
        44);
      return v4;
    }
  }
  LOWORD(v18) = 0;
  v12 = 0i64;
  v13 = 0i64;
  v15 = 0i64;
  v16 = &v17;
  LODWORD(Object) = 2;
  v17 = 8589934604i64;
  v11 = 48;
  v14 = 512;
  v5 = ZwDuplicateToken(v9, 983551i64, &v11, 0i64, Object, &Handle);
  v4 = v5;
  if ( v5 < 0 )
  {
    sub_140002E58(
      L"Impersonation::CreateImpersonationToken: Duplicate Token failed",
      v5,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\impersonation.cpp",
      78);
  }
  else
  {
    v6 = ObReferenceObjectByHandle(Handle, 0xF01FFu, 0i64, 0, v2, 0i64);
    v4 = v6;
    if ( v6 < 0 )
      sub_140002E58(
        L"Impersonation::CreateImpersonationToken: Reference Object by Handle failed",
        v6,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\impersonation.cpp",
        72);
    ZwClose(Handle);
  }
  ZwClose(v9);
  return v4;
}
// 1400216C0: using guessed type wchar_t aImpersonationC_0[69];
// 140021750: using guessed type wchar_t aImpersonationC_1[78];
// 1400217F0: using guessed type wchar_t aImpersonationC[75];
// 140021890: using guessed type wchar_t aImpersonationC_2[64];
// 1400293A8: using guessed type __int64 __fastcall ObOpenObjectByPointer(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400293B0: using guessed type __int64 __fastcall ZwOpenProcessTokenEx(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400293B8: using guessed type __int64 __fastcall ZwOpenThreadTokenEx(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400293C0: using guessed type __int64 __fastcall ZwDuplicateToken(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140015910) ----------------------------------------------------
signed __int64 __fastcall sub_140015910(__int64 a1)
{
  signed __int64 result; // rax
  char v2; // ST28_1
  int v3; // eax
  unsigned int v4; // ebx
  int v5; // eax
  HANDLE Handle; // [rsp+40h] [rbp-18h]

  Handle = 0i64;
  if ( a1 )
  {
    v2 = 0;
    v3 = ObOpenObjectByPointer(a1, 512i64, 0i64, 0i64, 0i64, v2, &Handle);
    v4 = v3;
    if ( v3 >= 0 )
    {
      v5 = ZwSetInformationThread(-2i64, 5i64, &Handle);
      v4 = v5;
      if ( v5 < 0 )
        sub_140002E58(
          L"Impersonation::ImpersonateClient: SetInformationThread failed",
          v5,
          0,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\impersonation.cpp",
          110);
      ZwClose(Handle);
    }
    else
    {
      sub_140002E58(
        L"Impersonation::ImpersonateClient: Open Object by Pointer failed",
        v3,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\impersonation.cpp",
        101);
    }
    result = v4;
  }
  else
  {
    sub_140002E58(
      L"Impersonation::ImpersonateClient: ImpersonateClient called with no Token",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\impersonation.cpp",
      94);
    result = 3221225473i64;
  }
  return result;
}
// 140021910: using guessed type wchar_t aImpersonationI[73];
// 1400219B0: using guessed type wchar_t aImpersonationI_1[64];
// 140021A30: using guessed type wchar_t aImpersonationI_0[62];
// 1400293A0: using guessed type __int64 __fastcall ZwSetInformationThread(_QWORD, _QWORD, _QWORD);
// 1400293A8: using guessed type __int64 __fastcall ObOpenObjectByPointer(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140015A08) ----------------------------------------------------
__int64 __fastcall sub_140015A08(__int64 a1)
{
  __int64 v1; // rdi
  int v2; // eax
  unsigned int v3; // ebx
  __int64 v4; // rcx
  __int64 v5; // r8
  int v6; // ST30_4
  __int16 v7; // ST28_2
  int v8; // eax
  __int64 v10; // [rsp+38h] [rbp-1h]
  void (__fastcall *v11)(_QWORD *, __int64); // [rsp+40h] [rbp+7h]
  __int64 v12; // [rsp+48h] [rbp+Fh]
  __int64 v13; // [rsp+50h] [rbp+17h]
  __int64 v14; // [rsp+58h] [rbp+1Fh]
  int v15; // [rsp+60h] [rbp+27h]
  __int64 v16; // [rsp+68h] [rbp+2Fh]
  int v17; // [rsp+70h] [rbp+37h]

  v13 = 0i64;
  v1 = a1;
  sub_14001E1C0((__m128 *)&v14, 0, 0x30ui64);
  v2 = FwpsAllocateCloneNetBufferList0(*(_QWORD *)(v1 + 64), 0i64, 0i64, 0i64, &v13);
  v3 = v2;
  if ( v2 < 0 )
  {
    v13 = 0i64;
    sub_140002E58(
      L"Reinject (Outbound): Failed to allocate clonedNetBufferList",
      v2,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
      422);
LABEL_3:
    v4 = v13;
    goto LABEL_7;
  }
  v5 = *(_QWORD *)(v1 + 96);
  v14 = v1 + 104;
  v15 = *(_DWORD *)(v1 + 120);
  v16 = *(_QWORD *)(v1 + 128);
  v17 = *(_DWORD *)(v1 + 136);
  v12 = v1;
  v11 = sub_1400164C0;
  v10 = v13;
  v6 = *(_DWORD *)(v1 + 72);
  v7 = *(_WORD *)(v1 + 24);
  v8 = FwpsInjectTransportSendAsync1(qword_140034F90, 0i64, v5, 0i64, &v14, v7, v6, v13);
  v3 = v8;
  if ( v8 < 0 )
  {
    sub_140002E58(
      L"Reinject (Outbound): Failed to inject packet to endpoint",
      v8,
      *(_DWORD *)(v1 + 96),
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
      450);
    goto LABEL_3;
  }
  v4 = 0i64;
  v13 = 0i64;
LABEL_7:
  if ( v4 )
    FwpsFreeCloneNetBufferList0(v4, 0i64);
  return v3;
}
// 14001DCDE: using guessed type __int64 __fastcall FwpsAllocateCloneNetBufferList0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 14001DCE4: using guessed type __int64 __fastcall FwpsFreeCloneNetBufferList0(_QWORD, _QWORD);
// 14001DCF6: using guessed type __int64 __fastcall FwpsInjectTransportSendAsync1(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400222B0: using guessed type wchar_t aReinjectOutbou[60];
// 140022330: using guessed type wchar_t aReinjectOutbou_0[57];
// 140034F90: using guessed type __int64 qword_140034F90;

//----- (0000000140015B50) ----------------------------------------------------
void __fastcall sub_140015B50(_QWORD **a1, char a2)
{
  _QWORD *v2; // r8
  _QWORD *v3; // rbx
  __int64 v4; // rcx

  v2 = *a1;
  v3 = a1;
  if ( *((_DWORD *)*a1 + 8) )
  {
    sub_140005770(*a1);
  }
  else
  {
    v4 = v2[5];
    v2[5] = 0i64;
    *((_DWORD *)v2 + 9) = (a2 != 0) + 4097;
    FwpsCompleteOperation0(v4, 0i64);
  }
  *v3 = 0i64;
}
// 14001DC6C: using guessed type __int64 __fastcall FwpsCompleteOperation0(_QWORD, _QWORD);

//----- (0000000140015BA0) ----------------------------------------------------
char __fastcall sub_140015BA0(unsigned __int16 *a1, int *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, _DWORD *a7)
{
  int *v7; // rbx
  unsigned __int16 *v8; // rdi
  int v9; // eax
  unsigned __int16 v10; // r12
  __int64 v11; // rcx
  __int64 v12; // rax
  __m128i *v13; // rax
  __m128i v14; // xmm0
  int v15; // eax
  __int64 *v16; // r15
  signed int v17; // ecx
  __int64 v18; // rax
  __int64 *v19; // r14
  __int64 v20; // rax
  __int64 *v21; // rsi
  __int64 v22; // rsi
  int v23; // ecx
  int v24; // ecx
  __int64 v25; // rcx
  __int64 v26; // rax
  __int64 v27; // rax
  unsigned __int8 v29; // [rsp+60h] [rbp-A0h]
  unsigned int v30; // [rsp+64h] [rbp-9Ch]
  char v31; // [rsp+68h] [rbp-98h]
  int v32; // [rsp+80h] [rbp-80h]
  bool v33; // [rsp+84h] [rbp-7Ch]
  __int128 v34; // [rsp+88h] [rbp-78h]
  __int16 v35; // [rsp+98h] [rbp-68h]
  __int128 v36; // [rsp+9Ch] [rbp-64h]
  __int16 v37; // [rsp+ACh] [rbp-54h]
  char v38; // [rsp+AEh] [rbp-52h]
  __int64 v39; // [rsp+B0h] [rbp-50h]
  __int64 v40; // [rsp+B8h] [rbp-48h]
  __int64 v41; // [rsp+C0h] [rbp-40h]
  __int64 v42; // [rsp+C8h] [rbp-38h]
  int v43; // [rsp+D0h] [rbp-30h]
  __int128 v44; // [rsp+D4h] [rbp-2Ch]
  __int16 v45; // [rsp+E4h] [rbp-1Ch]
  __int64 v46; // [rsp+E8h] [rbp-18h]
  int v47; // [rsp+F0h] [rbp-10h]
  unsigned int v48; // [rsp+F4h] [rbp-Ch]
  unsigned int v49; // [rsp+F8h] [rbp-8h]
  __int64 v50; // [rsp+100h] [rbp+0h]
  int v51; // [rsp+108h] [rbp+8h]
  unsigned int v52; // [rsp+10Ch] [rbp+Ch]
  __int64 v53; // [rsp+110h] [rbp+10h]

  v7 = a2;
  v8 = a1;
  *a7 = 4098;
  LOBYTE(v9) = sub_140016F00();
  if ( (_BYTE)v9 )
  {
    LOBYTE(v9) = sub_1400059F8(v8);
    if ( !(_BYTE)v9 )
    {
      LOBYTE(v9) = sub_140005B48(v8);
      if ( !(_BYTE)v9 )
      {
        sub_14001E1C0((__m128 *)&v32, 0, 0x90ui64);
        v10 = *v8;
        v33 = *v8 == 50;
        v11 = *((_QWORD *)v8 + 1);
        v42 = MEMORY[0xFFFFF78000000014];
        v32 = 2;
        if ( v10 == 50 )
        {
          _mm_storeu_si128((__m128i *)&v34, *(__m128i *)*(_QWORD *)(v11 + 40));
          v35 = *(_WORD *)(v11 + 72);
          _mm_storeu_si128((__m128i *)&v36, *(__m128i *)*(_QWORD *)(v11 + 104));
        }
        else
        {
          LODWORD(v34) = *(_DWORD *)(v11 + 40);
          v35 = *(_WORD *)(v11 + 72);
          LODWORD(v36) = *(_DWORD *)(v11 + 104);
        }
        v37 = *(_WORD *)(v11 + 120);
        v38 = *(_BYTE *)(v11 + 88);
        if ( *v7 & 0x20 )
        {
          v39 = *((_QWORD *)v7 + 8);
          v12 = PsGetCurrentThreadId();
          v13 = (__m128i *)sub_140019828(&v31, *((_QWORD *)v7 + 8), v12);
          v14 = *v13;
          v40 = v13->m128i_i64[0];
          v41 = (unsigned __int128)_mm_srli_si128(v14, 8);
        }
        else
        {
          sub_140002DD4(
            L"ConnectionTracking: Packet missing process id. Flow handle:",
            *((_QWORD *)v7 + 4),
            0i64,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
            1423);
        }
        v15 = *v7;
        v16 = qword_140022D10;
        v17 = 144;
        v47 = 144;
        if ( v15 & 8 && (v18 = *((_QWORD *)v7 + 6), *(_QWORD *)(v18 + 8)) )
        {
          v16 = *(__int64 **)(v18 + 8);
          v48 = *(_DWORD *)v18;
        }
        else
        {
          sub_140002DD4(
            L"ConnectionTracking: Packet missing process path. Flow handle:",
            *((_QWORD *)v7 + 4),
            0i64,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
            1436);
          v17 = v47;
        }
        v19 = qword_140022DA0;
        v20 = *((_QWORD *)v8 + 1);
        v49 = v48 + v17;
        v21 = *(__int64 **)(*(_QWORD *)(v20 + 24) + 8i64);
        if ( v21 )
        {
          v29 = 0;
          if ( sub_140015F84(v21, &v29) )
          {
            v19 = **(__int64 ***)(*v21 + 8);
            v50 = 4i64 * v29 + 8;
          }
          else
          {
            sub_140002DD4(
              L"ConnectionTracking: No user SID. Flow handle:",
              *((_QWORD *)v7 + 4),
              0i64,
              (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
              1457);
          }
        }
        else
        {
          sub_140002DD4(
            L"ConnectionTracking: No user ID. Flow handle:",
            *((_QWORD *)v7 + 4),
            0i64,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
            1462);
        }
        v22 = 0i64;
        v43 = 0;
        v51 = v50 + v49;
        if ( byte_140034F89 )
        {
          v23 = *v8;
          v30 = 0;
          sub_1400057DC(v23, &v30);
          v24 = *(_DWORD *)(*((_QWORD *)v8 + 1) + 16i64 * v30 + 8);
          if ( _bittest(&v24, 0x14u) && (*v7 & 0x30000000) == 805306368 )
          {
            v25 = *((_QWORD *)v7 + 26);
            v43 = 1;
            if ( v10 == 50 )
              _mm_storeu_si128((__m128i *)&v44, *(__m128i *)(v25 + 8));
            else
              LODWORD(v44) = _byteswap_ulong(*(_DWORD *)(v25 + 4));
            v45 = __ROR2__(*(_WORD *)(v25 + 2), 8);
            v46 = (unsigned int)v7[51];
          }
          else if ( sub_140005B54(v8) )
          {
            v26 = *((_QWORD *)v8 + 1);
            if ( *(_QWORD *)(v26 + 520) )
            {
              v43 = 2;
              v27 = *(_QWORD *)(v26 + 520);
              v22 = *(_QWORD *)(v27 + 8);
              v52 = *(_DWORD *)v27;
            }
          }
        }
        v53 = 0i64;
        v9 = sub_140014C04(1, &v53, 8i64, (__int64)&v32, 144i64, (__int64)v16, v48, (__int64)v19, v50, v22, v52);
        if ( v9 )
          LOBYTE(v9) = sub_140017980(1);
      }
    }
  }
  return v9;
}
// 140022C90: using guessed type wchar_t aConnectiontrac[60];
// 140022D10: using guessed type __int64 qword_140022D10[2];
// 140022D20: using guessed type wchar_t aConnectiontrac_11[62];
// 140022DA0: using guessed type __int64 qword_140022DA0[2];
// 140022DB0: using guessed type wchar_t aConnectiontrac_12[46];
// 140022E10: using guessed type wchar_t aConnectiontrac_0[45];
// 1400293E0: using guessed type __int64 PsGetCurrentThreadId(void);
// 140034F89: using guessed type char byte_140034F89;

//----- (0000000140015F00) ----------------------------------------------------
_LIST_ENTRY *__fastcall sub_140015F00(_LIST_ENTRY **a1, _BYTE *a2)
{
  _BYTE *v2; // rsi
  _LIST_ENTRY **v3; // rdi
  _LIST_ENTRY *v4; // rbx

  *a1 = 0i64;
  v2 = a2;
  *a2 = 0;
  v3 = a1;
  v4 = stru_140037780.Flink;
  if ( !stru_140037780.Flink )
    goto LABEL_5;
  *a1 = stru_140037780.Flink;
  if ( BYTE4(v4[11].Flink) == 1 )
  {
    sub_140004F14(v4);
    if ( !v4[4].Flink )
    {
      sub_140005770(v4);
      *v2 = 1;
      return 0i64;
    }
    sub_140004DE4((__int64)&stru_140037780, v4);
LABEL_5:
    *v3 = 0i64;
    return 0i64;
  }
  BYTE4(v4[11].Flink) = 1;
  return v4;
}

//----- (0000000140015F84) ----------------------------------------------------
char __fastcall sub_140015F84(__int64 *a1, _BYTE *a2)
{
  __int64 v2; // rax

  if ( !a1 )
    return 0;
  v2 = *a1;
  if ( !*a1 || !*(_DWORD *)v2 )
    return 0;
  *a2 = *(_BYTE *)(**(_QWORD **)(v2 + 8) + 1i64);
  return 1;
}

//----- (0000000140015FB0) ----------------------------------------------------
void __fastcall sub_140015FB0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, _DWORD *a7)
{
  __int64 v7; // r14
  __int64 v8; // rdi
  __int64 v9; // rbx
  _QWORD *v10; // rbp
  const wchar_t *v11; // rcx
  __int16 v12; // r15
  __int64 v13; // rdx
  __int64 v14; // rcx
  int v15; // eax
  __int64 v16; // rcx
  __int64 v17; // rax
  int v18; // eax
  __int64 v19; // rcx
  __int64 *v20; // r14
  unsigned __int32 v21; // er12
  __int64 v22; // r15
  __int64 v23; // r8
  int v24; // eax
  char v25; // bl
  int v26; // ecx
  char v27; // bl
  _LIST_ENTRY *v28; // r14
  int v29; // eax
  char v30; // bl
  int v31; // [rsp+20h] [rbp-98h]
  char v32; // [rsp+40h] [rbp-78h]
  char v33; // [rsp+58h] [rbp-60h]

  v7 = a3;
  v8 = a2;
  v9 = a1;
  v10 = 0i64;
  if ( !sub_1400171C0() && !sub_1400059F8((unsigned __int16 *)v9) )
    goto LABEL_6;
  if ( !(*(_DWORD *)v8 & 2) )
  {
    v31 = 950;
    v11 = L"ConnectionTracking: Packet missing flow handle.";
LABEL_5:
    sub_140002DD4(v11, 0i64, 0i64, (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c", v31);
LABEL_6:
    *a7 = 4098;
    return;
  }
  if ( *(_DWORD *)v8 & 0x40000 && *(_DWORD *)(v8 + 140) == 1 )
  {
    sub_140002DD4(
      L"ConnectionTracking: Inbound packet detected. Flow handle:",
      *(_QWORD *)(v8 + 32),
      0i64,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
      963);
    goto LABEL_6;
  }
  if ( sub_140005B48((unsigned __int16 *)v9) )
  {
    a7[6] &= 0xFFFFFFFE;
    goto LABEL_6;
  }
  v12 = sub_140010498(*(_WORD *)v9);
  if ( sub_140005ACC(v12, v9) )
    goto LABEL_6;
  if ( *(_DWORD *)v8 & 8 )
  {
    v13 = *(_QWORD *)(v8 + 48);
    v14 = *(_QWORD *)(v13 + 8);
    if ( v14 )
    {
      if ( sub_140017CE0(v14, *(_DWORD *)v13) )
        goto LABEL_6;
    }
  }
  if ( v7 )
  {
    v15 = FwpsQueryPacketInjectionState0(qword_140034F90, v7, 0i64);
    if ( !((v15 - 1) & 0xFFFFFFFD) )
    {
      sub_140002DD4(
        L"ConnectionTracking: Reinjected packet detected. (packet state; flow handle):",
        v15,
        *(_QWORD *)(v8 + 32),
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
        1011);
      goto LABEL_6;
    }
  }
  if ( sub_1400059F8((unsigned __int16 *)v9) )
  {
    v26 = *(_DWORD *)(v8 + 140);
    if ( !(*(_DWORD *)v8 & 0x40000) )
    {
      sub_140002DD4(
        L"ClassifyAUTH_CONNECT: Packet with malformed direction field, assume direction is outbound. Packet direction:",
        *(signed int *)(v8 + 140),
        0i64,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
        1205);
      v26 = 0;
    }
    if ( !v26 )
    {
      v27 = 0;
      KeAcquireInStackQueuedSpinLock(&unk_140037770);
      v28 = stru_140037780.Flink;
      if ( stru_140037780.Flink != &stru_140037780 )
      {
        while ( 1 )
        {
          if ( v28[1].Flink == *(_LIST_ENTRY **)(v8 + 32) )
          {
            v29 = HIDWORD(v28[2].Flink);
            if ( v29 )
              break;
          }
          v28 = v28->Flink;
          if ( v28 == &stru_140037780 )
            goto LABEL_62;
        }
        *a7 = v29;
        v10 = &v28->Flink;
        if ( BYTE4(v28[11].Flink) )
          sub_140004F14(v28);
        if ( !byte_140034F88 )
        {
          if ( v28[4].Flink )
          {
            if ( HIDWORD(v28[2].Flink) == 4098 )
            {
              HIDWORD(v28[1].Blink) = 1;
              KeAcquireInStackQueuedSpinLock(&unk_140037758);
              v30 = byte_140030180;
              byte_140030180 = 0;
              sub_140004DE4((__int64)&stru_140037760, v28);
              v10 = 0i64;
              KeReleaseInStackQueuedSpinLock(&v32);
              if ( v30 )
                KeSetEvent(&Object, 0, 0);
            }
          }
        }
        v27 = 1;
      }
LABEL_62:
      KeReleaseInStackQueuedSpinLock(&v33);
      if ( v27 )
        goto LABEL_65;
    }
    sub_140002DD4(
      L"ConnectionTracking: Policy change reauthorisation. Flow handle:",
      *(_QWORD *)(v8 + 32),
      0i64,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
      1327);
LABEL_64:
    *a7 = 4098;
LABEL_65:
    if ( v10 )
      sub_140005770(v10);
    return;
  }
  if ( j_unknown_libname_6(v16) == qword_140034FD0 )
  {
    sub_140002E58(
      L"ConnectionTracking: Skipping recursive network traffic.",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
      1031);
    goto LABEL_6;
  }
  if ( !(*(_DWORD *)v8 & 0x8000) )
  {
    v31 = 1042;
    v11 = L"ConnectionTracking: Packet missing transport endpoint handle.";
    goto LABEL_5;
  }
  v17 = sub_1400054F4((__int16 *)v9, v8, v12, v7, 0, 0);
  v10 = (_QWORD *)v17;
  if ( !v17 )
  {
    sub_140002E58(
      L"ConnectionTracking: Unable to allocate and initialise packet, rejecting",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
      1058);
    goto LABEL_6;
  }
  if ( *(_QWORD *)(v17 + 64) )
  {
    sub_140002DD4(
      L"ConnectionTracking (HTTP): Packet with payload detected. Flow handle:",
      *(_QWORD *)(v8 + 32),
      0i64,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
      1074);
    goto LABEL_64;
  }
  v18 = *(_DWORD *)v8;
  if ( *(_DWORD *)v8 & 8 && (v19 = *(_QWORD *)(v8 + 48), (v20 = *(__int64 **)(v19 + 8)) != 0i64) )
  {
    v21 = *(_DWORD *)v19;
  }
  else
  {
    sub_140002DD4(
      L"ConnectionTracking (HTTP): Packet missing process path. Flow handle:",
      *(_QWORD *)(v8 + 32),
      0i64,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
      1086);
    v18 = *(_DWORD *)v8;
    v20 = qword_1400228E0;
    v21 = 1;
  }
  if ( v18 & 0x20 )
  {
    v22 = *(_QWORD *)(v8 + 64);
  }
  else
  {
    sub_140002DD4(
      L"ConnectionTracking (HTTP): Packet missing process id. Flow handle:",
      *(_QWORD *)(v8 + 32),
      0i64,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
      1097);
    v18 = *(_DWORD *)v8;
    v22 = 0i64;
  }
  if ( v18 & 0x10 )
  {
    v23 = *(_QWORD *)(v8 + 56);
  }
  else
  {
    sub_140002DD4(
      L"ConnectionTracking (HTTP): Packet missing user token. Flow handle:",
      *(_QWORD *)(v8 + 32),
      0i64,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
      1107);
    v23 = 0i64;
  }
  if ( !sub_1400154FC(
          *(_BYTE *)(*(_QWORD *)(v9 + 8) + 88i64),
          v22,
          v23,
          (unsigned __int64)v20,
          v21,
          *(_QWORD *)(v8 + 112),
          *(_QWORD *)(v8 + 32)) )
  {
    sub_140002DD4(
      L"ConnectionTracking (HTTP): Failed to store information in cache. Flow handle:",
      *(_QWORD *)(v8 + 32),
      0i64,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
      1122);
    goto LABEL_64;
  }
  v24 = FwpsPendOperation0(*(_QWORD *)(v8 + 104), v10 + 5);
  if ( v24 < 0 )
  {
    sub_140002E58(
      L"ConnectionTracking: Unable to pend operation, completionHandle",
      v24,
      *(_QWORD *)(v8 + 104),
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
      1140);
    sub_1400154E0(*(_QWORD *)(v8 + 112));
    goto LABEL_64;
  }
  KeAcquireInStackQueuedSpinLock(&unk_140037770);
  KeAcquireInStackQueuedSpinLock(&unk_140037758);
  v25 = byte_140030180;
  byte_140030180 = 0;
  sub_140004DE4((__int64)&stru_140037780, v10);
  KeReleaseInStackQueuedSpinLock(&v32);
  KeReleaseInStackQueuedSpinLock(&v33);
  a7[6] &= 0xFFFFFFFE;
  a7[7] |= 1u;
  *a7 = 4097;
  if ( v25 )
    KeSetEvent(&Object, 0, 0);
}
// 1400169A4: using guessed type __int64 __fastcall j_unknown_libname_6(_QWORD);
// 14001DCC0: using guessed type __int64 __fastcall FwpsQueryPacketInjectionState0(_QWORD, _QWORD, _QWORD);
// 14001DCF0: using guessed type __int64 __fastcall FwpsPendOperation0(_QWORD, _QWORD);
// 1400224C0: using guessed type wchar_t aConnectiontrac_1[48];
// 140022520: using guessed type wchar_t aConnectiontrac_2[58];
// 1400225A0: using guessed type wchar_t aConnectiontrac_13[77];
// 140022640: using guessed type wchar_t aConnectiontrac_14[56];
// 1400226B0: using guessed type wchar_t aConnectiontrac_3[62];
// 140022730: using guessed type wchar_t aConnectiontrac_4[72];
// 1400227C0: using guessed type wchar_t aConnectiontrac_5[70];
// 140022850: using guessed type wchar_t aConnectiontrac_6[69];
// 1400228E0: using guessed type __int64 qword_1400228E0[2];
// 1400228F0: using guessed type wchar_t aConnectiontrac_15[67];
// 140022980: using guessed type wchar_t aConnectiontrac_16[67];
// 140022A10: using guessed type wchar_t aConnectiontrac_17[78];
// 140022AB0: using guessed type wchar_t aConnectiontrac_7[63];
// 140022B30: using guessed type wchar_t aClassifyauthCo[109];
// 140022C10: using guessed type wchar_t aConnectiontrac_18[64];
// 1400292E8: using guessed type __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD);
// 1400292F0: using guessed type __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD);
// 140030180: using guessed type char byte_140030180;
// 140034F88: using guessed type char byte_140034F88;
// 140034F90: using guessed type __int64 qword_140034F90;
// 140034FD0: using guessed type __int64 qword_140034FD0;

//----- (00000001400164C0) ----------------------------------------------------
void __fastcall sub_1400164C0(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rbx

  v2 = a1;
  FwpsFreeCloneNetBufferList0(a2, 0i64);
  sub_140005770(v2);
}
// 14001DCE4: using guessed type __int64 __fastcall FwpsFreeCloneNetBufferList0(_QWORD, _QWORD);

//----- (00000001400164F0) ----------------------------------------------------
void __fastcall sub_1400164F0(PVOID StartContext)
{
  PVOID v1; // rdi
  char v2; // si
  _LIST_ENTRY *v3; // rax
  PLARGE_INTEGER v4; // rbx
  __int64 v5; // rax
  __int64 v6; // rdi
  void *v7; // rcx
  int v8; // eax
  int v9; // er8
  __int64 v10; // rax
  bool v11; // al
  __int64 v12; // rcx
  bool v13; // bl
  unsigned int v14; // esi
  __int64 v15; // rbx
  __int16 v16; // ax
  signed int v17; // edi
  _LIST_ENTRY *v18; // rbx
  __int64 *v19; // rbx
  char v20; // [rsp+18h] [rbp-29h]
  PLARGE_INTEGER Timeout; // [rsp+20h] [rbp-21h]
  PVOID Object; // [rsp+28h] [rbp-19h]
  unsigned __int16 v23; // [rsp+30h] [rbp-11h]
  PVOID P; // [rsp+38h] [rbp-9h]
  __int16 v25; // [rsp+40h] [rbp-1h]
  __int16 v26; // [rsp+42h] [rbp+1h]
  __int64 v27; // [rsp+48h] [rbp+7h]
  char v28; // [rsp+50h] [rbp+Fh]
  char v29; // [rsp+68h] [rbp+27h]

  qword_140034FD0 = j_unknown_libname_6(StartContext);
  KeWaitForSingleObject(&::Object, 0, 0, 0, 0i64);
  while ( 1 )
  {
    v4 = 0i64;
    Timeout = 0i64;
    if ( byte_140034F88 )
      break;
    Object = 0i64;
    v1 = 0i64;
    v2 = 0;
    KeAcquireInStackQueuedSpinLock(&unk_140037770);
    if ( !(unsigned __int8)IsListEmpty(&stru_140037780) )
    {
      v3 = sub_140015F00((_LIST_ENTRY **)&Object, &v20);
      v1 = Object;
      v4 = (PLARGE_INTEGER)v3;
      v2 = v20;
      Timeout = (PLARGE_INTEGER)v3;
    }
    KeReleaseInStackQueuedSpinLock(&v28);
    if ( !v2 )
    {
      if ( !v1 )
      {
        KeAcquireInStackQueuedSpinLock(&unk_140037770);
        KeAcquireInStackQueuedSpinLock(&unk_140037758);
        if ( (unsigned __int8)IsListEmpty(&stru_140037760) )
        {
          byte_140030180 = 1;
        }
        else
        {
          v4 = (PLARGE_INTEGER)sub_140004F48((__int64 **)&stru_140037760);
          Timeout = v4;
        }
        KeReleaseInStackQueuedSpinLock(&v29);
        KeReleaseInStackQueuedSpinLock(&v28);
      }
      if ( v4 )
      {
        if ( !v4[3].HighPart )
        {
          v5 = ((__int64 (__fastcall *)(_QWORD))sub_14001545C)((LARGE_INTEGER)v4[2].QuadPart);
          v6 = v5;
          if ( v5 )
          {
            v7 = *(void **)(v5 + 160);
            Object = 0i64;
            if ( v7 )
            {
              v8 = ObReferenceObjectByHandle(v7, 0xF01FFu, SeTokenObjectType, 0, &Object, 0i64);
              if ( v8 < 0 )
              {
                v9 = *(_DWORD *)(v6 + 160);
                Object = 0i64;
                sub_140002E58(
                  L"WorkerThread: Failed to retrieve user token in worker thread, user_token_handle",
                  v8,
                  v9,
                  (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
                  696);
              }
            }
            v10 = *(unsigned int *)(v6 + 112);
            v26 = *(_WORD *)(v6 + 116);
            v27 = v6 + v10;
            v25 = v26 - 2;
            v11 = sub_140005A5C((__int64)&v25);
            v12 = *(_QWORD *)(v6 + 48);
            P = 0i64;
            v13 = v11;
            if ( sub_140004E4C(v12, (UNICODE_STRING *)&v23, v11, 0) )
            {
              *(_DWORD *)(v6 + 168) = 1;
              goto LABEL_25;
            }
            if ( !v13 )
              goto LABEL_25;
            if ( P )
            {
              if ( (unsigned __int64)v23 + 2 < *(unsigned int *)(v6 + 116) )
              {
                v14 = 0;
                if ( v23 & 0xFFFE )
                {
                  do
                  {
                    v15 = v14;
                    v16 = sub_140005688(*((_WORD *)P + v14++));
                    *((_WORD *)P + v15) = v16;
                  }
                  while ( v14 < (unsigned int)v23 >> 1 );
                }
                if ( sub_140018018((__int64)&v25, (__int64)&v23) )
                {
                  sub_14001E2C0((__m128i *)(v6 + *(unsigned int *)(v6 + 112)), (unsigned __int64)P, v23);
                  *(_WORD *)(v23 + v6 + *(unsigned int *)(v6 + 112)) = 0;
                  *(_DWORD *)(v6 + 116) = v23 + 2;
                }
              }
LABEL_25:
              if ( P )
                ExFreePoolWithTag(P, 0);
            }
            if ( *(_DWORD *)(v6 + 168) || !*(_QWORD *)(v6 + 160) )
            {
              if ( Object )
                ObfDereferenceObject(Object);
            }
            else if ( Object )
            {
              sub_1400153DC(v6);
            }
            if ( *(_DWORD *)(v6 + 168) == 1 )
              sub_1400153F0(v6);
            else
              sub_140015400(v6);
          }
          sub_140015B50((_QWORD **)&Timeout, 1);
          v4 = Timeout;
        }
        if ( v4 )
        {
          if ( v4[4].LowPart )
          {
            v17 = -1073741823;
            sub_140002E58(
              L"WorkerThread: Inbound packet inspected by worker thread",
              -1073741823,
              0,
              (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
              786);
          }
          else
          {
            v17 = sub_140015A08((__int64)v4);
          }
          if ( v17 >= 0 )
            v4 = 0i64;
          if ( v4 )
            sub_140005770(v4);
        }
        goto LABEL_45;
      }
    }
LABEL_45:
    KeAcquireInStackQueuedSpinLock(&unk_140037770);
    KeAcquireInStackQueuedSpinLock(&unk_140037758);
    if ( byte_140030180 && !byte_140034F88 )
      KeClearEvent(&::Object);
    KeReleaseInStackQueuedSpinLock(&v29);
    KeReleaseInStackQueuedSpinLock(&v28);
    KeWaitForSingleObject(&::Object, 0, 0, 0, 0i64);
  }
  while ( !(unsigned __int8)IsListEmpty(&stru_140037780) )
  {
    KeAcquireInStackQueuedSpinLock(&unk_140037770);
    v18 = 0i64;
    if ( !(unsigned __int8)IsListEmpty(&stru_140037780) )
      v18 = stru_140037780.Flink;
    Timeout = (PLARGE_INTEGER)v18;
    KeReleaseInStackQueuedSpinLock(&v28);
    if ( v18 )
      sub_140015B50((_QWORD **)&Timeout, 0);
  }
  while ( !(unsigned __int8)IsListEmpty(&stru_140037760) )
  {
    v19 = 0i64;
    KeAcquireInStackQueuedSpinLock(&unk_140037758);
    if ( !(unsigned __int8)IsListEmpty(&stru_140037760) )
      v19 = sub_140004F48((__int64 **)&stru_140037760);
    KeReleaseInStackQueuedSpinLock(&v29);
    if ( v19 )
      sub_140005770(v19);
  }
  qword_140034FD0 = 0i64;
  PsTerminateSystemThread(0);
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);
// 1400153DC: using guessed type __int64 __fastcall sub_1400153DC(_QWORD);
// 1400153F0: using guessed type __int64 __fastcall sub_1400153F0(_QWORD);
// 140015400: using guessed type __int64 __fastcall sub_140015400(_QWORD);
// 14001545C: using guessed type __int64 __fastcall sub_14001545C(_QWORD);
// 1400169A4: using guessed type __int64 __fastcall j_unknown_libname_6(_QWORD);
// 1400223B0: using guessed type wchar_t aWorkerthreadFa[80];
// 140022450: using guessed type wchar_t aWorkerthreadIn[56];
// 1400292E8: using guessed type __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD);
// 1400292F0: using guessed type __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD);
// 140030180: using guessed type char byte_140030180;
// 140034F88: using guessed type char byte_140034F88;
// 140034FD0: using guessed type __int64 qword_140034FD0;

//----- (00000001400169B0) ----------------------------------------------------
char __fastcall sub_1400169B0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  char result; // al

  v2 = a2;
  result = sub_1400171C0();
  if ( result )
  {
    if ( *(_DWORD *)v2 & 0x8000 )
      result = sub_1400154E0(*(_QWORD *)(v2 + 112));
  }
  return result;
}

//----- (00000001400169E0) ----------------------------------------------------
void __fastcall sub_1400169E0(_WORD *a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 a5, __int64 a6, _DWORD *a7)
{
  _QWORD *v7; // r14
  __int64 v8; // rdi
  __int64 v9; // r13
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rdi
  unsigned int v13; // eax
  unsigned __int64 v14; // r8
  __m128 *v15; // rax
  char *v16; // r15
  unsigned int v17; // eax
  unsigned __int64 v18; // rcx
  __int64 v19; // r12
  unsigned int v20; // eax
  unsigned __int64 v21; // r12
  __int64 v22; // rdi
  __int64 v23; // rcx
  unsigned __int64 v24; // r12
  unsigned int v25; // eax
  unsigned int v26; // er13
  unsigned __int64 v27; // rdi
  int v28; // ecx
  __int64 v29; // rdi
  __int64 v30; // rax
  __m128i v31; // xmm0
  __int16 v32; // [rsp+60h] [rbp-51h]
  _WORD *v33; // [rsp+68h] [rbp-49h]
  __int64 v34; // [rsp+70h] [rbp-41h]
  unsigned __int64 v35; // [rsp+78h] [rbp-39h]
  unsigned __int64 v36; // [rsp+80h] [rbp-31h]
  unsigned __int64 v37; // [rsp+90h] [rbp-21h]
  unsigned __int64 v38; // [rsp+98h] [rbp-19h]
  __int64 v39; // [rsp+A0h] [rbp-11h]
  __int64 v40; // [rsp+A8h] [rbp-9h]
  __int64 v41; // [rsp+B0h] [rbp-1h]

  v7 = a3;
  v33 = a1;
  v8 = a2;
  v32 = *a1;
  v38 = 0i64;
  v37 = 0i64;
  if ( !a7 )
    return;
  if ( !a3 )
  {
LABEL_56:
    *a7 = 4098;
    return;
  }
  v9 = *a3;
  if ( !sub_1400171C0() )
  {
    *((_DWORD *)v7 + 8) = 0;
    goto LABEL_56;
  }
  if ( !(*(_DWORD *)v8 & 2) )
  {
    sub_140002DD4(
      L"ClassifyStream: Stream missing flow handle.",
      0i64,
      0i64,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
      101);
    goto LABEL_55;
  }
  v10 = sub_14001545C(*(_QWORD *)(v8 + 32));
  v11 = v10;
  if ( !v10 )
  {
    sub_140002DD4(
      L"ClassifyStream: Connection was not found in cache. Flow handle:",
      *(_QWORD *)(v8 + 32),
      0i64,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
      113);
    goto LABEL_55;
  }
  v12 = *(_QWORD *)(v9 + 48);
  if ( !v12 )
  {
    sub_140002E58(
      L"ClassifyStream: payloadSize is 0",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
      128);
    *(_QWORD *)(v11 + 176) = 0i64;
    sub_140015400(v11);
    *((_DWORD *)v7 + 8) = 0;
    *a7 = 8198;
    return;
  }
  if ( !(unsigned __int8)sub_140015444(v10, &v38, &v37) )
  {
    sub_140002E58(
      L"ClassifyStream: Failed to get previousStream information",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
      142);
LABEL_14:
    *(_QWORD *)(v11 + 176) = 0i64;
    sub_140015400(v11);
LABEL_55:
    *((_DWORD *)v7 + 8) = 4;
    goto LABEL_56;
  }
  v36 = (unsigned int)sub_1400171AC();
  v35 = v12 + v37;
  v13 = sub_1400171AC();
  v14 = v12 + v37;
  if ( v12 + v37 >= v13 )
    v14 = (unsigned int)sub_1400171AC();
  v15 = sub_1400181F8(v14, (__int64)&unk_140030188);
  v16 = (char *)v15;
  if ( !v15 )
  {
    sub_140002E58(
      L"ClassifyStream: Failed to allocate storage for combined payload, payloadSize is:",
      0,
      v12 + v37,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
      157);
    goto LABEL_14;
  }
  if ( v38 )
    sub_14001E2C0((__m128i *)v15, v38, v37);
  v34 = (__int64)&v16[v37];
  v17 = sub_1400171AC();
  v18 = v37;
  v19 = v37 + v12;
  if ( v37 + v12 >= v17 )
  {
    v20 = sub_1400171AC();
    v18 = v37;
    v19 = v20;
  }
  v21 = v19 - v18;
  FwpsCopyStreamDataToBuffer0(v9, v34, v21, &v40);
  if ( v40 != v21 )
  {
    sub_140002E58(
      L"ClassifyStream: Unable to copy entire payload. Bytes left uncopied:",
      0,
      v12 - v40,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
      177);
LABEL_25:
    *(_QWORD *)(v11 + 176) = 0i64;
LABEL_53:
    sub_140015400(v11);
    goto LABEL_54;
  }
  v22 = v21 + v37;
  if ( v21 + v37 < 0xA )
  {
    v23 = 0i64;
LABEL_32:
    v39 = v23;
    if ( !v23 )
      goto LABEL_33;
LABEL_39:
    v24 = v23 + *(unsigned int *)(v11 + 116) + 192i64;
    v25 = sub_1400171AC();
    v26 = v25;
    if ( v24 > v25 )
    {
      *(_BYTE *)(v11 + 47) = 1;
      if ( v24 - v39 > v25 )
      {
        if ( v24 - *(unsigned int *)(v11 + 116) - v39 >= v25 )
        {
          sub_140002E58(
            L"ClassifyStream: Packet size (excluding both process path and HTTP headers) is greater than max buffer size. "
             "Packet not sent to service. Max buffer size:",
            0,
            v25,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
            270);
          goto LABEL_54;
        }
        sub_140002DD4(
          L"ClassifyStream: Packet size (excluding HTTP headers) is greater than max buffer size. HTTP headers will not be"
           " included at all, process will be truncated. Header size, cached packet size:",
          v39,
          v24 - v39,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
          259);
        v28 = *(_DWORD *)(v11 + 112);
        *(_DWORD *)(v11 + 116) += v26 + v39 - v24;
        *(_BYTE *)((unsigned int)(*(_DWORD *)(v11 + 116) + v28) + v11) = 0;
        v39 = 0i64;
      }
      else
      {
        v27 = v25 - v24;
        sub_140002DD4(
          L"ClassifyStream: Truncating HTTP headers. Header size (original; truncated):",
          v39,
          v27 + v39,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
          253);
        v39 += v27;
      }
    }
    *(_DWORD *)(v11 + 120) = *(_DWORD *)(v11 + 116) + 184;
    *(_DWORD *)v11 = 0;
    *(_QWORD *)(v11 + 128) = v39;
    *(_BYTE *)(v11 + 4) = 0;
    if ( v32 == 22 )
    {
      *(_DWORD *)(v11 + 8) = 0;
      *(_DWORD *)(v11 + 28) = 0;
    }
    else
    {
      *(_DWORD *)(v11 + 8) = *(_DWORD *)(*((_QWORD *)v33 + 1) + 8i64);
      *(_DWORD *)(v11 + 28) = *(_DWORD *)(*((_QWORD *)v33 + 1) + 40i64);
    }
    *(_WORD *)(v11 + 24) = *(_WORD *)(*((_QWORD *)v33 + 1) + 56i64);
    *(_WORD *)(v11 + 44) = *(_WORD *)(*((_QWORD *)v33 + 1) + 72i64);
    v29 = *(_QWORD *)(v11 + 48);
    if ( v29 )
    {
      v30 = PsGetCurrentThreadId();
      v31 = *(__m128i *)sub_140019828(&v36, v29, v30);
      _mm_storel_epi64((__m128i *)(v11 + 56), v31);
      _mm_storel_epi64((__m128i *)(v11 + 64), _mm_srli_si128(v31, 8));
    }
    *(_QWORD *)(v11 + 176) = v11;
    v41 = 0i64;
    if ( !(unsigned int)sub_140014C04(
                          0,
                          &v41,
                          8i64,
                          v11,
                          *(unsigned int *)(v11 + 116) + 184i64,
                          (__int64)v16,
                          v39,
                          0i64,
                          0i64,
                          0i64,
                          0i64) )
    {
      sub_140002E58(
        L"ClassifyStream: Failed to add event to EventBuffer.",
        0,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
        318);
      *(_QWORD *)(v11 + 176) = 0i64;
      goto LABEL_53;
    }
    sub_140017980(0);
LABEL_54:
    sub_1400183C4((__int64)v16);
    goto LABEL_55;
  }
  if ( !sub_140005DB8(v16, v21 + v37, &v39) )
    goto LABEL_25;
  v23 = v39;
  if ( v39 )
    goto LABEL_39;
  if ( v35 > v36 )
  {
    v23 = (unsigned int)sub_1400171AC();
    goto LABEL_32;
  }
LABEL_33:
  if ( a7[7] & 4 )
  {
    sub_140002DD4(
      L"ClassifyStream: No more data in stream (after parsing), but not enough for an HTTP header. (HTTP header size; payload size):",
      0i64,
      v22,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\inspect.c",
      230);
    *((_DWORD *)v7 + 8) = 4;
    *a7 = 4098;
    sub_1400183C4((__int64)v16);
  }
  else
  {
    if ( v38 )
      sub_1400183C4(v38);
    sub_1400154F0(v11, (__int64)v16, v22);
    *((_DWORD *)v7 + 8) = 0;
    *a7 = 8198;
  }
  *(_QWORD *)(v11 + 176) = 0i64;
  sub_140015400(v11);
}
// 140015400: using guessed type __int64 __fastcall sub_140015400(_QWORD);
// 140015444: using guessed type __int64 __fastcall sub_140015444(_QWORD, _QWORD, _QWORD);
// 14001545C: using guessed type __int64 __fastcall sub_14001545C(_QWORD);
// 14001DCFC: using guessed type __int64 __fastcall FwpsCopyStreamDataToBuffer0(_QWORD, _QWORD, _QWORD, _QWORD);
// 140021AF0: using guessed type wchar_t aClassifystream_0[44];
// 140021B50: using guessed type wchar_t aClassifystream_1[64];
// 140021BD0: using guessed type wchar_t aClassifystream[33];
// 140021C20: using guessed type wchar_t aClassifystream_2[57];
// 140021CA0: using guessed type wchar_t aClassifystream_3[81];
// 140021D50: using guessed type wchar_t aClassifystream_4[68];
// 140021DE0: using guessed type wchar_t aClassifystream_5[125];
// 140021EE0: using guessed type wchar_t aClassifystream_6[76];
// 140021F80: using guessed type wchar_t aClassifystream_7[188];
// 140022100: using guessed type wchar_t aClassifystream_8[153];
// 140022240: using guessed type wchar_t aClassifystream_9[52];
// 1400293E0: using guessed type __int64 PsGetCurrentThreadId(void);

//----- (0000000140016F00) ----------------------------------------------------
char sub_140016F00()
{
  return byte_140035080;
}
// 140035080: using guessed type char byte_140035080;

//----- (0000000140016F08) ----------------------------------------------------
void __fastcall sub_140016F08(char a1, __int64 a2)
{
  signed int *v2; // rbx
  char v3; // di
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // rax
  const wchar_t *v7; // r9
  LARGE_INTEGER Interval; // [rsp+30h] [rbp-18h]

  v2 = (signed int *)a2;
  v3 = a1;
  if ( *(_BYTE *)(a2 + 64) )
  {
    *(_BYTE *)(a2 + 64) = 0;
    KeSetEvent((PRKEVENT)(a2 + 40), 0, 0);
    v4 = *v2;
    Interval.QuadPart = -100000i64;
    sub_140002DD4(
      L"InvertedCall::DisableNotifications: Waiting for inverted calls to complete. Filtering type:",
      v4,
      0i64,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\invertedcall.c",
      543);
    while ( v2[17] )
    {
      v6 = j_unknown_libname_6(v5);
      if ( (unsigned __int8)PsIsThreadTerminating(v6) )
        break;
      KeDelayExecutionThread(0, 1u, &Interval);
    }
    if ( v3 )
      sub_140017930(*v2);
    sub_140014D7C(*v2);
  }
  if ( *v2 )
  {
    if ( *v2 == 1 )
    {
      v7 = L"CONNECTION_TRACKING";
    }
    else
    {
      if ( *v2 != 2 )
        return;
      v7 = L"STONEWALL_NOTIFICATION";
    }
  }
  else
  {
    v7 = L"HTTP_FILTERING";
  }
  if ( byte_140034440 & 4 )
    sub_1400172C8(&unk_140030040, (__int64)&unk_140029E40, 0i64, v7);
}
// 1400169A4: using guessed type __int64 __fastcall j_unknown_libname_6(_QWORD);
// 140023770: using guessed type wchar_t aInvertedcallDi[92];
// 140023830: using guessed type wchar_t aHttpFiltering[15];
// 140023850: using guessed type wchar_t aConnectionTrac[20];
// 140023880: using guessed type wchar_t aStonewallNotif[23];
// 140029418: using guessed type __int64 __fastcall PsIsThreadTerminating(_QWORD);
// 140034440: using guessed type char byte_140034440;

//----- (0000000140017008) ----------------------------------------------------
signed __int64 __fastcall sub_140017008(signed int a1, signed int *a2)
{
  signed int *v2; // rbx
  signed int v3; // edi
  int v5; // eax
  signed int v6; // ecx
  int v7; // ecx
  const wchar_t *v8; // r9

  v2 = a2;
  v3 = a1;
  if ( *((_BYTE *)a2 + 64) == 1 )
    return 0i64;
  if ( !a1 )
  {
    sub_140002DD4(
      L"InvertedCall::EnableNotifications: Failed to enable notifications. Expected buffer size must be non-null. Buffer s"
       "ize, Filtering type:",
      0i64,
      *a2,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\invertedcall.c",
      591);
    return 3221225473i64;
  }
  if ( a2[17] )
  {
    v5 = *a2;
    if ( *a2 )
    {
      if ( v5 == 1 )
      {
        sub_140002E58(
          L"EnableNotifications ConnectionTracking: numberOfInvertedCallsInProgress is equal to: ",
          0,
          a2[17],
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\invertedcall.c",
          603);
      }
      else if ( v5 == 2 )
      {
        sub_140002E58(
          L"EnableNotifications Stonewalling: numberOfInvertedCallsInProgress is equal to: ",
          0,
          a2[17],
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\invertedcall.c",
          607);
      }
    }
    else
    {
      sub_140002E58(
        L"EnableNotifications HTTP: numberOfInvertedCallsInProgress is equal to: ",
        0,
        a2[17],
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\invertedcall.c",
        599);
    }
  }
  v2[22] = v3;
  KeClearEvent((PRKEVENT)(v2 + 10));
  sub_140014D7C(*v2);
  v6 = *v2;
  *((_BYTE *)v2 + 64) = 1;
  if ( !v6 )
  {
    v8 = L"HTTP_FILTERING";
LABEL_17:
    if ( byte_140034440 & 4 )
      sub_1400172C8(&unk_140030040, (__int64)&unk_140029E30, 0i64, v8);
    return 0i64;
  }
  v7 = v6 - 1;
  if ( !v7 )
  {
    v8 = L"CONNECTION_TRACKING";
    goto LABEL_17;
  }
  if ( v7 == 1 )
  {
    v8 = L"STONEWALL_NOTIFICATION";
    goto LABEL_17;
  }
  return 0i64;
}
// 140023830: using guessed type wchar_t aHttpFiltering[15];
// 140023850: using guessed type wchar_t aConnectionTrac[20];
// 140023880: using guessed type wchar_t aStonewallNotif[23];
// 1400238B0: using guessed type wchar_t aInvertedcallEn[135];
// 1400239C0: using guessed type wchar_t aEnablenotifica[72];
// 140023A50: using guessed type wchar_t aEnablenotifica_0[86];
// 140023B00: using guessed type wchar_t aEnablenotifica_1[80];
// 140034440: using guessed type char byte_140034440;

//----- (0000000140017120) ----------------------------------------------------
void __fastcall sub_140017120(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rdi
  char v3; // bl
  KIRQL v4; // al

  v1 = a1;
  v2 = sub_1400171B4(a1);
  v3 = 1;
  sub_140002DD4(
    L"InvertedCall::EvtRequestCancel: Cancelling request.",
    0i64,
    0i64,
    (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\invertedcall.c",
    44);
  v4 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v2 + 8));
  if ( *(_BYTE *)(v2 + 1) )
    v3 = 0;
  else
    *(_BYTE *)v2 = 1;
  KeReleaseSpinLock((PKSPIN_LOCK)(v2 + 8), v4);
  if ( v3 )
    sub_14000ADD8(v1);
}
// 140022EB0: using guessed type wchar_t aInvertedcallEv[52];

//----- (00000001400171AC) ----------------------------------------------------
signed __int64 sub_1400171AC()
{
  return 4096i64;
}

//----- (00000001400171B4) ----------------------------------------------------
__int64 __fastcall sub_1400171B4(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_140036E20);
}
// 140036E20: using guessed type __int64 qword_140036E20;
// 140037458: using guessed type __int64 qword_140037458;

//----- (00000001400171C0) ----------------------------------------------------
char sub_1400171C0()
{
  return byte_140035020;
}
// 140035020: using guessed type char byte_140035020;

//----- (00000001400171C8) ----------------------------------------------------
void sub_1400171C8()
{
  dword_140034FE0 = 0;
  KeInitializeSemaphore(&Semaphore, 0, 0x7FFFFFFF);
  KeInitializeEvent(&Event, 0, 1u);
  qword_140035030 = (__int64)&Semaphore;
  qword_140035028 = (__int64)&Event;
  dword_140035038 = 4096;
  dword_140035040 = 1;
  KeInitializeSemaphore(&stru_140035048, 0, 0x7FFFFFFF);
  KeInitializeEvent(&stru_140035068, 0, 1u);
  qword_140035090 = (__int64)&stru_140035048;
  qword_140035088 = (__int64)&stru_140035068;
  dword_140035098 = 4096;
  dword_1400350A0 = 2;
  KeInitializeSemaphore(&stru_1400350A8, 0, 0x7FFFFFFF);
  KeInitializeEvent(&stru_1400350C8, 0, 1u);
  qword_1400350E8 = (__int64)&stru_1400350C8;
  qword_1400350F0 = (__int64)&stru_1400350A8;
  dword_1400350F8 = 4096;
}
// 140034FE0: using guessed type int dword_140034FE0;
// 140035028: using guessed type __int64 qword_140035028;
// 140035030: using guessed type __int64 qword_140035030;
// 140035038: using guessed type int dword_140035038;
// 140035040: using guessed type int dword_140035040;
// 140035088: using guessed type __int64 qword_140035088;
// 140035090: using guessed type __int64 qword_140035090;
// 140035098: using guessed type int dword_140035098;
// 1400350A0: using guessed type int dword_1400350A0;
// 1400350E8: using guessed type __int64 qword_1400350E8;
// 1400350F0: using guessed type __int64 qword_1400350F0;
// 1400350F8: using guessed type int dword_1400350F8;

//----- (00000001400172C8) ----------------------------------------------------
__int64 __fastcall sub_1400172C8(_QWORD *a1, __int64 a2, __int64 a3, const wchar_t *a4)
{
  _QWORD *v4; // rbx
  __int64 v5; // rsi
  __int64 v6; // rdi
  signed __int64 v7; // rax
  int v8; // er8
  const wchar_t *v9; // rdx
  char v11; // [rsp+30h] [rbp-48h]
  char v12; // [rsp+40h] [rbp-38h]

  v4 = a1;
  v5 = a3;
  v6 = a2;
  if ( a4 )
  {
    v7 = -1i64;
    do
      ++v7;
    while ( a4[v7] );
    v8 = 2 * v7 + 2;
  }
  else
  {
    v8 = 10;
  }
  v9 = L"NULL";
  if ( a4 )
    v9 = a4;
  sub_140002DA8((__int64)&v12, (__int64)v9, v8);
  return sub_140002FE0(v4, v6, v5, 2, (__int64)&v11);
}
// 14001E6B0: using guessed type wchar_t aNull[5];

//----- (0000000140017358) ----------------------------------------------------
signed __int64 __fastcall sub_140017358(__int64 *a1, __int64 a2, int *a3, __int64 a4)
{
  int *v4; // rbp
  __int64 v5; // rbx
  __int64 *v6; // r14
  __int64 v7; // rdx
  __int64 v8; // rcx
  int v9; // esi
  __int64 v10; // r9
  signed __int64 result; // rax

  v4 = a3;
  v5 = a4;
  v6 = a1;
  _InterlockedIncrement((volatile signed __int32 *)(a4 + 68));
  if ( !*(_QWORD *)(a4 + 72) || !*(_QWORD *)(a4 + 80) )
  {
    sub_14000ADD8(*a1);
    result = 3221225473i64;
    goto LABEL_12;
  }
  if ( !*(_BYTE *)(a4 + 64) )
    goto LABEL_8;
  v7 = *(unsigned int *)(a4 + 88);
  v8 = *a1;
  v9 = sub_14000AE54();
  if ( v9 >= 0 )
  {
    if ( *(_QWORD *)v4 == *(_DWORD *)(v5 + 88) )
      return 0i64;
    DbgPrintEx(80i64, 3i64, "InvertedCall::PreProcessInvertedCall Inverted call buffer incorrect size\n", v10);
    sub_140002E58(
      L"ProcessInvertedCall: Inverted call buffer incorrect size",
      0,
      *v4,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\invertedcall.c",
      157);
LABEL_8:
    v9 = -1073741823;
    goto LABEL_9;
  }
  DbgPrintEx(80i64, 3i64, "InvertedCall::PreProcessInvertedCall Unable to retrieve output buffer from request\n", v10);
  sub_140002E58(
    L"ProcessInvertedCall: Unable to retrieve output buffer from request, maxBufferSize",
    v9,
    *(_DWORD *)(v5 + 88),
    (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\invertedcall.c",
    143);
LABEL_9:
  sub_14000ADD8(*v6);
  result = (unsigned int)v9;
LABEL_12:
  _InterlockedDecrement((volatile signed __int32 *)(v5 + 68));
  return result;
}
// 140022F80: using guessed type wchar_t aProcessinverte[82];
// 140023080: using guessed type wchar_t aProcessinverte_0[57];

//----- (0000000140017474) ----------------------------------------------------
signed __int64 __fastcall sub_140017474(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  signed __int64 result; // rax
  BOOL v5; // esi
  __int64 v6; // [rsp+30h] [rbp-38h]
  __m128i *v7; // [rsp+38h] [rbp-30h]
  unsigned __int64 v8; // [rsp+40h] [rbp-28h]

  v2 = a2;
  v6 = a1;
  v3 = a1;
  result = sub_140017358(&v6, (__int64)&v7, (int *)&v8, a2);
  if ( !(_DWORD)result )
  {
    sub_140017C54();
    v5 = 0;
    while ( !(unsigned __int8)sub_140017CA8(v3) )
    {
      result = sub_1400179D8(&v6, v2);
      if ( (_DWORD)result != 1 )
        return result;
      if ( !(unsigned int)sub_140014B64(1, v7, v8, 1) )
      {
        sub_140002E58(
          L"InvertedCall::ProcessConnectionTrackingInvertedCall: Failed to retrieve message from ConnectionTracking EventBuffer",
          1,
          0,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\invertedcall.c",
          445);
        sub_140017C28();
        goto LABEL_12;
      }
      if ( v7 )
        v5 = sub_140004E4C(v7[3].m128i_i64[1], 0i64, 1, 0);
      if ( !v5 )
      {
        sub_140017C28();
        result = sub_140017C80();
        goto LABEL_13;
      }
    }
    sub_140017C28();
LABEL_12:
    result = sub_14000ADD8(v3);
LABEL_13:
    _InterlockedDecrement((volatile signed __int32 *)(v2 + 68));
  }
  return result;
}
// 1400235B0: using guessed type wchar_t aInvertedcallPr_1[116];

//----- (00000001400175DC) ----------------------------------------------------
signed __int64 __fastcall sub_1400175DC(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdi
  signed __int64 result; // rax
  __m128i *v5; // r14
  __int64 v6; // rbx
  __int64 v7; // rax
  int v8; // eax
  __int64 v9; // r9
  __int64 v10; // r14
  int v11; // eax
  __int64 v12; // r9
  __int64 v13; // r14
  __int64 v14; // [rsp+30h] [rbp-30h]
  __m128i *v15; // [rsp+38h] [rbp-28h]
  PVOID Object; // [rsp+40h] [rbp-20h]
  unsigned __int64 v17; // [rsp+48h] [rbp-18h]

  v2 = a2;
  v14 = a1;
  v3 = a1;
  result = sub_140017358(&v14, (__int64)&v15, (int *)&v17, a2);
  if ( !(_DWORD)result )
  {
    sub_140017C54();
    result = sub_1400179D8(&v14, v2);
    if ( (_DWORD)result == 1 )
    {
      if ( (unsigned int)sub_140014B64(0, v15, v17, 1) )
      {
        v5 = v15;
        v6 = v15[11].m128i_i64[1];
        v7 = sub_1400154CC(v15[11].m128i_i64[1]);
        if ( v6 && v7 )
        {
          v8 = sub_140015718(v7, &Object);
          v10 = v8;
          if ( v8 < 0 )
          {
            DbgPrintEx(80i64, 3i64, "Failed to create impersonation token\n", v9);
            sub_140002DD4(
              L"InvertedCall::ProcessHTTPInvertedCall: Failed to create impersonation token. Status:",
              v10,
              0i64,
              (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\invertedcall.c",
              371);
          }
          else
          {
            v11 = sub_140015910((__int64)Object);
            v13 = v11;
            if ( v11 < 0 )
            {
              DbgPrintEx(80i64, 3i64, "Failed to impersonate client\n", v12);
              sub_140002DD4(
                L"InvertedCall::ProcessHTTPInvertedCall: Failed to impersonate client. Status:",
                v13,
                0i64,
                (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\invertedcall.c",
                362);
            }
            ObfDereferenceObject(Object);
          }
          sub_1400153F0(v6);
        }
        else
        {
          DbgPrintEx(80i64, 3i64, "Failed to get cache packet, flow handle %I64x\n", v5[9].m128i_i64[1]);
          sub_140002DD4(
            L"InvertedCall::ProcessHTTPInvertedCall: Failed to get cache packet. Flow handle:",
            v5[9].m128i_i64[1],
            0i64,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\invertedcall.c",
            380);
        }
        sub_140017C28();
        result = sub_140017C80();
      }
      else
      {
        sub_140002E58(
          L"InvertedCall::ProcessHTTPInvertedCall: Failed to retrieve message from EventBuffer",
          1,
          0,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\invertedcall.c",
          332);
        sub_140017C28();
        result = sub_14000ADD8(v3);
      }
      _InterlockedDecrement((volatile signed __int32 *)(v2 + 68));
    }
  }
  return result;
}
// 1400153F0: using guessed type __int64 __fastcall sub_1400153F0(_QWORD);
// 140023290: using guessed type wchar_t aInvertedcallPr_2[83];
// 140023360: using guessed type wchar_t aInvertedcallPr_3[77];
// 140023430: using guessed type wchar_t aInvertedcallPr_7[85];
// 140023510: using guessed type wchar_t aInvertedcallPr_4[80];

//----- (0000000140017800) ----------------------------------------------------
signed __int64 __fastcall sub_140017800(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  signed __int64 result; // rax
  __int64 v5; // [rsp+30h] [rbp-28h]
  __m128i *v6; // [rsp+38h] [rbp-20h]
  unsigned __int64 v7; // [rsp+40h] [rbp-18h]

  v2 = a2;
  v5 = a1;
  v3 = a1;
  result = sub_140017358(&v5, (__int64)&v6, (int *)&v7, a2);
  if ( !(_DWORD)result )
  {
    sub_140017C54();
    result = sub_1400179D8(&v5, v2);
    if ( (_DWORD)result == 1 )
    {
      if ( (unsigned int)sub_140014B64(2, v6, v7, 1) )
      {
        sub_140017C28();
        result = sub_140017C80();
      }
      else
      {
        sub_140002E58(
          L"InvertedCall::ProcessStonewallingInvertedCall: Failed to retrieve message from Stonewalling EventBuffer",
          1,
          0,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\invertedcall.c",
          498);
        sub_140017C28();
        result = sub_14000ADD8(v3);
      }
      _InterlockedDecrement((volatile signed __int32 *)(v2 + 68));
    }
  }
  return result;
}
// 1400236A0: using guessed type wchar_t aInvertedcallPr_8[104];

//----- (0000000140017914) ----------------------------------------------------
void sub_140017914()
{
  signed int v0; // ebx

  v0 = 0;
  do
    sub_140017930(v0++);
  while ( v0 < 3 );
}

//----- (0000000140017930) ----------------------------------------------------
void __fastcall sub_140017930(signed int a1)
{
  signed int v1; // ebx

  v1 = a1;
  sub_140014D44(a1);
  if ( v1 )
  {
    if ( v1 == 2 )
      KeInitializeSemaphore(&stru_1400350A8, 0, 0x7FFFFFFF);
  }
  else
  {
    KeInitializeSemaphore(&Semaphore, 0, 0x7FFFFFFF);
    sub_140015410();
  }
}
// 140015410: using guessed type __int64 sub_140015410(void);

//----- (0000000140017980) ----------------------------------------------------
LONG __fastcall sub_140017980(int a1)
{
  struct _KSEMAPHORE *v1; // rcx
  LONG result; // eax

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v1 = &stru_140035048;
    }
    else
    {
      if ( a1 != 2 )
        return result;
      v1 = &stru_1400350A8;
    }
  }
  else
  {
    v1 = &Semaphore;
  }
  return KeReleaseSemaphore(v1, 0, 1, 0);
}

//----- (00000001400179D0) ----------------------------------------------------
char sub_1400179D0()
{
  return byte_1400350E0;
}
// 1400350E0: using guessed type char byte_1400350E0;

//----- (00000001400179D8) ----------------------------------------------------
signed __int64 __fastcall sub_1400179D8(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rdi
  __int64 v3; // r15
  char v4; // bp
  __int64 v5; // rax
  _BYTE *v6; // r14
  KSPIN_LOCK *v7; // r12
  unsigned int v8; // eax
  unsigned int v9; // ebx
  __int64 v10; // rsi
  NTSTATUS v11; // eax
  __int64 v12; // rcx
  __int64 v13; // rax
  KIRQL v14; // r13
  int v15; // eax
  __int64 v16; // rcx
  __int64 v17; // rcx
  __int64 v18; // rcx
  __int64 v19; // rcx

  v2 = a1;
  v3 = a2;
  v4 = 0;
  v5 = sub_1400171B4(*a1);
  v6 = (_BYTE *)v5;
  *(_WORD *)v5 = 0;
  v7 = (KSPIN_LOCK *)(v5 + 8);
  sub_14000AD60((_QWORD *)(v5 + 8));
  v8 = sub_14000AE0C(*v2);
  v9 = -1073741536;
  LODWORD(v10) = v8;
  if ( v8 == -1073741536 )
  {
    DbgPrintEx(
      80i64,
      3i64,
      "InvertedCall::PreProcessInvertedCall WdfRequestMarkCancelableEx failed status:%x\n",
      3221225760i64);
    sub_140002E58(
      L"ProcessInvertedCall: WdfRequestMarkCancelableEx failed",
      -1073741536,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\invertedcall.c",
      186);
LABEL_13:
    v16 = *v2;
    sub_140017C28();
LABEL_21:
    _InterlockedDecrement((volatile signed __int32 *)(v3 + 68));
    return v9;
  }
  if ( (v8 & 0x80000000) != 0 )
  {
    DbgPrintEx(80i64, 3i64, "InvertedCall::PreProcessInvertedCall WdfRequestMarkCancelableEx failed status:%x\n", v8);
    sub_140002E58(
      L"ProcessInvertedCall: WdfRequestMarkCancelableEx failed",
      v10,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\invertedcall.c",
      199);
LABEL_20:
    v19 = *v2;
    sub_140017C28();
    sub_14000ADD8(*v2);
    v9 = v10;
    goto LABEL_21;
  }
  do
  {
    v11 = KeWaitForMultipleObjects(2u, (PVOID *)(v3 + 72), WaitAny, 0, 0, 1u, 0i64, 0i64);
    v10 = v11;
    if ( v11 != 257 )
      break;
    v13 = j_unknown_libname_6(v12);
  }
  while ( !(unsigned __int8)PsIsThreadTerminating(v13) );
  v14 = KeAcquireSpinLockRaiseToDpc(v7);
  if ( *v6 || (v15 = sub_14000AE9C(*v2), v15 == -1073741536) || v15 < 0 )
    v4 = 1;
  else
    v6[1] = 1;
  KeReleaseSpinLock(v7, v14);
  if ( v4 )
    goto LABEL_13;
  if ( (_DWORD)v10 == 257 )
  {
    v17 = *v2;
    sub_140017C28();
    sub_14000ADD8(*v2);
    v9 = 257;
    goto LABEL_21;
  }
  if ( !(_DWORD)v10 )
  {
    v18 = *v2;
    sub_140017C28();
    sub_14000ADD8(*v2);
    v9 = 0;
    goto LABEL_21;
  }
  if ( (_DWORD)v10 != 1 )
  {
    sub_140002DD4(
      L"InvertedCall::ProcessInvertedCall: Wait state interrupted due to unexpected event. Wait status:",
      v10,
      0i64,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\invertedcall.c",
      288);
    goto LABEL_20;
  }
  return 1i64;
}
// 1400169A4: using guessed type __int64 __fastcall j_unknown_libname_6(_QWORD);
// 140023160: using guessed type wchar_t aProcessinverte_1[55];
// 1400231D0: using guessed type wchar_t aInvertedcallPr_6[96];
// 140029418: using guessed type __int64 __fastcall PsIsThreadTerminating(_QWORD);

//----- (0000000140017C28) ----------------------------------------------------
__int64 sub_140017C28()
{
  return sub_14001E1B0((__int64 (*)(void))qword_140036E40);
}
// 140036E40: using guessed type __int64 qword_140036E40;
// 140037458: using guessed type __int64 qword_140037458;

//----- (0000000140017C54) ----------------------------------------------------
__int64 sub_140017C54()
{
  return sub_14001E1B0((__int64 (*)(void))qword_140036E38);
}
// 140036E38: using guessed type __int64 qword_140036E38;
// 140037458: using guessed type __int64 qword_140037458;

//----- (0000000140017C80) ----------------------------------------------------
__int64 sub_140017C80()
{
  return sub_14001E1B0((__int64 (*)(void))qword_140037018);
}
// 140037018: using guessed type __int64 qword_140037018;
// 140037458: using guessed type __int64 qword_140037458;

//----- (0000000140017CA8) ----------------------------------------------------
__int64 __fastcall sub_140017CA8(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_140036FD8);
}
// 140036FD8: using guessed type __int64 qword_140036FD8;
// 140037458: using guessed type __int64 qword_140037458;

//----- (0000000140017CC0) ----------------------------------------------------
signed __int64 __fastcall sub_140017CC0(__int64 a1, unsigned int a2)
{
  unsigned int v2; // edx
  __int64 v3; // rax

  v2 = a2 >> 1;
  v3 = v2;
  do
  {
    --v2;
    --v3;
  }
  while ( v3 >= 0 && *(_WORD *)(a1 + 2 * v3) != 92 );
  return a1 + 2 * ((signed int)v2 + 1i64);
}

//----- (0000000140017CE0) ----------------------------------------------------
bool __fastcall sub_140017CE0(__int64 a1, unsigned int a2)
{
  wchar_t *v3; // rax

  if ( *(_WORD *)(a1 + 2 * ((unsigned __int64)a2 >> 1)) )
    return 0;
  v3 = (wchar_t *)sub_140017CC0(a1, a2);
  return sub_140017D08(v3);
}

//----- (0000000140017D08) ----------------------------------------------------
bool __fastcall sub_140017D08(wchar_t *Str2)
{
  wchar_t *v1; // rbx

  v1 = Str2;
  return !wcsicmp(L"iexplore.exe", Str2)
      || !wcsicmp(L"firefox.exe", v1)
      || !wcsicmp(L"safari.exe", v1)
      || !wcsicmp(L"webkit2webprocess.exe", v1)
      || !wcsicmp(L"chrome.exe", v1)
      || !wcsicmp(L"plugin-container.exe", v1)
      || !wcsicmp(L"opera.exe", v1)
      || !wcsicmp(L"swi_fc.exe", v1)
      || !wcsicmp(L"microsoftedge.exe", v1)
      || !wcsicmp(L"microsoftedgecp.exe", v1)
      || !wcsicmp(L"msedge.exe", v1)
      || !wcsicmp(L"vivaldi.exe", v1);
}

//----- (0000000140017E18) ----------------------------------------------------
__int64 __fastcall sub_140017E18(__int64 a1, _QWORD *a2, _DWORD *a3, __int64 a4)
{
  __int64 v4; // rdi
  _DWORD *v5; // rbx
  int v6; // eax
  __int64 (*v7)(void); // rax

  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a2;
  v4 = a1;
  *(_QWORD *)(a1 + 8) = a4;
  v5 = a3;
  v6 = FwpmTransactionBegin0(*a2, 0i64);
  *v5 = v6;
  if ( v6 >= 0 )
  {
    *(_DWORD *)(v4 + 16) = 1;
  }
  else
  {
    v7 = *(__int64 (**)(void))(v4 + 8);
    if ( v7 )
      sub_14001E1B0(v7);
  }
  return v4;
}
// 14001DD02: using guessed type __int64 __fastcall FwpmTransactionBegin0(_QWORD, _QWORD);

//----- (0000000140017E6C) ----------------------------------------------------
_QWORD *__fastcall sub_140017E6C(_QWORD *a1, void *a2)
{
  _QWORD *v2; // rbx

  *a1 = a2;
  v2 = a1;
  KeWaitForSingleObject(a2, 0, 0, 0, 0i64);
  return v2;
}

//----- (0000000140017E9C) ----------------------------------------------------
void __fastcall sub_140017E9C(__int64 a1)
{
  __int64 v1; // rbx
  __int64 (*v2)(void); // rax

  v1 = a1;
  if ( *(_DWORD *)(a1 + 16) )
  {
    FwpmTransactionAbort0(**(_QWORD **)a1);
    v2 = *(__int64 (**)(void))(v1 + 8);
    if ( v2 )
      sub_14001E1B0(v2);
  }
}
// 14001DD0E: using guessed type __int64 __fastcall FwpmTransactionAbort0(_QWORD);

//----- (0000000140017ECC) ----------------------------------------------------
LONG __fastcall sub_140017ECC(PRKMUTEX *a1)
{
  return KeReleaseMutex(*a1, 0);
}

//----- (0000000140017ED8) ----------------------------------------------------
__int64 __fastcall sub_140017ED8(_QWORD **a1)
{
  _QWORD **v1; // rbx
  __int64 result; // rax

  v1 = a1;
  result = FwpmTransactionCommit0(**a1);
  if ( (signed int)result >= 0 )
    *((_DWORD *)v1 + 4) = 0;
  return result;
}
// 14001DD08: using guessed type __int64 __fastcall FwpmTransactionCommit0(_QWORD);

//----- (0000000140017EFC) ----------------------------------------------------
_QWORD *__fastcall sub_140017EFC(_QWORD *a1)
{
  _QWORD *v1; // rbx

  v1 = a1;
  sub_14000AD60(a1);
  return v1;
}

//----- (0000000140017F14) ----------------------------------------------------
__int64 __fastcall sub_140017F14(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  sub_140017F44();
  return v1;
}
// 140017F44: using guessed type __int64 sub_140017F44(void);

//----- (0000000140017F2C) ----------------------------------------------------
KIRQL __fastcall sub_140017F2C(KSPIN_LOCK *a1)
{
  KSPIN_LOCK *v1; // rbx
  KIRQL result; // al

  v1 = a1;
  result = KeAcquireSpinLockRaiseToDpc(a1);
  *((_BYTE *)v1 + 8) = result;
  return result;
}

//----- (0000000140017F84) ----------------------------------------------------
__int64 __fastcall sub_140017F84(unsigned __int16 *a1)
{
  __int64 result; // rax
  unsigned int v2; // edx
  _WORD *v3; // r8
  __int64 v4; // r9
  bool v5; // zf
  unsigned int v6; // edx

  result = 0i64;
  v2 = (unsigned int)*a1 >> 1;
  if ( v2 )
  {
    v3 = (_WORD *)*((_QWORD *)a1 + 1);
    v4 = v2;
    do
    {
      v5 = *v3 == 92;
      v6 = result + 1;
      ++v3;
      if ( !v5 )
        v6 = result;
      result = v6;
      --v4;
    }
    while ( v4 );
  }
  return result;
}

//----- (0000000140017FAC) ----------------------------------------------------
char __fastcall sub_140017FAC(__int64 a1, unsigned int a2, _WORD *a3, unsigned int a4)
{
  unsigned int v4; // er10
  __int64 v5; // r11
  __int64 v7; // r11

  v4 = 0;
  if ( a4 <= a2 )
  {
    if ( a4 == a2 )
    {
      if ( !a4 )
        return 1;
      v5 = a1 - (_QWORD)a3;
      while ( *(_WORD *)((char *)a3 + v5) == *a3 )
      {
        ++v4;
        ++a3;
        if ( v4 >= a4 )
          return 1;
      }
    }
    else if ( a4 == 8 && a3[6] == 126 && (unsigned __int16)(a3[7] - 48) <= 9u )
    {
      v7 = a1 - (_QWORD)a3;
      while ( *a3 == *(_WORD *)((char *)a3 + v7) )
      {
        ++v4;
        ++a3;
        if ( v4 >= 6 )
          return 1;
      }
    }
  }
  return 0;
}

//----- (0000000140018018) ----------------------------------------------------
char __fastcall sub_140018018(__int64 a1, __int64 a2)
{
  unsigned __int16 v2; // di
  unsigned __int16 *v3; // rbx
  unsigned int v4; // er12
  unsigned __int16 v5; // bp
  _WORD *v6; // rsi
  _WORD *v7; // r14
  unsigned int v8; // er15
  unsigned int v9; // edx
  __int64 v10; // rbx
  __int64 v11; // rdi
  __int64 v12; // rcx
  __int16 v13; // r8
  signed int v14; // ecx
  __int64 v15; // rdi
  __int16 v16; // cx
  unsigned int v17; // edx
  unsigned int v18; // er9

  v2 = *(_WORD *)a1;
  v3 = (unsigned __int16 *)a2;
  v4 = 0;
  if ( !*(_WORD *)a1 )
    return 0;
  v5 = *(_WORD *)a2;
  if ( !*(_WORD *)a2 )
    return 0;
  v6 = *(_WORD **)(a1 + 8);
  if ( !v6 )
    return 0;
  v7 = *(_WORD **)(a2 + 8);
  if ( !v7 )
    return 0;
  if ( v2 <= v5 )
    return 0;
  v8 = sub_140017F84((unsigned __int16 *)a1);
  if ( v8 != (unsigned int)sub_140017F84(v3) )
    return 0;
  if ( *v6 != 92 )
    return 0;
  if ( *v7 != 92 )
    return 0;
  if ( v8 < 3 )
    return 0;
  v9 = (unsigned int)v2 >> 1;
  v10 = ((unsigned int)v5 >> 1) - 1;
  v11 = v9 - 1;
  v12 = (unsigned int)v11;
  if ( v6[v11] == 92 || v7[v10] == 92 )
    return 0;
  if ( v9 != 1 )
  {
    while ( 1 )
    {
      v13 = v6[v12];
      if ( v13 == 92 )
        goto LABEL_40;
      if ( v13 == 46 )
        break;
      ++v4;
      v12 = (unsigned int)(v12 - 1);
      if ( !(_DWORD)v12 )
        goto LABEL_40;
    }
    v14 = v4;
    if ( v4 > 3 )
      v14 = 3;
    if ( (unsigned int)v10 >= v14 + 1 && v7[(unsigned int)(v10 - v14)] == 46 )
    {
      v15 = v9 - v4 + v14 - 1;
      while ( 1 )
      {
        v16 = v6[v15];
        if ( v16 == 46 )
          break;
        if ( v16 != v7[v10] )
          return 0;
        v15 = (unsigned int)(v15 - 1);
        v10 = (unsigned int)(v10 - 1);
      }
      if ( v7[v10] == 46 )
      {
        v11 = (unsigned int)(v15 - 1);
        v10 = (unsigned int)(v10 - 1);
        goto LABEL_40;
      }
    }
    return 0;
  }
LABEL_40:
  while ( v8 && (_DWORD)v11 && (_DWORD)v10 )
  {
    v17 = 0;
    v18 = 0;
    while ( v6[v11] != 92 )
    {
      v11 = (unsigned int)(v11 - 1);
      ++v17;
    }
    while ( v7[v10] != 92 )
    {
      v10 = (unsigned int)(v10 - 1);
      ++v18;
    }
    if ( !sub_140017FAC((__int64)&v6[(unsigned int)(v11 + 1)], v17, &v7[(unsigned int)(v10 + 1)], v18) )
      return 0;
    if ( --v8 )
    {
      v11 = (unsigned int)(v11 - 1);
      v10 = (unsigned int)(v10 - 1);
    }
    else if ( (_DWORD)v11 || (_DWORD)v10 )
    {
      return 0;
    }
  }
  return 1;
}

//----- (00000001400181F8) ----------------------------------------------------
__m128 *__fastcall sub_1400181F8(unsigned __int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  unsigned __int64 v3; // rsi
  __int64 v4; // rbx
  SIZE_T v5; // rdx
  POOL_TYPE v6; // ecx
  __int64 v7; // rax
  __m128 *v8; // rcx
  __m128 *v10; // rax
  __m128 *v11; // rbx

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  v5 = a1 + 24;
  v6 = *(_DWORD *)(v2 + 4);
  if ( v6 == 1 )
  {
    if ( !(*(_DWORD *)(v2 + 8) & 2) && v5 <= (unsigned int)dword_140030280 )
    {
      if ( (unsigned int)dword_1400301C0[0] < v5 )
      {
        do
          v4 = (unsigned int)(v4 + 1);
        while ( (unsigned int)dword_1400301C0[48 * v4] < v5 );
      }
      v7 = sub_140018390((__int64)&Lookaside + 192 * v4);
      v8 = (__m128 *)v7;
      if ( !v7 )
      {
        sub_140002E58(
          L"MemoryMgnt::AllocateBuffer: Memory block allocation failed, insufficient memory (PagedLookasideList)",
          0,
          0,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\memorymgnt.c",
          341);
        return 0i64;
      }
LABEL_16:
      *(_DWORD *)(v7 + 4) = v4;
      goto LABEL_20;
    }
  }
  else if ( v6 == 512 && !(*(_DWORD *)(v2 + 8) & 2) && v5 <= (unsigned int)dword_140030700 )
  {
    if ( (unsigned int)dword_140030340[0] < v5 )
    {
      do
        v4 = (unsigned int)(v4 + 1);
      while ( (unsigned int)dword_140030340[48 * v4] < v5 );
    }
    v7 = sub_140004CAC((__int64)&stru_140030380 + 192 * v4);
    v8 = (__m128 *)v7;
    if ( !v7 )
    {
      sub_140002E58(
        L"MemoryMgnt::AllocateBuffer: Memory block allocation failed, insufficient memory (NonPagedLookasideList)",
        0,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\memorymgnt.c",
        370);
      return 0i64;
    }
    goto LABEL_16;
  }
  v10 = (__m128 *)ExAllocatePoolWithTag(v6, v5, 0x4E464349u);
  v8 = v10;
  if ( !v10 )
  {
    sub_140002E58(
      L"MemoryMgnt::AllocateBuffer: Failed to allocate buffer, insufficient memory (System heap)",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\memorymgnt.c",
      395);
    return 0i64;
  }
  HIDWORD(v10->m128_u64[0]) = -6;
LABEL_20:
  v11 = v8 + 1;
  LODWORD(v8->m128_u64[1]) = *(_DWORD *)(v2 + 4);
  LODWORD(v8->m128_u64[0]) = 305419896;
  if ( *(_DWORD *)(v2 + 8) & 1 )
    sub_14001E1C0(v11, 0, v3);
  return v11;
}
// 140023DA0: using guessed type wchar_t aMemorymgntAllo[101];
// 140023E70: using guessed type wchar_t aMemorymgntAllo_1[104];
// 140023F40: using guessed type wchar_t aMemorymgntAllo_0[89];
// 1400301C0: using guessed type int dword_1400301C0[];
// 140030280: using guessed type int dword_140030280;
// 140030340: using guessed type int dword_140030340[];
// 140030700: using guessed type int dword_140030700;

//----- (0000000140018390) ----------------------------------------------------
__int64 __fastcall sub_140018390(__int64 a1)
{
  __int64 v1; // rbx
  __int64 result; // rax
  __int64 v3; // rdx
  __int64 v4; // r8
  __int64 v5; // rcx

  ++*(_DWORD *)(a1 + 20);
  v1 = a1;
  result = (__int64)ExpInterlockedPopEntrySList((PSLIST_HEADER)a1);
  if ( !result )
  {
    ++*(_DWORD *)(v1 + 24);
    v3 = *(unsigned int *)(v1 + 44);
    v4 = *(unsigned int *)(v1 + 40);
    v5 = *(unsigned int *)(v1 + 36);
    result = sub_14001E1B0(*(__int64 (**)(void))(v1 + 48));
  }
  return result;
}

//----- (00000001400183C4) ----------------------------------------------------
void __fastcall sub_1400183C4(__int64 a1)
{
  signed __int64 v1; // r8
  __int64 v2; // rax
  int v3; // ecx

  if ( a1 )
  {
    v1 = a1 - 16;
    if ( *(_DWORD *)(a1 - 16) == 305419896 )
    {
      v2 = *(unsigned int *)(v1 + 4);
      if ( (_DWORD)v2 == -6 )
      {
        ExFreePoolWithTag((PVOID)(a1 - 16), 0);
      }
      else
      {
        v3 = *(_DWORD *)(v1 + 8);
        if ( v3 == 1 )
        {
          if ( (unsigned int)v2 >= 2 )
            sub_140002E58(
              L"MemoryMgnt::FreeBuffer: Failed to free buffer, memory block has invalid pool size (Paged Pool)",
              0,
              0,
              (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\memorymgnt.c",
              508);
          else
            sub_140004CE0(&Lookaside.L.ListHead + 12 * v2, (PSLIST_ENTRY)v1);
        }
        else if ( v3 == 512 )
        {
          if ( (unsigned int)v2 >= 6 )
            sub_140002E58(
              L"MemoryMgnt::FreeBuffer: Failed to free buffer, memory block has invalid pool size (Non-Paged Pool)",
              0,
              0,
              (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\memorymgnt.c",
              528);
          else
            sub_140004CE0(&stru_140030380.L.ListHead + 12 * v2, (PSLIST_ENTRY)v1);
        }
        else
        {
          sub_140002E58(
            L"MemoryMgnt::FreeBuffer: Failed to free buffer, unable to find valid memory pool",
            0,
            0,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\memorymgnt.c",
            538);
        }
      }
    }
    else
    {
      sub_140002E58(
        L"MemoryMgnt::FreeBuffer: Failed to free buffer, memory signature not present",
        0,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\memorymgnt.c",
        468);
    }
  }
  else
  {
    sub_140002E58(
      L"MemoryMgnt::FreeBuffer: Failed to free buffer, memory block pointer is NULL",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\memorymgnt.c",
      447);
  }
}
// 140024000: using guessed type wchar_t aMemorymgntFree_0[76];
// 1400240A0: using guessed type wchar_t aMemorymgntFree_1[76];
// 140024140: using guessed type wchar_t aMemorymgntFree_2[95];
// 140024200: using guessed type wchar_t aMemorymgntFree[99];
// 1400242D0: using guessed type wchar_t aMemorymgntFree_3[80];

//----- (00000001400184C0) ----------------------------------------------------
void sub_1400184C0()
{
  int *v0; // rbx
  signed __int64 v1; // rsi
  struct _PAGED_LOOKASIDE_LIST *v2; // rdi
  int *v3; // rbx
  signed __int64 v4; // rsi
  struct _NPAGED_LOOKASIDE_LIST *v5; // rdi
  bool v6; // zf
  int v7; // er9

  v0 = dword_1400301C0;
  v1 = 2i64;
  v2 = &Lookaside;
  do
  {
    ExInitializePagedLookasideList(v2, 0i64, 0i64, 0, (unsigned int)*v0, 0x45524946u, 0);
    v2 = (struct _PAGED_LOOKASIDE_LIST *)((char *)v2 + 192);
    v0 += 48;
    --v1;
  }
  while ( v1 );
  v3 = dword_140030340;
  v4 = 6i64;
  v5 = &stru_140030380;
  do
  {
    v6 = (unsigned __int8)RtlIsNtDdiVersionAvailable(100794368i64) == 0;
    v7 = 0;
    if ( !v6 )
      v7 = 512;
    sub_140004D28(v5, 0i64, 0i64, v7, (unsigned int)*v3, 0x45524946u, 0);
    v5 = (struct _NPAGED_LOOKASIDE_LIST *)((char *)v5 + 192);
    v3 += 48;
    --v4;
  }
  while ( v4 );
}
// 14001E025: using guessed type __int64 __fastcall RtlIsNtDdiVersionAvailable(_QWORD);
// 1400301C0: using guessed type int dword_1400301C0[];
// 140030340: using guessed type int dword_140030340[];

//----- (000000014001859C) ----------------------------------------------------
void sub_14001859C()
{
  struct _PAGED_LOOKASIDE_LIST *v0; // rbx
  signed __int64 v1; // rdi
  struct _NPAGED_LOOKASIDE_LIST *v2; // rbx
  signed __int64 v3; // rdi

  v0 = &Lookaside;
  v1 = 2i64;
  do
  {
    ExDeletePagedLookasideList(v0);
    v0 = (struct _PAGED_LOOKASIDE_LIST *)((char *)v0 + 192);
    --v1;
  }
  while ( v1 );
  v2 = &stru_140030380;
  v3 = 6i64;
  do
  {
    ExDeleteNPagedLookasideList(v2);
    v2 = (struct _NPAGED_LOOKASIDE_LIST *)((char *)v2 + 192);
    --v3;
  }
  while ( v3 );
}

//----- (00000001400185F8) ----------------------------------------------------
char __fastcall sub_1400185F8(__int64 a1, __int64 a2)
{
  char v2; // di
  __int64 v3; // rbp
  __int64 v4; // rbx
  void *v6; // rdx
  int v7; // edx
  int v8; // ecx
  unsigned int v9; // er8
  int v10; // er9
  __int64 *v11; // rsi
  bool v12; // zf
  __int64 v13; // rdx
  unsigned __int64 v14; // rdx
  __int64 v15; // rcx
  _QWORD *v16; // rax
  __int64 v17; // rdx
  __int64 v18[4]; // [rsp+30h] [rbp-48h]

  v2 = 0;
  v3 = a2;
  v4 = a1;
  if ( !a2 )
  {
    sub_140002E58(
      L"Cache::addCacheEntry: Unable to add new entry, new entry is NULL",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\cache.cpp",
      63);
    return 0;
  }
  if ( !*(_DWORD *)(a1 + 44) )
  {
    sub_140002E58(
      L"Cache::addCacheEntry: Unable to add new entry, maximum cache size is 0",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\cache.cpp",
      71);
    return 0;
  }
  if ( !*(_BYTE *)(a1 + 52) )
  {
    sub_140002E58(
      L"Cache::addCacheEntry: Worker Thread is not initialised",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\cache.cpp",
      80);
    return 0;
  }
  v6 = &unk_1400351A0;
  if ( *(_DWORD *)a1 == 1 )
    v6 = &unk_1400351A8;
  sub_14000391C(v18, (__int64)v6);
  v7 = *(_DWORD *)(v4 + 48);
  v8 = *(_DWORD *)(v4 + 40);
  v9 = *(_DWORD *)(v4 + 44);
  if ( v8 + v7 >= v9 )
  {
    v10 = *(_DWORD *)(v4 + 40);
    do
    {
      v8 = v10;
      if ( !v10 )
        break;
      v11 = sub_140004F48((__int64 **)(v4 + 8));
      v12 = (*((_DWORD *)v11 - 10))-- == 1;
      v13 = *(v11 - 6);
      if ( v12 )
      {
        sub_140002DD4(
          L"Cache::addCacheEntry: Cache is full. Removing oldest entry to make room for entry with key2 (flow handle)",
          v13,
          0i64,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\cache.cpp",
          97);
        v14 = *(v11 - 4);
        if ( v14 || *(v11 - 3) )
          sub_1400191E8((_DWORD *)v4, v14, *(v11 - 3));
        sub_1400183C4((__int64)(v11 - 7));
      }
      else
      {
        sub_140002DD4(
          L"Cache::addCacheEntry: Cache is full, but oldest entry is still referenced. Moving oldest entry to \"zombie\" l"
           "ist to make room for entry with key2 (flow handle)",
          v13,
          0i64,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\cache.cpp",
          107);
        *(v11 - 1) = 1i64;
        sub_140004DE4(v4 + 24, v11);
        ++*(_DWORD *)(v4 + 48);
      }
      v8 = *(_DWORD *)(v4 + 40) - 1;
      *(_DWORD *)(v4 + 40) = v8;
      if ( !v8 )
        *(_BYTE *)(v4 + 53) = 1;
      v7 = *(_DWORD *)(v4 + 48);
      v10 = v8;
      v9 = *(_DWORD *)(v4 + 44);
    }
    while ( v7 + v8 >= v9 );
  }
  if ( v8 + v7 < v9 )
  {
    v15 = v4 + 8;
    *(_DWORD *)(v3 + 48) = 0;
    *(_DWORD *)(v3 + 52) = 1;
    v16 = *(_QWORD **)(v4 + 8);
    if ( v16 == (_QWORD *)(v4 + 8) )
    {
LABEL_27:
      *(_DWORD *)(v3 + 16) = 1;
      sub_140004DE4(v15, (_QWORD *)(v3 + 56));
      ++*(_DWORD *)(v4 + 40);
      v2 = 1;
    }
    else
    {
      while ( 1 )
      {
        v17 = *(v16 - 6);
        if ( v17 == *(_QWORD *)(v3 + 8) )
          break;
        v16 = (_QWORD *)*v16;
        if ( v16 == (_QWORD *)v15 )
          goto LABEL_27;
      }
      sub_140002DD4(
        L"Cache::addCacheEntry: Unable to add entry to cache, an entry with the same key2 (flow handle) already exists. Key2:",
        v17,
        0i64,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\cache.cpp",
        147);
    }
  }
  else
  {
    sub_140002E58(
      L"Cache::addCacheEntry: Unable to add new entry, cache is full",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\cache.cpp",
      126);
  }
  sub_140003B34(v18);
  return v2;
}
// 1400243B0: using guessed type wchar_t aCacheAddcachee_2[65];
// 140024440: using guessed type wchar_t aCacheAddcachee_3[71];
// 1400244D0: using guessed type wchar_t aCacheAddcachee[55];
// 140024540: using guessed type wchar_t aCacheAddcachee_0[106];
// 140024620: using guessed type wchar_t aCacheAddcachee_4[159];
// 140024760: using guessed type wchar_t aCacheAddcachee_1[61];
// 1400247E0: using guessed type wchar_t aCacheAddcachee_5[116];

//----- (000000014001881C) ----------------------------------------------------
void __fastcall sub_14001881C(__int64 a1)
{
  int v1; // ebx
  __int64 v2; // rax
  PVOID *v3; // rdi
  NTSTATUS v4; // eax
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 v7; // rcx
  void *v8; // rdx
  __int64 **v9; // rsi
  __int64 *v10; // rax
  void *v11; // rbp
  __int64 v12; // rsi
  __int64 v13; // rax
  __int64 v14[4]; // [rsp+40h] [rbp-38h]

  v1 = a1;
  v2 = j_unknown_libname_6(a1);
  if ( !(unsigned __int8)PsIsThreadTerminating(v2) )
  {
    v3 = &off_1400307E0;
    if ( v1 == 1 )
      v3 = off_1400307D0;
    do
    {
      v4 = KeWaitForMultipleObjects(2u, v3, WaitAny, 0, 0, 1u, 0i64, 0i64);
      if ( !v4 )
        break;
      if ( v4 == 257 )
      {
        v6 = j_unknown_libname_6(v5);
        if ( (unsigned __int8)PsIsThreadTerminating(v6) )
          break;
      }
      else
      {
        v8 = &unk_1400351A0;
        if ( v1 == 1 )
          v8 = &unk_1400351A8;
        sub_14000391C(v14, (__int64)v8);
        v9 = (__int64 **)&unk_140035180;
        if ( v1 == 1 )
          v9 = (__int64 **)&ListHead;
        if ( (unsigned __int8)IsListEmpty(v9) || (v10 = sub_140004F48(v9)) == 0i64 )
        {
          sub_140003B34(v14);
        }
        else
        {
          v11 = (void *)*(v10 - 2);
          v12 = *(v10 - 1);
          sub_1400183C4((__int64)(v10 - 2));
          sub_140003B34(v14);
          if ( v11 )
            ObfDereferenceObject(v11);
          if ( v12 )
            sub_1400183C4(v12);
        }
      }
      v13 = j_unknown_libname_6(v7);
    }
    while ( !(unsigned __int8)PsIsThreadTerminating(v13) );
  }
  sub_1400190D8(v1);
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);
// 1400169A4: using guessed type __int64 __fastcall j_unknown_libname_6(_QWORD);
// 140029418: using guessed type __int64 __fastcall PsIsThreadTerminating(_QWORD);
// 1400307E0: using guessed type void *off_1400307E0;

//----- (0000000140018990) ----------------------------------------------------
void __fastcall sub_140018990(__int64 a1)
{
  __int64 v1; // rdi
  unsigned int v2; // eax
  void *v3; // rdx
  __int64 v4; // rbx
  bool v5; // si
  __int64 v6; // rbx
  unsigned __int64 v7; // rdx
  unsigned int v8; // eax
  __int64 v9[4]; // [rsp+30h] [rbp-38h]

  v1 = a1;
  v2 = sub_140018EF0(a1);
  sub_140002DD4(
    L"Cache::clearList: Clearing cache. Current cache size:",
    v2,
    0i64,
    (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\cache.cpp",
    480);
  v3 = &unk_1400351A0;
  if ( *(_DWORD *)v1 == 1 )
    v3 = &unk_1400351A8;
  sub_14000391C(v9, (__int64)v3);
  if ( !(unsigned __int8)IsListEmpty(v1 + 8) )
  {
    do
    {
      v4 = *(_QWORD *)(v1 + 8);
      v5 = sub_140004F14(*(_QWORD **)(v1 + 8));
      v6 = v4 - 56;
      if ( v6 )
      {
        v7 = *(_QWORD *)(v6 + 24);
        if ( v7 || *(_QWORD *)(v6 + 32) )
          sub_1400191E8((_DWORD *)v1, v7, *(_QWORD *)(v6 + 32));
        sub_1400183C4(v6);
      }
      --*(_DWORD *)(v1 + 40);
    }
    while ( !v5 );
  }
  v8 = sub_14000F454(v1);
  sub_140002DD4(
    L"Cache::clearList: Clearing \"zombie\" list. Current \"zombie\" list size:",
    v8,
    0i64,
    (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\cache.cpp",
    506);
  sub_140018B38(v1);
  sub_140003B34(v9);
  sub_1400190D8(*(_DWORD *)v1);
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);
// 140024AB0: using guessed type wchar_t aCacheClearlist_0[54];
// 140024B20: using guessed type wchar_t aCacheClearlist[70];

//----- (0000000140018AB0) ----------------------------------------------------
void __fastcall sub_140018AB0(__int64 a1)
{
  _QWORD **v1; // rsi
  _DWORD *v2; // rbp
  _QWORD *v3; // rbx
  _QWORD *v4; // rcx
  __int64 v5; // rdi
  unsigned __int64 v6; // rdx

  v1 = (_QWORD **)(a1 + 24);
  v2 = (_DWORD *)a1;
  if ( !(unsigned __int8)IsListEmpty(a1 + 24) )
  {
    v3 = *v1;
    while ( v3 != v1 )
    {
      v4 = v3;
      v3 = (_QWORD *)*v3;
      v5 = (__int64)(v4 - 7);
      if ( v4 != (_QWORD *)56 && *(_DWORD *)(v5 + 52) )
      {
        sub_140004F14(v4);
        v6 = *(_QWORD *)(v5 + 24);
        if ( v6 || *(_QWORD *)(v5 + 32) )
          sub_1400191E8(v2, v6, *(_QWORD *)(v5 + 32));
        sub_1400183C4(v5);
        --v2[12];
      }
    }
  }
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);

//----- (0000000140018B38) ----------------------------------------------------
void __fastcall sub_140018B38(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rbx
  bool v3; // bp
  __int64 v4; // rbx
  unsigned __int64 v5; // rdx

  v1 = a1;
  if ( !(unsigned __int8)IsListEmpty(a1 + 24) )
  {
    do
    {
      v2 = *(_QWORD *)(v1 + 24);
      v3 = sub_140004F14(*(_QWORD **)(v1 + 24));
      v4 = v2 - 56;
      if ( v4 )
      {
        v5 = *(_QWORD *)(v4 + 24);
        if ( v5 || *(_QWORD *)(v4 + 32) )
          sub_1400191E8((_DWORD *)v1, v5, *(_QWORD *)(v4 + 32));
        sub_1400183C4(v4);
      }
      --*(_DWORD *)(v1 + 48);
    }
    while ( !v3 );
  }
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);

//----- (0000000140018BC0) ----------------------------------------------------
void sub_140018BC0()
{
  sub_14001881C(0i64);
}

//----- (0000000140018BC8) ----------------------------------------------------
__int64 __fastcall sub_140018BC8(_DWORD *a1, __int64 a2)
{
  _DWORD *v2; // rdi
  __int64 v3; // rbx
  void *v4; // rdx
  unsigned int v5; // eax
  int v6; // eax
  unsigned __int64 v7; // rdx
  __int64 v9[4]; // [rsp+20h] [rbp-38h]

  v2 = a1;
  v3 = a2;
  v4 = &unk_1400351A0;
  if ( *a1 == 1 )
    v4 = &unk_1400351A8;
  sub_14000391C(v9, (__int64)v4);
  if ( *(_DWORD *)(v3 + 48) == 1 )
  {
    sub_140019058((__int64)v2, v3);
  }
  else
  {
    v5 = *(_DWORD *)(v3 + 16);
    if ( v5 <= 2 )
      v6 = 0;
    else
      v6 = v5 - 2;
    *(_DWORD *)(v3 + 16) = v6;
    sub_140004F14((_QWORD *)(v3 + 56));
    --v2[10];
    if ( *(_DWORD *)(v3 + 16) )
    {
      *(_DWORD *)(v3 + 52) = 0;
      *(_DWORD *)(v3 + 48) = 1;
      sub_140004DE4((__int64)(v2 + 6), (_QWORD *)(v3 + 56));
      ++v2[12];
    }
    else
    {
      v7 = *(_QWORD *)(v3 + 24);
      if ( v7 || *(_QWORD *)(v3 + 32) )
        sub_1400191E8(v2, v7, *(_QWORD *)(v3 + 32));
      sub_1400183C4(v3);
    }
  }
  return sub_140003B34(v9);
}

//----- (0000000140018CAC) ----------------------------------------------------
__int64 __fastcall sub_140018CAC(_DWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  void *v4; // rdx
  __int64 v6[4]; // [rsp+20h] [rbp-38h]

  v2 = (__int64)a1;
  v3 = a2;
  v4 = &unk_1400351A0;
  if ( *a1 == 1 )
    v4 = &unk_1400351A8;
  sub_14000391C(v6, (__int64)v4);
  sub_140019058(v2, v3);
  return sub_140003B34(v6);
}

//----- (0000000140018D18) ----------------------------------------------------
void __fastcall sub_140018D18(__int64 a1)
{
  __int64 v1; // rbx
  unsigned int v2; // eax
  void *v3; // rdx
  _QWORD **v4; // rsi
  _QWORD *v5; // rdi
  _QWORD *v6; // rdx
  __int64 v7; // rdx
  unsigned int v8; // eax
  __int64 v9[4]; // [rsp+30h] [rbp-38h]

  v1 = a1;
  v2 = sub_140018EF0(a1);
  sub_140002DD4(
    L"Cache::clearList: Clearing cache. Current cache size:",
    v2,
    0i64,
    (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\cache.cpp",
    516);
  v3 = &unk_1400351A0;
  if ( *(_DWORD *)v1 == 1 )
    v3 = &unk_1400351A8;
  sub_14000391C(v9, (__int64)v3);
  if ( *(_BYTE *)(v1 + 53) )
  {
    v4 = (_QWORD **)(v1 + 8);
    if ( !(unsigned __int8)IsListEmpty(v1 + 8) )
    {
      v5 = *v4;
      while ( v5 != v4 )
      {
        v6 = v5;
        v5 = (_QWORD *)*v5;
        v7 = (__int64)(v6 - 7);
        if ( v7 )
          sub_140019058(v1, v7);
      }
    }
    *(_BYTE *)(v1 + 53) = 0;
  }
  else
  {
    sub_140002E58(
      L"FlushCache called when unsafe",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\cache.cpp",
      546);
  }
  v8 = sub_14000F454(v1);
  sub_140002DD4(
    L"Cache::clearList: Clearing \"zombie\" list. Current \"zombie\" list size:",
    v8,
    0i64,
    (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\cache.cpp",
    548);
  sub_140018AB0(v1);
  sub_140003B34(v9);
  sub_1400190D8(*(_DWORD *)v1);
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);
// 140024AB0: using guessed type wchar_t aCacheClearlist_0[54];
// 140024B20: using guessed type wchar_t aCacheClearlist[70];
// 140024BB0: using guessed type wchar_t aFlushcacheCall[30];

//----- (0000000140018E38) ----------------------------------------------------
signed __int64 __fastcall sub_140018E38(_DWORD *a1, __int64 a2)
{
  _DWORD *v2; // rsi
  __int64 v3; // rdi
  void *v4; // rdx
  signed __int64 v5; // rbx
  _QWORD *i; // rax
  __int64 v8[4]; // [rsp+30h] [rbp-38h]

  v2 = a1;
  v3 = a2;
  v4 = &unk_1400351A0;
  if ( *a1 == 1 )
    v4 = &unk_1400351A8;
  sub_14000391C(v8, (__int64)v4);
  v5 = 0i64;
  if ( v3 )
  {
    for ( i = (_QWORD *)*((_QWORD *)v2 + 1); i != (_QWORD *)(v2 + 2); i = (_QWORD *)*i )
    {
      if ( *(i - 6) == v3 )
      {
        ++*((_DWORD *)i - 10);
        v5 = (signed __int64)(i - 7);
        break;
      }
    }
  }
  else
  {
    sub_140002E58(
      L"Cache::getCacheEntry: Unable to retrieve entry, key must be positive integer, actual key is",
      0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\cache.cpp",
      228);
  }
  sub_140003B34(v8);
  return v5;
}
// 1400249F0: using guessed type wchar_t aCacheGetcachee[92];

//----- (0000000140018EF0) ----------------------------------------------------
__int64 __fastcall sub_140018EF0(__int64 a1)
{
  return *(unsigned int *)(a1 + 40);
}

//----- (0000000140018F00) ----------------------------------------------------
void __fastcall StartRoutine(PVOID StartContext)
{
  sub_14001881C(1i64);
}

//----- (0000000140018F0C) ----------------------------------------------------
NTSTATUS __fastcall sub_140018F0C(__int64 a1)
{
  __int64 v1; // rdi
  struct _KSEMAPHORE *v2; // rcx
  struct _KEVENT *v3; // rcx
  void (__stdcall *StartRoutine)(PVOID); // rax
  NTSTATUS result; // eax
  PVOID *Object; // rcx
  int v7; // eax
  int v8; // ebx
  struct _LIST_ENTRY *v9; // rcx
  HANDLE ThreadHandle; // [rsp+40h] [rbp-18h]

  ThreadHandle = 0i64;
  v1 = a1;
  v2 = (struct _KSEMAPHORE *)&unk_140035100;
  if ( *(_DWORD *)v1 == 1 )
    v2 = &stru_140035120;
  KeInitializeSemaphore(v2, 0, 0x7FFFFFFF);
  v3 = (struct _KEVENT *)&unk_140035140;
  if ( *(_DWORD *)v1 == 1 )
    v3 = &stru_140035158;
  KeInitializeEvent(v3, SynchronizationEvent, 0);
  StartRoutine = (void (__stdcall *)(PVOID))sub_140018BC0;
  if ( *(_DWORD *)v1 == 1 )
    StartRoutine = (void (__stdcall *)(PVOID))::StartRoutine;
  result = PsCreateSystemThread(&ThreadHandle, 0x1FFFFFu, 0i64, 0i64, 0i64, StartRoutine, 0i64);
  if ( result >= 0 )
  {
    Object = (PVOID *)&qword_140035170;
    if ( *(_DWORD *)v1 == 1 )
      Object = &qword_140035178;
    v7 = ObReferenceObjectByHandle(ThreadHandle, 0, 0i64, 0, Object, 0i64);
    v8 = v7;
    if ( v7 >= 0 )
    {
      ZwClose(ThreadHandle);
      v9 = (struct _LIST_ENTRY *)&unk_140035180;
      if ( *(_DWORD *)v1 == 1 )
        v9 = &ListHead;
      InitializeListHead(v9);
      *(_BYTE *)(v1 + 52) = 1;
    }
    else
    {
      sub_140002E58(
        L"ObReferenceObjectByHandle failed",
        v7,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\cache.cpp",
        749);
    }
    result = v8;
  }
  return result;
}
// 140024BF0: using guessed type wchar_t aObreferenceobj[33];
// 140035170: using guessed type __int64 qword_140035170;

//----- (0000000140019058) ----------------------------------------------------
void __fastcall sub_140019058(__int64 a1, __int64 a2)
{
  unsigned int v2; // eax
  __int64 v3; // rbx
  __int64 v4; // rdi
  int v5; // eax
  bool v6; // zf
  unsigned __int64 v7; // rdx

  v2 = *(_DWORD *)(a2 + 16);
  v3 = a2;
  v4 = a1;
  if ( v2 >= 1 )
  {
    v5 = v2 - 1;
    *(_DWORD *)(a2 + 16) = v5;
    if ( !v5 )
    {
      if ( *(_QWORD *)(a2 + 64) )
      {
        sub_140004F14((_QWORD *)(a2 + 56));
        if ( *(_DWORD *)(v3 + 48) )
        {
          --*(_DWORD *)(v4 + 48);
        }
        else
        {
          v6 = (*(_DWORD *)(v4 + 40))-- == 1;
          if ( v6 )
            *(_BYTE *)(v4 + 53) = 1;
        }
      }
      v7 = *(_QWORD *)(v3 + 24);
      if ( v7 || *(_QWORD *)(v3 + 32) )
      {
        sub_1400191E8((_DWORD *)v4, v7, *(_QWORD *)(v3 + 32));
        *(_QWORD *)(v3 + 24) = 0i64;
        *(_QWORD *)(v3 + 32) = 0i64;
      }
      sub_1400183C4(v3);
    }
  }
}

//----- (00000001400190D8) ----------------------------------------------------
void __fastcall sub_1400190D8(int a1)
{
  struct _LIST_ENTRY *v1; // rdi
  int v2; // ebx
  void *v3; // rsi
  _LIST_ENTRY *v4; // rbx
  bool v5; // al
  signed __int64 v6; // rdx
  bool v7; // r14
  signed __int64 v8; // rbx
  void **v9; // rcx
  void *v10; // rbp
  __int64 v11; // rbx
  __int64 v12[4]; // [rsp+20h] [rbp-48h]

  v1 = (struct _LIST_ENTRY *)&unk_140035180;
  v2 = a1;
  if ( a1 == 1 )
    v1 = &ListHead;
  if ( v1->Flink && !(unsigned __int8)IsListEmpty(v1) )
  {
    v3 = &unk_1400351A0;
    if ( v2 == 1 )
      v3 = &unk_1400351A8;
    while ( 1 )
    {
      sub_14000391C(v12, (__int64)v3);
      if ( (unsigned __int8)IsListEmpty(v1) )
        break;
      v4 = v1->Flink;
      v5 = sub_140004F14(&v1->Flink->Flink);
      v6 = (signed __int64)&v4[-1];
      v7 = v5;
      v8 = -(signed __int64)v4;
      v9 = (void **)(v6 & -(signed __int64)(v8 != 0));
      if ( v6 & -(signed __int64)(v8 != 0) )
      {
        v10 = *v9;
        v11 = *(_QWORD *)((v6 & -(signed __int64)(v8 != 0)) + 8);
        sub_1400183C4((__int64)v9);
        sub_140003B34(v12);
        if ( v10 )
          ObfDereferenceObject(v10);
        if ( v11 )
          sub_1400183C4(v11);
      }
      else
      {
        sub_140003B34(v12);
      }
      if ( v7 )
        return;
    }
    sub_140003B34(v12);
  }
}
// 140004E44: using guessed type __int64 __fastcall IsListEmpty(_QWORD);

//----- (00000001400191E8) ----------------------------------------------------
signed __int64 __fastcall sub_1400191E8(_DWORD *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rsi
  _DWORD *v4; // rbx
  unsigned __int64 v5; // rdi
  __m128 *v6; // rax
  struct _LIST_ENTRY *v8; // rcx
  struct _KSEMAPHORE *v9; // rcx

  v3 = a2;
  v4 = a1;
  v5 = a3;
  v6 = sub_1400181F8(0x20ui64, (__int64)&unk_1400307C0);
  if ( !v6 )
    return 3221225626i64;
  v6->m128_u64[0] = v3;
  v6->m128_u64[1] = v5;
  v8 = (struct _LIST_ENTRY *)&unk_140035180;
  if ( *v4 == 1 )
    v8 = &ListHead;
  sub_140004DE4((__int64)v8, (__m128 *)v6[1].m128_u64);
  v9 = (struct _KSEMAPHORE *)&unk_140035100;
  if ( *v4 == 1 )
    v9 = &stru_140035120;
  KeReleaseSemaphore(v9, 0, 1, 0);
  return 0i64;
}

//----- (0000000140019278) ----------------------------------------------------
__int64 __fastcall sub_140019278(_DWORD *a1, __int64 a2)
{
  _DWORD *v2; // rsi
  __int64 v3; // rbp
  void *v4; // rdx
  _QWORD *i; // rbx
  _QWORD *v6; // r15
  bool v7; // zf
  unsigned __int64 v8; // rdx
  __int64 v10[4]; // [rsp+30h] [rbp-58h]

  v2 = a1;
  v3 = a2;
  v4 = &unk_1400351A0;
  if ( *a1 == 1 )
    v4 = &unk_1400351A8;
  sub_14000391C(v10, (__int64)v4);
  for ( i = (_QWORD *)*((_QWORD *)v2 + 1); i != (_QWORD *)(v2 + 2); i = (_QWORD *)*i )
  {
    if ( v3 && *(i - 7) == v3 )
    {
      v6 = (_QWORD *)i[1];
      sub_140004F14(i);
      v7 = (*((_DWORD *)i - 10))-- == 1;
      if ( v7 )
      {
        v8 = *(i - 4);
        if ( v8 || *(i - 3) )
          sub_1400191E8(v2, v8, *(i - 3));
        sub_1400183C4((__int64)(i - 7));
      }
      else
      {
        sub_140002DD4(
          L"Cache::removeCacheEntry: Attempting to remove entry which is still referenced, moving to \"zombie\" list. Key "
           "(transport endpoint handle):",
          v3,
          0i64,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\cache.cpp",
          201);
        *((_DWORD *)i - 2) = 1;
        *((_DWORD *)i - 1) = 1;
        sub_140004DE4((__int64)(v2 + 6), i);
        ++v2[12];
      }
      v7 = v2[10]-- == 1;
      i = v6;
      if ( v7 )
        *((_BYTE *)v2 + 53) = 1;
    }
  }
  return sub_140003B34(v10);
}
// 1400248D0: using guessed type wchar_t aCacheRemovecac[137];

//----- (0000000140019398) ----------------------------------------------------
LONG_PTR __fastcall sub_140019398(_DWORD *a1)
{
  _DWORD *v1; // rbx
  struct _KEVENT *v2; // rcx
  PVOID v3; // rcx
  PVOID v4; // rcx

  v1 = a1;
  v2 = (struct _KEVENT *)&unk_140035140;
  if ( *v1 == 1 )
    v2 = &stru_140035158;
  KeSetEvent(v2, 0, 0);
  v3 = (PVOID)qword_140035170;
  if ( *v1 == 1 )
    v3 = qword_140035178;
  KeWaitForSingleObject(v3, 0, 0, 0, 0i64);
  v4 = (PVOID)qword_140035170;
  if ( *v1 == 1 )
    v4 = qword_140035178;
  return ObfDereferenceObject(v4);
}
// 140035170: using guessed type __int64 qword_140035170;

//----- (0000000140019408) ----------------------------------------------------
__int64 sub_140019408()
{
  __int64 result; // rax

  while ( 1 )
  {
    result = (unsigned int)dword_1400355B0;
    if ( !dword_1400355B0 )
      break;
    dword_1400355B0 = result - 1;
    sub_14001E1B0((__int64 (*)(void))qword_1400351B0[(signed int)result - 1]);
  }
  return result;
}
// 1400355B0: using guessed type int dword_1400355B0;

//----- (0000000140019438) ----------------------------------------------------
void sub_140019438()
{
  sub_14001944C((__int64 (**)(void))&unk_1400294E0, (unsigned __int64)&unk_1400295B8);
}

//----- (000000014001944C) ----------------------------------------------------
void __fastcall sub_14001944C(__int64 (**a1)(void), unsigned __int64 a2)
{
  __int64 (**v2)(void); // rdi
  unsigned __int64 v3; // rsi
  unsigned __int64 v4; // rbx

  v2 = a1;
  v3 = 0i64;
  v4 = (a2 - (unsigned __int64)a1 + 7) >> 3;
  if ( (unsigned __int64)a1 > a2 )
    v4 = 0i64;
  if ( v4 )
  {
    do
    {
      if ( *v2 )
        sub_14001E1B0(*v2);
      ++v2;
      ++v3;
    }
    while ( v3 < v4 );
  }
}

//----- (00000001400194B0) ----------------------------------------------------
__int64 __fastcall sub_1400194B0(__int64 a1)
{
  __int64 v1; // rdx

  if ( a1 )
  {
    v1 = dword_1400355B0;
    qword_1400351B0[v1] = a1;
    dword_1400355B0 = v1 + 1;
  }
  return 0i64;
}
// 1400355B0: using guessed type int dword_1400355B0;

//----- (00000001400194D4) ----------------------------------------------------
NTSTATUS __fastcall sub_1400194D4(__int64 a1, PVOID *a2, _DWORD *a3)
{
  PVOID *v3; // r14
  __int64 v4; // rbp
  _DWORD *v5; // rsi
  NTSTATUS result; // eax
  int v7; // eax
  unsigned int v8; // ebx
  ACL *v9; // rax
  ACL *v10; // rdi
  NTSTATUS v11; // ebx
  ACL *v12; // rcx
  NTSTATUS v13; // eax
  PVOID v14; // rax
  char SecurityDescriptor; // [rsp+20h] [rbp-58h]

  *a2 = 0i64;
  v3 = a2;
  *a3 = 0;
  v4 = a1;
  v5 = a3;
  result = RtlCreateSecurityDescriptor(&SecurityDescriptor, 1u);
  if ( result >= 0 )
  {
    result = RtlSetOwnerSecurityDescriptor(&SecurityDescriptor, *(_QWORD *)(SeExports + 264i64), 0i64);
    if ( result >= 0 )
    {
      result = RtlSetGroupSecurityDescriptor(&SecurityDescriptor, *(_QWORD *)(SeExports + 264i64), 0i64);
      if ( result >= 0 )
      {
        v7 = RtlLengthSid(v4);
        v8 = v7 + 16;
        v9 = (ACL *)ExAllocatePoolWithTag((POOL_TYPE)512, (unsigned int)(v7 + 16), 0x53554349u);
        v10 = v9;
        if ( !v9 )
          return -1073741823;
        v11 = RtlCreateAcl(v9, v8, 2i64);
        v12 = v10;
        if ( v11 < 0 )
          goto LABEL_19;
        v11 = RtlAddAccessAllowedAce(v10, 2i64, 131073i64, v4);
        if ( v11 >= 0 )
        {
          v11 = RtlSetDaclSecurityDescriptor(&SecurityDescriptor, 1u, v10, 0);
          if ( v11 >= 0 )
          {
            if ( RtlValidSecurityDescriptor(&SecurityDescriptor) )
            {
              v13 = RtlAbsoluteToSelfRelativeSD(&SecurityDescriptor, 0i64, v5);
              if ( v13 != -1073741789 )
              {
                v11 = v13;
                goto LABEL_18;
              }
              v14 = ExAllocatePoolWithTag((POOL_TYPE)512, (unsigned int)*v5, 0x53554349u);
              *v3 = v14;
              if ( v14 )
              {
                v11 = RtlAbsoluteToSelfRelativeSD(&SecurityDescriptor, v14, v5);
                if ( v11 >= 0 )
                {
                  v11 = 0;
                }
                else
                {
                  *v5 = 0;
                  ExFreePoolWithTag(*v3, 0);
                  *v3 = 0i64;
                }
                goto LABEL_18;
              }
              *v5 = 0;
            }
            v11 = -1073741823;
          }
        }
LABEL_18:
        v12 = v10;
LABEL_19:
        ExFreePoolWithTag(v12, 0);
        return v11;
      }
    }
  }
  return result;
}
// 1400292B0: using guessed type __int64 __fastcall RtlLengthSid(_QWORD);
// 1400292C0: using guessed type __int64 __fastcall RtlCreateAcl(_QWORD, _QWORD, _QWORD);
// 1400292E0: using guessed type __int64 __fastcall RtlAddAccessAllowedAce(_QWORD, _QWORD, _QWORD, _QWORD);
// 140029460: using guessed type __int64 __fastcall RtlSetOwnerSecurityDescriptor(_QWORD, _QWORD, _QWORD);
// 140029468: using guessed type __int64 __fastcall RtlSetGroupSecurityDescriptor(_QWORD, _QWORD, _QWORD);
// 140029470: using guessed type __int64 __fastcall RtlAbsoluteToSelfRelativeSD(_QWORD, _QWORD, _QWORD);

//----- (0000000140019690) ----------------------------------------------------
bool sub_140019690()
{
  return qword_1400355B8 != 0;
}
// 1400355B8: using guessed type __int64 qword_1400355B8;

//----- (000000014001969C) ----------------------------------------------------
bool __fastcall sub_14001969C(int a1, __m128i *a2)
{
  __m128i *v2; // rbx
  int v3; // edi
  bool result; // al
  int v5; // eax

  v2 = a2;
  v3 = a1;
  result = sub_140019690();
  if ( result )
  {
    v5 = sub_14001E1B0(*(__int64 (**)(void))qword_1400355B8);
    if ( v5 >= 0 )
    {
      result = 1;
    }
    else
    {
      sub_140002E58(
        L"Failed to get SPID for PID",
        v5,
        v3,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\sedinterface.cpp",
        69);
      result = 0;
      _mm_storeu_si128(v2, (__m128i)0i64);
    }
  }
  return result;
}
// 140024DD0: using guessed type wchar_t aFailedToGetSpi[27];
// 1400355B8: using guessed type __int64 qword_1400355B8;

//----- (0000000140019714) ----------------------------------------------------
char __fastcall sub_140019714(int a1)
{
  int v1; // ebx
  int v2; // eax
  unsigned int v4; // [rsp+44h] [rbp-34h]
  __int64 v5; // [rsp+48h] [rbp-30h]
  char v6; // [rsp+50h] [rbp-28h]

  v1 = a1;
  if ( sub_140019690() && sub_14001969C(v1, (__m128i *)&v6) )
  {
    v4 = 0;
    v5 = 0i64;
    v2 = sub_14001E1B0(*(__int64 (**)(void))(qword_1400355B8 + 8));
    if ( v2 >= 0 && v4 >= 1 )
      return 0;
    sub_140002E58(
      L"IsAttestedExe: Failed to get Attested Exe Info for PID",
      v2,
      v1,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\sedinterface.cpp",
      104);
  }
  return 0;
}
// 140024E10: using guessed type wchar_t aIsattestedexeF[55];
// 1400355B8: using guessed type __int64 qword_1400355B8;

//----- (00000001400197DC) ----------------------------------------------------
void sub_1400197DC()
{
  int v0; // eax

  if ( Handle != (HANDLE)-1i64 )
  {
    v0 = ZwClose(Handle);
    if ( v0 < 0 )
      sub_140002E58(
        L"Failed to close connection to SED",
        v0,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\sedinterface.cpp",
        49);
    else
      Handle = (HANDLE)-1i64;
  }
}
// 140024D80: using guessed type wchar_t aFailedToCloseC[34];

//----- (0000000140019828) ----------------------------------------------------
_QWORD *__fastcall sub_140019828(_QWORD *a1, int a2, __int64 a3)
{
  int v3; // edi
  int v4; // esi
  _QWORD *v5; // rbx
  int v6; // eax
  unsigned int v8; // [rsp+40h] [rbp-38h]
  __int64 v9; // [rsp+48h] [rbp-30h]
  char v10; // [rsp+50h] [rbp-28h]

  a1[1] = 0i64;
  v3 = a3;
  v4 = a2;
  *a1 = a3;
  v5 = a1;
  if ( sub_140019690() && sub_14001969C(v4, (__m128i *)&v10) )
  {
    v8 = 0;
    v9 = 0i64;
    v6 = sub_14001E1B0(*(__int64 (**)(void))(qword_1400355B8 + 8));
    if ( v6 < 0 || v8 < 0x10 )
      sub_140002E58(
        L"GetSophosTid: Failed to get Sophos TID",
        v6,
        v3,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\sedinterface.cpp",
        139);
  }
  return v5;
}
// 140024E80: using guessed type wchar_t aGetsophostidFa[39];
// 1400355B8: using guessed type __int64 qword_1400355B8;

//----- (0000000140019900) ----------------------------------------------------
int sub_140019900()
{
  int v0; // eax
  int result; // eax

  v0 = sub_140001910(&Handle);
  if ( v0 >= 0 )
  {
    result = sub_14000197C(Handle, 268435459, &qword_1400355B8);
    if ( result < 0 )
    {
      result = sub_140002E58(
                 L"SedInterface_Initialise: Failed to open V2 interface to SED",
                 result,
                 0,
                 (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\sedinterface.cpp",
                 28);
      qword_1400355B8 = 0i64;
    }
  }
  else
  {
    result = sub_140002E58(
               L"SedInterface_Initialise: Failed to connect to SED",
               v0,
               0,
               (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\include\\sedinterface.cpp",
               18);
    Handle = (HANDLE)-1i64;
  }
  return result;
}
// 140024C90: using guessed type wchar_t aSedinterfaceIn[50];
// 140024D00: using guessed type wchar_t aSedinterfaceIn_0[60];
// 1400355B8: using guessed type __int64 qword_1400355B8;

//----- (0000000140019988) ----------------------------------------------------
__m128i *__fastcall sub_140019988(unsigned __int64 a1, __m128i *a2)
{
  return sub_14001E2C0(a2, a1, 0x7F8ui64);
}

//----- (000000014001999C) ----------------------------------------------------
__m128i *__fastcall sub_14001999C(unsigned __int64 a1, char a2)
{
  char v2; // bl
  __m128i *result; // rax

  v2 = a2;
  result = sub_140019988(a1, (__m128i *)qword_140035600);
  byte_140035DF8 = v2;
  return result;
}
// 140035DF8: using guessed type char byte_140035DF8;

//----- (00000001400199C0) ----------------------------------------------------
void sub_1400199C0()
{
  signed int v0; // ebx
  int *v1; // rdi

  sub_14001B0D8();
  v0 = 0;
  byte_1400355F9 = 0;
  sub_140005630(&qword_1400307F8, (__int64)&unk_140029FC8);
  if ( (unsigned __int8)byte_140030810 > 0u )
  {
    v1 = (int *)&unk_140030800;
    do
    {
      sub_1400064E0(*v1);
      ++v1;
      ++v0;
    }
    while ( v0 < (unsigned __int8)byte_140030810 );
  }
}
// 1400307F8: using guessed type __int64 qword_1400307F8;
// 140030810: using guessed type char byte_140030810;
// 1400355F9: using guessed type char byte_1400355F9;

//----- (0000000140019A1C) ----------------------------------------------------
signed __int64 sub_140019A1C()
{
  signed __int64 result; // rax

  if ( qword_1400307F8 == -1 )
    result = sub_140005C74(&qword_1400307F8, (__m128i *)&unk_140029FC8);
  else
    result = 0i64;
  return result;
}
// 1400307F8: using guessed type __int64 qword_1400307F8;

//----- (0000000140019A3C) ----------------------------------------------------
signed __int64 __fastcall sub_140019A3C(__int64 a1)
{
  __int64 v1; // rdi
  signed __int64 result; // rax
  unsigned int v3; // ebx
  int v4; // eax
  __int64 v5; // [rsp+38h] [rbp-80h]
  __int64 v6; // [rsp+38h] [rbp-80h]
  __int64 v7; // [rsp+38h] [rbp-80h]
  __int64 v8; // [rsp+38h] [rbp-80h]
  __int64 v9; // [rsp+58h] [rbp-60h]
  __int64 v10; // [rsp+58h] [rbp-60h]
  __int64 v11; // [rsp+58h] [rbp-60h]
  __int64 v12; // [rsp+58h] [rbp-60h]
  int v13; // [rsp+90h] [rbp-28h]
  int v14; // [rsp+94h] [rbp-24h]

  v1 = a1;
  v13 = 6;
  v14 = 17;
  LOBYTE(v9) = 2;
  LODWORD(v5) = 20483;
  result = sub_140005FF0(
             qword_1400307F8,
             (__int64)&unk_140029FC8,
             11,
             (__int64)L"Self-Isolation Outbound TCP&UDP IPv4 callout",
             (__int64)L"Self-Isolation for Outbound TCP&UDP IPv4",
             (__int64)L"Self-Isolation Outbound TCP&UDP IPv4 filter",
             (__int64)L"Self-Isolation for Outbound TCP&UDP IPv4",
             v5,
             1,
             (__m128i *)&xmmword_14002D860,
             (__int64)&v13,
             v9,
             (__m128i *)&unk_14002D130,
             (__m128i *)&unk_14002A008,
             (__m128i *)&unk_14002A0C8,
             (__int64)sub_140019D80,
             (__int64)sub_140006910,
             a1);
  v3 = 0;
  if ( (signed int)result >= 0 )
  {
    LOBYTE(v10) = 2;
    LODWORD(v6) = 20483;
    result = sub_140005FF0(
               qword_1400307F8,
               (__int64)&unk_140029FC8,
               12,
               (__int64)L"Self-Isolation Outbound TCP&UDP IPv6 callout",
               (__int64)L"Self-Isolation for Outbound TCP&UDP IPv6",
               (__int64)L"Self-Isolation Outbound TCP&UDP IPv6 filter",
               (__int64)L"Self-Isolation for Outbound TCP&UDP IPv6",
               v6,
               1,
               (__m128i *)&xmmword_14002D860,
               (__int64)&v13,
               v10,
               (__m128i *)&unk_14002D150,
               (__m128i *)&unk_14002A008,
               (__m128i *)&unk_14002A0D8,
               (__int64)sub_140019D80,
               (__int64)sub_140006910,
               v1);
    if ( (signed int)result >= 0 )
    {
      LOBYTE(v11) = 2;
      LODWORD(v7) = 20483;
      result = sub_140005FF0(
                 qword_1400307F8,
                 (__int64)&unk_140029FC8,
                 13,
                 (__int64)L"Self-Isolation Inbound TCP&UDP IPv4 callout",
                 (__int64)L"Self-Isolation for Inbound TCP&UDP IPv4",
                 (__int64)L"Self-Isolation Inbound TCP&UDP IPv4 filter",
                 (__int64)L"Self-Isolation for Inbound TCP&UDP IPv4",
                 v7,
                 1,
                 (__m128i *)&xmmword_14002D860,
                 (__int64)&v13,
                 v11,
                 (__m128i *)&unk_14002D0F0,
                 (__m128i *)&unk_14002A008,
                 (__m128i *)"C=v",
                 (__int64)sub_140019D80,
                 (__int64)sub_140006910,
                 v1);
      if ( (signed int)result >= 0 )
      {
        LOBYTE(v12) = 2;
        LODWORD(v8) = 20483;
        v4 = sub_140005FF0(
               qword_1400307F8,
               (__int64)&unk_140029FC8,
               14,
               (__int64)L"Self-Isolation Inbound TCP&UDP IPv6 callout",
               (__int64)L"Self-Isolation for Inbound TCP&UDP IPv6",
               (__int64)L"Self-Isolation Inbound TCP&UDP IPv6 filter",
               (__int64)L"Self-Isolation for Inbound TCP&UDP IPv6",
               v8,
               1,
               (__m128i *)&xmmword_14002D860,
               (__int64)&v13,
               v12,
               (__m128i *)&unk_14002D110,
               (__m128i *)&unk_14002A008,
               (__m128i *)&unk_14002A0F8,
               (__int64)sub_140019D80,
               (__int64)sub_140006910,
               v1);
        if ( v4 < 0 )
          v3 = v4;
        result = v3;
      }
    }
  }
  return result;
}
// 140024FA0: using guessed type wchar_t aSelfIsolationF[41];
// 140025000: using guessed type wchar_t aSelfIsolationO_0[44];
// 140025060: using guessed type wchar_t aSelfIsolationO[45];
// 1400250C0: using guessed type wchar_t aSelfIsolationF_0[41];
// 140025120: using guessed type wchar_t aSelfIsolationO_2[44];
// 140025180: using guessed type wchar_t aSelfIsolationO_1[45];
// 1400251E0: using guessed type wchar_t aSelfIsolationF_1[40];
// 140025230: using guessed type wchar_t aSelfIsolationI_0[43];
// 140025290: using guessed type wchar_t aSelfIsolationI[44];
// 1400252F0: using guessed type wchar_t aSelfIsolationF_2[40];
// 140025340: using guessed type wchar_t aSelfIsolationI_2[43];
// 1400253A0: using guessed type wchar_t aSelfIsolationI_1[44];
// 14002D860: using guessed type __int128 xmmword_14002D860;
// 1400307F8: using guessed type __int64 qword_1400307F8;

//----- (0000000140019D34) ----------------------------------------------------
__int64 sub_140019D34()
{
  __int64 result; // rax

  if ( byte_1400355F9 )
    return 0i64;
  result = sub_140006340(
             qword_1400307F8,
             (__int64)&unk_140029FC8,
             (__m128i *)&unk_14002A008,
             (__int64)L"Sophos Endpoint Self-Isolation Sub-Layer",
             (__int64)L"Sub-Layer for use by Sophos Self-Isolation callouts");
  byte_1400355F9 = (signed int)result >= 0;
  return result;
}
// 140024ED0: using guessed type wchar_t aSubLayerForUse[52];
// 140024F40: using guessed type wchar_t aSophosEndpoint[41];
// 1400307F8: using guessed type __int64 qword_1400307F8;
// 1400355F9: using guessed type char byte_1400355F9;

//----- (0000000140019D80) ----------------------------------------------------
_DWORD *__fastcall sub_140019D80(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, _DWORD *a7)
{
  __int64 v7; // rbx
  _DWORD *result; // rax

  v7 = a2;
  if ( sub_140004E14(*(_QWORD *)(a2 + 64)) )
  {
    sub_140002DD4(
      L"Sophos process excluded from isolation",
      0i64,
      *(_QWORD *)(v7 + 64),
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\selfisolation.cpp",
      363);
LABEL_3:
    result = a7;
    *a7 = 4098;
    return result;
  }
  if ( byte_1400355F8 && sub_140017CE0(*(_QWORD *)(*(_QWORD *)(v7 + 48) + 8i64), **(_DWORD **)(v7 + 48)) )
    goto LABEL_3;
  result = a7;
  result[6] &= 0xFFFFFFFE;
  *a7 = 4097;
  return result;
}
// 1400254E0: using guessed type wchar_t aSophosProcessE[39];
// 1400355F8: using guessed type char byte_1400355F8;

//----- (0000000140019E00) ----------------------------------------------------
LONG __fastcall sub_140019E00(char a1)
{
  char v1; // bl
  PRKMUTEX v3; // [rsp+20h] [rbp-18h]

  v1 = a1;
  sub_140017E6C(&v3, &unk_1400355C0);
  byte_1400355F8 = v1;
  return sub_140017ECC(&v3);
}
// 1400355F8: using guessed type char byte_1400355F8;

//----- (0000000140019E4C) ----------------------------------------------------
__int64 __fastcall sub_140019E4C(unsigned __int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  unsigned __int64 v3; // rbx
  unsigned int v4; // ebx
  char v6; // [rsp+30h] [rbp-D0h]
  int v7; // [rsp+34h] [rbp-CCh]
  PRKMUTEX v8; // [rsp+38h] [rbp-C8h]
  char v9; // [rsp+40h] [rbp-C0h]
  __m128 v10[128]; // [rsp+60h] [rbp-A0h]

  v2 = a2;
  v3 = a1;
  sub_140017E6C(&v8, &unk_1400355C0);
  v7 = sub_14001B144(v3, v2);
  v4 = v7;
  if ( v7 >= 0 )
  {
    if ( byte_1400355FA )
    {
      sub_140017E18((__int64)&v9, &qword_1400307F8, &v7, 0i64);
      v4 = v7;
      if ( v7 < 0
        || (sub_14001E1C0(v10, 0, 0x7F8ui64),
            v6 = 0,
            v7 = sub_14001AF08(
                   qword_1400307F8,
                   (__int64)&unk_140029FC8,
                   (__m128i *)&unk_14002A008,
                   v10,
                   (unsigned __int8 *)&v6),
            v4 = v7,
            v7 < 0)
        || (v7 = sub_140017ED8((_QWORD **)&v9), v4 = v7, v7 < 0) )
      {
        sub_140017E9C((__int64)&v9);
        goto LABEL_8;
      }
      sub_14001999C((unsigned __int64)v10, v6);
      sub_140017E9C((__int64)&v9);
    }
    v4 = 0;
  }
LABEL_8:
  sub_140017ECC(&v8);
  return v4;
}
// 1400307F8: using guessed type __int64 qword_1400307F8;
// 1400355FA: using guessed type char byte_1400355FA;

//----- (0000000140019F90) ----------------------------------------------------
void sub_140019F90()
{
  KeInitializeMutex((PRKMUTEX)&unk_1400355C0, 0);
}

//----- (0000000140019FA0) ----------------------------------------------------
__int64 __fastcall sub_140019FA0(__int64 a1)
{
  __int64 v1; // rdi
  unsigned int v2; // ebx
  int v3; // eax
  int v4; // eax
  char v6; // [rsp+30h] [rbp-D0h]
  int v7; // [rsp+34h] [rbp-CCh]
  PRKMUTEX v8; // [rsp+38h] [rbp-C8h]
  char v9; // [rsp+40h] [rbp-C0h]
  __m128 v10[128]; // [rsp+60h] [rbp-A0h]

  v1 = a1;
  sub_140017E6C(&v8, &unk_1400355C0);
  v2 = 0;
  v7 = 0;
  if ( !byte_1400355FA )
  {
    v3 = sub_140019A1C();
    v7 = v3;
    if ( v3 >= 0 )
    {
      sub_140017E18((__int64)&v9, &qword_1400307F8, &v7, (__int64)sub_1400199C0);
      v4 = v7;
      if ( v7 < 0 )
        goto LABEL_16;
      v4 = sub_140019D34();
      v7 = v4;
      if ( v4 < 0 )
        goto LABEL_16;
      v4 = sub_14001AADC(qword_1400307F8, (__int64)&unk_140029FC8, (__m128i *)&unk_14002A008);
      v7 = v4;
      if ( v4 < 0 )
        goto LABEL_16;
      sub_14001E1C0(v10, 0, 0x7F8ui64);
      v6 = 0;
      v4 = sub_14001AF08(
             qword_1400307F8,
             (__int64)&unk_140029FC8,
             (__m128i *)&unk_14002A008,
             v10,
             (unsigned __int8 *)&v6);
      v7 = v4;
      if ( v4 < 0 || (v4 = sub_140019A3C(v1), v7 = v4, v4 < 0) || (v4 = sub_140017ED8((_QWORD **)&v9), v7 = v4, v4 < 0) )
      {
LABEL_16:
        v2 = v4;
      }
      else
      {
        sub_14001999C((unsigned __int64)v10, v6);
        byte_1400355FA = 1;
        sub_140002E58(
          L"Endpoint self-isolation enabled",
          0,
          0,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\selfisolation.cpp",
          259);
      }
      sub_140017E9C((__int64)&v9);
    }
    else
    {
      v2 = v3;
    }
  }
  sub_140017ECC(&v8);
  return v2;
}
// 140025450: using guessed type wchar_t aEndpointSelfIs_0[32];
// 1400307F8: using guessed type __int64 qword_1400307F8;
// 1400355FA: using guessed type char byte_1400355FA;

//----- (000000014001A144) ----------------------------------------------------
__int64 sub_14001A144()
{
  signed int v0; // ebx
  int *v1; // rdi
  PRKMUTEX v3; // [rsp+30h] [rbp-18h]

  sub_140017E6C(&v3, &unk_1400355C0);
  if ( qword_1400307F8 != -1 )
  {
    v0 = 0;
    if ( byte_140030810 )
    {
      v1 = (int *)&unk_140030800;
      do
      {
        sub_140006454(qword_1400307F8, *v1);
        ++v1;
        ++v0;
      }
      while ( v0 < (unsigned __int8)byte_140030810 );
    }
    sub_14001B028(qword_1400307F8);
    FwpmSubLayerDeleteByKey0(qword_1400307F8, &unk_14002A008);
    byte_1400355F9 = 0;
    sub_140005630(&qword_1400307F8, (__int64)&unk_140029FC8);
  }
  byte_1400355FA = 0;
  sub_140002E58(
    L"Endpoint self-isolation disabled",
    0,
    0,
    (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\selfisolation.cpp",
    286);
  sub_140017ECC(&v3);
  return 0i64;
}
// 14001DD14: using guessed type __int64 __fastcall FwpmSubLayerDeleteByKey0(_QWORD, _QWORD);
// 140025490: using guessed type wchar_t aEndpointSelfIs[33];
// 1400307F8: using guessed type __int64 qword_1400307F8;
// 140030810: using guessed type char byte_140030810;
// 1400355F9: using guessed type char byte_1400355F9;
// 1400355FA: using guessed type char byte_1400355FA;

//----- (000000014001A22C) ----------------------------------------------------
__int64 __fastcall sub_14001A22C(__int64 a1, __int16 a2, int a3, char a4, __int64 a5, __int16 a6, __int64 a7, __int64 a8, __int64 a9, char a10, unsigned __int8 a11, __int64 a12, __int64 a13, __int64 a14)
{
  char v14; // r12
  int v15; // esi
  __int16 v16; // r15
  __int64 v17; // r14
  _QWORD *v18; // rax
  _QWORD *v19; // rax
  __int64 v20; // rax
  __int64 v22; // [rsp+30h] [rbp-20h]
  __int64 v23; // [rsp+38h] [rbp-18h]

  v14 = a4;
  v15 = a3;
  *(_DWORD *)a1 = 0;
  v16 = a2;
  v17 = a1;
  v22 = a7;
  v23 = a9;
  sub_14001E1C0((__m128 *)(a1 + 4), 0, 0x164ui64);
  *(_DWORD *)(v17 + 364) = v15;
  *(_WORD *)(v17 + 362) = v16;
  *(_BYTE *)(v17 + 360) = 0;
  *(_DWORD *)(v17 + 368) = 0;
  *(_QWORD *)(v17 + 372) = 0i64;
  *(_QWORD *)(v17 + 380) = 0i64;
  *(_DWORD *)(v17 + 388) = 0;
  *(_QWORD *)(v17 + 392) = 0i64;
  *(_QWORD *)(v17 + 400) = 0i64;
  v18 = (_QWORD *)(v17 + 408);
  *v18 = 0i64;
  v18[1] = 0i64;
  v19 = (_QWORD *)(v17 + 424);
  *v19 = 0i64;
  v19[1] = 0i64;
  *(_QWORD *)(v17 + 440) = 0i64;
  if ( v14 )
  {
    _mm_storeu_si128((__m128i *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360)), (__m128i)xmmword_14002D860);
    *(_DWORD *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360) + 16) = 0;
    *(_DWORD *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360) + 24) = 1;
    *(_BYTE *)(v17 + 40i64 * (unsigned __int8)(*(_BYTE *)(v17 + 360))++ + 32) = v14;
  }
  if ( (_WORD)a5 )
  {
    _mm_storeu_si128((__m128i *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360)), (__m128i)xmmword_14002D870);
    *(_DWORD *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360) + 16) = 0;
    *(_DWORD *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360) + 24) = 2;
    *(_WORD *)(v17 + 40i64 * (unsigned __int8)(*(_BYTE *)(v17 + 360))++ + 32) = a5;
  }
  if ( a6 )
  {
    _mm_storeu_si128((__m128i *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360)), (__m128i)xmmword_14002D880);
    *(_DWORD *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360) + 16) = 0;
    *(_DWORD *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360) + 24) = 2;
    *(_WORD *)(v17 + 40i64 * (unsigned __int8)(*(_BYTE *)(v17 + 360))++ + 32) = a6;
  }
  if ( v16 == 2 )
  {
    if ( (_DWORD)a7 )
      sub_14001A714(v17, (__m128i *)&unk_14002D630, &v22, a8, (_DWORD *)(v17 + 368));
    if ( (_DWORD)a9 )
      sub_14001A714(v17, (__m128i *)&unk_14002D640, &v23, a10, (_DWORD *)(v17 + 388));
  }
  else if ( v16 == 23 )
  {
    if ( a7 )
      sub_14001A7C0(v17, (__m128i *)&unk_14002D630, (__m128i **)&v22, a8, (__m128i *)(v17 + 368));
    if ( a9 )
      sub_14001A7C0(v17, (__m128i *)&unk_14002D640, (__m128i **)&v23, a10, (__m128i *)(v17 + 388));
  }
  if ( a11 )
  {
    _mm_storeu_si128((__m128i *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360)), (__m128i)xmmword_14002D790);
    *(_DWORD *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360) + 16) = 0;
    *(_DWORD *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360) + 24) = 3;
    *(_DWORD *)(v17 + 40i64 * (unsigned __int8)(*(_BYTE *)(v17 + 360))++ + 32) = a11;
    _mm_storeu_si128((__m128i *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360)), (__m128i)xmmword_14002D7A0);
    *(_DWORD *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360) + 16) = 0;
    *(_DWORD *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360) + 24) = 3;
    *(_DWORD *)(v17 + 40i64 * (unsigned __int8)(*(_BYTE *)(v17 + 360))++ + 32) = a11;
  }
  if ( a12 && a13 )
  {
    _mm_storeu_si128((__m128i *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360)), (__m128i)xmmword_14002D960);
    *(_DWORD *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360) + 16) = 0;
    *(_DWORD *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360) + 24) = 12;
    v20 = *(unsigned __int8 *)(v17 + 360);
    *(_DWORD *)(v17 + 408) = a13;
    *(_QWORD *)(v17 + 416) = a12;
    *(_QWORD *)(v17 + 40 * v20 + 32) = v17 + 408;
    ++*(_BYTE *)(v17 + 360);
  }
  if ( a14 && sub_1400194D4(a14, (PVOID *)(v17 + 440), &v22) >= 0 )
  {
    *(_DWORD *)(v17 + 424) = v22;
    *(_QWORD *)(v17 + 432) = *(_QWORD *)(v17 + 440);
    _mm_storeu_si128((__m128i *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360)), (__m128i)xmmword_14002D980);
    *(_DWORD *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360) + 16) = 0;
    *(_DWORD *)(v17 + 40i64 * *(unsigned __int8 *)(v17 + 360) + 24) = 14;
    *(_QWORD *)(v17 + 40i64 * (unsigned __int8)(*(_BYTE *)(v17 + 360))++ + 32) = v17 + 424;
  }
  return v17;
}
// 14002D790: using guessed type __int128 xmmword_14002D790;
// 14002D7A0: using guessed type __int128 xmmword_14002D7A0;
// 14002D860: using guessed type __int128 xmmword_14002D860;
// 14002D870: using guessed type __int128 xmmword_14002D870;
// 14002D880: using guessed type __int128 xmmword_14002D880;
// 14002D960: using guessed type __int128 xmmword_14002D960;
// 14002D980: using guessed type __int128 xmmword_14002D980;

//----- (000000014001A6C0) ----------------------------------------------------
void __fastcall sub_14001A6C0(__int64 a1)
{
  void *v1; // rcx

  v1 = *(void **)(a1 + 440);
  if ( v1 )
    ExFreePoolWithTag(v1, 0);
}

//----- (000000014001A6E0) ----------------------------------------------------
void *__fastcall sub_14001A6E0(__int64 a1, char a2)
{
  char v2; // bl
  void *v3; // rdi

  v2 = a2;
  v3 = (void *)a1;
  sub_14001A6C0(a1);
  if ( v2 & 1 )
    sub_140007714(v3);
  return v3;
}

//----- (000000014001A714) ----------------------------------------------------
__int64 __fastcall sub_14001A714(__int64 a1, __m128i *a2, _DWORD *a3, char a4, _DWORD *a5)
{
  unsigned int v5; // eax
  __int64 result; // rax

  _mm_storeu_si128((__m128i *)(a1 + 40i64 * *(unsigned __int8 *)(a1 + 360)), *a2);
  *(_DWORD *)(a1 + 40i64 * *(unsigned __int8 *)(a1 + 360) + 16) = 0;
  if ( (unsigned __int8)(a4 - 1) > 0x1Fu )
  {
    *(_DWORD *)(a1 + 40i64 * *(unsigned __int8 *)(a1 + 360) + 24) = 3;
    result = (unsigned int)*a3;
    *(_DWORD *)(a1 + 40i64 * *(unsigned __int8 *)(a1 + 360) + 32) = result;
  }
  else
  {
    *a5 = *a3;
    v5 = ~(0xFFFFFFFF >> a4);
    if ( a4 == 32 )
      v5 = 0;
    a5[1] = v5;
    *(_DWORD *)(a1 + 40i64 * *(unsigned __int8 *)(a1 + 360) + 24) = 256;
    result = *(unsigned __int8 *)(a1 + 360);
    *(_QWORD *)(a1 + 40 * result + 32) = a5;
  }
  ++*(_BYTE *)(a1 + 360);
  return result;
}

//----- (000000014001A7C0) ----------------------------------------------------
__int64 __fastcall sub_14001A7C0(__int64 a1, __m128i *a2, __m128i **a3, __int8 a4, __m128i *a5)
{
  __int64 result; // rax

  _mm_storeu_si128((__m128i *)(a1 + 40i64 * *(unsigned __int8 *)(a1 + 360)), *a2);
  *(_DWORD *)(a1 + 40i64 * *(unsigned __int8 *)(a1 + 360) + 16) = 0;
  if ( (unsigned __int8)(a4 - 1) > 0x7Fu )
  {
    *(_DWORD *)(a1 + 40i64 * *(unsigned __int8 *)(a1 + 360) + 24) = 11;
    _mm_storeu_si128(a5, **a3);
  }
  else
  {
    a5[1].m128i_i8[0] = a4;
    _mm_storeu_si128(a5, **a3);
    *(_DWORD *)(a1 + 40i64 * *(unsigned __int8 *)(a1 + 360) + 24) = 257;
  }
  result = *(unsigned __int8 *)(a1 + 360);
  *(_QWORD *)(a1 + 40 * result + 32) = a5;
  ++*(_BYTE *)(a1 + 360);
  return result;
}

//----- (000000014001A850) ----------------------------------------------------
__int64 __fastcall sub_14001A850(__int64 a1, __int64 a2, __int64 a3, __m128i *a4, __int64 a5, unsigned __int8 *a6, unsigned __int8 a7, _QWORD *a8)
{
  __m128i *v8; // r15
  __int64 v9; // r12
  __int64 v10; // r13
  __int64 v11; // rdi
  __int16 v12; // ax
  __int64 result; // rax
  __int16 v14; // ax
  __int64 v15; // [rsp+40h] [rbp-38h]

  v8 = a4;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  if ( !a5 )
    return 3221225485i64;
  if ( *(_DWORD *)(a1 + 364) != 1 )
  {
    v12 = *(_WORD *)(a1 + 362);
    if ( v12 != 23 )
    {
      if ( *a6 >= a7 )
        return 3221225485i64;
      LODWORD(v15) = *(unsigned __int8 *)(a1 + 360);
      result = sub_1400051FC(
                 a2,
                 a3,
                 a5 + 8i64 * *a6,
                 (__int64)L"Self-Isolation exclusion IPv4 outbound",
                 (__int64)qword_140022D10,
                 4098,
                 *a8,
                 a1,
                 v15,
                 (__m128i *)&unk_14002D130,
                 a4,
                 0i64);
      if ( (signed int)result < 0 )
        return result;
      ++*a6;
      v12 = *(_WORD *)(v11 + 362);
    }
    if ( v12 != 2 )
    {
      if ( *a6 >= a7 )
        return 3221225485i64;
      LODWORD(v15) = *(unsigned __int8 *)(v11 + 360);
      result = sub_1400051FC(
                 v10,
                 v9,
                 a5 + 8i64 * *a6,
                 (__int64)L"Self-Isolation exclusion IPv6 outbound",
                 (__int64)qword_140022D10,
                 4098,
                 *a8,
                 v11,
                 v15,
                 (__m128i *)&unk_14002D150,
                 v8,
                 0i64);
      if ( (signed int)result < 0 )
        return result;
      ++*a6;
    }
  }
  if ( !*(_DWORD *)(v11 + 364) )
    goto LABEL_20;
  v14 = *(_WORD *)(v11 + 362);
  if ( v14 != 23 )
  {
    if ( *a6 >= a7 )
      return 3221225485i64;
    LODWORD(v15) = *(unsigned __int8 *)(v11 + 360);
    result = sub_1400051FC(
               v10,
               v9,
               a5 + 8i64 * *a6,
               (__int64)L"Self-Isolation exclusion IPv4 inbound",
               (__int64)qword_140022D10,
               4098,
               *a8,
               v11,
               v15,
               (__m128i *)&unk_14002D0F0,
               v8,
               0i64);
    if ( (signed int)result < 0 )
      return result;
    ++*a6;
    v14 = *(_WORD *)(v11 + 362);
  }
  if ( v14 == 2 )
  {
LABEL_20:
    --*a8;
    return 0i64;
  }
  if ( *a6 < a7 )
  {
    LODWORD(v15) = *(unsigned __int8 *)(v11 + 360);
    result = sub_1400051FC(
               v10,
               v9,
               a5 + 8i64 * *a6,
               (__int64)L"Self-Isolation exclusion IPv6 inbound",
               (__int64)qword_140022D10,
               4098,
               *a8,
               v11,
               v15,
               (__m128i *)&unk_14002D110,
               v8,
               0i64);
    if ( (signed int)result < 0 )
      return result;
    ++*a6;
    goto LABEL_20;
  }
  return 3221225485i64;
}
// 140022D10: using guessed type __int64 qword_140022D10[2];
// 140025530: using guessed type wchar_t aSelfIsolationE[39];
// 140025580: using guessed type wchar_t aSelfIsolationE_0[39];
// 1400255D0: using guessed type wchar_t aSelfIsolationE_1[38];
// 140025620: using guessed type wchar_t aSelfIsolationE_2[38];

//----- (000000014001AADC) ----------------------------------------------------
__int64 __fastcall sub_14001AADC(__int64 a1, __int64 a2, __m128i *a3)
{
  int v3; // ebx
  __m128i *v4; // r15
  __int64 v5; // r14
  __int64 v6; // rsi
  __int64 v7; // rdi
  int v8; // ebx
  const wchar_t *v9; // rcx
  int v10; // eax
  const UNICODE_STRING *v11; // rax
  __int64 v13; // ST60_8
  __int64 v14; // ST58_8
  __int64 v15; // ST38_8
  __int64 v16; // ST20_8
  __int64 v17; // ST38_8
  __int64 v18; // ST20_8
  __int64 v19; // ST38_8
  __int64 v20; // ST20_8
  __int64 v21; // ST38_8
  __int64 v22; // ST20_8
  int v23; // ebx
  int v24; // eax
  unsigned int v25; // edi
  __int64 v26; // [rsp+20h] [rbp-99h]
  __int64 v27; // [rsp+38h] [rbp-81h]
  UNICODE_STRING Source; // [rsp+70h] [rbp-49h]
  UNICODE_STRING v29; // [rsp+80h] [rbp-39h]
  UNICODE_STRING DestinationString; // [rsp+90h] [rbp-29h]
  __int64 (**v31[3])(void); // [rsp+A0h] [rbp-19h]
  __int128 v32; // [rsp+B8h] [rbp-1h]
  __int64 v33; // [rsp+C8h] [rbp+Fh]
  __int16 v34; // [rsp+D0h] [rbp+17h]

  v3 = dword_140035E98;
  v4 = a3;
  v5 = a2;
  v6 = a1;
  if ( !(dword_140035E98 & 1) )
  {
    dword_140035E98 |= 1u;
    unknown_libname_2(&stru_140035E88);
    sub_1400194B0((__int64)sub_1400280E0);
    v3 = dword_140035E98;
  }
  v7 = sub_140003C0C((__int64)&stru_140035E88);
  if ( !*(_QWORD *)(v7 + 8) )
  {
    *(_QWORD *)&DestinationString.Length = 0i64;
    DestinationString.Buffer = 0i64;
    RtlInitUnicodeString(&DestinationString, L"\\SystemRoot");
    sub_140002584((__m128 *)v31, 0x18ui64);
    sub_140014DCC(v31, (__int64)&DestinationString);
    unknown_libname_2(&v29);
    v8 = sub_140014F1C(v31, &v29);
    if ( v8 < 0 )
    {
      v9 = L"Failed to query system path";
      v10 = 368;
LABEL_8:
      sub_140002E58(
        v9,
        v8,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\selfisolationexclusions.cpp",
        v10);
      sub_140003B78((__int64)&v29);
      return (unsigned int)v8;
    }
    v34 = 0;
    Source.Buffer = (PWSTR)&v32;
    v32 = xmmword_140025720;
    *(_DWORD *)&Source.Length = 1703960;
    v33 = 28429488050470958i64;
    v11 = (const UNICODE_STRING *)sub_140003C0C((__int64)&v29);
    v8 = sub_140014E44(v11, &Source, &stru_140035E88);
    if ( v8 < 0 )
    {
      v9 = L"Failed to query svchost path";
      v10 = 376;
      goto LABEL_8;
    }
    sub_140003B78((__int64)&v29);
    v3 = dword_140035E98;
  }
  if ( !(v3 & 2) )
  {
    v13 = *(unsigned __int16 *)(v7 + 2);
    v14 = *(_QWORD *)(v7 + 8);
    LOBYTE(v27) = 0;
    LOWORD(v26) = 0;
    dword_140035E98 = v3 | 2;
    sub_14001A22C((__int64)&unk_140035EA0, 0, 0, 17, v26, 53, 0i64, v27, 0i64, 0, 0, v14, v13, (__int64)&unk_14002E468);
    LOBYTE(v15) = 0;
    LOWORD(v16) = 68;
    sub_14001A22C(
      (__int64)&unk_140036060,
      2,
      2,
      17,
      v16,
      67,
      0i64,
      v15,
      0i64,
      0,
      0,
      *(_QWORD *)(v7 + 8),
      *(unsigned __int16 *)(v7 + 2),
      (__int64)&unk_14002E488);
    LOBYTE(v17) = 0;
    LOWORD(v18) = 546;
    sub_14001A22C(
      (__int64)&unk_140036220,
      23,
      2,
      17,
      v18,
      547,
      0i64,
      v17,
      0i64,
      0,
      0,
      *(_QWORD *)(v7 + 8),
      *(unsigned __int16 *)(v7 + 2),
      (__int64)&unk_14002E488);
    *(_QWORD *)&v29.Length = 2130706432i64;
    LOBYTE(v19) = 0;
    LOWORD(v20) = 0;
    sub_14001A22C((__int64)&unk_1400363E0, 2, 2, 0, v20, 0, 0i64, v19, 2130706432i64, 8, 0, 0i64, 0i64, 0i64);
    LOBYTE(v21) = 0;
    LOWORD(v22) = 0;
    sub_14001A22C(
      (__int64)&unk_1400365A0,
      23,
      2,
      0,
      v22,
      0,
      0i64,
      v21,
      (__int64)&unk_14002E4A8,
      128,
      0,
      0i64,
      0i64,
      0i64);
    sub_1400194B0((__int64)sub_1400280C0);
  }
  v23 = 0;
  while ( 1 )
  {
    v24 = sub_14001A850(
            (__int64)&unk_140035EA0 + 448 * v23,
            v6,
            v5,
            v4,
            (__int64)qword_140035E00,
            (unsigned __int8 *)&byte_140035DF9,
            0x10u,
            &qword_140030818);
    v25 = v24;
    if ( v24 < 0 )
      break;
    if ( ++v23 >= 5 )
    {
      sub_140002DD4(
        L"Successfully registered default self-isolation exclusions",
        0i64,
        0i64,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\selfisolationexclusions.cpp",
        470);
      return 0i64;
    }
  }
  sub_140002E58(
    L"Failed to apply default exclusion rule",
    v24,
    (unsigned __int8)byte_140035DF9,
    (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\selfisolationexclusions.cpp",
    465);
  return v25;
}
// 140003A00: using guessed type __int64 __fastcall unknown_libname_2(_QWORD);
// 1400256E0: using guessed type wchar_t aFailedToQueryS[28];
// 140025720: using guessed type __int128 xmmword_140025720;
// 140025740: using guessed type wchar_t aFailedToQueryS_0[29];
// 140025780: using guessed type wchar_t aFailedToApplyD[39];
// 1400257D0: using guessed type wchar_t aSuccessfullyRe[58];
// 140030818: using guessed type __int64 qword_140030818;
// 140035DF9: using guessed type char byte_140035DF9;
// 140035E98: using guessed type int dword_140035E98;

//----- (000000014001AF08) ----------------------------------------------------
__int64 __fastcall sub_14001AF08(__int64 a1, __int64 a2, __m128i *a3, _QWORD *a4, unsigned __int8 *a5)
{
  _QWORD *v5; // rdi
  __m128i *v6; // r12
  __int64 v7; // r13
  __int64 v8; // r14
  int v9; // ebx
  int v10; // eax
  unsigned int v11; // esi

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  sub_14001B088(a1);
  if ( v5 )
  {
    if ( P && byte_140035DFA )
    {
      v9 = 0;
      while ( 1 )
      {
        v10 = sub_14001A850((__int64)P + 448 * v9, v8, v7, v6, (__int64)v5, a5, 0xFFu, &qword_140030820);
        v11 = v10;
        if ( v10 < 0 )
          break;
        if ( ++v9 >= (unsigned __int8)byte_140035DFA )
        {
          sub_140002DD4(
            L"Successfully registered user policy self-isolation exclusions",
            0i64,
            0i64,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\selfisolationexclusions.cpp",
            513);
          return 0i64;
        }
      }
      sub_140002E58(
        L"Failed to apply user exclusion rule",
        v10,
        v9,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\selfisolationexclusions.cpp",
        508);
      return v11;
    }
    *v5 = 0i64;
  }
  *a5 = 0;
  return 0i64;
}
// 140025850: using guessed type wchar_t aFailedToApplyU[36];
// 1400258A0: using guessed type wchar_t aSuccessfullyRe_0[62];
// 140030820: using guessed type __int64 qword_140030820;
// 140035DFA: using guessed type char byte_140035DFA;

//----- (000000014001B028) ----------------------------------------------------
void __fastcall sub_14001B028(__int64 a1)
{
  __int64 v1; // rdi
  signed int v2; // ebx

  v1 = a1;
  sub_14001B088(a1);
  v2 = 0;
  byte_140035DF8 = 0;
  if ( byte_140035DF9 )
  {
    do
      sub_1400064C0(v1, &qword_140035E00[v2++]);
    while ( v2 < (unsigned __int8)byte_140035DF9 );
  }
  qword_140030818 = 0x100000i64;
  sub_14001B0D8();
}
// 140030818: using guessed type __int64 qword_140030818;
// 140035DF8: using guessed type char byte_140035DF8;
// 140035DF9: using guessed type char byte_140035DF9;

//----- (000000014001B088) ----------------------------------------------------
__int64 __fastcall sub_14001B088(__int64 a1)
{
  signed int v1; // ebx
  __int64 v2; // rdi
  __int64 result; // rax

  v1 = 0;
  v2 = a1;
  if ( byte_140035DF8 )
  {
    do
    {
      sub_1400064C0(v2, &qword_140035600[v1]);
      result = (unsigned __int8)byte_140035DF8;
      ++v1;
    }
    while ( v1 < (unsigned __int8)byte_140035DF8 );
  }
  qword_140030820 = 0x10000i64;
  return result;
}
// 140030820: using guessed type __int64 qword_140030820;
// 140035DF8: using guessed type char byte_140035DF8;

//----- (000000014001B0D8) ----------------------------------------------------
void sub_14001B0D8()
{
  byte_140035DF9 = 0;
}
// 140035DF9: using guessed type char byte_140035DF9;

//----- (000000014001B0E0) ----------------------------------------------------
void sub_14001B0E0()
{
  signed int v0; // ebx

  if ( P )
  {
    v0 = 0;
    if ( byte_140035DFA )
    {
      do
        sub_14001A6E0((__int64)P + 448 * v0++, 0);
      while ( v0 < (unsigned __int8)byte_140035DFA );
    }
    ExFreePoolWithTag(P, 0);
    P = 0i64;
    byte_140035DFA = 0;
  }
}
// 140035DFA: using guessed type char byte_140035DFA;

//----- (000000014001B144) ----------------------------------------------------
signed __int64 __fastcall sub_14001B144(unsigned __int64 a1, __int64 a2)
{
  _DWORD *v2; // rdi
  int v4; // ebp
  unsigned __int64 v5; // rsi
  unsigned __int16 v6; // bx
  __int16 v7; // dx
  _DWORD *v8; // r14
  __int16 v9; // ax
  __int64 v10; // rbx
  char v11; // r15
  int v12; // eax
  char *v13; // rdi
  char *v14; // rdx
  __int64 v15; // r10
  __int64 v16; // [rsp+20h] [rbp-78h]
  __int64 v17; // [rsp+38h] [rbp-60h]
  __int64 v18; // [rsp+A8h] [rbp+10h]

  v2 = (_DWORD *)a1;
  if ( !a2 )
  {
    sub_14001B0E0();
    return 0i64;
  }
  if ( !a1 )
    return 3223453724i64;
  v4 = 2;
  v5 = a1 + a2;
  v6 = 0;
  if ( a1 >= a1 + a2 )
  {
LABEL_16:
    sub_14001B0E0();
    byte_140035DFA = 0;
    P = ExAllocatePoolWithTag(PagedPool, 448i64 * v6, 0x78456C49u);
    while ( 1 )
    {
      if ( (unsigned __int64)v2 >= v5 )
        return 0i64;
      v8 = v2;
      v2 = (_DWORD *)((char *)v2 + 10);
      if ( *v8 == 1 )
      {
        v4 = 1;
      }
      else if ( *v8 == 2 )
      {
        v4 = 0;
      }
      v9 = *((_WORD *)v8 + 4);
      v10 = 0i64;
      v11 = 0;
      v18 = 0i64;
      if ( v9 == 2 )
      {
        v12 = *v2;
        v13 = (char *)(v2 + 1);
        LODWORD(v18) = v12;
        v10 = v18;
      }
      else
      {
        if ( v9 != 23 )
          goto LABEL_28;
        v10 = (__int64)v2;
        v13 = (char *)(v2 + 4);
      }
      v11 = *v13;
      v2 = v13 + 1;
LABEL_28:
      v14 = (char *)P + 448 * (unsigned __int8)byte_140035DFA++;
      v15 = sub_140008CB8(448i64, (__int64)v14);
      if ( v15 )
      {
        LOBYTE(v17) = 0;
        LOWORD(v16) = *((_WORD *)v8 + 2);
        sub_14001A22C(v15, *((_WORD *)v8 + 4), v4, 0, v16, *((_WORD *)v8 + 3), 0i64, v17, v10, v11, 0, 0i64, 0i64, 0i64);
      }
      v4 = 2;
    }
  }
  while ( v5 - a1 >= 0xA )
  {
    v7 = *(_WORD *)(a1 + 8);
    a1 += 10i64;
    if ( v7 == 2 )
    {
      if ( v5 - a1 < 5 )
        return 3221225990i64;
      a1 += 5i64;
    }
    else if ( v7 == 23 )
    {
      if ( v5 - a1 < 0x11 )
        return 3221225990i64;
      a1 += 17i64;
    }
    else if ( v7 )
    {
      return 3221225485i64;
    }
    if ( ++v6 > 0xFFu )
      return 3221225990i64;
    if ( a1 >= v5 )
      goto LABEL_16;
  }
  return 3221225990i64;
}
// 140035DFA: using guessed type char byte_140035DFA;

//----- (000000014001B350) ----------------------------------------------------
__int64 __fastcall sub_14001B350(__int64 a1, char a2)
{
  char v2; // bl
  __int64 v3; // rdi
  void *v4; // rax
  int v5; // eax
  unsigned int v6; // ebx
  char v8; // [rsp+30h] [rbp-B8h]
  int v9; // [rsp+48h] [rbp-A0h]
  int v10; // [rsp+4Ch] [rbp-9Ch]
  __int64 v11; // [rsp+50h] [rbp-98h]
  char v12; // [rsp+70h] [rbp-78h]
  void *v13; // [rsp+98h] [rbp-50h]

  v2 = a2;
  v3 = a1;
  sub_14001D3D4((__m128 *)&v12, 2);
  v4 = sub_14001B420;
  if ( v2 )
    v4 = sub_14000A660;
  v13 = v4;
  sub_14000AD68((__m128 *)&v8);
  v9 = 2;
  v11 = v3;
  v10 = 4;
  v5 = sub_14001D584();
  v6 = v5;
  if ( v5 < 0 )
    sub_140002E58(
      L"Unable to create default queue",
      v5,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
      1282);
  return v6;
}
// 1400279C0: using guessed type wchar_t aUnableToCreate_0[31];

//----- (000000014001B420) ----------------------------------------------------
__int64 __fastcall sub_14001B420(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  __int64 v5; // r14
  int v6; // eax
  int v7; // er8
  const wchar_t *v8; // rcx
  __int64 result; // rax
  int v10; // ecx
  int v11; // eax
  signed int *v12; // rdx
  int v13; // eax
  __int64 v14; // rbx
  int v15; // edx
  int v16; // eax
  __int64 v17; // rbx
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // ebx
  int v22; // ebx
  int Timeout; // [rsp+20h] [rbp-50h]
  __int64 v24; // [rsp+30h] [rbp-40h]
  PCWSTR SourceString; // [rsp+38h] [rbp-38h]
  unsigned __int64 v26; // [rsp+40h] [rbp-30h]
  __int64 v27; // [rsp+48h] [rbp-28h]
  unsigned __int64 v28; // [rsp+50h] [rbp-20h]
  __int64 v29; // [rsp+58h] [rbp-18h]
  __int64 v30; // [rsp+60h] [rbp-10h]

  v24 = a2;
  v5 = a2;
  if ( a5 <= 0x12E056 )
  {
    switch ( a5 )
    {
      case 0x12E056u:
        v6 = sub_14001D318(&v24, 2, (__int64 (*)(void))sub_140016F00);
        if ( v6 >= 0 )
          return sub_140017474(v5, (__int64)&dword_140035040);
        Timeout = 789;
        v8 = L"SNTP_CONNECTION_TRACKING_INVERTED_CALL: Invalid request, code:";
        v7 = 1237078;
        goto LABEL_120;
      case 0x12E002u:
        v6 = sub_14001D318(&v24, 1, 0i64);
        if ( v6 < 0 )
        {
          Timeout = 851;
          v8 = L"SNTP_START_HTTP_FILTERING: Invalid request, code:";
          v7 = 1236994;
          goto LABEL_120;
        }
        v6 = KeWaitForSingleObject(&Mutex, UserRequest, 0, 0, 0i64);
        if ( !v6 )
        {
          v20 = sub_14001C854(qword_140037700, 0);
          if ( v20 < 0 )
          {
            sub_140002E58(
              L"SNTP_START_HTTP_FILTERING: Unable to register callouts.",
              v20,
              0,
              (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
              876);
            goto LABEL_64;
          }
          v12 = &dword_140034FE0;
          goto LABEL_66;
        }
        Timeout = 866;
        break;
      case 0x12E006u:
        v6 = sub_14001D318(&v24, 1, 0i64);
        if ( v6 < 0 )
        {
          Timeout = 890;
          v8 = L"SNTP_STOP_HTTP_FILTERING: Invalid request, code:";
          v7 = 1236998;
          goto LABEL_120;
        }
        v6 = KeWaitForSingleObject(&Mutex, UserRequest, 0, 0, 0i64);
        if ( !v6 )
        {
          sub_140016F08(1, (__int64)&dword_140034FE0);
          v10 = 0;
LABEL_57:
          sub_14001D230(v10);
          goto LABEL_64;
        }
        Timeout = 905;
        break;
      case 0x12E00Au:
        if ( qword_140037678 )
        {
          if ( _InterlockedCompareExchange(&dword_140036760, 1, 0) )
          {
            sub_140002E58(
              L"SNTP_LINK: there already is a link, code:",
              -1073741808,
              1237002,
              (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
              817);
            v5 = v24;
          }
          else
          {
            v5 = v24;
            result = sub_14000AE0C(v24);
            if ( (signed int)result >= 0 )
              return result;
            sub_140002E58(
              L"SNTP_LINK: Unable to mark Link as cancelable, code:",
              result,
              1237002,
              (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
              823);
            v19 = KeWaitForSingleObject(&Mutex, UserRequest, 0, 0, 0i64);
            if ( v19 )
            {
              sub_140002E58(
                L"Wait for mutex object failed",
                v19,
                0,
                (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
                830);
              sub_14001BE54(0);
            }
            else
            {
              sub_14001BE54(1);
              KeReleaseMutex(&Mutex, 0);
            }
          }
          return sub_14000ADD8(v5);
        }
        Timeout = 807;
        v15 = -1073741667;
        v8 = L"SNTP_LINK: controlFileObject not initialised, code:";
        v7 = 1237002;
        goto LABEL_121;
      case 0x12E00Eu:
        v18 = sub_14001D318(&v24, 1, 0i64);
        if ( v18 >= 0 )
        {
          sub_140002DD4(
            L"sntp_drv::defaultControlHandler: FLUSH_CACHE IOCTL received",
            0i64,
            0i64,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
            1043);
          sub_140017914();
        }
        else
        {
          sub_140002E58(
            L"SNTP_FLUSH_CACHE: Invalid request, code:",
            v18,
            1237006,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
            1036);
        }
        return sub_14000ADD8(v5);
      case 0x12E012u:
        v6 = sub_14001D318(&v24, 1, 0i64);
        if ( v6 < 0 )
        {
          Timeout = 985;
          v8 = L"SNTP_SET_EXCLUSION_LIST: Invalid request, code:";
          v7 = 1237010;
          goto LABEL_120;
        }
        v29 = 0i64;
        v6 = sub_14000AE28();
        if ( v6 >= 0 && v29 )
        {
          v16 = sub_140002D94(SourceString);
          v17 = v16;
          if ( v16 >= 0 )
          {
            sub_140004C94(0);
            sub_140002DD4(
              L"SNTP_SET_EXCLUSION_LIST: Successfully added exclusions.",
              v17,
              0i64,
              (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
              1010);
            return sub_14000ADD8(v5);
          }
          Timeout = 1005;
          v8 = L"SNTP_SET_EXCLUSION_LIST: Failed to update exclusions list";
          v7 = 0;
          v15 = v16;
          goto LABEL_121;
        }
        Timeout = 998;
        v8 = L"SNTP_SET_EXCLUSION_LIST: Failed to retrieve input buffer from IOCTL";
LABEL_119:
        v7 = 0;
        goto LABEL_120;
      case 0x12E016u:
        v13 = sub_14001D318(&v24, 1, 0i64);
        v14 = v13;
        if ( v13 >= 0 )
        {
          sub_140002D44(0i64);
          sub_140004C94(0);
          sub_140002DD4(
            L"SNTP_RESET_EXCLUSION_LIST: Exclusions reset.",
            v14,
            0i64,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
            1028);
          return sub_14000ADD8(v5);
        }
        Timeout = 1018;
        v8 = L"SNTP_RESET_EXCLUSION_LIST: Invalid request, code:";
        v7 = 1237014;
        v15 = v13;
        goto LABEL_121;
      case 0x12E042u:
        v6 = sub_14001D318(&v24, 1, 0i64);
        if ( v6 < 0 )
        {
          Timeout = 918;
          v8 = L"SNTP_START_CONNECTION_TRACKING: Invalid request, code:";
          v7 = 1237058;
          goto LABEL_120;
        }
        v6 = KeWaitForSingleObject(&Mutex, UserRequest, 0, 0, 0i64);
        if ( v6 )
        {
          Timeout = 933;
          v8 = L"SNTP_START_CONNECTION_TRACKING: Wait for mutex object failed";
          goto LABEL_119;
        }
        v11 = sub_14001C854(qword_140037700, 1);
        if ( v11 < 0 )
        {
          sub_140002E58(
            L"SNTP_START_CONNECTION_TRACKING: Unable to register callouts.",
            v11,
            0,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
            943);
LABEL_64:
          KeReleaseMutex(&Mutex, 0);
          return sub_14000ADD8(v5);
        }
        v12 = &dword_140035040;
LABEL_66:
        sub_140017008(4096, v12);
        goto LABEL_64;
      case 0x12E046u:
        v6 = sub_14001D318(&v24, 1, 0i64);
        if ( v6 < 0 )
        {
          Timeout = 957;
          v8 = L"SNTP_STOP_CONNECTION_TRACKING: Invalid request, code:";
          v7 = 1237062;
LABEL_120:
          v15 = v6;
          goto LABEL_121;
        }
        v6 = KeWaitForSingleObject(&Mutex, UserRequest, 0, 0, 0i64);
        if ( v6 )
        {
          Timeout = 972;
          v8 = L"SNTP_STOP_CONNECTION_TRACKING: Wait for mutex object failed";
          goto LABEL_119;
        }
        sub_140016F08(1, (__int64)&dword_140035040);
        v10 = 1;
        goto LABEL_57;
      case 0x12E052u:
        v6 = sub_14001D318(&v24, 2, (__int64 (*)(void))sub_1400171C0);
        if ( v6 >= 0 )
          return sub_1400175DC(v5, (__int64)&dword_140034FE0);
        Timeout = 774;
        v7 = 1237074;
        v8 = L"SNTP_HTTP_FILTERING_INVERTED_CALL: Invalid request, code:";
        goto LABEL_120;
      default:
        goto LABEL_78;
    }
LABEL_55:
    v8 = L"Wait for mutex object failed";
    goto LABEL_119;
  }
  switch ( a5 )
  {
    case 0x12E082u:
      v6 = sub_14001D318(&v24, 1, 0i64);
      if ( v6 < 0 )
      {
        Timeout = 1053;
        v8 = L"SNTP_SELF_ISOLATION_START: Invalid request, code:";
        v7 = 1237122;
        goto LABEL_120;
      }
      v6 = sub_140019FA0(qword_140037700);
      if ( v6 < 0 )
      {
        Timeout = 1067;
        v8 = L"SNTP_SELF_ISOLATION_START: Failed to isolate the endpoint.";
        goto LABEL_119;
      }
      break;
    case 0x12E086u:
      v6 = sub_14001D318(&v24, 1, 0i64);
      if ( v6 < 0 )
      {
        Timeout = 1077;
        v8 = L"SNTP_SELF_ISOLATION_STOP: Invalid request, code:";
        v7 = 1237126;
        goto LABEL_120;
      }
      v6 = sub_14001A144();
      if ( v6 < 0 )
      {
        Timeout = 1091;
        v8 = L"SNTP_SELF_ISOLATION_STOP: Failed to un-isolate the endpoint.";
        goto LABEL_119;
      }
      break;
    case 0x12E08Au:
    case 0x12E08Eu:
      v6 = sub_14001D318(&v24, 1, 0i64);
      if ( v6 < 0 )
      {
        v7 = a5;
        Timeout = 1102;
        v8 = L"SNTP_SELF_ISOLATION_EXCLUDE/INCLUDE_BROWSERS: Invalid request, code:";
        goto LABEL_120;
      }
      sub_140019E00(a5 == 1237130);
      break;
    case 0x12E096u:
      v6 = sub_14001D318(&v24, 1, 0i64);
      if ( v6 < 0 )
      {
        Timeout = 1150;
        v8 = L"SNTP_STONEWALLING_SET_LIST: Invalid request, code:";
        v7 = 1237142;
        goto LABEL_120;
      }
      v28 = 0i64;
      v22 = sub_14000AE28();
      if ( (signed int)(v22 + 2147483648) >= 0 && v22 != -1073741789 )
      {
        Timeout = 1163;
        v8 = L"SNTP_STONEWALLING_SET_LIST: Failed to retrieve input buffer from IOCTL";
        v7 = 0;
        v15 = v22;
        goto LABEL_121;
      }
      v6 = KeWaitForSingleObject(&Mutex, UserRequest, 0, 0, 0i64);
      if ( !v6 )
      {
        if ( v28 )
        {
          if ( (signed int)sub_140017008(20, &dword_1400350A0) < 0 )
            return sub_14000ADD8(v5);
        }
        else
        {
          sub_140016F08(1, (__int64)&dword_1400350A0);
        }
        v6 = sub_14001D894(qword_140037700, v27, v28);
        if ( v6 < 0 )
        {
          Timeout = 1190;
          v8 = L"SNTP_STONEWALLING_SET_LIST: Failed to update stonewalling list";
          goto LABEL_119;
        }
        goto LABEL_64;
      }
      Timeout = 1170;
      goto LABEL_55;
    case 0x12E09Au:
      v6 = sub_14001D318(&v24, 1, 0i64);
      if ( v6 < 0 )
      {
        Timeout = 1203;
        v8 = L"SNTP_STONEWALLING_RESET_LIST: Invalid request, code:";
        v7 = 1237146;
        goto LABEL_120;
      }
      v6 = KeWaitForSingleObject(&Mutex, UserRequest, 0, 0, 0i64);
      if ( v6 )
      {
        Timeout = 1215;
        goto LABEL_55;
      }
      sub_140016F08(1, (__int64)&dword_1400350A0);
      KeReleaseMutex(&Mutex, 0);
      v6 = sub_14001D808();
      if ( v6 < 0 )
      {
        Timeout = 1224;
        v8 = L"SNTP_STONEWALLING_RESET_LIST: Failed to reset stonewalling list";
        goto LABEL_119;
      }
      break;
    case 0x12E09Eu:
      v6 = sub_14001D318(&v24, 2, (__int64 (*)(void))sub_1400179D0);
      if ( v6 >= 0 )
        return sub_140017800(v5, (__int64)&dword_1400350A0);
      Timeout = 1237;
      v8 = L"SNTP_STONEWALLING_NOTIFICATION_INVERTED_CALL: Invalid request, code:";
      v7 = 1237150;
      goto LABEL_120;
    case 0x12E0C2u:
      v6 = sub_14001D318(&v24, 1, 0i64);
      if ( v6 < 0 )
      {
        Timeout = 1119;
        v8 = L"SNTP_ISOLATION_ALLOW_IP_ADDRESS_AND_PORT: Invalid request, code:";
        v7 = 1237186;
        goto LABEL_120;
      }
      v30 = 0i64;
      v21 = sub_14000AE28();
      if ( (signed int)(v21 + 2147483648) >= 0 && v21 != -1073741789 )
      {
        Timeout = 1132;
        v8 = L"SNTP_ISOLATION_ALLOW_IP_ADDRESS_AND_PORT: Failed to retrieve input buffer from IOCTL";
        v7 = 0;
        v15 = v21;
        goto LABEL_121;
      }
      v6 = sub_140019E4C(v26, v30);
      if ( v6 < 0 )
      {
        Timeout = 1139;
        v8 = L"SNTP_ISOLATION_ALLOW_IP_ADDRESS_AND_PORT: Failed to update exclusions list";
        goto LABEL_119;
      }
      break;
    default:
LABEL_78:
      v15 = -1073741808;
      Timeout = 1250;
      v8 = L"Invalid IOCTL called, code:";
      v7 = a5;
LABEL_121:
      sub_140002E58(v8, v15, v7, (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c", Timeout);
      return sub_14000ADD8(v5);
  }
  return sub_14000ADD8(v5);
}
// 140002D44: using guessed type __int64 __fastcall sub_140002D44(_QWORD);
// 1400200E0: using guessed type wchar_t aSntpSetExclusi_1[68];
// 140020170: using guessed type wchar_t aSntpSetExclusi[58];
// 1400201F0: using guessed type wchar_t aSntpSetExclusi_0[56];
// 140020260: using guessed type wchar_t aSntpResetExclu[45];
// 140026A00: using guessed type wchar_t aWaitForMutexOb[29];
// 140026A90: using guessed type wchar_t aSntpHttpFilter[58];
// 140026B10: using guessed type wchar_t aSntpConnection[63];
// 140026B90: using guessed type wchar_t aSntpLinkContro[52];
// 140026C00: using guessed type wchar_t aSntpLinkThereA[42];
// 140026C60: using guessed type wchar_t aSntpLinkUnable[52];
// 140026CD0: using guessed type wchar_t aSntpStartHttpF[50];
// 140026D40: using guessed type wchar_t aSntpStartHttpF_0[56];
// 140026DB0: using guessed type wchar_t aSntpStopHttpFi[49];
// 140026E20: using guessed type wchar_t aSntpStartConne[55];
// 140026E90: using guessed type wchar_t aSntpStartConne_0[61];
// 140026F10: using guessed type wchar_t aSntpStartConne_1[61];
// 140026F90: using guessed type wchar_t aSntpStopConnec[54];
// 140027000: using guessed type wchar_t aSntpStopConnec_0[60];
// 140027080: using guessed type wchar_t aSntpSetExclusi_2[48];
// 1400270E0: using guessed type wchar_t aSntpResetExclu_0[50];
// 140027150: using guessed type wchar_t aSntpFlushCache[41];
// 1400271B0: using guessed type wchar_t aSntpDrvDefault[60];
// 140027230: using guessed type wchar_t aSntpSelfIsolat_2[50];
// 1400272A0: using guessed type wchar_t aSntpSelfIsolat_3[59];
// 140027320: using guessed type wchar_t aSntpSelfIsolat_0[49];
// 140027390: using guessed type wchar_t aSntpSelfIsolat_1[61];
// 140027410: using guessed type wchar_t aSntpSelfIsolat[69];
// 1400274A0: using guessed type wchar_t aSntpIsolationA[65];
// 140027530: using guessed type wchar_t aSntpIsolationA_0[85];
// 1400275E0: using guessed type wchar_t aSntpIsolationA_1[75];
// 140027680: using guessed type wchar_t aSntpStonewalli_2[51];
// 1400276F0: using guessed type wchar_t aSntpStonewalli_3[71];
// 140027780: using guessed type wchar_t aSntpStonewalli_4[63];
// 140027800: using guessed type wchar_t aSntpStonewalli_0[53];
// 140027870: using guessed type wchar_t aSntpStonewalli_1[64];
// 1400278F0: using guessed type wchar_t aSntpStonewalli[69];
// 140027980: using guessed type wchar_t aInvalidIoctlCa[28];
// 140034FE0: using guessed type int dword_140034FE0;
// 140035040: using guessed type int dword_140035040;
// 1400350A0: using guessed type int dword_1400350A0;
// 140036760: using guessed type int dword_140036760;
// 140037678: using guessed type __int64 qword_140037678;
// 140037700: using guessed type __int64 qword_140037700;

//----- (000000014001BE38) ----------------------------------------------------
void sub_14001BE38()
{
  signed int v0; // ebx

  v0 = 0;
  do
    sub_140014B2C(v0++);
  while ( v0 < 3 );
}

//----- (000000014001BE54) ----------------------------------------------------
void __fastcall sub_14001BE54(char a1)
{
  char v1; // bl

  v1 = a1;
  sub_140016F08(a1, (__int64)&dword_140034FE0);
  sub_140016F08(v1, (__int64)&dword_140035040);
  sub_140016F08(v1, (__int64)&dword_1400350A0);
}
// 140034FE0: using guessed type int dword_140034FE0;
// 140035040: using guessed type int dword_140035040;
// 1400350A0: using guessed type int dword_1400350A0;

//----- (000000014001BE90) ----------------------------------------------------
void __fastcall sub_14001BE90(__int64 a1)
{
  __int64 v1; // rbx
  signed int v2; // edi
  int v3; // eax

  v1 = a1;
  v2 = 0;
  ExAcquireFastMutex(&FastMutex);
  if ( qword_140037678 == v1 )
  {
    qword_140037678 = 0i64;
    v2 = 1;
  }
  else
  {
    --dword_140036764;
  }
  ExReleaseFastMutex(&FastMutex);
  if ( v2 )
  {
    v3 = KeWaitForSingleObject(&Mutex, UserRequest, 0, 0, 0i64);
    if ( v3 )
    {
      sub_140002E58(
        L"Wait for mutex object failed",
        v3,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
        1323);
    }
    else
    {
      sub_14001BE54(1);
      sub_14001C2B4();
      KeReleaseMutex(&Mutex, 0);
    }
    sub_14001D808();
    sub_14001A144();
  }
}
// 140026A00: using guessed type wchar_t aWaitForMutexOb[29];
// 140036764: using guessed type int dword_140036764;
// 140037678: using guessed type __int64 qword_140037678;

//----- (000000014001BF50) ----------------------------------------------------
__int64 __fastcall sub_14001BF50(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rsi

  v3 = a3;
  v4 = a2;
  ExAcquireFastMutex(&FastMutex);
  if ( qword_140037678 )
  {
    if ( dword_140036764 < 6 )
      ++dword_140036764;
  }
  else
  {
    qword_140037678 = v3;
  }
  ExReleaseFastMutex(&FastMutex);
  return sub_14000ADD8(v4);
}
// 140036764: using guessed type int dword_140036764;
// 140036768: using guessed type char byte_140036768;
// 140037678: using guessed type __int64 qword_140037678;

//----- (000000014001BFE0) ----------------------------------------------------
__int64 __fastcall sub_14001BFE0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  v2 = a2;
  sub_14000A3F0(a1);
  return sub_14000ADD8(v2);
}

//----- (000000014001C000) ----------------------------------------------------
__int64 __fastcall sub_14001C000(__int64 a1)
{
  __int64 v1; // rdi
  int v2; // eax
  int v3; // ebx
  LARGE_INTEGER Timeout; // [rsp+30h] [rbp-18h]

  v1 = a1;
  Timeout.QuadPart = -10000000i64;
  sub_140002E58(
    L"EvtRequestCancelForLink: Link canceled",
    0,
    0,
    (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
    689);
  while ( 1 )
  {
    v2 = KeWaitForSingleObject(&Mutex, 0, 0, 0, &Timeout);
    v3 = v2;
    if ( !v2 )
      break;
    sub_140002E58(
      L"Wait for mutex object failed",
      v2,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
      700);
    if ( v3 != 258 && v3 != 257 && v3 != 192 )
      goto LABEL_8;
  }
  sub_14001BE54(1);
  KeReleaseMutex(&Mutex, 0);
LABEL_8:
  dword_140036760 = 0;
  return sub_14000ADD8(v1);
}
// 140026A00: using guessed type wchar_t aWaitForMutexOb[29];
// 140026A40: using guessed type wchar_t aEvtrequestcanc[39];
// 140036760: using guessed type int dword_140036760;

//----- (000000014001C0E8) ----------------------------------------------------
void __fastcall sub_14001C0E8(_DWORD *a1)
{
  _DWORD *v1; // rbx

  v1 = a1;
  sub_14001D5B0(a1, 1);
  *((_QWORD *)v1 + 1) = 0i64;
  v1[4] = 0;
  KeInitializeEvent((PRKEVENT)v1 + 1, SynchronizationEvent, 0);
}

//----- (000000014001C11C) ----------------------------------------------------
__int64 __fastcall sub_14001C11C(__int64 a1, __m128 *a2, char a3)
{
  __int64 v3; // rsi
  char v4; // bl
  __m128 *v5; // rdi
  void (__fastcall *v6)(__int64); // r9
  void *v7; // rdx
  char v9; // [rsp+20h] [rbp-38h]

  v3 = a1;
  v4 = a3;
  v5 = a2;
  sub_14000AD68(a2);
  v6 = (void (__fastcall *)(__int64))sub_14001BFD0;
  v5[3].m128_u64[0] = (unsigned __int64)off_140030160;
  v7 = sub_14001BFE0;
  if ( !v4 )
    v6 = sub_14001BE90;
  if ( !v4 )
    v7 = sub_14001BF50;
  sub_14001D3B0((__int64)&v9, (__int64)v7, 0i64, (__int64)v6);
  sub_14001D530(v3);
  return sub_14001D508();
}
// 14001BFD0: using guessed type __int64 __fastcall sub_14001BFD0();
// 140030160: using guessed type void *off_140030160;

//----- (000000014001C1C4) ----------------------------------------------------
__int64 sub_14001C1C4()
{
  int v0; // eax
  unsigned int v1; // ebx
  char v3; // [rsp+30h] [rbp-48h]
  __int64 (*v4)(); // [rsp+40h] [rbp-38h]
  int v5; // [rsp+48h] [rbp-30h]

  sub_14001D398(&v3, 0i64);
  v5 |= 1u;
  v4 = sub_14001C460;
  v0 = sub_14001D54C();
  v1 = v0;
  if ( v0 < 0 )
    sub_140002E58(
      L"Unable to create driver",
      v0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
      1416);
  return v1;
}
// 140027A00: using guessed type wchar_t aUnableToCreate_1[24];

//----- (000000014001C258) ----------------------------------------------------
signed __int64 sub_14001C258()
{
  signed int v0; // ebx
  signed __int64 result; // rax

  v0 = 0;
  do
  {
    result = sub_140014BC8(v0);
    if ( (_DWORD)result )
      break;
    ++v0;
  }
  while ( v0 < 3 );
  return result;
}

//----- (000000014001C278) ----------------------------------------------------
__int64 __fastcall sub_14001C278(_QWORD *a1, __int64 a2, __int64 a3)
{
  char v4; // [rsp+30h] [rbp-28h]

  return sub_140002FE0(a1, a2, a3, 1, (__int64)&v4);
}

//----- (000000014001C2B4) ----------------------------------------------------
void sub_14001C2B4()
{
  sub_14001D230(1);
  sub_14001D230(0);
}

//----- (000000014001C2D0) ----------------------------------------------------
__int64 __fastcall sub_14001C2D0(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 result; // rax
  __int64 v6; // r11
  __int64 v7; // [rsp+48h] [rbp+10h]

  v3 = a3;
  v4 = a1;
  result = sub_14001C41C(a1, a2 >> 1, (__int64)&v7, 0x7FFFFFFFi64);
  if ( (signed int)result >= 0 )
    result = sub_14001C368((_WORD *)(v4 + 2 * v7), v6 - v7, 0i64, v3, 2147483646i64);
  return result;
}

//----- (000000014001C32C) ----------------------------------------------------
__int64 __fastcall sub_14001C32C(__int64 a1, unsigned __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // rdx
  _WORD *v4; // rcx
  __int64 v5; // r9

  result = unknown_libname_7(a1, a2 >> 1, 0x7FFFFFFFi64);
  if ( (signed int)result >= 0 )
    return sub_14001C368(v4, v3, 0i64, v5, 2147483646i64);
  if ( v3 )
    *v4 = 0;
  return result;
}
// 14001C444: using guessed type __int64 __fastcall unknown_libname_7(_QWORD, _QWORD, _QWORD);

//----- (000000014001C368) ----------------------------------------------------
__int64 __fastcall sub_14001C368(_WORD *a1, __int64 a2, signed __int64 *a3, __int64 a4, __int64 a5)
{
  _WORD *v5; // r10
  signed __int64 v6; // r11
  __int64 v7; // rax
  __int64 v8; // r9
  __int16 v9; // cx
  _WORD *v10; // rcx
  __int64 result; // rax
  signed __int64 v12; // rcx

  v5 = a1;
  v6 = 0i64;
  if ( a2 )
  {
    v7 = a5;
    v8 = a4 - (_QWORD)a1;
    do
    {
      if ( !v7 )
        break;
      v9 = *(_WORD *)((char *)v5 + v8);
      if ( !v9 )
        break;
      *v5 = v9;
      --v7;
      ++v5;
      ++v6;
      --a2;
    }
    while ( a2 );
  }
  v10 = v5 - 1;
  result = a2 == 0 ? 0x80000005 : 0;
  if ( a2 )
    v10 = v5;
  *v10 = 0;
  if ( a3 )
  {
    v12 = v6 - 1;
    if ( a2 )
      v12 = v6;
    *a3 = v12;
  }
  return result;
}

//----- (000000014001C3DC) ----------------------------------------------------
__int64 __fastcall sub_14001C3DC(_WORD *a1, __int64 a2, _QWORD *a3)
{
  __int64 i; // r9
  __int64 result; // rax

  for ( i = a2; a2; --a2 )
  {
    if ( !*a1 )
      break;
    ++a1;
  }
  result = a2 == 0 ? 0xC000000D : 0;
  if ( a3 )
  {
    if ( a2 )
      *a3 = i - a2;
    else
      *a3 = 0i64;
  }
  return result;
}

//----- (000000014001C41C) ----------------------------------------------------
__int64 __fastcall sub_14001C41C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax
  __int64 v5; // rdx
  _WORD *v6; // rcx
  _QWORD *v7; // r10

  result = unknown_libname_7(a1, a2, a4);
  if ( (signed int)result >= 0 )
    return sub_14001C3DC(v6, v5, v7);
  *v7 = 0i64;
  return result;
}
// 14001C444: using guessed type __int64 __fastcall unknown_libname_7(_QWORD, _QWORD, _QWORD);

//----- (000000014001C460) ----------------------------------------------------
__int64 sub_14001C460()
{
  int v0; // eax
  char v1; // bl
  char v3; // [rsp+30h] [rbp-48h]
  char v4; // [rsp+48h] [rbp-30h]

  v0 = KeWaitForSingleObject(&Mutex, 0, 0, 0, 0i64);
  if ( v0 )
  {
    sub_140002E58(
      L"Wait for mutex object failed",
      v0,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
      602);
    sub_14001BE54(1);
  }
  else
  {
    sub_14001BE54(1);
    KeReleaseMutex(&Mutex, 0);
  }
  KeAcquireInStackQueuedSpinLock(&unk_140037770);
  KeAcquireInStackQueuedSpinLock(&unk_140037758);
  v1 = byte_140030180;
  byte_140034F88 = 1;
  byte_140030180 = 0;
  KeReleaseInStackQueuedSpinLock(&v3);
  KeReleaseInStackQueuedSpinLock(&v4);
  if ( v1 )
    KeSetEvent(&Object, 0, 0);
  KeWaitForSingleObject(qword_1400376F8, 0, 0, 0, 0i64);
  ObfDereferenceObject(qword_1400376F8);
  sub_14001C2B4();
  sub_1400153E4();
  sub_14001D808();
  sub_14001A144();
  sub_140019DF8();
  FwpsInjectionHandleDestroy0(qword_140034F90);
  ExAcquireFastMutex(&FastMutex);
  dword_140036764 = 0;
  ExReleaseFastMutex(&FastMutex);
  sub_14001BE38();
  sub_140002D8C();
  sub_140004F7C();
  sub_1400197DC();
  sub_14001859C();
  sub_140019408();
  if ( byte_140034440 & 1 )
    sub_14001C278(&unk_140030040, (__int64)&unk_140029E00, 0i64);
  return sub_140002D9C();
}
// 140002D8C: using guessed type __int64 sub_140002D8C(void);
// 1400153E4: using guessed type __int64 sub_1400153E4(void);
// 140019DF8: using guessed type __int64 sub_140019DF8(void);
// 14001DCD8: using guessed type __int64 __fastcall FwpsInjectionHandleDestroy0(_QWORD);
// 140026A00: using guessed type wchar_t aWaitForMutexOb[29];
// 1400292E8: using guessed type __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD);
// 1400292F0: using guessed type __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD);
// 140030180: using guessed type char byte_140030180;
// 140034440: using guessed type char byte_140034440;
// 140034F88: using guessed type char byte_140034F88;
// 140034F90: using guessed type __int64 qword_140034F90;
// 140036764: using guessed type int dword_140036764;

//----- (000000014001C5FC) ----------------------------------------------------
__int64 __fastcall sub_14001C5FC(__int64 *a1, __int64 a2, __int64 *a3, char a4)
{
  __int64 *v4; // rsi
  __int64 v5; // rbx
  __int64 *v6; // rdi
  char v7; // r14
  __int64 v8; // rcx
  __int64 v9; // rax
  unsigned int v10; // ebx
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  __int64 v16; // [rsp+30h] [rbp-D0h]
  UNICODE_STRING DestinationString; // [rsp+48h] [rbp-B8h]
  UNICODE_STRING v18; // [rsp+58h] [rbp-A8h]
  char v19; // [rsp+68h] [rbp-98h]
  __int128 v20; // [rsp+A0h] [rbp-60h]
  __int128 v21; // [rsp+B0h] [rbp-50h]
  __m128 SourceString[8]; // [rsp+C0h] [rbp-40h]
  __m128 v23[8]; // [rsp+140h] [rbp+40h]

  v4 = a3;
  v5 = a2;
  v6 = a1;
  v7 = a4;
  sub_14001E1C0(SourceString, 0, 0x80ui64);
  sub_14001E1C0(v23, 0, 0x80ui64);
  sub_14001C32C((__int64)SourceString, 0x40ui64);
  sub_14001C2D0((__int64)SourceString, 0x40ui64, v5);
  sub_14001C32C((__int64)v23, 0x40ui64);
  sub_14001C2D0((__int64)v23, 0x40ui64, v5);
  *(_QWORD *)&DestinationString.Length = 0i64;
  DestinationString.Buffer = 0i64;
  *(_QWORD *)&v18.Length = 0i64;
  v18.Buffer = 0i64;
  RtlInitUnicodeString(&DestinationString, (PCWSTR)SourceString);
  RtlInitUnicodeString(&v18, (PCWSTR)v23);
  v8 = *v6;
  v20 = xmmword_140027A70;
  v21 = xmmword_140027A80;
  v9 = sub_14001D418(v8);
  v16 = v9;
  if ( v9 )
  {
    sub_14001D4EC(v9);
    sub_14001D4C4();
    v11 = sub_14001D490(v16);
    v10 = v11;
    if ( v11 >= 0 )
    {
      sub_14001C11C(v16, (__m128 *)&v19, v7);
      v12 = sub_14001D44C();
      v10 = v12;
      if ( v12 >= 0 )
      {
        v13 = sub_14001D474(*v4);
        v10 = v13;
        if ( v13 >= 0 )
        {
          v14 = sub_14001B350(*v4, v7);
          v10 = v14;
          if ( v14 >= 0 )
          {
            sub_14001D434(*v4);
            return v10;
          }
          sub_140002E58(
            L"Unable to create queues",
            v14,
            0,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
            1514);
        }
        else
        {
          sub_140002E58(
            L"Unable to create symbolic link",
            v13,
            0,
            (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
            1506);
        }
      }
      else
      {
        sub_140002E58(
          L"Unable to create device",
          v12,
          0,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
          1495);
      }
    }
    else
    {
      sub_140002E58(
        L"Unable to assign device name",
        v11,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
        1482);
    }
    sub_14001D4AC(v16);
  }
  else
  {
    v10 = -1073741670;
    sub_140002E58(
      L"Unable to initialise control device",
      -1073741670,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
      1466);
  }
  return v10;
}
// 140027A70: using guessed type __int128 xmmword_140027A70;
// 140027A80: using guessed type __int128 xmmword_140027A80;
// 140027A90: using guessed type wchar_t aUnableToInitia[36];
// 140027AE0: using guessed type wchar_t aUnableToAssign[29];
// 140027B20: using guessed type wchar_t aUnableToCreate_2[24];
// 140027B50: using guessed type wchar_t aUnableToCreate_3[31];
// 140027B90: using guessed type wchar_t aUnableToCreate_4[24];

//----- (000000014001C854) ----------------------------------------------------
signed __int64 __fastcall sub_14001C854(__int64 a1, int a2)
{
  char v2; // bp
  int v3; // edi
  __int64 v4; // rsi
  int v6; // eax
  int v7; // ebx
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  const wchar_t *v12; // rcx
  int v13; // eax
  int v14; // eax
  int v15; // eax
  char v16; // al
  int v17; // ecx
  int v18; // [rsp+20h] [rbp-88h]
  __int64 v19; // [rsp+48h] [rbp-60h]
  __int64 v20; // [rsp+48h] [rbp-60h]
  __int64 v21; // [rsp+48h] [rbp-60h]
  __int64 v22; // [rsp+48h] [rbp-60h]
  __int64 v23; // [rsp+48h] [rbp-60h]
  __int64 v24; // [rsp+48h] [rbp-60h]
  __int64 v25; // [rsp+48h] [rbp-60h]
  __int64 v26; // [rsp+48h] [rbp-60h]
  __int64 v27; // [rsp+48h] [rbp-60h]

  v2 = 0;
  v3 = a2;
  v4 = a1;
  if ( a2 )
  {
    if ( a2 != 1 )
      return 3221225473i64;
    if ( byte_140036769 )
      return 0i64;
  }
  else if ( byte_140036768 )
  {
    return 0i64;
  }
  v6 = sub_140005C74(&qword_140030140, (__m128i *)&unk_140029FB8);
  v7 = v6;
  if ( v6 < 0 )
  {
    sub_140002E58(
      L"Failed to open engine",
      v6,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
      165);
    goto LABEL_49;
  }
  v8 = FwpmTransactionBegin0(qword_140030140, 0i64);
  v7 = v8;
  if ( v8 < 0 )
  {
    sub_140002E58(
      L"Unable to begin transaction for gEngineHandle",
      v8,
      qword_140030140,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
      172);
    goto LABEL_49;
  }
  v2 = 1;
  v9 = sub_14001D170(v3);
  v7 = v9;
  if ( v9 < 0 )
  {
    sub_140002E58(
      L"Failed to register sublayer, filtering type:",
      v9,
      v3,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
      183);
    goto LABEL_49;
  }
  if ( v3 )
  {
    if ( v3 != 1 )
      goto LABEL_42;
    LODWORD(v19) = 6;
    v11 = sub_140006260(
            qword_140030140,
            (__int64)&unk_140029FB8,
            7,
            (__int64)L"ConnectionTracking TCP Start Callout IPv4",
            (__int64)L"ConnectionTracking TCP connection lifetime",
            (__int64)L"ConnectionTracking TCP filter",
            (__int64)L"Detect connection establishment",
            20483,
            (__m128i *)&xmmword_14002D860,
            v19,
            (__m128i *)&unk_14002D130,
            (__m128i *)&unk_140029FF8,
            (__m128i *)&unk_14002A088,
            (__int64)sub_140015BA0,
            (__int64)sub_140006910,
            v4);
    v7 = v11;
    if ( v11 < 0 )
    {
      v18 = 356;
      v12 = L"Unable to register CONNECTION_TRACKING TCP AUTH_CONNECT_V4 callout";
      goto LABEL_20;
    }
    LODWORD(v25) = 6;
    v11 = sub_140006260(
            qword_140030140,
            (__int64)&unk_140029FB8,
            8,
            (__int64)L"ConnectionTracking TCP Start Callout IPv6",
            (__int64)L"ConnectionTracking TCP connection lifetime",
            (__int64)L"ConnectionTracking TCP filter",
            (__int64)L"Detect connection establishment",
            20483,
            (__m128i *)&xmmword_14002D860,
            v25,
            (__m128i *)&unk_14002D150,
            (__m128i *)&unk_140029FF8,
            (__m128i *)&unk_14002A098,
            (__int64)sub_140015BA0,
            (__int64)sub_140006910,
            v4);
    v7 = v11;
    if ( v11 < 0 )
    {
      v18 = 380;
      v12 = L"Unable to register CONNECTION_TRACKING TCP AUTH_CONNECT_V6 callout";
      goto LABEL_20;
    }
    LODWORD(v26) = 17;
    v11 = sub_140006260(
            qword_140030140,
            (__int64)&unk_140029FB8,
            9,
            (__int64)L"ConnectionTracking UDP Start Callout IPv4",
            (__int64)L"ConnectionTracking UDP connection lifetime",
            (__int64)L"ConnectionTracking UDP filter",
            (__int64)L"Detect connection establishment",
            20483,
            (__m128i *)&xmmword_14002D860,
            v26,
            (__m128i *)&unk_14002D130,
            (__m128i *)&unk_140029FF8,
            (__m128i *)&unk_14002A0A8,
            (__int64)sub_140015BA0,
            (__int64)sub_140006910,
            v4);
    v7 = v11;
    if ( v11 < 0 )
    {
      v18 = 404;
      v12 = L"Unable to register CONNECTION_TRACKING UDP AUTH_CONNECT_V4 callout";
      goto LABEL_20;
    }
    LODWORD(v27) = 17;
    v14 = sub_140006260(
            qword_140030140,
            (__int64)&unk_140029FB8,
            10,
            (__int64)L"ConnectionTracking UDP Start Callout IPv6",
            (__int64)L"ConnectionTracking UDP connection lifetime",
            (__int64)L"ConnectionTracking UDP filter",
            (__int64)L"Detect connection establishment",
            20483,
            (__m128i *)&xmmword_14002D860,
            v27,
            (__m128i *)&unk_14002D150,
            (__m128i *)&unk_140029FF8,
            (__m128i *)&unk_14002A0B8,
            (__int64)sub_140015BA0,
            (__int64)sub_140006910,
            v4);
    v7 = v14;
    if ( v14 < 0 )
    {
      sub_140002E58(
        L"Unable to register CONNECTION_TRACKING UDP AUTH_CONNECT_V6 callout",
        v14,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
        428);
      goto LABEL_21;
    }
    sub_140002DD4(
      L"sntp_drv::SNTPRegisterCallouts: Successfully registered callouts for all required layers for Network Logging",
      0i64,
      0i64,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
      432);
  }
  else
  {
    LODWORD(v19) = 6;
    v10 = sub_140006260(
            qword_140030140,
            (__int64)&unk_140029FB8,
            1,
            (__int64)L"NTP HTTP Start Callout IPv4",
            (__int64)L"HTTP connection lifetime",
            (__int64)L"HTTP TCP filter",
            (__int64)L"Detect connection establishment (HTTP)",
            20483,
            (__m128i *)&xmmword_14002D860,
            v19,
            (__m128i *)&unk_14002D130,
            (__m128i *)&unk_140029FE8,
            (__m128i *)&unk_14002A028,
            (__int64)sub_140015FB0,
            (__int64)sub_140006910,
            v4);
    v7 = v10;
    if ( v10 < 0 )
    {
      sub_140002E58(
        L"Unable to register HTTP AUTH_CONNECT_V4 callout",
        v10,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
        209);
      v2 = 1;
      goto LABEL_49;
    }
    LODWORD(v20) = 6;
    v11 = sub_140006260(
            qword_140030140,
            (__int64)&unk_140029FB8,
            2,
            (__int64)L"NTP HTTP Start Callout IPv6",
            (__int64)L"HTTP connection lifetime",
            (__int64)L"HTTP TCP filter",
            (__int64)L"Detect connection establishment (HTTP)",
            20483,
            (__m128i *)&xmmword_14002D860,
            v20,
            (__m128i *)&unk_14002D150,
            (__m128i *)&unk_140029FE8,
            (__m128i *)&unk_14002A038,
            (__int64)sub_140015FB0,
            (__int64)sub_140006910,
            v4);
    v7 = v11;
    if ( v11 < 0 )
    {
      v18 = 233;
      v12 = L"Unable to register HTTP AUTH_CONNECT_V6 callout";
LABEL_20:
      sub_140002E58(v12, v11, 0, (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c", v18);
LABEL_21:
      v2 = 1;
      goto LABEL_49;
    }
    LODWORD(v21) = 0;
    v11 = sub_140006260(
            qword_140030140,
            (__int64)&unk_140029FB8,
            3,
            (__int64)L"NTP Stream Inspect Callout IPv4",
            (__int64)L"Inspect stream data traffic",
            (__int64)L"NTP Stream Inspect filter (OUTBOUND condition)",
            (__int64)L"Inspect stream traffic (HTTP)",
            16389,
            (__m128i *)&unk_14002D8F0,
            v21,
            (__m128i *)&unk_14002CF70,
            (__m128i *)&unk_140029FE8,
            (__m128i *)&unk_14002A048,
            (__int64)sub_1400169E0,
            (__int64)sub_140006910,
            v4);
    v7 = v11;
    if ( v11 < 0 )
    {
      v18 = 257;
      v12 = L"Unable to register STREAM_V4 callout";
      goto LABEL_20;
    }
    LODWORD(v22) = 0;
    v11 = sub_140006260(
            qword_140030140,
            (__int64)&unk_140029FB8,
            4,
            (__int64)L"NTP Stream Inspect Callout IPv6",
            (__int64)L"Inspect stream data traffic",
            (__int64)L"NTP Stream Inspect filter (OUTBOUND condition)",
            (__int64)L"Inspect stream traffic (HTTP)",
            16389,
            (__m128i *)&unk_14002D8F0,
            v22,
            (__m128i *)&unk_14002CF90,
            (__m128i *)&unk_140029FE8,
            (__m128i *)&unk_14002A058,
            (__int64)sub_1400169E0,
            (__int64)sub_140006910,
            v4);
    v7 = v11;
    if ( v11 < 0 )
    {
      v18 = 281;
      v12 = L"Unable to register STREAM_V6 callout";
      goto LABEL_20;
    }
    LODWORD(v23) = 6;
    v11 = sub_140006260(
            qword_140030140,
            (__int64)&unk_140029FB8,
            5,
            (__int64)L"NTP Lifetime Tracking Callout IPv4",
            (__int64)L"Track connection lifetime",
            (__int64)L"NTP Lifetime tracking filter (OUTBOUND condition)",
            (__int64)L"Track connection lifetime",
            24580,
            (__m128i *)&xmmword_14002D860,
            v23,
            (__m128i *)&unk_14002D350,
            (__m128i *)&unk_140029FE8,
            (__m128i *)&unk_14002A068,
            (__int64)sub_1400169B0,
            (__int64)sub_140006910,
            v4);
    v7 = v11;
    if ( v11 < 0 )
    {
      v18 = 305;
      v12 = L"Unable to register ENDPOINT_CLOSURE_V4 callout";
      goto LABEL_20;
    }
    LODWORD(v24) = 6;
    v13 = sub_140006260(
            qword_140030140,
            (__int64)&unk_140029FB8,
            6,
            (__int64)L"NTP Lifetime Tracking Callout IPv6",
            (__int64)L"Track connection lifetime",
            (__int64)L"NTP Lifetime tracking filter (OUTBOUND condition)",
            (__int64)L"Track connection lifetime",
            24580,
            (__m128i *)&xmmword_14002D860,
            v24,
            (__m128i *)&unk_14002D360,
            (__m128i *)&unk_140029FE8,
            (__m128i *)&unk_14002A078,
            (__int64)sub_1400169B0,
            (__int64)sub_140006910,
            v4);
    v7 = v13;
    if ( v13 < 0 )
    {
      sub_140002E58(
        L"Unable to register ENDPOINT_CLOSURE_V6 callout",
        v13,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
        329);
      goto LABEL_21;
    }
    sub_140002DD4(
      L"sntp_drv::SNTPRegisterCallouts: Successfully registered callouts for all required layers for MTD",
      0i64,
      0i64,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
      332);
  }
  v2 = 1;
LABEL_42:
  v15 = FwpmTransactionCommit0(qword_140030140);
  v7 = v15;
  if ( v15 >= 0 )
  {
    v2 = 0;
    if ( v3 )
    {
      v16 = byte_140036769;
      if ( v3 == 1 )
        v16 = 1;
      byte_140036769 = v16;
    }
    else
    {
      byte_140036768 = 1;
    }
  }
  else
  {
    sub_140002E58(
      L"Unable to commit transaction for gEngineHandle",
      v15,
      qword_140030140,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
      438);
  }
LABEL_49:
  if ( v7 < 0 )
  {
    if ( v2 )
      FwpmTransactionAbort0(qword_140030140);
    if ( v3 )
    {
      if ( v3 != 1 )
        goto LABEL_57;
      byte_140036769 = 0;
      sub_1400064E0(7);
      sub_1400064E0(8);
      sub_1400064E0(9);
      v17 = 10;
    }
    else
    {
      byte_140036768 = 0;
      sub_1400064E0(1);
      sub_1400064E0(2);
      sub_1400064E0(3);
      sub_1400064E0(4);
      sub_1400064E0(5);
      v17 = 6;
    }
    sub_1400064E0(v17);
LABEL_57:
    if ( !byte_140036768 && !byte_140036769 )
      sub_140005630(&qword_140030140, (__int64)&unk_140029FB8);
  }
  return (unsigned int)v7;
}
// 14001DD02: using guessed type __int64 __fastcall FwpmTransactionBegin0(_QWORD, _QWORD);
// 14001DD08: using guessed type __int64 __fastcall FwpmTransactionCommit0(_QWORD);
// 14001DD0E: using guessed type __int64 __fastcall FwpmTransactionAbort0(_QWORD);
// 140025BC0: using guessed type wchar_t aFailedToOpenEn[22];
// 140025BF0: using guessed type wchar_t aUnableToBeginT[46];
// 140025C50: using guessed type wchar_t aFailedToRegist[45];
// 140025CB0: using guessed type wchar_t aDetectConnecti[39];
// 140025D00: using guessed type wchar_t aHttpTcpFilter[16];
// 140025D20: using guessed type wchar_t aHttpConnection[25];
// 140025D60: using guessed type wchar_t aNtpHttpStartCa_0[28];
// 140025DA0: using guessed type wchar_t aUnableToRegist_1[48];
// 140025E00: using guessed type wchar_t aNtpHttpStartCa[28];
// 140025E40: using guessed type wchar_t aUnableToRegist_2[48];
// 140025EA0: using guessed type wchar_t aInspectStreamT[30];
// 140025EE0: using guessed type wchar_t aNtpStreamInspe[47];
// 140025F40: using guessed type wchar_t aInspectStreamD[28];
// 140025F80: using guessed type wchar_t aNtpStreamInspe_0[32];
// 140025FC0: using guessed type wchar_t aUnableToRegist_3[37];
// 140026010: using guessed type wchar_t aNtpStreamInspe_1[32];
// 140026050: using guessed type wchar_t aUnableToRegist_4[37];
// 1400260A0: using guessed type wchar_t aTrackConnectio[26];
// 1400260E0: using guessed type wchar_t aNtpLifetimeTra_1[50];
// 140026150: using guessed type wchar_t aNtpLifetimeTra_0[35];
// 1400261A0: using guessed type wchar_t aUnableToRegist_5[47];
// 140026200: using guessed type wchar_t aNtpLifetimeTra[35];
// 140026250: using guessed type wchar_t aUnableToRegist_6[47];
// 1400262B0: using guessed type wchar_t aSntpDrvSntpreg[97];
// 140026380: using guessed type wchar_t aDetectConnecti_0[32];
// 1400263C0: using guessed type wchar_t aConnectiontrac_8[30];
// 140026400: using guessed type wchar_t aConnectiontrac_9[43];
// 140026460: using guessed type wchar_t aConnectiontrac_19[42];
// 1400264C0: using guessed type wchar_t aUnableToRegist_7[67];
// 140026550: using guessed type wchar_t aConnectiontrac_20[42];
// 1400265B0: using guessed type wchar_t aUnableToRegist_8[67];
// 140026640: using guessed type wchar_t aConnectiontrac_22[30];
// 140026680: using guessed type wchar_t aConnectiontrac_10[43];
// 1400266E0: using guessed type wchar_t aConnectiontrac_21[42];
// 140026740: using guessed type wchar_t aUnableToRegist_9[67];
// 1400267D0: using guessed type wchar_t aConnectiontrac_23[42];
// 140026830: using guessed type wchar_t aUnableToRegist_10[67];
// 1400268C0: using guessed type wchar_t aSntpDrvSntpreg_0[109];
// 1400269A0: using guessed type wchar_t aUnableToCommit[47];
// 14002D860: using guessed type __int128 xmmword_14002D860;
// 140030140: using guessed type __int64 qword_140030140;
// 140036768: using guessed type char byte_140036768;
// 140036769: using guessed type char byte_140036769;

//----- (000000014001D170) ----------------------------------------------------
signed __int64 __fastcall sub_14001D170(int a1)
{
  int v1; // ebx

  v1 = 0;
  if ( qword_140030140 == -1 )
    return 3221225473i64;
  if ( a1 == 1 )
  {
    v1 = sub_140006340(
           qword_140030140,
           (__int64)&unk_140029FB8,
           (__m128i *)&unk_140029FF8,
           (__int64)L"Sophos Connection Tracking Sub-Layer",
           (__int64)L"Sub-Layer for use by Sophos Connection Tracking callouts");
    if ( v1 < 0 )
      sub_140002E58(
        L"Unable to add CONNECTION_TRACKING_SUBLAYER",
        v1,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
        114);
  }
  else if ( !a1 )
  {
    v1 = sub_140006340(
           qword_140030140,
           (__int64)&unk_140029FB8,
           (__m128i *)&unk_140029FE8,
           (__int64)L"Sophos Network Threat Protection Sub-Layer",
           (__int64)L"Sub-Layer for use by Sophos Network Threat Protection callouts");
    if ( v1 < 0 )
      sub_140002E58(
        L"Unable to add NTP_INSPECT_SUBLAYER",
        v1,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
        130);
  }
  return (unsigned int)v1;
}
// 140025920: using guessed type wchar_t aSubLayerForUse_0[57];
// 1400259A0: using guessed type wchar_t aSophosConnecti[37];
// 140025A30: using guessed type wchar_t aUnableToAddCon[43];
// 140025A90: using guessed type wchar_t aSubLayerForUse_1[63];
// 140025B10: using guessed type wchar_t aSophosNetworkT_0[43];
// 140025B70: using guessed type wchar_t aUnableToAddNtp[35];
// 140030140: using guessed type __int64 qword_140030140;

//----- (000000014001D230) ----------------------------------------------------
void __fastcall sub_14001D230(int a1)
{
  signed __int64 v1; // rbx
  signed __int64 v2; // rbx

  if ( qword_140030140 != -1 )
  {
    if ( !a1 )
    {
      if ( byte_140036768 )
      {
        v1 = 0i64;
        do
          sub_140006454(qword_140030140, *(unsigned __int8 *)(v1++ + 5368898744i64));
        while ( v1 < 6 );
        FwpmSubLayerDeleteByKey0(qword_140030140, &unk_140029FE8);
        byte_140036768 = 0;
      }
LABEL_13:
      if ( !byte_140036769 )
        sub_140005630(&qword_140030140, (__int64)&unk_140029FB8);
      return;
    }
    if ( a1 == 1 && byte_140036769 )
    {
      v2 = 0i64;
      do
        sub_140006454(qword_140030140, *(unsigned __int8 *)(v2++ + 5368898752i64));
      while ( v2 < 4 );
      FwpmSubLayerDeleteByKey0(qword_140030140, &unk_140029FF8);
      byte_140036769 = 0;
    }
    if ( !byte_140036768 )
      goto LABEL_13;
  }
}
// 14001DD14: using guessed type __int64 __fastcall FwpmSubLayerDeleteByKey0(_QWORD, _QWORD);
// 140030140: using guessed type __int64 qword_140030140;
// 140036768: using guessed type char byte_140036768;
// 140036769: using guessed type char byte_140036769;

//----- (000000014001D318) ----------------------------------------------------
signed __int64 __fastcall sub_14001D318(__int64 *a1, int a2, __int64 (*a3)(void))
{
  int v3; // ebx
  __int64 *v4; // rdi
  signed __int64 result; // rax
  __int64 v6; // rax

  v3 = a2;
  v4 = a1;
  if ( !a1 )
    return 3221225485i64;
  if ( !qword_140037678 )
    return 3221225629i64;
  if ( a3 && !(unsigned __int8)sub_14001E1B0(a3) )
    return 3221225488i64;
  v6 = sub_14000ADF4(*v4);
  if ( (v3 != 2 || qword_140037678 != v6) && (v3 != 1 || qword_140037678 == v6) )
    result = 0i64;
  else
    result = 3221225675i64;
  return result;
}
// 140037678: using guessed type __int64 qword_140037678;

//----- (000000014001D398) ----------------------------------------------------
__int64 __fastcall sub_14001D398(_QWORD *a1, __int64 a2)
{
  __int64 result; // rax

  result = 0i64;
  *a1 = 32i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  a1[1] = a2;
  return result;
}

//----- (000000014001D3B0) ----------------------------------------------------
void __fastcall sub_14001D3B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  *(_DWORD *)a1 = 40;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = a3;
  *(_QWORD *)(a1 + 24) = a4;
  *(_DWORD *)(a1 + 36) = 4;
  *(_DWORD *)(a1 + 32) = 2;
}

//----- (000000014001D3D4) ----------------------------------------------------
__m128 *__fastcall sub_14001D3D4(__m128 *a1, int a2)
{
  int v2; // ebx
  __m128 *v3; // rdi
  __m128 *result; // rax

  v2 = a2;
  v3 = a1;
  result = sub_14001E1C0(a1, 0, 0x58ui64);
  LODWORD(v3->m128_u64[0]) = 88;
  LODWORD(v3->m128_u64[1]) = 2;
  BYTE5(v3->m128_u64[1]) = 1;
  HIDWORD(v3->m128_u64[0]) = v2;
  if ( v2 == 2 )
    v3[5].m128_i32[0] = -1;
  return result;
}

//----- (000000014001D418) ----------------------------------------------------
__int64 __fastcall sub_14001D418(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_140036898);
}
// 140036898: using guessed type __int64 qword_140036898;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014001D434) ----------------------------------------------------
__int64 __fastcall sub_14001D434(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_1400368A8);
}
// 1400368A8: using guessed type __int64 qword_1400368A8;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014001D44C) ----------------------------------------------------
__int64 sub_14001D44C()
{
  return sub_14001E1B0((__int64 (*)(void))qword_140036A28);
}
// 140036A28: using guessed type __int64 qword_140036A28;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014001D474) ----------------------------------------------------
__int64 __fastcall sub_14001D474(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_140036A50);
}
// 140036A50: using guessed type __int64 qword_140036A50;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014001D490) ----------------------------------------------------
__int64 __fastcall sub_14001D490(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_1400369E8);
}
// 1400369E8: using guessed type __int64 qword_1400369E8;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014001D4AC) ----------------------------------------------------
__int64 __fastcall sub_14001D4AC(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_140036980);
}
// 140036980: using guessed type __int64 qword_140036980;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014001D4C4) ----------------------------------------------------
__int64 sub_14001D4C4()
{
  return sub_14001E1B0((__int64 (*)(void))qword_140036A00);
}
// 140036A00: using guessed type __int64 qword_140036A00;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014001D4EC) ----------------------------------------------------
__int64 __fastcall sub_14001D4EC(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_1400369E0);
}
// 1400369E0: using guessed type __int64 qword_1400369E0;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014001D508) ----------------------------------------------------
__int64 sub_14001D508()
{
  return sub_14001E1B0((__int64 (*)(void))qword_140036A08);
}
// 140036A08: using guessed type __int64 qword_140036A08;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014001D530) ----------------------------------------------------
__int64 __fastcall sub_14001D530(__int64 a1)
{
  return sub_14001E1B0((__int64 (*)(void))qword_140036A10);
}
// 140036A10: using guessed type __int64 qword_140036A10;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014001D54C) ----------------------------------------------------
__int64 sub_14001D54C()
{
  return sub_14001E1B0((__int64 (*)(void))qword_140036B70);
}
// 140036B70: using guessed type __int64 qword_140036B70;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014001D584) ----------------------------------------------------
__int64 sub_14001D584()
{
  return sub_14001E1B0((__int64 (*)(void))qword_140036C90);
}
// 140036C90: using guessed type __int64 qword_140036C90;
// 140037458: using guessed type __int64 qword_140037458;

//----- (000000014001D5B0) ----------------------------------------------------
void __fastcall sub_14001D5B0(_DWORD *a1, int a2)
{
  *a1 = a2;
}

//----- (000000014001D5C0) ----------------------------------------------------
void sub_14001D5C0()
{
  sub_140005630(&qword_140030828, (__int64)&unk_140029FD8);
}
// 140030828: using guessed type __int64 qword_140030828;

//----- (000000014001D5D4) ----------------------------------------------------
__int64 __fastcall sub_14001D5D4(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  sub_1400064C0(a1, &unk_1400367A8);
  sub_1400064C0(v1, &unk_1400367B8);
  FwpmCalloutDeleteById0(qword_140030828, (unsigned int)dword_1400367B0);
  FwpmCalloutDeleteById0(qword_140030828, (unsigned int)dword_1400367C0);
  FwpsCalloutUnregisterById0((unsigned int)dword_1400367B4);
  return FwpsCalloutUnregisterById0((unsigned int)dword_1400367C4);
}
// 14001DC66: using guessed type __int64 __fastcall FwpsCalloutUnregisterById0(_QWORD);
// 14001DCAE: using guessed type __int64 __fastcall FwpmCalloutDeleteById0(_QWORD, _QWORD);
// 140030828: using guessed type __int64 qword_140030828;
// 1400367B0: using guessed type int dword_1400367B0;
// 1400367B4: using guessed type int dword_1400367B4;
// 1400367C0: using guessed type int dword_1400367C0;
// 1400367C4: using guessed type int dword_1400367C4;

//----- (000000014001D640) ----------------------------------------------------
int __fastcall sub_14001D640(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, _DWORD *a7)
{
  __int64 v7; // rax
  unsigned int *v8; // rcx
  int result; // eax
  int v10; // [rsp+60h] [rbp-28h]
  __int64 v11; // [rsp+64h] [rbp-24h]
  __int64 v12; // [rsp+70h] [rbp-18h]

  v11 = 0i64;
  v7 = *(_QWORD *)(a1 + 8);
  v12 = 0i64;
  v10 = 1;
  v8 = *(unsigned int **)(v7 + 40);
  v11 = *v8;
  HIDWORD(v11) = *((unsigned __int16 *)v8 + 2);
  if ( (unsigned int)sub_140014C04(2, &v12, 8i64, (__int64)&v10, 12i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64) )
    result = sub_140017980(2);
  else
    result = sub_140002E58(
               L"Failed to send notification for inbound traffic",
               0,
               0,
               (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\stonewalling.cpp",
               287);
  a7[6] &= 0xFFFFFFFE;
  *a7 = 4097;
  return result;
}
// 140027D70: using guessed type wchar_t aFailedToSendNo_0[48];

//----- (000000014001D720) ----------------------------------------------------
int __fastcall sub_14001D720(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, _DWORD *a7)
{
  __int64 v7; // rax
  unsigned int *v8; // rcx
  int result; // eax
  int v10; // [rsp+60h] [rbp-28h]
  __int64 v11; // [rsp+64h] [rbp-24h]
  __int64 v12; // [rsp+70h] [rbp-18h]

  v11 = 0i64;
  v7 = *(_QWORD *)(a1 + 8);
  v12 = 0i64;
  v10 = 2;
  v8 = *(unsigned int **)(v7 + 40);
  v11 = *v8;
  HIDWORD(v11) = *((unsigned __int16 *)v8 + 2);
  if ( (unsigned int)sub_140014C04(2, &v12, 8i64, (__int64)&v10, 12i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64) )
    result = sub_140017980(2);
  else
    result = sub_140002E58(
               L"Failed to send notification for outbound traffic",
               0,
               0,
               (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\stonewalling.cpp",
               325);
  a7[6] &= 0xFFFFFFFE;
  *a7 = 4097;
  return result;
}
// 140027DD0: using guessed type wchar_t aFailedToSendNo[49];

//----- (000000014001D7F8) ----------------------------------------------------
void sub_14001D7F8()
{
  KeInitializeMutex((PRKMUTEX)&unk_140036770, 0);
}

//----- (000000014001D808) ----------------------------------------------------
signed __int64 sub_14001D808()
{
  PRKMUTEX v1; // [rsp+20h] [rbp-18h]

  if ( !byte_140034F8A )
    return 3221225659i64;
  sub_140017E6C(&v1, &unk_140036770);
  if ( qword_140030828 != -1 )
  {
    sub_14001D5D4(qword_140030828);
    FwpmSubLayerDeleteByKey0(qword_140030828, &unk_14002A018);
    sub_140005630(&qword_140030828, (__int64)&unk_140029FD8);
  }
  sub_140017ECC(&v1);
  return 0i64;
}
// 14001DD14: using guessed type __int64 __fastcall FwpmSubLayerDeleteByKey0(_QWORD, _QWORD);
// 140030828: using guessed type __int64 qword_140030828;
// 140034F8A: using guessed type char byte_140034F8A;

//----- (000000014001D894) ----------------------------------------------------
signed __int64 __fastcall sub_14001D894(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rsi
  __int64 v4; // r15
  __int64 v5; // r12
  unsigned __int64 v7; // rdi
  bool v8; // r14
  unsigned int v9; // ebx
  char *v10; // rax
  void *v11; // rbx
  signed __int64 v12; // rax
  unsigned __int64 v13; // rcx
  void *v14; // rcx
  __int64 v15; // [rsp+40h] [rbp-19h]
  __int64 v16; // [rsp+40h] [rbp-19h]
  int v17; // [rsp+60h] [rbp+7h]
  PRKMUTEX v18; // [rsp+68h] [rbp+Fh]
  char v19; // [rsp+70h] [rbp+17h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !byte_140034F8A )
    return 3221225659i64;
  v7 = (unsigned __int64)(a3 * (unsigned __int128)0xAAAAAAAAAAAAAAABui64 >> 64) >> 2;
  if ( a3 != 6 * v7 )
    return 3221225990i64;
  sub_140017E6C(&v18, &unk_140036770);
  v17 = 0;
  v8 = qword_140030828 != -1;
  if ( qword_140030828 != -1 || (v17 = sub_140005C74(&qword_140030828, (__m128i *)&unk_140029FD8), v9 = v17, v17 >= 0) )
  {
    sub_140017E18((__int64)&v19, &qword_140030828, &v17, (__int64)sub_14001D5C0);
    v9 = v17;
    if ( v17 < 0 )
    {
LABEL_24:
      sub_140017E9C((__int64)&v19);
      goto LABEL_25;
    }
    if ( v8 )
      sub_14001D5D4(qword_140030828);
    if ( v3 )
    {
      if ( !v8 )
      {
        v17 = sub_140006340(
                qword_140030828,
                (__int64)&unk_140029FD8,
                (__m128i *)&unk_14002A018,
                (__int64)L"Sophos Endpoint Stonewalling Sub-Layer",
                (__int64)L"Sub-Layer for use by Sophos stonewalling filters");
        v9 = v17;
        if ( v17 < 0 )
          goto LABEL_24;
      }
      v17 = sub_140005E8C(
              qword_140030828,
              (__int64)&dword_1400367B0,
              &dword_1400367B4,
              (__int64)L"Stonewall remote endpoints (inbound)",
              (__int64)qword_140022D10,
              (__m128i *)"~U",
              (__m128i *)&unk_14002A108,
              (__int64)sub_14001D640,
              (__int64)sub_140006910,
              v5);
      v9 = v17;
      if ( v17 < 0 )
        goto LABEL_24;
      v17 = sub_140005E8C(
              qword_140030828,
              (__int64)&dword_1400367C0,
              &dword_1400367C4,
              (__int64)L"Stonewall remote endpoints (outbound)",
              (__int64)qword_140022D10,
              (__m128i *)&unk_14002D1C0,
              (__m128i *)&unk_14002A118,
              (__int64)sub_14001D720,
              (__int64)sub_140006910,
              v5);
      v9 = v17;
      if ( v17 < 0 )
        goto LABEL_24;
      v10 = (char *)ExAllocatePoolWithTag((POOL_TYPE)512, 40 * v7, 0x4C575453u);
      v11 = v10;
      if ( v7 )
      {
        v12 = (signed __int64)(v10 + 24);
        v13 = v7;
        do
        {
          *(_DWORD *)(v12 - 8) = 0;
          *(_QWORD *)(v12 + 8) = v4;
          v4 += 6i64;
          *(_DWORD *)v12 = 18;
          _mm_storeu_si128((__m128i *)(v12 - 24), (__m128i)xmmword_14002D4A0);
          v12 += 40i64;
          --v13;
        }
        while ( v13 );
      }
      LODWORD(v15) = v7;
      v17 = sub_1400051FC(
              qword_140030828,
              (__int64)&unk_140029FD8,
              (__int64)&unk_1400367A8,
              (__int64)L"Stonewall remote endpoints (inbound)",
              (__int64)qword_140022D10,
              20483,
              0x10000,
              (__int64)v11,
              v15,
              (__m128i *)"~U",
              (__m128i *)&unk_14002A018,
              (__m128i *)&unk_14002A108);
      if ( v17 < 0 )
      {
        v14 = v11;
LABEL_21:
        ExFreePoolWithTag(v14, 0);
        v9 = v17;
        goto LABEL_24;
      }
      LODWORD(v16) = v7;
      v17 = sub_1400051FC(
              qword_140030828,
              (__int64)&unk_140029FD8,
              (__int64)&unk_1400367B8,
              (__int64)L"Stonewall remote endpoints (outbound)",
              (__int64)qword_140022D10,
              20483,
              0x10000,
              (__int64)v11,
              v16,
              (__m128i *)&unk_14002D1C0,
              (__m128i *)&unk_14002A018,
              (__m128i *)&unk_14002A118);
      v14 = v11;
      if ( v17 < 0 )
        goto LABEL_21;
      ExFreePoolWithTag(v11, 0);
      v17 = sub_140017ED8((_QWORD **)&v19);
      v9 = v17;
      if ( v17 < 0 )
        goto LABEL_24;
    }
    v9 = 0;
    goto LABEL_24;
  }
LABEL_25:
  sub_140017ECC(&v18);
  return v9;
}
// 140022D10: using guessed type __int64 qword_140022D10[2];
// 140027BC0: using guessed type wchar_t aSubLayerForUse_2[49];
// 140027C30: using guessed type wchar_t aSophosEndpoint_0[39];
// 140027C80: using guessed type wchar_t aStonewallRemot[37];
// 140027CD0: using guessed type wchar_t aStonewallRemot_0[38];
// 14002D4A0: using guessed type __int128 xmmword_14002D4A0;
// 140030828: using guessed type __int64 qword_140030828;
// 140034F8A: using guessed type char byte_140034F8A;
// 1400367B0: using guessed type int dword_1400367B0;
// 1400367B4: using guessed type int dword_1400367B4;
// 1400367C0: using guessed type int dword_1400367C0;
// 1400367C4: using guessed type int dword_1400367C4;

//----- (000000014001DD70) ----------------------------------------------------
void __fastcall __noreturn sub_14001DD70(ULONG_PTR BugCheckParameter1)
{
  KeBugCheckEx(0xF7u, BugCheckParameter1, _security_cookie, BugCheckParameter3, 0i64);
}

//----- (000000014001DDA0) ----------------------------------------------------
void __noreturn sub_14001DDA0()
{
  sub_14001DDB0(8ui64);
}

//----- (000000014001DDB0) ----------------------------------------------------
void __fastcall __noreturn sub_14001DDB0(ULONG_PTR BugCheckParameter1)
{
  KeBugCheckEx(0xF7u, (unsigned int)BugCheckParameter1, _security_cookie, BugCheckParameter3, 1ui64);
}

//----- (000000014001DE30) ----------------------------------------------------
__int64 __fastcall sub_14001DE30(unsigned __int64 a1, __int64 a2, _DWORD *a3)
{
  __int64 v3; // r9
  unsigned __int64 v4; // r10
  __int64 result; // rax
  unsigned __int8 v6; // dl
  __int64 v7; // r9

  v3 = a1;
  v4 = a1;
  if ( *a3 & 4 )
    v4 = -a3[2] & (a1 + (signed int)a3[1]);
  result = *(_QWORD *)(a2 + 8);
  v6 = *(_BYTE *)(*(unsigned int *)(*(_QWORD *)(a2 + 16) + 8i64) + result + 3);
  if ( v6 & 0xF )
  {
    result = v6 & 0xF0;
    v3 = result + a1;
  }
  v7 = *(_QWORD *)((signed int)(*a3 & 0xFFFFFFF8) + v4) ^ v3;
  return result;
}

//----- (000000014001E1B0) ----------------------------------------------------
__int64 __usercall sub_14001E1B0@<rax>(__int64 (*a1)(void)@<rax>)
{
  return a1();
}

//----- (000000014001E1C0) ----------------------------------------------------
__m128 *__fastcall sub_14001E1C0(__m128 *a1, unsigned __int8 a2, unsigned __int64 a3)
{
  __m128 *result; // rax
  signed __int64 v4; // rdx
  unsigned __int64 v5; // r9
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // r8
  unsigned __int64 i; // r8
  __m128 v9; // xmm0
  char *v10; // r8
  char *v11; // rcx
  unsigned __int64 v12; // r8
  unsigned __int64 v13; // r9
  unsigned __int64 j; // r9
  unsigned __int64 v15; // r8

  result = a1;
  if ( a3 < 8 )
  {
    for ( i = a3 & 7; i; --i )
      *((_BYTE *)a1->m128_u64 + i - 1) = a2;
  }
  else
  {
    v4 = 72340172838076673i64 * a2;
    if ( a3 >= 0x4F )
    {
      v9 = _mm_movelh_ps((__m128)(unsigned __int64)v4, (__m128)(unsigned __int64)v4);
      *a1 = v9;
      v10 = (char *)a1 + a3;
      v11 = (char *)((unsigned __int64)&a1[1] & 0xFFFFFFFFFFFFFFF0ui64);
      v12 = v10 - v11;
      v13 = v12 >> 7;
      if ( v12 >> 7 )
      {
        do
        {
          *(__m128 *)v11 = v9;
          *((__m128 *)v11 + 1) = v9;
          v11 += 128;
          *((__m128 *)v11 - 6) = v9;
          *((__m128 *)v11 - 5) = v9;
          --v13;
          *((__m128 *)v11 - 4) = v9;
          *((__m128 *)v11 - 3) = v9;
          *((__m128 *)v11 - 2) = v9;
          *((__m128 *)v11 - 1) = v9;
        }
        while ( v13 );
        v12 &= 0x7Fu;
      }
      for ( j = v12 >> 4; j; --j )
      {
        *(__m128 *)v11 = v9;
        v11 += 16;
      }
      v15 = v12 & 0xF;
      if ( v15 )
        *(__m128 *)&v11[v15 - 16] = v9;
    }
    else
    {
      v5 = a3 & 0xFFFFFFFFFFFFFFF8ui64;
      v6 = (unsigned __int64)a1 + (a3 & 0xFFFFFFFFFFFFFFF8ui64);
      do
      {
        *(unsigned __int64 *)((char *)&result->m128_u64[-1] + v5) = v4;
        v5 -= 8i64;
      }
      while ( v5 );
      v7 = a3 & 7;
      if ( v7 )
        *(_QWORD *)(v6 + v7 - 8) = v4;
    }
  }
  return result;
}

//----- (000000014001E2C0) ----------------------------------------------------
__m128i *__fastcall sub_14001E2C0(__m128i *_RCX, unsigned __int64 a2, unsigned __int64 a3)
{
  __m128i *v3; // r11
  bool v4; // cf
  unsigned __int64 k; // r9
  __int64 v7; // rax
  unsigned __int64 l; // r8
  __int8 v9; // al
  __m128i *result; // rax
  unsigned int v11; // ecx
  unsigned __int64 v12; // r9
  __m128i v13; // xmm0
  __m128i v14; // xmm1
  signed int v15; // eax
  signed int v16; // eax
  __m128i v17; // xmm1
  __m128i v18; // xmm1
  unsigned __int64 i; // r9
  __int64 v21; // rax
  unsigned __int64 j; // r8
  char v23; // al
  __m128i *v24; // rax
  signed __int64 v25; // rcx
  unsigned __int64 v26; // r9
  __m128i v27; // xmm0
  __m128i v28; // xmm1
  signed int v29; // eax
  signed int v30; // eax
  __m128i v31; // xmm1
  __m128i v32; // xmm1
  void *retaddr; // [rsp+0h] [rbp+0h]

  v3 = _RCX;
  v4 = a2 < (unsigned __int64)_RCX;
  _RDX = a2 - (_QWORD)_RCX;
  if ( v4 )
  {
    _RCX = (__m128i *)((char *)_RCX + a3);
    if ( a3 >= 0x4F )
    {
      if ( _RDX > 0xFFFFFFFFFFFFFFF0ui64 )
      {
        for ( ; (unsigned __int8)_RCX & 0xF; LOBYTE(_RCX->m128i_i64[0]) = *((_BYTE *)_RCX->m128i_i64 + _RDX) )
        {
          _RCX = (__m128i *)((char *)_RCX - 1);
          --a3;
        }
      }
      else
      {
        v24 = _RCX;
        v25 = (unsigned __int8)_RCX & 0xF;
        if ( (_DWORD)v25 )
        {
          a3 -= (unsigned int)v25;
          v25 = -(signed __int64)(unsigned int)v25;
          _mm_storeu_si128(v24 - 1, _mm_loadu_si128((__m128i *)((char *)v24 + _RDX - 16)));
        }
        _RCX = (__m128i *)((char *)v24 + v25);
      }
      v26 = a3 >> 5;
      if ( a3 >> 5 <= 0x2000 || _RDX > 0xFFFFFFFFFFFFFE00ui64 )
        goto LABEL_54;
      do
      {
        v29 = 4;
        do
        {
          _RCX -= 8;
          __asm
          {
            prefetchnta byte ptr [rcx+rdx]
            prefetchnta byte ptr [rcx+rdx+40h]
          }
          --v29;
        }
        while ( v29 );
        _RCX += 32;
        v30 = 8;
        do
        {
          v31 = _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX - 32));
          _mm_stream_si128(_RCX - 1, _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX - 16)));
          _mm_stream_si128(_RCX - 2, v31);
          _RCX -= 4;
          v32 = _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX));
          _mm_stream_si128(_RCX + 1, _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX + 16)));
          _mm_stream_si128(_RCX, v32);
          --v30;
        }
        while ( v30 );
        a3 -= 512i64;
      }
      while ( a3 >= 0x200 );
      _InterlockedOr8((volatile signed __int8 *)&retaddr, 0);
      v26 = a3 >> 5;
      if ( a3 >> 5 )
      {
LABEL_54:
        a3 &= 0x1Fu;
        do
        {
          v27 = _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX - 16));
          v28 = _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX - 32));
          _RCX -= 2;
          _mm_store_si128(_RCX + 1, v27);
          _mm_store_si128(_RCX, v28);
          --v26;
        }
        while ( v26 );
      }
    }
    for ( i = a3 >> 3; i; _RCX->m128i_i64[0] = v21 )
    {
      v21 = *(__int64 *)((char *)&_RCX->m128i_i64[-1] + _RDX);
      _RCX = (__m128i *)((char *)_RCX - 8);
      --i;
    }
    for ( j = a3 & 7; j; LOBYTE(_RCX->m128i_i64[0]) = v23 )
    {
      v23 = *((_BYTE *)_RCX->m128i_i64 + _RDX - 1);
      _RCX = (__m128i *)((char *)_RCX - 1);
      --j;
    }
    result = v3;
  }
  else
  {
    if ( a3 >= 0x4F )
    {
      if ( _RDX < 0x10 )
      {
        for ( ; (unsigned __int8)_RCX & 0xF; _RCX = (__m128i *)((char *)_RCX + 1) )
        {
          --a3;
          LOBYTE(_RCX->m128i_i64[0]) = *((_BYTE *)_RCX->m128i_i64 + _RDX);
        }
      }
      else
      {
        v11 = -(signed int)_RCX & 0xF;
        if ( v11 )
        {
          a3 -= v11;
          _mm_storeu_si128(v3, _mm_loadu_si128((__m128i *)((char *)v3 + _RDX)));
        }
        _RCX = (__m128i *)((char *)v3 + v11);
      }
      v12 = a3 >> 5;
      if ( a3 >> 5 <= 0x2000 || _RDX < 0x200 )
        goto LABEL_55;
      do
      {
        v15 = 4;
        do
        {
          __asm
          {
            prefetchnta byte ptr [rcx+rdx]
            prefetchnta byte ptr [rcx+rdx+40h]
          }
          _RCX += 8;
          --v15;
        }
        while ( v15 );
        _RCX -= 32;
        v16 = 8;
        do
        {
          v17 = _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX + 16));
          _mm_stream_si128(_RCX, _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX)));
          _mm_stream_si128(_RCX + 1, v17);
          _RCX += 4;
          v18 = _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX - 16));
          _mm_stream_si128(_RCX - 2, _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX - 32)));
          _mm_stream_si128(_RCX - 1, v18);
          --v16;
        }
        while ( v16 );
        a3 -= 512i64;
      }
      while ( a3 >= 0x200 );
      _InterlockedOr8((volatile signed __int8 *)&retaddr, 0);
      v12 = a3 >> 5;
      if ( a3 >> 5 )
      {
LABEL_55:
        a3 &= 0x1Fu;
        do
        {
          v13 = _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX));
          v14 = _mm_loadu_si128((__m128i *)((char *)_RCX + _RDX + 16));
          _RCX += 2;
          _mm_store_si128(_RCX - 2, v13);
          _mm_store_si128(_RCX - 1, v14);
          --v12;
        }
        while ( v12 );
      }
    }
    for ( k = a3 >> 3; k; _RCX[-1].m128i_i64[1] = v7 )
    {
      v7 = *(__int64 *)((char *)_RCX->m128i_i64 + _RDX);
      _RCX = (__m128i *)((char *)_RCX + 8);
      --k;
    }
    for ( l = a3 & 7; l; _RCX[-1].m128i_i8[15] = v9 )
    {
      v9 = *((_BYTE *)_RCX->m128i_i64 + _RDX);
      _RCX = (__m128i *)((char *)_RCX + 1);
      --l;
    }
    result = v3;
  }
  return result;
}

//----- (0000000140027E40) ----------------------------------------------------
void sub_140027E40()
{
  ExDeleteNPagedLookasideList(&stru_140034240);
}

//----- (0000000140027E50) ----------------------------------------------------
void sub_140027E50()
{
  ExDeleteNPagedLookasideList(&stru_1400341C0);
}

//----- (0000000140027E60) ----------------------------------------------------
__int64 __fastcall sub_140027E60(__int64 a1, __int64 a2)
{
  return sub_140003B08(&unk_140032960, a2);
}

//----- (0000000140027E70) ----------------------------------------------------
__int64 sub_140027E70()
{
  return sub_140003B2C(&unk_140031930);
}
// 140003B2C: using guessed type __int64 __fastcall sub_140003B2C(_QWORD);

//----- (0000000140027E80) ----------------------------------------------------
__int64 sub_140027E80()
{
  return sub_140003B2C(&unk_140030900);
}
// 140003B2C: using guessed type __int64 __fastcall sub_140003B2C(_QWORD);

//----- (0000000140027E90) ----------------------------------------------------
void sub_140027E90()
{
  ExDeleteNPagedLookasideList(&stru_140034480);
}

//----- (0000000140027EA0) ----------------------------------------------------
__int64 sub_140027EA0()
{
  return sub_140007728((__int64)&unk_140034500, 8i64, 6i64, (__int64 (*)(void))sub_140007690);
}

//----- (0000000140027EC0) ----------------------------------------------------
__int64 sub_140027EC0()
{
  return sub_140007728((__int64)&unk_140034540, 8i64, 8i64, (__int64 (*)(void))sub_140007690);
}

//----- (0000000140027EE0) ----------------------------------------------------
void sub_140027EE0()
{
  sub_140007668(&qword_140034450[1]);
}

//----- (0000000140027EF0) ----------------------------------------------------
void sub_140027EF0()
{
  ExDeleteNPagedLookasideList(&stru_140034940);
}

//----- (0000000140027F00) ----------------------------------------------------
void sub_140027F00()
{
  ExDeleteNPagedLookasideList(&stru_1400348C0);
}

//----- (0000000140027F10) ----------------------------------------------------
void sub_140027F10()
{
  ExDeleteNPagedLookasideList(&stru_140034A40);
}

//----- (0000000140027F20) ----------------------------------------------------
void sub_140027F20()
{
  ExDeleteNPagedLookasideList(&stru_1400349C0);
}

//----- (0000000140027F30) ----------------------------------------------------
__int64 __fastcall sub_140027F30(__int64 a1, __int64 a2)
{
  return nullsub_1(qword_140034798, a2);
}
// 140004C90: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);

//----- (0000000140027F40) ----------------------------------------------------
__int64 (__fastcall **sub_140027F40())()
{
  return sub_140006684((__int64)&unk_1400347B8);
}

//----- (0000000140027F50) ----------------------------------------------------
__int64 (__fastcall **sub_140027F50())()
{
  return sub_1400066B0((__int64)&unk_1400347E0);
}

//----- (0000000140027F60) ----------------------------------------------------
__int64 sub_140027F60()
{
  return sub_140010900(stru_140034810);
}
// 140010900: using guessed type __int64 __fastcall sub_140010900(_QWORD);

//----- (0000000140027F70) ----------------------------------------------------
__int64 sub_140027F70()
{
  return sub_140008C20((__int64)stru_140034670);
}

//----- (0000000140027F80) ----------------------------------------------------
void sub_140027F80()
{
  ExDeleteNPagedLookasideList(&stru_140034940);
}

//----- (0000000140027F90) ----------------------------------------------------
void sub_140027F90()
{
  ExDeleteNPagedLookasideList(&stru_1400348C0);
}

//----- (0000000140027FA0) ----------------------------------------------------
void sub_140027FA0()
{
  ExDeleteNPagedLookasideList(&stru_140034A40);
}

//----- (0000000140027FB0) ----------------------------------------------------
void sub_140027FB0()
{
  ExDeleteNPagedLookasideList(&stru_1400349C0);
}

//----- (0000000140027FC0) ----------------------------------------------------
__int64 sub_140027FC0()
{
  return sub_140007728((__int64)&unk_140034AC0, 8i64, 2i64, (__int64 (*)(void))sub_14000ED60);
}

//----- (0000000140027FE0) ----------------------------------------------------
void sub_140027FE0()
{
  ExDeleteNPagedLookasideList(&stru_140034480);
}

//----- (0000000140027FF0) ----------------------------------------------------
__int64 sub_140027FF0()
{
  return sub_14000FBC8(stru_140034AD8);
}

//----- (0000000140028000) ----------------------------------------------------
__int64 sub_140028000()
{
  return sub_14000FBE0(&unk_140034AD0);
}

//----- (0000000140028010) ----------------------------------------------------
void sub_140028010()
{
  ExDeleteNPagedLookasideList(&stru_140034B00);
}

//----- (0000000140028020) ----------------------------------------------------
void sub_140028020()
{
  ExDeleteNPagedLookasideList(&stru_140034C00);
}

//----- (0000000140028030) ----------------------------------------------------
void sub_140028030()
{
  ExDeleteNPagedLookasideList(&stru_140034B80);
}

//----- (0000000140028040) ----------------------------------------------------
void sub_140028040()
{
  ExDeleteNPagedLookasideList(&stru_140034C80);
}

//----- (0000000140028050) ----------------------------------------------------
__int64 sub_140028050()
{
  return sub_140012DD4(&unk_140034D00);
}
// 140012DD4: using guessed type __int64 __fastcall sub_140012DD4(_QWORD);

//----- (0000000140028060) ----------------------------------------------------
void sub_140028060()
{
  ExDeleteNPagedLookasideList(&stru_140034E00);
}

//----- (0000000140028070) ----------------------------------------------------
__int64 sub_140028070()
{
  return sub_140007728((__int64)qword_140034E80, 88i64, 3i64, (__int64 (*)(void))sub_1400142B0);
}

//----- (0000000140028090) ----------------------------------------------------
__int64 sub_140028090()
{
  return sub_1400153D4(&unk_140034F98);
}
// 1400153D4: using guessed type __int64 __fastcall sub_1400153D4(_QWORD);

//----- (00000001400280A0) ----------------------------------------------------
__int64 __fastcall sub_1400280A0(__int64 a1, __int64 a2)
{
  return nullsub_1(&unk_1400351A0, a2);
}
// 140004C90: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);

//----- (00000001400280B0) ----------------------------------------------------
__int64 __fastcall sub_1400280B0(__int64 a1, __int64 a2)
{
  return nullsub_1(&unk_1400351A8, a2);
}
// 140004C90: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD);

//----- (00000001400280C0) ----------------------------------------------------
__int64 sub_1400280C0()
{
  return sub_140007728((__int64)&unk_140035EA0, 448i64, 5i64, (__int64 (*)(void))sub_14001A6C0);
}

//----- (00000001400280E0) ----------------------------------------------------
void sub_1400280E0()
{
  sub_140003B78((__int64)&stru_140035E88);
}

//----- (000000014003B000) ----------------------------------------------------
__int64 __fastcall sub_14003B000(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v5; // [rsp+30h] [rbp-28h]
  int v6; // [rsp+38h] [rbp-20h]

  v5 = a4;
  v6 = 16;
  return PcwAddInstance(a1, a2, a3, 1i64, &v5);
}
// 14001DF4C: using guessed type __int64 __fastcall PcwAddInstance(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014003B048) ----------------------------------------------------
__int64 __fastcall sub_14003B048(__int64 a1, __int64 a2)
{
  int v3; // [rsp+20h] [rbp-50h]
  const wchar_t *v4; // [rsp+28h] [rbp-48h]
  int v5; // [rsp+30h] [rbp-40h]
  int v6; // [rsp+34h] [rbp-3Ch]
  int *v7; // [rsp+38h] [rbp-38h]
  int v8; // [rsp+40h] [rbp-30h]
  int v9; // [rsp+44h] [rbp-2Ch]
  void *v10; // [rsp+48h] [rbp-28h]
  __int64 v11; // [rsp+50h] [rbp-20h]
  __int64 v12; // [rsp+58h] [rbp-18h]

  v6 = 0;
  v9 = 0;
  v4 = L"Sophos IPS Incoming Packets";
  v10 = &unk_14002E178;
  v11 = a1;
  v12 = a2;
  v7 = &v3;
  v3 = 3670070;
  v5 = 256;
  v8 = 2;
  return PcwRegister(&qword_1400343F8, &v5);
}
// 14001DF40: using guessed type __int64 __fastcall PcwRegister(_QWORD, _QWORD);
// 1400343F8: using guessed type __int64 qword_1400343F8;
// 14003B160: using guessed type wchar_t aSophosIpsIncom[28];

//----- (000000014003B0C4) ----------------------------------------------------
__int64 __fastcall sub_14003B0C4(__int64 a1, __int64 a2)
{
  int v3; // [rsp+20h] [rbp-50h]
  const wchar_t *v4; // [rsp+28h] [rbp-48h]
  int v5; // [rsp+30h] [rbp-40h]
  int v6; // [rsp+34h] [rbp-3Ch]
  int *v7; // [rsp+38h] [rbp-38h]
  int v8; // [rsp+40h] [rbp-30h]
  int v9; // [rsp+44h] [rbp-2Ch]
  void *v10; // [rsp+48h] [rbp-28h]
  __int64 v11; // [rsp+50h] [rbp-20h]
  __int64 v12; // [rsp+58h] [rbp-18h]

  v6 = 0;
  v9 = 0;
  v4 = L"Sophos IPS Outgoing Packets";
  v10 = &unk_14002E188;
  v11 = a1;
  v12 = a2;
  v7 = &v3;
  v3 = 3670070;
  v5 = 256;
  v8 = 2;
  return PcwRegister(&qword_140034400, &v5);
}
// 14001DF40: using guessed type __int64 __fastcall PcwRegister(_QWORD, _QWORD);
// 140034400: using guessed type __int64 qword_140034400;
// 14003B1A0: using guessed type wchar_t aSophosIpsOutgo[28];

//----- (000000014003B140) ----------------------------------------------------
__int64 sub_14003B140()
{
  return PcwUnregister(qword_1400343F8);
}
// 14001DF46: using guessed type __int64 __fastcall PcwUnregister(_QWORD);
// 1400343F8: using guessed type __int64 qword_1400343F8;

//----- (000000014003B14C) ----------------------------------------------------
__int64 sub_14003B14C()
{
  return PcwUnregister(qword_140034400);
}
// 14001DF46: using guessed type __int64 __fastcall PcwUnregister(_QWORD);
// 140034400: using guessed type __int64 qword_140034400;

//----- (000000014003C000) ----------------------------------------------------
__int64 sub_14003C000()
{
  char v0; // di
  char v1; // r15
  char v2; // si
  const wchar_t *v3; // rcx
  int v4; // eax
  int v5; // eax
  int v6; // ebx
  const wchar_t *v7; // rcx
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int ClientId; // [rsp+20h] [rbp-68h]
  PCLIENT_ID ClientIda; // [rsp+20h] [rbp-68h]
  __int64 v15; // [rsp+40h] [rbp-48h]
  char v16; // [rsp+48h] [rbp-40h]
  HANDLE ThreadHandle; // [rsp+50h] [rbp-38h]

  v0 = 0;
  v1 = 0;
  v2 = 0;
  sub_140002DB4();
  byte_140034F89 = RtlIsNtDdiVersionAvailable(100794368i64);
  byte_140034F8A = byte_140034F89;
  if ( byte_140034F89 )
  {
    v3 = L"Driver running on Windows 8+";
    v4 = 1551;
  }
  else
  {
    v3 = L"Driver running on Windows 7";
    v4 = 1555;
  }
  sub_140002E58(v3, 0, 0, (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c", v4);
  sub_140019438();
  sub_1400184C0();
  sub_1400171C8();
  v5 = sub_14001C258();
  v6 = v5;
  if ( v5 < 0 )
  {
    ClientId = 1573;
    v7 = L"Unable to initialise EventBuffer(s)";
LABEL_6:
    sub_140002E58(v7, v5, 0, (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c", ClientId);
    goto LABEL_29;
  }
  v0 = 1;
  sub_140019900();
  v5 = sub_140004D54();
  v6 = v5;
  if ( v5 < 0 )
  {
    ClientId = 1586;
    v7 = L"Unable to initialise process exclusions";
    goto LABEL_6;
  }
  v1 = 1;
  v5 = sub_1400154D4();
  v6 = v5;
  if ( v5 < 0 )
  {
    ClientId = 1597;
    v7 = L"Unable to initialise HTTP Cache";
    goto LABEL_6;
  }
  v2 = 1;
  sub_140002D1C();
  sub_14001C0E8(&FastMutex);
  KeInitializeMutex(&Mutex, 0);
  sub_140019F90();
  sub_14001D7F8();
  v5 = sub_14001C1C4();
  v6 = v5;
  if ( v5 < 0 )
  {
    ClientId = 1622;
    v7 = L"Unable to initialise driver objects";
    goto LABEL_6;
  }
  v5 = sub_14001C5FC((__int64 *)&v16, (__int64)L"SNTP", &v15, 0);
  v6 = v5;
  if ( v5 < 0 )
  {
    ClientId = 1633;
    v7 = L"Unable to initialise SNTP device objects";
    goto LABEL_6;
  }
  qword_140037700 = sub_140008568(v15);
  if ( sub_14000A4D0() )
  {
    v5 = sub_14001C5FC((__int64 *)&v16, (__int64)L"SNTPIPS", &v15, 1);
    v6 = v5;
    if ( v5 < 0 )
    {
      ClientId = 1648;
      v7 = L"Unable to initialise SNTP IPS device objects";
      goto LABEL_6;
    }
  }
  v8 = sub_14000A59C(v15);
  if ( v8 < 0 )
    sub_140002E58(
      L"Unable to initialize IPS callout",
      v8,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
      1656);
  v9 = FwpsInjectionHandleCreate0(0i64, 2i64, &qword_140034F90);
  v6 = v9;
  if ( v9 >= 0 )
  {
    InitializeListHead(&stru_140037780);
    sub_14000AD60(&unk_140037770);
    InitializeListHead(&stru_140037760);
    sub_14000AD60(&unk_140037758);
    KeInitializeEvent(&Object, 0, 0);
    v10 = PsCreateSystemThread(&ThreadHandle, 0x1FFFFFu, 0i64, 0i64, 0i64, (PKSTART_ROUTINE)sub_1400164F0, 0i64);
    v6 = v10;
    if ( v10 >= 0 )
    {
      v11 = ObReferenceObjectByHandle(ThreadHandle, 0, 0i64, 0, &qword_1400376F8, 0i64);
      v6 = v11;
      if ( v11 < 0 )
        sub_140002E58(
          L"ObReferenceObjectByHandle failed",
          v11,
          0,
          (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
          1712);
      ZwClose(ThreadHandle);
      if ( byte_140034440 & 1 )
        sub_14001C278(&unk_140030040, (__int64)&unk_140029DF0, 0i64);
    }
    else
    {
      sub_140002E58(
        L"Unable to create PendedPacketWorker thread",
        v10,
        0,
        (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
        1697);
    }
  }
  else
  {
    sub_140002E58(
      L"Unable to create injection handle",
      v9,
      0,
      (__int64)"c:\\forjenkins\\basefolder\\ntp\\source\\driver\\sntp\\sntp_drv.c",
      1668);
    qword_140034F90 = 0i64;
  }
LABEL_29:
  if ( v6 < 0 )
  {
    if ( byte_140034440 & 8 )
    {
      LODWORD(ClientIda) = 1723;
      sub_140014A78(&unk_140030040, (__int64)&unk_140029E50, 0i64, v6, ClientIda);
    }
    sub_140002D9C();
    sub_140019DF8();
    if ( v2 && !KeWaitForSingleObject(&Mutex, 0, 0, 0, 0i64) )
      KeReleaseMutex(&Mutex, 0);
    if ( qword_140034F90 )
      FwpsInjectionHandleDestroy0(qword_140034F90);
    if ( v0 )
      sub_14001BE38();
    if ( v2 )
      sub_1400153E4();
    if ( v1 )
      sub_140004F7C();
    sub_1400197DC();
    sub_14001859C();
    sub_140019408();
  }
  return (unsigned int)v6;
}
// 1400153E4: using guessed type __int64 sub_1400153E4(void);
// 140019DF8: using guessed type __int64 sub_140019DF8(void);
// 14001DCD2: using guessed type __int64 __fastcall FwpsInjectionHandleCreate0(_QWORD, _QWORD, _QWORD);
// 14001DCD8: using guessed type __int64 __fastcall FwpsInjectionHandleDestroy0(_QWORD);
// 14001E025: using guessed type __int64 __fastcall RtlIsNtDdiVersionAvailable(_QWORD);
// 140034440: using guessed type char byte_140034440;
// 140034F89: using guessed type char byte_140034F89;
// 140034F8A: using guessed type char byte_140034F8A;
// 140034F90: using guessed type __int64 qword_140034F90;
// 140037700: using guessed type __int64 qword_140037700;
// 14003C4F0: using guessed type wchar_t aDriverRunningO[29];
// 14003C530: using guessed type wchar_t aDriverRunningO_0[28];
// 14003C570: using guessed type wchar_t aUnableToInitia_0[36];
// 14003C5C0: using guessed type wchar_t aUnableToInitia_1[40];
// 14003C610: using guessed type wchar_t aUnableToInitia_2[32];
// 14003C650: using guessed type wchar_t aUnableToInitia_3[36];
// 14003C6A0: using guessed type wchar_t aSntp[5];
// 14003C6B0: using guessed type wchar_t aUnableToInitia_4[41];
// 14003C710: using guessed type wchar_t aSntpips[8];
// 14003C720: using guessed type wchar_t aUnableToInitia_5[45];
// 14003C780: using guessed type wchar_t aUnableToInitia_6[33];
// 14003C7D0: using guessed type wchar_t aUnableToCreate_5[34];
// 14003C820: using guessed type wchar_t aUnableToCreate_6[43];
// 14003C880: using guessed type wchar_t aObreferenceobj_0[33];

//----- (000000014003C414) ----------------------------------------------------
__int64 sub_14003C414()
{
  _security_init_cookie();
  return sub_14003C000();
}
// 14003C440: using guessed type __int64 _security_init_cookie(void);

// ALL OK, 1059 function(s) have been successfully decompiled
