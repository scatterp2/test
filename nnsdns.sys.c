/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall sub_11008(__int64 a1, unsigned __int16 a2, __int64 a3);
__int64 __fastcall sub_1102C(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4);
__int64 __fastcall sub_110CC(__int64 a1, unsigned __int16 a2, __int64 a3, const char *a4);
__int64 sub_11144();
char __fastcall sub_11340(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
__int64 __fastcall sub_114D0(__int64 a1);
void __fastcall sub_11628(const signed __int32 *a1);
__int64 sub_117FC();
__int64 __fastcall sub_118F4(char a1);
__int64 sub_11A68();
__int64 sub_11E24();
__int64 __fastcall sub_12200(char a1);
__int64 sub_12374(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_123B0(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_12408();
__int64 sub_125BC();
__int64 sub_127CC();
__int64 sub_12970();
__int64 sub_12B74();
__int64 __fastcall sub_12C8C(__int64 a1, _QWORD *a2);
__int64 sub_1312C();
__int64 __fastcall sub_131EC(char a1);
__int64 sub_133DC(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 __fastcall sub_1342C(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_13650(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_13864(__int64 a1, int a2, __int64 a3, __int64 a4, int a5, char a6);
__int64 __fastcall sub_13AFC(__int64 a1);
__int64 __fastcall sub_13CDC(__int64 a1, __int64 a2, int a3, __int64 a4, int a5);
__int64 __fastcall sub_13F00(__int64 a1, __int64 a2);
__int64 __fastcall sub_14140(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5);
__int64 __fastcall sub_14358(__int64 a1, __int64 a2, __int16 a3);
__int64 __fastcall sub_14544(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 sub_14580(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_145D4(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_14640(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_14720(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_14774(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 __fastcall sub_14818(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_148D8(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall sub_14934(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_149A0(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_14A2C(__int64 a1, __int64 a2, __int64 a3, int a4, const char *a5);
__int64 __fastcall sub_14AB8(__int64 a1, __int64 a2, __int64 a3, double a4);
__int64 sub_14B00(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_14B50(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_14BA4(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_14BEC(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_14C58(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_14CAC(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 __fastcall sub_14D60(__int64 a1, unsigned __int16 a2, __int64 a3, const char *a4);
__int64 __fastcall sub_14DC8(__int64 a1, __int64 a2, __int64 a3, const char *a4);
__int64 __fastcall sub_14E48(__int64 a1, __int64 a2, __int64 a3, const char *a4);
__int64 __fastcall sub_14EDC(__int64 a1, __int64 a2, __int64 a3, const char *a4);
__int64 __fastcall sub_14F80(__int64 a1, __int64 a2, __int64 a3, const char *a4);
__int64 __fastcall sub_15018(__int64 a1, unsigned __int16 a2, __int64 a3, const char *a4, const char *a5);
__int64 __fastcall sub_150C8(__int64 a1);
int __fastcall sub_15208(__int64 *a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_15310(_QWORD *a1);
__int64 __fastcall sub_153FC(__int64 a1);
__int64 __fastcall sub_15550(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
char __fastcall sub_15B58(__int64 a1);
__int64 __fastcall sub_15D44(__int64 a1, __int64 a2, _BYTE *a3);
__int64 __fastcall sub_16234(__int64 a1, int *a2);
__int64 __fastcall sub_16A88(__int64 a1, __int64 *a2);
__int64 __fastcall sub_16F24(_DWORD *a1, _BYTE *a2);
__int64 __fastcall sub_17220(_WORD *a1, __int64 a2);
__int64 __fastcall sub_172D8(__int64 a1, unsigned __int16 *a2, unsigned int a3, double *a4);
__int64 __fastcall sub_17674(__int64 a1, unsigned __int16 *a2, unsigned int a3, char a4, _WORD *a5);
__int64 __fastcall sub_179FC(__int64 a1, unsigned __int16 **a2, int *a3, unsigned __int8 *a4);
__int64 __fastcall sub_17DA4(__int64 a1, int a2, __int64 a3);
char __fastcall sub_1861C(int a1);
const char *__fastcall sub_186BC(int a1);
void **__fastcall sub_18700(__int64 a1);
__int64 __fastcall sub_18C5C(__int64 a1, __int64 a2);
__int64 __fastcall sub_18FA0(__int64 *a1);
char __fastcall sub_19334(char *Str);
char __fastcall sub_19494(char *Str);
__int64 __fastcall sub_19600(unsigned __int64 a1, __int64 a2, __int64 a3);
_DWORD *__fastcall sub_19A30(__int64 a1, unsigned int a2);
__int64 __fastcall sub_19BCC(__int64 a1);
__int64 sub_19C84();
__int64 __fastcall sub_19D78(__int64 a1, __int64 a2, __int64 a3, int a4, const char *a5);
__int64 sub_19E18(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 __fastcall sub_19EA0(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_19F24(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, char a5, const char *a6);
__int64 __fastcall sub_19FC0(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 sub_1A030(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_1A078(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_1A0E4(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_1A140(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_1A298(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 __fastcall sub_1A400(__int64 a1, __int64 a2, __int64 a3, const char *a4, char a5, char a6, const char *a7);
__int64 __fastcall sub_1A4CC(__int64 a1, __int64 a2, __int64 a3, const char *a4, const char *a5, const char *a6);
__int64 sub_1A5CC();
__int64 sub_1A774();
__int64 __fastcall sub_1A864(__int64 a1, __int64 a2);
__int64 __fastcall sub_1A9A0(PFAST_MUTEX FastMutex); // idb
__int64 __fastcall sub_1AA94(__int64 *a1, int *a2, ULONG_PTR **a3, _DWORD *a4);
__int64 __fastcall sub_1ACDC(unsigned __int64 a1, _QWORD *a2, _DWORD *a3);
__int64 __fastcall sub_1AE3C(unsigned __int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_1AF84(ULONG_PTR BugCheckParameter1); // idb
__int64 __fastcall sub_1B038(PFAST_MUTEX FastMutex, int *a2);
__int64 __fastcall sub_1B8B0(PFAST_MUTEX FastMutex); // idb
__int64 __fastcall sub_1B918(__int64 a1);
__int64 sub_1BDFC();
char __fastcall sub_1BFB4(__int64 a1);
__int64 __fastcall sub_1C094(__int64 a1, __int64 a2, __int64 a3, __int16 a4, __int64 a5);
__int64 __fastcall sub_1C1E8(__int64 a1, char a2, __int64 *a3, __int64 a4);
NTSTATUS __stdcall DriverEntry(_DRIVER_OBJECT *DriverObject, PUNICODE_STRING RegistryPath);
void __fastcall sub_1C6E8(PDEVICE_OBJECT DeviceObject);
__int64 sub_1C820();
__int64 __fastcall sub_1C950(__int64 a1, IRP *a2);
__int64 sub_1C978();
__int64 __fastcall sub_1CD6C(__int64 a1, IRP *a2);
__int64 __fastcall sub_1CE18(__int64 a1, IRP *a2);
void sub_1D0B8();
__int64 __fastcall sub_1D1C8(); // weak
__int64 __fastcall sub_1D1D4(__int64 a1, unsigned __int16 a2);
PVOID __fastcall sub_1D254(int a1, unsigned int a2, ULONG a3);
void __fastcall sub_1D2D8(PVOID P, ULONG Tag);
PVOID __fastcall sub_1D34C(__int64 a1, void *a2, unsigned int a3, unsigned int a4);
char *__fastcall sub_1D4C0(int a1, unsigned int a2, ULONG a3);
void __fastcall sub_1D544(PVOID P);
_DWORD *__fastcall sub_1D664(__int64 a1);
void __fastcall sub_1D6CC(__int64 a1, __int64 a2);
__int64 __fastcall sub_1D7F8(PERESOURCE Resource); // idb
__int64 __fastcall sub_1D8CC(PERESOURCE Resource); // idb
BOOLEAN __fastcall sub_1D9A0(PERESOURCE Resource);
BOOLEAN __fastcall sub_1DA78(PERESOURCE Resource);
void __fastcall sub_1DB50(PERESOURCE Resource);
bool __fastcall sub_1DC1C(struct _KEVENT **a1, char a2);
void __fastcall sub_1DC94(PVOID P);
int __fastcall sub_1DCFC(PRKEVENT Event);
int __fastcall sub_1DD64(PRKEVENT Event);
void __fastcall sub_1DE30(__int64 a1);
void __fastcall sub_1DF10(PFAST_MUTEX FastMutex);
void __fastcall sub_1DFDC(PFAST_MUTEX FastMutex);
__int64 __fastcall sub_1E0A8(PVOID P); // idb
_QWORD *__fastcall sub_1E11C(__int64 a1, int a2, __int64 a3);
void __fastcall sub_1E294(__int64 a1, unsigned int a2);
__int64 __fastcall sub_1E308(PVOID Object); // idb
__int64 __fastcall sub_1E374(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_1E404(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_1E4A0(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall sub_1E4E8(__int64 a1, __int64 a2, __int64 a3, int a4);
PVOID __fastcall sub_1E578(int a1, unsigned int a2, ULONG a3);
void __fastcall sub_1E694(PVOID P, ULONG Tag);
char *__fastcall sub_1E78C(int a1, unsigned int a2, ULONG a3);
_DWORD *__fastcall sub_1E940(__int64 a1);
__int64 __fastcall sub_1EA44(_QWORD *a1);
void __fastcall sub_1EAC8(PKSPIN_LOCK SpinLock, KIRQL *a2);
void __fastcall sub_1EB80(PKSPIN_LOCK SpinLock, KIRQL a2);
bool __fastcall sub_1EC24(struct _KEVENT **a1, char a2);
void __fastcall sub_1ED0C(PVOID P);
int __fastcall sub_1EDA4(PRKEVENT Event);
void __fastcall HandleInformation(PVOID StartContext);
unsigned __int8 __fastcall sub_1EED0(PVOID *Object, __int64 a2, __int64 a3);
__int64 __fastcall sub_1F040(PVOID Object); // idb
__int64 __fastcall sub_1F0D4(void ***a1);
__int64 __fastcall sub_1F3E0(unsigned int a1, char a2);
__int64 __fastcall sub_1F694(PVOID P); // idb
void __fastcall sub_1F9F0(__int64 a1, char a2);
void __fastcall sub_1FAB4(__int64 a1, unsigned int a2);
__int64 __fastcall sub_1FBC0(PVOID Object); // idb
__int64 __fastcall sub_1FC68(ULONG Count, PVOID Object[]); // idb
__int64 __fastcall sub_1FD74(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, __int64 a5, int a6);
__int64 __fastcall sub_1FDD4(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, __int64 a6, int a7);
__int64 __fastcall sub_1FE44(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall sub_1FE98(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall sub_1FEF4(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 sub_1FF64(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 __fastcall sub_1FFB0(__int64 a1, __int64 a2, _QWORD *a3);
__int64 sub_204A8();
__int64 (**sub_207F0())(void);
void sub_2091C();
__int64 __fastcall sub_20AD8(unsigned int a1);
char *__fastcall sub_20D44(unsigned int a1);
void sub_20F24();
__int64 __fastcall sub_21008(__int64 a1);
__int64 sub_215C0();
__int64 __fastcall sub_21C8C(unsigned int a1, int a2, unsigned int a3, _DWORD *a4);
__int64 __fastcall sub_22284(__int64 a1, unsigned int a2, __int64 a3);
__int64 __fastcall sub_22648(int a1);
__int64 __fastcall sub_227A4(int a1);
__int64 __fastcall sub_228CC(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4);
__int64 sub_2297C(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_229E8(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 __fastcall sub_22A74(__int16 *a1, int a2, unsigned int *a3);
__int64 __fastcall sub_22C48(char a1);
__int64 sub_22CE4();
__int64 __fastcall sub_22EA4(unsigned int a1, __int64 a2);
__int64 sub_22FF4();
__int64 sub_23264();
__int64 __fastcall sub_234EC(int a1);
__int64 sub_238B0();
__int64 sub_24014();
__int64 __fastcall sub_24374(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_245CC(unsigned int *a1);
__int64 __fastcall sub_24728(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_24814(__int64 a1, int a2, unsigned int a3, void *a4);
__int64 __fastcall sub_24A10(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_24C84(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_24F9C(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_2517C(__int64 a1, __int64 a2, __int64 a3);
__int64 sub_25320();
__int64 __fastcall sub_25418(__int64 a1, _BYTE *a2);
bool __fastcall sub_254F4(__int64 a1);
char __fastcall sub_25558(PFAST_MUTEX FastMutex);
char __fastcall sub_255B8(PFAST_MUTEX FastMutex);
char __fastcall sub_25618(PFAST_MUTEX FastMutex);
char __fastcall sub_25680(PFAST_MUTEX FastMutex);
const char *__fastcall sub_256E4(unsigned int a1);
const char *__fastcall sub_25B40(int a1);
const char *__fastcall sub_26044(int a1);
const char *__fastcall sub_26094(int a1);
const char *__fastcall sub_26134(int a1);
__int64 __fastcall sub_26178(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_261DC(__int64 a1, __int64 a2, __int64 a3, double a4);
__int64 __fastcall sub_26250(__int64 a1, __int64 a2, __int64 a3, double a4);
__int64 __fastcall sub_262B4(double a1, int a2, double *a3);
__int64 sub_26420(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 __fastcall sub_26484(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall sub_264E0(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_26550(int a1, _QWORD *a2);
__int64 __fastcall sub_26734(int a1, __int64 a2);
__int64 __fastcall sub_26894(int a1, struct _FAST_MUTEX *a2, KIRQL *a3);
__int64 __fastcall sub_269A4(int a1, struct _FAST_MUTEX *a2, KIRQL a3);
__int64 __fastcall sub_26A80(__int64 a1, __int64 a2, char a3);
__int64 __fastcall sub_26BAC(__int64 a1, __int64 a2, char a3);
_DWORD *__fastcall sub_26CD0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6, int a7, int a8, int a9, int a10, _DWORD *a11);
__int64 __fastcall sub_26F58(__int64 a1);
unsigned __int64 __fastcall sub_273EC(__int64 a1, unsigned __int64 a2, _DWORD *a3);
_DWORD *__fastcall sub_274E8(__int64 a1, __int64 a2, _DWORD *a3);
__int64 __fastcall sub_27670(__int64 a1, unsigned int a2, __int64 *a3);
__int64 __fastcall sub_2786C(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_279EC(__int64 a1, __int64 a2);
__int64 __fastcall sub_27C1C(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_27D14(__int64 a1, unsigned __int64 a2, __int64 a3, ULONG_PTR **a4);
__int64 __fastcall sub_27F50(__int64 a1, unsigned __int64 a2, __int64 a3, _DWORD *a4);
__int64 __fastcall sub_281DC(__int64 a1, unsigned __int64 a2, _QWORD *a3, _DWORD *a4);
_QWORD *__fastcall sub_283D0(__int64 a1, unsigned int a2, __int64 a3, _DWORD *a4);
ULONG_PTR __fastcall sub_28590(ULONG_PTR BugCheckParameter2, unsigned __int64 a2, __int64 a3, ULONG_PTR **a4, __int64 a5);
__int64 __fastcall sub_28A18(__int64 a1, ULONG_PTR *a2, _DWORD *a3);
__int64 __fastcall sub_28BEC(__int64 a1, ULONG_PTR *a2, __int64 a3, _DWORD *a4);
__int64 __fastcall sub_28EA8(ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter1); // idb
__int64 __fastcall sub_2904C(ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter1, char a3);
__int64 __fastcall sub_29190(ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter1, char a3);
char __fastcall sub_2930C(_BYTE *a1, _DWORD *a2);
char __fastcall sub_29458(_BYTE *a1, _DWORD *a2);
char __fastcall sub_295A4(_BYTE *a1, _DWORD *a2);
__int64 sub_296F0();
char __fastcall sub_29814(ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter1);
void __fastcall DeferredRoutine(_KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2);
__int64 __fastcall sub_298A0(_QWORD *a1, _QWORD *a2);
void __fastcall sub_29A24(PVOID P);
__int64 __fastcall sub_29A94(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, void *Src);
__int64 __fastcall sub_29BF8(_WORD *a1, __int64 a2, __int16 *a3, __int64 a4);
__int64 __fastcall sub_29D00(_BYTE *a1, __int64 a2, char *a3);
__int64 __fastcall sub_29D88(void *a1, size_t a2, const void *a3, size_t a4);
// NTSTATUS __stdcall RtlStringCopyWorkerA(NTSTRSAFE_PSTR pszDest, size_t cchDest, size_t *pcchNewDestLength, STRSAFE_PCNZCH pszSrc, size_t cchToCopy);
// __int64 __fastcall unknown_libname_2(_QWORD, _QWORD, _QWORD); weak
// NTSTATUS __stdcall RtlStringValidateDestAndLengthA(NTSTRSAFE_PCSTR pszDest, size_t cchDest, size_t *pcchDestLength, const size_t cchMax);
__int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
// void *__cdecl memmove(void *Dst, const void *Src, size_t MaxCount);
// void *__cdecl memset(void *Dst, int Val, size_t Size);
// int __cdecl isdigit(int C);
__int64 __fastcall sub_2A40C(_WORD *a1, __int64 a2, __int16 *a3);
// char *__cdecl strstr(const char *Str, const char *SubStr);
// PVOID __stdcall ExAllocatePoolWithTag(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag);
// NTSTATUS __stdcall IoWMIRegistrationControl(PDEVICE_OBJECT DeviceObject, ULONG Action);
// PIRP __stdcall IoBuildDeviceIoControlRequest(ULONG IoControlCode, PDEVICE_OBJECT DeviceObject, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, BOOLEAN InternalDeviceIoControl, PKEVENT Event, PIO_STATUS_BLOCK IoStatusBlock);
// void __stdcall ExFreePoolWithTag(PVOID P, ULONG Tag);
// NTSTATUS __stdcall IoWMIWriteEvent(PVOID WnodeEventItem);
// void __stdcall RtlInitUnicodeString(PUNICODE_STRING DestinationString, PCWSTR SourceString);
// void __stdcall IoDeleteDevice(PDEVICE_OBJECT DeviceObject);
// PVOID __stdcall MmGetSystemRoutineAddress(PUNICODE_STRING SystemRoutineName);
// NTSTATUS __stdcall IoGetDeviceObjectPointer(PUNICODE_STRING ObjectName, ACCESS_MASK DesiredAccess, PFILE_OBJECT *FileObject, PDEVICE_OBJECT *DeviceObject);
// void __stdcall IofCompleteRequest(PIRP Irp, CCHAR PriorityBoost);
// SIZE_T __stdcall RtlCompareMemory(const void *Source1, const void *Source2, SIZE_T Length);
// LONG_PTR __stdcall ObfDereferenceObject(PVOID Object);
// NTSTATUS __stdcall IoCreateDevice(PDRIVER_OBJECT DriverObject, ULONG DeviceExtensionSize, PUNICODE_STRING DeviceName, ULONG DeviceType, ULONG DeviceCharacteristics, BOOLEAN Exclusive, PDEVICE_OBJECT *DeviceObject);
// NTSTATUS __stdcall IofCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp);
// void __stdcall __noreturn KeBugCheckEx(ULONG BugCheckCode, ULONG_PTR BugCheckParameter1, ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter3, ULONG_PTR BugCheckParameter4);
// BOOLEAN __stdcall ExAcquireResourceExclusiveLite(PERESOURCE Resource, BOOLEAN Wait);
// void __stdcall KeClearEvent(PRKEVENT Event);
// LONG __stdcall KeResetEvent(PRKEVENT Event);
// void __stdcall ExReleaseFastMutex(PFAST_MUTEX FastMutex);
// void KeLeaveCriticalRegion(void);
// void __stdcall ExInitializeNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside, PALLOCATE_FUNCTION Allocate, PFREE_FUNCTION Free, ULONG Flags, SIZE_T Size, ULONG Tag, USHORT Depth);
// void __stdcall ExAcquireFastMutex(PFAST_MUTEX FastMutex);
// LONG __stdcall KeSetEvent(PRKEVENT Event, KPRIORITY Increment, BOOLEAN Wait);
// PSLIST_ENTRY __stdcall ExpInterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry);
// void __stdcall KeInitializeEvent(PRKEVENT Event, EVENT_TYPE Type, BOOLEAN State);
// void __stdcall KeReleaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL NewIrql);
// PSLIST_ENTRY __stdcall ExpInterlockedPopEntrySList(PSLIST_HEADER ListHead);
// void __stdcall KeReleaseSpinLockFromDpcLevel(PKSPIN_LOCK SpinLock);
// void KeEnterCriticalRegion(void);
// void __stdcall ExDeletePagedLookasideList(PPAGED_LOOKASIDE_LIST Lookaside);
// NTSTATUS __stdcall PsCreateSystemThread(PHANDLE ThreadHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PKSTART_ROUTINE StartRoutine, PVOID StartContext);
// NTSTATUS __stdcall PsTerminateSystemThread(NTSTATUS ExitStatus);
// BOOLEAN __stdcall ExAcquireResourceSharedLite(PERESOURCE Resource, BOOLEAN Wait);
// void __stdcall ExReleaseResourceLite(PERESOURCE Resource);
// NTSTATUS __stdcall ZwClose(HANDLE Handle);
// USHORT __stdcall ExQueryDepthSList(PSLIST_HEADER SListHead);
// NTSTATUS __stdcall ObReferenceObjectByHandle(HANDLE Handle, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PVOID *Object, POBJECT_HANDLE_INFORMATION HandleInformation);
// NTSTATUS __stdcall KeWaitForSingleObject(PVOID Object, KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
// NTSTATUS __stdcall ExDeleteResourceLite(PERESOURCE Resource);
// void __stdcall ExInitializePagedLookasideList(PPAGED_LOOKASIDE_LIST Lookaside, PALLOCATE_FUNCTION Allocate, PFREE_FUNCTION Free, ULONG Flags, SIZE_T Size, ULONG Tag, USHORT Depth);
// NTSTATUS __stdcall ExInitializeResourceLite(PERESOURCE Resource);
// NTSTATUS __stdcall KeWaitForMultipleObjects(ULONG Count, PVOID Object[], WAIT_TYPE WaitType, KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PKWAIT_BLOCK WaitBlockArray);
// void __stdcall KeAcquireSpinLockAtDpcLevel(PKSPIN_LOCK SpinLock);
// void __stdcall ExDeleteNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside);
// KIRQL __stdcall KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock);
// NTSTATUS __stdcall KeDelayExecutionThread(KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Interval);
// void __stdcall KeInitializeDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext);
// void __stdcall KeInitializeTimer(PKTIMER Timer);
// BOOLEAN __stdcall KeSetTimer(PKTIMER Timer, LARGE_INTEGER DueTime, PKDPC Dpc);
// BOOLEAN __stdcall KeCancelTimer(PKTIMER);
__int64 __fastcall sub_32008(unsigned __int8 a1, __int64 a2, unsigned int a3, unsigned int *a4, __int64 a5, unsigned int *a6);

//-------------------------------------------------------------------------
// Data declarations

__int64 qword_2A4E0[2] = { -3689348814741962752i64, -3689348814741910324i64 }; // weak
__int64 qword_2A550[2] = { -3689348818173407675i64, -3689348814741910324i64 }; // weak
__int64 qword_2A560[2] = { -3689348818173612210i64, -3689348814741910324i64 }; // weak
__int64 qword_2A5C0[2] = { -3689348814755302551i64, -3689348814741910324i64 }; // weak
_UNKNOWN unk_2B290; // weak
_UNKNOWN unk_2B2A0; // weak
_UNKNOWN unk_2B2B0; // weak
_UNKNOWN unk_2B2C0; // weak
_UNKNOWN unk_2B2D0; // weak
_DWORD dword_2B2E0[34] =
{
  1,
  11,
  23,
  53,
  97,
  193,
  389,
  769,
  1543,
  3079,
  6151,
  12289,
  24593,
  49157,
  98317,
  196613,
  393241,
  786433,
  1572869,
  3145739,
  6291469,
  12582917,
  25165843,
  50331653,
  100663319,
  201326611,
  402653189,
  805306457,
  1610612741,
  0,
  -911531371,
  1099016528,
  -1193350085,
  -256973122
}; // idb
_UNKNOWN unk_2B368; // weak
_UNKNOWN unk_2B378; // weak
_UNKNOWN unk_2B388; // weak
_UNKNOWN unk_2B3A8; // weak
_UNKNOWN unk_2B3B8; // weak
_UNKNOWN unk_2B3C8; // weak
_UNKNOWN unk_2B3D8; // weak
_UNKNOWN unk_2B3E8; // weak
_UNKNOWN unk_2B3F8; // weak
_UNKNOWN unk_2B408; // weak
_UNKNOWN unk_2B418; // weak
_UNKNOWN unk_2B44A; // weak
void *off_2E128 = &off_2E128; // weak
char aUnknownModule[15] = "Unknown module"; // weak
__int64 (__fastcall *qword_2E190)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = NULL; // weak
__int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = NULL; // weak
__int64 (*qword_2E1A0)(void) = NULL; // weak
__int64 (__fastcall *qword_2E1A8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = NULL; // weak
__int64 (__fastcall *qword_2E1B0)(_QWORD, _QWORD, _QWORD, _QWORD) = NULL; // weak
int dword_2E1B8 = 0; // weak
char byte_2E1CC = '\0'; // weak
PVOID qword_2E1D0 = NULL; // idb
int dword_2E1D8 = 0; // weak
int dword_2E1DC = 0; // weak
PVOID qword_2E1E0 = NULL; // idb
PVOID Object = NULL; // idb
PVOID qword_2E1F0 = NULL; // idb
PVOID qword_2E1F8 = NULL; // idb
PVOID P; // idb
__int64 qword_2E208; // weak
int dword_2E210; // weak
struct _FAST_MUTEX FastMutex; // idb
char byte_2E25C; // weak
int dword_2E260; // weak
int dword_2E268; // weak
__int64 (__fastcall *qword_2E26C)(_QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_2E274)(_QWORD); // weak
__int64 qword_2E27C; // weak
__int64 qword_2E284; // weak
char byte_2E28C; // weak
PVOID qword_2E290; // idb
__int64 qword_2E298; // weak
int dword_2E2A0; // weak
struct _FAST_MUTEX stru_2E2A8; // idb
char byte_2E2EC; // weak
int dword_2E2F0; // weak
int dword_2E2F8; // weak
int dword_2E2FC; // weak
int dword_2E300; // weak
int dword_2E304; // weak
PVOID Event; // idb
struct _FAST_MUTEX stru_2E310; // idb
PVOID qword_2E348; // idb
int dword_2E354; // weak
PVOID qword_2E378; // idb
PVOID qword_2E380; // idb
PVOID qword_2E390; // idb
_WORD word_2E3A0[520]; // idb
int dword_2E7B0; // weak
PVOID qword_2E7B8; // idb
__int64 qword_2E7C0; // weak
PVOID qword_2E7C8; // idb
PVOID qword_2E7D0; // idb
int dword_2E7D8; // weak
int dword_2E7DC; // weak
char byte_2E7E0; // weak
char byte_2E7E1; // weak
char byte_2E7E2; // weak
char byte_2E7E3; // weak
char byte_2E7E4; // weak
__int64 (__fastcall *qword_2E7E8)(_QWORD); // weak
__int64 qword_2E7F0; // weak
__int64 qword_2E7F8; // weak
__int64 qword_2E800; // weak
__int64 qword_2E808; // weak
__int64 qword_30DF0; // weak
struct _KDPC Dpc; // idb
struct _KTIMER Timer; // idb
__int64 qword_30E80; // weak
__int64 qword_30E88; // weak
__int64 qword_30E90; // weak
__int64 qword_30EA0; // weak
char byte_30EA8; // weak
char byte_30EA9; // weak
__int16 word_30EAA; // weak
int dword_30EAC; // weak
__int64 qword_30EC0; // weak
__int64 qword_30EC8; // weak
__int64 qword_30ED0; // weak
__int64 qword_30EE0; // weak
char byte_30EE8; // weak
char byte_30EE9; // weak
__int16 word_30EEA; // weak
int dword_30EEC; // weak
__int64 qword_30F00; // weak
__int64 qword_30F08; // weak
__int64 qword_30F10; // weak
__int64 qword_30F20; // weak
char byte_30F28; // weak
char byte_30F29; // weak
__int16 word_30F2A; // weak
int dword_30F2C; // weak
__int64 qword_30F40; // weak
__int64 qword_30F48; // weak
__int64 qword_30F50; // weak
__int64 qword_30F60; // weak
char byte_30F68; // weak
char byte_30F69; // weak
__int16 word_30F6A; // weak
int dword_30F6C; // weak
__int64 qword_30F80; // weak
PVOID qword_30F88; // idb


//----- (0000000000011008) ----------------------------------------------------
__int64 __fastcall sub_11008(__int64 a1, unsigned __int16 a2, __int64 a3)
{
  return qword_2E198(a1, 43i64, a3, a2, 0i64);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001102C) ----------------------------------------------------
__int64 __fastcall sub_1102C(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4)
{
  __int64 v5; // rcx
  const wchar_t *v6; // rdi
  bool v7; // zf

  if ( a4 && *a4 )
  {
    v5 = -1i64;
    v6 = a4;
    do
    {
      if ( !v5 )
        break;
      v7 = *v6++ == 0;
      --v5;
    }
    while ( !v7 );
  }
  if ( a4 )
  {
    if ( !*a4 )
      a4 = L"<NULL>";
  }
  else
  {
    a4 = L"NULL";
  }
  return qword_2E198(a1, 43i64, &unk_2B418, a2, a4);
}
// 2A4A0: using guessed type wchar_t aNull_3[7];
// 2A4B0: using guessed type wchar_t aNull[5];
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000110CC) ----------------------------------------------------
__int64 __fastcall sub_110CC(__int64 a1, unsigned __int16 a2, __int64 a3, const char *a4)
{
  const char *v5; // rax

  if ( a4 )
    strlen(a4);
  v5 = "NULL";
  if ( a4 )
    v5 = a4;
  return qword_2E198(a1, 43i64, a3, a2, v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000011144) ----------------------------------------------------
__int64 sub_11144()
{
  int v0; // eax
  unsigned int v1; // ebx
  __int64 v3[4]; // [rsp+20h] [rbp-C8h] BYREF
  int v4[4]; // [rsp+40h] [rbp-A8h] BYREF
  __int16 v5; // [rsp+50h] [rbp-98h]
  char Dst[114]; // [rsp+52h] [rbp-96h] BYREF
  int v7; // [rsp+C4h] [rbp-24h]
  char v8; // [rsp+C8h] [rbp-20h]

  v4[0] = 33722368;
  v4[1] = 5111886;
  v4[2] = 4456531;
  v4[3] = 5439566;
  v5 = 0;
  memset(Dst, 0, sizeof(Dst));
  v3[3] = 0i64;
  v3[0] = (__int64)sub_11340;
  v7 = 1936606286;
  v3[1] = (__int64)sub_114D0;
  v8 = 22;
  v3[2] = (__int64)sub_11628;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 1) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0xAu, (__int64)&unk_2B418);
  v0 = sub_1FFB0((__int64)v4, 3156i64, v3);
  v1 = v0;
  if ( v0 )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 1) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
      sub_14544(*((_QWORD *)off_2E128 + 27), 0xBu, (__int64)&unk_2B418, v0);
    goto LABEL_17;
  }
  sub_22C48(0);
  v1 = sub_22CE4();
  if ( v1 )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 1) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0xCu, (__int64)&unk_2B418);
    sub_22FF4();
    goto LABEL_17;
  }
  sub_117FC();
  v1 = sub_204A8();
  if ( v1 )
LABEL_17:
    sub_2091C();
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 1) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0xDu, (__int64)&unk_2B418);
  return v1;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000011340) ----------------------------------------------------
char __fastcall sub_11340(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  char v4; // r10

  v4 = 1;
  switch ( a1 )
  {
    case 33722369:
      *a2 = 0;
      goto LABEL_3;
    case 33722370:
      *a2 = 4;
      goto LABEL_6;
    case 33722371:
      *a2 = 8;
      goto LABEL_3;
    case 33722372:
      *a2 = 12;
      goto LABEL_3;
    case 33722373:
      *a2 = 16;
LABEL_6:
      *a3 = 2;
      *a4 = 6;
      return v4;
    case 33722374:
      *a2 = 20;
      goto LABEL_3;
    case 33722375:
      *a2 = 28;
      goto LABEL_3;
    case 33722376:
      *a2 = 32;
      goto LABEL_3;
    case 33722377:
      *a2 = 36;
      goto LABEL_3;
    case 33722378:
      *a2 = 40;
      goto LABEL_3;
    case 33722379:
      *a2 = 44;
      *a3 = 1;
      goto LABEL_4;
    case 33722380:
      *a2 = 72;
      *a3 = 2048;
      goto LABEL_17;
    case 33722381:
      *a2 = 48;
      goto LABEL_3;
    case 33722382:
      *a2 = 52;
      goto LABEL_3;
    case 33722383:
      *a2 = 56;
      goto LABEL_3;
    case 33722384:
      *a2 = 60;
      goto LABEL_3;
    case 33722385:
      *a2 = 64;
      goto LABEL_3;
    case 33722386:
      *a2 = 68;
      goto LABEL_3;
    case 33722387:
      *a2 = 2120;
      *a3 = 1024;
LABEL_17:
      *a4 = 2;
      return v4;
    case 33722388:
      *a2 = 3144;
      goto LABEL_3;
    case 33722389:
      *a2 = 3148;
      goto LABEL_3;
    case 33722390:
      *a2 = 3152;
LABEL_3:
      *a3 = 4;
LABEL_4:
      *a4 = 0;
      break;
    default:
      v4 = 0;
      break;
  }
  return v4;
}

//----- (00000000000114D0) ----------------------------------------------------
__int64 __fastcall sub_114D0(__int64 a1)
{
  __int64 v2; // rcx
  __int64 *v3; // rdi
  bool v4; // zf
  __int64 v5; // rcx
  const wchar_t *v6; // rdi
  __int64 result; // rax

  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0xEu, (__int64)&unk_2B418);
  }
  *(_WORD *)(a1 + 4) = 2;
  *(_DWORD *)(a1 + 40) = 2;
  *(_DWORD *)(a1 + 64) = 2;
  v2 = -1i64;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 52) = 3;
  *(_DWORD *)(a1 + 3144) = 3;
  *(_DWORD *)(a1 + 36) = 0;
  *(_BYTE *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 3152) = 0;
  *(_DWORD *)(a1 + 8) = 10;
  *(_DWORD *)(a1 + 20) = 10;
  *(_DWORD *)(a1 + 3148) = 10;
  v3 = qword_2A4E0;
  *(_DWORD *)(a1 + 12) = 1;
  *(_WORD *)(a1 + 16) = 1;
  *(_DWORD *)(a1 + 48) = 1;
  *(_DWORD *)(a1 + 56) = 1;
  *(_DWORD *)(a1 + 60) = 1;
  *(_DWORD *)(a1 + 68) = 1;
  do
  {
    if ( !v2 )
      break;
    v4 = *(_WORD *)v3 == 0;
    v3 = (__int64 *)((char *)v3 + 2);
    --v2;
  }
  while ( !v4 );
  sub_29BF8((_WORD *)(a1 + 72), 1024i64, (__int16 *)qword_2A4E0, -v2 - 2);
  v5 = -1i64;
  v6 = L"in-addr.arpa|ip6.arpa";
  do
  {
    if ( !v5 )
      break;
    v4 = *v6++ == 0;
    --v5;
  }
  while ( !v4 );
  result = sub_29BF8((_WORD *)(a1 + 2120), 512i64, L"in-addr.arpa|ip6.arpa", -v5 - 2);
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    result = sub_11008(*((_QWORD *)off_2E128 + 19), 0xFu, (__int64)&unk_2B418);
  }
  return result;
}
// 2A4E0: using guessed type __int64 qword_2A4E0[2];
// 2A4F0: using guessed type wchar_t aInAddrArpaIp6A[22];
// 2E128: using guessed type void *off_2E128;

//----- (0000000000011628) ----------------------------------------------------
void __fastcall sub_11628(const signed __int32 *a1)
{
  void **v2; // rcx
  int v3; // eax
  int v4; // eax
  int v5; // eax

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_12374(*((_QWORD *)off_2E128 + 19), 0x10u, (__int64)&unk_2B418, a1);
    v2 = (void **)off_2E128;
  }
  if ( (*(_BYTE *)a1 & 1) != 0 )
  {
    if ( (unsigned __int8)sub_20AD8(0x2029001u) == 1 )
      sub_1C978();
    else
      sub_1C820();
    v2 = (void **)off_2E128;
  }
  if ( (*(_BYTE *)a1 & 8) != 0 )
  {
    _InterlockedExchange(&dword_2E2F8, sub_20AD8(0x2029004u));
    v2 = (void **)off_2E128;
  }
  if ( (*(_BYTE *)a1 & 0x40) != 0 || *(char *)a1 < 0 || _bittest(a1, 8u) )
  {
    sub_131EC(1);
    v2 = (void **)off_2E128;
  }
  if ( _bittest(a1, 0xBu) )
  {
    if ( v2 != &off_2E128 && _bittest((const signed __int32 *)v2 + 43, 8u) && *((_BYTE *)v2 + 169) >= 4u )
      sub_11008((__int64)v2[19], 0x11u, (__int64)&unk_2B418);
    sub_11A68();
    v2 = (void **)off_2E128;
  }
  if ( _bittest(a1, 0xEu) )
  {
    v3 = sub_20AD8(0x202900Fu);
    v2 = (void **)off_2E128;
    dword_2E2FC = v3;
  }
  if ( _bittest(a1, 0xFu) )
  {
    v4 = sub_20AD8(0x2029010u);
    v2 = (void **)off_2E128;
    dword_2E300 = v4;
  }
  if ( _bittest(a1, 0x10u) )
  {
    v5 = sub_20AD8(0x2029011u);
    v2 = (void **)off_2E128;
    dword_2E304 = v5;
  }
  if ( _bittest(a1, 0x12u) )
  {
    if ( v2 != &off_2E128 && _bittest((const signed __int32 *)v2 + 43, 8u) && *((_BYTE *)v2 + 169) >= 4u )
      sub_11008((__int64)v2[19], 0x12u, (__int64)&unk_2B418);
    sub_11E24();
    v2 = (void **)off_2E128;
  }
  if ( v2 != &off_2E128 && _bittest((const signed __int32 *)v2 + 43, 8u) && *((_BYTE *)v2 + 169) >= 5u )
    sub_11008((__int64)v2[19], 0x13u, (__int64)&unk_2B418);
}
// 2E128: using guessed type void *off_2E128;
// 2E2F8: using guessed type int dword_2E2F8;
// 2E2FC: using guessed type int dword_2E2FC;
// 2E300: using guessed type int dword_2E300;
// 2E304: using guessed type int dword_2E304;

//----- (00000000000117FC) ----------------------------------------------------
__int64 sub_117FC()
{
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 1) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x14u, (__int64)&unk_2B418);
  dword_2E210 = 0;
  qword_2E208 = (__int64)&P;
  P = &P;
  sub_1DE30((__int64)&FastMutex);
  dword_2E2A0 = 0;
  qword_2E298 = (__int64)&qword_2E290;
  qword_2E290 = &qword_2E290;
  byte_2E25C = 1;
  sub_1DE30((__int64)&stru_2E2A8);
  byte_2E2EC = 1;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 1) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x15u, (__int64)&unk_2B418);
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;
// 2E208: using guessed type __int64 qword_2E208;
// 2E210: using guessed type int dword_2E210;
// 2E25C: using guessed type char byte_2E25C;
// 2E298: using guessed type __int64 qword_2E298;
// 2E2A0: using guessed type int dword_2E2A0;
// 2E2EC: using guessed type char byte_2E2EC;

//----- (00000000000118F4) ----------------------------------------------------
__int64 __fastcall sub_118F4(char a1)
{
  void **v2; // rcx
  unsigned __int16 v3; // dx
  __int64 v4; // rdx
  _QWORD *v5; // rax
  PVOID *v6; // rbx

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x18u, (__int64)&unk_2B418);
    v2 = (void **)off_2E128;
  }
  if ( byte_2E25C )
  {
    sub_1DF10(&FastMutex);
    while ( 1 )
    {
      v6 = (PVOID *)P;
      if ( P == &P )
        break;
      v4 = *(_QWORD *)P;
      v5 = (_QWORD *)*((_QWORD *)P + 1);
      *v5 = *(_QWORD *)P;
      *(_QWORD *)(v4 + 8) = v5;
      sub_1D2D8(v6[2], 0x64736E44u);
      sub_1D2D8(v6, 0x64736E44u);
      --dword_2E210;
    }
    sub_1DFDC(&FastMutex);
    if ( a1 )
      byte_2E25C = 0;
    v2 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    {
      v3 = 26;
      goto LABEL_19;
    }
  }
  else if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 236) & 0x20) != 0 && *((_BYTE *)v2 + 233) >= 5u )
  {
    v3 = 25;
LABEL_19:
    sub_11008((__int64)v2[27], v3, (__int64)&unk_2B418);
    return 0i64;
  }
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;
// 2E210: using guessed type int dword_2E210;
// 2E25C: using guessed type char byte_2E25C;

//----- (0000000000011A68) ----------------------------------------------------
__int64 sub_11A68()
{
  unsigned int v0; // er12
  char *v1; // rax
  __int64 v2; // rcx
  char *v3; // rsi
  char *v4; // rdi
  bool v5; // zf
  __int64 v6; // r14
  void **v7; // rcx
  __int64 v8; // r13
  __int16 v9; // di
  unsigned __int16 v10; // di
  PVOID v11; // rsi
  int v12; // er15
  PVOID v13; // rax
  unsigned __int16 v14; // bp
  int v15; // edi
  __int64 v16; // rdx
  _QWORD *v17; // rax
  char v18; // bp
  _QWORD *v19; // rcx
  unsigned __int16 v20; // dx
  char v22; // [rsp+70h] [rbp+8h]
  char *v23; // [rsp+78h] [rbp+10h]
  char *v24; // [rsp+80h] [rbp+18h]

  v22 = 1;
  v0 = 0;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x1Bu, (__int64)&unk_2B418);
  v1 = sub_20D44(0x202900Cu);
  v2 = -1i64;
  v3 = v1;
  v24 = v1;
  v4 = v1;
  do
  {
    if ( !v2 )
      break;
    v5 = *(_WORD *)v4 == 0;
    v4 += 2;
    --v2;
  }
  while ( !v5 );
  v6 = -v2 - 2;
  if ( -(int)v2 == 2 )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0x1Cu, (__int64)&unk_2B418);
    sub_118F4(0);
    sub_20F24();
    return 0i64;
  }
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
    sub_1102C(*((_QWORD *)off_2E128 + 27), 0x1Du, (__int64)&unk_2B418, (const wchar_t *)v1);
  _InterlockedExchange(&dword_2E260, 1);
  sub_118F4(0);
  v7 = (void **)off_2E128;
  v8 = 0i64;
  while ( 1 )
  {
    v9 = 0;
    v23 = &v3[2 * v8];
    if ( v0 > (unsigned int)v6 )
      goto LABEL_36;
    do
    {
      if ( *(_WORD *)&v3[2 * v8] == 124 )
        break;
      if ( !*(_WORD *)&v3[2 * v8] )
        break;
      ++v0;
      ++v9;
      ++v8;
    }
    while ( v0 <= (unsigned int)v6 );
    if ( v0 > (unsigned int)v6 || !v9 )
    {
LABEL_36:
      if ( v7 != &off_2E128 && (*((_BYTE *)v7 + 236) & 0x20) != 0 && *((_BYTE *)v7 + 233) >= 2u )
      {
        sub_11008((__int64)v7[27], 0x1Eu, (__int64)&unk_2B418);
        v7 = (void **)off_2E128;
      }
      v18 = 0;
      v22 = 0;
      goto LABEL_39;
    }
    v10 = v9 + 1;
    v11 = sub_1D254(1, 0x18u, 0x64736E44u);
    if ( !v11 )
      break;
    v12 = v10;
    *(_QWORD *)v11 = 0i64;
    *((_QWORD *)v11 + 1) = 0i64;
    *((_QWORD *)v11 + 2) = 0i64;
    v13 = sub_1D254(1, v10, 0x64736E44u);
    *((_QWORD *)v11 + 2) = v13;
    if ( !v13 )
    {
      v19 = off_2E128;
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
      {
        v20 = 31;
LABEL_49:
        sub_11008(v19[27], v20, (__int64)&unk_2B418);
        goto LABEL_50;
      }
      goto LABEL_50;
    }
    v14 = 0;
    memset(v13, 0, v10);
    v15 = v10 - 1;
    if ( v12 - 1 > 0 )
    {
      do
      {
        v16 = v14++;
        *(_BYTE *)(v16 + *((_QWORD *)v11 + 2)) = v23[2 * v16];
      }
      while ( v14 < v15 );
    }
    *(_BYTE *)(v14 + *((_QWORD *)v11 + 2)) = 0;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
    {
      strlen(*((const char **)v11 + 2));
      sub_110CC(*((_QWORD *)off_2E128 + 27), 0x21u, (__int64)&unk_2B418, *((const char **)v11 + 2));
    }
    v17 = (_QWORD *)qword_2E208;
    v18 = v22;
    *((_QWORD *)v11 + 1) = qword_2E208;
    *(_QWORD *)v11 = &P;
    *v17 = v11;
    ++dword_2E210;
    v7 = (void **)off_2E128;
    qword_2E208 = (__int64)v11;
    v3 = v24;
    ++v0;
    ++v8;
LABEL_39:
    if ( !v18 )
      goto LABEL_50;
  }
  v19 = off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
  {
    v20 = 32;
    goto LABEL_49;
  }
LABEL_50:
  sub_20F24();
  _InterlockedExchange(&dword_2E260, 0);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x22u, (__int64)&unk_2B418);
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;
// 2E208: using guessed type __int64 qword_2E208;
// 2E210: using guessed type int dword_2E210;
// 2E260: using guessed type int dword_2E260;

//----- (0000000000011E24) ----------------------------------------------------
__int64 sub_11E24()
{
  unsigned int v0; // er12
  char *v1; // rax
  __int64 v2; // rcx
  char *v3; // rsi
  char *v4; // rdi
  bool v5; // zf
  __int64 v6; // r14
  void **v7; // rcx
  __int64 v8; // r13
  __int16 v9; // di
  unsigned __int16 v10; // di
  PVOID v11; // rsi
  int v12; // er15
  PVOID v13; // rax
  unsigned __int16 v14; // bp
  int v15; // edi
  __int64 v16; // rdx
  _QWORD *v17; // rax
  char v18; // bp
  _QWORD *v19; // rcx
  unsigned __int16 v20; // dx
  char v22; // [rsp+70h] [rbp+8h]
  char *v23; // [rsp+78h] [rbp+10h]
  char *v24; // [rsp+80h] [rbp+18h]

  v22 = 1;
  v0 = 0;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x23u, (__int64)&unk_2B418);
  v1 = sub_20D44(0x2029013u);
  v2 = -1i64;
  v3 = v1;
  v24 = v1;
  v4 = v1;
  do
  {
    if ( !v2 )
      break;
    v5 = *(_WORD *)v4 == 0;
    v4 += 2;
    --v2;
  }
  while ( !v5 );
  v6 = -v2 - 2;
  if ( -(int)v2 == 2 )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0x24u, (__int64)&unk_2B418);
    sub_12200(0);
    sub_20F24();
    return 0i64;
  }
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
    sub_1102C(*((_QWORD *)off_2E128 + 27), 0x25u, (__int64)&unk_2B418, (const wchar_t *)v1);
  _InterlockedExchange(&dword_2E2F0, 1);
  sub_12200(0);
  v7 = (void **)off_2E128;
  v8 = 0i64;
  while ( 1 )
  {
    v9 = 0;
    v23 = &v3[2 * v8];
    if ( v0 > (unsigned int)v6 )
      goto LABEL_36;
    do
    {
      if ( *(_WORD *)&v3[2 * v8] == 124 )
        break;
      if ( !*(_WORD *)&v3[2 * v8] )
        break;
      ++v0;
      ++v9;
      ++v8;
    }
    while ( v0 <= (unsigned int)v6 );
    if ( v0 > (unsigned int)v6 || !v9 )
    {
LABEL_36:
      if ( v7 != &off_2E128 && (*((_BYTE *)v7 + 236) & 0x20) != 0 && *((_BYTE *)v7 + 233) >= 2u )
      {
        sub_11008((__int64)v7[27], 0x26u, (__int64)&unk_2B418);
        v7 = (void **)off_2E128;
      }
      v18 = 0;
      v22 = 0;
      goto LABEL_39;
    }
    v10 = v9 + 1;
    v11 = sub_1D254(1, 0x18u, 0x64736E44u);
    if ( !v11 )
      break;
    v12 = v10;
    *(_QWORD *)v11 = 0i64;
    *((_QWORD *)v11 + 1) = 0i64;
    *((_QWORD *)v11 + 2) = 0i64;
    v13 = sub_1D254(1, v10, 0x64736E44u);
    *((_QWORD *)v11 + 2) = v13;
    if ( !v13 )
    {
      v19 = off_2E128;
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
      {
        v20 = 39;
LABEL_49:
        sub_11008(v19[27], v20, (__int64)&unk_2B418);
        goto LABEL_50;
      }
      goto LABEL_50;
    }
    v14 = 0;
    memset(v13, 0, v10);
    v15 = v10 - 1;
    if ( v12 - 1 > 0 )
    {
      do
      {
        v16 = v14++;
        *(_BYTE *)(v16 + *((_QWORD *)v11 + 2)) = v23[2 * v16];
      }
      while ( v14 < v15 );
    }
    *(_BYTE *)(v14 + *((_QWORD *)v11 + 2)) = 0;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
    {
      strlen(*((const char **)v11 + 2));
      sub_110CC(*((_QWORD *)off_2E128 + 27), 0x29u, (__int64)&unk_2B418, *((const char **)v11 + 2));
    }
    v17 = (_QWORD *)qword_2E298;
    v18 = v22;
    *((_QWORD *)v11 + 1) = qword_2E298;
    *(_QWORD *)v11 = &qword_2E290;
    *v17 = v11;
    ++dword_2E2A0;
    v7 = (void **)off_2E128;
    qword_2E298 = (__int64)v11;
    v3 = v24;
    ++v0;
    ++v8;
LABEL_39:
    if ( !v18 )
      goto LABEL_50;
  }
  v19 = off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
  {
    v20 = 40;
    goto LABEL_49;
  }
LABEL_50:
  sub_20F24();
  _InterlockedExchange(&dword_2E2F0, 0);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x2Au, (__int64)&unk_2B418);
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;
// 2E298: using guessed type __int64 qword_2E298;
// 2E2A0: using guessed type int dword_2E2A0;
// 2E2F0: using guessed type int dword_2E2F0;

//----- (0000000000012200) ----------------------------------------------------
__int64 __fastcall sub_12200(char a1)
{
  void **v2; // rcx
  unsigned __int16 v3; // dx
  __int64 v4; // rdx
  _QWORD *v5; // rax
  PVOID *v6; // rbx

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x2Bu, (__int64)&unk_2B418);
    v2 = (void **)off_2E128;
  }
  if ( byte_2E2EC )
  {
    sub_1DF10(&stru_2E2A8);
    while ( 1 )
    {
      v6 = (PVOID *)qword_2E290;
      if ( qword_2E290 == &qword_2E290 )
        break;
      v4 = *(_QWORD *)qword_2E290;
      v5 = (_QWORD *)*((_QWORD *)qword_2E290 + 1);
      *v5 = *(_QWORD *)qword_2E290;
      *(_QWORD *)(v4 + 8) = v5;
      sub_1D2D8(v6[2], 0x64736E44u);
      sub_1D2D8(v6, 0x64736E44u);
      --dword_2E2A0;
    }
    sub_1DFDC(&stru_2E2A8);
    if ( a1 )
      byte_2E2EC = 0;
    v2 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    {
      v3 = 45;
      goto LABEL_19;
    }
  }
  else if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 236) & 0x20) != 0 && *((_BYTE *)v2 + 233) >= 5u )
  {
    v3 = 44;
LABEL_19:
    sub_11008((__int64)v2[27], v3, (__int64)&unk_2B418);
    return 0i64;
  }
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;
// 2E2A0: using guessed type int dword_2E2A0;
// 2E2EC: using guessed type char byte_2E2EC;

//----- (0000000000012374) ----------------------------------------------------
__int64 sub_12374(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2E198(a1, 43i64, a3, a2, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000123B0) ----------------------------------------------------
__int64 sub_123B0(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2E198(a1, 43i64, &unk_2B408, 33i64, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000012408) ----------------------------------------------------
__int64 sub_12408()
{
  unsigned int v0; // ebx
  unsigned int v1; // edi
  unsigned int v2; // esi

  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 1) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0xAu, (__int64)&unk_2B408);
  v0 = sub_11144();
  if ( !v0 )
  {
    byte_2E1CC = 1;
    sub_19C84();
    sub_1A5CC();
    v1 = sub_20AD8(0x2029002u);
    if ( v1 )
    {
      if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 108) < 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
        sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x2Cu);
      qword_2E1D0 = (PVOID)sub_1F3E0(v1, 1);
      if ( !qword_2E1D0 )
        goto LABEL_18;
      v2 = sub_20AD8(0x2029005u);
      if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 108) < 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
        sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x2Bu);
      qword_2E1E0 = (PVOID)sub_1F3E0(v2, 0);
      if ( qword_2E1E0 )
      {
        dword_2E1D8 = v1;
        sub_22C48(1);
      }
      else
      {
LABEL_18:
        v0 = 3;
      }
    }
    else
    {
      v0 = 6;
    }
  }
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 1) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0xBu, (__int64)&unk_2B408);
  return v0;
}
// 2E128: using guessed type void *off_2E128;
// 2E1CC: using guessed type char byte_2E1CC;
// 2E1D8: using guessed type int dword_2E1D8;

//----- (00000000000125BC) ----------------------------------------------------
__int64 sub_125BC()
{
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 1) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0xCu, (__int64)&unk_2B408);
  if ( byte_2E1CC )
  {
    if ( qword_2E1D0 )
    {
      sub_20AD8(0x2029003u);
      sub_1E0A8(qword_2E1D0);
    }
    if ( qword_2E1E0 )
    {
      sub_20AD8(0x2029006u);
      sub_1E0A8(qword_2E1E0);
    }
    sub_207F0();
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 1) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0x16u, (__int64)&unk_2B418);
    sub_118F4(1);
    sub_12200(1);
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 1) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0x17u, (__int64)&unk_2B418);
  }
  sub_22FF4();
  if ( byte_2E1CC )
  {
    sub_1A774();
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0xBCu, (__int64)&unk_2B3E8);
    sub_1D544(qword_2E1F0);
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0xBDu, (__int64)&unk_2B3E8);
    sub_2091C();
    byte_2E1CC = 0;
  }
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 1) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0xDu, (__int64)&unk_2B408);
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;
// 2E1CC: using guessed type char byte_2E1CC;

//----- (00000000000127CC) ----------------------------------------------------
__int64 sub_127CC()
{
  unsigned int v0; // ebx
  void **v1; // rcx

  v0 = 0;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0xEu, (__int64)&unk_2B408);
  }
  sub_12970();
  if ( sub_1DC1C((struct _KEVENT **)&Event, 0) )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 0x10) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
      sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x27u);
    if ( sub_1EED0(&Object, (__int64)sub_12B74, 0i64) == 1 )
    {
      v1 = (void **)off_2E128;
    }
    else
    {
      v1 = (void **)off_2E128;
      if ( off_2E128 != &off_2E128
        && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
        && *((_BYTE *)off_2E128 + 169) >= 2u )
      {
        sub_11008(*((_QWORD *)off_2E128 + 19), 0x10u, (__int64)&unk_2B408);
        v1 = (void **)off_2E128;
      }
      v0 = 1;
    }
  }
  else
  {
    v1 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
      && *((_BYTE *)off_2E128 + 169) >= 2u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 19), 0xFu, (__int64)&unk_2B408);
      v1 = (void **)off_2E128;
    }
    v0 = 6;
  }
  if ( v1 != &off_2E128 && _bittest((const signed __int32 *)v1 + 43, 9u) && *((_BYTE *)v1 + 169) >= 5u )
    sub_11008((__int64)v1[19], 0x11u, (__int64)&unk_2B408);
  return v0;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000012970) ----------------------------------------------------
__int64 sub_12970()
{
  void **v0; // rcx
  PVOID v1; // rax
  PVOID v2; // rbx

  v0 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x12u, (__int64)&unk_2B408);
    v0 = (void **)off_2E128;
  }
  if ( Event )
  {
    if ( v0 != &off_2E128 && _bittest((const signed __int32 *)v0 + 43, 9u) && *((_BYTE *)v0 + 169) >= 5u )
      sub_11008((__int64)v0[19], 0x13u, (__int64)&unk_2B408);
    sub_1DCFC((PRKEVENT)Event);
    v0 = (void **)off_2E128;
  }
  v1 = Object;
  if ( Object )
  {
    if ( v0 != &off_2E128 && _bittest((const signed __int32 *)v0 + 43, 9u) && *((_BYTE *)v0 + 169) >= 5u )
    {
      sub_11008((__int64)v0[19], 0x14u, (__int64)&unk_2B408);
      v1 = Object;
    }
    sub_1E308(v1);
    v2 = Object;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 0x10) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
      sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x28u);
    sub_1F040(v2);
    Object = 0i64;
    v0 = (void **)off_2E128;
  }
  if ( Event )
  {
    if ( v0 != &off_2E128 && _bittest((const signed __int32 *)v0 + 43, 9u) && *((_BYTE *)v0 + 169) >= 5u )
      sub_11008((__int64)v0[19], 0x15u, (__int64)&unk_2B408);
    sub_1DC94(Event);
    Event = 0i64;
    v0 = (void **)off_2E128;
  }
  if ( v0 != &off_2E128 && _bittest((const signed __int32 *)v0 + 43, 9u) && *((_BYTE *)v0 + 169) >= 5u )
    sub_11008((__int64)v0[19], 0x16u, (__int64)&unk_2B408);
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000012B74) ----------------------------------------------------
__int64 sub_12B74()
{
  void **v0; // rcx
  __int64 result; // rax

  v0 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( _bittest((const signed __int32 *)off_2E128 + 43, 9u) && *((_BYTE *)off_2E128 + 169) >= 5u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x17u, (__int64)&unk_2B408);
      v0 = (void **)off_2E128;
    }
    if ( v0 != &off_2E128 && _bittest((const signed __int32 *)v0 + 43, 9u) && *((_BYTE *)v0 + 169) >= 4u )
      sub_11008((__int64)v0[19], 0x18u, (__int64)&unk_2B408);
  }
  sub_1E308(Event);
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
    && *((_BYTE *)off_2E128 + 169) >= 4u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x19u, (__int64)&unk_2B408);
  }
  result = sub_131EC(0);
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    result = sub_11008(*((_QWORD *)off_2E128 + 19), 0x1Au, (__int64)&unk_2B408);
  }
  return result;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000012C8C) ----------------------------------------------------
__int64 __fastcall sub_12C8C(__int64 a1, _QWORD *a2)
{
  unsigned int v4; // esi
  void **v5; // rcx
  __int64 v7; // rdx
  __int64 v8; // r8
  __int64 v9; // rax
  unsigned int v10; // eax
  void **v11; // rcx
  __int64 v12; // [rsp+20h] [rbp-48h]
  _QWORD *v13; // [rsp+30h] [rbp-38h] BYREF
  PVOID P; // [rsp+38h] [rbp-30h] BYREF
  __int64 v15; // [rsp+40h] [rbp-28h]

  v4 = 0;
  v5 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x1Bu, (__int64)&unk_2B408);
    v5 = (void **)off_2E128;
  }
  if ( !a2 )
  {
    if ( v5 != &off_2E128 && (*((_BYTE *)v5 + 236) & 8) != 0 && *((_BYTE *)v5 + 233) >= 2u )
      sub_11008((__int64)v5[27], 0x1Cu, (__int64)&unk_2B408);
    return 4i64;
  }
  switch ( *(_DWORD *)a1 )
  {
    case 1:
      v13 = 0i64;
      P = 0i64;
      v15 = 0i64;
      if ( v5 != &off_2E128 && (*((_BYTE *)v5 + 236) & 8) != 0 && *((_BYTE *)v5 + 233) >= 4u )
        sub_12374((__int64)v5[27], 0x1Du, (__int64)&unk_2B408, a2);
      HIDWORD(v12) = 0;
      if ( !sub_1DC1C((struct _KEVENT **)&P, 0) )
      {
        v5 = (void **)off_2E128;
        if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
        {
          sub_11008(*((_QWORD *)off_2E128 + 27), 0x1Eu, (__int64)&unk_2B408);
          v5 = (void **)off_2E128;
        }
        v4 = 3;
        goto LABEL_83;
      }
      v9 = *(_QWORD *)(a1 + 12);
      v13 = a2;
      v15 = v9;
      if ( !*((_DWORD *)a2 + 6) && !*((_BYTE *)a2 + 32) )
        goto LABEL_81;
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
        sub_12374(*((_QWORD *)off_2E128 + 27), 0x1Fu, (__int64)&unk_2B408, &v13, 0i64, 0);
      v10 = sub_150C8((__int64)&v13);
      v4 = v10;
      if ( v10 )
      {
        v11 = (void **)off_2E128;
        if ( off_2E128 == &off_2E128 )
        {
LABEL_81:
          sub_1DC94(P);
          break;
        }
        if ( (*((_BYTE *)off_2E128 + 236) & 8) == 0 || *((_BYTE *)off_2E128 + 233) < 4u )
        {
LABEL_77:
          if ( v11 != &off_2E128 && (*((_BYTE *)v11 + 236) & 8) != 0 && *((_BYTE *)v11 + 233) >= 4u )
            sub_12374((__int64)v11[27], 0x22u, (__int64)&unk_2B408, &v13);
          goto LABEL_81;
        }
        LODWORD(v12) = v10;
        sub_123B0(*((_QWORD *)off_2E128 + 27), 33i64, (__int64)&unk_2B408, &v13, v12);
      }
      else
      {
        if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
          sub_12374(*((_QWORD *)off_2E128 + 27), 0x20u, (__int64)&unk_2B408, &v13);
        sub_1E308(P);
      }
      v11 = (void **)off_2E128;
      goto LABEL_77;
    case 2:
      if ( v5 != &off_2E128 )
      {
        if ( (*((_BYTE *)v5 + 236) & 8) != 0 && *((_BYTE *)v5 + 233) >= 4u )
        {
          sub_12374((__int64)v5[27], 0x23u, (__int64)&unk_2B408, a2);
          v5 = (void **)off_2E128;
        }
        if ( v5 != &off_2E128 && (*((_BYTE *)v5 + 236) & 8) != 0 && *((_BYTE *)v5 + 233) >= 4u )
        {
          sub_14544((__int64)v5[27], 0x24u, (__int64)&unk_2B408, *((_DWORD *)a2 + 2));
          v5 = (void **)off_2E128;
        }
      }
      if ( dword_2E300 )
      {
        sub_19600(*a2, 0i64, (__int64)a2 + 12);
      }
      else if ( v5 != &off_2E128 && _bittest((const signed __int32 *)v5 + 43, 0xEu) && *((_BYTE *)v5 + 169) >= 3u )
      {
        sub_11008((__int64)v5[19], 0x25u, (__int64)&unk_2B408);
      }
      sub_13AFC(*a2);
      if ( *((_DWORD *)a2 + 2) == 2 )
      {
        if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
          sub_12374(*((_QWORD *)off_2E128 + 27), 0x26u, (__int64)&unk_2B408, *a2);
        v4 = sub_1AE3C(*a2, v7, v8);
      }
      break;
    case 0xA:
      if ( v5 != &off_2E128 && (*((_BYTE *)v5 + 236) & 8) != 0 && *((_BYTE *)v5 + 233) >= 4u )
        sub_12374((__int64)v5[27], 0x27u, (__int64)&unk_2B408, a2);
      sub_153FC((__int64)a2);
      break;
    case 0xB:
      if ( v5 != &off_2E128 && (*((_BYTE *)v5 + 236) & 8) != 0 && *((_BYTE *)v5 + 233) >= 4u )
        sub_12374((__int64)v5[27], 0x28u, (__int64)&unk_2B408, a2);
      sub_15310(a2);
      break;
    default:
      if ( v5 != &off_2E128 && (*((_BYTE *)v5 + 236) & 8) != 0 && *((_BYTE *)v5 + 233) >= 4u )
      {
        sub_11008((__int64)v5[27], 0x29u, (__int64)&unk_2B408);
        v5 = (void **)off_2E128;
      }
      v4 = 4;
      goto LABEL_83;
  }
  v5 = (void **)off_2E128;
LABEL_83:
  if ( v5 != &off_2E128 && (*((_BYTE *)v5 + 236) & 8) != 0 && *((_BYTE *)v5 + 233) >= 5u )
    sub_11008((__int64)v5[27], 0x2Au, (__int64)&unk_2B408);
  return v4;
}
// 12EF4: variable 'v7' is possibly undefined
// 12EF4: variable 'v8' is possibly undefined
// 13088: variable 'v12' is possibly undefined
// 2E128: using guessed type void *off_2E128;
// 2E300: using guessed type int dword_2E300;

//----- (000000000001312C) ----------------------------------------------------
__int64 sub_1312C()
{
  unsigned int v0; // ebx

  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x2Bu, (__int64)&unk_2B408);
  }
  sub_255B8(&stru_2E310);
  memset(&dword_2E268, 0, 0x25ui64);
  byte_2E28C = 0;
  v0 = sub_127CC();
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x2Cu, (__int64)&unk_2B408);
  }
  return v0;
}
// 2E128: using guessed type void *off_2E128;
// 2E268: using guessed type int dword_2E268;
// 2E28C: using guessed type char byte_2E28C;

//----- (00000000000131EC) ----------------------------------------------------
__int64 __fastcall sub_131EC(char a1)
{
  unsigned int v1; // ebx
  int v3; // eax
  int v5[2]; // [rsp+20h] [rbp-38h] BYREF
  int v6; // [rsp+28h] [rbp-30h]
  int v7; // [rsp+30h] [rbp-28h] BYREF
  char Dst[17]; // [rsp+34h] [rbp-24h] BYREF

  v1 = 0;
  v5[0] = 0;
  v7 = 0;
  v5[1] = 0;
  v6 = 0;
  memset(Dst, 0, sizeof(Dst));
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x2Du, (__int64)&unk_2B408);
  }
  v7 = 2;
  *(_DWORD *)&Dst[1] = 0;
  v3 = sub_20AD8(0x2029007u);
  Dst[0] = a1;
  *(_DWORD *)&Dst[5] = v3;
  *(_DWORD *)&Dst[9] = sub_20AD8(0x2029008u);
  v5[0] = 20;
  v6 = 21;
  *(_DWORD *)&Dst[13] = sub_20AD8(0x2029009u);
  if ( sub_25618(&stru_2E310) )
  {
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
      && *((_BYTE *)off_2E128 + 169) >= 4u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x2Eu, (__int64)&unk_2B408);
    }
    if ( (unsigned int)qword_2E26C(2i64, v5, &v7) )
    {
      if ( off_2E128 != &off_2E128
        && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
        && *((_BYTE *)off_2E128 + 169) >= 2u )
      {
        sub_11008(*((_QWORD *)off_2E128 + 19), 0x2Fu, (__int64)&unk_2B408);
      }
      v1 = 11;
    }
    else if ( off_2E128 != &off_2E128
           && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
           && *((_BYTE *)off_2E128 + 169) >= 4u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x30u, (__int64)&unk_2B408);
    }
    sub_25680(&stru_2E310);
  }
  else if ( off_2E128 != &off_2E128
         && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
         && *((_BYTE *)off_2E128 + 169) >= 2u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x31u, (__int64)&unk_2B408);
  }
  return v1;
}
// 2E128: using guessed type void *off_2E128;
// 2E26C: using guessed type __int64 (__fastcall *qword_2E26C)(_QWORD, _QWORD, _QWORD);

//----- (00000000000133DC) ----------------------------------------------------
__int64 sub_133DC(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2E198(a1, 43i64, &unk_2B3F8, a2, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001342C) ----------------------------------------------------
__int64 __fastcall sub_1342C(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v5; // ebx
  void **v6; // rcx
  int v8[2]; // [rsp+20h] [rbp-58h] BYREF
  int v9; // [rsp+28h] [rbp-50h]
  __int64 v10; // [rsp+30h] [rbp-48h] BYREF
  __int64 v11; // [rsp+38h] [rbp-40h]
  _BYTE v12[20]; // [rsp+40h] [rbp-38h]
  __int64 v13; // [rsp+90h] [rbp+18h]
  __int64 v14; // [rsp+98h] [rbp+20h]

  v14 = a4;
  v13 = a3;
  v8[0] = 0;
  v10 = 0i64;
  v11 = 0i64;
  *(_OWORD *)v12 = 0ui64;
  v8[1] = 0;
  v9 = 0;
  *(_DWORD *)&v12[16] = 0;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0xAu, (__int64)&unk_2B3F8);
    a4 = v14;
    a3 = v13;
  }
  v11 = 0i64;
  *a1 = 0i64;
  v8[0] = 1;
  v9 = 36;
  *(_QWORD *)&v12[4] = a3;
  *(_QWORD *)&v12[12] = a4;
  *(_DWORD *)v12 = 2;
  if ( sub_25618(&stru_2E310) )
  {
    v5 = 11;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0xBu, (__int64)&unk_2B3F8);
    if ( (unsigned int)qword_2E26C(2i64, v8, &v10) )
    {
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
        sub_11008(*((_QWORD *)off_2E128 + 27), 0xCu, (__int64)&unk_2B3F8);
    }
    else
    {
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
        sub_11008(*((_QWORD *)off_2E128 + 27), 0xDu, (__int64)&unk_2B3F8);
      v5 = 0;
      *a1 = v10;
    }
    sub_25680(&stru_2E310);
    v6 = (void **)off_2E128;
  }
  else
  {
    v6 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 27), 0xEu, (__int64)&unk_2B3F8);
      v6 = (void **)off_2E128;
    }
    v5 = 9;
  }
  if ( v6 != &off_2E128 && (*((_BYTE *)v6 + 236) & 8) != 0 && *((_BYTE *)v6 + 233) >= 5u )
    sub_11008((__int64)v6[27], 0xFu, (__int64)&unk_2B3F8);
  return v5;
}
// 2E128: using guessed type void *off_2E128;
// 2E26C: using guessed type __int64 (__fastcall *qword_2E26C)(_QWORD, _QWORD, _QWORD);

//----- (0000000000013650) ----------------------------------------------------
__int64 __fastcall sub_13650(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v4; // esi
  __int64 v6; // rdi
  __int64 v7; // rbx
  _QWORD *v9; // rcx
  unsigned __int16 v10; // dx
  void **v11; // rcx
  int v13[2]; // [rsp+20h] [rbp-58h] BYREF
  int v14; // [rsp+28h] [rbp-50h]
  __int64 Dst[4]; // [rsp+30h] [rbp-48h] BYREF
  __int64 v16; // [rsp+80h] [rbp+8h]
  __int64 v17; // [rsp+88h] [rbp+10h]

  v17 = a2;
  v16 = a1;
  v4 = 0;
  v6 = a1;
  v13[0] = 0;
  v7 = a2;
  v13[1] = 0;
  v14 = 0;
  LODWORD(Dst[0]) = 0;
  memset((char *)Dst + 4, 0, 0x1Cui64);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x16u, (__int64)&unk_2B3F8);
    v7 = v17;
    v6 = v16;
  }
  Dst[1] = v7;
  Dst[0] = v6;
  Dst[2] = a3;
  Dst[3] = a4;
  v13[0] = 9;
  v14 = 32;
  if ( sub_25618(&stru_2E310) )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0x17u, (__int64)&unk_2B3F8);
    if ( (unsigned int)qword_2E26C(2i64, v13, Dst) )
    {
      v9 = off_2E128;
      if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 8) == 0 || *((_BYTE *)off_2E128 + 233) < 2u )
        goto LABEL_20;
      v10 = 24;
    }
    else
    {
      v9 = off_2E128;
      if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 8) == 0 || *((_BYTE *)off_2E128 + 233) < 4u )
        goto LABEL_20;
      v10 = 25;
    }
    sub_11008(v9[27], v10, (__int64)&unk_2B3F8);
LABEL_20:
    sub_25680(&stru_2E310);
    v11 = (void **)off_2E128;
    goto LABEL_26;
  }
  v11 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x1Au, (__int64)&unk_2B3F8);
    v11 = (void **)off_2E128;
  }
  v4 = 9;
LABEL_26:
  if ( v11 != &off_2E128 && (*((_BYTE *)v11 + 236) & 8) != 0 && *((_BYTE *)v11 + 233) >= 5u )
    sub_11008((__int64)v11[27], 0x1Bu, (__int64)&unk_2B3F8);
  return v4;
}
// 2E128: using guessed type void *off_2E128;
// 2E26C: using guessed type __int64 (__fastcall *qword_2E26C)(_QWORD, _QWORD, _QWORD);

//----- (0000000000013864) ----------------------------------------------------
__int64 __fastcall sub_13864(__int64 a1, int a2, __int64 a3, __int64 a4, int a5, char a6)
{
  unsigned int v6; // ebx
  void **v10; // rcx
  void **v11; // rcx
  __int64 v13; // [rsp+20h] [rbp-58h] BYREF
  __int64 v14; // [rsp+28h] [rbp-50h]
  __int64 v15; // [rsp+30h] [rbp-48h] BYREF
  _BYTE v16[24]; // [rsp+38h] [rbp-40h]
  char v17; // [rsp+50h] [rbp-28h]

  v6 = 0;
  *(_OWORD *)v16 = 0ui64;
  *(_QWORD *)&v16[16] = 0i64;
  v15 = 0i64;
  v13 = 0i64;
  LODWORD(v14) = 0;
  v17 = 0;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x1Cu, (__int64)&unk_2B3F8);
  *(_DWORD *)v16 = a2;
  *(_DWORD *)&v16[20] = a5;
  v15 = a1;
  *(_QWORD *)&v16[4] = 0i64;
  *(_QWORD *)&v16[12] = a4;
  v17 = a6;
  LODWORD(v13) = 6;
  LODWORD(v14) = 33;
  if ( sub_25618(&stru_2E310) )
  {
    v10 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128 )
    {
      if ( (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
      {
        sub_11008(*((_QWORD *)off_2E128 + 27), 0x1Du, (__int64)&unk_2B3F8);
        v10 = (void **)off_2E128;
      }
      if ( v10 != &off_2E128 )
      {
        if ( (*((_BYTE *)v10 + 236) & 8) != 0 && *((_BYTE *)v10 + 233) >= 4u )
        {
          sub_12374((__int64)v10[27], 0x1Eu, (__int64)&unk_2B3F8, v15, v13, v14);
          v10 = (void **)off_2E128;
        }
        if ( v10 != &off_2E128 && (*((_BYTE *)v10 + 236) & 8) != 0 && *((_BYTE *)v10 + 233) >= 4u )
          sub_14544((__int64)v10[27], 0x1Fu, (__int64)&unk_2B3F8, *(int *)v16);
      }
    }
    if ( (unsigned int)qword_2E26C(2i64, &v13, &v15) )
    {
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
        sub_11008(*((_QWORD *)off_2E128 + 27), 0x20u, (__int64)&unk_2B3F8);
      v6 = 11;
    }
    else if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 27), 0x21u, (__int64)&unk_2B3F8);
    }
    sub_25680(&stru_2E310);
    v11 = (void **)off_2E128;
  }
  else
  {
    v11 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 27), 0x22u, (__int64)&unk_2B3F8);
      v11 = (void **)off_2E128;
    }
    v6 = 9;
  }
  if ( v11 != &off_2E128 && (*((_BYTE *)v11 + 236) & 8) != 0 && *((_BYTE *)v11 + 233) >= 5u )
    sub_11008((__int64)v11[27], 0x23u, (__int64)&unk_2B3F8);
  return v6;
}
// 2E128: using guessed type void *off_2E128;
// 2E26C: using guessed type __int64 (__fastcall *qword_2E26C)(_QWORD, _QWORD, _QWORD);

//----- (0000000000013AFC) ----------------------------------------------------
__int64 __fastcall sub_13AFC(__int64 a1)
{
  unsigned int v1; // ebx
  _QWORD *v2; // rcx
  unsigned __int16 v3; // dx
  void **v4; // rcx
  __int64 v6; // [rsp+20h] [rbp-28h] BYREF
  __int64 v7; // [rsp+28h] [rbp-20h]
  __int64 v8; // [rsp+30h] [rbp-18h] BYREF
  __int64 v9; // [rsp+38h] [rbp-10h]
  __int64 v10; // [rsp+50h] [rbp+8h]

  v10 = a1;
  v1 = 0;
  v6 = 0i64;
  v8 = 0i64;
  LODWORD(v7) = 0;
  v9 = 0i64;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_12374(*((_QWORD *)off_2E128 + 27), 0x30u, (__int64)&unk_2B3F8, a1, v6, v7, v8, v9);
    a1 = v10;
  }
  v8 = a1;
  LODWORD(v6) = 12;
  LODWORD(v7) = 16;
  if ( sub_25618(&stru_2E310) )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
      sub_12374(*((_QWORD *)off_2E128 + 27), 0x31u, (__int64)&unk_2B3F8, v10, v6, v7, v8);
    if ( (unsigned int)qword_2E26C(2i64, &v6, &v8) )
    {
      v2 = off_2E128;
      if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 8) == 0 || *((_BYTE *)off_2E128 + 233) < 2u )
        goto LABEL_20;
      v3 = 50;
    }
    else
    {
      v2 = off_2E128;
      if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 8) == 0 || *((_BYTE *)off_2E128 + 233) < 4u )
        goto LABEL_20;
      v3 = 51;
    }
    sub_11008(v2[27], v3, (__int64)&unk_2B3F8);
LABEL_20:
    sub_25680(&stru_2E310);
    v4 = (void **)off_2E128;
    goto LABEL_26;
  }
  v4 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x34u, (__int64)&unk_2B3F8);
    v4 = (void **)off_2E128;
  }
  v1 = 9;
LABEL_26:
  if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 236) & 8) != 0 && *((_BYTE *)v4 + 233) >= 5u )
    sub_11008((__int64)v4[27], 0x35u, (__int64)&unk_2B3F8);
  return v1;
}
// 2E128: using guessed type void *off_2E128;
// 2E26C: using guessed type __int64 (__fastcall *qword_2E26C)(_QWORD, _QWORD, _QWORD);

//----- (0000000000013CDC) ----------------------------------------------------
__int64 __fastcall sub_13CDC(__int64 a1, __int64 a2, int a3, __int64 a4, int a5)
{
  unsigned int v5; // esi
  __int64 v7; // rdi
  __int64 v8; // rbx
  _QWORD *v10; // rcx
  unsigned __int16 v11; // dx
  void **v12; // rcx
  int v14[2]; // [rsp+20h] [rbp-58h] BYREF
  int v15; // [rsp+28h] [rbp-50h]
  __int64 Dst[2]; // [rsp+30h] [rbp-48h] BYREF
  int v17; // [rsp+40h] [rbp-38h]
  __int64 v18; // [rsp+44h] [rbp-34h]
  int v19; // [rsp+4Ch] [rbp-2Ch]
  __int64 v20; // [rsp+80h] [rbp+8h]
  __int64 v21; // [rsp+88h] [rbp+10h]

  v21 = a2;
  v20 = a1;
  v5 = 0;
  v7 = a1;
  v14[0] = 0;
  v8 = a2;
  v14[1] = 0;
  v15 = 0;
  LODWORD(Dst[0]) = 0;
  memset((char *)Dst + 4, 0, 0x1Cui64);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x3Cu, (__int64)&unk_2B3F8);
    v8 = v21;
    v7 = v20;
  }
  Dst[0] = v7;
  Dst[1] = v8;
  v17 = a3;
  v18 = a4;
  v19 = a5;
  v14[0] = 21;
  v15 = 32;
  if ( sub_25618(&stru_2E310) )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0x3Du, (__int64)&unk_2B3F8);
    if ( (unsigned int)qword_2E26C(2i64, v14, Dst) )
    {
      v10 = off_2E128;
      if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 8) == 0 || *((_BYTE *)off_2E128 + 233) < 2u )
        goto LABEL_20;
      v11 = 62;
    }
    else
    {
      v10 = off_2E128;
      if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 8) == 0 || *((_BYTE *)off_2E128 + 233) < 4u )
        goto LABEL_20;
      v11 = 63;
    }
    sub_11008(v10[27], v11, (__int64)&unk_2B3F8);
LABEL_20:
    sub_25680(&stru_2E310);
    v12 = (void **)off_2E128;
    goto LABEL_26;
  }
  v12 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x40u, (__int64)&unk_2B3F8);
    v12 = (void **)off_2E128;
  }
  v5 = 9;
LABEL_26:
  if ( v12 != &off_2E128 && (*((_BYTE *)v12 + 236) & 8) != 0 && *((_BYTE *)v12 + 233) >= 5u )
    sub_11008((__int64)v12[27], 0x41u, (__int64)&unk_2B3F8);
  return v5;
}
// 2E128: using guessed type void *off_2E128;
// 2E26C: using guessed type __int64 (__fastcall *qword_2E26C)(_QWORD, _QWORD, _QWORD);

//----- (0000000000013F00) ----------------------------------------------------
__int64 __fastcall sub_13F00(__int64 a1, __int64 a2)
{
  unsigned int v2; // edi
  __int64 v3; // rbx
  _QWORD *v5; // rcx
  unsigned __int16 v6; // dx
  void **v7; // rcx
  int v9[2]; // [rsp+30h] [rbp-48h] BYREF
  int v10; // [rsp+38h] [rbp-40h]
  __int64 Dst; // [rsp+40h] [rbp-38h] BYREF
  __int64 v12; // [rsp+48h] [rbp-30h]
  __int64 v13; // [rsp+50h] [rbp-28h]
  __int64 v14; // [rsp+80h] [rbp+8h]

  v14 = a1;
  v2 = 0;
  v3 = a1;
  v9[0] = 0;
  LODWORD(Dst) = 0;
  v9[1] = 0;
  v10 = 0;
  memset((char *)&Dst + 4, 0, 0x14ui64);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x42u, (__int64)&unk_2B3F8);
    v3 = v14;
  }
  Dst = v3;
  v13 = a2;
  v9[0] = 18;
  v10 = 24;
  v12 = 0i64;
  if ( sub_25618(&stru_2E310) )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
      sub_133DC(*((_QWORD *)off_2E128 + 27), 0x43u, (__int64)&unk_2B3F8, Dst, v12);
    if ( (unsigned int)qword_2E26C(2i64, v9, &Dst) )
    {
      v5 = off_2E128;
      if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 8) == 0 || *((_BYTE *)off_2E128 + 233) < 2u )
        goto LABEL_20;
      v6 = 68;
    }
    else
    {
      v5 = off_2E128;
      if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 8) == 0 || *((_BYTE *)off_2E128 + 233) < 4u )
        goto LABEL_20;
      v6 = 69;
    }
    sub_133DC(v5[27], v6, (__int64)&unk_2B3F8, Dst, v12);
LABEL_20:
    sub_25680(&stru_2E310);
    v7 = (void **)off_2E128;
    goto LABEL_26;
  }
  v7 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
  {
    sub_133DC(*((_QWORD *)off_2E128 + 27), 0x46u, (__int64)&unk_2B3F8, Dst, v12);
    v7 = (void **)off_2E128;
  }
  v2 = 9;
LABEL_26:
  if ( v7 != &off_2E128 && (*((_BYTE *)v7 + 236) & 8) != 0 && *((_BYTE *)v7 + 233) >= 5u )
    sub_11008((__int64)v7[27], 0x47u, (__int64)&unk_2B3F8);
  return v2;
}
// 2E128: using guessed type void *off_2E128;
// 2E26C: using guessed type __int64 (__fastcall *qword_2E26C)(_QWORD, _QWORD, _QWORD);

//----- (0000000000014140) ----------------------------------------------------
__int64 __fastcall sub_14140(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5)
{
  unsigned int v5; // esi
  __int64 v6; // rdi
  __int64 v7; // rbx
  _QWORD *v9; // rcx
  unsigned __int16 v10; // dx
  void **v11; // rcx
  int v13[2]; // [rsp+20h] [rbp-58h] BYREF
  int v14; // [rsp+28h] [rbp-50h]
  __int64 Dst[2]; // [rsp+30h] [rbp-48h] BYREF
  int v16; // [rsp+40h] [rbp-38h]
  __int64 v17; // [rsp+44h] [rbp-34h]
  int v18; // [rsp+4Ch] [rbp-2Ch]
  __int64 v19; // [rsp+80h] [rbp+8h]
  __int64 v20; // [rsp+88h] [rbp+10h]

  v20 = a2;
  v19 = a1;
  v5 = 0;
  v6 = a1;
  v7 = a2;
  v13[0] = 0;
  v13[1] = 0;
  v14 = 0;
  LODWORD(Dst[0]) = 0;
  memset((char *)Dst + 4, 0, 0x1Cui64);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x48u, (__int64)&unk_2B3F8);
    v7 = v20;
    v6 = v19;
  }
  Dst[0] = v6;
  Dst[1] = v7;
  v16 = 40010;
  v17 = a4;
  v18 = a5;
  v13[0] = 22;
  v14 = 32;
  if ( sub_25618(&stru_2E310) )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0x49u, (__int64)&unk_2B3F8);
    if ( (unsigned int)qword_2E26C(2i64, v13, Dst) )
    {
      v9 = off_2E128;
      if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 8) == 0 || *((_BYTE *)off_2E128 + 233) < 2u )
        goto LABEL_20;
      v10 = 74;
    }
    else
    {
      v9 = off_2E128;
      if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 8) == 0 || *((_BYTE *)off_2E128 + 233) < 4u )
        goto LABEL_20;
      v10 = 75;
    }
    sub_11008(v9[27], v10, (__int64)&unk_2B3F8);
LABEL_20:
    sub_25680(&stru_2E310);
    v11 = (void **)off_2E128;
    goto LABEL_26;
  }
  v11 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x4Cu, (__int64)&unk_2B3F8);
    v11 = (void **)off_2E128;
  }
  v5 = 9;
LABEL_26:
  if ( v11 != &off_2E128 && (*((_BYTE *)v11 + 236) & 8) != 0 && *((_BYTE *)v11 + 233) >= 5u )
    sub_11008((__int64)v11[27], 0x4Du, (__int64)&unk_2B3F8);
  return v5;
}
// 2E128: using guessed type void *off_2E128;
// 2E26C: using guessed type __int64 (__fastcall *qword_2E26C)(_QWORD, _QWORD, _QWORD);

//----- (0000000000014358) ----------------------------------------------------
__int64 __fastcall sub_14358(__int64 a1, __int64 a2, __int16 a3)
{
  unsigned int v3; // ebx
  _QWORD *v7; // rcx
  unsigned __int16 v8; // dx
  void **v9; // rcx
  int v11[2]; // [rsp+20h] [rbp-48h] BYREF
  int v12; // [rsp+28h] [rbp-40h]
  __int64 v13; // [rsp+30h] [rbp-38h] BYREF
  _TBYTE v14; // [rsp+38h] [rbp-30h]

  v3 = 0;
  v14 = 0.0;
  v13 = 0i64;
  v11[0] = 0;
  v11[1] = 0;
  v12 = 0;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x4Eu, (__int64)&unk_2B3F8);
  LOWORD(v14) = a3;
  v13 = a1;
  *(_QWORD *)((char *)&v14 + 2) = a2;
  v12 = 0;
  v11[0] = 23;
  if ( sub_25618(&stru_2E310) )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0x4Fu, (__int64)&unk_2B3F8);
    if ( (unsigned int)qword_2E26C(23i64, v11, &v13) )
    {
      v7 = off_2E128;
      if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 8) == 0 || *((_BYTE *)off_2E128 + 233) < 2u )
        goto LABEL_20;
      v8 = 80;
    }
    else
    {
      v7 = off_2E128;
      if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 8) == 0 || *((_BYTE *)off_2E128 + 233) < 4u )
        goto LABEL_20;
      v8 = 81;
    }
    sub_11008(v7[27], v8, (__int64)&unk_2B3F8);
LABEL_20:
    sub_25680(&stru_2E310);
    v9 = (void **)off_2E128;
    goto LABEL_26;
  }
  v9 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 8) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x52u, (__int64)&unk_2B3F8);
    v9 = (void **)off_2E128;
  }
  v3 = 9;
LABEL_26:
  if ( v9 != &off_2E128 && (*((_BYTE *)v9 + 236) & 8) != 0 && *((_BYTE *)v9 + 233) >= 5u )
    sub_11008((__int64)v9[27], 0x53u, (__int64)&unk_2B3F8);
  return v3;
}
// 2E128: using guessed type void *off_2E128;
// 2E26C: using guessed type __int64 (__fastcall *qword_2E26C)(_QWORD, _QWORD, _QWORD);

//----- (0000000000014544) ----------------------------------------------------
__int64 __fastcall sub_14544(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+68h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, a3, a2, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014580) ----------------------------------------------------
__int64 sub_14580(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2E198(a1, 43i64, &unk_2B3E8, a2, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000145D4) ----------------------------------------------------
__int64 sub_145D4(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+98h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2E198(a1, 43i64, &unk_2B3E8, 18i64, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014640) ----------------------------------------------------
__int64 sub_14640(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 v5; // [rsp+B8h] [rbp+20h] BYREF
  va_list va; // [rsp+B8h] [rbp+20h]
  __int64 v7; // [rsp+C0h] [rbp+28h]
  __int64 v8; // [rsp+C8h] [rbp+30h]
  __int64 v9; // [rsp+D0h] [rbp+38h]
  __int64 v10; // [rsp+D8h] [rbp+40h]
  const char *v11; // [rsp+E0h] [rbp+48h]
  va_list va1; // [rsp+E8h] [rbp+50h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, const char *);
  if ( v11 )
    strlen(v11);
  return qword_2E198(a1, 43i64, &unk_2B3E8, 54i64, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014720) ----------------------------------------------------
__int64 sub_14720(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2E198(a1, 43i64, &unk_2B3E8, 51i64, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014774) ----------------------------------------------------
__int64 sub_14774(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 v5; // [rsp+88h] [rbp+20h] BYREF
  va_list va; // [rsp+88h] [rbp+20h]
  const char *v7; // [rsp+90h] [rbp+28h]
  va_list va1; // [rsp+98h] [rbp+30h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, const char *);
  if ( v7 )
    strlen(v7);
  return qword_2E198(a1, 43i64, &unk_2B3E8, 44i64, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014818) ----------------------------------------------------
__int64 __fastcall sub_14818(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+F8h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B3E8, 67i64, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000148D8) ----------------------------------------------------
__int64 __fastcall sub_148D8(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+88h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B3E8, a2, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014934) ----------------------------------------------------
__int64 __fastcall sub_14934(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+98h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B3E8, 92i64, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000149A0) ----------------------------------------------------
__int64 __fastcall sub_149A0(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+B8h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B3E8, 66i64, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014A2C) ----------------------------------------------------
__int64 __fastcall sub_14A2C(__int64 a1, __int64 a2, __int64 a3, int a4, const char *a5)
{
  int v7; // [rsp+78h] [rbp+20h] BYREF

  v7 = a4;
  if ( a5 )
    strlen(a5);
  return qword_2E198(a1, 43i64, &unk_2B3E8, 136i64, &v7);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014AB8) ----------------------------------------------------
__int64 __fastcall sub_14AB8(__int64 a1, __int64 a2, __int64 a3, double a4)
{
  double v5; // [rsp+68h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B3E8, 95i64, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014B00) ----------------------------------------------------
__int64 sub_14B00(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2E198(a1, 43i64, &unk_2B3E8, 43i64, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014B50) ----------------------------------------------------
__int64 sub_14B50(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2E198(a1, 43i64, &unk_2B3E8, 37i64, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014BA4) ----------------------------------------------------
__int64 sub_14BA4(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2E198(a1, 43i64, a3, a2, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014BEC) ----------------------------------------------------
__int64 sub_14BEC(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+98h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2E198(a1, 43i64, &unk_2B3E8, a2, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014C58) ----------------------------------------------------
__int64 sub_14C58(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+88h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2E198(a1, 43i64, a3, a2, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014CAC) ----------------------------------------------------
__int64 sub_14CAC(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 v5; // [rsp+98h] [rbp+20h] BYREF
  va_list va; // [rsp+98h] [rbp+20h]
  const char *v7; // [rsp+A0h] [rbp+28h]
  va_list va1; // [rsp+A8h] [rbp+30h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, const char *);
  if ( v7 )
    strlen(v7);
  return qword_2E198(a1, 43i64, &unk_2B3E8, 39i64, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014D60) ----------------------------------------------------
__int64 __fastcall sub_14D60(__int64 a1, unsigned __int16 a2, __int64 a3, const char *a4)
{
  const char *v5; // rax

  if ( a4 )
    strlen(a4);
  v5 = "NULL";
  if ( a4 )
    v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B3E8, a2, v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014DC8) ----------------------------------------------------
__int64 __fastcall sub_14DC8(__int64 a1, __int64 a2, __int64 a3, const char *a4)
{
  const char *v5; // rax

  if ( a4 )
    strlen(a4);
  v5 = "NULL";
  if ( a4 )
    v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B3E8, 159i64, v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014E48) ----------------------------------------------------
__int64 __fastcall sub_14E48(__int64 a1, __int64 a2, __int64 a3, const char *a4)
{
  const char *v5; // rax

  if ( a4 )
    strlen(a4);
  v5 = "NULL";
  if ( a4 )
    v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B3E8, 101i64, v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014EDC) ----------------------------------------------------
__int64 __fastcall sub_14EDC(__int64 a1, __int64 a2, __int64 a3, const char *a4)
{
  const char *v5; // rax

  if ( a4 )
    strlen(a4);
  v5 = "NULL";
  if ( a4 )
    v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B3E8, 65i64, v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014F80) ----------------------------------------------------
__int64 __fastcall sub_14F80(__int64 a1, __int64 a2, __int64 a3, const char *a4)
{
  const char *v5; // rax

  if ( a4 )
    strlen(a4);
  v5 = "NULL";
  if ( a4 )
    v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B3E8, 114i64, v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000015018) ----------------------------------------------------
__int64 __fastcall sub_15018(__int64 a1, unsigned __int16 a2, __int64 a3, const char *a4, const char *a5)
{
  const char *v7; // rcx

  if ( a5 )
    strlen(a5);
  if ( a4 )
    strlen(a4);
  v7 = "NULL";
  if ( a4 )
    v7 = a4;
  return qword_2E198(a1, 43i64, a3, a2, v7);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000150C8) ----------------------------------------------------
__int64 __fastcall sub_150C8(__int64 a1)
{
  unsigned int v2; // ebx
  _QWORD *v3; // rax
  void **v4; // rcx

  v2 = 0;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0xAu, (__int64)&unk_2B3E8);
  v3 = sub_1E11C((__int64)qword_2E1D0, 8, (__int64)sub_15208);
  if ( v3 )
  {
    *v3 = a1;
    sub_1E294((__int64)v3, (**(_DWORD **)a1 + *(_DWORD *)(*(_QWORD *)a1 + 8i64)) % (unsigned int)dword_2E1D8 + 1);
    v4 = (void **)off_2E128;
  }
  else
  {
    v4 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 27), 0xBu, (__int64)&unk_2B3E8);
      v4 = (void **)off_2E128;
    }
    v2 = 3;
  }
  if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 236) & 4) != 0 && *((_BYTE *)v4 + 233) >= 5u )
    sub_14544((__int64)v4[27], 0xCu, (__int64)&unk_2B3E8, v2);
  return v2;
}
// 2E128: using guessed type void *off_2E128;
// 2E1D8: using guessed type int dword_2E1D8;

//----- (0000000000015208) ----------------------------------------------------
int __fastcall sub_15208(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  void **v5; // rcx
  int result; // eax
  __int64 v7; // rbx
  __int64 v8; // [rsp+20h] [rbp-18h]

  v5 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    result = sub_11008(*((_QWORD *)off_2E128 + 27), 0xDu, (__int64)&unk_2B3E8);
    v5 = (void **)off_2E128;
  }
  if ( a1 )
  {
    v7 = *a1;
    sub_15550((__int64 *)v7, a2, a3, a4, v8);
    result = sub_1DCFC(*(PRKEVENT *)(v7 + 8));
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
      result = sub_11008(*((_QWORD *)off_2E128 + 27), 0x10u, (__int64)&unk_2B3E8);
  }
  else if ( v5 != &off_2E128 && (*((_BYTE *)v5 + 236) & 4) != 0 && *((_BYTE *)v5 + 233) >= 2u )
  {
    result = sub_12374((__int64)v5[27], 0xEu, (__int64)&unk_2B3E8, 0i64);
  }
  return result;
}
// 152A5: variable 'a2' is possibly undefined
// 152A5: variable 'a3' is possibly undefined
// 152A5: variable 'a4' is possibly undefined
// 152A5: variable 'v8' is possibly undefined
// 2E128: using guessed type void *off_2E128;

//----- (0000000000015310) ----------------------------------------------------
__int64 __fastcall sub_15310(_QWORD *a1)
{
  void **v2; // rcx

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 27), 0x11u, (__int64)&unk_2B3E8);
      v2 = (void **)off_2E128;
    }
    if ( v2 != &off_2E128 )
    {
      if ( (*((_BYTE *)v2 + 236) & 4) != 0 && *((_BYTE *)v2 + 233) >= 4u )
      {
        sub_145D4(
          (__int64)v2[27],
          18i64,
          (__int64)&unk_2B3E8,
          *(_QWORD *)((char *)a1 + 28),
          *a1,
          a1[1],
          *(_QWORD *)((char *)a1 + 20));
        v2 = (void **)off_2E128;
      }
      if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 236) & 4) != 0 && *((_BYTE *)v2 + 233) >= 5u )
        sub_11008((__int64)v2[27], 0x13u, (__int64)&unk_2B3E8);
    }
  }
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;

//----- (00000000000153FC) ----------------------------------------------------
__int64 __fastcall sub_153FC(__int64 a1)
{
  __int64 v2; // rax
  unsigned int v3; // ebx
  __int64 v4; // rdi
  void **v5; // rcx
  unsigned int v7; // [rsp+50h] [rbp+8h] BYREF
  ULONG_PTR BugCheckParameter1; // [rsp+58h] [rbp+10h] BYREF

  v7 = 0;
  BugCheckParameter1 = 0i64;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x14u, (__int64)&unk_2B3E8);
  v2 = sub_1ACDC(*(_QWORD *)(a1 + 8), &BugCheckParameter1, &v7);
  v3 = v7;
  v4 = v2;
  if ( !v7 )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
      sub_1FF64(*((_QWORD *)off_2E128 + 27), v7 + 21, (__int64)&unk_2B3E8, *(_QWORD *)(a1 + 8), *(_DWORD *)(a1 + 28));
    _InterlockedAdd((volatile signed __int32 *)(v4 + 356), 0xFFFFFFFF);
    sub_1AF84(BugCheckParameter1);
    v3 = v7;
    goto LABEL_15;
  }
  v5 = (void **)off_2E128;
  if ( off_2E128 == &off_2E128 )
    return v3;
  if ( (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
  {
    sub_12374(*((_QWORD *)off_2E128 + 27), 0x16u, (__int64)&unk_2B3E8, *(_QWORD *)(a1 + 8));
LABEL_15:
    v5 = (void **)off_2E128;
  }
  if ( v5 != &off_2E128 && (*((_BYTE *)v5 + 236) & 4) != 0 && *((_BYTE *)v5 + 233) >= 5u )
    sub_11008((__int64)v5[27], 0x17u, (__int64)&unk_2B3E8);
  return v3;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000015550) ----------------------------------------------------
__int64 __fastcall sub_15550(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  char v5; // bp
  void **v7; // rcx
  unsigned int v9; // er9
  __int64 v10; // rcx
  int v11; // eax
  unsigned int v12; // ebx
  void **v13; // r10
  unsigned __int16 v14; // dx
  __int64 v15; // r10
  __int64 v16; // rax
  struct _FAST_MUTEX *v17; // rsi
  __int64 v18; // rax
  unsigned __int16 v19; // dx
  unsigned int v20; // eax
  ULONG_PTR *v21[9]; // [rsp+40h] [rbp-48h] BYREF
  char v22; // [rsp+90h] [rbp+8h] BYREF
  char v23; // [rsp+98h] [rbp+10h] BYREF
  int v24; // [rsp+A0h] [rbp+18h] BYREF
  int *v25; // [rsp+A8h] [rbp+20h] BYREF

  v25 = 0i64;
  v21[0] = 0i64;
  v5 = 0;
  v23 = 0;
  v22 = 1;
  v7 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x18u, (__int64)&unk_2B3E8);
    v7 = (void **)off_2E128;
  }
  if ( !a1 )
  {
    if ( v7 != &off_2E128 && (*((_BYTE *)v7 + 236) & 4) != 0 && *((_BYTE *)v7 + 233) >= 2u )
      sub_12374((__int64)v7[27], 0x19u, (__int64)&unk_2B3E8, 0i64);
    return 4i64;
  }
  v9 = *(_DWORD *)(*a1 + 24);
  if ( v9 < 0xC )
  {
    if ( v7 != &off_2E128 && (*((_BYTE *)v7 + 236) & 4) != 0 && *((_BYTE *)v7 + 233) >= 2u )
      sub_1E4A0((__int64)v7[27], 0x1Au, (__int64)&unk_2B3E8, v9);
    return 6i64;
  }
  if ( v9 > 0x200 )
  {
    if ( v7 != &off_2E128 && (*((_BYTE *)v7 + 236) & 4) != 0 && *((_BYTE *)v7 + 233) >= 2u )
      sub_14544((__int64)v7[27], 0x1Bu, (__int64)&unk_2B3E8, v9);
    return 6i64;
  }
  if ( !*(_QWORD *)(*a1 + 33) )
  {
    if ( v7 != &off_2E128 && (*((_BYTE *)v7 + 236) & 4) != 0 && *((_BYTE *)v7 + 233) >= 3u )
      sub_11008((__int64)v7[27], 0x1Cu, (__int64)&unk_2B3E8);
    return 6i64;
  }
  v10 = a1[2];
  if ( v10 && !*(_QWORD *)(v10 + 64) )
    return 6i64;
  v11 = sub_16A88(*a1, (__int64 *)&v25);
  v12 = v11;
  if ( v11 )
  {
    v13 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
    {
      v14 = 29;
LABEL_34:
      sub_14544((__int64)v13[27], v14, (__int64)&unk_2B3E8, v11);
LABEL_98:
      v13 = (void **)off_2E128;
      goto LABEL_99;
    }
    goto LABEL_99;
  }
  v11 = sub_16F24(v25, &v22);
  v12 = v11;
  v24 = v11;
  if ( !v11 )
  {
    if ( !v22 )
    {
      v13 = (void **)off_2E128;
      if ( off_2E128 == &off_2E128 )
      {
LABEL_52:
        if ( a5 )
        {
          sub_19BCC(a5);
          a5 = 0i64;
        }
        goto LABEL_54;
      }
      if ( (*((_BYTE *)off_2E128 + 236) & 4) == 0 || *((_BYTE *)off_2E128 + 233) < 4u )
      {
LABEL_48:
        if ( v13 != &off_2E128 && (*((_BYTE *)v13 + 236) & 4) != 0 && *((_BYTE *)v13 + 233) >= 4u )
        {
          sub_256E4(v12);
          sub_14CAC(*(_QWORD *)(v15 + 216), 39i64, (__int64)&unk_2B3E8, a5);
        }
        goto LABEL_52;
      }
      sub_11008(*((_QWORD *)off_2E128 + 27), 0x1Fu, (__int64)&unk_2B3E8);
      goto LABEL_45;
    }
    v16 = sub_1ACDC(*(_QWORD *)*a1, v21, &v24);
    v12 = v24;
    v17 = (struct _FAST_MUTEX *)v16;
    if ( v24 == 5 )
    {
      v18 = sub_1AA94((__int64 *)*a1, v25, v21, &v24);
      v12 = v24;
      v17 = (struct _FAST_MUTEX *)v18;
      if ( v24 )
      {
        v13 = (void **)off_2E128;
        if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 4) == 0 || *((_BYTE *)off_2E128 + 233) < 2u )
          goto LABEL_99;
        v19 = 32;
        goto LABEL_65;
      }
    }
    else if ( v24 )
    {
      v13 = (void **)off_2E128;
      if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 4) == 0 || *((_BYTE *)off_2E128 + 233) < 2u )
        goto LABEL_99;
      v19 = 33;
LABEL_65:
      sub_14580((__int64)v13[27], v19, (__int64)&unk_2B3E8, *(_QWORD *)*a1, v12);
      goto LABEL_98;
    }
    v20 = sub_16234((__int64)v17, v25);
    v12 = v20;
    if ( v20 && off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
      sub_14580(*((_QWORD *)off_2E128 + 27), 0x22u, (__int64)&unk_2B3E8, *(_QWORD *)*a1, v20);
    sub_18C5C((__int64)v17, (__int64)v25);
    v5 = sub_19494((char *)v25 + 40);
    if ( v5 )
    {
      v13 = (void **)off_2E128;
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
      {
        sub_14D60(*((_QWORD *)off_2E128 + 27), 0x23u, (__int64)&unk_2B3E8, (const char *)v25 + 40);
        goto LABEL_98;
      }
      goto LABEL_99;
    }
    v11 = sub_1B038(v17, v25);
    v12 = v11;
    if ( v11 )
    {
      v13 = (void **)off_2E128;
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
      {
        v14 = 36;
        goto LABEL_34;
      }
      goto LABEL_99;
    }
    if ( sub_15B58((__int64)v17) )
    {
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
        sub_14B50(*((_QWORD *)off_2E128 + 27), 37i64, (__int64)&unk_2B3E8);
      *(_BYTE *)(*a1 + 32) |= 4u;
    }
    else
    {
      sub_15D44((__int64)v17, a1[2], &v23);
      if ( v23 )
      {
        if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
          sub_11008(*((_QWORD *)off_2E128 + 27), 0x26u, (__int64)&unk_2B3E8);
        sub_1B8B0(v17);
        v25 = 0i64;
        goto LABEL_98;
      }
    }
LABEL_45:
    v13 = (void **)off_2E128;
    goto LABEL_46;
  }
  v13 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
  {
    v14 = 30;
    goto LABEL_34;
  }
LABEL_99:
  if ( v12 )
    goto LABEL_48;
LABEL_46:
  if ( !v22 || v5 )
    goto LABEL_48;
LABEL_54:
  sub_1AF84((ULONG_PTR)v21[1]);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x28u, (__int64)&unk_2B3E8);
  return v12;
}
// 157FA: variable 'v15' is possibly undefined
// 2E128: using guessed type void *off_2E128;

//----- (0000000000015B58) ----------------------------------------------------
char __fastcall sub_15B58(__int64 a1)
{
  char v2; // di
  void **v3; // rcx

  v2 = 0;
  v3 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x29u, (__int64)&unk_2B3E8);
    v3 = (void **)off_2E128;
  }
  if ( a1 )
  {
    if ( !*(_QWORD *)(a1 + 368) )
    {
      if ( v3 == &off_2E128 )
        return v2;
      if ( (*((_BYTE *)v3 + 236) & 0x20) == 0 || *((_BYTE *)v3 + 233) < 2u )
        goto LABEL_25;
      sub_14B00((__int64)v3[27], 43i64, (__int64)&unk_2B3E8, *(_QWORD *)(a1 + 56), 0i64);
      goto LABEL_24;
    }
    if ( *(_DWORD *)(a1 + 360) == 1 )
    {
      if ( (unsigned int)sub_20AD8(0x202900Bu) )
      {
        v2 = sub_19334((char *)(*(_QWORD *)(a1 + 368) + 40i64));
        if ( v2 )
        {
          ++*(_DWORD *)(a1 + 388);
          v3 = (void **)off_2E128;
          if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
          {
            sub_14774(
              *((_QWORD *)off_2E128 + 27),
              44i64,
              (__int64)&unk_2B3E8,
              *(_QWORD *)(a1 + 56),
              *(_QWORD *)(a1 + 368) + 40i64,
              *(_DWORD *)(a1 + 388));
            v3 = (void **)off_2E128;
          }
          if ( *(_BYTE *)(a1 + 97) )
            goto LABEL_25;
          *(_BYTE *)(a1 + 97) = 1;
          sub_18FA0((__int64 *)a1);
        }
      }
      goto LABEL_24;
    }
  }
  else
  {
    if ( v3 == &off_2E128 )
      return v2;
    if ( (*((_BYTE *)v3 + 236) & 0x20) != 0 && *((_BYTE *)v3 + 233) >= 2u )
    {
      sub_12374((__int64)v3[27], 0x2Au, (__int64)&unk_2B3E8, 0i64);
LABEL_24:
      v3 = (void **)off_2E128;
      goto LABEL_25;
    }
  }
LABEL_25:
  if ( v3 != &off_2E128 && (*((_BYTE *)v3 + 236) & 0x20) != 0 && *((_BYTE *)v3 + 233) >= 5u )
    sub_11008((__int64)v3[27], 0x2Du, (__int64)&unk_2B3E8);
  return v2;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000015D44) ----------------------------------------------------
__int64 __fastcall sub_15D44(__int64 a1, __int64 a2, _BYTE *a3)
{
  unsigned int v3; // edi
  __int64 v6; // rsi
  void **v8; // rcx
  int v9; // eax
  unsigned int v10; // edi
  _BYTE *v11; // rax
  int v12; // ecx
  __int64 v13; // rcx
  int v14; // eax

  v3 = 0;
  v6 = 0i64;
  v8 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 59, 0xBu)
    && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x2Eu, (__int64)&unk_2B3E8);
    v8 = (void **)off_2E128;
  }
  if ( !a1 )
  {
    if ( v8 != &off_2E128 && _bittest((const signed __int32 *)v8 + 59, 0xBu) && *((_BYTE *)v8 + 233) >= 2u )
    {
      sub_12374((__int64)v8[27], 0x2Fu, (__int64)&unk_2B3E8, 0i64);
      v8 = (void **)off_2E128;
    }
    v3 = 4;
    goto LABEL_57;
  }
  if ( (unsigned int)sub_20AD8(0x2029016u) )
  {
    if ( *(_QWORD *)(a1 + 368) && *(_QWORD *)(a1 + 376) && a2 )
    {
      if ( _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 356), 1, 1) == 1 )
      {
        v8 = (void **)off_2E128;
        if ( off_2E128 == &off_2E128 )
          return v3;
        if ( !_bittest((const signed __int32 *)off_2E128 + 59, 0xBu) || *((_BYTE *)off_2E128 + 233) < 3u )
          goto LABEL_57;
        sub_12374(*((_QWORD *)off_2E128 + 27), 0x32u, (__int64)&unk_2B3E8, *(_QWORD *)(a1 + 56));
        goto LABEL_56;
      }
      if ( off_2E128 != &off_2E128
        && _bittest((const signed __int32 *)off_2E128 + 59, 0xBu)
        && *((_BYTE *)off_2E128 + 233) >= 4u )
      {
        sub_14720(*((_QWORD *)off_2E128 + 27), 51i64, (__int64)&unk_2B3E8, *(_QWORD *)(a1 + 56), a2);
      }
      v9 = sub_13F00(*(_QWORD *)(a1 + 56), a2);
      v3 = v9;
      if ( v9 )
      {
        v8 = (void **)off_2E128;
        if ( off_2E128 == &off_2E128 )
          return v3;
        if ( !_bittest((const signed __int32 *)off_2E128 + 59, 0xBu) || *((_BYTE *)off_2E128 + 233) < 2u )
          goto LABEL_57;
        sub_14544(*((_QWORD *)off_2E128 + 27), 0x34u, (__int64)&unk_2B3E8, v9);
        goto LABEL_56;
      }
      v10 = *(_DWORD *)(*(_QWORD *)(a1 + 368) + 16i64) + *(_DWORD *)(*(_QWORD *)(a1 + 376) + 16i64);
      v11 = sub_1D254(2, v10 + 288, 0x61576E44u);
      v6 = (__int64)v11;
      if ( v11 )
      {
        sub_29D00(v11 + 12, 256i64, (char *)(a1 + 98));
        *(_WORD *)(v6 + 8) = *(_WORD *)(a1 + 80);
        *(_WORD *)(v6 + 10) = *(_WORD *)(a1 + 88);
        *(_DWORD *)(v6 + 280) = *(_DWORD *)(*(_QWORD *)(a1 + 368) + 16i64);
        v12 = *(_DWORD *)(*(_QWORD *)(a1 + 376) + 16i64);
        *(_DWORD *)(v6 + 268) = 0;
        *(_QWORD *)(v6 + 272) = 0i64;
        *(_DWORD *)(v6 + 284) = v12;
        sub_29D88(
          (void *)(v6 + 288),
          v10,
          *(const void **)(*(_QWORD *)(a1 + 368) + 8i64),
          *(unsigned int *)(*(_QWORD *)(a1 + 368) + 16i64));
        v13 = *(unsigned int *)(*(_QWORD *)(a1 + 368) + 16i64);
        sub_29D88(
          (void *)(v13 + v6 + 288),
          v10 - (unsigned int)v13,
          *(const void **)(*(_QWORD *)(a1 + 376) + 8i64),
          *(unsigned int *)(*(_QWORD *)(a1 + 376) + 16i64));
        if ( off_2E128 != &off_2E128
          && _bittest((const signed __int32 *)off_2E128 + 59, 0xBu)
          && *((_BYTE *)off_2E128 + 233) >= 4u )
        {
          sub_14640(
            *((_QWORD *)off_2E128 + 27),
            54i64,
            (__int64)&unk_2B3E8,
            *(_QWORD *)(a1 + 56),
            *(unsigned __int16 *)(v6 + 8),
            *(unsigned __int16 *)(v6 + 10),
            *(_DWORD *)(v6 + 280),
            *(_DWORD *)(v6 + 284),
            a1 + 98);
        }
        v14 = sub_14140(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), 40010i64, v6, v10 + 288);
        v3 = v14;
        if ( v14
          && off_2E128 != &off_2E128
          && _bittest((const signed __int32 *)off_2E128 + 59, 0xBu)
          && *((_BYTE *)off_2E128 + 233) >= 2u )
        {
          sub_14544(*((_QWORD *)off_2E128 + 27), 0x37u, (__int64)&unk_2B3E8, v14);
        }
        _InterlockedAdd((volatile signed __int32 *)(a1 + 356), 1u);
        v8 = (void **)off_2E128;
        *a3 = 1;
      }
      else
      {
        v8 = (void **)off_2E128;
        if ( off_2E128 != &off_2E128
          && _bittest((const signed __int32 *)off_2E128 + 59, 0xBu)
          && *((_BYTE *)off_2E128 + 233) >= 2u )
        {
          sub_11008(*((_QWORD *)off_2E128 + 27), 0x35u, (__int64)&unk_2B3E8);
          v8 = (void **)off_2E128;
        }
        v3 = 3;
      }
    }
    else
    {
      v8 = (void **)off_2E128;
      if ( off_2E128 != &off_2E128
        && _bittest((const signed __int32 *)off_2E128 + 59, 0xBu)
        && *((_BYTE *)off_2E128 + 233) >= 3u )
      {
        sub_14C58(*((_QWORD *)off_2E128 + 27), 0x31u, (__int64)&unk_2B3E8);
        v8 = (void **)off_2E128;
      }
      v3 = 6;
    }
    if ( v6 )
    {
      sub_1D2D8((PVOID)v6, 0x61576E44u);
      goto LABEL_56;
    }
  }
  else
  {
    v8 = (void **)off_2E128;
    if ( off_2E128 == &off_2E128 )
      return v3;
    if ( _bittest((const signed __int32 *)off_2E128 + 59, 0xBu) && *((_BYTE *)off_2E128 + 233) >= 4u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 27), 0x30u, (__int64)&unk_2B3E8);
LABEL_56:
      v8 = (void **)off_2E128;
      goto LABEL_57;
    }
  }
LABEL_57:
  if ( v8 != &off_2E128 && _bittest((const signed __int32 *)v8 + 59, 0xBu) && *((_BYTE *)v8 + 233) >= 5u )
    sub_11008((__int64)v8[27], 0x38u, (__int64)&unk_2B3E8);
  return v3;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000016234) ----------------------------------------------------
__int64 __fastcall sub_16234(__int64 a1, int *a2)
{
  unsigned int v3; // ebx
  char *v4; // rdi
  unsigned __int16 v5; // bp
  unsigned __int16 v6; // r12
  __int64 v8; // r13
  unsigned int v9; // er14
  void **v10; // r10
  int v11; // ecx
  int v12; // ecx
  const char *v13; // r9
  unsigned __int16 v14; // dx
  int v15; // ecx
  int v16; // ecx
  __int64 v17; // rdi
  unsigned __int16 v18; // r8
  _DWORD *v19; // rdx
  int v20; // er12
  char *v21; // rax
  unsigned __int16 v23; // bp
  char *v24; // rbx
  unsigned __int16 v25; // ax
  __int64 v26; // rsi
  char v27; // al
  int v28; // eax
  char *P; // [rsp+70h] [rbp-98h]
  int v30; // [rsp+B4h] [rbp-54h]
  char *v31; // [rsp+B8h] [rbp-50h]
  __int64 v32; // [rsp+C0h] [rbp-48h]
  unsigned __int16 v33; // [rsp+110h] [rbp+8h]
  unsigned __int16 v34; // [rsp+120h] [rbp+18h]

  v3 = 0;
  v4 = 0i64;
  v5 = 0;
  v6 = 0;
  v33 = 0;
  v8 = (int)sub_20AD8(0x2029014u);
  v9 = sub_20AD8(0x2029015u);
  v10 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 59, 9u)
    && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x39u, (__int64)&unk_2B3E8);
    v10 = (void **)off_2E128;
  }
  if ( !a1 || !a2 )
  {
    if ( v10 != &off_2E128 && _bittest((const signed __int32 *)v10 + 59, 9u) && *((_BYTE *)v10 + 233) >= 2u )
    {
      sub_14BA4((__int64)v10[27], 0x3Au, (__int64)&unk_2B3E8, a1, a2);
      v10 = (void **)off_2E128;
    }
    v3 = 4;
    goto LABEL_62;
  }
  v11 = *(_DWORD *)(a1 + 72);
  if ( v11 == 2 )
  {
    v15 = *a2;
    if ( *a2 != 2 )
    {
      if ( v10 == &off_2E128 )
        return v3;
      if ( (*((_BYTE *)v10 + 236) & 4) == 0 || *((_BYTE *)v10 + 233) < 4u )
        goto LABEL_64;
      if ( v15 )
      {
        v16 = v15 - 1;
        if ( !v16 )
        {
          v13 = "REQUEST";
          goto LABEL_28;
        }
        if ( v16 == 1 )
        {
          v13 = "RESPONSE";
LABEL_28:
          v14 = 60;
LABEL_17:
          sub_14D60((__int64)v10[27], v14, (__int64)&unk_2B3E8, v13);
          v10 = (void **)off_2E128;
          goto LABEL_64;
        }
      }
      v13 = "TYPE_UNKNOWN";
      goto LABEL_28;
    }
    v17 = v8;
    v18 = 0;
    if ( *((_WORD *)a2 + 14) )
    {
      v19 = (_DWORD *)(*((_QWORD *)a2 + 37) + 8i64);
      while ( 1 )
      {
        if ( *v19 == 1 && (v8 == 1 || v8 == 3) )
        {
          ++v5;
        }
        else if ( *v19 == 28 && (v8 == 2 || v8 == 3) )
        {
          ++v6;
        }
        if ( v5 + (unsigned int)v6 >= v9 )
          break;
        ++v18;
        v19 += 10;
        if ( v18 >= *((_WORD *)a2 + 14) )
          goto LABEL_46;
      }
      if ( v10 != &off_2E128 && _bittest((const signed __int32 *)v10 + 59, 9u) && *((_BYTE *)v10 + 233) >= 3u )
      {
        sub_14544((__int64)v10[27], 0x3Du, (__int64)&unk_2B3E8, v9);
        v10 = (void **)off_2E128;
      }
    }
LABEL_46:
    v20 = v5 + v6;
    v30 = v20;
    if ( !v20 )
    {
      if ( v10 == &off_2E128 )
        return v3;
      if ( !_bittest((const signed __int32 *)v10 + 59, 9u) || *((_BYTE *)v10 + 233) < 3u )
        goto LABEL_64;
      v13 = (const char *)(a2 + 10);
      v14 = 62;
      goto LABEL_17;
    }
    if ( v10 != &off_2E128 && _bittest((const signed __int32 *)v10 + 59, 9u) && *((_BYTE *)v10 + 233) >= 4u )
      sub_1E4A0((__int64)v10[27], 0x3Fu, (__int64)&unk_2B3E8, v5);
    v21 = (char *)sub_1D254(2, 21 * v20, 0x6C416E44u);
    P = v21;
    if ( !v21 )
    {
      v10 = (void **)off_2E128;
      if ( off_2E128 != &off_2E128
        && _bittest((const signed __int32 *)off_2E128 + 59, 9u)
        && *((_BYTE *)off_2E128 + 233) >= 2u )
      {
        sub_11008(*((_QWORD *)off_2E128 + 27), 0x40u, (__int64)&unk_2B3E8);
        v10 = (void **)off_2E128;
      }
      v3 = 3;
      goto LABEL_61;
    }
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 59, 9u)
      && *((_BYTE *)off_2E128 + 233) >= 4u )
    {
      sub_14EDC(*((_QWORD *)off_2E128 + 27), 65i64, (__int64)&unk_2B3E8, (const char *)a2 + 40);
      v21 = P;
    }
    v23 = 0;
    v34 = 0;
    if ( *((_WORD *)a2 + 14) )
    {
      v24 = v21 + 16;
      v25 = 0;
      v26 = *((_QWORD *)a2 + 37) + 8i64;
      v31 = v24;
      v32 = v26;
      do
      {
        if ( v25 >= v20 )
          break;
        if ( *(_DWORD *)v26 == 1 && (v17 == 1 || v17 == 3) || *(_DWORD *)v26 == 28 && (v17 == 2 || v17 == 3) )
        {
          v27 = 16;
          if ( *(_DWORD *)v26 == 1 )
            v27 = 4;
          v24[4] = v27;
          sub_29D88(v24 - 12, 0x10ui64, *(const void **)(v26 + 24), *(unsigned __int16 *)(v26 + 12));
          *((_DWORD *)v24 - 4) = *(_DWORD *)(v26 + 8);
          if ( *(_DWORD *)v26 == 1 )
          {
            if ( off_2E128 != &off_2E128
              && _bittest((const signed __int32 *)off_2E128 + 59, 9u)
              && *((_BYTE *)off_2E128 + 233) >= 4u )
            {
              sub_149A0(*((_QWORD *)off_2E128 + 27), 66i64, (__int64)&unk_2B3E8, v33);
            }
          }
          else if ( off_2E128 != &off_2E128
                 && _bittest((const signed __int32 *)off_2E128 + 59, 9u)
                 && *((_BYTE *)off_2E128 + 233) >= 4u )
          {
            sub_14818(*((_QWORD *)off_2E128 + 27), 67i64, (__int64)&unk_2B3E8, v33);
            v24 = v31;
            v17 = v8;
            v26 = v32;
            v20 = v30;
            v23 = v34;
          }
          v25 = v33 + 1;
          v24 += 21;
          v31 = v24;
          ++v33;
        }
        else
        {
          v25 = v33;
        }
        ++v23;
        v26 += 40i64;
        v32 = v26;
        v34 = v23;
      }
      while ( v23 < *((_WORD *)a2 + 14) );
      v21 = P;
    }
    v28 = sub_14358((__int64)(a2 + 10), (__int64)v21, v33);
    v3 = v28;
    if ( v28 )
    {
      v10 = (void **)off_2E128;
      if ( off_2E128 == &off_2E128
        || !_bittest((const signed __int32 *)off_2E128 + 59, 9u)
        || *((_BYTE *)off_2E128 + 233) < 2u )
      {
        goto LABEL_61;
      }
      sub_14544(*((_QWORD *)off_2E128 + 27), 0x44u, (__int64)&unk_2B3E8, v28);
    }
    v10 = (void **)off_2E128;
LABEL_61:
    v4 = P;
LABEL_62:
    if ( v4 )
    {
      sub_1D2D8(v4, 0x6C416E44u);
      v10 = (void **)off_2E128;
    }
    goto LABEL_64;
  }
  if ( v10 == &off_2E128 )
    return v3;
  if ( (*((_BYTE *)v10 + 236) & 4) != 0 && *((_BYTE *)v10 + 233) >= 4u )
  {
    v12 = v11 - 1;
    if ( v12 )
    {
      if ( v12 == 1 )
        v13 = "OUTGOING";
      else
        v13 = "UNKNOWN";
    }
    else
    {
      v13 = "INCOMING";
    }
    v14 = 59;
    goto LABEL_17;
  }
LABEL_64:
  if ( v10 != &off_2E128 && _bittest((const signed __int32 *)v10 + 59, 9u) && *((_BYTE *)v10 + 233) >= 5u )
    sub_11008((__int64)v10[27], 0x45u, (__int64)&unk_2B3E8);
  return v3;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000016A88) ----------------------------------------------------
__int64 __fastcall sub_16A88(__int64 a1, __int64 *a2)
{
  void **v4; // rcx
  unsigned int v5; // edx
  _DWORD *v7; // rax
  void **v8; // rcx
  unsigned int v9; // ebx
  void **v10; // r10
  __int64 v11; // r9

  v4 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x46u, (__int64)&unk_2B3E8);
    v4 = (void **)off_2E128;
  }
  if ( a1 && a2 )
  {
    v5 = *(_DWORD *)(a1 + 24);
    if ( v5 < 0xC )
    {
      if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 236) & 4) != 0 && *((_BYTE *)v4 + 233) >= 2u )
        sub_11008((__int64)v4[27], 0x48u, (__int64)&unk_2B3E8);
      return 6i64;
    }
    v7 = sub_19A30(*(_QWORD *)(a1 + 16), v5);
    *a2 = (__int64)v7;
    if ( v7 )
    {
      v7[4] = *(_DWORD *)(a1 + 24);
      sub_29D88(*(void **)(*a2 + 8), *(unsigned int *)(*a2 + 16), *(const void **)(a1 + 16), *(unsigned int *)(a1 + 24));
      v10 = (void **)off_2E128;
      if ( off_2E128 != &off_2E128 )
      {
        if ( (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
        {
          sub_11008(*((_QWORD *)off_2E128 + 27), 0x4Au, (__int64)&unk_2B3E8);
          v10 = (void **)off_2E128;
        }
        if ( v10 != &off_2E128 )
        {
          if ( (*((_BYTE *)v10 + 236) & 4) != 0 && *((_BYTE *)v10 + 233) >= 4u )
          {
            sub_14544(
              (__int64)v10[27],
              0x4Bu,
              (__int64)&unk_2B3E8,
              (unsigned __int8)HIBYTE(**(_WORD **)(*a2 + 8)) | (unsigned __int16)((unsigned __int8)**(_WORD **)(*a2 + 8) << 8));
            v10 = (void **)off_2E128;
          }
          if ( v10 != &off_2E128 )
          {
            if ( (*((_BYTE *)v10 + 236) & 4) != 0 && *((_BYTE *)v10 + 233) >= 4u )
            {
              sub_14544(
                (__int64)v10[27],
                0x4Cu,
                (__int64)&unk_2B3E8,
                (unsigned __int8)HIBYTE(*(_WORD *)(*(_QWORD *)(*a2 + 8) + 2i64)) | (unsigned __int16)((unsigned __int8)*(_WORD *)(*(_QWORD *)(*a2 + 8) + 2i64) << 8));
              v10 = (void **)off_2E128;
            }
            if ( v10 != &off_2E128 )
            {
              if ( (*((_BYTE *)v10 + 236) & 4) != 0 && *((_BYTE *)v10 + 233) >= 4u )
              {
                sub_14544(
                  (__int64)v10[27],
                  0x4Du,
                  (__int64)&unk_2B3E8,
                  (unsigned __int8)HIBYTE(*(_WORD *)(*(_QWORD *)(*a2 + 8) + 4i64)) | (unsigned __int16)((unsigned __int8)*(_WORD *)(*(_QWORD *)(*a2 + 8) + 4i64) << 8));
                v10 = (void **)off_2E128;
              }
              if ( v10 != &off_2E128 )
              {
                if ( (*((_BYTE *)v10 + 236) & 4) != 0 && *((_BYTE *)v10 + 233) >= 4u )
                {
                  sub_14544(
                    (__int64)v10[27],
                    0x4Eu,
                    (__int64)&unk_2B3E8,
                    (unsigned __int8)HIBYTE(*(_WORD *)(*(_QWORD *)(*a2 + 8) + 6i64)) | (unsigned __int16)((unsigned __int8)*(_WORD *)(*(_QWORD *)(*a2 + 8) + 6i64) << 8));
                  v10 = (void **)off_2E128;
                }
                if ( v10 != &off_2E128 )
                {
                  if ( (*((_BYTE *)v10 + 236) & 4) != 0 && *((_BYTE *)v10 + 233) >= 4u )
                  {
                    sub_14544(
                      (__int64)v10[27],
                      0x4Fu,
                      (__int64)&unk_2B3E8,
                      (unsigned __int8)HIBYTE(*(_WORD *)(*(_QWORD *)(*a2 + 8) + 8i64)) | (unsigned __int16)((unsigned __int8)*(_WORD *)(*(_QWORD *)(*a2 + 8) + 8i64) << 8));
                    v10 = (void **)off_2E128;
                  }
                  if ( v10 != &off_2E128 && (*((_BYTE *)v10 + 236) & 4) != 0 && *((_BYTE *)v10 + 233) >= 4u )
                    sub_14544(
                      (__int64)v10[27],
                      0x50u,
                      (__int64)&unk_2B3E8,
                      (unsigned __int8)HIBYTE(*(_WORD *)(*(_QWORD *)(*a2 + 8) + 10i64)) | (unsigned __int16)((unsigned __int8)*(_WORD *)(*(_QWORD *)(*a2 + 8) + 10i64) << 8));
                }
              }
            }
          }
        }
      }
      sub_17220(*(_WORD **)(*a2 + 8), *a2);
      v11 = *(_QWORD *)(*a2 + 8);
      if ( (((unsigned __int8)HIBYTE(*(_WORD *)(v11 + 2)) | (unsigned __int16)((unsigned __int8)*(_WORD *)(v11 + 2) << 8)) & 0x7800) != 0 )
      {
        v8 = (void **)off_2E128;
        if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
        {
          sub_11008(*((_QWORD *)off_2E128 + 27), 0x51u, (__int64)&unk_2B3E8);
          v8 = (void **)off_2E128;
        }
        v9 = 18;
      }
      else
      {
        v9 = sub_17DA4(v11, *(_DWORD *)(a1 + 24), *a2);
        sub_18700(*a2);
        v8 = (void **)off_2E128;
        if ( !v9 )
        {
LABEL_56:
          if ( v8 != &off_2E128 && (*((_BYTE *)v8 + 236) & 4) != 0 && *((_BYTE *)v8 + 233) >= 5u )
            sub_11008((__int64)v8[27], 0x52u, (__int64)&unk_2B3E8);
          return v9;
        }
      }
    }
    else
    {
      v8 = (void **)off_2E128;
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
      {
        sub_11008(*((_QWORD *)off_2E128 + 27), 0x49u, (__int64)&unk_2B3E8);
        v8 = (void **)off_2E128;
      }
      v9 = 3;
    }
    if ( *a2 )
    {
      sub_19BCC(*a2);
      *a2 = 0i64;
      v8 = (void **)off_2E128;
    }
    goto LABEL_56;
  }
  if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 236) & 4) != 0 && *((_BYTE *)v4 + 233) >= 2u )
    sub_14BA4((__int64)v4[27], 0x47u, (__int64)&unk_2B3E8, a1, a2);
  return 4i64;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000016F24) ----------------------------------------------------
__int64 __fastcall sub_16F24(_DWORD *a1, _BYTE *a2)
{
  void **v4; // rcx
  int v5; // eax
  const char *v6; // rax
  __int64 v7; // r10
  unsigned __int16 v8; // dx
  const char *v9; // r9
  const char *v10; // rax
  const char *v11; // rax
  int v12; // eax
  int v13; // ecx

  v4 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x53u, (__int64)&unk_2B3E8);
    v4 = (void **)off_2E128;
  }
  if ( a1 && a2 )
  {
    *a2 = 1;
    v5 = sub_20AD8(0x202900Du);
    if ( *a1 != 1 || v5 == 1 || v5 == 3 )
    {
      if ( *a1 != 2 )
        goto LABEL_37;
      if ( v5 == 2 || v5 == 3 )
      {
        v12 = sub_20AD8(0x202900Eu);
        v13 = a1[6];
        if ( v13 )
        {
          if ( v12 == 2 || v12 == 3 )
            goto LABEL_37;
          if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 4) == 0 || *((_BYTE *)off_2E128 + 233) < 4u )
            goto LABEL_36;
          v10 = sub_26094(v13);
          v8 = 88;
        }
        else
        {
          if ( v12 == 1 || v12 == 3 )
            goto LABEL_37;
          if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 4) == 0 || *((_BYTE *)off_2E128 + 233) < 4u )
            goto LABEL_36;
          v10 = sub_26094(0);
          v8 = 87;
        }
      }
      else
      {
        if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 4) == 0 || *((_BYTE *)off_2E128 + 233) < 4u )
          goto LABEL_36;
        v11 = sub_26134(v5);
        v8 = 86;
        v9 = v11;
        v10 = "RESPONSE";
      }
    }
    else
    {
      if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 4) == 0 || *((_BYTE *)off_2E128 + 233) < 4u )
        goto LABEL_36;
      v6 = sub_26134(v5);
      v8 = 85;
      v9 = v6;
      v10 = "REQUEST";
    }
    sub_15018(*(_QWORD *)(v7 + 216), v8, (__int64)&unk_2B3E8, v9, v10);
LABEL_36:
    *a2 = 0;
LABEL_37:
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0x59u, (__int64)&unk_2B3E8);
    return 0i64;
  }
  if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 236) & 4) != 0 && *((_BYTE *)v4 + 233) >= 2u )
    sub_14BA4((__int64)v4[27], 0x54u, (__int64)&unk_2B3E8, a1, a2);
  return 4i64;
}
// 170FB: conditional instruction was optimized away because of 'ecx.4==0'
// 1717E: variable 'v7' is possibly undefined
// 1718D: variable 'v9' is possibly undefined
// 2E128: using guessed type void *off_2E128;

//----- (0000000000017220) ----------------------------------------------------
__int64 __fastcall sub_17220(_WORD *a1, __int64 a2)
{
  __int16 v2; // r8

  *(_WORD *)(a2 + 20) = (unsigned __int8)HIBYTE(*a1) | ((unsigned __int8)*a1 << 8);
  v2 = _byteswap_ushort(a1[1]) & 0x8000;
  *(_DWORD *)a2 = (v2 == -32768) + 1;
  *(_WORD *)(a2 + 22) = _byteswap_ushort(a1[2]);
  if ( v2 == -32768 )
  {
    *(_WORD *)(a2 + 28) = _byteswap_ushort(a1[3]);
    *(_DWORD *)(a2 + 24) = HIBYTE(a1[1]) & 0xF;
  }
  return 0i64;
}

//----- (00000000000172D8) ----------------------------------------------------
__int64 __fastcall sub_172D8(__int64 a1, unsigned __int16 *a2, unsigned int a3, double *a4)
{
  __int64 v4; // r11
  unsigned int v5; // er15
  unsigned __int16 *v6; // rbp
  int v7; // er14
  int v8; // er13
  int v9; // eax
  unsigned int v10; // esi
  int v11; // er15
  unsigned __int8 *v12; // r13
  __int64 v13; // r14
  int v14; // ebp
  int v15; // eax
  void **v16; // r10
  const char *v17; // rax
  __int64 v18; // r10
  unsigned __int8 v20[4]; // [rsp+40h] [rbp-68h] BYREF
  int v21; // [rsp+44h] [rbp-64h] BYREF
  int v22; // [rsp+48h] [rbp-60h]
  int v23; // [rsp+4Ch] [rbp-5Ch]
  int v24; // [rsp+50h] [rbp-58h]
  int v25; // [rsp+54h] [rbp-54h]
  int v26; // [rsp+58h] [rbp-50h]
  unsigned __int16 *v27; // [rsp+60h] [rbp-48h] BYREF
  __int64 v28; // [rsp+B0h] [rbp+8h]
  unsigned __int16 *v29; // [rsp+B8h] [rbp+10h]
  unsigned int v30; // [rsp+C0h] [rbp+18h]

  v30 = a3;
  v29 = a2;
  v28 = a1;
  v4 = a1;
  v5 = a3;
  v6 = a2;
  v21 = 0;
  v20[0] = 0;
  v27 = 0i64;
  v23 = 0;
  v7 = 0;
  v25 = 0;
  v8 = 0;
  v26 = 0;
  if ( !a1 || !a2 || !a4 )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
      sub_14C58(*((_QWORD *)off_2E128 + 27), 0x5Au, (__int64)&unk_2B3E8, a1, a2, a4);
    return 4;
  }
  v27 = a2;
  v24 = 1;
  while ( 1 )
  {
    v9 = sub_179FC(v4, &v27, &v21, v20);
    v10 = v9;
    if ( v9 )
      break;
    if ( v21 == 2 )
    {
      v11 = *(unsigned __int8 *)v27;
      v12 = (unsigned __int8 *)v27 + 1;
      if ( v27 == (unsigned __int16 *)-1i64 || !*(_BYTE *)v27 )
      {
LABEL_17:
        v15 = v23;
        v16 = (void **)off_2E128;
      }
      else
      {
        v13 = *(unsigned __int8 *)v27;
        v14 = 0;
        do
        {
          if ( isdigit(*v12) )
            ++v14;
          ++v12;
          --v13;
        }
        while ( v13 );
        v7 = v25;
        v22 = v14;
        v6 = v29;
        v15 = v22;
        v23 = v22;
        v16 = (void **)off_2E128;
        if ( off_2E128 != &off_2E128
          && _bittest((const signed __int32 *)off_2E128 + 43, 0x15u)
          && *((_BYTE *)off_2E128 + 169) >= 4u )
        {
          sub_14544(*((_QWORD *)off_2E128 + 19), 0x10u, (__int64)&unk_2B368, v22);
          goto LABEL_17;
        }
      }
      v7 += v15;
      v8 = v11 + v26;
      v25 = v7;
      v26 += v11;
      if ( v16 != &off_2E128 && (*((_BYTE *)v16 + 236) & 4) != 0 && *((_BYTE *)v16 + 233) >= 4u )
      {
        sub_14934((__int64)v16[27], 92i64, (__int64)&unk_2B3E8, v24);
        v16 = (void **)off_2E128;
      }
      ++v24;
      v5 = v30;
      goto LABEL_27;
    }
    v16 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
    {
      v17 = sub_186BC(v21);
      sub_14D60(*(_QWORD *)(v18 + 216), 0x5Du, (__int64)&unk_2B3E8, v17);
      v16 = (void **)off_2E128;
    }
LABEL_27:
    if ( v27 > (unsigned __int16 *)((char *)v6 + v5) )
    {
      if ( v16 != &off_2E128 && (*((_BYTE *)v16 + 236) & 4) != 0 && *((_BYTE *)v16 + 233) >= 3u )
        sub_14BEC((__int64)v16[27], 0x5Eu, (__int64)&unk_2B3E8, v27, v6, v5, (char *)v6 + v5);
      return 10;
    }
    v4 = v28;
    if ( v21 == 3 )
    {
      if ( v8 )
      {
        *a4 = (double)(100 * v7) / (double)v8;
        v16 = (void **)off_2E128;
      }
      if ( v16 != &off_2E128 && (*((_BYTE *)v16 + 236) & 4) != 0 && *((_BYTE *)v16 + 233) >= 4u )
        sub_14AB8((__int64)v16[27], 95i64, (__int64)&unk_2B3E8, *a4);
      return v10;
    }
  }
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
    sub_14544(*((_QWORD *)off_2E128 + 27), 0x5Bu, (__int64)&unk_2B3E8, v9);
  return 4;
}
// 174B1: variable 'v18' is possibly undefined
// 2E128: using guessed type void *off_2E128;

//----- (0000000000017674) ----------------------------------------------------
__int64 __fastcall sub_17674(__int64 a1, unsigned __int16 *a2, unsigned int a3, char a4, _WORD *a5)
{
  __int64 v6; // r14
  unsigned __int8 v7; // bp
  int v8; // eax
  unsigned int v9; // edi
  const char *v10; // rax
  __int64 v11; // r11
  _QWORD *v12; // rcx
  unsigned __int16 v13; // dx
  const char *v14; // rax
  __int64 v15; // r10
  int v17; // [rsp+40h] [rbp-38h] BYREF
  unsigned __int16 *v18; // [rsp+48h] [rbp-30h] BYREF
  unsigned __int8 v19; // [rsp+80h] [rbp+8h] BYREF
  char v20; // [rsp+98h] [rbp+20h]

  v20 = a4;
  v6 = a3;
  v17 = 0;
  v19 = 0;
  v18 = 0i64;
  v7 = 0;
  if ( !a1 || !a2 || !a5 )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
      sub_14C58(*((_QWORD *)off_2E128 + 27), 0x60u, (__int64)&unk_2B3E8, a1, a2, a5);
    return 4;
  }
  v18 = a2;
  while ( 1 )
  {
    while ( 1 )
    {
      v8 = sub_179FC(a1, &v18, &v17, &v19);
      v9 = v8;
      if ( v8 )
      {
        if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
          sub_14544(*((_QWORD *)off_2E128 + 27), 0x61u, (__int64)&unk_2B3E8, v8);
        return 4;
      }
      if ( (unsigned __int64)v18 > a1 + v6 )
      {
        if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 3u )
          sub_14BEC(*((_QWORD *)off_2E128 + 27), 0x62u, (__int64)&unk_2B3E8);
        return 10;
      }
      if ( v7 > (unsigned int)v6 )
      {
        if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 3u )
          sub_1E4A0(*((_QWORD *)off_2E128 + 27), 0x63u, (__int64)&unk_2B3E8, v7);
        return 10;
      }
      if ( !v20 )
        break;
      if ( v17 == 2 )
      {
        v7 += v19;
        v12 = off_2E128;
        if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 3u )
        {
          v13 = 102;
LABEL_24:
          sub_1E4A0(v12[27], v13, (__int64)&unk_2B3E8, v19);
          goto LABEL_25;
        }
      }
      else if ( v17 == 3 )
      {
        --v7;
        v12 = off_2E128;
        if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 4) == 0 || *((_BYTE *)off_2E128 + 233) < 3u )
          goto LABEL_31;
        v13 = 103;
        goto LABEL_24;
      }
    }
    v7 += v19;
    if ( v17 != 2 )
      break;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 3u )
    {
      v10 = sub_186BC(2);
      sub_14E48(*(_QWORD *)(v11 + 216), v9 + 101, (__int64)&unk_2B3E8, v10);
LABEL_25:
      if ( v17 == 3 )
        goto LABEL_31;
    }
  }
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 3u )
  {
    v14 = sub_186BC(v17);
    sub_14D60(*(_QWORD *)(v15 + 216), 0x64u, (__int64)&unk_2B3E8, v14);
  }
LABEL_31:
  *a5 = v7;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
    sub_14544(*((_QWORD *)off_2E128 + 27), 0x68u, (__int64)&unk_2B3E8, v7);
  return v9;
}
// 17775: variable 'v11' is possibly undefined
// 1785B: variable 'v15' is possibly undefined
// 2E128: using guessed type void *off_2E128;

//----- (00000000000179FC) ----------------------------------------------------
__int64 __fastcall sub_179FC(__int64 a1, unsigned __int16 **a2, int *a3, unsigned __int8 *a4)
{
  unsigned int v4; // esi
  int v7; // er13
  void **v8; // r10
  const char *v9; // rax
  __int64 v10; // r10
  char v11; // r12
  unsigned __int16 v12; // r13
  unsigned __int16 *v13; // r13
  int v14; // er14
  const char *v15; // rax
  __int64 v16; // r10
  const char *v17; // rax
  __int64 v18; // r10
  char *v21; // [rsp+88h] [rbp+20h]

  v21 = (char *)a4;
  v4 = 0;
  if ( a2 && a3 && a4 )
  {
    v7 = *a3;
    if ( *a3 == 3 )
    {
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 3u )
        sub_11008(*((_QWORD *)off_2E128 + 27), 0x6Au, (__int64)&unk_2B3E8);
      v4 = 10;
    }
    else
    {
      v8 = (void **)off_2E128;
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
      {
        v9 = sub_186BC(v7);
        sub_14D60(*(_QWORD *)(v10 + 216), 0x6Bu, (__int64)&unk_2B3E8, v9);
        v8 = (void **)off_2E128;
        a4 = (unsigned __int8 *)v21;
      }
      v11 = 2;
      if ( v7 == 1 )
      {
        v12 = _byteswap_ushort(**a2) & 0x3FFF;
        if ( v8 != &off_2E128 && (*((_BYTE *)v8 + 236) & 4) != 0 && *((_BYTE *)v8 + 233) >= 4u )
        {
          sub_14544((__int64)v8[27], 0x6Cu, (__int64)&unk_2B3E8, v12);
          v8 = (void **)off_2E128;
        }
        v13 = (unsigned __int16 *)(a1 + v12);
      }
      else if ( v7 == 2 )
      {
        if ( v8 != &off_2E128 && (*((_BYTE *)v8 + 236) & 4) != 0 && *((_BYTE *)v8 + 233) >= 4u )
        {
          sub_14544((__int64)v8[27], 0x6Du, (__int64)&unk_2B3E8, *a4);
          v8 = (void **)off_2E128;
        }
        v13 = (unsigned __int16 *)((char *)*a2 + (unsigned __int8)*v21);
      }
      else
      {
        if ( v8 != &off_2E128 && (*((_BYTE *)v8 + 236) & 4) != 0 && *((_BYTE *)v8 + 233) >= 4u )
        {
          sub_11008((__int64)v8[27], 0x6Eu, (__int64)&unk_2B3E8);
          v8 = (void **)off_2E128;
        }
        v13 = *a2;
      }
      if ( (*(_BYTE *)v13 & 0xC0) != 0 )
        v14 = (*(_BYTE *)v13 & 0xC0) == 192;
      else
        v14 = 2;
      if ( v8 != &off_2E128 && (*((_BYTE *)v8 + 236) & 4) != 0 && *((_BYTE *)v8 + 233) >= 4u )
      {
        v15 = sub_186BC(v14);
        sub_14D60(*(_QWORD *)(v16 + 216), 0x6Fu, (__int64)&unk_2B3E8, v15);
        v8 = (void **)off_2E128;
      }
      if ( v14 != 1 )
      {
        if ( *(_BYTE *)v13 )
        {
          v11 = *(_BYTE *)v13 + 1;
          if ( v8 != &off_2E128 && (*((_BYTE *)v8 + 236) & 4) != 0 && *((_BYTE *)v8 + 233) >= 4u )
            sub_1E4A0((__int64)v8[27], 0x71u, (__int64)&unk_2B3E8, *(unsigned __int8 *)v13);
        }
        else
        {
          if ( v8 != &off_2E128 && (*((_BYTE *)v8 + 236) & 4) != 0 && *((_BYTE *)v8 + 233) >= 4u )
            sub_11008((__int64)v8[27], 0x70u, (__int64)&unk_2B3E8);
          v11 = 1;
          v14 = 3;
        }
      }
      *a3 = v14;
      *a2 = v13;
      *v21 = v11;
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
      {
        v17 = sub_186BC(*a3);
        sub_14F80(*(_QWORD *)(v18 + 216), 114i64, (__int64)&unk_2B3E8, v17);
      }
    }
  }
  else
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
      sub_14C58(*((_QWORD *)off_2E128 + 27), 0x69u, (__int64)&unk_2B3E8, a2, a3, a4);
    v4 = 4;
  }
  return v4;
}
// 17ABF: variable 'v10' is possibly undefined
// 17C1D: variable 'v16' is possibly undefined
// 17D10: variable 'v18' is possibly undefined
// 2E128: using guessed type void *off_2E128;

//----- (0000000000017DA4) ----------------------------------------------------
__int64 __fastcall sub_17DA4(__int64 a1, int a2, __int64 a3)
{
  unsigned __int16 v5; // si
  unsigned __int16 v6; // r12
  void **v8; // r10
  unsigned int v9; // edi
  __int64 v10; // rcx
  unsigned __int16 v11; // dx
  __int64 result; // rax
  unsigned __int16 v13; // r15
  unsigned __int16 *v14; // rbx
  __int16 v15; // r13
  __int64 v16; // rdx
  char v17; // al
  __int64 v18; // rcx
  __int16 v19; // si
  __int64 v20; // rdi
  unsigned __int16 v21; // r12
  __int64 v22; // r13
  int v23; // eax
  unsigned __int16 v24; // si
  __int16 *v25; // rbx
  __int16 v26; // cx
  int v27; // ecx
  const char *v28; // rax
  __int64 v29; // r10
  _WORD *v30; // rbx
  __int16 v31; // si
  __int16 v32; // cx
  int v33; // ecx
  const char *v34; // rax
  __int64 v35; // r10
  _DWORD *v36; // rbx
  __int16 v37; // si
  int v38; // er9
  __int16 *v39; // rbx
  __int16 v40; // si
  __int16 v41; // dx
  unsigned __int16 v42; // dx
  __int64 v43; // rcx
  _WORD *v44; // rbx
  unsigned __int16 *v45; // rbx
  __int16 v46; // si
  __int16 v47; // cx
  int v48; // ecx
  const char *v49; // rax
  __int64 v50; // r10
  __int16 v51; // cx
  int v52; // ecx
  const char *v53; // rax
  __int64 v54; // r10
  unsigned int v55; // [rsp+30h] [rbp-48h]
  int v56; // [rsp+38h] [rbp-40h]
  __int64 v57; // [rsp+80h] [rbp+8h] BYREF
  unsigned __int16 v58; // [rsp+98h] [rbp+20h]

  v57 = a1;
  v55 = 0;
  v5 = 0;
  v6 = 0;
  v8 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x73u, (__int64)&unk_2B3E8);
    v8 = (void **)off_2E128;
  }
  v9 = *(unsigned __int8 *)(a1 + 12);
  if ( v9 >= 0x40 )
  {
    if ( v8 != &off_2E128 && (*((_BYTE *)v8 + 236) & 4) != 0 && *((_BYTE *)v8 + 233) >= 2u )
    {
      v10 = (__int64)v8[27];
      v11 = 116;
LABEL_10:
      sub_14544(v10, v11, (__int64)&unk_2B3E8, v9);
    }
    return 6i64;
  }
  if ( *(_BYTE *)(a1 + 12) )
  {
    v13 = a2 - 13;
    if ( v8 != &off_2E128 && (*((_BYTE *)v8 + 236) & 4) != 0 && *((_BYTE *)v8 + 233) >= 5u )
    {
      sub_148D8((__int64)v8[27], 0x76u, (__int64)&unk_2B3E8, a2);
      v8 = (void **)off_2E128;
    }
    if ( *(_WORD *)(a3 + 22) )
    {
      v14 = (unsigned __int16 *)(a1 + 13);
      if ( v8 != &off_2E128 && (*((_BYTE *)v8 + 236) & 4) != 0 && *((_BYTE *)v8 + 233) >= 4u )
      {
        sub_11008((__int64)v8[27], 0x78u, (__int64)&unk_2B3E8);
        v8 = (void **)off_2E128;
      }
      if ( *(_BYTE *)v14 )
      {
        while ( 1 )
        {
          if ( v5 > v13 )
            goto LABEL_39;
          v15 = v9;
          v16 = (unsigned __int16)v9;
          do
          {
            v17 = *(_BYTE *)v14;
            v18 = v6;
            v14 = (unsigned __int16 *)((char *)v14 + 1);
            ++v6;
            --v16;
            *(_BYTE *)(v18 + a3 + 40) = v17;
          }
          while ( v16 );
          v9 = *(unsigned __int8 *)v14;
          v19 = v15 + v5;
          if ( v9 >= 0x40 )
            break;
          if ( !*(_BYTE *)v14 )
          {
            if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
              sub_14D60(*((_QWORD *)off_2E128 + 27), 0x7Au, (__int64)&unk_2B3E8, (const char *)(a3 + 40));
            v45 = (unsigned __int16 *)((char *)v14 + 1);
            v46 = v19 + 1;
            v47 = (unsigned __int8)*v45;
            v58 = *v45;
            v48 = HIBYTE(v58) | (unsigned __int16)(v47 << 8);
            *(_DWORD *)(a3 + 32) = v48;
            if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
            {
              v49 = sub_25B40(v48);
              sub_14D60(*(_QWORD *)(v50 + 216), 0x7Bu, (__int64)&unk_2B3E8, v49);
            }
            v14 = v45 + 1;
            v5 = v46 + 2;
            v51 = (unsigned __int8)*v14;
            v58 = *v14;
            v52 = HIBYTE(v58) | (unsigned __int16)(v51 << 8);
            *(_DWORD *)(a3 + 36) = v52;
            v8 = (void **)off_2E128;
            if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
            {
              v53 = sub_26044(v52);
              sub_14D60(*(_QWORD *)(v54 + 216), 0x7Cu, (__int64)&unk_2B3E8, v53);
              v8 = (void **)off_2E128;
            }
            if ( *(_WORD *)(a3 + 28) )
            {
              ++v14;
              v5 += 2;
            }
            if ( v8 != &off_2E128 && (*((_BYTE *)v8 + 236) & 4) != 0 && *((_BYTE *)v8 + 233) >= 4u )
            {
              sub_11008((__int64)v8[27], 0x7Du, (__int64)&unk_2B3E8);
LABEL_39:
              v8 = (void **)off_2E128;
              goto LABEL_40;
            }
            goto LABEL_40;
          }
          v14 = (unsigned __int16 *)((char *)v14 + 1);
          v5 = v19 + 1;
          *(_BYTE *)(v6++ + a3 + 40) = 46;
          if ( !*(_BYTE *)v14 )
            goto LABEL_39;
        }
        if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
        {
          v10 = *((_QWORD *)off_2E128 + 27);
          v11 = 121;
          goto LABEL_10;
        }
        return 6i64;
      }
LABEL_40:
      if ( *(_WORD *)(a3 + 28) )
      {
        v20 = *(_QWORD *)(a3 + 296);
        v21 = 0;
        if ( v5 <= v13 )
        {
          v22 = v57;
          while ( 1 )
          {
            if ( v21 >= *(_WORD *)(a3 + 28) )
              goto LABEL_107;
            LOWORD(v57) = 0;
            if ( v8 != &off_2E128 && (*((_BYTE *)v8 + 236) & 4) != 0 && *((_BYTE *)v8 + 233) >= 4u )
              sub_14544((__int64)v8[27], 0x7Eu, (__int64)&unk_2B3E8, v21);
            *(_QWORD *)v20 = v14;
            v23 = sub_17674(v22, v14, v13, 0, &v57);
            v55 = v23;
            if ( v23 )
              break;
            v8 = (void **)off_2E128;
            if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
            {
              sub_14544(*((_QWORD *)off_2E128 + 27), 0x80u, (__int64)&unk_2B3E8, (unsigned __int16)v57);
              v8 = (void **)off_2E128;
            }
            v24 = v57 + v5;
            v25 = (__int16 *)((char *)v14 + (unsigned __int16)v57);
            if ( v24 > v13 )
            {
              if ( v8 == &off_2E128 )
                goto LABEL_111;
              if ( (*((_BYTE *)v8 + 236) & 4) != 0 && *((_BYTE *)v8 + 233) >= 3u )
              {
                sub_11008((__int64)v8[27], 0x81u, (__int64)&unk_2B3E8);
LABEL_106:
                v8 = (void **)off_2E128;
                goto LABEL_107;
              }
              goto LABEL_107;
            }
            v26 = (unsigned __int8)*v25;
            v58 = *v25;
            v27 = HIBYTE(v58) | (unsigned __int16)(v26 << 8);
            *(_DWORD *)(v20 + 8) = v27;
            if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
            {
              v28 = sub_25B40(v27);
              sub_14D60(*(_QWORD *)(v29 + 216), 0x82u, (__int64)&unk_2B3E8, v28);
            }
            v30 = v25 + 1;
            v31 = v24 + 2;
            v32 = (unsigned __int8)*v30;
            v58 = *v30;
            v33 = HIBYTE(v58) | (unsigned __int16)(v32 << 8);
            *(_DWORD *)(v20 + 12) = v33;
            if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
            {
              v34 = sub_26044(v33);
              sub_14D60(*(_QWORD *)(v35 + 216), 0x83u, (__int64)&unk_2B3E8, v34);
            }
            v36 = v30 + 1;
            v37 = v31 + 2;
            v56 = *v36;
            v58 = HIWORD(*v36);
            v38 = ((BYTE1(v56) | (unsigned __int16)((unsigned __int8)v56 << 8)) << 16)
                + (HIBYTE(v56) | (unsigned __int16)(BYTE2(v56) << 8));
            *(_DWORD *)(v20 + 16) = v38;
            if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
              sub_14544(*((_QWORD *)off_2E128 + 27), 0x84u, (__int64)&unk_2B3E8, v38);
            v39 = (__int16 *)(v36 + 1);
            v40 = v37 + 4;
            v41 = (unsigned __int8)*v39;
            v58 = *v39;
            v42 = HIBYTE(v58) | (unsigned __int16)(v41 << 8);
            *(_WORD *)(v20 + 20) = v42;
            if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
              sub_14544(*((_QWORD *)off_2E128 + 27), 0x85u, (__int64)&unk_2B3E8, v42);
            v43 = *(unsigned __int16 *)(v20 + 20);
            v44 = v39 + 1;
            *(_QWORD *)(v20 + 32) = v44;
            v5 = v43 + 2 + v40;
            v14 = (_WORD *)((char *)v44 + v43);
            v8 = (void **)off_2E128;
            if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
            {
              sub_14544(*((_QWORD *)off_2E128 + 27), 0x86u, (__int64)&unk_2B3E8, v21);
              v8 = (void **)off_2E128;
            }
            v20 += 40i64;
            ++v21;
            if ( v5 > v13 )
              goto LABEL_107;
          }
          v8 = (void **)off_2E128;
          if ( off_2E128 == &off_2E128 )
            goto LABEL_111;
          if ( (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 3u )
          {
            sub_14544(*((_QWORD *)off_2E128 + 27), 0x7Fu, (__int64)&unk_2B3E8, v23);
            goto LABEL_106;
          }
        }
      }
LABEL_107:
      if ( v8 != &off_2E128 && (*((_BYTE *)v8 + 236) & 4) != 0 && *((_BYTE *)v8 + 233) >= 5u )
        sub_11008((__int64)v8[27], 0x87u, (__int64)&unk_2B3E8);
LABEL_111:
      result = v55;
    }
    else
    {
      if ( v8 != &off_2E128 && (*((_BYTE *)v8 + 236) & 4) != 0 && *((_BYTE *)v8 + 233) >= 3u )
        sub_11008((__int64)v8[27], 0x77u, (__int64)&unk_2B3E8);
      result = 5i64;
    }
  }
  else
  {
    if ( v8 != &off_2E128 && (*((_BYTE *)v8 + 236) & 4) != 0 && *((_BYTE *)v8 + 233) >= 5u )
      sub_11008((__int64)v8[27], 0x75u, (__int64)&unk_2B3E8);
    result = 12i64;
  }
  return result;
}
// 17FA5: conditional instruction was optimized away because of 'di.2 in (1..3F)'
// 18175: variable 'v29' is possibly undefined
// 181E7: variable 'v35' is possibly undefined
// 18416: variable 'v50' is possibly undefined
// 18484: variable 'v54' is possibly undefined
// 2E128: using guessed type void *off_2E128;

//----- (000000000001861C) ----------------------------------------------------
char __fastcall sub_1861C(int a1)
{
  const char *v2; // rax
  __int64 v3; // r10
  int v4; // er9

  if ( a1 > 20 )
  {
    if ( a1 == 28 || a1 == 33 || a1 == 37 )
      return 0;
  }
  else if ( a1 == 20 || a1 > 0 && (a1 <= 2 || a1 > 4 && (a1 <= 6 || a1 > 10 && (a1 <= 13 || a1 > 14 && a1 <= 16))) )
  {
    return 0;
  }
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 3u )
  {
    v2 = sub_25B40(a1);
    sub_14A2C(*(_QWORD *)(v3 + 216), 136i64, (__int64)&unk_2B3E8, v4, v2);
  }
  return 1;
}
// 18693: variable 'v3' is possibly undefined
// 186AB: variable 'v4' is possibly undefined
// 2E128: using guessed type void *off_2E128;

//----- (00000000000186BC) ----------------------------------------------------
const char *__fastcall sub_186BC(int a1)
{
  int v1; // ecx
  int v2; // ecx

  if ( !a1 )
    return "UNKNOWN";
  v1 = a1 - 1;
  if ( !v1 )
    return "POINTER";
  v2 = v1 - 1;
  if ( !v2 )
    return "LABEL";
  if ( v2 == 1 )
    return (const char *)qword_2A550;
  return (const char *)qword_2A560;
}
// 2A550: using guessed type __int64 qword_2A550[2];
// 2A560: using guessed type __int64 qword_2A560[2];

//----- (0000000000018700) ----------------------------------------------------
void **__fastcall sub_18700(__int64 a1)
{
  void **result; // rax
  unsigned __int16 v2; // r13
  __int64 v4; // rcx
  unsigned __int16 v5; // dx
  void **v6; // r10
  const char *v7; // r9
  const char *v8; // rax
  __int64 v9; // r10
  const char *v10; // rax
  __int64 v11; // r10
  const char *v12; // rax
  __int64 v13; // r10
  __int64 v14; // r12
  const char *v15; // rax
  __int64 v16; // r10
  const char *v17; // rax
  __int64 v18; // r10
  void *retaddr; // [rsp+38h] [rbp+0h] BYREF

  result = &retaddr;
  v2 = 0;
  if ( !a1 )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    {
      v4 = *((_QWORD *)off_2E128 + 27);
      v5 = 137;
      return (void **)sub_11008(v4, v5, (__int64)&unk_2B3E8);
    }
    return result;
  }
  v6 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
    {
      result = (void **)sub_11008(*((_QWORD *)off_2E128 + 27), 0x8Au, (__int64)&unk_2B3E8);
      v6 = (void **)off_2E128;
    }
    if ( v6 != &off_2E128 )
    {
      if ( (*((_BYTE *)v6 + 236) & 4) != 0 && *((_BYTE *)v6 + 233) >= 4u )
      {
        result = (void **)sub_12374((__int64)v6[27], 0x8Bu, (__int64)&unk_2B3E8, *(_QWORD *)(a1 + 8));
        v6 = (void **)off_2E128;
      }
      if ( v6 != &off_2E128 )
      {
        if ( (*((_BYTE *)v6 + 236) & 4) == 0 || *((_BYTE *)v6 + 233) < 4u )
        {
LABEL_24:
          if ( v6 != &off_2E128 )
          {
            if ( (*((_BYTE *)v6 + 236) & 4) != 0 && *((_BYTE *)v6 + 233) >= 4u )
            {
              result = (void **)sub_14544((__int64)v6[27], 0x8Du, (__int64)&unk_2B3E8, *(_DWORD *)(a1 + 16));
              v6 = (void **)off_2E128;
            }
            if ( v6 != &off_2E128 )
            {
              if ( (*((_BYTE *)v6 + 236) & 4) != 0 && *((_BYTE *)v6 + 233) >= 4u )
              {
                result = (void **)sub_11008((__int64)v6[27], 0x8Eu, (__int64)&unk_2B3E8);
                v6 = (void **)off_2E128;
              }
              if ( v6 != &off_2E128 )
              {
                if ( (*((_BYTE *)v6 + 236) & 4) != 0 && *((_BYTE *)v6 + 233) >= 4u )
                {
                  result = (void **)sub_14544(
                                      (__int64)v6[27],
                                      0x8Fu,
                                      (__int64)&unk_2B3E8,
                                      *(unsigned __int16 *)(a1 + 20));
                  v6 = (void **)off_2E128;
                }
                if ( v6 != &off_2E128 )
                {
                  if ( (*((_BYTE *)v6 + 236) & 4) != 0 && *((_BYTE *)v6 + 233) >= 4u )
                  {
                    result = (void **)sub_14544(
                                        (__int64)v6[27],
                                        0x90u,
                                        (__int64)&unk_2B3E8,
                                        *(unsigned __int16 *)(a1 + 22));
                    v6 = (void **)off_2E128;
                  }
                  if ( v6 != &off_2E128 )
                  {
                    if ( (*((_BYTE *)v6 + 236) & 4) != 0 && *((_BYTE *)v6 + 233) >= 4u )
                    {
                      result = (void **)sub_14544(
                                          (__int64)v6[27],
                                          0x91u,
                                          (__int64)&unk_2B3E8,
                                          *(unsigned __int16 *)(a1 + 28));
                      v6 = (void **)off_2E128;
                    }
                    if ( v6 != &off_2E128 && (*((_BYTE *)v6 + 236) & 4) != 0 && *((_BYTE *)v6 + 233) >= 4u )
                    {
                      v8 = sub_26094(*(_DWORD *)(a1 + 24));
                      result = (void **)sub_14D60(*(_QWORD *)(v9 + 216), 0x92u, (__int64)&unk_2B3E8, v8);
                      v6 = (void **)off_2E128;
                    }
                  }
                }
              }
            }
          }
          goto LABEL_48;
        }
        if ( *(_DWORD *)a1 )
        {
          if ( *(_DWORD *)a1 == 1 )
          {
            v7 = "REQUEST";
            goto LABEL_23;
          }
          if ( *(_DWORD *)a1 == 2 )
          {
            v7 = "RESPONSE";
LABEL_23:
            result = (void **)sub_14D60((__int64)v6[27], 0x8Cu, (__int64)&unk_2B3E8, v7);
            v6 = (void **)off_2E128;
            goto LABEL_24;
          }
        }
        v7 = "TYPE_UNKNOWN";
        goto LABEL_23;
      }
    }
  }
LABEL_48:
  if ( *(_WORD *)(a1 + 22) && v6 != &off_2E128 )
  {
    if ( (*((_BYTE *)v6 + 236) & 4) != 0 && *((_BYTE *)v6 + 233) >= 4u )
    {
      result = (void **)sub_11008((__int64)v6[27], 0x93u, (__int64)&unk_2B3E8);
      v6 = (void **)off_2E128;
    }
    if ( v6 != &off_2E128 )
    {
      if ( (*((_BYTE *)v6 + 236) & 4) != 0 && *((_BYTE *)v6 + 233) >= 4u )
      {
        v10 = sub_25B40(*(_DWORD *)(a1 + 32));
        result = (void **)sub_14D60(*(_QWORD *)(v11 + 216), 0x94u, (__int64)&unk_2B3E8, v10);
        v6 = (void **)off_2E128;
      }
      if ( v6 != &off_2E128 )
      {
        if ( (*((_BYTE *)v6 + 236) & 4) != 0 && *((_BYTE *)v6 + 233) >= 4u )
        {
          v12 = sub_26044(*(_DWORD *)(a1 + 36));
          result = (void **)sub_14D60(*(_QWORD *)(v13 + 216), 0x95u, (__int64)&unk_2B3E8, v12);
          v6 = (void **)off_2E128;
        }
        if ( v6 != &off_2E128 && (*((_BYTE *)v6 + 236) & 4) != 0 && *((_BYTE *)v6 + 233) >= 4u )
        {
          result = (void **)sub_14D60((__int64)v6[27], 0x96u, (__int64)&unk_2B3E8, (const char *)(a1 + 40));
          v6 = (void **)off_2E128;
        }
      }
    }
  }
  if ( *(_WORD *)(a1 + 28) )
  {
    v14 = *(_QWORD *)(a1 + 296) + 12i64;
    do
    {
      if ( v6 != &off_2E128 )
      {
        if ( (*((_BYTE *)v6 + 236) & 4) != 0 && *((_BYTE *)v6 + 233) >= 4u )
        {
          result = (void **)sub_14544((__int64)v6[27], 0x97u, (__int64)&unk_2B3E8, v2);
          v6 = (void **)off_2E128;
        }
        if ( v6 != &off_2E128 )
        {
          if ( (*((_BYTE *)v6 + 236) & 4) != 0 && *((_BYTE *)v6 + 233) >= 4u )
          {
            v15 = sub_25B40(*(_DWORD *)(v14 - 4));
            result = (void **)sub_14D60(*(_QWORD *)(v16 + 216), 0x98u, (__int64)&unk_2B3E8, v15);
            v6 = (void **)off_2E128;
          }
          if ( v6 != &off_2E128 )
          {
            if ( (*((_BYTE *)v6 + 236) & 4) != 0 && *((_BYTE *)v6 + 233) >= 4u )
            {
              v17 = sub_26044(*(_DWORD *)v14);
              result = (void **)sub_14D60(*(_QWORD *)(v18 + 216), 0x99u, (__int64)&unk_2B3E8, v17);
              v6 = (void **)off_2E128;
            }
            if ( v6 != &off_2E128 )
            {
              if ( (*((_BYTE *)v6 + 236) & 4) != 0 && *((_BYTE *)v6 + 233) >= 4u )
              {
                result = (void **)sub_14544((__int64)v6[27], 0x9Au, (__int64)&unk_2B3E8, *(_DWORD *)(v14 + 4));
                v6 = (void **)off_2E128;
              }
              if ( v6 != &off_2E128 && (*((_BYTE *)v6 + 236) & 4) != 0 && *((_BYTE *)v6 + 233) >= 4u )
              {
                result = (void **)sub_14544((__int64)v6[27], 0x9Bu, (__int64)&unk_2B3E8, *(unsigned __int16 *)(v14 + 8));
                v6 = (void **)off_2E128;
              }
            }
          }
        }
      }
      ++v2;
      v14 += 40i64;
    }
    while ( v2 < *(_WORD *)(a1 + 28) );
  }
  if ( v6 != &off_2E128 && (*((_BYTE *)v6 + 236) & 4) != 0 && *((_BYTE *)v6 + 233) >= 4u )
  {
    v4 = (__int64)v6[27];
    v5 = 156;
    return (void **)sub_11008(v4, v5, (__int64)&unk_2B3E8);
  }
  return result;
}
// 1899C: variable 'v9' is possibly undefined
// 18A1E: variable 'v11' is possibly undefined
// 18A5B: variable 'v13' is possibly undefined
// 18B2A: variable 'v16' is possibly undefined
// 18B6C: variable 'v18' is possibly undefined
// 2E128: using guessed type void *off_2E128;

//----- (0000000000018C5C) ----------------------------------------------------
__int64 __fastcall sub_18C5C(__int64 a1, __int64 a2)
{
  unsigned int v4; // esi
  void **v5; // r10
  int v6; // eax
  __int64 v7; // rax
  int v8; // eax
  const char *v9; // rax
  __int64 v10; // r10
  const char *v11; // r9
  int v13; // [rsp+30h] [rbp-158h] BYREF
  __int64 Dst[37]; // [rsp+34h] [rbp-154h] BYREF

  v4 = 0;
  v13 = 0;
  memset(Dst, 0, 0x11Dui64);
  v5 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 59, 0xAu)
    && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x9Du, (__int64)&unk_2B3E8);
    v5 = (void **)off_2E128;
  }
  if ( !a1 || !a2 )
  {
    if ( v5 != &off_2E128 && _bittest((const signed __int32 *)v5 + 59, 0xAu) && *((_BYTE *)v5 + 233) >= 2u )
    {
      sub_14BA4((__int64)v5[27], 0x9Eu, (__int64)&unk_2B3E8, a1, a2);
      v5 = (void **)off_2E128;
    }
    v4 = 4;
    goto LABEL_38;
  }
  if ( v5 != &off_2E128 && _bittest((const signed __int32 *)v5 + 59, 0xAu) && *((_BYTE *)v5 + 233) >= 4u )
    sub_14DC8((__int64)v5[27], 159i64, (__int64)&unk_2B3E8, (const char *)(a2 + 40));
  v6 = sub_20AD8(0x202900Au);
  if ( !v6 || (*(_DWORD *)a2 != 1 || v6 != 3 && v6 != 1) && (*(_DWORD *)a2 != 2 || v6 != 3 && v6 != 2) )
  {
    v5 = (void **)off_2E128;
    if ( off_2E128 == &off_2E128 )
      return v4;
    if ( !_bittest((const signed __int32 *)off_2E128 + 59, 0xAu) || *((_BYTE *)off_2E128 + 233) < 4u )
      goto LABEL_38;
    v9 = sub_26134(v6);
    sub_15018(*(_QWORD *)(v10 + 216), 0xA0u, (__int64)&unk_2B3E8, v11, v9);
    goto LABEL_32;
  }
  if ( !*(_BYTE *)(a1 + 96) )
  {
    v7 = *(_QWORD *)(a1 + 80);
    v13 = *(_DWORD *)a2;
    Dst[0] = v7;
    Dst[1] = *(_QWORD *)(a1 + 88);
    *(_DWORD *)((char *)&Dst[3] + 1) = *(_DWORD *)(a2 + 32);
    *(_WORD *)((char *)&Dst[2] + 1) = *(_WORD *)(a2 + 22);
    LODWORD(v7) = *(_DWORD *)(a2 + 24);
    LOBYTE(Dst[2]) = 1;
    *(_DWORD *)((char *)&Dst[2] + 3) = v7;
    *(_WORD *)((char *)&Dst[2] + 7) = *(_WORD *)(a2 + 28);
    sub_29D88((char *)&Dst[3] + 5, 0x100ui64, (const void *)(a2 + 40), 0x100ui64);
    v8 = sub_13CDC(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), 40039, (__int64)&v13, 289);
    v4 = v8;
    if ( v8 )
    {
      v5 = (void **)off_2E128;
      if ( off_2E128 == &off_2E128 )
        return v4;
      if ( !_bittest((const signed __int32 *)off_2E128 + 59, 0xAu) || *((_BYTE *)off_2E128 + 233) < 2u )
        goto LABEL_38;
      sub_14544(*((_QWORD *)off_2E128 + 27), 0xA2u, (__int64)&unk_2B3E8, v8);
    }
    goto LABEL_32;
  }
  v5 = (void **)off_2E128;
  if ( off_2E128 == &off_2E128 )
    return v4;
  if ( _bittest((const signed __int32 *)off_2E128 + 59, 0xAu) && *((_BYTE *)off_2E128 + 233) >= 4u )
  {
    sub_12374(*((_QWORD *)off_2E128 + 27), 0xA1u, (__int64)&unk_2B3E8, *(_QWORD *)(a1 + 56));
LABEL_32:
    v5 = (void **)off_2E128;
  }
LABEL_38:
  if ( v5 != &off_2E128 && _bittest((const signed __int32 *)v5 + 59, 0xAu) && *((_BYTE *)v5 + 233) >= 5u )
    sub_11008((__int64)v5[27], 0xA3u, (__int64)&unk_2B3E8);
  return v4;
}
// 18EDE: variable 'v10' is possibly undefined
// 18EF2: variable 'v11' is possibly undefined
// 2E128: using guessed type void *off_2E128;

//----- (0000000000018FA0) ----------------------------------------------------
__int64 __fastcall sub_18FA0(__int64 *a1)
{
  void **v2; // r9
  __int64 result; // rax
  __int64 v4; // rsi
  int v5; // eax
  unsigned int v6; // edi
  __int64 v7; // [rsp+30h] [rbp-188h] BYREF
  __int64 v8; // [rsp+38h] [rbp-180h] BYREF
  size_t pcchDestLength; // [rsp+40h] [rbp-178h] BYREF
  int v10; // [rsp+48h] [rbp-170h] BYREF
  int Dst[4]; // [rsp+4Ch] [rbp-16Ch] BYREF
  char pszDest[304]; // [rsp+60h] [rbp-158h] BYREF

  v7 = 0i64;
  v8 = 0i64;
  v10 = 0;
  memset(Dst, 0, sizeof(Dst));
  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0xA4u, (__int64)&unk_2B3E8);
    v2 = (void **)off_2E128;
  }
  if ( strlen((const char *)(a1[46] + 40)) )
  {
    sub_1342C(&v7, 0i64, a1[7], a1[8]);
    sub_13864(v7, 2, 0i64, 1i64, 4, 0);
    sub_13864(v7, 4, 0i64, 1i64, 4, 0);
    if ( (int)unknown_libname_2(pszDest, 10i64, 0x7FFFFFFFi64) >= 0 )
      RtlStringCopyWorkerA(pszDest, 0xAui64, 0i64, "https://", 0x7FFFFFFEui64);
    v4 = a1[46];
    if ( RtlStringValidateDestAndLengthA(pszDest, 0x12Bui64, &pcchDestLength, 0x7FFFFFFFui64) >= 0 )
      RtlStringCopyWorkerA(
        &pszDest[pcchDestLength],
        299 - pcchDestLength,
        0i64,
        (STRSAFE_PCNZCH)(v4 + 40),
        0x7FFFFFFFui64);
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
    {
      strlen(pszDest);
      sub_110CC(*((_QWORD *)off_2E128 + 27), 0xA6u, (__int64)&unk_2B3E8, pszDest);
    }
    sub_13864(v7, 5, 0i64, (__int64)pszDest, strlen(pszDest), dword_2E2FC);
    sub_13864(v7, 3, 0i64, a1[46] + 40, strlen((const char *)(a1[46] + 40)), dword_2E2FC);
    Dst[0] = 1;
    Dst[1] = 6;
    v10 = 6;
    LOBYTE(Dst[2]) = 0;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
      sub_148D8(*((_QWORD *)off_2E128 + 27), 0xA7u, (__int64)&unk_2B3E8, 6);
    sub_13864(v7, 7, 0i64, (__int64)&v10, 20, dword_2E2FC);
    v5 = sub_13650(a1[7], a1[8], v7, (__int64)&v8);
    v6 = v5;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
      sub_14544(*((_QWORD *)off_2E128 + 27), 0xA8u, (__int64)&unk_2B3E8, v5);
    result = v6;
  }
  else
  {
    if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 236) & 4) != 0 && *((_BYTE *)v2 + 233) >= 2u )
      sub_11008((__int64)v2[27], 0xA5u, (__int64)&unk_2B3E8);
    result = 4i64;
  }
  return result;
}
// 29E8C: using guessed type __int64 __fastcall unknown_libname_2(_QWORD, _QWORD, _QWORD);
// 2E128: using guessed type void *off_2E128;
// 2E2FC: using guessed type int dword_2E2FC;

//----- (0000000000019334) ----------------------------------------------------
char __fastcall sub_19334(char *Str)
{
  char v1; // bl
  const char *i; // rdi

  v1 = 0;
  if ( !_InterlockedCompareExchange(&dword_2E260, 1, 1) )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
      sub_14D60(*((_QWORD *)off_2E128 + 27), 0xA9u, (__int64)&unk_2B3E8, Str);
    sub_1DF10(&FastMutex);
    for ( i = (const char *)P; i != (const char *)&P; i = *(const char **)i )
    {
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
        sub_14D60(*((_QWORD *)off_2E128 + 27), 0xAAu, (__int64)&unk_2B3E8, *((const char **)i + 2));
      if ( strstr(Str, *((const char **)i + 2)) )
      {
        if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x20) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
          sub_14D60(*((_QWORD *)off_2E128 + 27), 0xABu, (__int64)&unk_2B3E8, Str);
        v1 = 1;
        break;
      }
    }
    sub_1DFDC(&FastMutex);
  }
  return v1;
}
// 2E128: using guessed type void *off_2E128;
// 2E260: using guessed type int dword_2E260;

//----- (0000000000019494) ----------------------------------------------------
char __fastcall sub_19494(char *Str)
{
  char v1; // bl
  const char *i; // rdi

  v1 = 0;
  if ( !_InterlockedCompareExchange(&dword_2E2F0, 1, 1) )
  {
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 59, 8u)
      && *((_BYTE *)off_2E128 + 233) >= 5u )
    {
      sub_14D60(*((_QWORD *)off_2E128 + 27), 0xACu, (__int64)&unk_2B3E8, Str);
    }
    sub_1DF10(&stru_2E2A8);
    for ( i = (const char *)qword_2E290; i != (const char *)&qword_2E290; i = *(const char **)i )
    {
      if ( off_2E128 != &off_2E128
        && _bittest((const signed __int32 *)off_2E128 + 59, 8u)
        && *((_BYTE *)off_2E128 + 233) >= 4u )
      {
        sub_14D60(*((_QWORD *)off_2E128 + 27), 0xADu, (__int64)&unk_2B3E8, *((const char **)i + 2));
      }
      if ( strstr(Str, *((const char **)i + 2)) )
      {
        if ( off_2E128 != &off_2E128
          && _bittest((const signed __int32 *)off_2E128 + 59, 8u)
          && *((_BYTE *)off_2E128 + 233) >= 4u )
        {
          sub_15018(*((_QWORD *)off_2E128 + 27), 0xAEu, (__int64)&unk_2B3E8, Str, *((const char **)i + 2));
        }
        v1 = 1;
        break;
      }
    }
    sub_1DFDC(&stru_2E2A8);
  }
  return v1;
}
// 2E128: using guessed type void *off_2E128;
// 2E2F0: using guessed type int dword_2E2F0;

//----- (0000000000019600) ----------------------------------------------------
__int64 __fastcall sub_19600(unsigned __int64 a1, __int64 a2, __int64 a3)
{
  unsigned int v6; // esi
  char v7; // r12
  void **v8; // rcx
  __int64 v9; // rax
  unsigned __int16 v10; // dx
  __int64 v11; // rax
  bool v12; // zf
  __m128i v13; // xmm0
  int v14; // eax
  unsigned int v16; // [rsp+30h] [rbp-1E8h] BYREF
  ULONG_PTR BugCheckParameter1; // [rsp+38h] [rbp-1E0h] BYREF
  char v18; // [rsp+40h] [rbp-1D8h] BYREF
  _BYTE Dst[414]; // [rsp+41h] [rbp-1D7h] BYREF

  BugCheckParameter1 = 0i64;
  v6 = 0;
  v16 = 0;
  v18 = 0;
  memset(Dst, 0, sizeof(Dst));
  v7 = 0;
  v8 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x10) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0xAFu, (__int64)&unk_2B3E8);
    v8 = (void **)off_2E128;
  }
  if ( !a2 )
  {
    v9 = sub_1ACDC(a1, &BugCheckParameter1, &v16);
    v6 = v16;
    a2 = v9;
    if ( v16 )
    {
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x10) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
        sub_14580(*((_QWORD *)off_2E128 + 27), 0xB0u, (__int64)&unk_2B3E8, a1, v16);
      goto LABEL_39;
    }
    v8 = (void **)off_2E128;
  }
  if ( *(_BYTE *)(a2 + 96) )
  {
    if ( v8 == &off_2E128 || (*((_BYTE *)v8 + 236) & 0x10) == 0 || *((_BYTE *)v8 + 233) < 4u )
      goto LABEL_39;
    v10 = 177;
    goto LABEL_38;
  }
  sub_1DF10((PFAST_MUTEX)a2);
  if ( *(_QWORD *)(a2 + 400) || *(_DWORD *)(a2 + 384) )
  {
    *(_QWORD *)Dst = *(_QWORD *)(a2 + 80);
    v11 = *(_QWORD *)(a2 + 88);
    v7 = 1;
    v18 = 1;
    *(_QWORD *)&Dst[8] = v11;
    sub_29D00(&Dst[38], 256i64, (char *)(a2 + 98));
    *(_QWORD *)&Dst[298] = *(_QWORD *)(a2 + 392);
    *(_QWORD *)&Dst[314] = *(_QWORD *)(a2 + 408);
    *(_QWORD *)&Dst[322] = *(_QWORD *)(a2 + 416);
    *(_QWORD *)&Dst[306] = *(_QWORD *)(a2 + 400);
    *(_DWORD *)&Dst[294] = *(_DWORD *)(a2 + 384);
    *(_DWORD *)&Dst[338] = *(_DWORD *)(a2 + 424);
    *(_DWORD *)&Dst[342] = *(_DWORD *)(a2 + 428);
    *(_DWORD *)&Dst[350] = *(_DWORD *)(a2 + 432);
    *(_QWORD *)&Dst[358] = *(_QWORD *)(a2 + 448);
    *(_QWORD *)&Dst[374] = *(_QWORD *)(a2 + 464);
    *(_QWORD *)&Dst[382] = *(_QWORD *)(a2 + 472);
    *(_QWORD *)&Dst[366] = *(_QWORD *)(a2 + 456);
    *(_DWORD *)&Dst[354] = *(_DWORD *)(a2 + 440);
    *(_DWORD *)&Dst[398] = *(_DWORD *)(a2 + 480);
    *(_DWORD *)&Dst[402] = *(_DWORD *)(a2 + 484);
    *(_DWORD *)&Dst[410] = *(_DWORD *)(a2 + 488);
    memset((void *)(a2 + 384), 0, 0x38ui64);
    memset((void *)(a2 + 440), 0, 0x38ui64);
    if ( a3 )
    {
      v12 = *(_DWORD *)(a3 + 36) == 2;
      *(_DWORD *)&Dst[32] = *(_DWORD *)(a3 + 40);
      if ( v12 )
        v13 = _mm_loadu_si128((const __m128i *)(a3 + 20));
      else
        v13 = _mm_loadu_si128((const __m128i *)(a3 + 4));
      *(__m128i *)&Dst[16] = v13;
    }
  }
  sub_1DFDC((PFAST_MUTEX)a2);
  if ( !v7 )
  {
    v8 = (void **)off_2E128;
    if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 236) & 0x10) == 0 || *((_BYTE *)off_2E128 + 233) < 4u )
      goto LABEL_39;
    v10 = 180;
LABEL_38:
    sub_12374((__int64)v8[27], v10, (__int64)&unk_2B3E8, *(_QWORD *)(a2 + 56));
    goto LABEL_39;
  }
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x10) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
    sub_12374(*((_QWORD *)off_2E128 + 27), 0xB2u, (__int64)&unk_2B3E8, *(_QWORD *)(a2 + 56));
  v14 = sub_13CDC(*(_QWORD *)(a2 + 56), *(_QWORD *)(a2 + 64), 40044, (__int64)&v18, 415);
  v6 = v14;
  if ( v14 && off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x10) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
    sub_14544(*((_QWORD *)off_2E128 + 27), 0xB3u, (__int64)&unk_2B3E8, v14);
LABEL_39:
  sub_1AF84(BugCheckParameter1);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x10) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0xB5u, (__int64)&unk_2B3E8);
  return v6;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000019A30) ----------------------------------------------------
_DWORD *__fastcall sub_19A30(__int64 a1, unsigned int a2)
{
  size_t v3; // rdi
  _DWORD *v4; // rax
  _DWORD *v5; // rbx
  _QWORD *v6; // rcx
  unsigned __int16 v7; // dx
  ULONG v8; // er8
  PVOID v9; // rax
  unsigned __int16 v10; // di
  PVOID v11; // rcx

  v3 = a2;
  v4 = sub_1D664((__int64)qword_2E1F0);
  v5 = v4;
  if ( v4 )
  {
    memset(v4, 0, 0x130ui64);
    v8 = 1903324740;
    if ( (((unsigned __int8)HIBYTE(*(_WORD *)(a1 + 2)) | (unsigned __int16)((unsigned __int8)*(_WORD *)(a1 + 2) << 8)) & 0x8000) == 0x8000 )
      v8 = 1936879172;
    v9 = sub_1D254(1, v3, v8);
    *((_QWORD *)v5 + 1) = v9;
    memset(v9, 0, v3);
    v10 = _byteswap_ushort(*(_WORD *)(a1 + 6));
    if ( v10 )
    {
      v11 = sub_1D254(1, 40 * (unsigned int)v10, 0x616D6E44u);
      *((_QWORD *)v5 + 37) = v11;
      if ( v11 )
      {
        memset(v11, 0, 40i64 * v10);
        return v5;
      }
      v6 = off_2E128;
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
      {
        v7 = 184;
        goto LABEL_6;
      }
    }
  }
  else
  {
    v6 = off_2E128;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
    {
      v7 = 182;
LABEL_6:
      sub_11008(v6[27], v7, (__int64)&unk_2B3E8);
      return v5;
    }
  }
  return v5;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000019BCC) ----------------------------------------------------
__int64 __fastcall sub_19BCC(__int64 a1)
{
  _WORD *v2; // rcx
  ULONG v3; // edx
  void *v4; // rcx

  if ( a1 )
  {
    v2 = *(_WORD **)(a1 + 8);
    if ( v2 )
    {
      v3 = 1903324740;
      if ( (((unsigned __int8)HIBYTE(v2[1]) | (unsigned __int16)((unsigned __int8)v2[1] << 8)) & 0x8000) == 0x8000 )
        v3 = 1936879172;
      sub_1D2D8(v2, v3);
      *(_QWORD *)(a1 + 8) = 0i64;
    }
    v4 = *(void **)(a1 + 296);
    if ( v4 )
    {
      sub_1D2D8(v4, 0x616D6E44u);
      *(_QWORD *)(a1 + 296) = 0i64;
    }
    sub_1D6CC((__int64)qword_2E1F0, a1);
  }
  return 0i64;
}

//----- (0000000000019C84) ----------------------------------------------------
__int64 sub_19C84()
{
  __int64 result; // rax

  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0xB9u, (__int64)&unk_2B3E8);
  qword_2E1F0 = sub_1D4C0(1, 0x130u, 0x6D736E44u);
  if ( qword_2E1F0 )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0xBBu, (__int64)&unk_2B3E8);
    result = 0i64;
  }
  else
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0xBAu, (__int64)&unk_2B3E8);
    result = 3i64;
  }
  return result;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000019D78) ----------------------------------------------------
__int64 __fastcall sub_19D78(__int64 a1, __int64 a2, __int64 a3, int a4, const char *a5)
{
  int v7; // [rsp+88h] [rbp+20h] BYREF

  v7 = a4;
  if ( a5 )
    strlen(a5);
  return qword_2E198(a1, 43i64, &unk_2B3D8, 67i64, &v7);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000019E18) ----------------------------------------------------
__int64 sub_19E18(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  __int64 v5; // [rsp+78h] [rbp+20h] BYREF
  va_list va; // [rsp+78h] [rbp+20h]
  const char *v7; // [rsp+80h] [rbp+28h]
  va_list va1; // [rsp+88h] [rbp+30h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, const char *);
  if ( v7 )
    strlen(v7);
  return qword_2E198(a1, 43i64, &unk_2B3D8, a2, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000019EA0) ----------------------------------------------------
__int64 __fastcall sub_19EA0(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+A8h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B3D8, 58i64, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000019F24) ----------------------------------------------------
__int64 __fastcall sub_19F24(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, char a5, const char *a6)
{
  int v8; // [rsp+88h] [rbp+20h] BYREF

  v8 = a4;
  if ( a6 )
    strlen(a6);
  return qword_2E198(a1, 43i64, &unk_2B3D8, a2, &v8);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000019FC0) ----------------------------------------------------
__int64 __fastcall sub_19FC0(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+98h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B3D8, 61i64, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001A030) ----------------------------------------------------
__int64 sub_1A030(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2E198(a1, 43i64, &unk_2B3D8, 54i64, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001A078) ----------------------------------------------------
__int64 sub_1A078(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+98h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2E198(a1, 43i64, &unk_2B3D8, a2, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001A0E4) ----------------------------------------------------
__int64 sub_1A0E4(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+88h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2E198(a1, 43i64, &unk_2B3D8, a2, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001A140) ----------------------------------------------------
__int64 sub_1A140(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 v5; // [rsp+B8h] [rbp+20h] BYREF
  va_list va; // [rsp+B8h] [rbp+20h]
  const char *v7; // [rsp+C0h] [rbp+28h]
  __int64 v8; // [rsp+C8h] [rbp+30h]
  const char *v9; // [rsp+D0h] [rbp+38h]
  __int64 v10; // [rsp+D8h] [rbp+40h]
  const char *v11; // [rsp+E0h] [rbp+48h]
  va_list va1; // [rsp+E8h] [rbp+50h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, const char *);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, const char *);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, const char *);
  if ( v11 )
    strlen(v11);
  if ( v9 )
    strlen(v9);
  if ( v7 )
    strlen(v7);
  return qword_2E198(a1, 43i64, &unk_2B3D8, 53i64, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001A298) ----------------------------------------------------
__int64 sub_1A298(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 v5; // [rsp+C8h] [rbp+20h] BYREF
  va_list va; // [rsp+C8h] [rbp+20h]
  const char *v7; // [rsp+D0h] [rbp+28h]
  __int64 v8; // [rsp+D8h] [rbp+30h]
  const char *v9; // [rsp+E0h] [rbp+38h]
  __int64 v10; // [rsp+E8h] [rbp+40h]
  const char *v11; // [rsp+F0h] [rbp+48h]
  va_list va1; // [rsp+F8h] [rbp+50h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, const char *);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, const char *);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, const char *);
  if ( v11 )
    strlen(v11);
  if ( v9 )
    strlen(v9);
  if ( v7 )
    strlen(v7);
  return qword_2E198(a1, 43i64, &unk_2B3D8, 52i64, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001A400) ----------------------------------------------------
__int64 __fastcall sub_1A400(__int64 a1, __int64 a2, __int64 a3, const char *a4, char a5, char a6, const char *a7)
{
  const char *v8; // rcx

  if ( a7 )
    strlen(a7);
  if ( a4 )
    strlen(a4);
  v8 = "NULL";
  if ( a4 )
    v8 = a4;
  return qword_2E198(a1, 43i64, &unk_2B3D8, 55i64, v8);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001A4CC) ----------------------------------------------------
__int64 __fastcall sub_1A4CC(__int64 a1, __int64 a2, __int64 a3, const char *a4, const char *a5, const char *a6)
{
  const char *v8; // rdx

  if ( a6 )
    strlen(a6);
  if ( a5 )
    strlen(a5);
  if ( a4 )
    strlen(a4);
  v8 = "NULL";
  if ( a4 )
    v8 = a4;
  return qword_2E198(a1, 43i64, &unk_2B3D8, 65i64, v8);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001A5CC) ----------------------------------------------------
__int64 sub_1A5CC()
{
  __int64 v0; // rcx
  __int64 result; // rax
  int v2; // [rsp+70h] [rbp+8h] BYREF

  v2 = 0;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0xAu, (__int64)&unk_2B3D8);
  qword_2E1F8 = sub_1D4C0(2, 0x1F0u, 0x73736E44u);
  if ( qword_2E1F8 )
  {
    LOBYTE(v0) = 1;
    qword_30F88 = sub_26CD0(v0, 0i64, 1i64, 1936944708i64, 0, 2, 0, 0, (int)sub_1A9A0, 0, &v2);
    if ( v2 )
    {
      sub_1D544(qword_2E1F8);
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
        sub_14544(*((_QWORD *)off_2E128 + 27), 0xCu, (__int64)&unk_2B3D8, v2);
      result = 1i64;
    }
    else
    {
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
        sub_11008(*((_QWORD *)off_2E128 + 27), 0xDu, (__int64)&unk_2B3D8);
      result = 0i64;
    }
  }
  else
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0xBu, (__int64)&unk_2B3D8);
    result = 3i64;
  }
  return result;
}
// 1A6C5: variable 'v0' is possibly undefined
// 2E128: using guessed type void *off_2E128;

//----- (000000000001A774) ----------------------------------------------------
__int64 sub_1A774()
{
  int v0; // eax
  __int64 result; // rax

  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0xEu, (__int64)&unk_2B3D8);
  v0 = sub_26F58((__int64)qword_30F88);
  if ( v0 )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
      sub_14544(*((_QWORD *)off_2E128 + 27), 0xFu, (__int64)&unk_2B3D8, v0);
    result = 1i64;
  }
  else
  {
    sub_1D544(qword_2E1F8);
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0x10u, (__int64)&unk_2B3D8);
    result = 0i64;
  }
  return result;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001A864) ----------------------------------------------------
__int64 __fastcall sub_1A864(__int64 a1, __int64 a2)
{
  _DWORD *v2; // rax
  __int64 v3; // rbx
  __int64 result; // rax
  __int64 v5; // r11
  __int64 v6; // rcx

  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x14u, (__int64)&unk_2B3D8);
  v2 = sub_1D664((__int64)qword_2E1F8);
  v3 = (__int64)v2;
  if ( v2 )
  {
    memset(v2, 0, 0x1F0ui64);
    sub_1DE30(v3);
    v5 = a2;
    if ( a1 )
      v5 = a1;
    *(_QWORD *)(v3 + 56) = v5;
    v6 = a1;
    if ( a2 )
      v6 = a2;
    *(_QWORD *)(v3 + 64) = v6;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0x16u, (__int64)&unk_2B3D8);
    result = v3;
  }
  else
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0x15u, (__int64)&unk_2B3D8);
    result = 0i64;
  }
  return result;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001A9A0) ----------------------------------------------------
__int64 __fastcall sub_1A9A0(PFAST_MUTEX FastMutex)
{
  void **v2; // rcx

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x17u, (__int64)&unk_2B3D8);
    v2 = (void **)off_2E128;
  }
  if ( FastMutex )
  {
    if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 236) & 0x40) != 0 && *((_BYTE *)v2 + 233) >= 5u )
      sub_12374((__int64)v2[27], 0x18u, (__int64)&unk_2B3D8, *(_QWORD *)&FastMutex[1].Count);
    sub_1B8B0(FastMutex);
    sub_1D6CC((__int64)qword_2E1F8, (__int64)FastMutex);
    v2 = (void **)off_2E128;
  }
  if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 236) & 0x40) != 0 && *((_BYTE *)v2 + 233) >= 5u )
    sub_11008((__int64)v2[27], 0x19u, (__int64)&unk_2B3D8);
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001AA94) ----------------------------------------------------
__int64 __fastcall sub_1AA94(__int64 *a1, int *a2, ULONG_PTR **a3, _DWORD *a4)
{
  void **v8; // r10
  int v9; // ecx
  int v10; // ecx
  const char *v11; // rax
  __int64 v13; // rax
  __int64 v14; // rsi
  char v15; // al
  unsigned __int64 v16; // rdx
  PVOID v17; // rcx
  int v18; // eax
  void **v19; // rcx

  v8 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x1Au, (__int64)&unk_2B3D8);
    v8 = (void **)off_2E128;
  }
  v9 = *a2;
  *a4 = 0;
  if ( v9 != 1 )
  {
    if ( v8 == &off_2E128 || (*((_BYTE *)v8 + 236) & 0x40) == 0 || *((_BYTE *)v8 + 233) < 3u )
      goto LABEL_16;
    if ( v9 )
    {
      v10 = v9 - 1;
      if ( !v10 )
      {
        v11 = "REQUEST";
        goto LABEL_15;
      }
      if ( v10 == 1 )
      {
        v11 = "RESPONSE";
LABEL_15:
        sub_19E18((__int64)v8[27], 0x1Bu, (__int64)&unk_2B3D8, *a1, v11);
LABEL_16:
        *a4 = 6;
        return 0i64;
      }
    }
    v11 = "TYPE_UNKNOWN";
    goto LABEL_15;
  }
  v13 = sub_1A864(*a1, a1[1]);
  v14 = v13;
  if ( !v13 )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
      sub_12374(*((_QWORD *)off_2E128 + 27), 0x1Cu, (__int64)&unk_2B3D8, *a1);
    *a4 = 3;
    return 0i64;
  }
  *(_QWORD *)(v13 + 80) = *(__int64 *)((char *)a1 + 33);
  *(_QWORD *)(v13 + 88) = *(__int64 *)((char *)a1 + 41);
  *(_DWORD *)(v13 + 72) = (*((_DWORD *)a1 + 7) != 0) + 1;
  v15 = sub_1BFB4(*(_QWORD *)(v13 + 80));
  v16 = *(_QWORD *)(v14 + 56);
  v17 = qword_30F88;
  *(_BYTE *)(v14 + 96) = v15;
  v18 = sub_27D14((__int64)v17, v16, v14, a3);
  if ( v18 )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
      sub_1FF64(*((_QWORD *)off_2E128 + 27), 0x1Du, (__int64)&unk_2B3D8, *a1, v18);
    sub_1A9A0((PFAST_MUTEX)v14);
    *a4 = 13;
    return 0i64;
  }
  v19 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
    {
      sub_12374(*((_QWORD *)off_2E128 + 27), 0x1Eu, (__int64)&unk_2B3D8, *a1);
      v19 = (void **)off_2E128;
    }
    if ( v19 != &off_2E128 && (*((_BYTE *)v19 + 236) & 0x40) != 0 && *((_BYTE *)v19 + 233) >= 5u )
      sub_11008((__int64)v19[27], 0x1Fu, (__int64)&unk_2B3D8);
  }
  return v14;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001ACDC) ----------------------------------------------------
__int64 __fastcall sub_1ACDC(unsigned __int64 a1, _QWORD *a2, _DWORD *a3)
{
  __int64 v5; // rbx
  void **v6; // rcx
  unsigned __int64 v8; // [rsp+30h] [rbp+8h]
  int v9; // [rsp+40h] [rbp+18h] BYREF

  v8 = a1;
  v9 = 0;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x20u, (__int64)&unk_2B3D8);
    a1 = v8;
  }
  *a3 = 0;
  v5 = sub_281DC((__int64)qword_30F88, a1, a2, &v9);
  if ( v9 )
  {
    v6 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
    {
      sub_12374(*((_QWORD *)off_2E128 + 27), 0x22u, (__int64)&unk_2B3D8, v8);
      v6 = (void **)off_2E128;
    }
    *a3 = 5;
    v5 = 0i64;
  }
  else
  {
    v6 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
    {
      sub_12374(*((_QWORD *)off_2E128 + 27), 0x21u, (__int64)&unk_2B3D8, v8);
      v6 = (void **)off_2E128;
    }
    *a3 = 0;
  }
  if ( v6 != &off_2E128 && (*((_BYTE *)v6 + 236) & 0x40) != 0 && *((_BYTE *)v6 + 233) >= 5u )
    sub_11008((__int64)v6[27], 0x23u, (__int64)&unk_2B3D8);
  return v5;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001AE3C) ----------------------------------------------------
__int64 __fastcall sub_1AE3C(unsigned __int64 a1, __int64 a2, __int64 a3)
{
  unsigned int v3; // ebx
  void **v4; // rcx
  unsigned __int64 v6; // [rsp+40h] [rbp+8h]
  int v7; // [rsp+48h] [rbp+10h] BYREF

  v6 = a1;
  v3 = 0;
  v7 = 0;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x24u, (__int64)&unk_2B3D8);
    a1 = v6;
  }
  LOBYTE(a3) = 1;
  sub_27F50((__int64)qword_30F88, a1, a3, &v7);
  if ( v7 )
  {
    v4 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
    {
      sub_1FF64(*((_QWORD *)off_2E128 + 27), 0x25u, (__int64)&unk_2B3D8, v6, v7);
      v4 = (void **)off_2E128;
    }
    v3 = 1;
  }
  else
  {
    v4 = (void **)off_2E128;
    if ( off_2E128 == &off_2E128 )
      return v3;
    if ( (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
    {
      sub_12374(*((_QWORD *)off_2E128 + 27), 0x26u, (__int64)&unk_2B3D8, v6);
      v4 = (void **)off_2E128;
    }
  }
  if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 236) & 0x40) != 0 && *((_BYTE *)v4 + 233) >= 5u )
    sub_11008((__int64)v4[27], 0x27u, (__int64)&unk_2B3D8);
  return v3;
}
// 1AEA3: variable 'a3' is possibly undefined
// 2E128: using guessed type void *off_2E128;

//----- (000000000001AF84) ----------------------------------------------------
__int64 __fastcall sub_1AF84(ULONG_PTR BugCheckParameter1)
{
  void **v2; // rcx

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x28u, (__int64)&unk_2B3D8);
    v2 = (void **)off_2E128;
  }
  if ( BugCheckParameter1 )
  {
    sub_28EA8((ULONG_PTR)qword_30F88, BugCheckParameter1);
    v2 = (void **)off_2E128;
  }
  if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 236) & 0x40) != 0 && *((_BYTE *)v2 + 233) >= 5u )
    sub_11008((__int64)v2[27], 0x29u, (__int64)&unk_2B3D8);
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001B038) ----------------------------------------------------
__int64 __fastcall sub_1B038(PFAST_MUTEX FastMutex, int *a2)
{
  int v3; // er14
  unsigned int v4; // er13
  const char *v6; // r12
  __int64 v7; // rax
  __int64 v8; // xmm6_8
  void **v9; // rcx
  __int64 v10; // xmm6_8
  unsigned __int16 v11; // bp
  int *v12; // rdi
  __int64 v13; // xmm6_8
  __int64 v14; // xmm7_8
  unsigned __int64 v15; // kr08_8
  __int64 v16; // rdi
  double v17; // xmm6_8
  int v18; // er15
  _BYTE *v19; // r12
  void **v20; // rcx
  unsigned __int16 **v21; // r15
  ULONG *v22; // rax
  KEVENT *v23; // rdi
  unsigned __int16 v24; // r12
  __int64 v25; // xmm6_8
  __int64 v26; // xmm7_8
  int v27; // er14
  unsigned __int16 v28; // dx
  int v29; // eax
  _LIST_ENTRY *v30; // rcx
  int v31; // er9
  _LIST_ENTRY **v32; // rcx
  const char *v33; // r11
  _LIST_ENTRY *v34; // rax
  int v35; // edi
  _LIST_ENTRY **v36; // rax
  const char *v37; // r11
  __int64 v39; // [rsp+28h] [rbp-80h]
  unsigned __int16 v40; // [rsp+B0h] [rbp+8h] BYREF
  double v41; // [rsp+B8h] [rbp+10h] BYREF

  v3 = 0;
  v4 = 0;
  sub_1DF10(FastMutex);
  v6 = (const char *)(a2 + 10);
  sub_29D00((_BYTE *)&FastMutex[1].Event.Header.WaitListHead.Blink + 2, 256i64, (char *)a2 + 40);
  v7 = (unsigned int)a2[4];
  if ( *a2 == 1 )
  {
    ++FastMutex[6].OldIrql;
    FastMutex[7].Owner = (char *)FastMutex[7].Owner + v7;
    v8 = *(_QWORD *)&FastMutex[7].Count;
    sub_262B4((double)a2[4], FastMutex[6].OldIrql, (double *)&FastMutex[7].Count);
    if ( sub_1861C(a2[8]) )
    {
      if ( ++HIDWORD(FastMutex[7].Event.Header.WaitListHead.Flink) == 1 )
        LODWORD(FastMutex[7].Event.Header.WaitListHead.Blink) = a2[8];
    }
    else
    {
      ++LODWORD(FastMutex[7].Event.Header.WaitListHead.Flink);
    }
    v9 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    {
      sub_1A078(
        *((_QWORD *)off_2E128 + 27),
        0x2Au,
        (__int64)&unk_2B3D8,
        *(_QWORD *)&FastMutex[1].Count,
        v8,
        a2[4],
        *(_QWORD *)&FastMutex[7].Count);
      v9 = (void **)off_2E128;
    }
  }
  else
  {
    ++FastMutex[7].OldIrql;
    FastMutex[8].Owner = (char *)FastMutex[8].Owner + v7;
    v10 = *(_QWORD *)&FastMutex[8].Count;
    *(&FastMutex[7].OldIrql + 1) += *((unsigned __int16 *)a2 + 14);
    sub_262B4((double)a2[4], FastMutex[7].OldIrql, (double *)&FastMutex[8].Count);
    v11 = 0;
    if ( *((_WORD *)a2 + 14) )
    {
      v12 = (int *)(*((_QWORD *)a2 + 37) + 8i64);
      do
      {
        if ( sub_1861C(*v12) )
        {
          if ( ++HIDWORD(FastMutex[8].Event.Header.WaitListHead.Flink) == 1 )
            LODWORD(FastMutex[8].Event.Header.WaitListHead.Blink) = *v12;
        }
        else
        {
          ++LODWORD(FastMutex[8].Event.Header.WaitListHead.Flink);
        }
        ++v11;
        v12 += 10;
      }
      while ( v11 < *((_WORD *)a2 + 14) );
    }
    v9 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    {
      sub_1A078(
        *((_QWORD *)off_2E128 + 27),
        0x2Bu,
        (__int64)&unk_2B3D8,
        *(_QWORD *)&FastMutex[1].Count,
        v10,
        a2[4],
        *(_QWORD *)&FastMutex[8].Count);
      v9 = (void **)off_2E128;
    }
    v6 = (const char *)(a2 + 10);
  }
  if ( *a2 == 1 )
  {
    v13 = *(_QWORD *)&FastMutex[7].Contention;
    v14 = *(_QWORD *)&FastMutex[7].Event.Header.Lock;
    v15 = strlen(v6) + 1;
    LODWORD(v16) = v15 - 1;
    sub_262B4((double)((int)v15 - 1), FastMutex[6].OldIrql, (double *)&FastMutex[7].Contention);
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    {
      LODWORD(v39) = v15 - 1;
      sub_1A078(
        *((_QWORD *)off_2E128 + 27),
        0x2Cu,
        (__int64)&unk_2B3D8,
        *(_QWORD *)&FastMutex[1].Count,
        v13,
        v39,
        *(_QWORD *)&FastMutex[7].Contention);
    }
    v17 = 0.0;
    v18 = 0;
    if ( a2 == (int *)-40i64 || (_DWORD)v15 == 1 )
      goto LABEL_45;
    v19 = a2 + 10;
    v16 = (unsigned int)v16;
    do
    {
      if ( *v19 != 46 )
      {
        if ( isdigit((unsigned __int8)*v19) )
          ++v3;
        else
          ++v18;
      }
      ++v19;
      --v16;
    }
    while ( v16 );
    v20 = (void **)off_2E128;
    if ( v3 + v18 )
    {
      v17 = (double)(100 * v3) / (double)(v3 + v18);
    }
    else
    {
      if ( off_2E128 == &off_2E128 )
      {
LABEL_45:
        sub_262B4(v17, FastMutex[6].OldIrql, (double *)&FastMutex[7].Event.Header.Lock);
        if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
          sub_1A0E4(
            *((_QWORD *)off_2E128 + 27),
            0x2Du,
            (__int64)&unk_2B3D8,
            *(_QWORD *)&FastMutex[1].Count,
            v14,
            *(_QWORD *)&FastMutex[7].Event.Header.Lock);
        goto LABEL_80;
      }
      if ( _bittest((const signed __int32 *)off_2E128 + 43, 0x15u) && *((_BYTE *)off_2E128 + 169) >= 3u )
      {
        sub_11008(*((_QWORD *)off_2E128 + 19), 0xEu, (__int64)&unk_2B368);
        v20 = (void **)off_2E128;
      }
    }
    if ( v20 != &off_2E128 && _bittest((const signed __int32 *)v20 + 43, 0x15u) && *((_BYTE *)v20 + 169) >= 4u )
    {
      HIDWORD(v39) = HIDWORD(v17);
      sub_26178((__int64)v20[19], 15i64, (__int64)&unk_2B368, v3);
    }
    goto LABEL_45;
  }
  v21 = (unsigned __int16 **)*((_QWORD *)a2 + 37);
  v22 = &FastMutex[8].Contention;
  v23 = &FastMutex[8].Event;
  v24 = 0;
  v41 = 0.0;
  v25 = *(_QWORD *)&FastMutex[8].Contention;
  v26 = *(_QWORD *)&FastMutex[8].Event.Header.Lock;
  if ( *((_WORD *)a2 + 14) )
  {
    while ( 1 )
    {
      v40 = 0;
      if ( v9 != &off_2E128 && (*((_BYTE *)v9 + 236) & 4) != 0 && *((_BYTE *)v9 + 233) >= 4u )
        sub_14544((__int64)v9[27], 0x2Eu, (__int64)&unk_2B3D8, v24);
      v27 = v24 - *((unsigned __int16 *)a2 + 14) + *(&FastMutex[7].OldIrql + 1) + 1;
      v4 = sub_17674(*((_QWORD *)a2 + 1), *v21, a2[4], 1, &v40);
      if ( v4 )
        break;
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
        sub_14544(*((_QWORD *)off_2E128 + 27), 0x30u, (__int64)&unk_2B3D8, v40);
      sub_262B4((double)v40, v27, (double *)&FastMutex[8].Contention);
      v4 = sub_172D8(*((_QWORD *)a2 + 1), *v21, a2[4], &v41);
      if ( v4 )
      {
        v9 = (void **)off_2E128;
        if ( off_2E128 == &off_2E128 )
          goto LABEL_80;
        if ( (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 3u )
        {
          v28 = 49;
LABEL_70:
          sub_14544((__int64)v9[27], v28, (__int64)&unk_2B3D8, v4);
          v9 = (void **)off_2E128;
          goto LABEL_71;
        }
        goto LABEL_71;
      }
      sub_262B4(v41, v27, (double *)&FastMutex[8].Event.Header.Lock);
      v9 = (void **)off_2E128;
      ++v24;
      v21 += 5;
      if ( v24 >= *((_WORD *)a2 + 14) )
        goto LABEL_71;
    }
    v9 = (void **)off_2E128;
    if ( off_2E128 == &off_2E128 )
      goto LABEL_80;
    if ( (*((_BYTE *)off_2E128 + 236) & 4) != 0 && *((_BYTE *)off_2E128 + 233) >= 3u )
    {
      v28 = 47;
      goto LABEL_70;
    }
LABEL_71:
    v23 = &FastMutex[8].Event;
    v22 = &FastMutex[8].Contention;
  }
  if ( v9 != &off_2E128 )
  {
    if ( (*((_BYTE *)v9 + 236) & 0x40) != 0 && *((_BYTE *)v9 + 233) >= 5u )
    {
      sub_1A0E4((__int64)v9[27], 0x32u, (__int64)&unk_2B3D8, *(_QWORD *)&FastMutex[1].Count, v25, *(_QWORD *)v22);
      v9 = (void **)off_2E128;
    }
    if ( v9 != &off_2E128 && (*((_BYTE *)v9 + 236) & 0x40) != 0 && *((_BYTE *)v9 + 233) >= 5u )
      sub_1A0E4(
        (__int64)v9[27],
        0x33u,
        (__int64)&unk_2B3D8,
        *(_QWORD *)&FastMutex[1].Count,
        v26,
        *(_QWORD *)&v23->Header.Lock);
  }
LABEL_80:
  v29 = *a2;
  FastMutex[6].Event.Header.LockNV = *a2;
  if ( v29 == 1 )
  {
    v30 = FastMutex[6].Event.Header.WaitListHead.Flink;
    if ( !v30 )
    {
      FastMutex[6].Event.Header.WaitListHead.Flink = (_LIST_ENTRY *)a2;
      goto LABEL_98;
    }
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 3u )
    {
      v31 = WORD2(v30[1].Flink);
      v32 = &v30[2].Blink;
      v33 = "DIFFERENT";
      if ( (_WORD)v31 == *((_WORD *)a2 + 10) )
        v33 = "SAME";
      LODWORD(v39) = v31;
      sub_1A298(
        *((_QWORD *)off_2E128 + 27),
        52i64,
        (__int64)&unk_2B3D8,
        *(_QWORD *)&FastMutex[1].Count,
        v33,
        v39,
        v32,
        *((unsigned __int16 *)a2 + 10),
        a2 + 10,
        FastMutex[6].Event.Header.WaitListHead.Blink);
    }
  }
  else
  {
    v34 = FastMutex[6].Event.Header.WaitListHead.Blink;
    if ( !v34 )
    {
      FastMutex[6].Event.Header.WaitListHead.Blink = (_LIST_ENTRY *)a2;
      goto LABEL_98;
    }
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 3u )
    {
      v35 = WORD2(v34[1].Flink);
      v36 = &v34[2].Blink;
      v37 = "DIFFERENT";
      if ( (_WORD)v35 == *((_WORD *)a2 + 10) )
        v37 = "SAME";
      LODWORD(v39) = v35;
      sub_1A140(
        *((_QWORD *)off_2E128 + 27),
        53i64,
        (__int64)&unk_2B3D8,
        *(_QWORD *)&FastMutex[1].Count,
        v37,
        v39,
        v36,
        *((unsigned __int16 *)a2 + 10),
        a2 + 10);
    }
  }
  v4 = 23;
LABEL_98:
  sub_1B918((__int64)FastMutex);
  sub_1DFDC(FastMutex);
  return v4;
}
// 1B330: conditional instruction was optimized away because of 'edi.4!=0'
// 1B304: variable 'v39' is possibly undefined
// 2E128: using guessed type void *off_2E128;

//----- (000000000001B8B0) ----------------------------------------------------
__int64 __fastcall sub_1B8B0(PFAST_MUTEX FastMutex)
{
  _LIST_ENTRY *v2; // rcx
  _LIST_ENTRY *v3; // rcx

  sub_1DF10(FastMutex);
  v2 = FastMutex[6].Event.Header.WaitListHead.Flink;
  if ( v2 )
  {
    sub_19BCC((__int64)v2);
    FastMutex[6].Event.Header.WaitListHead.Flink = 0i64;
  }
  v3 = FastMutex[6].Event.Header.WaitListHead.Blink;
  if ( v3 )
  {
    sub_19BCC((__int64)v3);
    FastMutex[6].Event.Header.WaitListHead.Blink = 0i64;
  }
  sub_1DFDC(FastMutex);
  return 0i64;
}

//----- (000000000001B918) ----------------------------------------------------
__int64 __fastcall sub_1B918(__int64 a1)
{
  void **v2; // r11
  const char *v3; // rdi
  const char *v4; // r9
  const char *v5; // rax
  const char *v6; // rax
  __int64 v7; // r11
  const char *v8; // rax
  __int64 v9; // r11
  const char *v10; // rax
  __int64 v11; // r11
  const char *v12; // r8
  const char *v13; // r10
  const char *v14; // rax
  __int64 v15; // r11

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
    {
      sub_1A030(*((_QWORD *)off_2E128 + 27), 54i64, (__int64)&unk_2B3D8, *(_QWORD *)(a1 + 56));
      v2 = (void **)off_2E128;
    }
    if ( v2 != &off_2E128 )
    {
      v3 = "FALSE";
      if ( (*((_BYTE *)v2 + 236) & 0x40) != 0 && *((_BYTE *)v2 + 233) >= 4u )
      {
        if ( *(_DWORD *)(a1 + 72) == 1 )
        {
          v4 = "INCOMING";
        }
        else if ( *(_DWORD *)(a1 + 72) == 2 )
        {
          v4 = "OUTGOING";
        }
        else
        {
          v4 = "UNKNOWN";
        }
        v5 = "FALSE";
        if ( *(_BYTE *)(a1 + 96) )
          v5 = "TRUE";
        sub_1A400((__int64)v2[27], 55i64, (__int64)&unk_2B3D8, v4, *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), v5);
        v2 = (void **)off_2E128;
      }
      if ( v2 != &off_2E128 )
      {
        if ( (*((_BYTE *)v2 + 236) & 0x40) != 0 && *((_BYTE *)v2 + 233) >= 4u )
        {
          if ( *(_BYTE *)(a1 + 97) )
            v3 = "TRUE";
          sub_15018((__int64)v2[27], 0x38u, (__int64)&unk_2B3D8, (const char *)(a1 + 98), v3);
          v2 = (void **)off_2E128;
        }
        if ( v2 != &off_2E128 )
        {
          if ( (*((_BYTE *)v2 + 236) & 0x40) != 0 && *((_BYTE *)v2 + 233) >= 4u )
          {
            sub_11008((__int64)v2[27], 0x39u, (__int64)&unk_2B3D8);
            v2 = (void **)off_2E128;
          }
          if ( v2 != &off_2E128 )
          {
            if ( (*((_BYTE *)v2 + 236) & 0x40) != 0 && *((_BYTE *)v2 + 233) >= 4u )
            {
              sub_19EA0((__int64)v2[27], 58i64, (__int64)&unk_2B3D8, *(_DWORD *)(a1 + 384));
              v2 = (void **)off_2E128;
            }
            if ( v2 != &off_2E128 )
            {
              if ( (*((_BYTE *)v2 + 236) & 0x40) != 0 && *((_BYTE *)v2 + 233) >= 4u )
              {
                v6 = sub_25B40(*(_DWORD *)(a1 + 432));
                sub_19F24(
                  *(_QWORD *)(v7 + 216),
                  0x3Bu,
                  (__int64)&unk_2B3D8,
                  *(_DWORD *)(a1 + 424),
                  *(_DWORD *)(a1 + 428),
                  v6);
                v2 = (void **)off_2E128;
              }
              if ( v2 != &off_2E128 )
              {
                if ( (*((_BYTE *)v2 + 236) & 0x40) != 0 && *((_BYTE *)v2 + 233) >= 4u )
                {
                  sub_11008((__int64)v2[27], 0x3Cu, (__int64)&unk_2B3D8);
                  v2 = (void **)off_2E128;
                }
                if ( v2 != &off_2E128 )
                {
                  if ( (*((_BYTE *)v2 + 236) & 0x40) != 0 && *((_BYTE *)v2 + 233) >= 4u )
                  {
                    sub_19FC0((__int64)v2[27], 61i64, (__int64)&unk_2B3D8, *(_DWORD *)(a1 + 440));
                    v2 = (void **)off_2E128;
                  }
                  if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 236) & 0x40) != 0 && *((_BYTE *)v2 + 233) >= 4u )
                  {
                    v8 = sub_25B40(*(_DWORD *)(a1 + 488));
                    sub_19F24(
                      *(_QWORD *)(v9 + 216),
                      0x3Eu,
                      (__int64)&unk_2B3D8,
                      *(_DWORD *)(a1 + 480),
                      *(_DWORD *)(a1 + 484),
                      v8);
                    v2 = (void **)off_2E128;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if ( *(_QWORD *)(a1 + 368) && v2 != &off_2E128 )
  {
    if ( (*((_BYTE *)v2 + 236) & 0x40) != 0 && *((_BYTE *)v2 + 233) >= 4u )
    {
      sub_11008((__int64)v2[27], 0x3Fu, (__int64)&unk_2B3D8);
      v2 = (void **)off_2E128;
    }
    if ( v2 != &off_2E128 )
    {
      if ( (*((_BYTE *)v2 + 236) & 0x40) != 0 && *((_BYTE *)v2 + 233) >= 4u )
      {
        sub_1E4A0((__int64)v2[27], 0x40u, (__int64)&unk_2B3D8, *(unsigned __int16 *)(*(_QWORD *)(a1 + 368) + 20i64));
        v2 = (void **)off_2E128;
      }
      if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 236) & 0x40) != 0 && *((_BYTE *)v2 + 233) >= 4u )
      {
        sub_26044(*(_DWORD *)(*(_QWORD *)(a1 + 368) + 36i64));
        v10 = sub_25B40(*(_DWORD *)(*(_QWORD *)(a1 + 368) + 32i64));
        sub_1A4CC(*(_QWORD *)(v11 + 216), 65i64, (__int64)&unk_2B3D8, v10, v12, v13);
        v2 = (void **)off_2E128;
      }
    }
  }
  if ( *(_QWORD *)(a1 + 376) && v2 != &off_2E128 )
  {
    if ( (*((_BYTE *)v2 + 236) & 0x40) != 0 && *((_BYTE *)v2 + 233) >= 4u )
    {
      sub_11008((__int64)v2[27], 0x42u, (__int64)&unk_2B3D8);
      v2 = (void **)off_2E128;
    }
    if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 236) & 0x40) != 0 && *((_BYTE *)v2 + 233) >= 4u )
    {
      v14 = sub_26094(*(_DWORD *)(*(_QWORD *)(a1 + 376) + 24i64));
      sub_19D78(
        *(_QWORD *)(v15 + 216),
        67i64,
        (__int64)&unk_2B3D8,
        *(unsigned __int16 *)(*(_QWORD *)(a1 + 376) + 20i64),
        v14);
    }
  }
  return 0i64;
}
// 1BB32: variable 'v7' is possibly undefined
// 1BC20: variable 'v9' is possibly undefined
// 1BD11: variable 'v11' is possibly undefined
// 1BD2D: variable 'v12' is possibly undefined
// 1BD2D: variable 'v13' is possibly undefined
// 1BDB9: variable 'v15' is possibly undefined
// 2E128: using guessed type void *off_2E128;

//----- (000000000001BDFC) ----------------------------------------------------
__int64 sub_1BDFC()
{
  __int64 v0; // rax
  void **v1; // rcx
  int v2; // ebx
  __int64 v3; // r8
  int v5; // [rsp+30h] [rbp+8h] BYREF
  ULONG_PTR v6; // [rsp+38h] [rbp+10h] BYREF

  v5 = 0;
  v6 = 0i64;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x44u, (__int64)&unk_2B3D8);
  v0 = sub_28A18((__int64)qword_30F88, &v6, &v5);
  if ( v0 )
  {
    do
    {
      sub_19600(*(_QWORD *)(v0 + 56), v0, 0i64);
      LOBYTE(v3) = 1;
      v0 = sub_28BEC((__int64)qword_30F88, &v6, v3, &v5);
    }
    while ( v0 );
LABEL_29:
    v1 = (void **)off_2E128;
    goto LABEL_30;
  }
  v1 = (void **)off_2E128;
  if ( off_2E128 == &off_2E128 )
    return 0i64;
  if ( (*((_BYTE *)off_2E128 + 236) & 0x40) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    if ( *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x108u, (__int64)&unk_2B2D0);
      v1 = (void **)off_2E128;
    }
    if ( v5 )
    {
      v2 = 1;
      if ( v5 != 1 )
      {
        switch ( v5 )
        {
          case 2:
            v2 = 3;
            break;
          case 3:
            v2 = 4;
            break;
          case 4:
            v2 = 5;
            break;
          case 5:
            v2 = 6;
            break;
          case 6:
          case 7:
          case 8:
            v2 = 19;
            break;
        }
      }
    }
    else
    {
      v2 = 0;
    }
    sub_14544((__int64)v1[27], 0x45u, (__int64)&unk_2B3D8, v2);
    goto LABEL_29;
  }
LABEL_30:
  if ( v1 != &off_2E128 && (*((_BYTE *)v1 + 236) & 0x40) != 0 && *((_BYTE *)v1 + 233) >= 5u )
    sub_11008((__int64)v1[27], 0x46u, (__int64)&unk_2B3D8);
  return 0i64;
}
// 1BF5F: variable 'v3' is possibly undefined
// 2E128: using guessed type void *off_2E128;

//----- (000000000001BFB4) ----------------------------------------------------
char __fastcall sub_1BFB4(__int64 a1)
{
  char v2; // bl
  void **v3; // rax
  __int64 *v4; // rcx
  char v6; // [rsp+48h] [rbp+10h] BYREF

  v2 = 0;
  v6 = 0;
  if ( (unsigned int)sub_20AD8(0x2029012u) )
  {
    sub_25418(a1, &v6);
    v2 = v6;
LABEL_7:
    v3 = (void **)off_2E128;
    goto LABEL_8;
  }
  v3 = (void **)off_2E128;
  if ( off_2E128 == &off_2E128 )
    return v2;
  if ( *((char *)off_2E128 + 236) < 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x47u, (__int64)&unk_2B3D8);
    goto LABEL_7;
  }
LABEL_8:
  if ( v3 != &off_2E128 && *((char *)v3 + 236) < 0 && *((_BYTE *)v3 + 233) >= 4u )
  {
    v4 = (__int64 *)"is not";
    if ( v2 )
      v4 = qword_2A5C0;
    sub_19E18((__int64)v3[27], 0x48u, (__int64)&unk_2B3D8, a1, v4);
  }
  return v2;
}
// 2A5C0: using guessed type __int64 qword_2A5C0[2];
// 2E128: using guessed type void *off_2E128;

//----- (000000000001C094) ----------------------------------------------------
__int64 __fastcall sub_1C094(__int64 a1, __int64 a2, __int64 a3, __int16 a4, __int64 a5)
{
  char *v7; // rsi
  __int64 *v8; // rax
  __int64 v9; // r8
  SIZE_T v10; // rbx
  unsigned __int64 v11; // rcx
  int *v12; // rdx
  __int64 v13; // r9
  char *v15; // rax
  __int64 v16; // rbp
  const void **i; // rdi
  size_t v18; // rbx
  unsigned int v19; // ebx
  __int64 WnodeEventItem[7]; // [rsp+30h] [rbp-D8h] BYREF
  int v21; // [rsp+68h] [rbp-A0h] BYREF
  char *v22; // [rsp+70h] [rbp-98h]
  int v23; // [rsp+78h] [rbp-90h]
  __int16 v24; // [rsp+128h] [rbp+20h] BYREF

  v24 = a4;
  v7 = 0i64;
  memset(WnodeEventItem, 0, 0x30ui64);
  WnodeEventItem[1] = a1;
  WnodeEventItem[6] = (__int64)&v24;
  v8 = &a5;
  WnodeEventItem[3] = a3;
  HIDWORD(WnodeEventItem[5]) = 1703936;
  BYTE4(WnodeEventItem[0]) = -1;
  v21 = 2;
  v9 = a5;
  v10 = 0i64;
  v11 = 0i64;
  if ( a5 )
  {
    v12 = &v21;
    do
    {
      v13 = v8[1];
      ++v11;
      v12 += 4;
      v10 += v13;
      if ( v11 <= 7 )
      {
        *((_QWORD *)v12 - 1) = v9;
        *v12 = v13;
      }
      v8 += 2;
      v9 = *v8;
    }
    while ( *v8 );
  }
  if ( v10 > 0x2000 )
    return 3221225473i64;
  if ( v11 <= 7 )
  {
    LOWORD(WnodeEventItem[0]) = 16 * (v11 + 4);
  }
  else
  {
    v15 = (char *)ExAllocatePoolWithTag(NonPagedPool, v10, 0x45435453u);
    v7 = v15;
    if ( !v15 )
      return 3221225495i64;
    v22 = v15;
    v23 = v10;
    v16 = 0i64;
    for ( i = (const void **)&a5; *i; i += 2 )
    {
      v18 = (size_t)i[1];
      memmove(&v7[v16], *i, v18);
      v16 += v18;
    }
    LOWORD(WnodeEventItem[0]) = 80;
  }
  v19 = IoWMIWriteEvent(WnodeEventItem);
  if ( v7 )
    ExFreePoolWithTag(v7, 0);
  return v19;
}

//----- (000000000001C1E8) ----------------------------------------------------
__int64 __fastcall sub_1C1E8(__int64 a1, char a2, __int64 *a3, __int64 a4)
{
  __int64 result; // rax

  result = 0i64;
  if ( a2 == 1 || !a2 )
  {
    if ( a2 )
    {
      *(_DWORD *)(a4 + 44) = *((_DWORD *)a3 + 1);
      *(_BYTE *)(a4 + 41) = *((_BYTE *)a3 + 2);
      result = *a3;
    }
    else
    {
      *(_BYTE *)(a4 + 41) = 0;
      *(_DWORD *)(a4 + 44) = 0;
    }
    *(_QWORD *)(a4 + 24) = result;
  }
  return result;
}

//----- (000000000001C220) ----------------------------------------------------
NTSTATUS __stdcall DriverEntry(_DRIVER_OBJECT *DriverObject, PUNICODE_STRING RegistryPath)
{
  int v3; // eax
  void **v4; // rcx
  __int64 *v5; // rbx
  __int64 v6; // rcx
  ULONG v7; // edx
  struct _DEVICE_OBJECT *v8; // rcx
  NTSTATUS v9; // ebx
  int v11; // eax
  struct _UNICODE_STRING SystemRoutineName; // [rsp+40h] [rbp-38h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+50h] [rbp-28h] BYREF
  unsigned int v14; // [rsp+90h] [rbp+18h] BYREF
  PDEVICE_OBJECT DeviceObject; // [rsp+98h] [rbp+20h] BYREF

  qword_30E88 = (__int64)&unk_2B290;
  qword_30E90 = (__int64)&qword_30EC0;
  qword_30EC8 = (__int64)&unk_2B2A0;
  qword_30E80 = 0i64;
  qword_30ED0 = (__int64)&qword_30F00;
  qword_30EA0 = 0i64;
  qword_30F08 = (__int64)&unk_2B2B0;
  byte_30EA8 = 1;
  qword_30F10 = (__int64)&qword_30F40;
  byte_30EA9 = 0;
  word_30EAA = 0;
  dword_30EAC = 0;
  qword_30EC0 = 0i64;
  qword_30F48 = (__int64)&unk_2B2C0;
  qword_30EE0 = 0i64;
  byte_30EE8 = 1;
  byte_30EE9 = 0;
  word_30EEA = 0;
  dword_30EEC = 0;
  qword_30F00 = 0i64;
  qword_30F20 = 0i64;
  byte_30F28 = 1;
  byte_30F29 = 0;
  word_30F2A = 0;
  dword_30F2C = 0;
  qword_30F40 = 0i64;
  qword_30F50 = 0i64;
  qword_30F60 = 0i64;
  byte_30F68 = 1;
  byte_30F69 = 0;
  word_30F6A = 0;
  dword_30F6C = 0;
  v14 = 0;
  RtlInitUnicodeString(&SystemRoutineName, L"PsGetVersion");
  qword_2E1B0 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))MmGetSystemRoutineAddress(&SystemRoutineName);
  RtlInitUnicodeString(&SystemRoutineName, L"WmiTraceMessage");
  qword_2E198 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))MmGetSystemRoutineAddress(&SystemRoutineName);
  if ( !qword_2E198 )
  {
    qword_2E198 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_1C094;
    v3 = 1;
LABEL_3:
    dword_2E1B8 = v3;
    goto LABEL_10;
  }
  RtlInitUnicodeString(&SystemRoutineName, L"WmiQueryTraceInformation");
  qword_2E190 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))MmGetSystemRoutineAddress(&SystemRoutineName);
  v3 = 2;
  dword_2E1B8 = 2;
  if ( qword_2E1B0 )
  {
    qword_2E1B0(&v14, 0i64, 0i64, 0i64);
    v3 = dword_2E1B8;
  }
  if ( v14 >= 6 )
  {
    RtlInitUnicodeString(&SystemRoutineName, L"EtwRegisterClassicProvider");
    qword_2E1A8 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))MmGetSystemRoutineAddress(&SystemRoutineName);
    if ( qword_2E1A8 )
    {
      RtlInitUnicodeString(&SystemRoutineName, L"EtwUnregister");
      qword_2E1A0 = (__int64 (*)(void))MmGetSystemRoutineAddress(&SystemRoutineName);
      v3 = 4;
      goto LABEL_3;
    }
    v3 = dword_2E1B8;
  }
LABEL_10:
  v4 = (void **)off_2E128;
  v5 = &qword_30E80;
  qword_30EA0 = 0i64;
  if ( off_2E128 != &qword_30E80 )
  {
    off_2E128 = &qword_30E80;
    if ( v3 == 4 )
    {
      do
      {
        v6 = v5[1];
        v5[7] = 0i64;
        qword_2E1A8(v6, 0i64, sub_1C1E8, v5, v5 + 7);
        v5 = (__int64 *)v5[2];
      }
      while ( v5 );
    }
    else
    {
      if ( v3 == 2 )
      {
        v7 = -2147418111;
        v8 = (struct _DEVICE_OBJECT *)&qword_30E80;
        qword_30E80 = (__int64)sub_32008;
      }
      else
      {
        qword_30E80 = 0i64;
        v7 = 1;
        v8 = (struct _DEVICE_OBJECT *)DriverObject;
      }
      IoWMIRegistrationControl(v8, v7);
    }
    v4 = (void **)off_2E128;
  }
  if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 236) & 1) != 0 && *((_BYTE *)v4 + 233) >= 5u )
    sub_11008((__int64)v4[27], 0xAu, (__int64)&unk_2B3C8);
  if ( !sub_254F4((__int64)&stru_2E310) )
  {
    v9 = -1073741670;
LABEL_25:
    sub_1C6E8((PDEVICE_OBJECT)DriverObject);
    return v9;
  }
  DriverObject->DriverUnload = (PDRIVER_UNLOAD)sub_1C6E8;
  RtlInitUnicodeString(&DestinationString, L"\\Device\\NNS_Parser2");
  v9 = IoCreateDevice(DriverObject, 0, &DestinationString, 0x22u, 0, 0, &DeviceObject);
  if ( v9 )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 1) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
      sub_110CC(*((_QWORD *)off_2E128 + 27), 0xCu, (__int64)&unk_2B3C8, (const char *)L"\\Device\\NNS_Parser2");
  }
  else
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 1) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0xBu, (__int64)&unk_2B3C8);
    DriverObject->MajorFunction[0] = (PDRIVER_DISPATCH)sub_1C950;
    DriverObject->MajorFunction[2] = (PDRIVER_DISPATCH)sub_1C950;
    DriverObject->MajorFunction[14] = (PDRIVER_DISPATCH)sub_1CD6C;
    DriverObject->MajorFunction[15] = (PDRIVER_DISPATCH)sub_1CE18;
  }
  if ( v9 < 0 )
    goto LABEL_25;
  v11 = sub_12408();
  if ( v11 )
    v9 = (unsigned __int16)v11 | 0xE0020000;
  if ( v9 < 0 )
    goto LABEL_25;
  if ( (unsigned __int8)sub_20AD8(0x2029001u) == 1 )
    sub_1C978();
  qword_30F80 = 1000000i64;
  KeInitializeDpc(&Dpc, (PKDEFERRED_ROUTINE)DeferredRoutine, sub_1D0B8);
  KeInitializeTimer(&Timer);
  qword_30DF0 = -10000000i64;
  KeSetTimer(&Timer, (LARGE_INTEGER)-10000000i64, &Dpc);
  return v9;
}
// 2E128: using guessed type void *off_2E128;
// 2E190: using guessed type __int64 (__fastcall *qword_2E190)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 2E1A0: using guessed type __int64 (*qword_2E1A0)(void);
// 2E1A8: using guessed type __int64 (__fastcall *qword_2E1A8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 2E1B0: using guessed type __int64 (__fastcall *qword_2E1B0)(_QWORD, _QWORD, _QWORD, _QWORD);
// 2E1B8: using guessed type int dword_2E1B8;
// 30DF0: using guessed type __int64 qword_30DF0;
// 30E80: using guessed type __int64 qword_30E80;
// 30E88: using guessed type __int64 qword_30E88;
// 30E90: using guessed type __int64 qword_30E90;
// 30EA0: using guessed type __int64 qword_30EA0;
// 30EA8: using guessed type char byte_30EA8;
// 30EA9: using guessed type char byte_30EA9;
// 30EAA: using guessed type __int16 word_30EAA;
// 30EAC: using guessed type int dword_30EAC;
// 30EC0: using guessed type __int64 qword_30EC0;
// 30EC8: using guessed type __int64 qword_30EC8;
// 30ED0: using guessed type __int64 qword_30ED0;
// 30EE0: using guessed type __int64 qword_30EE0;
// 30EE8: using guessed type char byte_30EE8;
// 30EE9: using guessed type char byte_30EE9;
// 30EEA: using guessed type __int16 word_30EEA;
// 30EEC: using guessed type int dword_30EEC;
// 30F00: using guessed type __int64 qword_30F00;
// 30F08: using guessed type __int64 qword_30F08;
// 30F10: using guessed type __int64 qword_30F10;
// 30F20: using guessed type __int64 qword_30F20;
// 30F28: using guessed type char byte_30F28;
// 30F29: using guessed type char byte_30F29;
// 30F2A: using guessed type __int16 word_30F2A;
// 30F2C: using guessed type int dword_30F2C;
// 30F40: using guessed type __int64 qword_30F40;
// 30F48: using guessed type __int64 qword_30F48;
// 30F50: using guessed type __int64 qword_30F50;
// 30F60: using guessed type __int64 qword_30F60;
// 30F68: using guessed type char byte_30F68;
// 30F69: using guessed type char byte_30F69;
// 30F6A: using guessed type __int16 word_30F6A;
// 30F6C: using guessed type int dword_30F6C;
// 30F80: using guessed type __int64 qword_30F80;

//----- (000000000001C6E8) ----------------------------------------------------
void __fastcall sub_1C6E8(PDEVICE_OBJECT DeviceObject)
{
  struct _DEVICE_OBJECT *v2; // rcx
  _QWORD *v3; // rbx
  ULONG v4; // edx
  struct _DEVICE_OBJECT *v5; // rcx

  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 1) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0xDu, (__int64)&unk_2B3C8);
  v2 = (struct _DEVICE_OBJECT *)DeviceObject->DriverObject;
  if ( v2 )
  {
    IoDeleteDevice(v2);
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 1) != 0 && *((_BYTE *)off_2E128 + 233) >= 4u )
      sub_11008(*((_QWORD *)off_2E128 + 27), 0xEu, (__int64)&unk_2B3C8);
  }
  sub_1C820();
  KeCancelTimer(&Timer);
  sub_125BC();
  dword_2E354 = 0;
  if ( qword_2E348 )
    sub_1DC94(qword_2E348);
  v3 = off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( dword_2E1B8 == 4 )
    {
      while ( v3 )
      {
        if ( v3[7] )
          qword_2E1A0();
        v3 = (_QWORD *)v3[2];
      }
    }
    else
    {
      v4 = 2;
      if ( dword_2E1B8 == 2 )
      {
        v4 = -2147483646;
        v5 = (struct _DEVICE_OBJECT *)off_2E128;
      }
      else
      {
        v5 = DeviceObject;
      }
      IoWMIRegistrationControl(v5, v4);
    }
    off_2E128 = &off_2E128;
  }
}
// 2E128: using guessed type void *off_2E128;
// 2E1A0: using guessed type __int64 (*qword_2E1A0)(void);
// 2E1B8: using guessed type int dword_2E1B8;
// 2E354: using guessed type int dword_2E354;

//----- (000000000001C820) ----------------------------------------------------
__int64 sub_1C820()
{
  __int64 result; // rax

  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
    && *((_BYTE *)off_2E128 + 169) >= 4u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0xFu, (__int64)&unk_2B3C8);
  }
  sub_12970();
  if ( byte_2E28C )
  {
    if ( qword_2E274 && sub_25618(&stru_2E310) )
    {
      qword_2E274(2i64);
      sub_25680(&stru_2E310);
    }
    sub_255B8(&stru_2E310);
    memset(&dword_2E268, 0, 0x25ui64);
    byte_2E28C = 0;
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
      && *((_BYTE *)off_2E128 + 169) >= 4u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x11u, (__int64)&unk_2B3C8);
    }
    result = 0i64;
  }
  else
  {
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
      && *((_BYTE *)off_2E128 + 169) >= 2u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x10u, (__int64)&unk_2B3C8);
    }
    result = 16i64;
  }
  return result;
}
// 2E128: using guessed type void *off_2E128;
// 2E268: using guessed type int dword_2E268;
// 2E274: using guessed type __int64 (__fastcall *qword_2E274)(_QWORD);
// 2E28C: using guessed type char byte_2E28C;

//----- (000000000001C950) ----------------------------------------------------
__int64 __fastcall sub_1C950(__int64 a1, IRP *a2)
{
  a2->IoStatus.Status = 0;
  a2->IoStatus.Information = 0i64;
  IofCompleteRequest(a2, 0);
  return 0i64;
}

//----- (000000000001C978) ----------------------------------------------------
__int64 sub_1C978()
{
  void **v0; // rcx
  unsigned int v1; // edi
  unsigned __int16 v2; // dx
  int v3; // eax
  unsigned int v4; // ebx
  IRP *v6; // rax
  NTSTATUS v7; // ebx
  void **v8; // rcx
  struct _UNICODE_STRING DestinationString; // [rsp+50h] [rbp-38h] BYREF
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+60h] [rbp-28h] BYREF
  PDEVICE_OBJECT DeviceObject; // [rsp+90h] [rbp+8h] BYREF
  PFILE_OBJECT FileObject; // [rsp+98h] [rbp+10h] BYREF

  v0 = (void **)off_2E128;
  v1 = 5;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x12u, (__int64)&unk_2B3C8);
    v0 = (void **)off_2E128;
  }
  if ( byte_2E28C )
  {
    if ( v0 == &off_2E128 || !_bittest((const signed __int32 *)v0 + 43, 9u) || *((_BYTE *)v0 + 169) < 2u )
      return 0i64;
    v2 = 19;
LABEL_68:
    sub_11008((__int64)v0[19], v2, (__int64)&unk_2B3C8);
    return 0i64;
  }
  v3 = sub_127CC();
  v4 = v3;
  if ( v3 )
  {
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
      && *((_BYTE *)off_2E128 + 169) >= 2u )
    {
      sub_14544(*((_QWORD *)off_2E128 + 19), 0x14u, (__int64)&unk_2B3C8, v3);
    }
    return v4;
  }
  RtlInitUnicodeString(&DestinationString, L"\\Device\\NNS_Streamer");
  if ( IoGetDeviceObjectPointer(&DestinationString, 0, &FileObject, &DeviceObject) < 0 )
  {
    v0 = (void **)off_2E128;
    if ( off_2E128 == &off_2E128
      || !_bittest((const signed __int32 *)off_2E128 + 43, 9u)
      || *((_BYTE *)off_2E128 + 169) < 5u )
    {
      return 0i64;
    }
    v2 = 21;
    goto LABEL_68;
  }
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x16u, (__int64)&unk_2B3C8);
  }
  qword_2E27C = (__int64)sub_12C8C;
  qword_2E284 = (__int64)sub_1312C;
  dword_2E268 = 2;
  v6 = IoBuildDeviceIoControlRequest(
         0x223E80u,
         DeviceObject,
         &dword_2E268,
         0x25u,
         &dword_2E268,
         0x25u,
         1u,
         0i64,
         &IoStatusBlock);
  if ( v6 )
  {
    v7 = IofCallDriver(DeviceObject, v6);
    if ( v7 < 0 )
    {
      if ( off_2E128 != &off_2E128
        && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
        && *((_BYTE *)off_2E128 + 169) >= 2u )
      {
        sub_11008(*((_QWORD *)off_2E128 + 19), 0x18u, (__int64)&unk_2B3C8);
      }
      if ( _bittest(&v7, 0x1Du) )
        return (unsigned __int16)v7;
      if ( (v7 & 0xC0000000) == 0 )
        return 0;
      if ( v7 != -1073741811 )
      {
        switch ( v7 )
        {
          case -1073741801:
            return 3;
          case -1073741776:
            return 4;
          case -1073741670:
            return 3;
        }
        if ( v7 <= -1073741586 )
          return 1;
        if ( v7 > -1073741574 )
        {
          if ( v7 == -1073741275 )
            return v1;
          return 1;
        }
      }
      return 4;
    }
    sub_25558(&stru_2E310);
    if ( sub_25618(&stru_2E310) )
    {
      if ( qword_2E27C && qword_2E284 )
      {
        sub_1DCFC((PRKEVENT)Event);
        sub_25680(&stru_2E310);
      }
    }
    else
    {
      v8 = (void **)off_2E128;
      if ( off_2E128 == &off_2E128 )
      {
LABEL_64:
        ObfDereferenceObject(FileObject);
        byte_2E28C = 1;
        v0 = (void **)off_2E128;
        if ( off_2E128 == &off_2E128
          || !_bittest((const signed __int32 *)off_2E128 + 43, 9u)
          || *((_BYTE *)off_2E128 + 169) < 5u )
        {
          return 0i64;
        }
        v2 = 27;
        goto LABEL_68;
      }
      if ( !_bittest((const signed __int32 *)off_2E128 + 43, 9u) || *((_BYTE *)off_2E128 + 169) < 2u )
      {
LABEL_60:
        if ( v8 != &off_2E128 && _bittest((const signed __int32 *)v8 + 43, 9u) && *((_BYTE *)v8 + 169) >= 5u )
          sub_14BA4((__int64)v8[19], 0x1Au, (__int64)&unk_2B3C8, qword_2E27C, qword_2E284);
        goto LABEL_64;
      }
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x19u, (__int64)&unk_2B3C8);
    }
    v8 = (void **)off_2E128;
    goto LABEL_60;
  }
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 9u)
    && *((_BYTE *)off_2E128 + 169) >= 2u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x17u, (__int64)&unk_2B3C8);
  }
  return 7i64;
}
// 2E128: using guessed type void *off_2E128;
// 2E268: using guessed type int dword_2E268;
// 2E27C: using guessed type __int64 qword_2E27C;
// 2E284: using guessed type __int64 qword_2E284;
// 2E28C: using guessed type char byte_2E28C;

//----- (000000000001CD6C) ----------------------------------------------------
__int64 __fastcall sub_1CD6C(__int64 a1, IRP *a2)
{
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 2) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x1Cu, (__int64)&unk_2B3C8);
  a2->IoStatus.Status = 0;
  a2->IoStatus.Information = 0i64;
  IofCompleteRequest(a2, 0);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 2) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_14544(*((_QWORD *)off_2E128 + 27), 0x1Du, (__int64)&unk_2B3C8, 0);
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001CE18) ----------------------------------------------------
__int64 __fastcall sub_1CE18(__int64 a1, IRP *a2)
{
  unsigned int v3; // esi
  void **v4; // rcx
  int v5; // er9
  unsigned int v6; // ebx

  v3 = 0;
  v4 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 2) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 27), 0x1Eu, (__int64)&unk_2B3C8);
    v4 = (void **)off_2E128;
  }
  v5 = a2->Tail.Overlay.CurrentStackLocation->Parameters.Read.ByteOffset.LowPart;
  if ( v5 == 2244224 )
  {
    if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 236) & 2) != 0 && *((_BYTE *)v4 + 233) >= 5u )
      sub_11008((__int64)v4[27], 0x1Fu, (__int64)&unk_2B3C8);
    if ( (unsigned __int8)sub_20AD8(0x2029001u) )
    {
      v3 = 37;
      memmove(&dword_2E268, a2->AssociatedIrp.MasterIrp, 0x25ui64);
      dword_2E268 = 2;
      qword_2E27C = (__int64)sub_12C8C;
      qword_2E284 = (__int64)sub_1312C;
      memmove(a2->AssociatedIrp.MasterIrp, &dword_2E268, 0x25ui64);
      sub_25558(&stru_2E310);
      byte_2E28C = 1;
      if ( sub_25618(&stru_2E310) )
      {
        if ( qword_2E27C && qword_2E284 )
        {
          if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 2) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
            sub_11008(*((_QWORD *)off_2E128 + 27), 0x21u, (__int64)&unk_2B3C8);
          sub_1DCFC((PRKEVENT)Event);
          sub_25680(&stru_2E310);
        }
      }
      else if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 2) != 0 && *((_BYTE *)off_2E128 + 233) >= 2u )
      {
        sub_11008(*((_QWORD *)off_2E128 + 27), 0x22u, (__int64)&unk_2B3C8);
      }
      v6 = 0;
    }
    else
    {
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 2) != 0 && *((_BYTE *)off_2E128 + 233) >= 3u )
        sub_11008(*((_QWORD *)off_2E128 + 27), 0x20u, (__int64)&unk_2B3C8);
      v6 = -1073740976;
    }
  }
  else
  {
    if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 236) & 2) != 0 && *((_BYTE *)v4 + 233) >= 3u )
      sub_14544((__int64)v4[27], 0x23u, (__int64)&unk_2B3C8, v5);
    v6 = -1073741811;
  }
  a2->IoStatus.Information = v3;
  a2->IoStatus.Status = v6;
  IofCompleteRequest(a2, 0);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 236) & 2) != 0 && *((_BYTE *)off_2E128 + 233) >= 5u )
    sub_14544(*((_QWORD *)off_2E128 + 27), 0x24u, (__int64)&unk_2B3C8, v6);
  return v6;
}
// 2E128: using guessed type void *off_2E128;
// 2E268: using guessed type int dword_2E268;
// 2E27C: using guessed type __int64 qword_2E27C;
// 2E284: using guessed type __int64 qword_2E284;
// 2E28C: using guessed type char byte_2E28C;

//----- (000000000001D0B8) ----------------------------------------------------
void sub_1D0B8()
{
  unsigned int v0; // er8
  void **v1; // rcx
  _QWORD *v2; // rax

  v0 = ++dword_2E1DC;
  v1 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 0xEu)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_1E4A0(*((_QWORD *)off_2E128 + 19), 0x25u, (__int64)&unk_2B3C8, v0);
    v0 = dword_2E1DC;
    v1 = (void **)off_2E128;
  }
  if ( v0 >= dword_2E304 )
  {
    if ( dword_2E300 )
    {
      v2 = sub_1E11C((__int64)qword_2E1D0, 4, (__int64)sub_1D1C8);
      if ( v2 )
        sub_1E294((__int64)v2, 0);
    }
    else if ( v1 != &off_2E128 && _bittest((const signed __int32 *)v1 + 43, 0xEu) && *((_BYTE *)v1 + 169) >= 3u )
    {
      sub_11008((__int64)v1[19], 0x26u, (__int64)&unk_2B3C8);
    }
    dword_2E1DC = 0;
  }
}
// 1D1C8: using guessed type __int64 __fastcall sub_1D1C8();
// 2E128: using guessed type void *off_2E128;
// 2E1DC: using guessed type int dword_2E1DC;
// 2E300: using guessed type int dword_2E300;
// 2E304: using guessed type int dword_2E304;

//----- (000000000001D1D4) ----------------------------------------------------
__int64 __fastcall sub_1D1D4(__int64 a1, unsigned __int16 a2)
{
  strlen(aUnknownModule);
  return qword_2E198(a1, 43i64, &unk_2B3B8, a2, aUnknownModule);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001D254) ----------------------------------------------------
PVOID __fastcall sub_1D254(int a1, unsigned int a2, ULONG a3)
{
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 4) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0xAu);
  return sub_1E578(a1, a2, a3);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001D2D8) ----------------------------------------------------
void __fastcall sub_1D2D8(PVOID P, ULONG Tag)
{
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 4) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0xBu);
  sub_1E694(P, Tag);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001D34C) ----------------------------------------------------
PVOID __fastcall sub_1D34C(__int64 a1, void *a2, unsigned int a3, unsigned int a4)
{
  size_t v5; // rsi
  void **v7; // rcx
  PVOID v8; // rax
  PVOID v9; // rbx

  v5 = a3;
  v7 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 108) & 4) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    {
      sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0xCu);
      v7 = (void **)off_2E128;
    }
    if ( v7 != &off_2E128 )
    {
      if ( (*((_BYTE *)v7 + 108) & 2) != 0 && *((_BYTE *)v7 + 105) >= 4u )
      {
        sub_11008((__int64)v7[11], 0x10u, (__int64)&unk_2B3A8);
        v7 = (void **)off_2E128;
      }
      if ( v7 != &off_2E128 && (*((_BYTE *)v7 + 108) & 4) != 0 && *((_BYTE *)v7 + 105) >= 6u )
        sub_1E404((__int64)v7[11], 17i64, (__int64)&unk_2B3A8, (int)a2);
    }
  }
  v8 = sub_1E578(1, a4, 0x706D744Eu);
  v9 = v8;
  if ( v8 && a2 )
  {
    memmove(v8, a2, v5);
    sub_1E694(a2, 0x706D744Eu);
  }
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_14544(*((_QWORD *)off_2E128 + 11), 0x12u, (__int64)&unk_2B3A8, (int)v9);
  return v9;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001D4C0) ----------------------------------------------------
char *__fastcall sub_1D4C0(int a1, unsigned int a2, ULONG a3)
{
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 4) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0xDu);
  return sub_1E78C(a1, a2, a3);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001D544) ----------------------------------------------------
void __fastcall sub_1D544(PVOID P)
{
  void **v2; // rcx

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 108) & 4) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    {
      sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0xEu);
      v2 = (void **)off_2E128;
    }
    if ( v2 != &off_2E128 )
    {
      if ( (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      {
        sub_11008((__int64)v2[11], 0x16u, (__int64)&unk_2B3A8);
        v2 = (void **)off_2E128;
      }
      if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 108) & 4) != 0 && *((_BYTE *)v2 + 105) >= 5u )
        sub_11008((__int64)v2[11], 0x17u, (__int64)&unk_2B3A8);
    }
  }
  if ( *(_DWORD *)P == 2 )
  {
    ExDeleteNPagedLookasideList((PNPAGED_LOOKASIDE_LIST)((char *)P + 64));
  }
  else if ( *(_DWORD *)P == 1 )
  {
    ExDeletePagedLookasideList((PPAGED_LOOKASIDE_LIST)((char *)P + 64));
  }
  sub_1E694(P, *((_DWORD *)P + 2));
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x18u, (__int64)&unk_2B3A8);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001D664) ----------------------------------------------------
_DWORD *__fastcall sub_1D664(__int64 a1)
{
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 4) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0xFu);
  return sub_1E940(a1);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001D6CC) ----------------------------------------------------
void __fastcall sub_1D6CC(__int64 a1, __int64 a2)
{
  void **v4; // rcx
  struct _SLIST_ENTRY *v5; // rdi

  v4 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 108) & 4) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    {
      sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x10u);
      v4 = (void **)off_2E128;
    }
    if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 108) & 2) != 0 && *((_BYTE *)v4 + 105) >= 4u )
    {
      sub_11008((__int64)v4[11], 0x1Bu, (__int64)&unk_2B3A8);
      v4 = (void **)off_2E128;
    }
  }
  v5 = (struct _SLIST_ENTRY *)(a2 - 4);
  if ( LODWORD(v5->Next) )
  {
    if ( LODWORD(v5->Next) == 1 )
    {
      sub_1E694(v5, *(_DWORD *)(a1 + 8));
LABEL_18:
      v4 = (void **)off_2E128;
      goto LABEL_19;
    }
  }
  else if ( *(_DWORD *)a1 == 2 || *(_DWORD *)a1 == 1 )
  {
    ++*(_DWORD *)(a1 + 92);
    if ( ExQueryDepthSList((PSLIST_HEADER)(a1 + 64)) < *(_WORD *)(a1 + 80) )
    {
      ExpInterlockedPushEntrySList((PSLIST_HEADER)(a1 + 64), v5);
    }
    else
    {
      ++*(_DWORD *)(a1 + 96);
      (*(void (__fastcall **)(struct _SLIST_ENTRY *))(a1 + 120))(v5);
    }
    goto LABEL_18;
  }
LABEL_19:
  if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 108) & 2) != 0 && *((_BYTE *)v4 + 105) >= 4u )
    sub_11008((__int64)v4[11], 0x1Cu, (__int64)&unk_2B3A8);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001D7F8) ----------------------------------------------------
__int64 __fastcall sub_1D7F8(PERESOURCE Resource)
{
  void **v2; // rcx
  int v3; // eax
  unsigned int v4; // ebx

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 108) & 0x20) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    {
      sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x12u);
      v2 = (void **)off_2E128;
    }
    if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x1Fu, (__int64)&unk_2B3A8);
  }
  v3 = ExInitializeResourceLite(Resource);
  v4 = v3;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_14544(*((_QWORD *)off_2E128 + 11), 0x20u, (__int64)&unk_2B3A8, v3);
  return v4;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001D8CC) ----------------------------------------------------
__int64 __fastcall sub_1D8CC(PERESOURCE Resource)
{
  void **v2; // rcx
  int v3; // eax
  unsigned int v4; // ebx

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 108) & 0x20) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    {
      sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x13u);
      v2 = (void **)off_2E128;
    }
    if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x21u, (__int64)&unk_2B3A8);
  }
  v3 = ExDeleteResourceLite(Resource);
  v4 = v3;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_14544(*((_QWORD *)off_2E128 + 11), 0x22u, (__int64)&unk_2B3A8, v3);
  return v4;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001D9A0) ----------------------------------------------------
BOOLEAN __fastcall sub_1D9A0(PERESOURCE Resource)
{
  void **v2; // rcx
  BOOLEAN v3; // al
  BOOLEAN v4; // bl

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 108) & 0x20) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    {
      sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x15u);
      v2 = (void **)off_2E128;
    }
    if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x25u, (__int64)&unk_2B3A8);
  }
  v3 = ExAcquireResourceExclusiveLite(Resource, 1u);
  v4 = v3;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_14544(*((_QWORD *)off_2E128 + 11), 0x26u, (__int64)&unk_2B3A8, v3);
  return v4;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001DA78) ----------------------------------------------------
BOOLEAN __fastcall sub_1DA78(PERESOURCE Resource)
{
  void **v2; // rcx
  BOOLEAN v3; // al
  BOOLEAN v4; // bl

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 108) & 0x20) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    {
      sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x16u);
      v2 = (void **)off_2E128;
    }
    if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x27u, (__int64)&unk_2B3A8);
  }
  v3 = ExAcquireResourceSharedLite(Resource, 1u);
  v4 = v3;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_14544(*((_QWORD *)off_2E128 + 11), 0x28u, (__int64)&unk_2B3A8, v3);
  return v4;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001DB50) ----------------------------------------------------
void __fastcall sub_1DB50(PERESOURCE Resource)
{
  void **v2; // rcx

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 108) & 0x20) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    {
      sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x18u);
      v2 = (void **)off_2E128;
    }
    if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x2Bu, (__int64)&unk_2B3A8);
  }
  ExReleaseResourceLite(Resource);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x2Cu, (__int64)&unk_2B3A8);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001DC1C) ----------------------------------------------------
bool __fastcall sub_1DC1C(struct _KEVENT **a1, char a2)
{
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 0x20) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x1Du);
  return sub_1EC24(a1, a2);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001DC94) ----------------------------------------------------
void __fastcall sub_1DC94(PVOID P)
{
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 0x20) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x1Eu);
  sub_1ED0C(P);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001DCFC) ----------------------------------------------------
int __fastcall sub_1DCFC(PRKEVENT Event)
{
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 0x20) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x1Fu);
  return sub_1EDA4(Event);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001DD64) ----------------------------------------------------
int __fastcall sub_1DD64(PRKEVENT Event)
{
  void **v2; // rcx
  int result; // eax

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 108) & 0x20) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    {
      sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x20u);
      v2 = (void **)off_2E128;
    }
    if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x3Bu, (__int64)&unk_2B3A8);
  }
  result = KeResetEvent(Event);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    result = sub_11008(*((_QWORD *)off_2E128 + 11), 0x3Cu, (__int64)&unk_2B3A8);
  return result;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001DE30) ----------------------------------------------------
void __fastcall sub_1DE30(__int64 a1)
{
  void **v2; // rcx

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 108) & 0x20) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    {
      sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x21u);
      v2 = (void **)off_2E128;
    }
    if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x3Du, (__int64)&unk_2B3A8);
  }
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 1;
  KeInitializeEvent((PRKEVENT)(a1 + 24), SynchronizationEvent, 0);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x3Eu, (__int64)&unk_2B3A8);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001DF10) ----------------------------------------------------
void __fastcall sub_1DF10(PFAST_MUTEX FastMutex)
{
  void **v2; // rcx

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 108) & 0x20) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    {
      sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x22u);
      v2 = (void **)off_2E128;
    }
    if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x3Fu, (__int64)&unk_2B3A8);
  }
  ExAcquireFastMutex(FastMutex);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x40u, (__int64)&unk_2B3A8);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001DFDC) ----------------------------------------------------
void __fastcall sub_1DFDC(PFAST_MUTEX FastMutex)
{
  void **v2; // rcx

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 108) & 0x20) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    {
      sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x24u);
      v2 = (void **)off_2E128;
    }
    if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x43u, (__int64)&unk_2B3A8);
  }
  ExReleaseFastMutex(FastMutex);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x44u, (__int64)&unk_2B3A8);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001E0A8) ----------------------------------------------------
__int64 __fastcall sub_1E0A8(PVOID P)
{
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 108) < 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x2Du);
  return sub_1F694(P);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001E11C) ----------------------------------------------------
_QWORD *__fastcall sub_1E11C(__int64 a1, int a2, __int64 a3)
{
  PVOID v3; // r13
  void **v6; // rcx
  _QWORD *v7; // rbx
  _QWORD *v8; // rdi
  unsigned int v9; // ebp

  v3 = qword_2E1D0;
  v6 = (void **)off_2E128;
  v7 = 0i64;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 108) < 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
  {
    sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x2Eu);
    v6 = (void **)off_2E128;
  }
  v8 = 0i64;
  v9 = a2 + 40;
  if ( v6 != &off_2E128 && (*((_BYTE *)v6 + 108) & 2) != 0 && *((_BYTE *)v6 + 105) >= 4u )
  {
    sub_11008((__int64)v6[11], 0x68u, (__int64)&unk_2B3A8);
    v6 = (void **)off_2E128;
  }
  if ( v3 && a3 && a2 )
  {
    v8 = sub_1E578(2, v9, 0x6E635749u);
LABEL_17:
    if ( v8 )
    {
      memset(v8, 0, v9);
      v8[4] = 0i64;
      v7 = v8 + 5;
      v8[1] = v8;
      *v8 = v8;
      v8[3] = a3;
      v8[2] = v3;
    }
    v6 = (void **)off_2E128;
    goto LABEL_20;
  }
  if ( v6 == &off_2E128 )
    return v7;
  if ( *((char *)v6 + 108) < 0 && *((_BYTE *)v6 + 105) >= 3u )
  {
    sub_11008((__int64)v6[11], 0x69u, (__int64)&unk_2B3A8);
    goto LABEL_17;
  }
LABEL_20:
  if ( v6 != &off_2E128 && (*((_BYTE *)v6 + 108) & 2) != 0 && *((_BYTE *)v6 + 105) >= 4u )
    sub_14544((__int64)v6[11], 0x6Au, (__int64)&unk_2B3A8, (int)v7);
  return v7;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001E294) ----------------------------------------------------
void __fastcall sub_1E294(__int64 a1, unsigned int a2)
{
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 108) < 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x31u);
  sub_1FAB4(a1, a2);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001E308) ----------------------------------------------------
__int64 __fastcall sub_1E308(PVOID Object)
{
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 0x20) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x32u);
  return sub_1FBC0(Object);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001E374) ----------------------------------------------------
__int64 __fastcall sub_1E374(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+B8h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B3A8, 14i64, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001E404) ----------------------------------------------------
__int64 __fastcall sub_1E404(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+C8h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B3A8, 17i64, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001E4A0) ----------------------------------------------------
__int64 __fastcall sub_1E4A0(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+78h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, a3, a2, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001E4E8) ----------------------------------------------------
__int64 __fastcall sub_1E4E8(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+B8h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B3A8, 11i64, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001E578) ----------------------------------------------------
PVOID __fastcall sub_1E578(int a1, unsigned int a2, ULONG a3)
{
  SIZE_T v4; // rdi
  void **v6; // rcx
  PVOID v7; // rax
  PVOID v8; // rbx

  v4 = a2;
  v6 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 11), 0xAu, (__int64)&unk_2B3A8);
      v6 = (void **)off_2E128;
    }
    if ( v6 != &off_2E128 && (*((_BYTE *)v6 + 108) & 4) != 0 && *((_BYTE *)v6 + 105) >= 6u )
      sub_1E4E8((__int64)v6[11], 11i64, (__int64)&unk_2B3A8, v4);
  }
  v7 = ExAllocatePoolWithTag((POOL_TYPE)(a1 != 2), v4, a3);
  v8 = v7;
  if ( v7 )
    memset(v7, 0, v4);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_14544(*((_QWORD *)off_2E128 + 11), 0xCu, (__int64)&unk_2B3A8, (int)v8);
  return v8;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001E694) ----------------------------------------------------
void __fastcall sub_1E694(PVOID P, ULONG Tag)
{
  void **v4; // rcx

  v4 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 11), 0xDu, (__int64)&unk_2B3A8);
      v4 = (void **)off_2E128;
    }
    if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 108) & 4) != 0 && *((_BYTE *)v4 + 105) >= 6u )
    {
      sub_1E374((__int64)v4[11], 14i64, (__int64)&unk_2B3A8, (int)P);
      v4 = (void **)off_2E128;
    }
  }
  if ( P )
  {
    ExFreePoolWithTag(P, Tag);
    v4 = (void **)off_2E128;
  }
  if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 108) & 2) != 0 && *((_BYTE *)v4 + 105) >= 4u )
    sub_11008((__int64)v4[11], 0xFu, (__int64)&unk_2B3A8);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001E78C) ----------------------------------------------------
char *__fastcall sub_1E78C(int a1, unsigned int a2, ULONG a3)
{
  __int64 v4; // rsi
  char *v5; // rbx
  void **v7; // rcx
  bool v8; // dl
  char *v9; // rax

  v4 = a2;
  v5 = 0i64;
  v7 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x13u, (__int64)&unk_2B3A8);
    v7 = (void **)off_2E128;
  }
  v8 = (_DWORD)v4 != 0;
  if ( a1 != 2 && a1 != 1 )
    v8 = 0;
  if ( v8 )
  {
    v9 = (char *)sub_1E578(2, 0xC0u, a3);
    v5 = v9;
    if ( v9 )
    {
      memset(v9, 0, 0xC0ui64);
      *((_DWORD *)v5 + 1) = v4;
      *(_DWORD *)v5 = a1;
      *((_DWORD *)v5 + 2) = a3;
      v7 = (void **)off_2E128;
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 4) != 0 && *((_BYTE *)off_2E128 + 105) >= 5u )
      {
        sub_11008(*((_QWORD *)off_2E128 + 11), 0x14u, (__int64)&unk_2B3A8);
        v7 = (void **)off_2E128;
      }
      if ( *(_DWORD *)v5 == 2 )
      {
        ExInitializeNPagedLookasideList((PNPAGED_LOOKASIDE_LIST)(v5 + 64), 0i64, 0i64, 0, v4 + 7, a3, 0);
        v7 = (void **)off_2E128;
      }
      if ( *(_DWORD *)v5 == 1 )
      {
        ExInitializePagedLookasideList((PPAGED_LOOKASIDE_LIST)(v5 + 64), 0i64, 0i64, 0, v4 + 7, a3, 0);
        v7 = (void **)off_2E128;
      }
    }
    else
    {
      v7 = (void **)off_2E128;
    }
  }
  if ( v7 != &off_2E128 && (*((_BYTE *)v7 + 108) & 2) != 0 && *((_BYTE *)v7 + 105) >= 4u )
    sub_14544((__int64)v7[11], 0x15u, (__int64)&unk_2B3A8, (int)v5);
  return v5;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001E940) ----------------------------------------------------
_DWORD *__fastcall sub_1E940(__int64 a1)
{
  _DWORD *v2; // rbx
  _DWORD *v3; // rax

  v2 = 0i64;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x19u, (__int64)&unk_2B3A8);
  if ( (*(_DWORD *)a1 == 2 || *(_DWORD *)a1 == 1)
    && ((++*(_DWORD *)(a1 + 84), (v3 = ExpInterlockedPopEntrySList((PSLIST_HEADER)(a1 + 64))) != 0i64)
     || (++*(_DWORD *)(a1 + 88),
         (v3 = (_DWORD *)(*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(a1 + 112))(
                           *(unsigned int *)(a1 + 100),
                           *(unsigned int *)(a1 + 108),
                           *(unsigned int *)(a1 + 104))) != 0i64)) )
  {
    *v3 = 0;
  }
  else
  {
    v3 = sub_1E578(*(_DWORD *)a1, *(_DWORD *)(a1 + 4) + 7, *(_DWORD *)(a1 + 8));
    if ( !v3 )
      goto LABEL_14;
    *v3 = 1;
  }
  v2 = v3 + 1;
  if ( v3 != (_DWORD *)-4i64 )
    memset(v3 + 1, 0, *(unsigned int *)(a1 + 4));
LABEL_14:
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_14544(*((_QWORD *)off_2E128 + 11), 0x1Au, (__int64)&unk_2B3A8, (int)v2);
  return v2;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001EA44) ----------------------------------------------------
__int64 __fastcall sub_1EA44(_QWORD *a1)
{
  __int64 result; // rax

  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    result = sub_11008(*((_QWORD *)off_2E128 + 11), 0x2Fu, (__int64)&unk_2B3A8);
  *a1 = 0i64;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    result = sub_11008(*((_QWORD *)off_2E128 + 11), 0x30u, (__int64)&unk_2B3A8);
  return result;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001EAC8) ----------------------------------------------------
void __fastcall sub_1EAC8(PKSPIN_LOCK SpinLock, KIRQL *a2)
{
  unsigned __int8 v4; // si

  v4 = KeGetCurrentIrql();
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x31u, (__int64)&unk_2B3A8);
  if ( v4 == 2 )
  {
    *a2 = 2;
    KeAcquireSpinLockAtDpcLevel(SpinLock);
  }
  else
  {
    *a2 = KeAcquireSpinLockRaiseToDpc(SpinLock);
  }
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x32u, (__int64)&unk_2B3A8);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001EB80) ----------------------------------------------------
void __fastcall sub_1EB80(PKSPIN_LOCK SpinLock, KIRQL a2)
{
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x33u, (__int64)&unk_2B3A8);
  if ( a2 == 2 )
    KeReleaseSpinLockFromDpcLevel(SpinLock);
  else
    KeReleaseSpinLock(SpinLock, a2);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x34u, (__int64)&unk_2B3A8);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001EC24) ----------------------------------------------------
bool __fastcall sub_1EC24(struct _KEVENT **a1, char a2)
{
  struct _KEVENT *v4; // rax
  struct _KEVENT *v5; // rdi

  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x35u, (__int64)&unk_2B3A8);
  *a1 = 0i64;
  v4 = (struct _KEVENT *)sub_1E578(2, 0x18u, 0x6E634556u);
  v5 = v4;
  if ( v4 )
  {
    KeInitializeEvent(v4, (EVENT_TYPE)(a2 == 0), 0);
    *a1 = v5;
  }
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_14544(*((_QWORD *)off_2E128 + 11), 0x36u, (__int64)&unk_2B3A8, v5 != 0i64);
  return v5 != 0i64;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001ED0C) ----------------------------------------------------
void __fastcall sub_1ED0C(PVOID P)
{
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x37u, (__int64)&unk_2B3A8);
  KeClearEvent((PRKEVENT)P);
  sub_1E694(P, 0x6E634556u);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x38u, (__int64)&unk_2B3A8);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001EDA4) ----------------------------------------------------
int __fastcall sub_1EDA4(PRKEVENT Event)
{
  int result; // eax

  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x39u, (__int64)&unk_2B3A8);
  result = KeSetEvent(Event, 0, 0);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    result = sub_11008(*((_QWORD *)off_2E128 + 11), 0x3Au, (__int64)&unk_2B3A8);
  return result;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001EE34) ----------------------------------------------------
void __fastcall HandleInformation(PVOID StartContext)
{
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x49u, (__int64)&unk_2B3A8);
  (*(void (__fastcall **)(_QWORD))StartContext)(*((_QWORD *)StartContext + 1));
  sub_1E694(StartContext, 0x6E635448u);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x4Au, (__int64)&unk_2B3A8);
  PsTerminateSystemThread(0);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001EED0) ----------------------------------------------------
unsigned __int8 __fastcall sub_1EED0(PVOID *Object, __int64 a2, __int64 a3)
{
  unsigned __int8 v6; // bl
  _QWORD *v7; // rax
  _QWORD *StartContext; // rsi
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+40h] [rbp-48h] BYREF
  void *ThreadHandle; // [rsp+90h] [rbp+8h] BYREF

  v6 = 1;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x4Bu, (__int64)&unk_2B3A8);
  v7 = sub_1E578(2, 0x10u, 0x6E635448u);
  *Object = 0i64;
  StartContext = v7;
  if ( !v7 )
    goto LABEL_10;
  memset(&ObjectAttributes.RootDirectory, 0, 0x28ui64);
  ThreadHandle = 0i64;
  ObjectAttributes.Length = 48;
  *StartContext = a2;
  StartContext[1] = a3;
  if ( !PsCreateSystemThread(
          &ThreadHandle,
          0x1F03FFu,
          &ObjectAttributes,
          0i64,
          0i64,
          (PKSTART_ROUTINE)HandleInformation,
          StartContext) )
  {
    ObReferenceObjectByHandle(ThreadHandle, 0, 0i64, 0, Object, 0i64);
    ZwClose(ThreadHandle);
  }
  if ( !*Object )
  {
    sub_1E694(StartContext, 0x6E635448u);
LABEL_10:
    v6 = 0;
  }
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_14544(*((_QWORD *)off_2E128 + 11), 0x4Cu, (__int64)&unk_2B3A8, v6);
  return v6;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001F040) ----------------------------------------------------
__int64 __fastcall sub_1F040(PVOID Object)
{
  void **v2; // rcx
  __int64 result; // rax

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
  {
    result = sub_11008(*((_QWORD *)off_2E128 + 11), 0x4Du, (__int64)&unk_2B3A8);
    v2 = (void **)off_2E128;
  }
  if ( Object )
  {
    result = ObfDereferenceObject(Object);
    v2 = (void **)off_2E128;
  }
  if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
    result = sub_11008((__int64)v2[11], 0x4Eu, (__int64)&unk_2B3A8);
  return result;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001F0D4) ----------------------------------------------------
__int64 __fastcall sub_1F0D4(void ***a1)
{
  void **v1; // r12
  __int64 v2; // rdi
  void *v4; // rax
  ULONG v5; // er14
  void *v6; // rdx
  void **v7; // r10
  unsigned int v8; // ebp
  __int64 v9; // rsi
  __int64 v10; // r13
  __int64 v11; // rsi
  _QWORD **v12; // rcx
  _QWORD *v13; // rbx
  _QWORD *v14; // rax
  char *v15; // rcx
  void (__fastcall *v16)(_QWORD *); // rax
  __int64 result; // rax
  void **v18; // rcx
  PVOID v19[2]; // [rsp+30h] [rbp-48h] BYREF
  __int64 v20; // [rsp+40h] [rbp-38h]
  KIRQL v21; // [rsp+80h] [rbp+8h] BYREF

  v1 = *a1;
  v2 = *((int *)a1 + 2);
  v4 = **a1;
  v5 = 2;
  v21 = 0;
  v19[0] = v4;
  v6 = (void *)*((_QWORD *)v1[3] + 3);
  v20 = 0i64;
  v19[1] = v6;
  v7 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x53u, (__int64)&unk_2B3A8);
    v7 = (void **)off_2E128;
  }
  if ( *((_BYTE *)v1 + 12) )
  {
    v5 = 3;
    v20 = *((_QWORD *)v1[3] + 4 * (unsigned int)v2 + 3);
  }
  if ( a1[2] )
  {
    if ( v7 != &off_2E128 && *((char *)v7 + 108) < 0 && *((_BYTE *)v7 + 105) >= 5u )
      sub_14544((__int64)v7[11], 0x54u, (__int64)&unk_2B3A8, v2);
    sub_1EDA4((PRKEVENT)a1[2]);
  }
  while ( 1 )
  {
    result = sub_1FC68(v5, v19);
    if ( !(_DWORD)result )
      break;
    v8 = 0;
    v9 = 0i64;
    if ( (_DWORD)result == 2 )
    {
      v8 = v2;
      v9 = v2;
    }
    if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 108) < 0 && *((_BYTE *)off_2E128 + 105) >= 5u )
      sub_14544(*((_QWORD *)off_2E128 + 11), 0x56u, (__int64)&unk_2B3A8, v2);
    v10 = 32i64 * v8;
    sub_1EAC8((PKSPIN_LOCK)((char *)v1[3] + v10), &v21);
    v11 = 32 * v9;
    v12 = (_QWORD **)((char *)v1[3] + v11 + 8);
    v13 = 0i64;
    if ( *v12 != v12 )
    {
      v13 = *v12;
      v14 = (_QWORD *)**v12;
      *v12 = v14;
      v14[1] = v12;
      if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 108) < 0 && *((_BYTE *)off_2E128 + 105) >= 5u )
        sub_1E4A0(*((_QWORD *)off_2E128 + 11), 0x57u, (__int64)&unk_2B3A8, v2);
      v15 = (char *)v1[3];
      if ( *(char **)&v15[v11 + 8] != &v15[v11 + 8] )
        sub_1EDA4(*(PRKEVENT *)&v15[v11 + 24]);
    }
    sub_1EB80((PKSPIN_LOCK)((char *)v1[3] + v10), v21);
    if ( v13 )
    {
      if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 108) < 0 && *((_BYTE *)off_2E128 + 105) >= 5u )
        sub_1E4A0(*((_QWORD *)off_2E128 + 11), 0x58u, (__int64)&unk_2B3A8, v2);
      v16 = (void (__fastcall *)(_QWORD *))v13[3];
      if ( v16 )
        v16(v13 + 5);
      sub_1F9F0((__int64)(v13 + 5), 0);
      if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 108) < 0 && *((_BYTE *)off_2E128 + 105) >= 5u )
        sub_1E4A0(*((_QWORD *)off_2E128 + 11), 0x59u, (__int64)&unk_2B3A8, v2);
    }
  }
  v18 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( *((char *)off_2E128 + 108) < 0 && *((_BYTE *)off_2E128 + 105) >= 5u )
    {
      result = sub_14544(*((_QWORD *)off_2E128 + 11), 0x55u, (__int64)&unk_2B3A8, v2);
      v18 = (void **)off_2E128;
    }
    if ( v18 != &off_2E128 && (*((_BYTE *)v18 + 108) & 2) != 0 && *((_BYTE *)v18 + 105) >= 4u )
      result = sub_11008((__int64)v18[11], 0x5Au, (__int64)&unk_2B3A8);
  }
  return result;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001F3E0) ----------------------------------------------------
__int64 __fastcall sub_1F3E0(unsigned int a1, char a2)
{
  __int64 v3; // r12
  int v4; // esi
  __int64 v5; // r14
  PVOID v6; // rax
  __int64 v7; // rdi
  unsigned int v8; // ebx
  PVOID v9; // rax
  _QWORD *v10; // r11
  __int64 v11; // r13
  unsigned int v12; // ebp
  __int64 v13; // rbx
  _QWORD *v14; // rax
  __int64 v16; // [rsp+30h] [rbp-48h] BYREF
  unsigned int v17; // [rsp+38h] [rbp-40h]
  PVOID P; // [rsp+40h] [rbp-38h] BYREF

  v3 = a1;
  v4 = 0;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x5Bu, (__int64)&unk_2B3A8);
  v5 = 32i64;
  v6 = sub_1E578(2, 0x20u, 0x6E635450u);
  v7 = (__int64)v6;
  if ( !v6 )
    goto LABEL_24;
  memset(v6, 0, 0x20ui64);
  sub_1EC24((struct _KEVENT **)v7, 1);
  *(_DWORD *)(v7 + 8) = v3;
  *(_BYTE *)(v7 + 12) = a2;
  *(_QWORD *)(v7 + 16) = sub_1E578(2, 8 * (int)v3, 0x6E635450u);
  v8 = a2 ? 32 * (v3 + 1) : 32;
  v9 = sub_1E578(2, v8, 0x6E635450u);
  *(_QWORD *)(v7 + 24) = v9;
  if ( *(_QWORD *)(v7 + 16) && v9 )
  {
    v16 = v7;
    sub_1EC24((struct _KEVENT **)&P, 0);
    memset(*(void **)(v7 + 16), 0, 8 * v3);
    memset(*(void **)(v7 + 24), 0, v8);
    sub_1EA44(*(_QWORD **)(v7 + 24));
    sub_1EC24((struct _KEVENT **)(*(_QWORD *)(v7 + 24) + 24i64), 0);
    v10 = (_QWORD *)(*(_QWORD *)(v7 + 24) + 8i64);
    v10[1] = v10;
    *v10 = v10;
    if ( (_DWORD)v3 )
    {
      v11 = 0i64;
      v12 = 1;
      while ( 1 )
      {
        if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 108) < 0 && *((_BYTE *)off_2E128 + 105) >= 5u )
          sub_1E4A0(*((_QWORD *)off_2E128 + 11), 0x5Cu, (__int64)&unk_2B3A8, v12);
        v17 = v12;
        if ( a2 )
        {
          v13 = 32i64 * v12;
          sub_1EA44((_QWORD *)(v13 + *(_QWORD *)(v7 + 24)));
          sub_1EC24((struct _KEVENT **)(v13 + *(_QWORD *)(v7 + 24) + 24), 0);
          v14 = (_QWORD *)(v5 + *(_QWORD *)(v7 + 24) + 8);
          v14[1] = v14;
          *v14 = v14;
        }
        sub_1EED0((PVOID *)(*(_QWORD *)(v7 + 16) + 8i64 * (v12 - 1)), (__int64)sub_1F0D4, (__int64)&v16);
        if ( !*(_QWORD *)(v11 + *(_QWORD *)(v7 + 16)) )
          break;
        sub_1FBC0(P);
        ++v12;
        v5 += 32i64;
        v11 += 8i64;
        if ( v12 - 1 >= (unsigned int)v3 )
          goto LABEL_23;
      }
      v4 = -16777213;
    }
LABEL_23:
    sub_1ED0C(P);
  }
  else
  {
LABEL_24:
    v4 = -16777213;
  }
  if ( v4 && v7 )
  {
    sub_1F694((PVOID)v7);
    v7 = 0i64;
  }
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_14544(*((_QWORD *)off_2E128 + 11), 0x5Du, (__int64)&unk_2B3A8, v7);
  return v7;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001F694) ----------------------------------------------------
__int64 __fastcall sub_1F694(PVOID P)
{
  void **v2; // rcx
  unsigned int v3; // eax
  __int64 v4; // rsi
  __int64 v5; // rbp
  __int64 v6; // r12
  void **v7; // rcx
  __int64 v8; // rdx
  _QWORD **v9; // rcx
  _QWORD *v10; // rdi
  _QWORD *v11; // rax
  unsigned int v12; // esi
  __int64 v13; // rdi
  __int64 v14; // rbp
  KIRQL v16; // [rsp+50h] [rbp+8h] BYREF

  v16 = 0;
  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x5Eu, (__int64)&unk_2B3A8);
    v2 = (void **)off_2E128;
  }
  if ( *((_BYTE *)P + 12) )
    v3 = *((_DWORD *)P + 2) + 1;
  else
    v3 = 1;
  if ( v3 )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = v3;
    do
    {
      sub_1EAC8((PKSPIN_LOCK)(v5 + *((_QWORD *)P + 3)), &v16);
      v7 = (void **)off_2E128;
      if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 108) < 0 && *((_BYTE *)off_2E128 + 105) >= 5u )
      {
        sub_11008(*((_QWORD *)off_2E128 + 11), 0x5Fu, (__int64)&unk_2B3A8);
        v7 = (void **)off_2E128;
      }
      v8 = *((_QWORD *)P + 3);
      if ( *(_QWORD *)(v4 + v8 + 8) != v4 + v8 + 8 )
      {
        do
        {
          v9 = (_QWORD **)(v4 + v8 + 8);
          v10 = *v9;
          v11 = (_QWORD *)**v9;
          *v9 = v11;
          v11[1] = v9;
          if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 108) < 0 && *((_BYTE *)off_2E128 + 105) >= 5u )
            sub_14544(*((_QWORD *)off_2E128 + 11), 0x60u, (__int64)&unk_2B3A8, (int)v10);
          sub_1F9F0((__int64)(v10 + 5), 1);
          v8 = *((_QWORD *)P + 3);
        }
        while ( *(_QWORD *)(v4 + v8 + 8) != v4 + v8 + 8 );
        v7 = (void **)off_2E128;
      }
      if ( v7 != &off_2E128 && *((char *)v7 + 108) < 0 && *((_BYTE *)v7 + 105) >= 5u )
        sub_11008((__int64)v7[11], 0x61u, (__int64)&unk_2B3A8);
      sub_1EB80((PKSPIN_LOCK)(v5 + *((_QWORD *)P + 3)), v16);
      v5 += 32i64;
      v4 += 32i64;
      --v6;
    }
    while ( v6 );
    v2 = (void **)off_2E128;
  }
  if ( *(_QWORD *)P )
  {
    if ( v2 != &off_2E128 && *((char *)v2 + 108) < 0 && *((_BYTE *)v2 + 105) >= 5u )
      sub_11008((__int64)v2[11], 0x62u, (__int64)&unk_2B3A8);
    sub_1EDA4(*(PRKEVENT *)P);
    v2 = (void **)off_2E128;
  }
  if ( v2 != &off_2E128 && *((char *)v2 + 108) < 0 && *((_BYTE *)v2 + 105) >= 5u )
  {
    sub_14544((__int64)v2[11], 0x63u, (__int64)&unk_2B3A8, *((_DWORD *)P + 2));
    v2 = (void **)off_2E128;
  }
  v12 = 0;
  if ( *((_DWORD *)P + 2) )
  {
    v13 = 0i64;
    v14 = 32i64;
    do
    {
      if ( *(_QWORD *)(v13 + *((_QWORD *)P + 2)) )
      {
        if ( v2 != &off_2E128 && *((char *)v2 + 108) < 0 && *((_BYTE *)v2 + 105) >= 5u )
          sub_14544((__int64)v2[11], 0x64u, (__int64)&unk_2B3A8, v12);
        sub_1FBC0(*(PVOID *)(v13 + *((_QWORD *)P + 2)));
        if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 108) < 0 && *((_BYTE *)off_2E128 + 105) >= 5u )
          sub_14544(*((_QWORD *)off_2E128 + 11), 0x65u, (__int64)&unk_2B3A8, v12);
        sub_1F040(*(PVOID *)(v13 + *((_QWORD *)P + 2)));
        *(_QWORD *)(v13 + *((_QWORD *)P + 2)) = 0i64;
        if ( *((_BYTE *)P + 12) )
          sub_1ED0C(*(PVOID *)(*((_QWORD *)P + 3) + v14 + 24));
        v2 = (void **)off_2E128;
      }
      ++v12;
      v14 += 32i64;
      v13 += 8i64;
    }
    while ( v12 < *((_DWORD *)P + 2) );
  }
  if ( v2 != &off_2E128 && *((char *)v2 + 108) < 0 && *((_BYTE *)v2 + 105) >= 5u )
    sub_11008((__int64)v2[11], 0x66u, (__int64)&unk_2B3A8);
  sub_1ED0C(*(PVOID *)(*((_QWORD *)P + 3) + 24i64));
  sub_1ED0C(*(PVOID *)P);
  sub_1E694(*((PVOID *)P + 2), 0x6E635450u);
  sub_1E694(*((PVOID *)P + 3), 0x6E635450u);
  sub_1E694(P, 0x6E635450u);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x67u, (__int64)&unk_2B3A8);
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001F9F0) ----------------------------------------------------
void __fastcall sub_1F9F0(__int64 a1, char a2)
{
  void **v4; // rcx
  void (__fastcall *v5)(__int64); // rax

  v4 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x6Bu, (__int64)&unk_2B3A8);
    v4 = (void **)off_2E128;
  }
  if ( a1 )
  {
    if ( a2 )
    {
      v5 = *(void (__fastcall **)(__int64))(a1 - 8);
      if ( v5 )
        v5(a1);
    }
    sub_1E694((PVOID)(a1 - 40), 0x6E635749u);
    v4 = (void **)off_2E128;
  }
  if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 108) & 2) != 0 && *((_BYTE *)v4 + 105) >= 4u )
    sub_11008((__int64)v4[11], 0x6Cu, (__int64)&unk_2B3A8);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001FAB4) ----------------------------------------------------
void __fastcall sub_1FAB4(__int64 a1, unsigned int a2)
{
  void **v4; // rcx
  __int64 *v5; // rbp
  __int64 v6; // rdi
  __int64 v7; // rbx
  __int64 v8; // r11
  __int64 v9; // rcx
  __int64 **v10; // rax
  KIRQL v11; // [rsp+40h] [rbp+8h] BYREF

  v4 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x6Du, (__int64)&unk_2B3A8);
    v4 = (void **)off_2E128;
  }
  if ( a1 )
  {
    v5 = (__int64 *)(a1 - 40);
    v11 = 0;
    v6 = *(_QWORD *)(a1 - 40 + 16);
    if ( a2 > *(_DWORD *)(v6 + 8) || !*(_BYTE *)(v6 + 12) )
      a2 = 0;
    v7 = 32i64 * a2;
    sub_1EAC8((PKSPIN_LOCK)(v7 + *(_QWORD *)(v6 + 24)), &v11);
    v8 = *(_QWORD *)(v6 + 24);
    v9 = v7 + v8 + 8;
    v10 = *(__int64 ***)(v7 + v8 + 16);
    *v5 = v9;
    v5[1] = (__int64)v10;
    *v10 = v5;
    *(_QWORD *)(v9 + 8) = v5;
    sub_1EDA4(*(PRKEVENT *)(v7 + *(_QWORD *)(v6 + 24) + 24));
    sub_1EB80((PKSPIN_LOCK)(v7 + *(_QWORD *)(v6 + 24)), v11);
    v4 = (void **)off_2E128;
  }
  if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 108) & 2) != 0 && *((_BYTE *)v4 + 105) >= 4u )
    sub_11008((__int64)v4[11], 0x6Eu, (__int64)&unk_2B3A8);
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001FBC0) ----------------------------------------------------
__int64 __fastcall sub_1FBC0(PVOID Object)
{
  int v2; // eax
  unsigned int v3; // ebx

  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x6Fu, (__int64)&unk_2B3A8);
  v2 = KeWaitForSingleObject(Object, Executive, 0, 0, 0i64);
  v3 = v2;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_14544(*((_QWORD *)off_2E128 + 11), 0x70u, (__int64)&unk_2B3A8, v2);
  return v3;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001FC68) ----------------------------------------------------
__int64 __fastcall sub_1FC68(ULONG Count, PVOID Object[])
{
  struct _KWAIT_BLOCK *WaitBlockArray; // rdi
  unsigned int v6; // ebx

  WaitBlockArray = 0i64;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 11), 0x71u, (__int64)&unk_2B3A8);
  if ( Count > 3 )
  {
    WaitBlockArray = (struct _KWAIT_BLOCK *)sub_1E578(2, 48 * Count, 0x6E635742u);
    if ( !WaitBlockArray )
      return 4278190083i64;
  }
  v6 = KeWaitForMultipleObjects(Count, Object, WaitAny, Executive, 0, 0, 0i64, WaitBlockArray);
  if ( WaitBlockArray )
    sub_1E694(WaitBlockArray, 0x6E635742u);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 2) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
    sub_14544(*((_QWORD *)off_2E128 + 11), 0x72u, (__int64)&unk_2B3A8, v6);
  return v6;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000001FD74) ----------------------------------------------------
__int64 __fastcall sub_1FD74(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, __int64 a5, int a6)
{
  int v7; // [rsp+88h] [rbp+20h] BYREF

  v7 = a4;
  a6 = 0;
  return qword_2E198(a1, 43i64, &unk_2B388, a2, &v7);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001FDD4) ----------------------------------------------------
__int64 __fastcall sub_1FDD4(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, __int64 a6, int a7)
{
  int v8; // [rsp+98h] [rbp+20h] BYREF

  v8 = a4;
  a7 = 0;
  return qword_2E198(a1, 43i64, &unk_2B388, 125i64, &v8);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001FE44) ----------------------------------------------------
__int64 __fastcall sub_1FE44(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+78h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B2D0, a2, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001FE98) ----------------------------------------------------
__int64 __fastcall sub_1FE98(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+88h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B388, a2, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001FEF4) ----------------------------------------------------
__int64 __fastcall sub_1FEF4(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+98h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B388, 115i64, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001FF64) ----------------------------------------------------
__int64 sub_1FF64(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2E198(a1, 43i64, a3, a2, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001FFB0) ----------------------------------------------------
__int64 __fastcall sub_1FFB0(__int64 a1, __int64 a2, _QWORD *a3)
{
  bool v5; // r12
  void **v6; // rcx
  unsigned __int16 v7; // dx
  char *v8; // rbx
  unsigned int v9; // edi
  int v10; // er9
  unsigned int v11; // eax
  _WORD *v12; // rdx
  char *v13; // rax
  PVOID v14; // rax
  unsigned int v15; // edx
  __int64 v16; // r8
  _QWORD *v17; // rax
  char *v18; // rcx
  unsigned int *v19; // rbx
  unsigned int v20; // eax
  void *v21; // rcx
  void *v22; // rcx

  v5 = 0;
  v6 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0xAu, (__int64)&unk_2B388);
    v6 = (void **)off_2E128;
  }
  if ( !a1 )
  {
    if ( v6 == &off_2E128 || !_bittest((const signed __int32 *)v6 + 43, 8u) || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_12;
    v7 = 11;
    goto LABEL_10;
  }
  v10 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 0xFF000000) != 0x2000000 || (v10 & 0xFFFF00) == 0 || (_BYTE)v10 )
  {
    if ( v6 != &off_2E128 && _bittest((const signed __int32 *)v6 + 43, 8u) && *((_BYTE *)v6 + 169) >= 2u )
    {
      sub_14544((__int64)v6[19], 0xCu, (__int64)&unk_2B388, v10);
      v6 = (void **)off_2E128;
    }
    v9 = 4;
    goto LABEL_57;
  }
  v11 = 0;
  v12 = (_WORD *)(a1 + 4);
  do
  {
    if ( !*v12 )
      break;
    ++v11;
    ++v12;
  }
  while ( v11 < 0x40 );
  if ( v11 < 0x40 )
  {
    if ( !a3 || !*a3 )
    {
      if ( v6 == &off_2E128 || !_bittest((const signed __int32 *)v6 + 43, 8u) || *((_BYTE *)v6 + 169) < 2u )
        goto LABEL_12;
      sub_12374((__int64)v6[19], 0xEu, (__int64)&unk_2B388, a3);
      goto LABEL_11;
    }
    v13 = (char *)sub_1D254(2, 0xDB4u, 0x66634E4Eu);
    v8 = v13;
    qword_2E378 = v13;
    if ( !v13 )
    {
      v6 = (void **)off_2E128;
      if ( off_2E128 != &off_2E128
        && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
        && *((_BYTE *)off_2E128 + 169) )
      {
        sub_14544(*((_QWORD *)off_2E128 + 19), 0xFu, (__int64)&unk_2B388, 3156);
        v6 = (void **)off_2E128;
        v8 = (char *)qword_2E378;
      }
      v9 = 3;
      goto LABEL_64;
    }
    memset(v13, 0, 0xDB4ui64);
    v5 = sub_254F4((__int64)(v8 + 128));
    if ( !v5 )
    {
      v6 = (void **)off_2E128;
      if ( off_2E128 != &off_2E128
        && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
        && *((_BYTE *)off_2E128 + 169) )
      {
        sub_11008(*((_QWORD *)off_2E128 + 19), 0x10u, (__int64)&unk_2B388);
        v6 = (void **)off_2E128;
      }
      v9 = 9;
LABEL_58:
      v8 = (char *)qword_2E378;
LABEL_59:
      if ( v5 && v8 != (char *)-128i64 )
      {
        v21 = (void *)*((_QWORD *)v8 + 23);
        *((_DWORD *)v8 + 49) = 0;
        if ( v21 )
        {
          sub_1DC94(v21);
          v8 = (char *)qword_2E378;
        }
        v6 = (void **)off_2E128;
      }
      goto LABEL_64;
    }
    v14 = sub_1D254(1, 4 * (unsigned int)*(unsigned __int8 *)(a1 + 136), 0x66634E4Eu);
    v8 = (char *)qword_2E378;
    *((_QWORD *)qword_2E378 + 26) = v14;
    if ( !v14 )
    {
      v6 = (void **)off_2E128;
      if ( off_2E128 != &off_2E128
        && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
        && *((_BYTE *)off_2E128 + 169) )
      {
        sub_14544(*((_QWORD *)off_2E128 + 19), 0x11u, (__int64)&unk_2B388, 4 * *(unsigned __int8 *)(a1 + 136));
        v6 = (void **)off_2E128;
        v8 = (char *)qword_2E378;
      }
      v9 = 3;
      goto LABEL_59;
    }
    v15 = 0;
    if ( *(_BYTE *)(a1 + 136) )
    {
      v16 = 0i64;
      do
      {
        *(_DWORD *)(v16 + *((_QWORD *)v8 + 26)) = *(_DWORD *)a1 | ++v15;
        v16 += 4i64;
      }
      while ( v15 < *(unsigned __int8 *)(a1 + 136) );
    }
    *(_DWORD *)v8 = 2;
    *((_DWORD *)v8 + 1) = 3156;
    v8[8] = 0;
    *((_DWORD *)v8 + 4) = *(_DWORD *)a1;
    v8[20] = *(_BYTE *)(a1 + 136);
    *((_QWORD *)v8 + 3) = *((_QWORD *)v8 + 26);
    *((_QWORD *)v8 + 4) = sub_21008;
    sub_1D7F8((PERESOURCE)(v8 + 216));
    v17 = (char *)qword_2E378 + 56;
    v18 = (char *)qword_2E378 + 72;
    *((_QWORD *)qword_2E378 + 8) = (char *)qword_2E378 + 56;
    *v17 = v17;
    sub_1DE30((__int64)v18);
    v19 = (unsigned int *)qword_2E378;
    memmove((char *)qword_2E378 + 320, a3, 0x20ui64);
    v20 = sub_22A74((__int16 *)(a1 + 4), *(_DWORD *)(a1 + 132), v19 + 4);
    v6 = (void **)off_2E128;
    v9 = v20;
LABEL_57:
    if ( !v9 )
      goto LABEL_68;
    goto LABEL_58;
  }
  if ( v6 == &off_2E128 || !_bittest((const signed __int32 *)v6 + 43, 8u) || *((_BYTE *)v6 + 169) < 2u )
    goto LABEL_12;
  v7 = 13;
LABEL_10:
  sub_11008((__int64)v6[19], v7, (__int64)&unk_2B388);
LABEL_11:
  v6 = (void **)off_2E128;
LABEL_12:
  v8 = (char *)qword_2E378;
  v9 = 4;
LABEL_64:
  if ( v8 )
  {
    v22 = (void *)*((_QWORD *)v8 + 26);
    if ( v22 )
    {
      sub_1D2D8(v22, 0x66634E4Eu);
      v8 = (char *)qword_2E378;
    }
    sub_1D2D8(v8, 0x66634E4Eu);
    v6 = (void **)off_2E128;
    qword_2E378 = 0i64;
  }
LABEL_68:
  if ( v6 != &off_2E128 && _bittest((const signed __int32 *)v6 + 43, 8u) && *((_BYTE *)v6 + 169) >= 5u )
    sub_14544((__int64)v6[19], 0x12u, (__int64)&unk_2B388, v9);
  return v9;
}
// 2E128: using guessed type void *off_2E128;

//----- (00000000000204A8) ----------------------------------------------------
__int64 sub_204A8()
{
  char v0; // di
  void **v1; // rcx
  PVOID v2; // rdx
  unsigned int v3; // ebx
  void *v4; // rcx
  int v5; // eax
  _QWORD *v6; // rax
  unsigned int v7; // eax
  int v8; // eax

  v0 = 0;
  v1 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x13u, (__int64)&unk_2B388);
    v1 = (void **)off_2E128;
  }
  v2 = qword_2E378;
  if ( !qword_2E378 )
  {
    if ( v1 != &off_2E128 && _bittest((const signed __int32 *)v1 + 43, 8u) && *((_BYTE *)v1 + 169) >= 2u )
    {
      sub_11008((__int64)v1[19], 0x14u, (__int64)&unk_2B388);
      v1 = (void **)off_2E128;
    }
    v3 = 16;
    goto LABEL_59;
  }
  if ( *((_QWORD *)qword_2E378 + 5) )
  {
    if ( v1 != &off_2E128 && _bittest((const signed __int32 *)v1 + 43, 8u) && *((_BYTE *)v1 + 169) >= 2u )
    {
      sub_11008((__int64)v1[19], 0x15u, (__int64)&unk_2B388);
      v1 = (void **)off_2E128;
    }
    v3 = 6;
    goto LABEL_59;
  }
  v4 = (void *)*((_QWORD *)qword_2E378 + 26);
  if ( v4 )
  {
    sub_1D2D8(v4, 0x66634E4Eu);
    v2 = qword_2E378;
    *((_QWORD *)qword_2E378 + 26) = 0i64;
  }
  v5 = sub_22EA4(6u, (__int64)v2 + 40);
  v3 = v5;
  if ( v5 )
  {
    v1 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
      && *((_BYTE *)off_2E128 + 169) >= 2u )
    {
      sub_14544(*((_QWORD *)off_2E128 + 19), 0x16u, (__int64)&unk_2B388, v5);
      v1 = (void **)off_2E128;
    }
    goto LABEL_55;
  }
  v6 = (_QWORD *)*((_QWORD *)qword_2E378 + 5);
  if ( !v6 || !*v6 || !v6[1] || !v6[2] || !v6[3] || !v6[4] || !v6[5] || !v6[6] || !v6[7] || !v6[8] || !v6[9] || !v6[10] )
  {
    v3 = 2;
    goto LABEL_58;
  }
  v7 = ((__int64 (__fastcall *)(_QWORD, char *))*v6)(*((unsigned int *)qword_2E378 + 4), (char *)qword_2E378 + 48);
  if ( v7 < 0x700 )
  {
    v0 = sub_25558((PFAST_MUTEX)((char *)qword_2E378 + 128));
    if ( !v0 )
    {
      v1 = (void **)off_2E128;
      if ( off_2E128 != &off_2E128
        && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
        && *((_BYTE *)off_2E128 + 169) >= 2u )
      {
        sub_11008(*((_QWORD *)off_2E128 + 19), 0x18u, (__int64)&unk_2B388);
        v1 = (void **)off_2E128;
      }
      v3 = 9;
LABEL_56:
      if ( !v0 )
        goto LABEL_59;
      sub_255B8((PFAST_MUTEX)((char *)qword_2E378 + 128));
LABEL_58:
      v1 = (void **)off_2E128;
      goto LABEL_59;
    }
    v8 = sub_215C0();
    v3 = v8;
    if ( !v8 )
      goto LABEL_58;
    v1 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
      && *((_BYTE *)off_2E128 + 169) >= 2u )
    {
      sub_14544(*((_QWORD *)off_2E128 + 19), 0x19u, (__int64)&unk_2B388, v8);
      v1 = (void **)off_2E128;
    }
    v3 = 0;
LABEL_55:
    if ( !v3 )
      goto LABEL_59;
    goto LABEL_56;
  }
  v1 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
    && *((_BYTE *)off_2E128 + 169) >= 2u )
  {
    sub_14544(*((_QWORD *)off_2E128 + 19), 0x17u, (__int64)&unk_2B388, v7);
    v1 = (void **)off_2E128;
  }
  v3 = 8;
LABEL_59:
  if ( v1 != &off_2E128 && _bittest((const signed __int32 *)v1 + 43, 8u) && *((_BYTE *)v1 + 169) >= 5u )
    sub_14544((__int64)v1[19], 0x1Au, (__int64)&unk_2B388, v3);
  return v3;
}
// 2E128: using guessed type void *off_2E128;

//----- (00000000000207F0) ----------------------------------------------------
__int64 (**sub_207F0())(void)
{
  void **v0; // rcx
  __int64 (**result)(void); // rax
  unsigned __int16 v2; // dx

  v0 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x1Bu, (__int64)&unk_2B388);
    v0 = (void **)off_2E128;
  }
  result = (__int64 (**)(void))qword_2E378;
  if ( qword_2E378 )
  {
    sub_255B8((PFAST_MUTEX)((char *)qword_2E378 + 128));
    result = (__int64 (**)(void))*((_QWORD *)qword_2E378 + 5);
    if ( result && *((_QWORD *)qword_2E378 + 6) )
    {
      result = (__int64 (**)(void))result[1]();
      *((_QWORD *)qword_2E378 + 6) = 0i64;
    }
    v0 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
      && *((_BYTE *)off_2E128 + 169) >= 5u )
    {
      v2 = 30;
      return (__int64 (**)(void))sub_11008((__int64)v0[19], v2, (__int64)&unk_2B388);
    }
  }
  else if ( v0 != &off_2E128 )
  {
    if ( _bittest((const signed __int32 *)v0 + 43, 8u) && *((_BYTE *)v0 + 169) >= 2u )
    {
      result = (__int64 (**)(void))sub_11008((__int64)v0[19], (unsigned __int16)qword_2E378 + 28, (__int64)&unk_2B388);
      v0 = (void **)off_2E128;
    }
    if ( v0 != &off_2E128 && _bittest((const signed __int32 *)v0 + 43, 8u) && *((_BYTE *)v0 + 169) >= 5u )
    {
      v2 = 29;
      return (__int64 (**)(void))sub_11008((__int64)v0[19], v2, (__int64)&unk_2B388);
    }
  }
  return result;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000002091C) ----------------------------------------------------
void sub_2091C()
{
  void **v0; // rcx
  unsigned __int16 v1; // dx
  char *v2; // rcx
  PVOID *v3; // rax
  _QWORD *v4; // rcx
  _QWORD *v5; // rax
  _QWORD **v6; // rdx

  v0 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x1Fu, (__int64)&unk_2B388);
    v0 = (void **)off_2E128;
  }
  if ( qword_2E378 )
  {
    sub_22FF4();
    v2 = (char *)qword_2E378;
    v3 = (PVOID *)((char *)qword_2E378 + 128);
    if ( qword_2E378 != (PVOID)-128i64 )
    {
      *((_DWORD *)qword_2E378 + 49) = 0;
      if ( v3[7] )
      {
        sub_1DC94(v3[7]);
        v2 = (char *)qword_2E378;
      }
    }
    if ( !*((_QWORD *)v2 + 26) )
      goto LABEL_21;
    v4 = (_QWORD *)*((_QWORD *)v2 + 26);
    while ( 1 )
    {
      sub_1D2D8(v4, 0x66634E4Eu);
      v2 = (char *)qword_2E378;
LABEL_21:
      v6 = (_QWORD **)(v2 + 56);
      if ( *v6 == v6 )
        break;
      v5 = (_QWORD *)**v6;
      v4 = *v6 - 5;
      *v6 = v5;
      v5[1] = v6;
    }
    sub_1D8CC((PERESOURCE)(v2 + 216));
    sub_1D2D8(qword_2E378, 0x66634E4Eu);
    qword_2E378 = 0i64;
    v0 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
      && *((_BYTE *)off_2E128 + 169) >= 5u )
    {
      v1 = 34;
      goto LABEL_26;
    }
  }
  else if ( v0 != &off_2E128 )
  {
    if ( _bittest((const signed __int32 *)v0 + 43, 8u) && *((_BYTE *)v0 + 169) >= 2u )
    {
      sub_11008((__int64)v0[19], 0x20u, (__int64)&unk_2B388);
      v0 = (void **)off_2E128;
    }
    if ( v0 != &off_2E128 && _bittest((const signed __int32 *)v0 + 43, 8u) && *((_BYTE *)v0 + 169) >= 5u )
    {
      v1 = 33;
LABEL_26:
      sub_11008((__int64)v0[19], v1, (__int64)&unk_2B388);
      return;
    }
  }
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000020AD8) ----------------------------------------------------
__int64 __fastcall sub_20AD8(unsigned int a1)
{
  void **v2; // r10
  unsigned __int16 v3; // dx
  unsigned __int8 (__fastcall *v5)(_QWORD, unsigned int *, size_t *, char *); // r11
  __int64 v6; // rcx
  unsigned __int16 v7; // dx
  char *v8; // rbx
  char v9[40]; // [rsp+30h] [rbp-28h] BYREF
  unsigned int Dst; // [rsp+68h] [rbp+10h] BYREF
  size_t MaxCount; // [rsp+70h] [rbp+18h] BYREF
  unsigned int v12; // [rsp+78h] [rbp+20h] BYREF

  Dst = 0;
  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_14544(*((_QWORD *)off_2E128 + 19), 0x2Cu, (__int64)&unk_2B388, a1);
    v2 = (void **)off_2E128;
  }
  if ( !qword_2E378 )
  {
    if ( v2 == &off_2E128 || !_bittest((const signed __int32 *)v2 + 43, 8u) || *((_BYTE *)v2 + 169) < 2u )
      return 0i64;
    v3 = (_WORD)qword_2E378 + 45;
    goto LABEL_10;
  }
  v5 = (unsigned __int8 (__fastcall *)(_QWORD, unsigned int *, size_t *, char *))*((_QWORD *)qword_2E378 + 40);
  if ( !v5 )
  {
    if ( v2 == &off_2E128 || !_bittest((const signed __int32 *)v2 + 43, 8u) || *((_BYTE *)v2 + 169) < 2u )
      return 0i64;
    v3 = 46;
LABEL_10:
    sub_11008((__int64)v2[19], v3, (__int64)&unk_2B388);
    return 0i64;
  }
  if ( (unsigned __int8)(a1 - 1) >= (unsigned int)*((unsigned __int8 *)qword_2E378 + 20) )
  {
    if ( v2 == &off_2E128 || !_bittest((const signed __int32 *)v2 + 43, 8u) || *((_BYTE *)v2 + 169) < 2u )
      return 0i64;
    v6 = (__int64)v2[19];
    v7 = 47;
    goto LABEL_22;
  }
  if ( !v5(a1, &v12, &MaxCount, v9) )
  {
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
      && *((_BYTE *)off_2E128 + 169) >= 2u )
    {
      sub_1E4A0(*((_QWORD *)off_2E128 + 19), 0x30u, (__int64)&unk_2B388, a1);
    }
    return 0i64;
  }
  if ( (unsigned int)MaxCount > 4 )
  {
    if ( off_2E128 == &off_2E128
      || !_bittest((const signed __int32 *)off_2E128 + 43, 8u)
      || *((_BYTE *)off_2E128 + 169) < 2u )
    {
      return 0i64;
    }
    v6 = *((_QWORD *)off_2E128 + 19);
    v7 = 49;
LABEL_22:
    sub_1FE98(v6, v7, (__int64)&unk_2B388, a1);
    return 0i64;
  }
  KeEnterCriticalRegion();
  sub_1DA78((PERESOURCE)((char *)qword_2E378 + 216));
  v8 = (char *)qword_2E378;
  memmove(&Dst, (char *)qword_2E378 + v12 + 352, (unsigned int)MaxCount);
  sub_1DB50((PERESOURCE)(v8 + 216));
  KeLeaveCriticalRegion();
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_14544(*((_QWORD *)off_2E128 + 19), 0x32u, (__int64)&unk_2B388, Dst);
  }
  return Dst;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000020D44) ----------------------------------------------------
char *__fastcall sub_20D44(unsigned int a1)
{
  char *v2; // rbx
  void **v3; // r10
  unsigned int v5; // [rsp+58h] [rbp+10h] BYREF
  char v6; // [rsp+60h] [rbp+18h] BYREF
  char v7; // [rsp+68h] [rbp+20h] BYREF

  v2 = 0i64;
  v3 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_14544(*((_QWORD *)off_2E128 + 19), 0x53u, (__int64)&unk_2B388, a1);
    v3 = (void **)off_2E128;
  }
  if ( qword_2E378 )
  {
    if ( (unsigned __int8)(a1 - 1) < (unsigned int)*((unsigned __int8 *)qword_2E378 + 20) )
    {
      if ( (*((unsigned __int8 (__fastcall **)(_QWORD, unsigned int *, char *, char *))qword_2E378 + 40))(
             a1,
             &v5,
             &v7,
             &v6) )
      {
        KeEnterCriticalRegion();
        sub_1DA78((PERESOURCE)((char *)qword_2E378 + 216));
        v2 = (char *)qword_2E378 + v5 + 352;
      }
      else
      {
        v3 = (void **)off_2E128;
        if ( off_2E128 == &off_2E128 )
          return v2;
        if ( !_bittest((const signed __int32 *)off_2E128 + 43, 8u) || *((_BYTE *)off_2E128 + 169) < 2u )
          goto LABEL_22;
        sub_14544(*((_QWORD *)off_2E128 + 19), 0x56u, (__int64)&unk_2B388, a1);
      }
    }
    else
    {
      if ( v3 == &off_2E128 )
        return v2;
      if ( !_bittest((const signed __int32 *)v3 + 43, 8u) || *((_BYTE *)v3 + 169) < 2u )
        goto LABEL_22;
      sub_1E4A0((__int64)v3[19], 0x55u, (__int64)&unk_2B388, a1);
    }
    goto LABEL_21;
  }
  if ( v3 == &off_2E128 )
    return v2;
  if ( _bittest((const signed __int32 *)v3 + 43, 8u) && *((_BYTE *)v3 + 169) >= 2u )
  {
    sub_11008((__int64)v3[19], 0x54u, (__int64)&unk_2B388);
LABEL_21:
    v3 = (void **)off_2E128;
  }
LABEL_22:
  if ( v3 != &off_2E128 && _bittest((const signed __int32 *)v3 + 43, 8u) && *((_BYTE *)v3 + 169) >= 5u )
    sub_12374((__int64)v3[19], 0x57u, (__int64)&unk_2B388, v2);
  return v2;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000020F24) ----------------------------------------------------
void sub_20F24()
{
  void **v0; // rcx

  v0 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x58u, (__int64)&unk_2B388);
    v0 = (void **)off_2E128;
  }
  if ( qword_2E378 )
  {
    sub_1DB50((PERESOURCE)((char *)qword_2E378 + 216));
    KeLeaveCriticalRegion();
    goto LABEL_11;
  }
  if ( v0 == &off_2E128 )
    return;
  if ( _bittest((const signed __int32 *)v0 + 43, 8u) && *((_BYTE *)v0 + 169) >= 2u )
  {
    sub_11008((__int64)v0[19], (_WORD)qword_2E378 + 89, (__int64)&unk_2B388);
LABEL_11:
    v0 = (void **)off_2E128;
  }
  if ( v0 != &off_2E128 && _bittest((const signed __int32 *)v0 + 43, 8u) && *((_BYTE *)v0 + 169) >= 5u )
    sub_11008((__int64)v0[19], 0x5Au, (__int64)&unk_2B388);
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000021008) ----------------------------------------------------
__int64 __fastcall sub_21008(__int64 a1)
{
  char *v1; // r8
  unsigned int v2; // ebx
  __int64 (__fastcall **v4)(_QWORD, _QWORD); // r13
  __int64 v5; // r14
  int v6; // ebp
  void **v7; // rcx
  _DWORD *v8; // rdi
  unsigned __int16 v10; // dx
  unsigned __int16 v11; // dx
  int v12; // edx
  int *v13; // rdi
  int *v14; // rbp
  int v15; // edi
  int *v16; // rbp
  int v17; // edi

  v1 = (char *)qword_2E378;
  v2 = 0;
  v4 = (__int64 (__fastcall **)(_QWORD, _QWORD))*((_QWORD *)qword_2E378 + 5);
  v5 = *((_QWORD *)qword_2E378 + 6);
  v6 = 0;
  v7 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x5Bu, (__int64)&unk_2B388);
    v1 = (char *)qword_2E378;
    v7 = (void **)off_2E128;
  }
  if ( !a1 )
    goto LABEL_6;
  v8 = *(_DWORD **)(a1 + 56);
  if ( !v8 )
    goto LABEL_6;
  switch ( *v8 )
  {
    case 0:
      v16 = v8 + 1;
      if ( v7 != &off_2E128 && _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 4u )
      {
        sub_11008((__int64)v7[19], 0x5Cu, (__int64)&unk_2B388);
        v1 = (char *)qword_2E378;
        v7 = (void **)off_2E128;
      }
      if ( v8 != (_DWORD *)-4i64 )
      {
        if ( !sub_25618((PFAST_MUTEX)(v1 + 128)) )
          goto LABEL_26;
        v2 = sub_22648(*v16);
        if ( v2 )
          goto LABEL_65;
        v17 = v4[9](v5, (unsigned int)*v16);
        if ( off_2E128 != &off_2E128
          && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
          && *((_BYTE *)off_2E128 + 169) >= 4u )
        {
          sub_1E4A0(*((_QWORD *)off_2E128 + 19), v2 + 93, (__int64)&unk_2B388, *v16);
        }
        sub_25680((PFAST_MUTEX)((char *)qword_2E378 + 128));
        if ( !v17 )
          goto LABEL_26;
        v2 = 8;
        v7 = (void **)off_2E128;
        if ( off_2E128 != &off_2E128 )
        {
          if ( _bittest((const signed __int32 *)off_2E128 + 43, 8u) && *((_BYTE *)off_2E128 + 169) >= 2u )
          {
            v10 = 94;
            goto LABEL_91;
          }
          goto LABEL_93;
        }
        goto LABEL_53;
      }
LABEL_6:
      v2 = 2;
      goto LABEL_93;
    case 1:
      v14 = v8 + 1;
      if ( v7 != &off_2E128 && _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 4u )
      {
        sub_11008((__int64)v7[19], 0x5Fu, (__int64)&unk_2B388);
        v1 = (char *)qword_2E378;
        v7 = (void **)off_2E128;
      }
      if ( v8 != (_DWORD *)-4i64 )
      {
        if ( !sub_25618((PFAST_MUTEX)(v1 + 128)) )
          goto LABEL_26;
        v2 = sub_227A4(*v14);
        if ( v2 )
        {
LABEL_65:
          sub_25680((PFAST_MUTEX)((char *)qword_2E378 + 128));
LABEL_92:
          v7 = (void **)off_2E128;
          goto LABEL_93;
        }
        v15 = v4[10](v5, (unsigned int)*v14);
        if ( off_2E128 != &off_2E128
          && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
          && *((_BYTE *)off_2E128 + 169) >= 4u )
        {
          sub_1E4A0(*((_QWORD *)off_2E128 + 19), 0x60u, (__int64)&unk_2B388, *v14);
        }
        sub_25680((PFAST_MUTEX)((char *)qword_2E378 + 128));
        if ( !v15 )
          goto LABEL_26;
        v2 = 8;
        v7 = (void **)off_2E128;
        if ( off_2E128 != &off_2E128 )
        {
          if ( _bittest((const signed __int32 *)off_2E128 + 43, 8u) && *((_BYTE *)off_2E128 + 169) >= 2u )
          {
            v10 = 97;
            goto LABEL_91;
          }
LABEL_93:
          if ( v7 != &off_2E128 && _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 2u )
            sub_11008((__int64)v7[19], 0x68u, (__int64)&unk_2B388);
          if ( v2 )
            goto LABEL_53;
          goto LABEL_98;
        }
LABEL_53:
        v12 = v2;
        goto LABEL_27;
      }
      goto LABEL_6;
    case 2:
      if ( sub_25618((PFAST_MUTEX)(v1 + 128)) )
      {
        v2 = sub_21C8C(v8[1], v8[2], v8[3], v8 + 4);
        sub_25680((PFAST_MUTEX)((char *)qword_2E378 + 128));
      }
      goto LABEL_53;
    case 3:
      if ( sub_25618((PFAST_MUTEX)(v1 + 128)) )
      {
        v2 = sub_22284((unsigned int)v8[1], v8[2], a1);
        sub_25680((PFAST_MUTEX)((char *)qword_2E378 + 128));
      }
      goto LABEL_28;
    case 4:
      v13 = v8 + 1;
      if ( v7 != &off_2E128 && _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 4u )
      {
        sub_11008((__int64)v7[19], 0x62u, (__int64)&unk_2B388);
        v1 = (char *)qword_2E378;
      }
      if ( sub_25618((PFAST_MUTEX)(v1 + 128)) )
      {
        if ( v13 )
        {
          v6 = v4[8](v5, (unsigned int)*v13);
          if ( off_2E128 != &off_2E128
            && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
            && *((_BYTE *)off_2E128 + 169) >= 4u )
          {
            sub_1E4A0(*((_QWORD *)off_2E128 + 19), 0x63u, (__int64)&unk_2B388, *v13);
          }
        }
        sub_25680((PFAST_MUTEX)((char *)qword_2E378 + 128));
        if ( !v13 || v6 )
        {
          v2 = 8;
          if ( off_2E128 != &off_2E128
            && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
            && *((_BYTE *)off_2E128 + 169) >= 2u )
          {
            sub_11008(*((_QWORD *)off_2E128 + 19), 0x64u, (__int64)&unk_2B388);
          }
        }
      }
      goto LABEL_53;
    case 5:
      if ( v7 == &off_2E128 || !_bittest((const signed __int32 *)v7 + 43, 8u) || *((_BYTE *)v7 + 169) < 4u )
        goto LABEL_26;
      v11 = 101;
      goto LABEL_25;
  }
  if ( *v8 != 6 )
  {
    if ( *((_QWORD *)v1 + 43) )
      return (*((__int64 (__fastcall **)(__int64, _QWORD, char *, void *))v1 + 43))(
               a1,
               (unsigned int)(*v8 - 5),
               v1,
               &unk_2B388);
    if ( v7 == &off_2E128 )
    {
LABEL_98:
      v2 = 17;
      goto LABEL_53;
    }
    if ( _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 3u )
    {
      v10 = 103;
LABEL_91:
      sub_11008((__int64)v7[19], v10, (__int64)&unk_2B388);
      goto LABEL_92;
    }
    goto LABEL_93;
  }
  if ( v7 != &off_2E128 && _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 4u )
  {
    v11 = 102;
LABEL_25:
    sub_11008((__int64)v7[19], v11, (__int64)&unk_2B388);
  }
LABEL_26:
  v12 = 0;
LABEL_27:
  sub_24814(a1, v12, 0, 0i64);
LABEL_28:
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_14544(*((_QWORD *)off_2E128 + 19), 0x69u, (__int64)&unk_2B388, v2);
  }
  return v2;
}
// 2E128: using guessed type void *off_2E128;

//----- (00000000000215C0) ----------------------------------------------------
__int64 sub_215C0()
{
  __int64 v0; // rsi
  __int64 v1; // r15
  unsigned int v2; // er13
  int v3; // eax
  void *v4; // rbp
  void **v5; // r14
  unsigned int v6; // er12
  void (__fastcall *v7)(char *); // rax
  int v8; // eax
  void **v9; // r10
  _DWORD *v10; // r11
  unsigned int i; // er9
  void (__fastcall *v12)(int *); // rax
  PVOID v13; // r11
  int v14; // esi
  unsigned int v15; // eax
  unsigned int v16; // esi
  PVOID v17; // rax
  char *v18; // rbx
  int v19; // eax
  int v20; // ebx
  unsigned int v21; // eax
  unsigned int v22; // ebx
  int v23; // eax
  char *v24; // rsi
  size_t v25; // r8
  void (__fastcall *v26)(int *); // rax
  __int64 v28; // [rsp+20h] [rbp-A8h]
  __int64 v29; // [rsp+28h] [rbp-A0h]
  __int64 v30; // [rsp+30h] [rbp-98h]
  int v31; // [rsp+38h] [rbp-90h]
  char v32[8]; // [rsp+40h] [rbp-88h] BYREF
  void *Src; // [rsp+48h] [rbp-80h] BYREF
  __int64 v34; // [rsp+50h] [rbp-78h]
  int v35[28]; // [rsp+58h] [rbp-70h] BYREF
  _BYTE v36[28]; // [rsp+5Ch] [rbp-6Ch] BYREF
  char v37; // [rsp+D0h] [rbp+8h] BYREF
  size_t MaxCount; // [rsp+D8h] [rbp+10h] BYREF
  unsigned int v39; // [rsp+E0h] [rbp+18h] BYREF
  size_t v40; // [rsp+E8h] [rbp+20h] BYREF

  v0 = *((_QWORD *)qword_2E378 + 6);
  v1 = *((_QWORD *)qword_2E378 + 5);
  v34 = v0;
  v2 = 0;
  v37 = 0;
  v35[0] = 0;
  memset(v36, 0, sizeof(v36));
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x6Au, (__int64)&unk_2B388);
  }
  v3 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))(v1 + 40))(v0, 0i64, &v37);
  if ( !v3 )
  {
    v13 = qword_2E378;
    v20 = *((_DWORD *)qword_2E378 + 4);
    v21 = v20 | *((char *)qword_2E378 + 20);
    v22 = v20 | 1;
    if ( v22 > v21 )
    {
LABEL_73:
      v9 = (void **)off_2E128;
      goto LABEL_74;
    }
    while ( 1 )
    {
      Src = 0i64;
      LODWORD(MaxCount) = 0;
      if ( (*((unsigned __int8 (__fastcall **)(_QWORD, unsigned int *, size_t *, char *, _DWORD))v13 + 40))(
             v22,
             &v39,
             &v40,
             v32,
             v28) )
      {
        v23 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, void **, size_t *))(v1 + 16))(
                v0,
                0i64,
                v22,
                &Src,
                &MaxCount);
        if ( v23 || !Src )
        {
          v9 = (void **)off_2E128;
          if ( off_2E128 != &off_2E128
            && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
            && *((_BYTE *)off_2E128 + 169) >= 2u )
          {
            LODWORD(v28) = v22;
            sub_1E4A0(*((_QWORD *)off_2E128 + 19), 0x70u, (__int64)&unk_2B388, v23);
            v9 = (void **)off_2E128;
          }
          v2 = 8;
          goto LABEL_66;
        }
        if ( off_2E128 != &off_2E128
          && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
          && *((_BYTE *)off_2E128 + 169) >= 4u )
        {
          sub_14544(*((_QWORD *)off_2E128 + 19), 0x71u, (__int64)&unk_2B388, v22);
        }
        KeEnterCriticalRegion();
        LODWORD(v28) = 0;
        sub_1D9A0((PERESOURCE)((char *)qword_2E378 + 216));
        v24 = (char *)qword_2E378;
        v25 = (unsigned int)MaxCount;
        if ( (unsigned int)MaxCount >= (unsigned int)v40 )
          v25 = (unsigned int)v40;
        memmove((char *)qword_2E378 + v39 + 352, Src, v25);
        sub_1DB50((PERESOURCE)(v24 + 216));
        KeLeaveCriticalRegion();
        v0 = v34;
        (*(void (__fastcall **)(__int64, void *))(v1 + 32))(v34, Src);
        v35[(unsigned __int8)(v22 - 1) >> 5] |= 1 << ((v22 - 1) & 0x1F);
      }
      v9 = (void **)off_2E128;
LABEL_66:
      v13 = qword_2E378;
      if ( ++v22 > (*((_DWORD *)qword_2E378 + 4) | (unsigned int)*((char *)qword_2E378 + 20)) )
        goto LABEL_74;
    }
  }
  v4 = 0i64;
  v5 = 0i64;
  v6 = 0;
  if ( v3 == 1879048199 || v3 == 1879048193 )
  {
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
      && *((_BYTE *)off_2E128 + 169) >= 3u )
    {
      sub_14544(*((_QWORD *)off_2E128 + 19), 0x6Bu, (__int64)&unk_2B388, 0);
    }
  }
  else if ( off_2E128 != &off_2E128
         && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
         && *((_BYTE *)off_2E128 + 169) >= 3u )
  {
    LODWORD(v28) = 0;
    sub_1E4A0(*((_QWORD *)off_2E128 + 19), 0x6Cu, (__int64)&unk_2B388, v3);
  }
  v7 = (void (__fastcall *)(char *))*((_QWORD *)qword_2E378 + 41);
  if ( v7 )
    v7((char *)qword_2E378 + 352);
  v8 = (*(__int64 (__fastcall **)(__int64, _QWORD))(v1 + 64))(v0, 0i64);
  if ( v8 )
  {
    v9 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
      && *((_BYTE *)off_2E128 + 169) >= 2u )
    {
      sub_14544(*((_QWORD *)off_2E128 + 19), 0x6Du, (__int64)&unk_2B388, v8);
      v9 = (void **)off_2E128;
    }
    v10 = qword_2E378;
    for ( i = *((_DWORD *)qword_2E378 + 4) | 1; i <= (v10[4] | (unsigned int)*((char *)v10 + 20)); ++i )
      v35[(unsigned __int8)(i - 1) >> 5] |= 1 << ((i - 1) & 0x1F);
    v12 = (void (__fastcall *)(int *))*((_QWORD *)v10 + 42);
    if ( v12 )
    {
      v12(v35);
      v9 = (void **)off_2E128;
    }
    v2 = 8;
    goto LABEL_76;
  }
  v9 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
    && *((_BYTE *)off_2E128 + 169) >= 4u )
  {
    sub_14544(*((_QWORD *)off_2E128 + 19), 0x6Eu, (__int64)&unk_2B388, 0);
    v9 = (void **)off_2E128;
  }
  v13 = qword_2E378;
  v14 = *((_DWORD *)qword_2E378 + 4);
  v15 = v14 | *((char *)qword_2E378 + 20);
  v16 = v14 | 1;
  if ( v16 > v15 )
    goto LABEL_74;
  do
  {
    if ( !(*((unsigned __int8 (__fastcall **)(_QWORD, unsigned int *, size_t *, size_t *, __int64, __int64))v13 + 40))(
            v16,
            &v39,
            &MaxCount,
            &v40,
            v28,
            v29) )
      goto LABEL_44;
    if ( (unsigned int)MaxCount > v6 )
    {
      if ( (unsigned int)MaxCount > 8 )
      {
        if ( v4 )
        {
          v31 = 0;
          v30 = 0i64;
          v29 = 0i64;
          LODWORD(v28) = 1886221390;
          v17 = sub_1D34C(1i64, v4, v6, MaxCount);
        }
        else
        {
          LODWORD(v29) = 0;
          v28 = 0i64;
          v17 = sub_1D254(1, MaxCount, 0x706D744Eu);
        }
        v4 = v17;
        v5 = (void **)v17;
        v6 = v17 != 0i64 ? MaxCount : 0;
      }
      else
      {
        v5 = &Src;
        v6 = 8;
      }
    }
    v35[(unsigned __int8)(v16 - 1) >> 5] |= 1 << ((v16 - 1) & 0x1F);
    if ( !v5 )
    {
      v2 = 3;
LABEL_44:
      v9 = (void **)off_2E128;
      goto LABEL_45;
    }
    KeEnterCriticalRegion();
    sub_1DA78((PERESOURCE)((char *)qword_2E378 + 216));
    v18 = (char *)qword_2E378;
    memmove(v5, (char *)qword_2E378 + v39 + 352, (unsigned int)MaxCount);
    sub_1DB50((PERESOURCE)(v18 + 216));
    KeLeaveCriticalRegion();
    LODWORD(v29) = MaxCount;
    v19 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, void **, __int64, __int64, int))(v1 + 24))(
            v34,
            0i64,
            0i64,
            v16,
            v5,
            v29,
            v30,
            v31);
    if ( !v19 )
      goto LABEL_44;
    v9 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
      && *((_BYTE *)off_2E128 + 169) >= 4u )
    {
      LODWORD(v28) = v16;
      sub_1E4A0(*((_QWORD *)off_2E128 + 19), 0x6Fu, (__int64)&unk_2B388, v19);
      v9 = (void **)off_2E128;
    }
    v2 = 8;
LABEL_45:
    v13 = qword_2E378;
    ++v16;
  }
  while ( v16 <= (*((_DWORD *)qword_2E378 + 4) | (unsigned int)*((char *)qword_2E378 + 20)) );
  if ( v4 )
  {
    sub_1D2D8(v4, 0x706D744Eu);
    v13 = qword_2E378;
    goto LABEL_73;
  }
LABEL_74:
  v26 = (void (__fastcall *)(int *))*((_QWORD *)v13 + 42);
  if ( v26 )
  {
    v26(v35);
    v9 = (void **)off_2E128;
  }
LABEL_76:
  if ( v9 != &off_2E128 && _bittest((const signed __int32 *)v9 + 43, 8u) && *((_BYTE *)v9 + 169) >= 5u )
    sub_14544((__int64)v9[19], 0x72u, (__int64)&unk_2B388, v2);
  return v2;
}
// 21846: variable 'v28' is possibly undefined
// 21846: variable 'v29' is possibly undefined
// 219C3: variable 'v30' is possibly undefined
// 219C3: variable 'v31' is possibly undefined
// 2E128: using guessed type void *off_2E128;
// 215C0: using guessed type int var_70[28];

//----- (0000000000021C8C) ----------------------------------------------------
__int64 __fastcall sub_21C8C(unsigned int a1, int a2, unsigned int a3, _DWORD *a4)
{
  _QWORD *v4; // rsi
  __int64 v6; // rax
  __int64 v7; // r15
  _QWORD *v9; // r14
  unsigned int v10; // ebx
  void **v13; // rcx
  _QWORD *i; // rax
  char *v16; // rsi
  size_t v17; // r8
  char *v18; // rcx
  _QWORD *v19; // rax
  void (__fastcall *v20)(int *); // rdx
  int v21; // eax
  _QWORD *v22; // rcx
  unsigned __int16 v23; // dx
  __int64 v24; // r9
  _QWORD *v25; // rcx
  unsigned __int16 v26; // dx
  unsigned __int64 v27; // r11
  __int64 v28; // rcx
  int v29; // eax
  int v30; // [rsp+20h] [rbp-78h]
  __int64 v31; // [rsp+20h] [rbp-78h]
  __int64 v32; // [rsp+20h] [rbp-78h]
  __int64 v33; // [rsp+20h] [rbp-78h]
  unsigned int v34; // [rsp+28h] [rbp-70h]
  __int64 v35; // [rsp+28h] [rbp-70h]
  _DWORD *v36; // [rsp+30h] [rbp-68h]
  unsigned int v37; // [rsp+40h] [rbp-58h] BYREF
  int v38; // [rsp+44h] [rbp-54h] BYREF
  __int64 v39; // [rsp+48h] [rbp-50h]
  int v40[8]; // [rsp+50h] [rbp-48h] BYREF
  _BYTE v41[28]; // [rsp+54h] [rbp-44h] BYREF
  size_t MaxCount; // [rsp+A0h] [rbp+8h] BYREF

  v4 = qword_2E378;
  v6 = *((_QWORD *)qword_2E378 + 6);
  v7 = *((_QWORD *)qword_2E378 + 5);
  v9 = 0i64;
  v10 = 0;
  v37 = 0;
  LODWORD(MaxCount) = 0;
  v40[0] = 0;
  v39 = v6;
  memset(v41, 0, sizeof(v41));
  v13 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( _bittest((const signed __int32 *)off_2E128 + 43, 8u) && *((_BYTE *)off_2E128 + 169) >= 4u )
    {
      v36 = a4;
      v34 = a3;
      v30 = a2;
      sub_1FEF4(*((_QWORD *)off_2E128 + 19), 115i64, (__int64)&unk_2B388, a1);
      v4 = qword_2E378;
      v13 = (void **)off_2E128;
    }
    if ( v13 != &off_2E128 && _bittest((const signed __int32 *)v13 + 43, 8u) && *((_BYTE *)v13 + 169) >= 4u )
    {
      sub_11008((__int64)v13[19], 0x74u, (__int64)&unk_2B388);
      v4 = qword_2E378;
      v13 = (void **)off_2E128;
    }
  }
  if ( a1 )
  {
    for ( i = (_QWORD *)v4[7]; i != v4 + 7; i = (_QWORD *)*i )
    {
      v9 = i - 5;
      if ( *((_DWORD *)i - 10) == a1 )
        goto LABEL_15;
    }
    v9 = 0i64;
LABEL_15:
    if ( !v9 )
    {
      if ( v13 != &off_2E128 && _bittest((const signed __int32 *)v13 + 43, 8u) && *((_BYTE *)v13 + 169) >= 2u )
        sub_14544((__int64)v13[19], 0x75u, (__int64)&unk_2B388, a1);
      return 4i64;
    }
  }
  if ( !((unsigned __int8 (__fastcall *)(_QWORD, unsigned int *, size_t *, int *, int, unsigned int))v4[40])(
          a3,
          &v37,
          &MaxCount,
          &v38,
          v30,
          v34) )
  {
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
      && *((_BYTE *)off_2E128 + 169) >= 2u )
    {
      sub_14544(*((_QWORD *)off_2E128 + 19), 0x76u, (__int64)&unk_2B388, a3);
    }
    return 4i64;
  }
  if ( a1 )
  {
    v16 = (char *)v9 + v37 + 56;
    sub_1DF10((PFAST_MUTEX)((char *)qword_2E378 + 72));
  }
  else
  {
    v16 = (char *)qword_2E378 + v37 + 352;
    KeEnterCriticalRegion();
    sub_1D9A0((PERESOURCE)((char *)qword_2E378 + 216));
  }
  if ( v38 < 0 )
    goto LABEL_34;
  if ( v38 <= 1 )
    goto LABEL_77;
  if ( v38 == 2 )
  {
    if ( a4 )
    {
      v24 = (unsigned int)*a4;
      if ( 2 * v24 <= (unsigned __int64)(unsigned int)MaxCount )
      {
        memmove(v16, a4 + 1, 2 * v24);
        v27 = 2i64 * (unsigned int)*a4;
        if ( v27 >= (unsigned int)MaxCount )
          goto LABEL_44;
        v17 = (unsigned int)MaxCount - v27;
        v18 = &v16[v27];
        goto LABEL_43;
      }
      v22 = off_2E128;
      if ( off_2E128 == &off_2E128
        || !_bittest((const signed __int32 *)off_2E128 + 43, 8u)
        || *((_BYTE *)off_2E128 + 169) < 2u )
      {
LABEL_64:
        v10 = 6;
        goto LABEL_44;
      }
      v23 = 121;
LABEL_58:
      LODWORD(v31) = a3;
      sub_1FD74(v22[19], v23, (__int64)&unk_2B388, v24, v31, 0);
      goto LABEL_64;
    }
    v25 = off_2E128;
    if ( off_2E128 == &off_2E128
      || !_bittest((const signed __int32 *)off_2E128 + 43, 8u)
      || *((_BYTE *)off_2E128 + 169) < 2u )
    {
      goto LABEL_64;
    }
    v26 = 122;
LABEL_63:
    sub_11008(v25[19], v26, (__int64)&unk_2B388);
    goto LABEL_64;
  }
  if ( v38 > 4 )
  {
    if ( v38 > 7 )
    {
LABEL_34:
      if ( off_2E128 != &off_2E128
        && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
        && *((_BYTE *)off_2E128 + 169) >= 2u )
      {
        sub_11008(*((_QWORD *)off_2E128 + 19), 0x7Bu, (__int64)&unk_2B388);
      }
      v10 = 4;
      goto LABEL_44;
    }
LABEL_77:
    memmove(v16, a4, (unsigned int)MaxCount);
    goto LABEL_44;
  }
  if ( !a4 )
  {
    v25 = off_2E128;
    if ( off_2E128 == &off_2E128
      || !_bittest((const signed __int32 *)off_2E128 + 43, 8u)
      || *((_BYTE *)off_2E128 + 169) < 2u )
    {
      goto LABEL_64;
    }
    v26 = 120;
    goto LABEL_63;
  }
  if ( *a4 > (unsigned int)MaxCount )
  {
    v22 = off_2E128;
    if ( off_2E128 == &off_2E128
      || !_bittest((const signed __int32 *)off_2E128 + 43, 8u)
      || *((_BYTE *)off_2E128 + 169) < 2u )
    {
      goto LABEL_64;
    }
    v23 = 119;
    LODWORD(v24) = *a4;
    goto LABEL_58;
  }
  memmove(v16, a4 + 1, (unsigned int)*a4);
  if ( *a4 < (unsigned int)MaxCount )
  {
    v17 = (unsigned int)(MaxCount - *a4);
    v18 = &v16[*a4];
LABEL_43:
    memset(v18, 0, v17);
  }
LABEL_44:
  if ( a1 )
  {
    if ( !v10 )
    {
      v28 = v39;
      *((_DWORD *)v9 + (((a3 - 1) >> 5) & 7) + 1) |= 1 << ((a3 - 1) & 0x1F);
      v29 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, char *, _DWORD))(v7 + 24))(
              v28,
              a1,
              0i64,
              a3,
              v16,
              MaxCount);
      if ( v29 )
      {
        if ( off_2E128 != &off_2E128
          && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
          && *((_BYTE *)off_2E128 + 169) >= 2u )
        {
          LODWORD(v35) = a3;
          LODWORD(v33) = a1;
          sub_1FDD4(*((_QWORD *)off_2E128 + 19), 125i64, (__int64)&unk_2B388, v29, v33, v35, 0);
        }
        v10 = 8;
      }
    }
    sub_1DFDC((PFAST_MUTEX)((char *)qword_2E378 + 72));
  }
  else
  {
    sub_1DB50((PERESOURCE)((char *)qword_2E378 + 216));
    KeLeaveCriticalRegion();
    if ( !v10 )
    {
      v19 = qword_2E378;
      v40[((a3 - 1) >> 5) & 7] |= 1 << ((a3 - 1) & 0x1F);
      v20 = (void (__fastcall *)(int *))v19[42];
      if ( v20 )
        v20(v40);
      v21 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, char *, _DWORD, _DWORD *))(v7 + 24))(
              v39,
              0i64,
              0i64,
              a3,
              v16,
              MaxCount,
              v36);
      if ( v21 )
      {
        if ( off_2E128 != &off_2E128
          && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
          && *((_BYTE *)off_2E128 + 169) >= 2u )
        {
          LODWORD(v32) = a3;
          sub_1FD74(*((_QWORD *)off_2E128 + 19), 0x7Cu, (__int64)&unk_2B388, v21, v32, 0);
        }
        v10 = 8;
      }
    }
  }
  return v10;
}
// 21EDC: conditional instruction was optimized away because of 'eax.4>=3'
// 21E0E: variable 'v30' is possibly undefined
// 21E0E: variable 'v34' is possibly undefined
// 21FFD: variable 'v36' is possibly undefined
// 22047: variable 'v32' is possibly undefined
// 2209A: variable 'v31' is possibly undefined
// 2223B: variable 'v33' is possibly undefined
// 2223B: variable 'v35' is possibly undefined
// 2E128: using guessed type void *off_2E128;
// 21C8C: using guessed type int var_48[8];

//----- (0000000000022284) ----------------------------------------------------
__int64 __fastcall sub_22284(__int64 a1, unsigned int a2, __int64 a3)
{
  unsigned int v5; // ebx
  void **v6; // rcx
  void **v7; // rcx
  int v8; // edx
  char *v9; // rbp
  unsigned int v10; // er8
  __int64 *v11; // r9
  unsigned int v12; // er12
  _DWORD *v13; // rsi
  unsigned __int16 v14; // dx
  int v15; // eax
  __int64 Dst; // [rsp+30h] [rbp-38h] BYREF
  unsigned int v18; // [rsp+38h] [rbp-30h] BYREF
  int v19; // [rsp+3Ch] [rbp-2Ch] BYREF
  size_t MaxCount; // [rsp+88h] [rbp+20h] BYREF

  v5 = 0;
  v6 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( _bittest((const signed __int32 *)off_2E128 + 43, 8u) && *((_BYTE *)off_2E128 + 169) >= 5u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x7Eu, (__int64)&unk_2B388);
      v6 = (void **)off_2E128;
    }
    if ( v6 != &off_2E128 && _bittest((const signed __int32 *)v6 + 43, 8u) && *((_BYTE *)v6 + 169) >= 4u )
      sub_14544((__int64)v6[19], 0x7Fu, (__int64)&unk_2B388, a2);
  }
  if ( !(*((unsigned __int8 (__fastcall **)(_QWORD, unsigned int *, size_t *, int *))qword_2E378 + 40))(
          a2,
          &v18,
          &MaxCount,
          &v19) )
  {
    v7 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128 )
    {
      if ( _bittest((const signed __int32 *)off_2E128 + 43, 8u) && *((_BYTE *)off_2E128 + 169) >= 2u )
      {
        sub_14544(*((_QWORD *)off_2E128 + 19), 0x80u, (__int64)&unk_2B388, a2);
LABEL_46:
        v7 = (void **)off_2E128;
      }
LABEL_47:
      if ( v7 != &off_2E128 && _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 2u )
        sub_11008((__int64)v7[19], 0x85u, (__int64)&unk_2B388);
    }
LABEL_51:
    v8 = 17;
LABEL_52:
    v11 = 0i64;
    v5 = v8;
    v10 = 0;
    goto LABEL_53;
  }
  if ( !(_DWORD)MaxCount )
  {
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
      && *((_BYTE *)off_2E128 + 169) >= 2u )
    {
      sub_14544(*((_QWORD *)off_2E128 + 19), 0x81u, (__int64)&unk_2B388, a2);
    }
    v8 = 12;
    goto LABEL_52;
  }
  v9 = (char *)qword_2E378 + v18 + 352;
  if ( v19 < 0 )
  {
LABEL_41:
    v7 = (void **)off_2E128;
    if ( off_2E128 == &off_2E128 )
      goto LABEL_51;
    if ( !_bittest((const signed __int32 *)off_2E128 + 43, 8u) || *((_BYTE *)off_2E128 + 169) < 2u )
      goto LABEL_47;
    v14 = 132;
    goto LABEL_45;
  }
  if ( v19 <= 1 )
  {
LABEL_40:
    LODWORD(Dst) = 0;
    memmove(&Dst, (char *)qword_2E378 + v18 + 352, (unsigned int)MaxCount);
    v8 = 0;
    v10 = 4;
    v11 = &Dst;
    goto LABEL_53;
  }
  if ( v19 == 2 )
  {
    v12 = MaxCount + 4;
    v13 = sub_1D254(1, (int)MaxCount + 4, 0x66634E4Eu);
    if ( !v13 )
    {
      v7 = (void **)off_2E128;
      if ( off_2E128 == &off_2E128 )
        goto LABEL_51;
      if ( !_bittest((const signed __int32 *)off_2E128 + 43, 8u) || *((_BYTE *)off_2E128 + 169) < 2u )
        goto LABEL_47;
      v14 = 131;
      goto LABEL_45;
    }
    v15 = (unsigned int)MaxCount >> 1;
  }
  else
  {
    if ( v19 > 4 )
    {
      if ( v19 > 6 )
      {
        if ( v19 == 7 )
        {
          Dst = 0i64;
          memmove(&Dst, (char *)qword_2E378 + v18 + 352, (unsigned int)MaxCount);
          v8 = 0;
          v10 = 8;
          v11 = &Dst;
LABEL_53:
          sub_24814(a3, v8, v10, v11);
          goto LABEL_54;
        }
        goto LABEL_41;
      }
      goto LABEL_40;
    }
    v12 = MaxCount + 4;
    v13 = sub_1D254(1, (int)MaxCount + 4, 0x66634E4Eu);
    if ( !v13 )
    {
      v7 = (void **)off_2E128;
      if ( off_2E128 == &off_2E128 )
        goto LABEL_51;
      if ( !_bittest((const signed __int32 *)off_2E128 + 43, 8u) || *((_BYTE *)off_2E128 + 169) < 2u )
        goto LABEL_47;
      v14 = 130;
LABEL_45:
      sub_11008((__int64)v7[19], v14, (__int64)&unk_2B388);
      goto LABEL_46;
    }
    v15 = MaxCount;
  }
  *v13 = v15;
  memmove(v13 + 1, v9, (unsigned int)MaxCount);
  sub_24814(a3, 0, v12, v13);
  sub_1D2D8(v13, 0x66634E4Eu);
LABEL_54:
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_14544(*((_QWORD *)off_2E128 + 19), 0x86u, (__int64)&unk_2B388, v5);
  }
  return v5;
}
// 22408: conditional instruction was optimized away because of 'eax.4>=3'
// 2E128: using guessed type void *off_2E128;

//----- (0000000000022648) ----------------------------------------------------
__int64 __fastcall sub_22648(int a1)
{
  unsigned int v1; // edi
  char *v4; // r10
  char *i; // rax
  char *v6; // rax
  _DWORD *v7; // rax
  _QWORD *v8; // rsi
  char *v9; // rbx
  _QWORD *v10; // rdx
  __int64 v11; // rcx

  v1 = 0;
  if ( !a1 )
    return 6i64;
  sub_1DF10((PFAST_MUTEX)((char *)qword_2E378 + 72));
  v4 = (char *)qword_2E378;
  for ( i = (char *)*((_QWORD *)qword_2E378 + 7); i != (char *)qword_2E378 + 56; i = (char *)*((_QWORD *)v6 + 5) )
  {
    v6 = i - 40;
    if ( *(_DWORD *)v6 == a1 )
      goto LABEL_8;
  }
  v6 = 0i64;
LABEL_8:
  if ( v6 )
  {
    v1 = 6;
  }
  else
  {
    v7 = sub_1D254(1, *((_DWORD *)qword_2E378 + 1) + 56, 0x66634E4Eu);
    v8 = v7;
    if ( v7 )
    {
      *v7 = a1;
      memset(v7 + 1, 0, 0x20ui64);
      KeEnterCriticalRegion();
      sub_1DA78((PERESOURCE)((char *)qword_2E378 + 216));
      v9 = (char *)qword_2E378;
      memmove(v8 + 7, (char *)qword_2E378 + 352, *((unsigned int *)qword_2E378 + 1));
      sub_1DB50((PERESOURCE)(v9 + 216));
      KeLeaveCriticalRegion();
      v4 = (char *)qword_2E378;
      v10 = (char *)qword_2E378 + 56;
      v11 = *((_QWORD *)qword_2E378 + 7);
      v8[6] = (char *)qword_2E378 + 56;
      v8[5] = v11;
      *(_QWORD *)(v11 + 8) = v8 + 5;
      *v10 = v8 + 5;
    }
    else
    {
      v4 = (char *)qword_2E378;
      v1 = 3;
    }
  }
  sub_1DFDC((PFAST_MUTEX)(v4 + 72));
  return v1;
}

//----- (00000000000227A4) ----------------------------------------------------
__int64 __fastcall sub_227A4(int a1)
{
  __int64 result; // rax
  char *v3; // r11
  _QWORD *i; // rax
  char *v5; // rdi
  __int64 v6; // rcx
  _QWORD *v7; // rax
  char *v8; // rbx
  void (__fastcall *v9)(char *); // rax

  if ( !a1 )
    return 6i64;
  sub_1DF10((PFAST_MUTEX)((char *)qword_2E378 + 72));
  v3 = (char *)qword_2E378;
  for ( i = (_QWORD *)*((_QWORD *)qword_2E378 + 7); i != (_QWORD *)((char *)qword_2E378 + 56); i = (_QWORD *)*i )
  {
    v5 = (char *)(i - 5);
    if ( *((_DWORD *)i - 10) == a1 )
      goto LABEL_8;
  }
  v5 = 0i64;
LABEL_8:
  if ( v5 )
  {
    v6 = *((_QWORD *)v5 + 5);
    v7 = (_QWORD *)*((_QWORD *)v5 + 6);
    *v7 = v6;
    *(_QWORD *)(v6 + 8) = v7;
    sub_1DFDC((PFAST_MUTEX)(v3 + 72));
    KeEnterCriticalRegion();
    sub_1D9A0((PERESOURCE)((char *)qword_2E378 + 216));
    v8 = (char *)qword_2E378;
    memmove((char *)qword_2E378 + 352, v5 + 56, *((unsigned int *)qword_2E378 + 1));
    sub_1DB50((PERESOURCE)(v8 + 216));
    KeLeaveCriticalRegion();
    v9 = (void (__fastcall *)(char *))*((_QWORD *)qword_2E378 + 42);
    if ( v9 )
      v9(v5 + 4);
    sub_1D2D8(v5, 0x66634E4Eu);
    result = 0i64;
  }
  else
  {
    sub_1DFDC((PFAST_MUTEX)((char *)qword_2E378 + 72));
    result = 5i64;
  }
  return result;
}

//----- (00000000000228CC) ----------------------------------------------------
__int64 __fastcall sub_228CC(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4)
{
  __int64 v5; // rcx
  const wchar_t *v6; // rdi
  bool v7; // zf

  if ( a4 && *a4 )
  {
    v5 = -1i64;
    v6 = a4;
    do
    {
      if ( !v5 )
        break;
      v7 = *v6++ == 0;
      --v5;
    }
    while ( !v7 );
  }
  if ( a4 )
  {
    if ( !*a4 )
      a4 = L"<NULL>";
  }
  else
  {
    a4 = L"NULL";
  }
  return qword_2E198(a1, 43i64, &unk_2B378, 71i64, a4);
}
// 2B430: using guessed type wchar_t aNull_1[7];
// 2B440: using guessed type wchar_t aNull_2[5];
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002297C) ----------------------------------------------------
__int64 sub_2297C(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+98h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2E198(a1, 43i64, &unk_2B378, 134i64, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000229E8) ----------------------------------------------------
__int64 sub_229E8(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 v5; // [rsp+78h] [rbp+20h] BYREF
  va_list va; // [rsp+78h] [rbp+20h]
  const char *v7; // [rsp+80h] [rbp+28h]
  va_list va1; // [rsp+88h] [rbp+30h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, const char *);
  if ( v7 )
    strlen(v7);
  return qword_2E198(a1, 43i64, &unk_2B378, 310i64, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000022A74) ----------------------------------------------------
__int64 __fastcall sub_22A74(__int16 *a1, int a2, unsigned int *a3)
{
  void **v6; // rbx
  __int64 v7; // rcx
  unsigned __int16 v8; // dx

  v6 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0xAu, (__int64)&unk_2B378);
    v6 = (void **)off_2E128;
  }
  if ( !byte_2E7E2 )
  {
    memset(&qword_2E380, 0, 0x470ui64);
    if ( a3 )
    {
      if ( !(unsigned int)sub_245CC(a3) )
      {
        dword_2E7D8 = 0;
        dword_2E7DC = 0;
        byte_2E7E3 = 0;
        byte_2E7E0 = 0;
        byte_2E7E1 = 0;
        sub_2A40C(word_2E3A0, 520i64, a1);
        dword_2E7B0 = a2;
        byte_2E7E2 = 1;
        sub_22C48(1);
        if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
          sub_14544(*((_QWORD *)off_2E128 + 19), 0xEu, (__int64)&unk_2B378, 0);
        return 0i64;
      }
      if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 172) & 1) == 0 || *((_BYTE *)off_2E128 + 169) < 2u )
        return 264i64;
      v7 = *((_QWORD *)off_2E128 + 19);
      v8 = 13;
    }
    else
    {
      if ( v6 == &off_2E128 || (*((_BYTE *)v6 + 172) & 1) == 0 || *((_BYTE *)v6 + 169) < 2u )
        return 264i64;
      v7 = (__int64)v6[19];
      v8 = 12;
    }
    sub_11008(v7, v8, (__int64)&unk_2B378);
    return 264i64;
  }
  if ( v6 != &off_2E128 && (*((_BYTE *)v6 + 172) & 1) != 0 && *((_BYTE *)v6 + 169) >= 2u )
    sub_11008((__int64)v6[19], 0xBu, (__int64)&unk_2B378);
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;
// 2E7B0: using guessed type int dword_2E7B0;
// 2E7D8: using guessed type int dword_2E7D8;
// 2E7DC: using guessed type int dword_2E7DC;
// 2E7E0: using guessed type char byte_2E7E0;
// 2E7E1: using guessed type char byte_2E7E1;
// 2E7E2: using guessed type char byte_2E7E2;
// 2E7E3: using guessed type char byte_2E7E3;

//----- (0000000000022C48) ----------------------------------------------------
__int64 __fastcall sub_22C48(char a1)
{
  void **v2; // rcx

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0xFu, (__int64)&unk_2B378);
    v2 = (void **)off_2E128;
  }
  byte_2E7E4 = a1;
  if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 172) & 1) != 0 && *((_BYTE *)v2 + 169) >= 5u )
    sub_14544((__int64)v2[19], 0x10u, (__int64)&unk_2B378, 0);
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;
// 2E7E4: using guessed type char byte_2E7E4;

//----- (0000000000022CE4) ----------------------------------------------------
__int64 sub_22CE4()
{
  void **v0; // rcx
  _QWORD *v2; // rcx
  unsigned __int16 v3; // dx

  v0 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x1Bu, (__int64)&unk_2B378);
    v0 = (void **)off_2E128;
  }
  if ( !byte_2E7E2 )
  {
    if ( v0 != &off_2E128 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
      sub_11008((__int64)v0[19], 0x1Cu, (__int64)&unk_2B378);
    return 258i64;
  }
  if ( !dword_2E7D8 && !dword_2E7DC && v0 != &off_2E128 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
    sub_11008((__int64)v0[19], 0x1Du, (__int64)&unk_2B378);
  if ( (unsigned int)sub_23264() )
  {
    v2 = off_2E128;
    if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 172) & 1) == 0 || *((_BYTE *)off_2E128 + 169) < 2u )
      return 257i64;
    v3 = 30;
LABEL_22:
    sub_11008(v2[19], v3, (__int64)&unk_2B378);
    return 257i64;
  }
  if ( (unsigned int)sub_238B0() )
  {
    v2 = off_2E128;
    if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 172) & 1) == 0 || *((_BYTE *)off_2E128 + 169) < 2u )
      return 257i64;
    v3 = 31;
    goto LABEL_22;
  }
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 4u )
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x20u, (__int64)&unk_2B378);
  sub_25320();
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
    sub_14544(*((_QWORD *)off_2E128 + 19), 0x21u, (__int64)&unk_2B378, 0);
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;
// 2E7D8: using guessed type int dword_2E7D8;
// 2E7DC: using guessed type int dword_2E7DC;
// 2E7E2: using guessed type char byte_2E7E2;

//----- (0000000000022EA4) ----------------------------------------------------
__int64 __fastcall sub_22EA4(unsigned int a1, __int64 a2)
{
  void **v4; // rcx
  __int64 result; // rax
  int v6; // eax

  v4 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x35u, (__int64)&unk_2B378);
    v4 = (void **)off_2E128;
  }
  if ( byte_2E7E3 )
  {
    if ( qword_2E7B8 && a2 )
    {
      v6 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(*((_QWORD *)qword_2E7B8 + 1) + 8i64))(
             **((_QWORD **)qword_2E7B8 + 1),
             a1,
             a2);
      v4 = (void **)off_2E128;
    }
    else
    {
      v6 = 1796;
    }
    if ( v6 )
    {
      if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 2u )
        sub_14544((__int64)v4[19], 0x37u, (__int64)&unk_2B378, v6);
      result = 257i64;
    }
    else
    {
      if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 5u )
        sub_14544((__int64)v4[19], 0x38u, (__int64)&unk_2B378, 0);
      result = 0i64;
    }
  }
  else
  {
    if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x36u, (__int64)&unk_2B378);
    result = 260i64;
  }
  return result;
}
// 2E128: using guessed type void *off_2E128;
// 2E7E3: using guessed type char byte_2E7E3;

//----- (0000000000022FF4) ----------------------------------------------------
__int64 sub_22FF4()
{
  void **v0; // rcx
  int v2; // eax
  unsigned int v3; // edi
  void **v4; // rbx
  PVOID *v5; // rcx
  PVOID *v6; // rcx

  v0 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x39u, (__int64)&unk_2B378);
    v0 = (void **)off_2E128;
  }
  if ( byte_2E7E2 )
  {
    v2 = sub_24014();
    v3 = v2;
    if ( v2 )
    {
      v4 = (void **)off_2E128;
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 2u )
      {
        sub_14544(*((_QWORD *)off_2E128 + 19), 0x3Bu, (__int64)&unk_2B378, v2);
        v4 = (void **)off_2E128;
      }
      if ( v3 != 260 )
        return v3;
    }
    else
    {
      v4 = (void **)off_2E128;
    }
    if ( dword_2E7D8 )
    {
      v5 = (PVOID *)qword_2E380;
      if ( qword_2E380 != &qword_2E380 )
      {
        do
        {
          qword_2E380 = *v5;
          *((_QWORD *)qword_2E380 + 1) = &qword_2E380;
          sub_1D2D8(v5, 0x74785072u);
          v5 = (PVOID *)qword_2E380;
        }
        while ( qword_2E380 != &qword_2E380 );
        v4 = (void **)off_2E128;
      }
    }
    if ( dword_2E7DC )
    {
      v6 = (PVOID *)qword_2E390;
      if ( qword_2E390 != &qword_2E390 )
      {
        do
        {
          qword_2E390 = *v6;
          *((_QWORD *)qword_2E390 + 1) = &qword_2E390;
          sub_1D2D8(v6, 0x746D436Eu);
          v6 = (PVOID *)qword_2E390;
        }
        while ( qword_2E390 != &qword_2E390 );
        v4 = (void **)off_2E128;
      }
    }
    if ( qword_2E7C8 && byte_2E7E0 == 1 )
    {
      sub_1D2D8(qword_2E7C8, 0x74785072u);
      qword_2E7C8 = 0i64;
      v4 = (void **)off_2E128;
    }
    if ( qword_2E7D0 && byte_2E7E1 == 1 )
    {
      sub_1D2D8(qword_2E7D0, 0x746D436Eu);
      v4 = (void **)off_2E128;
    }
    memset(&qword_2E380, 0, 0x470ui64);
    if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 5u )
      sub_14544((__int64)v4[19], 0x3Cu, (__int64)&unk_2B378, v3);
    return v3;
  }
  if ( v0 != &off_2E128 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
    sub_11008((__int64)v0[19], 0x3Au, (__int64)&unk_2B378);
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;
// 2E7D8: using guessed type int dword_2E7D8;
// 2E7DC: using guessed type int dword_2E7DC;
// 2E7E0: using guessed type char byte_2E7E0;
// 2E7E1: using guessed type char byte_2E7E1;
// 2E7E2: using guessed type char byte_2E7E2;

//----- (0000000000023264) ----------------------------------------------------
__int64 sub_23264()
{
  void **v0; // rcx
  PVOID v1; // rax
  PVOID v3; // rax

  v0 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x3Du, (__int64)&unk_2B378);
    v0 = (void **)off_2E128;
  }
  if ( dword_2E7D8 )
  {
    v1 = sub_1D254(2, 0x1340u, 0x74785072u);
    qword_2E7C8 = v1;
    if ( !v1 )
      return 3i64;
    memset(v1, 0, 0x1340ui64);
    if ( (unsigned int)sub_234EC(0) )
    {
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 4u )
        sub_11008(*((_QWORD *)off_2E128 + 19), 0x3Eu, (__int64)&unk_2B378);
      sub_1D2D8(qword_2E7C8, 0x74785072u);
      qword_2E7C8 = 0i64;
      return 1i64;
    }
    v0 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 4u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x3Fu, (__int64)&unk_2B378);
      v0 = (void **)off_2E128;
    }
    byte_2E7E0 = 1;
  }
  if ( dword_2E7DC )
  {
    v3 = sub_1D254(2, 0x9A0u, 0x746D436Eu);
    qword_2E7D0 = v3;
    if ( v3 )
    {
      memset(v3, 0, 0x9A0ui64);
      if ( (unsigned int)sub_234EC(1) )
      {
        if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 4u )
          sub_11008(*((_QWORD *)off_2E128 + 19), 0x40u, (__int64)&unk_2B378);
        sub_1D2D8(qword_2E7D0, 0x746D436Eu);
        qword_2E7D0 = 0i64;
        return 1i64;
      }
      v0 = (void **)off_2E128;
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 4u )
      {
        sub_11008(*((_QWORD *)off_2E128 + 19), 0x41u, (__int64)&unk_2B378);
        v0 = (void **)off_2E128;
      }
      byte_2E7E1 = 1;
      goto LABEL_33;
    }
    return 3i64;
  }
LABEL_33:
  if ( v0 != &off_2E128 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 5u )
    sub_14544((__int64)v0[19], 0x42u, (__int64)&unk_2B378, 0);
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;
// 2E7D8: using guessed type int dword_2E7D8;
// 2E7DC: using guessed type int dword_2E7DC;
// 2E7E0: using guessed type char byte_2E7E0;
// 2E7E1: using guessed type char byte_2E7E1;

//----- (00000000000234EC) ----------------------------------------------------
__int64 __fastcall sub_234EC(int a1)
{
  unsigned int v2; // edi
  void **v3; // rcx
  PVOID *j; // rbx
  int v5; // edx
  unsigned int v6; // er9
  unsigned __int64 v7; // r8
  PVOID *i; // rbx
  unsigned int v9; // er9
  __int64 v10; // r8
  __int64 (__fastcall *v11)(__int64, __int64, __int64); // rcx
  int v12; // eax

  v2 = 0;
  v3 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x43u, (__int64)&unk_2B378);
    v3 = (void **)off_2E128;
  }
  if ( a1 )
  {
    for ( i = (PVOID *)qword_2E390; i != &qword_2E390; i = (PVOID *)*i )
    {
      v9 = *((_DWORD *)i + 4) - 40000;
      if ( v9 >= 0x4D )
      {
        if ( v3 != &off_2E128 && (*((_BYTE *)v3 + 172) & 1) != 0 && *((_BYTE *)v3 + 169) >= 2u )
        {
          sub_14544((__int64)v3[19], 0x45u, (__int64)&unk_2B378, v9);
          v3 = (void **)off_2E128;
        }
        v2 = 1;
      }
      else
      {
        v10 = 32i64 * v9;
        *(_DWORD *)((char *)qword_2E7D0 + v10) = *((_DWORD *)i + 4);
        *(_DWORD *)((char *)qword_2E7D0 + v10 + 4) = -1;
        *(_DWORD *)((char *)qword_2E7D0 + v10 + 8) = *((_DWORD *)i + 6);
        *(_DWORD *)((char *)qword_2E7D0 + v10 + 12) = *((_DWORD *)i + 7);
        *(_QWORD *)((char *)qword_2E7D0 + v10 + 24) = i + 3;
        if ( *((_DWORD *)i + 4) == 40005 )
        {
          v11 = sub_24F9C;
        }
        else
        {
          v12 = *((_DWORD *)i + 4);
          if ( v12 == 40015
            || v12 == 40016
            || v12 == 40017
            || v12 == 40018
            || v12 == 40019
            || v12 == 40020
            || v12 == 40021
            || v12 == 40023
            || v12 == 40022
            || v12 == 40039
            || v12 == 40044
            || v12 == 40024
            || v12 == 40036
            || v12 == 40012
            || v12 == 40037
            || v12 == 40014
            || v12 == 40041
            || v12 == 40042
            || v12 == 40013
            || v12 == 40038
            || v12 == 40025 )
          {
            v11 = sub_2517C;
          }
          else if ( v12 == 40011
                 || v12 == 40053
                 || v12 == 40050
                 || v12 == 40051
                 || v12 == 40052
                 || v12 == 40045
                 || v12 == 40003 )
          {
            v11 = sub_24C84;
          }
          else
          {
            v11 = sub_24A10;
          }
        }
        *(_QWORD *)((char *)qword_2E7D0 + v10 + 16) = v11;
        v3 = (void **)off_2E128;
      }
    }
  }
  else
  {
    for ( j = (PVOID *)qword_2E380; j != &qword_2E380; j = (PVOID *)*j )
    {
      v5 = *((_DWORD *)j + 4);
      v6 = v5 - 40000;
      if ( (unsigned int)(v5 - 40000) >= 0x4D )
      {
        if ( v3 != &off_2E128 && (*((_BYTE *)v3 + 172) & 1) != 0 && *((_BYTE *)v3 + 169) >= 2u )
        {
          sub_14544((__int64)v3[19], 0x44u, (__int64)&unk_2B378, v6);
          v3 = (void **)off_2E128;
        }
        v2 = 1;
      }
      else
      {
        v7 = (unsigned __int64)v6 << 6;
        *(_DWORD *)((char *)qword_2E7C8 + v7) = v5;
        *(_DWORD *)((char *)qword_2E7C8 + v7 + 4) = *((_DWORD *)j + 6);
        *(_DWORD *)((char *)qword_2E7C8 + v7 + 8) = -1;
        *(_QWORD *)((char *)qword_2E7C8 + v7 + 16) = 0i64;
        *(_DWORD *)((char *)qword_2E7C8 + v7 + 24) = *((_DWORD *)j + 7);
        *(_QWORD *)((char *)qword_2E7C8 + v7 + 32) = (unsigned __int64)sub_24374 & -(__int64)(j[4] != 0i64);
        *(_QWORD *)((char *)qword_2E7C8 + v7 + 40) = j + 3;
        *(_DWORD *)((char *)qword_2E7C8 + v7 + 48) = 0;
        *(_QWORD *)((char *)qword_2E7C8 + v7 + 56) = 0i64;
        v3 = (void **)off_2E128;
      }
    }
  }
  if ( v3 != &off_2E128 && (*((_BYTE *)v3 + 172) & 1) != 0 && *((_BYTE *)v3 + 169) >= 5u )
    sub_14544((__int64)v3[19], 0x46u, (__int64)&unk_2B378, v2);
  return v2;
}
// 2E128: using guessed type void *off_2E128;

//----- (00000000000238B0) ----------------------------------------------------
__int64 sub_238B0()
{
  void **v0; // rcx
  _QWORD *v1; // rax
  _QWORD *v2; // rbx
  int v3; // edi
  void **v4; // rcx
  unsigned __int16 v5; // dx
  int v6; // er9
  unsigned int v7; // esi
  __int64 v8; // rdi
  _QWORD *v9; // rbp
  int v10; // er12
  int v11; // eax
  __int64 v12; // rax
  int v13; // eax
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // rcx
  void **v18; // r10
  unsigned int v19; // ebx
  __int64 v20; // rdi
  int v21; // er9
  __int64 v22; // rax
  unsigned int v23; // ebx
  __int64 v24; // rdi
  __int64 v25; // rax
  __int64 v26; // rax
  unsigned __int16 v27; // dx
  __int64 (__fastcall **v28)(_QWORD *, _QWORD, _WORD *); // [rsp+60h] [rbp+8h] BYREF

  v0 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_228CC(*((_QWORD *)off_2E128 + 19), 71i64, (__int64)&unk_2B378, word_2E3A0);
    v0 = (void **)off_2E128;
  }
  if ( byte_2E7E0 || byte_2E7E1 )
    goto LABEL_11;
  if ( v0 != &off_2E128 )
  {
    if ( (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
    {
      sub_11008((__int64)v0[19], 0x48u, (__int64)&unk_2B378);
      v0 = (void **)off_2E128;
    }
LABEL_11:
    if ( v0 != &off_2E128 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 4u )
      sub_12374((__int64)v0[19], 0x49u, (__int64)&unk_2B378, &qword_2E7B8);
  }
  qword_2E7B8 = 0i64;
  v1 = sub_1D254(2, 0x38u, 0x41434E50u);
  v2 = v1;
  if ( !v1 )
  {
    v3 = 1793;
LABEL_25:
    v4 = (void **)off_2E128;
    if ( off_2E128 == &off_2E128 || (*((_BYTE *)off_2E128 + 172) & 1) == 0 || !*((_BYTE *)off_2E128 + 169) )
      return 260i64;
    v5 = 74;
    v6 = v3;
LABEL_53:
    v16 = (__int64)v4[19];
    goto LABEL_54;
  }
  memset(v1, 0, 0x38ui64);
  v3 = sub_298A0(v2 + 6, v2 + 1);
  if ( v3
    || (v3 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD *))(v2[1] + 8i64))(
               *(_QWORD *)v2[1],
               4026531842i64,
               v2 + 2)) != 0
    || (v3 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD *))(v2[1] + 8i64))(
               *(_QWORD *)v2[1],
               4026531845i64,
               v2 + 5)) != 0
    || (v3 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD *))(v2[1] + 8i64))(
               *(_QWORD *)v2[1],
               4026531843i64,
               v2 + 4)) != 0
    || (v3 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD *))(v2[1] + 8i64))(
               *(_QWORD *)v2[1],
               4026531844i64,
               v2 + 3)) != 0 )
  {
    sub_29A24(v2);
    v2 = qword_2E7B8;
  }
  else
  {
    *(_BYTE *)v2 = 1;
    qword_2E7B8 = v2;
  }
  if ( v3 )
    goto LABEL_25;
  v4 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 4u )
  {
    sub_12374(*((_QWORD *)off_2E128 + 19), 0x4Bu, (__int64)&unk_2B378, &qword_2E7B8, 0i64, 0);
    v4 = (void **)off_2E128;
    v2 = qword_2E7B8;
  }
  v7 = dword_2E7B0;
  v8 = 0i64;
  v9 = v2;
  v10 = 1796;
  if ( v2 )
  {
    v11 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD))(v2[1] + 8i64))(*(_QWORD *)v2[1], 1i64, &v28);
    v4 = (void **)off_2E128;
    v2 = qword_2E7B8;
    if ( !v11 )
    {
      v12 = (*v28)(v9, v7, word_2E3A0);
      v4 = (void **)off_2E128;
      v2 = qword_2E7B8;
      v8 = v12;
    }
  }
  qword_2E7C0 = v8;
  if ( !v8 )
  {
    if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) )
      sub_11008((__int64)v4[19], 0x4Cu, (__int64)&unk_2B378);
    return 260i64;
  }
  if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 4u )
  {
    sub_14C58((__int64)v4[19], 0x4Du, (__int64)&unk_2B378, v2, v8, &qword_2E7F0);
    v4 = (void **)off_2E128;
    v8 = qword_2E7C0;
    v2 = qword_2E7B8;
  }
  v13 = 1796;
  if ( !v8 || (v14 = *(_QWORD *)(v8 + 1112)) == 0 )
  {
LABEL_49:
    if ( v4 == &off_2E128 || (*((_BYTE *)v4 + 172) & 1) == 0 || !*((_BYTE *)v4 + 169) )
      return 260i64;
    v5 = 78;
    v6 = v13;
    goto LABEL_53;
  }
  v13 = (*(__int64 (__fastcall **)(_QWORD *, __int64, __int64 *))(v14 + 112))(v2, v8, &qword_2E7F0);
  if ( v13 )
  {
    v4 = (void **)off_2E128;
    goto LABEL_49;
  }
  v18 = (void **)off_2E128;
  if ( !dword_2E7D8 )
  {
LABEL_71:
    if ( dword_2E7DC )
    {
      v23 = 0;
      v24 = 0i64;
      do
      {
        if ( v18 != &off_2E128 && (*((_BYTE *)v18 + 172) & 1) != 0 && *((_BYTE *)v18 + 169) >= 4u )
        {
          sub_14C58(
            (__int64)v18[19],
            0x52u,
            (__int64)&unk_2B378,
            qword_2E7B8,
            qword_2E7C0,
            (char *)qword_2E7D0 + 32 * v23);
          v18 = (void **)off_2E128;
        }
        if ( *(_DWORD *)((char *)qword_2E7D0 + v24) )
        {
          v21 = 1796;
          if ( !qword_2E7C0 )
            goto LABEL_105;
          v25 = *(_QWORD *)(qword_2E7C0 + 1112);
          if ( !v25 )
            goto LABEL_105;
          v21 = (*(__int64 (__fastcall **)(__int64, char *, __int64, __int64))(v25 + 40))(
                  qword_2E7C0,
                  (char *)qword_2E7D0 + 32 * v23,
                  v15,
                  1796i64);
          if ( v21 )
          {
            v18 = (void **)off_2E128;
LABEL_105:
            if ( v18 != &off_2E128 && (*((_BYTE *)v18 + 172) & 1) != 0 && *((_BYTE *)v18 + 169) )
            {
              v27 = 83;
LABEL_103:
              sub_1E4A0((__int64)v18[19], v27, (__int64)&unk_2B378, v21);
            }
            return 260i64;
          }
          v18 = (void **)off_2E128;
          if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) )
          {
            sub_14544(*((_QWORD *)off_2E128 + 19), 0x54u, (__int64)&unk_2B378, v23);
            v18 = (void **)off_2E128;
          }
        }
        ++v23;
        v24 += 32i64;
      }
      while ( v23 < 0x4D );
    }
    if ( v18 != &off_2E128 && (*((_BYTE *)v18 + 172) & 1) != 0 && *((_BYTE *)v18 + 169) >= 4u )
    {
      sub_14BA4((__int64)v18[19], 0x55u, (__int64)&unk_2B378, qword_2E7B8, qword_2E7C0);
      v18 = (void **)off_2E128;
    }
    if ( qword_2E7C0 )
    {
      v26 = *(_QWORD *)(qword_2E7C0 + 1112);
      if ( v26 )
      {
        v10 = (*(__int64 (__fastcall **)(PVOID))(v26 + 8))(qword_2E7B8);
        if ( !v10 )
        {
          byte_2E7E3 = 1;
          if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
            sub_14544(*((_QWORD *)off_2E128 + 19), 0x57u, (__int64)&unk_2B378, 0);
          return 0i64;
        }
        v18 = (void **)off_2E128;
      }
    }
    if ( v18 == &off_2E128 || (*((_BYTE *)v18 + 172) & 1) == 0 || !*((_BYTE *)v18 + 169) )
      return 260i64;
    v16 = (__int64)v18[19];
    v5 = 86;
    v6 = v10;
LABEL_54:
    sub_14544(v16, v5, (__int64)&unk_2B378, v6);
    return 260i64;
  }
  v19 = 0;
  v20 = 0i64;
  while ( 1 )
  {
    if ( v18 != &off_2E128 && (*((_BYTE *)v18 + 172) & 1) != 0 && *((_BYTE *)v18 + 169) >= 4u )
    {
      sub_14C58(
        (__int64)v18[19],
        0x4Fu,
        (__int64)&unk_2B378,
        qword_2E7B8,
        qword_2E7C0,
        (char *)qword_2E7C8 + 64 * (unsigned __int64)v19);
      v18 = (void **)off_2E128;
    }
    if ( !*(_DWORD *)((char *)qword_2E7C8 + v20) )
      goto LABEL_70;
    v21 = 1796;
    if ( !qword_2E7C0 )
      goto LABEL_99;
    v22 = *(_QWORD *)(qword_2E7C0 + 1112);
    if ( !v22 )
      goto LABEL_99;
    v21 = (*(__int64 (__fastcall **)(__int64, char *, __int64, __int64))(v22 + 64))(
            qword_2E7C0,
            (char *)qword_2E7C8 + 64 * (unsigned __int64)v19,
            v15,
            1796i64);
    if ( v21 )
      break;
    v18 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) )
    {
      sub_14544(*((_QWORD *)off_2E128 + 19), 0x51u, (__int64)&unk_2B378, v19);
      v18 = (void **)off_2E128;
    }
LABEL_70:
    ++v19;
    v20 += 64i64;
    if ( v19 >= 0x4D )
      goto LABEL_71;
  }
  v18 = (void **)off_2E128;
LABEL_99:
  if ( v18 != &off_2E128 && (*((_BYTE *)v18 + 172) & 1) != 0 && *((_BYTE *)v18 + 169) )
  {
    v27 = 80;
    goto LABEL_103;
  }
  return 260i64;
}
// 23D2D: variable 'v15' is possibly undefined
// 2E128: using guessed type void *off_2E128;
// 2E7B0: using guessed type int dword_2E7B0;
// 2E7C0: using guessed type __int64 qword_2E7C0;
// 2E7D8: using guessed type int dword_2E7D8;
// 2E7DC: using guessed type int dword_2E7DC;
// 2E7E0: using guessed type char byte_2E7E0;
// 2E7E1: using guessed type char byte_2E7E1;
// 2E7E3: using guessed type char byte_2E7E3;
// 2E7F0: using guessed type __int64 qword_2E7F0;

//----- (0000000000024014) ----------------------------------------------------
__int64 sub_24014()
{
  void **v0; // rcx
  unsigned int v2; // ebx
  __int64 v3; // rdx
  unsigned int v4; // eax
  PVOID v5; // rdi
  __int64 v6; // rax
  int v7; // esi
  int v8; // eax
  int v9; // er11
  char v10; // al
  __int64 v11; // rax
  __int64 v12; // r8
  int v13; // eax
  __int64 v14; // rdx
  __int64 v15; // [rsp+20h] [rbp-28h]
  __int64 v16; // [rsp+50h] [rbp+8h] BYREF

  v0 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x58u, (__int64)&unk_2B378);
    v0 = (void **)off_2E128;
  }
  if ( !byte_2E7E3 )
  {
    if ( v0 != &off_2E128 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
      sub_11008((__int64)v0[19], 0x59u, (__int64)&unk_2B378);
    return 260i64;
  }
  if ( v0 != &off_2E128 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 4u )
  {
    sub_12374((__int64)v0[19], 0x5Au, (__int64)&unk_2B378, qword_2E7C0);
    v0 = (void **)off_2E128;
  }
  v2 = 0;
  if ( qword_2E7C0 )
  {
    v3 = *(_QWORD *)(qword_2E7C0 + 1112);
    if ( v3 )
    {
      v4 = (*(__int64 (__fastcall **)(__int64))(v3 + 88))(qword_2E7C0);
      v0 = (void **)off_2E128;
      v2 = v4;
    }
  }
  if ( v0 != &off_2E128 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 4u )
  {
    sub_1FF64((__int64)v0[19], 0x5Bu, (__int64)&unk_2B378, qword_2E7B8, v2);
    v0 = (void **)off_2E128;
  }
  v5 = qword_2E7B8;
  v6 = 0i64;
  v7 = 1796;
  v16 = 0i64;
  if ( qword_2E7B8 )
  {
    v8 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64 *))(*((_QWORD *)qword_2E7B8 + 1) + 8i64))(
           **((_QWORD **)qword_2E7B8 + 1),
           1i64,
           &v16);
    v0 = (void **)off_2E128;
    v9 = v8;
    v6 = v16;
  }
  else
  {
    v9 = 1796;
  }
  if ( !v9 )
  {
    v10 = (*(__int64 (__fastcall **)(PVOID, _QWORD))(v6 + 80))(v5, v2);
    v0 = (void **)off_2E128;
    if ( v10 )
    {
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 4u )
      {
        LODWORD(v15) = v2;
        sub_1FF64(*((_QWORD *)off_2E128 + 19), 0x5Du, (__int64)&unk_2B378, qword_2E7B8, v15);
        v0 = (void **)off_2E128;
      }
      v11 = qword_2E7C0;
      if ( qword_2E7C0 )
      {
        v12 = *(_QWORD *)(qword_2E7C0 + 1112);
        if ( v12 )
        {
          v13 = (*(__int64 (__fastcall **)(PVOID, __int64))(v12 + 16))(qword_2E7B8, qword_2E7C0);
          v0 = (void **)off_2E128;
          v7 = v13;
          v11 = qword_2E7C0;
        }
      }
      if ( v7 )
      {
        if ( v0 != &off_2E128 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
          sub_14544((__int64)v0[19], 0x5Eu, (__int64)&unk_2B378, v7 != 0);
        return 257i64;
      }
      if ( v0 != &off_2E128 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 4u )
      {
        sub_11008((__int64)v0[19], 0x5Fu, (__int64)&unk_2B378);
        v0 = (void **)off_2E128;
        v11 = qword_2E7C0;
      }
      if ( !v11 )
        goto LABEL_52;
      v14 = *(_QWORD *)(v11 + 1112);
      if ( !v14 )
        goto LABEL_52;
      (*(void (__fastcall **)(__int64))(v14 + 32))(v11);
      goto LABEL_51;
    }
  }
  if ( v0 != &off_2E128 )
  {
    if ( (*((_BYTE *)v0 + 172) & 1) == 0 || *((_BYTE *)v0 + 169) < 2u )
    {
LABEL_52:
      if ( v0 != &off_2E128 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 4u )
        sub_12374((__int64)v0[19], 0x60u, (__int64)&unk_2B378, qword_2E7B8);
      goto LABEL_56;
    }
    sub_11008((__int64)v0[19], 0x5Cu, (__int64)&unk_2B378);
LABEL_51:
    v0 = (void **)off_2E128;
    goto LABEL_52;
  }
LABEL_56:
  sub_29A24(qword_2E7B8);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
    sub_14544(*((_QWORD *)off_2E128 + 19), 0x61u, (__int64)&unk_2B378, 0);
  return 0i64;
}
// 241DC: variable 'v15' is possibly undefined
// 2E128: using guessed type void *off_2E128;
// 2E7C0: using guessed type __int64 qword_2E7C0;
// 2E7E3: using guessed type char byte_2E7E3;

//----- (0000000000024374) ----------------------------------------------------
__int64 __fastcall sub_24374(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int v3; // esi
  void **v7; // rcx
  void (__fastcall *v9)(_QWORD, _QWORD, _QWORD, int *); // rdi
  unsigned __int16 v10; // dx
  char v11[40]; // [rsp+40h] [rbp-28h] BYREF
  int v12; // [rsp+80h] [rbp+18h] BYREF
  char v13; // [rsp+88h] [rbp+20h] BYREF

  v3 = 0;
  v12 = 0;
  v7 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 0xAu)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_14C58(*((_QWORD *)off_2E128 + 19), 0x84u, (__int64)&unk_2B378, a1, a2, a3);
    v7 = (void **)off_2E128;
  }
  if ( a3 )
  {
    if ( a2 )
    {
      v9 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, int *))(a2 + 8);
      if ( v9 )
      {
        if ( v7 != &off_2E128 && _bittest((const signed __int32 *)v7 + 43, 0xAu) && *((_BYTE *)v7 + 169) >= 4u )
        {
          sub_2297C((__int64)v7[19], 134i64, (__int64)&unk_2B378, qword_2E7B8, a3, &v13, &v12);
          v7 = (void **)off_2E128;
        }
        if ( qword_2E7B8 )
        {
          (*(void (__fastcall **)(_QWORD, __int64, char *, int *, char *, _QWORD))(*((_QWORD *)qword_2E7B8 + 5) + 32i64))(
            **((_QWORD **)qword_2E7B8 + 5),
            a3,
            &v13,
            &v12,
            v11,
            0i64);
        }
        else
        {
          v3 = 1799;
          if ( v7 != &off_2E128 && _bittest((const signed __int32 *)v7 + 43, 0xAu) && *((_BYTE *)v7 + 169) >= 2u )
            sub_14544((__int64)v7[19], 0x87u, (__int64)&unk_2B378, 1799);
        }
        v9(*(unsigned int *)(a3 + 8), *(_QWORD *)(a3 + 56), *(unsigned int *)(a3 + 28), &v12);
        if ( qword_2E7B8 )
          (*(void (__fastcall **)(_QWORD, __int64))(*((_QWORD *)qword_2E7B8 + 5) + 24i64))(
            **((_QWORD **)qword_2E7B8 + 5),
            a3);
        goto LABEL_34;
      }
      if ( v7 != &off_2E128 )
      {
        if ( _bittest((const signed __int32 *)v7 + 43, 0xAu) && *((_BYTE *)v7 + 169) >= 2u )
        {
          v10 = 136;
LABEL_33:
          sub_11008((__int64)v7[19], v10, (__int64)&unk_2B378);
LABEL_34:
          v7 = (void **)off_2E128;
          goto LABEL_35;
        }
        goto LABEL_35;
      }
    }
    else if ( v7 != &off_2E128 )
    {
      if ( _bittest((const signed __int32 *)v7 + 43, 0xAu) && *((_BYTE *)v7 + 169) >= 2u )
      {
        v10 = 137;
        goto LABEL_33;
      }
LABEL_35:
      if ( v7 != &off_2E128 && _bittest((const signed __int32 *)v7 + 43, 0xAu) && *((_BYTE *)v7 + 169) >= 5u )
        sub_14544((__int64)v7[19], 0x8Au, (__int64)&unk_2B378, v3);
      return v3;
    }
    return v3;
  }
  if ( v7 != &off_2E128 && _bittest((const signed __int32 *)v7 + 43, 0xAu) && *((_BYTE *)v7 + 169) >= 2u )
    sub_11008((__int64)v7[19], 0x85u, (__int64)&unk_2B378);
  return 3899654172i64;
}
// 2E128: using guessed type void *off_2E128;

//----- (00000000000245CC) ----------------------------------------------------
__int64 __fastcall sub_245CC(unsigned int *a1)
{
  void **v2; // rcx
  __int64 result; // rax

  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x8Bu, (__int64)&unk_2B378);
    v2 = (void **)off_2E128;
  }
  qword_2E7F0 = 0i64;
  qword_2E7F8 = 0i64;
  qword_2E800 = 0i64;
  qword_2E7F0 = *a1;
  HIDWORD(qword_2E7F0) = *((unsigned __int8 *)a1 + 4);
  qword_2E7F8 = *((_QWORD *)a1 + 1);
  if ( *((_QWORD *)a1 + 2) )
  {
    qword_2E800 = (__int64)sub_24728;
    qword_2E7E8 = (__int64 (__fastcall *)(_QWORD))*((_QWORD *)a1 + 2);
    if ( v2 != &off_2E128 )
    {
      if ( (*((_BYTE *)v2 + 172) & 1) != 0 && *((_BYTE *)v2 + 169) >= 4u )
      {
        sub_11008((__int64)v2[19], 0x8Cu, (__int64)&unk_2B378);
        v2 = (void **)off_2E128;
      }
      if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 172) & 1) != 0 && *((_BYTE *)v2 + 169) >= 5u )
        sub_14544((__int64)v2[19], 0x8Eu, (__int64)&unk_2B378, 0);
    }
    result = 0i64;
  }
  else
  {
    if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 172) & 1) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x8Du, (__int64)&unk_2B378);
    result = 264i64;
  }
  return result;
}
// 2E128: using guessed type void *off_2E128;
// 2E7E8: using guessed type __int64 (__fastcall *qword_2E7E8)(_QWORD);
// 2E7F0: using guessed type __int64 qword_2E7F0;
// 2E7F8: using guessed type __int64 qword_2E7F8;
// 2E800: using guessed type __int64 qword_2E800;

//----- (0000000000024728) ----------------------------------------------------
__int64 __fastcall sub_24728(__int64 a1, __int64 a2, __int64 a3)
{
  void **v4; // rcx

  v4 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( _bittest((const signed __int32 *)off_2E128 + 43, 8u) && *((_BYTE *)off_2E128 + 169) >= 5u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x8Fu, (__int64)&unk_2B378);
      v4 = (void **)off_2E128;
    }
    if ( v4 != &off_2E128 && _bittest((const signed __int32 *)v4 + 43, 8u) && *((_BYTE *)v4 + 169) >= 4u )
    {
      sub_12374((__int64)v4[19], 0x90u, (__int64)&unk_2B378, a3);
      v4 = (void **)off_2E128;
    }
  }
  if ( qword_2E7E8 )
  {
    qword_2E7E8(a3);
    v4 = (void **)off_2E128;
  }
  if ( v4 != &off_2E128 && _bittest((const signed __int32 *)v4 + 43, 8u) && *((_BYTE *)v4 + 169) >= 5u )
    sub_14544((__int64)v4[19], 0x91u, (__int64)&unk_2B378, 0);
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;
// 2E7E8: using guessed type __int64 (__fastcall *qword_2E7E8)(_QWORD);

//----- (0000000000024814) ----------------------------------------------------
__int64 __fastcall sub_24814(__int64 a1, int a2, unsigned int a3, void *a4)
{
  unsigned int v8; // ebx
  void **v9; // rcx
  _DWORD *v11; // rdi
  __int64 v12; // r8
  int v13; // eax

  v8 = 6;
  v9 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 8u)
    && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_1E4A0(*((_QWORD *)off_2E128 + 19), 0x92u, (__int64)&unk_2B378, a2);
    v9 = (void **)off_2E128;
  }
  if ( !byte_2E7E3 )
  {
    if ( v9 != &off_2E128 && _bittest((const signed __int32 *)v9 + 43, 8u) && *((_BYTE *)v9 + 169) >= 2u )
      sub_11008((__int64)v9[19], 0x93u, (__int64)&unk_2B378);
    return 260i64;
  }
  v11 = *(_DWORD **)(a1 + 56);
  if ( v11 )
  {
    if ( a2 && v9 != &off_2E128 && _bittest((const signed __int32 *)v9 + 43, 8u) && *((_BYTE *)v9 + 169) >= 3u )
    {
      sub_14544((__int64)v9[19], 0x94u, (__int64)&unk_2B378, a2);
      v9 = (void **)off_2E128;
    }
    v12 = a2 != 0 ? 0x80000000 : 0;
    if ( *v11 == 3 || *v11 == 8 )
    {
      v13 = sub_29A94((__int64)qword_2E7B8, a1, v12, a3, a4);
    }
    else
    {
      if ( !qword_2E7B8 )
      {
        v13 = 1799;
        goto LABEL_24;
      }
      v13 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD, _QWORD))(*((_QWORD *)qword_2E7B8 + 3) + 24i64))(
              **((_QWORD **)qword_2E7B8 + 3),
              a1,
              v12,
              0i64,
              0i64);
    }
    v9 = (void **)off_2E128;
LABEL_24:
    if ( v13 )
    {
      if ( v9 != &off_2E128 && _bittest((const signed __int32 *)v9 + 43, 8u) && *((_BYTE *)v9 + 169) >= 2u )
      {
        sub_14544((__int64)v9[19], 0x95u, (__int64)&unk_2B378, v13);
        v9 = (void **)off_2E128;
      }
      v8 = 273;
    }
    else
    {
      v8 = 0;
    }
  }
  if ( v9 != &off_2E128 && _bittest((const signed __int32 *)v9 + 43, 8u) && *((_BYTE *)v9 + 169) >= 5u )
    sub_14544((__int64)v9[19], 0x96u, (__int64)&unk_2B378, v8);
  return v8;
}
// 2E128: using guessed type void *off_2E128;
// 2E7E3: using guessed type char byte_2E7E3;

//----- (0000000000024A10) ----------------------------------------------------
__int64 __fastcall sub_24A10(__int64 a1, __int64 a2, __int64 a3)
{
  void **v6; // rcx
  void (__fastcall *v7)(_QWORD, _QWORD, _QWORD, __int64, unsigned int *); // rax
  unsigned int v8; // ebx
  unsigned int v9; // eax
  unsigned __int16 v11; // dx
  unsigned int v12; // [rsp+58h] [rbp+20h] BYREF

  v12 = 3;
  v6 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( _bittest((const signed __int32 *)off_2E128 + 43, 0xAu) && *((_BYTE *)off_2E128 + 169) >= 5u )
    {
      sub_14C58(*((_QWORD *)off_2E128 + 19), 0x97u, (__int64)&unk_2B378, a1, a2, a3);
      v6 = (void **)off_2E128;
    }
    if ( v6 != &off_2E128 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 4u )
    {
      sub_14544((__int64)v6[19], 0x98u, (__int64)&unk_2B378, *(_DWORD *)a3);
      v6 = (void **)off_2E128;
    }
  }
  if ( !byte_2E7E4 )
  {
    if ( v6 != &off_2E128 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 3u )
      sub_11008((__int64)v6[19], 0x99u, (__int64)&unk_2B378);
    return 0i64;
  }
  if ( !a2 )
  {
    if ( v6 != &off_2E128 )
    {
      if ( !_bittest((const signed __int32 *)v6 + 43, 0xAu) || *((_BYTE *)v6 + 169) < 2u )
        goto LABEL_37;
      v11 = 157;
LABEL_36:
      sub_11008((__int64)v6[19], v11, (__int64)&unk_2B378);
      v6 = (void **)off_2E128;
      goto LABEL_37;
    }
    return 0i64;
  }
  v7 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, __int64, unsigned int *))(a2 + 8);
  if ( !v7 )
  {
    if ( v6 != &off_2E128 )
    {
      if ( !_bittest((const signed __int32 *)v6 + 43, 0xAu) || *((_BYTE *)v6 + 169) < 2u )
        goto LABEL_37;
      v11 = 156;
      goto LABEL_36;
    }
    return 0i64;
  }
  v7(*(unsigned int *)(a3 + 8), *(_QWORD *)(a3 + 56), *(unsigned int *)(a3 + 28), a3, &v12);
  v6 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 0xAu)
    && *((_BYTE *)off_2E128 + 169) >= 4u )
  {
    sub_14544(*((_QWORD *)off_2E128 + 19), 0x9Au, (__int64)&unk_2B378, v12);
    v6 = (void **)off_2E128;
  }
  if ( !qword_2E7B8 )
  {
    v8 = 1799;
    goto LABEL_23;
  }
  v9 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD, _QWORD))(*((_QWORD *)qword_2E7B8 + 3) + 24i64))(
         **((_QWORD **)qword_2E7B8 + 3),
         a3,
         v12,
         0i64,
         0i64);
  v6 = (void **)off_2E128;
  v8 = v9;
  if ( !v9 )
  {
LABEL_37:
    if ( v6 != &off_2E128 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 5u )
      sub_14544((__int64)v6[19], 0x9Eu, (__int64)&unk_2B378, 0);
    return 0i64;
  }
LABEL_23:
  if ( v6 != &off_2E128 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 2u )
    sub_14544((__int64)v6[19], 0x9Bu, (__int64)&unk_2B378, v8);
  return v8;
}
// 2E128: using guessed type void *off_2E128;
// 2E7E4: using guessed type char byte_2E7E4;

//----- (0000000000024C84) ----------------------------------------------------
__int64 __fastcall sub_24C84(__int64 a1, __int64 a2, __int64 a3)
{
  void **v6; // rcx
  void (__fastcall *v7)(_QWORD, _QWORD, _QWORD, unsigned int *, PVOID *, __int64 *); // rax
  void **v8; // rcx
  int v9; // eax
  unsigned int v10; // ebx
  unsigned __int16 v12; // dx
  __int64 v13; // [rsp+20h] [rbp-28h]
  __int64 Tag; // [rsp+30h] [rbp-18h] BYREF
  PVOID P[2]; // [rsp+38h] [rbp-10h] BYREF
  unsigned int v16; // [rsp+68h] [rbp+20h] BYREF

  P[0] = 0i64;
  v16 = 0;
  LODWORD(Tag) = 0;
  v6 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( _bittest((const signed __int32 *)off_2E128 + 43, 0xAu) && *((_BYTE *)off_2E128 + 169) >= 5u )
    {
      sub_14C58(*((_QWORD *)off_2E128 + 19), 0x9Fu, (__int64)&unk_2B378, a1, a2, a3, Tag);
      v6 = (void **)off_2E128;
    }
    if ( v6 != &off_2E128 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 4u )
    {
      sub_14544((__int64)v6[19], 0xA0u, (__int64)&unk_2B378, *(_DWORD *)a3);
      v6 = (void **)off_2E128;
    }
  }
  if ( !byte_2E7E4 )
  {
    if ( v6 != &off_2E128 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 3u )
      sub_11008((__int64)v6[19], 0xA1u, (__int64)&unk_2B378);
    return 0i64;
  }
  if ( !a2 )
  {
    if ( v6 == &off_2E128 )
      return 0i64;
    if ( !_bittest((const signed __int32 *)v6 + 43, 0xAu) || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_46;
    v12 = 167;
    goto LABEL_44;
  }
  v7 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, unsigned int *, PVOID *, __int64 *))(a2 + 16);
  if ( !v7 )
  {
    if ( v6 == &off_2E128 )
      return 0i64;
    if ( !_bittest((const signed __int32 *)v6 + 43, 0xAu) || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_46;
    v12 = 166;
LABEL_44:
    sub_11008((__int64)v6[19], v12, (__int64)&unk_2B378);
    goto LABEL_45;
  }
  v7(*(unsigned int *)(a3 + 8), *(_QWORD *)(a3 + 56), *(unsigned int *)(a3 + 28), &v16, P, &Tag);
  v8 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( _bittest((const signed __int32 *)off_2E128 + 43, 0xAu) && *((_BYTE *)off_2E128 + 169) >= 4u )
    {
      sub_14544(*((_QWORD *)off_2E128 + 19), 0xA2u, (__int64)&unk_2B378, 5);
      v8 = (void **)off_2E128;
    }
    if ( v8 != &off_2E128 && _bittest((const signed __int32 *)v8 + 43, 0xAu) && *((_BYTE *)v8 + 169) >= 4u )
      sub_14544((__int64)v8[19], 0xA3u, (__int64)&unk_2B378, v16);
  }
  v9 = sub_29A94((__int64)qword_2E7B8, a3, 5i64, v16, P[0]);
  v10 = v9;
  if ( !v9 )
  {
    if ( !P[0] || !v16 )
      goto LABEL_45;
    LODWORD(v13) = 0;
    sub_1D2D8(P[0], Tag);
    v6 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128 )
    {
      if ( _bittest((const signed __int32 *)off_2E128 + 43, 0xAu) && *((_BYTE *)off_2E128 + 169) >= 4u )
      {
        sub_12374(*((_QWORD *)off_2E128 + 19), 0xA5u, (__int64)&unk_2B378, P[0], v13);
LABEL_45:
        v6 = (void **)off_2E128;
      }
LABEL_46:
      if ( v6 != &off_2E128 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 5u )
        sub_14544((__int64)v6[19], 0xA8u, (__int64)&unk_2B378, 0);
    }
    return 0i64;
  }
  if ( off_2E128 != &off_2E128
    && _bittest((const signed __int32 *)off_2E128 + 43, 0xAu)
    && *((_BYTE *)off_2E128 + 169) >= 2u )
  {
    sub_14544(*((_QWORD *)off_2E128 + 19), 0xA4u, (__int64)&unk_2B378, v9);
  }
  return v10;
}
// 24EF3: variable 'v13' is possibly undefined
// 2E128: using guessed type void *off_2E128;
// 2E7E4: using guessed type char byte_2E7E4;

//----- (0000000000024F9C) ----------------------------------------------------
__int64 __fastcall sub_24F9C(__int64 a1, __int64 a2, __int64 a3)
{
  void **v6; // rcx
  void (__fastcall *v7)(_QWORD, _QWORD, __int64, __int64); // rax
  unsigned __int16 v8; // dx

  v6 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
    {
      sub_14C58(*((_QWORD *)off_2E128 + 19), 0xF7u, (__int64)&unk_2B378, a1, a2, a3);
      v6 = (void **)off_2E128;
    }
    if ( v6 != &off_2E128 && (*((_BYTE *)v6 + 172) & 1) != 0 && *((_BYTE *)v6 + 169) >= 4u )
    {
      sub_14544((__int64)v6[19], 0xF8u, (__int64)&unk_2B378, *(_DWORD *)a3);
      v6 = (void **)off_2E128;
    }
  }
  if ( !byte_2E7E4 )
  {
    if ( v6 != &off_2E128 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 3u )
      sub_11008((__int64)v6[19], 0xF9u, (__int64)&unk_2B378);
    return 0i64;
  }
  if ( a2 )
  {
    v7 = *(void (__fastcall **)(_QWORD, _QWORD, __int64, __int64))(a2 + 24);
    if ( v7 )
    {
      v7(*(unsigned int *)(a3 + 8), *(_QWORD *)(a3 + 56), 1024i64, a1);
      v6 = (void **)off_2E128;
      if ( off_2E128 == &off_2E128 )
        return 0i64;
      if ( (*((_BYTE *)off_2E128 + 172) & 1) == 0 || *((_BYTE *)off_2E128 + 169) < 4u )
        goto LABEL_30;
      sub_14544(*((_QWORD *)off_2E128 + 19), 0xFAu, (__int64)&unk_2B378, 3);
      goto LABEL_29;
    }
    if ( v6 == &off_2E128 )
      return 0i64;
    if ( (*((_BYTE *)v6 + 172) & 1) == 0 || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_30;
    v8 = 251;
  }
  else
  {
    if ( v6 == &off_2E128 )
      return 0i64;
    if ( (*((_BYTE *)v6 + 172) & 1) == 0 || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_30;
    v8 = 252;
  }
  sub_11008((__int64)v6[19], v8, (__int64)&unk_2B378);
LABEL_29:
  v6 = (void **)off_2E128;
LABEL_30:
  if ( v6 != &off_2E128 && (*((_BYTE *)v6 + 172) & 1) != 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_14544((__int64)v6[19], 0xFDu, (__int64)&unk_2B378, 0);
  return 0i64;
}
// 2509F: variable 'a1' is possibly undefined
// 2E128: using guessed type void *off_2E128;
// 2E7E4: using guessed type char byte_2E7E4;

//----- (000000000002517C) ----------------------------------------------------
__int64 __fastcall sub_2517C(__int64 a1, __int64 a2, __int64 a3)
{
  void **v6; // rcx
  void (__fastcall *v7)(_QWORD, _QWORD, _QWORD, __int64); // rax
  unsigned __int16 v8; // dx

  v6 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
    {
      sub_14C58(*((_QWORD *)off_2E128 + 19), 0x114u, (__int64)&unk_2B378, a1, a2, a3);
      v6 = (void **)off_2E128;
    }
    if ( v6 != &off_2E128 && (*((_BYTE *)v6 + 172) & 1) != 0 && *((_BYTE *)v6 + 169) >= 4u )
    {
      sub_14544((__int64)v6[19], 0x115u, (__int64)&unk_2B378, *(_DWORD *)a3);
      v6 = (void **)off_2E128;
    }
  }
  if ( !byte_2E7E4 )
  {
    if ( v6 != &off_2E128 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 3u )
      sub_11008((__int64)v6[19], 0x116u, (__int64)&unk_2B378);
    return 0i64;
  }
  if ( !a2 )
  {
    if ( v6 == &off_2E128 )
      return 0i64;
    if ( (*((_BYTE *)v6 + 172) & 1) == 0 || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_27;
    v8 = 280;
    goto LABEL_25;
  }
  v7 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, __int64))(a2 + 32);
  if ( !v7 )
  {
    if ( v6 == &off_2E128 )
      return 0i64;
    if ( (*((_BYTE *)v6 + 172) & 1) == 0 || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_27;
    v8 = 279;
LABEL_25:
    sub_11008((__int64)v6[19], v8, (__int64)&unk_2B378);
    goto LABEL_26;
  }
  v7(*(unsigned int *)(a3 + 8), *(_QWORD *)(a3 + 56), *(unsigned int *)(a3 + 28), a1);
LABEL_26:
  v6 = (void **)off_2E128;
LABEL_27:
  if ( v6 != &off_2E128 && (*((_BYTE *)v6 + 172) & 1) != 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_14544((__int64)v6[19], 0x119u, (__int64)&unk_2B378, 0);
  return 0i64;
}
// 2527D: variable 'a1' is possibly undefined
// 2E128: using guessed type void *off_2E128;
// 2E7E4: using guessed type char byte_2E7E4;

//----- (0000000000025320) ----------------------------------------------------
__int64 sub_25320()
{
  unsigned int v0; // ebx
  void **v1; // rcx
  int v2; // eax

  v0 = 0;
  v1 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x11Au, (__int64)&unk_2B378);
    v1 = (void **)off_2E128;
  }
  if ( qword_2E808 )
    goto LABEL_12;
  v2 = sub_22EA4(9u, (__int64)&qword_2E808);
  v0 = v2;
  if ( !v2 )
    goto LABEL_11;
  v1 = (void **)off_2E128;
  if ( off_2E128 == &off_2E128 )
    return v0;
  if ( (*((_BYTE *)off_2E128 + 172) & 1) != 0 && *((_BYTE *)off_2E128 + 169) >= 2u )
  {
    sub_14544(*((_QWORD *)off_2E128 + 19), 0x11Bu, (__int64)&unk_2B378, v2);
LABEL_11:
    v1 = (void **)off_2E128;
  }
LABEL_12:
  if ( v1 != &off_2E128 && (*((_BYTE *)v1 + 172) & 1) != 0 && *((_BYTE *)v1 + 169) >= 5u )
    sub_14544((__int64)v1[19], 0x11Cu, (__int64)&unk_2B378, v0);
  return v0;
}
// 2E128: using guessed type void *off_2E128;
// 2E808: using guessed type __int64 qword_2E808;

//----- (0000000000025418) ----------------------------------------------------
__int64 __fastcall sub_25418(__int64 a1, _BYTE *a2)
{
  __int64 v2; // rax
  __int64 result; // rax
  const char *v6; // rax

  v2 = qword_2E808;
  if ( qword_2E808 )
  {
    *a2 = 0;
    if ( ((*(__int64 (**)(void))(v2 + 8))() & 0x40) != 0 )
      *a2 = 1;
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 0x13u)
      && *((_BYTE *)off_2E128 + 169) >= 5u )
    {
      v6 = "not";
      if ( *a2 )
        v6 = (const char *)&unk_2B44A;
      sub_229E8(*((_QWORD *)off_2E128 + 19), 310i64, (__int64)&unk_2B378, a1, v6);
    }
    result = 0i64;
  }
  else
  {
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 0x13u)
      && *((_BYTE *)off_2E128 + 169) >= 2u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x135u, (__int64)&unk_2B378);
    }
    result = 258i64;
  }
  return result;
}
// 2E128: using guessed type void *off_2E128;
// 2E808: using guessed type __int64 qword_2E808;

//----- (00000000000254F4) ----------------------------------------------------
bool __fastcall sub_254F4(__int64 a1)
{
  bool v3; // bl

  if ( !a1 )
    return 0;
  v3 = sub_1DC1C((struct _KEVENT **)(a1 + 56), 1);
  sub_1DE30(a1);
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_BYTE *)(a1 + 72) = 0;
  return v3;
}

//----- (0000000000025558) ----------------------------------------------------
char __fastcall sub_25558(PFAST_MUTEX FastMutex)
{
  char result; // al

  result = 0;
  if ( FastMutex && !LODWORD(FastMutex[1].Owner) && !LOBYTE(FastMutex[1].Contention) && !HIDWORD(FastMutex[1].Owner) )
  {
    sub_1DF10(FastMutex);
    sub_1DCFC(*(PRKEVENT *)&FastMutex[1].Count);
    LOBYTE(FastMutex[1].Contention) = 1;
    sub_1DFDC(FastMutex);
    result = 1;
  }
  return result;
}

//----- (00000000000255B8) ----------------------------------------------------
char __fastcall sub_255B8(PFAST_MUTEX FastMutex)
{
  if ( !FastMutex )
    return 0;
  if ( LOBYTE(FastMutex[1].Contention) )
  {
    sub_1DF10(FastMutex);
    LOBYTE(FastMutex[1].Contention) = 0;
    sub_1DFDC(FastMutex);
    sub_1E308(*(PVOID *)&FastMutex[1].Count);
  }
  return 1;
}

//----- (0000000000025618) ----------------------------------------------------
char __fastcall sub_25618(PFAST_MUTEX FastMutex)
{
  char v1; // di
  struct _KEVENT *v4; // rcx

  v1 = 0;
  if ( !FastMutex )
    return 0;
  sub_1DF10(FastMutex);
  if ( LOBYTE(FastMutex[1].Contention) )
  {
    v4 = *(struct _KEVENT **)&FastMutex[1].Count;
    ++LODWORD(FastMutex[1].Owner);
    sub_1DD64(v4);
    v1 = 1;
  }
  sub_1DFDC(FastMutex);
  return v1;
}

//----- (0000000000025680) ----------------------------------------------------
char __fastcall sub_25680(PFAST_MUTEX FastMutex)
{
  if ( !FastMutex || !*(_QWORD *)&FastMutex[1].Count || !LODWORD(FastMutex[1].Owner) )
    return 0;
  sub_1DF10(FastMutex);
  if ( LODWORD(FastMutex[1].Owner)-- == 1 )
    sub_1DCFC(*(PRKEVENT *)&FastMutex[1].Count);
  sub_1DFDC(FastMutex);
  return 1;
}

//----- (00000000000256E4) ----------------------------------------------------
const char *__fastcall sub_256E4(unsigned int a1)
{
  unsigned int v1; // ecx
  unsigned int v2; // ecx
  unsigned int v3; // ecx
  unsigned int v4; // ecx
  const char *result; // rax
  unsigned int v6; // ecx
  unsigned int v7; // ecx
  unsigned int v8; // ecx
  unsigned int v9; // ecx
  unsigned int v10; // ecx
  unsigned int v11; // ecx
  unsigned int v12; // ecx
  unsigned int v13; // ecx
  unsigned int v14; // ecx
  unsigned int v15; // ecx
  unsigned int v16; // ecx
  unsigned int v17; // ecx
  unsigned int v18; // ecx
  unsigned int v19; // ecx
  unsigned int v20; // ecx
  unsigned int v21; // ecx
  unsigned int v22; // ecx
  unsigned int v23; // ecx
  unsigned int v24; // ecx
  unsigned int v25; // ecx
  unsigned int v26; // ecx
  unsigned int v27; // ecx
  unsigned int v28; // ecx
  unsigned int v29; // ecx
  unsigned int v30; // ecx
  unsigned int v31; // ecx
  unsigned int v32; // ecx
  unsigned int v33; // ecx
  unsigned int v34; // ecx
  unsigned int v35; // ecx
  unsigned int v36; // ecx
  unsigned int v37; // ecx
  unsigned int v38; // ecx
  unsigned int v39; // ecx
  unsigned int v40; // ecx
  unsigned int v41; // ecx

  if ( a1 <= 0x101 )
  {
    if ( a1 == 257 )
      return "NNS_ERROR_NMGR_GENERIC_INTERNAL_ERROR";
    if ( a1 > 0xD )
    {
      if ( a1 > 0x14 )
      {
        v16 = a1 - 21;
        if ( !v16 )
          return "NNS_ERROR_ALREADY_RUNNING";
        v17 = v16 - 1;
        if ( !v17 )
          return "NNS_ERROR_SO_NOT_SUPPORTED";
        v18 = v17 - 1;
        if ( !v18 )
          return "NNS_ERROR_ELEMENT_ALREADY_EXISTS";
        v19 = v18 - 1;
        if ( !v19 )
          return "NNS_ERROR_TASK_BUSY_TRY_LATER";
        v20 = v19 - 1;
        if ( !v20 )
          return "NNS_ERROR_INCOMPATIBLE_VERSION";
        if ( v20 == 1 )
          return "NNS_ERROR_SETTING_DATA";
      }
      else
      {
        if ( a1 == 20 )
          return "NNS_ERROR_BUFFER_OVERFLOW";
        v11 = a1 - 14;
        if ( !v11 )
          return "NNS_ERROR_LOADING_LIBRARY";
        v12 = v11 - 1;
        if ( !v12 )
          return "NNS_ERROR_GETTING_INTERFACE";
        v13 = v12 - 1;
        if ( !v13 )
          return "NNS_ERROR_NOT_INITIALIZED";
        v14 = v13 - 1;
        if ( !v14 )
          return "NNS_ERROR_NOT_PROCESSED";
        v15 = v14 - 1;
        if ( !v15 )
          return "NNS_ERROR_NOT_SUPPORTED";
        if ( v15 == 1 )
          return "NNS_ERROR_INTERNAL";
      }
    }
    else
    {
      if ( a1 == 13 )
        return "NNS_ERROR_INSERTING_ELEMENT";
      if ( a1 > 6 )
      {
        v6 = a1 - 7;
        if ( !v6 )
          return "NNS_ERROR_NOT_ACTIVE";
        v7 = v6 - 1;
        if ( !v7 )
          return "NNS_ERROR_CONFIG_PERSISTENCE";
        v8 = v7 - 1;
        if ( !v8 )
          return "NNS_ERROR_ACQUIRE_CS_API";
        v9 = v8 - 1;
        if ( !v9 )
          return "NNS_ERROR_LIMIT_EXCEEDED";
        v10 = v9 - 1;
        if ( !v10 )
          return "NNS_ERROR_SENDING_DATA";
        if ( v10 == 1 )
          return "NNS_ERROR_GETTING_DATA";
      }
      else
      {
        if ( a1 == 6 )
          return "NNS_ERROR_INVALID_DATA";
        if ( !a1 )
          return "NNS_SUCCESS";
        v1 = a1 - 1;
        if ( !v1 )
          return "NNS_ERROR_GENERIC";
        v2 = v1 - 1;
        if ( !v2 )
          return "NNS_ERROR_EXTERN";
        v3 = v2 - 1;
        if ( !v3 )
          return "NNS_ERROR_NOT_ENOUGH_MEMORY";
        v4 = v3 - 1;
        if ( !v4 )
          return "NNS_ERROR_INVALID_PARAM";
        if ( v4 == 1 )
          return "NNS_ERROR_ELEMENT_NOT_FOUND";
      }
    }
    return "UNKNOWN_NNS_ERROR";
  }
  if ( a1 <= 0x200 )
  {
    if ( a1 == 512 )
      return "NNS_ERROR_FRAGMENT_EXT_HEADER_INFO";
    if ( a1 > 0x109 )
    {
      v27 = a1 - 272;
      if ( !v27 )
        return "NNS_ERROR_NMGR_COUNTER_LIMIT_EXCEEDS";
      v28 = v27 - 1;
      if ( !v28 )
        return "NNS_ERROR_NMGR_CONFIG_DISTPATCHER_SET_RESUL";
      v29 = v28 - 1;
      if ( !v29 )
        return "NNS_ERROR_NMGR_REPORTS_DEACTIVATED";
      v30 = v29 - 1;
      if ( !v30 )
        return "NNS_ERROR_NMGR_GETTING_PROCESS_INFO";
      v31 = v30 - 1;
      if ( !v31 )
        return "NNS_ERROR_NMGR_GETTING_PROCESS_INFO_SIZE";
      v32 = v31 - 1;
      if ( !v32 )
        return "NNS_ERROR_STRMR_UNSUPPORTED_COMMAND";
      if ( v32 == 1 )
        return "NNS_ERROR_STRMR_INVALID_DATA_SIZE";
    }
    else
    {
      if ( a1 == 265 )
        return "NNS_ERROR_NMGR_API_CALL_ORDER_INCORRECT";
      v21 = a1 - 258;
      if ( !v21 )
        return "NNS_ERROR_NMGR_API_NOT_INITIALIZED";
      v22 = v21 - 1;
      if ( !v22 )
        return "NNS_ERROR_NMGR_NOT_PROVIDERS_OR_CONSUMERS_ADDED";
      v23 = v22 - 1;
      if ( !v23 )
        return "NNS_ERROR_NMGR_COMMS_NOT_INITIALIZED";
      v24 = v23 - 1;
      if ( !v24 )
        return "NNS_ERROR_NMGR_MESSAGE_OUT_OF_RANGE";
      v25 = v24 - 1;
      if ( !v25 )
        return "NNS_ERROR_NMGR_SENDING_ASYNC_PACKET";
      v26 = v25 - 1;
      if ( !v26 )
        return "NNS_ERROR_NMGR_SENDING_SYNC_PACKET";
      if ( v26 == 1 )
        return "NNS_ERROR_NMGR_CONFIG_PARAM_INCORRECT";
    }
    return "UNKNOWN_NNS_ERROR";
  }
  if ( a1 > 0x301 )
  {
    if ( a1 <= 0x401 )
    {
      if ( a1 == 1025 )
        return "NNS_ERROR_FILE_NOT_FOUND";
      v33 = a1 - 770;
      if ( !v33 )
        return "NNS_ERROR_WINSOCK_GETADDRINFO";
      v34 = v33 - 1;
      if ( !v34 )
        return "NNS_ERROR_WINSOCK_SOCKET";
      v35 = v34 - 1;
      if ( !v35 )
        return "NNS_ERROR_WINSOCK_BIND";
      v36 = v35 - 1;
      if ( !v36 )
        return "NNS_ERROR_WINSOCK_SENDTO";
      v37 = v36 - 1;
      if ( !v37 )
        return "NNS_ERROR_WINSOCK_RCVFROM";
      if ( v37 == 1 )
        return "NNS_ERROR_WINSOCK_SETSOCKOPTION";
      return "UNKNOWN_NNS_ERROR";
    }
    v38 = a1 - 1281;
    if ( v38 )
    {
      v39 = v38 - 1;
      if ( v39 )
      {
        v40 = v39 - 1;
        if ( v40 )
        {
          v41 = v40 - 2813;
          if ( v41 )
          {
            if ( v41 != 4096 )
              return "UNKNOWN_NNS_ERROR";
            result = "NNS_ERROR_MATCHES";
          }
          else
          {
            result = "NNS_ERROR_DOESNT_MATCH";
          }
        }
        else
        {
          result = "NNS_ERROR_UNIQUE_INSTANCE_ALLOWED";
        }
      }
      else
      {
        result = "NNS_ERROR_API_NOT_INITIALIZED";
      }
    }
    else
    {
      result = "NNS_ERROR_API_ALREADY_INITIALIZED";
    }
  }
  else if ( a1 == 769 )
  {
    result = "NNS_ERROR_WINSOCK_INITIALIZING";
  }
  else
  {
    switch ( a1 )
    {
      case 0x201u:
        result = "NNS_ERROR_FRAGMENT_NO_IP_HEADER_FOUND";
        break;
      case 0x202u:
        result = "NNS_ERROR_FRAGMENT_NO_REASSEMBLY_TOKEN";
        break;
      case 0x203u:
        result = "NNS_ERROR_FRAGMENT_NO_FRAGMENT_TOKEN";
        break;
      case 0x204u:
        result = "NNS_ERROR_FRAGMENT_NO_REASSEMBLED_PACKET";
        break;
      case 0x205u:
        result = "NNS_ERROR_FRAGMENT_REBUILD_DEFRAG_IPV4_SIZE";
        break;
      case 0x206u:
        result = "NNS_ERROR_FRAGMENT_REBUILD_DEFRAG_IPV4_SIZE_EXT";
        break;
      case 0x207u:
        result = "NNS_ERROR_FRAGMENT_REBUILD_DEFRAG_IPV6_HDR_SIZE";
        break;
      case 0x208u:
        result = "NNS_ERROR_FRAGMENT_REBUILD_DEFRAG_IPV6_REASSAM_SIZE";
        break;
      case 0x209u:
        result = "NNS_ERROR_FRAGMENT_REBUILD_DEFRAG_IPV6_FRAG_SIZE";
        break;
      case 0x20Au:
        result = "NNS_ERROR_FRAGMENT_REBUILD_DEFRAG_IPV6_FRAG_OFFSET";
        break;
      case 0x20Bu:
        result = "NNS_ERROR_FRAGMENT_ATTACH_PENDING_IPV4_NO_PACKET";
        break;
      case 0x20Cu:
        result = "NNS_ERROR_FRAGMENT_ATTACH_PENDING_IPV4_SIZE";
        break;
      case 0x20Du:
        result = "NNS_ERROR_FRAGMENT_ATTACH_PENDING_IPV4_REMAIN";
        break;
      case 0x20Eu:
        result = "NNS_ERROR_FRAGMENT_ATTACH_PENDING_IPV6_NO_PACKET";
        break;
      case 0x20Fu:
        result = "NNS_ERROR_FRAGMENT_ATTACH_PENDING_IPV6_SIZE";
        break;
      case 0x210u:
        result = "NNS_ERROR_FRAGMENT_ATTACH_PENDING_IPV6_REMAIN";
        break;
      case 0x211u:
        result = "NNS_ERROR_FRAGMENT_RECONSTRUCTION_IN_PROGRESS";
        break;
      case 0x212u:
        result = "NNS_ERROR_FRAGMENT_REPLICATED_HEADER_AND_OFFSET";
        break;
      default:
        return "UNKNOWN_NNS_ERROR";
    }
  }
  return result;
}

//----- (0000000000025B40) ----------------------------------------------------
const char *__fastcall sub_25B40(int a1)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  int v21; // ecx
  int v22; // ecx
  int v23; // ecx
  int v24; // ecx
  int v25; // ecx
  int v26; // ecx
  int v27; // ecx
  int v28; // ecx
  int v29; // ecx
  int v30; // ecx
  int v31; // ecx
  int v32; // ecx
  int v33; // ecx
  int v34; // ecx
  int v35; // ecx
  int v36; // ecx
  int v37; // ecx
  int v38; // ecx
  int v39; // ecx
  int v40; // ecx
  int v41; // ecx
  int v42; // ecx
  int v43; // ecx
  int v44; // ecx
  int v45; // ecx
  int v46; // ecx
  int v47; // ecx
  int v48; // ecx
  int v49; // ecx
  int v50; // ecx
  int v51; // ecx
  int v52; // ecx
  int v53; // ecx
  int v54; // ecx
  int v55; // ecx
  int v56; // ecx
  int v57; // ecx
  int v58; // ecx
  int v59; // ecx
  int v60; // ecx
  int v61; // ecx
  int v62; // ecx
  int v63; // ecx
  int v64; // ecx
  int v65; // ecx
  int v66; // ecx
  int v67; // ecx
  int v68; // ecx

  if ( a1 <= 249 )
  {
    if ( a1 == 249 )
      return "TYPE_TKEY";
    if ( a1 > 37 )
    {
      if ( a1 > 56 )
      {
        if ( a1 > 101 )
        {
          v54 = a1 - 102;
          if ( !v54 )
            return "TYPE_GID";
          v55 = v54 - 1;
          if ( !v55 )
            return "TYPE_UNSPEC";
          v56 = v55 - 1;
          if ( !v56 )
            return "TYPE_NID";
          v57 = v56 - 1;
          if ( !v57 )
            return "TYPE_L32";
          v58 = v57 - 1;
          if ( !v58 )
            return "TYPE_L64";
          v59 = v58 - 1;
          if ( !v59 )
            return "TYPE_LP";
          v60 = v59 - 1;
          if ( !v60 )
            return "TYPE_EUI48";
          if ( v60 == 1 )
            return "TYPE_EUI64";
        }
        else
        {
          if ( a1 == 101 )
            return "TYPE_UID";
          v46 = a1 - 57;
          if ( !v46 )
            return "TYPE_RKEY";
          v47 = v46 - 1;
          if ( !v47 )
            return "TYPE_TALINK";
          v48 = v47 - 1;
          if ( !v48 )
            return "TYPE_CDS";
          v49 = v48 - 1;
          if ( !v49 )
            return "TYPE_CDNSKEY";
          v50 = v49 - 1;
          if ( !v50 )
            return "TYPE_OPENPGPKEY";
          v51 = v50 - 1;
          if ( !v51 )
            return "TYPE_CSYNC";
          v52 = v51 - 1;
          if ( !v52 )
            return "TYPE_ZONEMD";
          v53 = v52 - 36;
          if ( !v53 )
            return "TYPE_SPF";
          if ( v53 == 1 )
            return "TYPE_UINFO";
        }
      }
      else
      {
        if ( a1 == 56 )
          return "TYPE_NINFO";
        if ( a1 > 47 )
        {
          v39 = a1 - 48;
          if ( !v39 )
            return "TYPE_DNSKEY";
          v40 = v39 - 1;
          if ( !v40 )
            return "TYPE_DHCID";
          v41 = v40 - 1;
          if ( !v41 )
            return "TYPE_NSEC3";
          v42 = v41 - 1;
          if ( !v42 )
            return "TYPE_NSEC3PARAM";
          v43 = v42 - 1;
          if ( !v43 )
            return "TYPE_TLSA";
          v44 = v43 - 1;
          if ( !v44 )
            return "TYPE_SMIMEA";
          v45 = v44 - 1;
          if ( !v45 )
            return "TYPE_Unassigned";
          if ( v45 == 1 )
            return "TYPE_HIP";
        }
        else
        {
          if ( a1 == 47 )
            return "TYPE_NSEC";
          v31 = a1 - 38;
          if ( !v31 )
            return "TYPE_A6";
          v32 = v31 - 1;
          if ( !v32 )
            return "TYPE_DNAME";
          v33 = v32 - 1;
          if ( !v33 )
            return "TYPE_SINK";
          v34 = v33 - 1;
          if ( !v34 )
            return "TYPE_OPT";
          v35 = v34 - 1;
          if ( !v35 )
            return "TYPE_APL";
          v36 = v35 - 1;
          if ( !v36 )
            return "TYPE_DS";
          v37 = v36 - 1;
          if ( !v37 )
            return "TYPE_SSHFP";
          v38 = v37 - 1;
          if ( !v38 )
            return "TYPE_IPSECKEY";
          if ( v38 == 1 )
            return "TYPE_RRSIG";
        }
      }
    }
    else
    {
      if ( a1 == 37 )
        return "TYPE_CERT";
      if ( a1 > 18 )
      {
        if ( a1 > 28 )
        {
          v24 = a1 - 29;
          if ( !v24 )
            return "TYPE_LOC";
          v25 = v24 - 1;
          if ( !v25 )
            return "TYPE_NXT";
          v26 = v25 - 1;
          if ( !v26 )
            return "TYPE_EID";
          v27 = v26 - 1;
          if ( !v27 )
            return "TYPE_NIMLOC";
          v28 = v27 - 1;
          if ( !v28 )
            return "TYPE_SRV";
          v29 = v28 - 1;
          if ( !v29 )
            return "TYPE_ATMA";
          v30 = v29 - 1;
          if ( !v30 )
            return "TYPE_NAPTR";
          if ( v30 == 1 )
            return "TYPE_KX";
        }
        else
        {
          if ( a1 == 28 )
            return "TYPE_AAAA";
          v16 = a1 - 19;
          if ( !v16 )
            return "TYPE_X25";
          v17 = v16 - 1;
          if ( !v17 )
            return "TYPE_ISDN";
          v18 = v17 - 1;
          if ( !v18 )
            return "TYPE_RT";
          v19 = v18 - 1;
          if ( !v19 )
            return "TYPE_NSAP";
          v20 = v19 - 1;
          if ( !v20 )
            return "TYPE_NSAP-PTR";
          v21 = v20 - 1;
          if ( !v21 )
            return "TYPE_SIG";
          v22 = v21 - 1;
          if ( !v22 )
            return "TYPE_KEY";
          v23 = v22 - 1;
          if ( !v23 )
            return "TYPE_PX";
          if ( v23 == 1 )
            return "TYPE_GPOS";
        }
      }
      else
      {
        if ( a1 == 18 )
          return "TYPE_AFSDB";
        if ( a1 > 9 )
        {
          v9 = a1 - 10;
          if ( !v9 )
            return "TYPE_NULL";
          v10 = v9 - 1;
          if ( !v10 )
            return "TYPE_WKS";
          v11 = v10 - 1;
          if ( !v11 )
            return "TYPE_PTR";
          v12 = v11 - 1;
          if ( !v12 )
            return "TYPE_HINFO";
          v13 = v12 - 1;
          if ( !v13 )
            return "TYPE_MINFO";
          v14 = v13 - 1;
          if ( !v14 )
            return "TYPE_MX";
          v15 = v14 - 1;
          if ( !v15 )
            return "TYPE_TXT";
          if ( v15 == 1 )
            return "TYPE_RP";
        }
        else
        {
          if ( a1 == 9 )
            return "TYPE_MR";
          if ( !a1 )
            return "TYPE_UNKNOWN";
          v1 = a1 - 1;
          if ( !v1 )
            return "TYPE_A";
          v2 = v1 - 1;
          if ( !v2 )
            return "TYPE_NS";
          v3 = v2 - 1;
          if ( !v3 )
            return "TYPE_MD";
          v4 = v3 - 1;
          if ( !v4 )
            return "TYPE_MF";
          v5 = v4 - 1;
          if ( !v5 )
            return "TYPE_CNAME";
          v6 = v5 - 1;
          if ( !v6 )
            return "TYPE_SOA";
          v7 = v6 - 1;
          if ( !v7 )
            return "TYPE_MB";
          if ( v7 == 1 )
            return "TYPE_MG";
        }
      }
    }
    return "UNKNOWN";
  }
  if ( a1 <= 0x8000 )
  {
    if ( a1 == 0x8000 )
      return "TYPE_TA";
    if ( a1 > 255 )
    {
      v65 = a1 - 256;
      if ( !v65 )
        return "TYPE_URI";
      v66 = v65 - 1;
      if ( !v66 )
        return "TYPE_CAA";
      v67 = v66 - 1;
      if ( !v67 )
        return "TYPE_AVC";
      v68 = v67 - 1;
      if ( !v68 )
        return "TYPE_DOA";
      if ( v68 == 1 )
        return "TYPE_AMTRELAY";
    }
    else
    {
      if ( a1 == 255 )
        return "TYPE_ALL_ANY";
      v61 = a1 - 250;
      if ( !v61 )
        return "TYPE_TSIG";
      v62 = v61 - 1;
      if ( !v62 )
        return "TYPE_IXFR";
      v63 = v62 - 1;
      if ( !v63 )
        return "TYPE_AXFR";
      v64 = v63 - 1;
      if ( !v64 )
        return "TYPE_MAILB";
      if ( v64 == 1 )
        return "TYPE_MAILA";
    }
    return "UNKNOWN";
  }
  if ( a1 != 32769 )
    return "UNKNOWN";
  return "TYPE_DLV";
}

//----- (0000000000026044) ----------------------------------------------------
const char *__fastcall sub_26044(int a1)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx

  if ( !a1 )
    return "CLASS_TYPE_RESERVED";
  v1 = a1 - 1;
  if ( !v1 )
    return "CLASS_TYPE_INTERNET";
  v2 = v1 - 1;
  if ( !v2 )
    return "CLASS_TYPE_UNASSIGNED";
  v3 = v2 - 1;
  if ( !v3 )
    return "CLASS_TYPE_CHAOS";
  if ( v3 == 1 )
    return "CLASS_TYPE_HESIOD";
  return "CLASS_TYPE_OTHER";
}

//----- (0000000000026094) ----------------------------------------------------
const char *__fastcall sub_26094(int a1)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx

  if ( a1 <= 5 )
  {
    if ( a1 == 5 )
      return "ERROR_QUERY_REFUSED";
    if ( !a1 )
      return "SUCCESS";
    v1 = a1 - 1;
    if ( !v1 )
      return "ERROR_IN_FORMAT";
    v2 = v1 - 1;
    if ( !v2 )
      return "ERROR_SERVER_FAILURE";
    v3 = v2 - 1;
    if ( !v3 )
      return "ERROR_NON_EXIST_DOMAIN";
    if ( v3 == 1 )
      return "ERROR_NOT_IMPLEMENTED";
    return "ERROR_UNKNOWN";
  }
  v5 = a1 - 6;
  if ( !v5 )
    return "ERROR_NAME_EXIST_WHEN_IT_SHOULD_NOT";
  v6 = v5 - 1;
  if ( !v6 )
    return "ERROR_RR_EXIST_WHEN_IT_SHOULD_NOT";
  v7 = v6 - 1;
  if ( !v7 )
    return "ERROR_RR_SET_SHOULD_EXIST_DOESNT";
  v8 = v7 - 1;
  if ( !v8 )
    return "ERROR_SERVER_NOT_AUTH_FOR_ZONE:";
  if ( v8 != 1 )
    return "ERROR_UNKNOWN";
  return "ERROR_NAME_NOT_CONATAINED_IN_ZONE";
}

//----- (0000000000026134) ----------------------------------------------------
const char *__fastcall sub_26134(int a1)
{
  int v1; // ecx
  int v2; // ecx

  if ( !a1 )
    return "NONE";
  v1 = a1 - 1;
  if ( !v1 )
    return "REQUEST";
  v2 = v1 - 1;
  if ( !v2 )
    return "RESPONSE";
  if ( v2 == 1 )
    return "BOTH";
  return "UNKNOWN";
}

//----- (0000000000026178) ----------------------------------------------------
__int64 __fastcall sub_26178(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+88h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B368, 15i64, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000261DC) ----------------------------------------------------
__int64 __fastcall sub_261DC(__int64 a1, __int64 a2, __int64 a3, double a4)
{
  double v5; // [rsp+98h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B368, 12i64, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000026250) ----------------------------------------------------
__int64 __fastcall sub_26250(__int64 a1, __int64 a2, __int64 a3, double a4)
{
  double v5; // [rsp+88h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B368, 13i64, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000262B4) ----------------------------------------------------
__int64 __fastcall sub_262B4(double a1, int a2, double *a3)
{
  unsigned int v3; // esi
  double v6; // xmm6_8
  double v7; // xmm8_8

  v3 = 0;
  v6 = a1;
  v7 = *a3;
  if ( a2 )
  {
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 0x15u)
      && *((_BYTE *)off_2E128 + 169) >= 4u )
    {
      sub_261DC(*((_QWORD *)off_2E128 + 19), 12i64, (__int64)&unk_2B368, v7);
    }
    if ( a2 != 1 )
      v6 = (a1 - v7) / (double)a2 + v7;
    *a3 = v6;
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 0x15u)
      && *((_BYTE *)off_2E128 + 169) >= 4u )
    {
      sub_26250(*((_QWORD *)off_2E128 + 19), 13i64, (__int64)&unk_2B368, v6);
    }
  }
  else
  {
    if ( off_2E128 != &off_2E128
      && _bittest((const signed __int32 *)off_2E128 + 43, 0x15u)
      && *((_BYTE *)off_2E128 + 169) >= 2u )
    {
      sub_14544(*((_QWORD *)off_2E128 + 19), 0xBu, (__int64)&unk_2B368, 0);
    }
    v3 = -2147483391;
  }
  return v3;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000026420) ----------------------------------------------------
__int64 sub_26420(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+88h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2E198(a1, 43i64, &unk_2B2D0, 103i64, (__int64 *)va);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000026484) ----------------------------------------------------
__int64 __fastcall sub_26484(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+88h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B2D0, a2, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000264E0) ----------------------------------------------------
__int64 __fastcall sub_264E0(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+98h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2E198(a1, 43i64, &unk_2B2D0, 189i64, &v5);
}
// 2E198: using guessed type __int64 (__fastcall *qword_2E198)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000026550) ----------------------------------------------------
__int64 __fastcall sub_26550(int a1, _QWORD *a2)
{
  void **v4; // rcx
  int v6; // ebx

  v4 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0xAu, (__int64)&unk_2B2D0);
    v4 = (void **)off_2E128;
  }
  if ( a2 )
  {
    if ( a1 )
    {
      v6 = a1 - 1;
      if ( !v6 )
      {
        if ( v4 != &off_2E128 )
        {
          if ( *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
          {
            sub_11008((__int64)v4[19], 0xDu, (__int64)&unk_2B2D0);
            v4 = (void **)off_2E128;
          }
          if ( v4 != &off_2E128 && (*((_BYTE *)v4 + 108) & 0x20) != 0 && *((_BYTE *)v4 + 105) >= 4u )
            sub_1D1D4((__int64)v4[11], 0x1Au);
        }
        sub_1EA44(a2);
        goto LABEL_32;
      }
      if ( v6 == 1 )
      {
        if ( v4 != &off_2E128 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
          sub_11008((__int64)v4[19], 0xEu, (__int64)&unk_2B2D0);
        sub_1DE30((__int64)a2);
        goto LABEL_32;
      }
    }
    else
    {
      if ( v4 == &off_2E128 )
        return 0i64;
      if ( *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
      {
        sub_11008((__int64)v4[19], 0xCu, (__int64)&unk_2B2D0);
LABEL_32:
        v4 = (void **)off_2E128;
        goto LABEL_33;
      }
    }
LABEL_33:
    if ( v4 != &off_2E128 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
      sub_11008((__int64)v4[19], 0xFu, (__int64)&unk_2B2D0);
    return 0i64;
  }
  if ( v4 != &off_2E128 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 2u )
    sub_11008((__int64)v4[19], 0xBu, (__int64)&unk_2B2D0);
  return 3i64;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000026734) ----------------------------------------------------
__int64 __fastcall sub_26734(int a1, __int64 a2)
{
  void **v4; // rcx
  int v6; // ebx
  unsigned __int16 v7; // dx

  v4 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x10u, (__int64)&unk_2B2D0);
    v4 = (void **)off_2E128;
  }
  if ( a2 )
  {
    if ( a1 )
    {
      v6 = a1 - 1;
      if ( v6 )
      {
        if ( v6 != 1 )
          goto LABEL_27;
        if ( v4 != &off_2E128 )
        {
          if ( *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
          {
            v7 = 20;
LABEL_26:
            sub_11008((__int64)v4[19], v7, (__int64)&unk_2B2D0);
            v4 = (void **)off_2E128;
            goto LABEL_27;
          }
          goto LABEL_27;
        }
      }
      else if ( v4 != &off_2E128 )
      {
        if ( *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
        {
          v7 = 19;
          goto LABEL_26;
        }
LABEL_27:
        if ( v4 != &off_2E128 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
          sub_11008((__int64)v4[19], 0x15u, (__int64)&unk_2B2D0);
        return 0i64;
      }
    }
    else if ( v4 != &off_2E128 )
    {
      if ( *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
      {
        v7 = 18;
        goto LABEL_26;
      }
      goto LABEL_27;
    }
    return 0i64;
  }
  if ( v4 != &off_2E128 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 2u )
    sub_11008((__int64)v4[19], 0x11u, (__int64)&unk_2B2D0);
  return 3i64;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000026894) ----------------------------------------------------
__int64 __fastcall sub_26894(int a1, struct _FAST_MUTEX *a2, KIRQL *a3)
{
  _QWORD *v5; // rcx
  unsigned __int16 v6; // dx
  int v8; // ecx

  if ( !a2 )
  {
    v5 = off_2E128;
    if ( off_2E128 == &off_2E128 || *((char *)off_2E128 + 172) >= 0 || *((_BYTE *)off_2E128 + 169) < 2u )
      return 3i64;
    v6 = 22;
LABEL_6:
    sub_11008(v5[19], v6, (__int64)&unk_2B2D0);
    return 3i64;
  }
  if ( !a3 )
  {
    v5 = off_2E128;
    if ( off_2E128 == &off_2E128 || *((char *)off_2E128 + 172) >= 0 || *((_BYTE *)off_2E128 + 169) < 2u )
      return 3i64;
    v6 = 23;
    goto LABEL_6;
  }
  v8 = a1 - 1;
  if ( v8 )
  {
    if ( v8 == 1 )
      sub_1DF10(a2);
  }
  else
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 0x20) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
      sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x1Bu);
    sub_1EAC8((PKSPIN_LOCK)a2, a3);
  }
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;

//----- (00000000000269A4) ----------------------------------------------------
__int64 __fastcall sub_269A4(int a1, struct _FAST_MUTEX *a2, KIRQL a3)
{
  __int64 result; // rax
  int v6; // ecx

  if ( a2 )
  {
    v6 = a1 - 1;
    if ( v6 )
    {
      if ( v6 == 1 )
        sub_1DFDC(a2);
    }
    else
    {
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 108) & 0x20) != 0 && *((_BYTE *)off_2E128 + 105) >= 4u )
        sub_1D1D4(*((_QWORD *)off_2E128 + 11), 0x1Cu);
      sub_1EB80((PKSPIN_LOCK)a2, a3);
    }
    result = 0i64;
  }
  else
  {
    if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x18u, (__int64)&unk_2B2D0);
    result = 3i64;
  }
  return result;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000026A80) ----------------------------------------------------
__int64 __fastcall sub_26A80(__int64 a1, __int64 a2, char a3)
{
  void **v6; // rcx
  unsigned __int16 v7; // dx

  v6 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x19u, (__int64)&unk_2B2D0);
    v6 = (void **)off_2E128;
  }
  if ( !a1 )
  {
    if ( v6 == &off_2E128 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 26;
LABEL_10:
    sub_11008((__int64)v6[19], v7, (__int64)&unk_2B2D0);
    return 3i64;
  }
  if ( !a2 )
  {
    if ( v6 == &off_2E128 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 27;
    goto LABEL_10;
  }
  *(_DWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 8) = a2;
  *(_QWORD *)a2 = a2;
  if ( a3 )
    sub_26550(*(_DWORD *)(a1 + 24), (_QWORD *)(a2 + 24));
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x1Cu, (__int64)&unk_2B2D0);
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000026BAC) ----------------------------------------------------
__int64 __fastcall sub_26BAC(__int64 a1, __int64 a2, char a3)
{
  void **v6; // rcx
  unsigned __int16 v7; // dx

  v6 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x1Du, (__int64)&unk_2B2D0);
    v6 = (void **)off_2E128;
  }
  if ( !a1 )
  {
    if ( v6 == &off_2E128 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 30;
LABEL_10:
    sub_11008((__int64)v6[19], v7, (__int64)&unk_2B2D0);
    return 3i64;
  }
  if ( !a2 )
  {
    if ( v6 == &off_2E128 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 31;
    goto LABEL_10;
  }
  if ( a3 )
  {
    sub_26734(*(_DWORD *)(a1 + 24), a2 + 24);
    v6 = (void **)off_2E128;
  }
  if ( v6 != &off_2E128 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_11008((__int64)v6[19], 0x20u, (__int64)&unk_2B2D0);
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000026CD0) ----------------------------------------------------
_DWORD *__fastcall sub_26CD0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6, int a7, int a8, int a9, int a10, _DWORD *a11)
{
  int v11; // eax
  int v12; // esi
  _DWORD *v14; // rbx
  char *v15; // rax
  unsigned int i; // edi
  void **v17; // rcx

  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x21u, (__int64)&unk_2B2D0);
  *a11 = 0;
  v11 = sub_296F0();
  v12 = v11;
  if ( !v11 )
  {
    if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 2u )
      sub_14544(*((_QWORD *)off_2E128 + 19), 0x23u, (__int64)&unk_2B2D0, 2);
    *a11 = 3;
    return 0i64;
  }
  v14 = sub_1D254(2, 16 * (5 * v11 + 5), 0x73736E44u);
  if ( !v14 )
  {
    if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x25u, (__int64)&unk_2B2D0);
LABEL_17:
    *a11 = 2;
    return 0i64;
  }
  v15 = sub_1D4C0(1, 0x38u, 0x73736E44u);
  *((_QWORD *)v14 + 9) = v15;
  if ( !v15 )
  {
    if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x26u, (__int64)&unk_2B2D0);
    sub_1D2D8(v14, 0x73736E44u);
    goto LABEL_17;
  }
  v14[3] = 1936944708;
  *((_QWORD *)v14 + 2) = 0i64;
  *v14 = 0;
  v14[1] = v12;
  v14[2] = 0;
  v14[6] = 2;
  for ( i = 0; i < v14[1]; ++i )
    sub_26A80((__int64)v14, (__int64)&v14[20 * i + 20], 1);
  *((_QWORD *)v14 + 5) = 0i64;
  *((_QWORD *)v14 + 6) = 0i64;
  *((_QWORD *)v14 + 7) = sub_1A9A0;
  *((_QWORD *)v14 + 8) = 0i64;
  v17 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 4u )
    {
      sub_26484(*((_QWORD *)off_2E128 + 19), 0x27u, (__int64)&unk_2B2D0, v14[1]);
      v17 = (void **)off_2E128;
    }
    if ( v17 != &off_2E128 && *((char *)v17 + 172) < 0 && *((_BYTE *)v17 + 169) >= 5u )
      sub_11008((__int64)v17[19], 0x28u, (__int64)&unk_2B2D0);
  }
  return v14;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000026F58) ----------------------------------------------------
__int64 __fastcall sub_26F58(__int64 a1)
{
  char *v1; // rdi
  void **v2; // rcx
  __int64 v4; // rsi
  _QWORD **v5; // r12
  int v6; // ecx
  struct _FAST_MUTEX *v7; // r14
  _QWORD *v8; // rbp
  __int64 v9; // r13
  void **v10; // rcx
  ULONG_PTR v11; // rbx
  int v12; // eax
  int i; // ebx
  __int64 j; // rbx
  void **v15; // rcx
  __int64 v16; // [rsp+20h] [rbp-98h]
  __int64 v17; // [rsp+30h] [rbp-88h] BYREF
  _BYTE v18[72]; // [rsp+38h] [rbp-80h] BYREF
  __int64 v19; // [rsp+C0h] [rbp+8h] BYREF
  unsigned int v20; // [rsp+D0h] [rbp+18h] BYREF
  union _LARGE_INTEGER Interval; // [rsp+D8h] [rbp+20h] BYREF

  v19 = a1;
  v20 = 0;
  v1 = (char *)qword_30F88;
  v17 = 0i64;
  memset(v18, 0, sizeof(v18));
  v2 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 0x80) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x36u, (__int64)&unk_2B2D0);
    v2 = (void **)off_2E128;
  }
  if ( !v1 )
  {
    if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 172) & 0x80) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x37u, (__int64)&unk_2B2D0);
    return 3i64;
  }
  if ( v2 != &off_2E128 && (*((_BYTE *)v2 + 172) & 0x80) != 0 && *((_BYTE *)v2 + 169) >= 4u )
    sub_26484((__int64)v2[19], 0x38u, (__int64)&unk_2B2D0, *((_DWORD *)v1 + 1));
  _InterlockedAdd((volatile signed __int32 *)v1 + 7, 1u);
  v4 = 0i64;
  if ( !*((_DWORD *)v1 + 1) )
    goto LABEL_38;
  v5 = (_QWORD **)(v1 + 80);
  do
  {
    v6 = *((_DWORD *)v1 + 6);
    v7 = (struct _FAST_MUTEX *)&v1[80 * v4 + 104];
    Interval.QuadPart = (LONGLONG)v7;
    sub_26894(v6, v7, (KIRQL *)&v19);
    v8 = *v5;
    v9 = (__int64)&v1[80 * v4 + 80];
    if ( *v5 == (_QWORD *)v9 )
      goto LABEL_37;
    v10 = (void **)off_2E128;
    do
    {
      v11 = (ULONG_PTR)v8;
      v8 = (_QWORD *)*v8;
      if ( *(_BYTE *)(v11 + 44) )
      {
        if ( v10 != &off_2E128 && *((char *)v10 + 172) < 0 && *((_BYTE *)v10 + 169) >= 4u )
        {
          LODWORD(v16) = *(_DWORD *)(v11 + 40);
          sub_1FF64((__int64)v10[19], 0x39u, (__int64)&unk_2B2D0, *(_QWORD *)(v11 + 16), v16);
LABEL_34:
          v10 = (void **)off_2E128;
          continue;
        }
      }
      else
      {
        if ( !sub_29458(v1, &v20) )
          v20 = sub_29190((ULONG_PTR)v1, v11, 1);
        if ( *(_DWORD *)(v11 + 40) )
        {
          *(_BYTE *)(v11 + 44) = 1;
          goto LABEL_34;
        }
        v20 = sub_27670((__int64)v1, v4, (__int64 *)v11);
        if ( !v20 )
        {
          sub_2786C((__int64)v1, (__int64)&v17, v11);
          goto LABEL_34;
        }
        v10 = (void **)off_2E128;
        if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 3u )
        {
          sub_11008(*((_QWORD *)off_2E128 + 19), 0x3Au, (__int64)&unk_2B2D0);
          goto LABEL_34;
        }
      }
    }
    while ( v8 != (_QWORD *)v9 );
    v7 = (struct _FAST_MUTEX *)Interval.QuadPart;
LABEL_37:
    sub_269A4(*((_DWORD *)v1 + 6), v7, v19);
    v4 = (unsigned int)(v4 + 1);
    v5 += 10;
  }
  while ( (unsigned int)v4 < *((_DWORD *)v1 + 1) );
LABEL_38:
  sub_279EC((__int64)v1, (__int64)&v17);
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 0x80) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x3Bu, (__int64)&unk_2B2D0);
  v12 = sub_27C1C((__int64)v1, &v20);
  if ( v12 )
  {
    Interval.QuadPart = -5000000i64;
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 0x80) != 0 && *((_BYTE *)off_2E128 + 169) >= 3u )
      sub_14544(*((_QWORD *)off_2E128 + 19), 0x3Cu, (__int64)&unk_2B2D0, v12);
    for ( i = 0; i < 10; ++i )
    {
      if ( !(unsigned int)sub_27C1C((__int64)v1, &v20) )
        break;
      if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 0x80) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
        sub_14544(*((_QWORD *)off_2E128 + 19), 0x3Du, (__int64)&unk_2B2D0, i);
      KeDelayExecutionThread(0, 0, &Interval);
    }
  }
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 0x80) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x3Eu, (__int64)&unk_2B2D0);
  for ( j = 0i64; (unsigned int)j < *((_DWORD *)v1 + 1); j = (unsigned int)(j + 1) )
    sub_26BAC((__int64)v1, (__int64)&v1[80 * j + 80], 1);
  sub_1D544(*((PVOID *)v1 + 9));
  sub_1D2D8(v1, *((_DWORD *)v1 + 3));
  v15 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 )
  {
    if ( (*((_BYTE *)off_2E128 + 172) & 0x80) != 0 && *((_BYTE *)off_2E128 + 169) >= 4u )
    {
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x3Fu, (__int64)&unk_2B2D0);
      v15 = (void **)off_2E128;
    }
    if ( v15 != &off_2E128 && (*((_BYTE *)v15 + 172) & 0x80) != 0 && *((_BYTE *)v15 + 169) >= 5u )
      sub_11008((__int64)v15[19], 0x40u, (__int64)&unk_2B2D0);
  }
  return v20;
}
// 270FA: variable 'v16' is possibly undefined
// 2E128: using guessed type void *off_2E128;

//----- (00000000000273EC) ----------------------------------------------------
unsigned __int64 __fastcall sub_273EC(__int64 a1, unsigned __int64 a2, _DWORD *a3)
{
  void **v6; // rcx
  unsigned __int64 result; // rax

  v6 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x5Au, (__int64)&unk_2B2D0);
    v6 = (void **)off_2E128;
  }
  *a3 = 0;
  if ( a1 )
  {
    if ( v6 != &off_2E128 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 5u )
      sub_11008((__int64)v6[19], 0x5Cu, (__int64)&unk_2B2D0);
    result = a2 % *(unsigned int *)(a1 + 4);
  }
  else
  {
    if ( v6 != &off_2E128 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 2u )
      sub_11008((__int64)v6[19], 0x5Bu, (__int64)&unk_2B2D0);
    *a3 = 3;
    result = 0xFFFFFFFFi64;
  }
  return result;
}
// 2E128: using guessed type void *off_2E128;

//----- (00000000000274E8) ----------------------------------------------------
_DWORD *__fastcall sub_274E8(__int64 a1, __int64 a2, _DWORD *a3)
{
  void **v6; // rcx
  unsigned __int16 v7; // dx
  _DWORD *v9; // rax
  _DWORD *v10; // rdi
  __int64 v11; // r11

  v6 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x5Du, (__int64)&unk_2B2D0);
    v6 = (void **)off_2E128;
  }
  *a3 = 0;
  if ( !a1 )
  {
    if ( v6 == &off_2E128 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_11;
    v7 = 94;
LABEL_10:
    sub_11008((__int64)v6[19], v7, (__int64)&unk_2B2D0);
LABEL_11:
    *a3 = 3;
    return 0i64;
  }
  if ( !a2 )
  {
    if ( v6 == &off_2E128 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_11;
    v7 = 95;
    goto LABEL_10;
  }
  v9 = sub_1D664(*(_QWORD *)(a1 + 72));
  v10 = v9;
  if ( !v9 )
  {
    if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x60u, (__int64)&unk_2B2D0);
    *a3 = 2;
    return 0i64;
  }
  memset(v9, 0, 0x38ui64);
  v11 = *(_QWORD *)(a1 + 16);
  *((_QWORD *)v10 + 4) = a2;
  *((_QWORD *)v10 + 3) = v11;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x61u, (__int64)&unk_2B2D0);
  return v10;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000027670) ----------------------------------------------------
__int64 __fastcall sub_27670(__int64 a1, unsigned int a2, __int64 *a3)
{
  __int64 v4; // rsi
  void **v6; // rcx
  unsigned __int16 v7; // dx
  __int64 result; // rax
  _QWORD *v9; // rax
  __int64 v10; // rcx
  signed __int32 v11; // eax
  void **v12; // rcx
  __int64 v13; // [rsp+20h] [rbp-28h]
  unsigned int v14; // [rsp+50h] [rbp+8h] BYREF

  v14 = 0;
  v4 = a2;
  v6 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x62u, (__int64)&unk_2B2D0);
    v6 = (void **)off_2E128;
  }
  if ( !a1 )
  {
    if ( v6 == &off_2E128 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 99;
LABEL_10:
    sub_11008((__int64)v6[19], v7, (__int64)&unk_2B2D0);
    return 3i64;
  }
  if ( !a3 )
  {
    if ( v6 == &off_2E128 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 100;
    goto LABEL_10;
  }
  if ( v6 != &off_2E128 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_1FF64((__int64)v6[19], 0x65u, (__int64)&unk_2B2D0, a3[2], *((_DWORD *)a3 + 10));
  if ( sub_295A4((_BYTE *)a1, &v14) )
  {
    if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 4u )
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x66u, (__int64)&unk_2B2D0);
    result = 12i64;
  }
  else
  {
    v9 = (_QWORD *)a3[1];
    v10 = *a3;
    *v9 = *a3;
    *(_QWORD *)(v10 + 8) = v9;
    --*(_DWORD *)(a1 + 80 * v4 + 96);
    v11 = _InterlockedDecrement((volatile signed __int32 *)(a1 + 8));
    v12 = (void **)off_2E128;
    if ( off_2E128 != &off_2E128 )
    {
      if ( *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 4u )
      {
        LODWORD(v13) = *(_DWORD *)(a1 + 80 * v4 + 96);
        sub_26420(*((_QWORD *)off_2E128 + 19), 103i64, (__int64)&unk_2B2D0, a3[2], v13, v11);
        v12 = (void **)off_2E128;
      }
      if ( v12 != &off_2E128 && *((char *)v12 + 172) < 0 && *((_BYTE *)v12 + 169) >= 5u )
        sub_11008((__int64)v12[19], 0x68u, (__int64)&unk_2B2D0);
    }
    result = v14;
  }
  return result;
}
// 27815: variable 'v13' is possibly undefined
// 2E128: using guessed type void *off_2E128;

//----- (000000000002786C) ----------------------------------------------------
__int64 __fastcall sub_2786C(__int64 a1, __int64 a2, __int64 a3)
{
  void **v6; // rcx
  __int64 *v7; // rax
  __int64 result; // rax
  int v9; // [rsp+20h] [rbp-18h]

  v6 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x69u, (__int64)&unk_2B2D0);
    v6 = (void **)off_2E128;
  }
  if ( a1 && a2 && a3 )
  {
    if ( !*(_DWORD *)(a2 + 16) )
    {
      sub_26A80(a1, a2, 0);
      v6 = (void **)off_2E128;
    }
    if ( v6 != &off_2E128 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 5u )
    {
      v9 = *(_DWORD *)(a3 + 40);
      sub_1FF64((__int64)v6[19], 0x6Bu, (__int64)&unk_2B2D0, *(_QWORD *)(a3 + 16), v9);
    }
    v7 = *(__int64 **)(a2 + 8);
    *(_QWORD *)a3 = a2;
    *(_QWORD *)(a3 + 8) = v7;
    *v7 = a3;
    ++*(_DWORD *)(a2 + 16);
    *(_QWORD *)(a2 + 8) = a3;
    if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x6Cu, (__int64)&unk_2B2D0);
    result = 0i64;
  }
  else
  {
    if ( v6 != &off_2E128 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 2u )
      sub_14C58((__int64)v6[19], 0x6Au, (__int64)&unk_2B2D0, a1, a2, a3);
    result = 3i64;
  }
  return result;
}
// 2E128: using guessed type void *off_2E128;

//----- (00000000000279EC) ----------------------------------------------------
__int64 __fastcall sub_279EC(__int64 a1, __int64 a2)
{
  unsigned int v4; // edi
  void **v5; // rcx
  __int64 *v6; // r12
  __int64 *v7; // rsi
  __int64 v8; // rcx
  __int64 *v9; // rax
  __int64 v10; // rcx
  void (__fastcall *v11)(__int64); // rax
  __int64 result; // rax

  v4 = 0;
  v5 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x6Du, (__int64)&unk_2B2D0);
    v5 = (void **)off_2E128;
  }
  if ( a1 && a2 )
  {
    if ( *(_DWORD *)(a2 + 16) )
    {
      v6 = *(__int64 **)a2;
      while ( *(_QWORD *)a2 != a2 )
      {
        v7 = v6;
        v6 = (__int64 *)*v6;
        v8 = *v7;
        v9 = (__int64 *)v7[1];
        *v9 = *v7;
        *(_QWORD *)(v8 + 8) = v9;
        --*(_DWORD *)(a2 + 16);
        v10 = v7[4];
        if ( v10 )
        {
          v11 = *(void (__fastcall **)(__int64))(a1 + 56);
          if ( v11 )
          {
            v11(v10);
            if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
              sub_12374(*((_QWORD *)off_2E128 + 19), 0x71u, (__int64)&unk_2B2D0, v7[2]);
            sub_1D6CC(*(_QWORD *)(a1 + 72), (__int64)v7);
          }
          else
          {
            if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 2u )
              sub_11008(*((_QWORD *)off_2E128 + 19), 0x70u, (__int64)&unk_2B2D0);
            v4 = 5;
          }
        }
        else
        {
          if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 2u )
            sub_11008(*((_QWORD *)off_2E128 + 19), 0x6Fu, (__int64)&unk_2B2D0);
          v4 = 6;
        }
      }
    }
    else
    {
      v4 = 4;
    }
    sub_26BAC(a1, a2, 0);
    if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x72u, (__int64)&unk_2B2D0);
    result = v4;
  }
  else
  {
    if ( v5 != &off_2E128 && *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 2u )
      sub_14BA4((__int64)v5[19], 0x6Eu, (__int64)&unk_2B2D0, a1, a2);
    result = 3i64;
  }
  return result;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000027C1C) ----------------------------------------------------
__int64 __fastcall sub_27C1C(__int64 a1, _DWORD *a2)
{
  void **v4; // rcx
  __int64 result; // rax
  unsigned __int32 v6; // ebx

  v4 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x73u, (__int64)&unk_2B2D0);
    v4 = (void **)off_2E128;
  }
  *a2 = 0;
  if ( a1 )
  {
    v6 = _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 8), 0);
    if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x75u, (__int64)&unk_2B2D0);
    result = v6;
  }
  else
  {
    if ( v4 != &off_2E128 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x74u, (__int64)&unk_2B2D0);
    *a2 = 3;
    result = 0i64;
  }
  return result;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000027D14) ----------------------------------------------------
__int64 __fastcall sub_27D14(__int64 a1, unsigned __int64 a2, __int64 a3, ULONG_PTR **a4)
{
  volatile signed __int32 *v4; // rdi
  void **v8; // rcx
  unsigned __int16 v9; // dx
  __int64 result; // rax
  ULONG_PTR v11; // rax
  void **v12; // rcx
  unsigned int v13; // ebx
  __int64 v14; // [rsp+60h] [rbp+8h] BYREF

  HIDWORD(v14) = HIDWORD(a1);
  v4 = (volatile signed __int32 *)qword_30F88;
  LODWORD(v14) = 0;
  v8 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x86u, (__int64)&unk_2B2D0);
    v8 = (void **)off_2E128;
  }
  if ( a4 )
    *a4 = 0i64;
  if ( !v4 )
  {
    if ( v8 == &off_2E128 || *((char *)v8 + 172) >= 0 || *((_BYTE *)v8 + 169) < 2u )
      return 3i64;
    v9 = 135;
LABEL_12:
    sub_11008((__int64)v8[19], v9, (__int64)&unk_2B2D0);
    return 3i64;
  }
  if ( !a3 )
  {
    if ( v8 == &off_2E128 || *((char *)v8 + 172) >= 0 || *((_BYTE *)v8 + 169) < 2u )
      return 3i64;
    v9 = 136;
    goto LABEL_12;
  }
  if ( _InterlockedCompareExchange(v4 + 7, 0, 0) )
  {
    if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x89u, (__int64)&unk_2B2D0);
    result = 9i64;
  }
  else
  {
    v11 = sub_28590((ULONG_PTR)v4, a2, a3, a4, (__int64)&v14);
    if ( v11 )
    {
      if ( v11 == a3 )
      {
        v13 = v14;
        v12 = (void **)off_2E128;
      }
      else
      {
        if ( a4 )
          sub_28EA8((ULONG_PTR)v4, (ULONG_PTR)*a4);
        v12 = (void **)off_2E128;
        if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 2u )
        {
          sub_12374(*((_QWORD *)off_2E128 + 19), 0x8Bu, (__int64)&unk_2B2D0, a2);
          v12 = (void **)off_2E128;
        }
        v13 = 7;
      }
      if ( v12 != &off_2E128 && *((char *)v12 + 172) < 0 && *((_BYTE *)v12 + 169) >= 5u )
        sub_11008((__int64)v12[19], 0x8Cu, (__int64)&unk_2B2D0);
      result = v13;
    }
    else
    {
      if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 2u )
        sub_14544(*((_QWORD *)off_2E128 + 19), 0x8Au, (__int64)&unk_2B2D0, v14);
      result = (unsigned int)v14;
    }
  }
  return result;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000027F50) ----------------------------------------------------
__int64 __fastcall sub_27F50(__int64 a1, unsigned __int64 a2, __int64 a3, _DWORD *a4)
{
  char *v4; // rbx
  __int64 v5; // rbp
  void **v8; // rcx
  __int64 v10; // r14
  struct _FAST_MUTEX *v11; // r13
  _QWORD *v12; // rax
  __int64 v13; // rsi
  int v14; // eax
  __int64 v15; // [rsp+20h] [rbp-78h] BYREF
  _BYTE v16[72]; // [rsp+28h] [rbp-70h] BYREF
  __int64 v17; // [rsp+A0h] [rbp+8h] BYREF

  v17 = a1;
  v4 = (char *)qword_30F88;
  v5 = 0i64;
  v15 = 0i64;
  memset(v16, 0, sizeof(v16));
  v8 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 0x80) != 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x93u, (__int64)&unk_2B2D0);
    v8 = (void **)off_2E128;
  }
  *a4 = 0;
  if ( !v4 )
  {
    if ( v8 != &off_2E128 && (*((_BYTE *)v8 + 172) & 0x80) != 0 && *((_BYTE *)v8 + 169) >= 2u )
      sub_11008((__int64)v8[19], 0x94u, (__int64)&unk_2B2D0);
    *a4 = 3;
    return 0i64;
  }
  if ( sub_29458(v4, a4) )
  {
    if ( off_2E128 != &off_2E128 && (*((_BYTE *)off_2E128 + 172) & 0x80) != 0 && *((_BYTE *)off_2E128 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_2E128 + 19), 0x95u, (__int64)&unk_2B2D0);
    *a4 = 10;
    return 0i64;
  }
  v10 = (unsigned int)sub_273EC((__int64)v4, a2, a4);
  v11 = (struct _FAST_MUTEX *)&v4[80 * v10 + 104];
  sub_26894(*((_DWORD *)v4 + 6), v11, (KIRQL *)&v17);
  v12 = sub_283D0((__int64)v4, v10, a2, a4);
  v13 = (__int64)v12;
  if ( v12 )
  {
    if ( *a4 == 8 )
    {
      sub_269A4(*((_DWORD *)v4 + 6), v11, v17);
      if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 3u )
        sub_12374(*((_QWORD *)off_2E128 + 19), 0x96u, (__int64)&unk_2B2D0, a2, v15);
      return 0i64;
    }
    sub_29190((ULONG_PTR)v4, (ULONG_PTR)v12, 0);
    v5 = *(_QWORD *)(v13 + 32);
    if ( *(_DWORD *)(v13 + 40) )
    {
      *(_BYTE *)(v13 + 44) = 1;
    }
    else
    {
      v14 = sub_27670((__int64)v4, v10, (__int64 *)v13);
      *a4 = v14;
      if ( !v14 )
        sub_2786C((__int64)v4, (__int64)&v15, v13);
    }
  }
  sub_269A4(*((_DWORD *)v4 + 6), v11, v17);
  sub_279EC((__int64)v4, (__int64)&v15);
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x97u, (__int64)&unk_2B2D0);
  return v5;
}
// 2E128: using guessed type void *off_2E128;

//----- (00000000000281DC) ----------------------------------------------------
__int64 __fastcall sub_281DC(__int64 a1, unsigned __int64 a2, _QWORD *a3, _DWORD *a4)
{
  _DWORD *v4; // rdi
  __int64 v8; // r12
  void **v9; // rcx
  unsigned int v11; // ebx
  struct _FAST_MUTEX *v12; // r13
  _QWORD *v13; // rax
  _QWORD *v14; // rbx
  __int64 v15; // [rsp+50h] [rbp+8h] BYREF

  v15 = a1;
  v4 = qword_30F88;
  v8 = 0i64;
  v9 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0xACu, (__int64)&unk_2B2D0);
    v9 = (void **)off_2E128;
  }
  *a4 = 4;
  if ( a3 )
    *a3 = 0i64;
  if ( !v4 )
  {
    if ( v9 != &off_2E128 && *((char *)v9 + 172) < 0 && *((_BYTE *)v9 + 169) >= 2u )
      sub_11008((__int64)v9[19], 0xADu, (__int64)&unk_2B2D0);
    *a4 = 3;
    return 0i64;
  }
  v11 = sub_273EC((__int64)v4, a2, a4);
  v12 = (struct _FAST_MUTEX *)&v4[20 * v11 + 26];
  sub_26894(v4[6], v12, (KIRQL *)&v15);
  v13 = sub_283D0((__int64)v4, v11, a2, a4);
  v14 = v13;
  if ( v13 )
  {
    if ( *a4 == 8 )
    {
      sub_269A4(v4[6], v12, v15);
      if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 3u )
        sub_12374(*((_QWORD *)off_2E128 + 19), 0xAEu, (__int64)&unk_2B2D0, a2);
      return 0i64;
    }
    v8 = v13[4];
    if ( a3 )
    {
      sub_2904C((ULONG_PTR)v4, (ULONG_PTR)v13, 0);
      *a3 = v14;
    }
  }
  sub_269A4(v4[6], v12, v15);
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 19), 0xAFu, (__int64)&unk_2B2D0);
  return v8;
}
// 2E128: using guessed type void *off_2E128;

//----- (00000000000283D0) ----------------------------------------------------
_QWORD *__fastcall sub_283D0(__int64 a1, unsigned int a2, __int64 a3, _DWORD *a4)
{
  __int64 v6; // r12
  _QWORD *v8; // rsi
  void **v9; // rcx
  _QWORD *result; // rax
  _QWORD *v11; // rdx
  _QWORD *v12; // rbx

  v6 = a2;
  v8 = 0i64;
  v9 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0xB0u, (__int64)&unk_2B2D0);
    v9 = (void **)off_2E128;
  }
  *a4 = 4;
  if ( a1 )
  {
    v11 = (_QWORD *)(a1 + 16 * (5 * v6 + 5));
    if ( (_QWORD *)*v11 != v11 )
    {
      v12 = (_QWORD *)*v11;
      while ( v12 != v11 )
      {
        v8 = v12;
        if ( v12[2] == a3 )
        {
          if ( v9 != &off_2E128 && *((char *)v9 + 172) < 0 && *((_BYTE *)v9 + 169) >= 4u )
          {
            sub_1FE44((__int64)v9[19], 0xB2u, (__int64)&unk_2B2D0, v6);
            v9 = (void **)off_2E128;
          }
          if ( *((_BYTE *)v12 + 44) )
          {
            if ( v9 != &off_2E128 && *((char *)v9 + 172) < 0 && *((_BYTE *)v9 + 169) >= 4u )
            {
              sub_12374((__int64)v9[19], 0xB3u, (__int64)&unk_2B2D0, v12[2]);
              v9 = (void **)off_2E128;
            }
            *a4 = 8;
          }
          else
          {
            *a4 = 0;
          }
          break;
        }
        v12 = (_QWORD *)*v12;
        v8 = 0i64;
      }
    }
    if ( v9 != &off_2E128 && *((char *)v9 + 172) < 0 && *((_BYTE *)v9 + 169) >= 5u )
      sub_11008((__int64)v9[19], 0xB4u, (__int64)&unk_2B2D0);
    result = v8;
  }
  else
  {
    if ( v9 != &off_2E128 && *((char *)v9 + 172) < 0 && *((_BYTE *)v9 + 169) >= 2u )
      sub_11008((__int64)v9[19], 0xB1u, (__int64)&unk_2B2D0);
    *a4 = 3;
    result = 0i64;
  }
  return result;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000028590) ----------------------------------------------------
ULONG_PTR __fastcall sub_28590(ULONG_PTR BugCheckParameter2, unsigned __int64 a2, __int64 a3, ULONG_PTR **a4, __int64 a5)
{
  ULONG_PTR v9; // r12
  unsigned int v10; // er14
  void **v11; // rcx
  _DWORD *v12; // rbp
  int v14; // ebx
  unsigned int v15; // edi
  __int64 v16; // r14
  ULONG_PTR *v17; // rax
  ULONG_PTR *v18; // rdi
  ULONG_PTR *v19; // rax
  ULONG_PTR v20; // rcx
  ULONG_PTR **v21; // rax
  ULONG_PTR v22; // [rsp+20h] [rbp-58h]
  int v23[4]; // [rsp+40h] [rbp-38h] BYREF
  int v24; // [rsp+80h] [rbp+8h]

  v9 = 0i64;
  v23[0] = 0;
  v10 = 0;
  v11 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0xB5u, (__int64)&unk_2B2D0);
    v11 = (void **)off_2E128;
  }
  v12 = (_DWORD *)a5;
  if ( !a5 )
  {
    if ( v11 != &off_2E128 && *((char *)v11 + 172) < 0 && *((_BYTE *)v11 + 169) >= 2u )
      sub_11008((__int64)v11[19], 0xB6u, (__int64)&unk_2B2D0);
    return 0i64;
  }
  if ( !BugCheckParameter2 )
  {
    if ( v11 != &off_2E128 && *((char *)v11 + 172) < 0 && *((_BYTE *)v11 + 169) >= 2u )
      sub_11008((__int64)v11[19], 0xB7u, (__int64)&unk_2B2D0);
    *v12 = 3;
    return 0i64;
  }
  if ( !a3 )
  {
    if ( v11 != &off_2E128 && *((char *)v11 + 172) < 0 && *((_BYTE *)v11 + 169) >= 2u )
      sub_11008((__int64)v11[19], 0xB8u, (__int64)&unk_2B2D0);
    v14 = 3;
    goto LABEL_37;
  }
  if ( _InterlockedCompareExchange((volatile signed __int32 *)(BugCheckParameter2 + 28), 0, 0) )
  {
    if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_2E128 + 19), 0xB9u, (__int64)&unk_2B2D0);
    *v12 = 9;
    return 0i64;
  }
  v15 = sub_273EC(BugCheckParameter2, a2, v23);
  v24 = v15;
  v16 = 10i64 * v15;
  sub_26894(
    *(_DWORD *)(BugCheckParameter2 + 24),
    (struct _FAST_MUTEX *)(BugCheckParameter2 + 80i64 * v15 + 104),
    (KIRQL *)&a5);
  if ( sub_2930C((_BYTE *)BugCheckParameter2, v23)
    || (v17 = sub_283D0(BugCheckParameter2, v15, a2, v23), (v18 = v17) == 0i64) )
  {
    v19 = (ULONG_PTR *)sub_274E8(BugCheckParameter2, a3, v23);
    v18 = v19;
    if ( !v19 )
    {
      v14 = 2;
      if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 2u )
        sub_11008(*((_QWORD *)off_2E128 + 19), 0xBCu, (__int64)&unk_2B2D0);
      goto LABEL_36;
    }
    v19[2] = a2;
    if ( !sub_29458((_BYTE *)BugCheckParameter2, v23) )
      sub_2904C(BugCheckParameter2, (ULONG_PTR)v18, 1);
    v20 = BugCheckParameter2 + 8 * v16 + 80;
    v21 = *(ULONG_PTR ***)(BugCheckParameter2 + 8 * v16 + 88);
    *v18 = v20;
    v18[1] = (ULONG_PTR)v21;
    *v21 = v18;
    *(_QWORD *)(v20 + 8) = v18;
    ++*(_DWORD *)(BugCheckParameter2 + 8 * v16 + 96);
    _InterlockedIncrement((volatile signed __int32 *)(BugCheckParameter2 + 8));
    if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 4u )
    {
      v10 = v24;
      v22 = v18[2];
      sub_264E0(*((_QWORD *)off_2E128 + 19), 189i64, (__int64)&unk_2B2D0, v24);
      v14 = v23[0];
      goto LABEL_59;
    }
    v14 = v23[0];
LABEL_58:
    v10 = v24;
LABEL_59:
    v9 = v18[4];
    if ( a4 )
    {
      sub_2904C(BugCheckParameter2, (ULONG_PTR)v18, 1);
      *a4 = v18;
    }
    goto LABEL_37;
  }
  sub_29814(BugCheckParameter2, (ULONG_PTR)v17);
  v14 = v23[0];
  if ( v23[0] != 8 )
  {
    if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 )
    {
      v10 = v24;
      if ( *((_BYTE *)off_2E128 + 169) >= 4u )
      {
        v22 = v18[2];
        sub_1FE44(*((_QWORD *)off_2E128 + 19), 0xBBu, (__int64)&unk_2B2D0, v24);
      }
      goto LABEL_59;
    }
    goto LABEL_58;
  }
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 3u )
    sub_12374(*((_QWORD *)off_2E128 + 19), 0xBAu, (__int64)&unk_2B2D0, a2);
LABEL_36:
  v10 = v24;
LABEL_37:
  sub_269A4(*(_DWORD *)(BugCheckParameter2 + 24), (struct _FAST_MUTEX *)(BugCheckParameter2 + 80i64 * v10 + 104), a5);
  *v12 = v14;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    LODWORD(v22) = v14;
    sub_1FF64(*((_QWORD *)off_2E128 + 19), 0xBEu, (__int64)&unk_2B2D0, v9, v22);
  }
  return v9;
}
// 28841: variable 'v22' is possibly undefined
// 2E128: using guessed type void *off_2E128;

//----- (0000000000028A18) ----------------------------------------------------
__int64 __fastcall sub_28A18(__int64 a1, ULONG_PTR *a2, _DWORD *a3)
{
  char *v3; // rsi
  __int64 v6; // rdi
  void **v7; // rcx
  unsigned __int16 v8; // dx
  unsigned int v10; // ebp
  char **v11; // r13
  char *v12; // r11
  ULONG_PTR v13; // rbx
  __int64 v14; // [rsp+50h] [rbp+8h] BYREF

  v14 = a1;
  v3 = (char *)qword_30F88;
  v6 = 0i64;
  v7 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0xBFu, (__int64)&unk_2B2D0);
    v7 = (void **)off_2E128;
  }
  *a3 = 0;
  if ( !v3 )
  {
    if ( v7 == &off_2E128 || *((char *)v7 + 172) >= 0 || *((_BYTE *)v7 + 169) < 2u )
      goto LABEL_11;
    v8 = 192;
LABEL_10:
    sub_11008((__int64)v7[19], v8, (__int64)&unk_2B2D0);
LABEL_11:
    *a3 = 3;
    return 0i64;
  }
  if ( !a2 )
  {
    if ( v7 == &off_2E128 || *((char *)v7 + 172) >= 0 || *((_BYTE *)v7 + 169) < 2u )
      goto LABEL_11;
    v8 = 193;
    goto LABEL_10;
  }
  *a2 = 0i64;
  v10 = 0;
  if ( *((_DWORD *)v3 + 1) )
  {
    v11 = (char **)(v3 + 80);
LABEL_19:
    sub_26894(*((_DWORD *)v3 + 6), (struct _FAST_MUTEX *)&v3[80 * v10 + 104], (KIRQL *)&v14);
    v12 = *v11;
    do
    {
      if ( v12 == &v3[80 * v10 + 80] )
      {
        sub_269A4(*((_DWORD *)v3 + 6), (struct _FAST_MUTEX *)&v3[80 * v10++ + 104], v14);
        v11 += 10;
        if ( v10 >= *((_DWORD *)v3 + 1) )
          goto LABEL_25;
        goto LABEL_19;
      }
      v13 = (ULONG_PTR)v12;
      v12 = *(char **)v12;
    }
    while ( *(_BYTE *)(v13 + 44) );
    *a2 = v13;
    sub_2904C((ULONG_PTR)v3, v13, 1);
    v6 = *(_QWORD *)(v13 + 32);
    sub_269A4(*((_DWORD *)v3 + 6), (struct _FAST_MUTEX *)&v3[80 * v10 + 104], v14);
LABEL_25:
    v7 = (void **)off_2E128;
  }
  if ( v7 != &off_2E128 && *((char *)v7 + 172) < 0 && *((_BYTE *)v7 + 169) >= 5u )
    sub_11008((__int64)v7[19], 0xC2u, (__int64)&unk_2B2D0);
  return v6;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000028BEC) ----------------------------------------------------
__int64 __fastcall sub_28BEC(__int64 a1, ULONG_PTR *a2, __int64 a3, _DWORD *a4)
{
  ULONG_PTR v4; // r14
  _DWORD *v5; // rbx
  __int64 v6; // rdi
  void **v8; // rcx
  unsigned __int16 v9; // dx
  __int64 v11; // r12
  char *v12; // rsi
  struct _FAST_MUTEX *v13; // r15
  char *v14; // r13
  int v15; // eax
  int v16; // eax
  char *v17; // rbp
  ULONG_PTR v18; // r14
  __int64 v19; // [rsp+20h] [rbp-88h] BYREF
  _BYTE v20[72]; // [rsp+28h] [rbp-80h] BYREF
  __int64 v21; // [rsp+B0h] [rbp+8h] BYREF
  ULONG_PTR *v22; // [rsp+B8h] [rbp+10h]

  v22 = a2;
  v21 = a1;
  v4 = *a2;
  v5 = qword_30F88;
  v6 = 0i64;
  v19 = 0i64;
  memset(v20, 0, sizeof(v20));
  v8 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0xC3u, (__int64)&unk_2B2D0);
    v8 = (void **)off_2E128;
  }
  *a4 = 0;
  if ( !v5 )
  {
    if ( v8 == &off_2E128 || *((char *)v8 + 172) >= 0 || *((_BYTE *)v8 + 169) < 2u )
      goto LABEL_11;
    v9 = 196;
LABEL_10:
    sub_11008((__int64)v8[19], v9, (__int64)&unk_2B2D0);
LABEL_11:
    *a4 = 3;
    return 0i64;
  }
  if ( !v4 )
  {
    if ( v8 == &off_2E128 || *((char *)v8 + 172) >= 0 || *((_BYTE *)v8 + 169) < 2u )
      goto LABEL_11;
    v9 = 197;
    goto LABEL_10;
  }
  LODWORD(v11) = sub_273EC((__int64)v5, *(_QWORD *)(v4 + 16), a4);
  v12 = (char *)&v5[20 * (unsigned int)v11 + 20];
  v13 = (struct _FAST_MUTEX *)(v12 + 24);
  sub_26894(v5[6], (struct _FAST_MUTEX *)(v12 + 24), (KIRQL *)&v21);
  v14 = *(char **)v4;
  v15 = sub_29190((ULONG_PTR)v5, v4, 1);
  *a4 = v15;
  if ( !v15 && !*(_DWORD *)(v4 + 40) )
  {
    v16 = sub_27670((__int64)v5, v11, (__int64 *)v4);
    *a4 = v16;
    if ( !v16 )
      sub_2786C((__int64)v5, (__int64)&v19, v4);
  }
  if ( v14 != v12 )
    goto LABEL_24;
  sub_269A4(v5[6], (struct _FAST_MUTEX *)(v12 + 24), v21);
  v11 = (unsigned int)(v11 + 1);
  if ( (unsigned int)v11 < v5[1] )
  {
    v12 = (char *)&v5[20 * v11 + 20];
    v13 = (struct _FAST_MUTEX *)(v12 + 24);
    sub_26894(v5[6], (struct _FAST_MUTEX *)(v12 + 24), (KIRQL *)&v21);
    v14 = *(char **)v12;
LABEL_24:
    v17 = (char *)&v5[20 * (int)v11 + 20];
    do
    {
      while ( v14 == v12 )
      {
        sub_269A4(v5[6], v13, v21);
        LODWORD(v11) = v11 + 1;
        v17 += 80;
        if ( (unsigned int)v11 >= v5[1] )
          goto LABEL_30;
        v13 = (struct _FAST_MUTEX *)(v17 + 24);
        v12 = v17;
        sub_26894(v5[6], (struct _FAST_MUTEX *)(v17 + 24), (KIRQL *)&v21);
        v14 = *(char **)v17;
      }
      v18 = (ULONG_PTR)v14;
      v14 = *(char **)v14;
    }
    while ( *(_BYTE *)(v18 + 44) );
    *v22 = v18;
    sub_2904C((ULONG_PTR)v5, v18, 1);
    v6 = *(_QWORD *)(v18 + 32);
    sub_269A4(v5[6], (struct _FAST_MUTEX *)(v12 + 24), v21);
  }
LABEL_30:
  sub_279EC((__int64)v5, (__int64)&v19);
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2E128 + 19), 0xC6u, (__int64)&unk_2B2D0);
  return v6;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000028EA8) ----------------------------------------------------
__int64 __fastcall sub_28EA8(ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter1)
{
  void **v4; // rcx
  __int64 result; // rax
  unsigned int v6; // ebx
  struct _FAST_MUTEX *v7; // rbp
  unsigned int v8; // ebx
  __int64 v9; // [rsp+20h] [rbp-68h] BYREF
  _BYTE v10[72]; // [rsp+28h] [rbp-60h] BYREF
  KIRQL v11; // [rsp+90h] [rbp+8h] BYREF
  unsigned int v12; // [rsp+98h] [rbp+10h] BYREF

  v12 = 0;
  v9 = 0i64;
  memset(v10, 0, sizeof(v10));
  v4 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0xCFu, (__int64)&unk_2B2D0);
    v4 = (void **)off_2E128;
  }
  if ( BugCheckParameter1 )
  {
    v6 = sub_273EC(BugCheckParameter2, *(_QWORD *)(BugCheckParameter1 + 16), &v12);
    v7 = (struct _FAST_MUTEX *)(BugCheckParameter2 + 80i64 * v6 + 104);
    sub_26894(*(_DWORD *)(BugCheckParameter2 + 24), v7, &v11);
    sub_29190(BugCheckParameter2, BugCheckParameter1, 0);
    if ( *(_DWORD *)(BugCheckParameter1 + 40) )
    {
      v8 = v12;
    }
    else
    {
      v8 = sub_27670(BugCheckParameter2, v6, (__int64 *)BugCheckParameter1);
      if ( !v8 )
        sub_2786C(BugCheckParameter2, (__int64)&v9, BugCheckParameter1);
    }
    sub_269A4(*(_DWORD *)(BugCheckParameter2 + 24), v7, v11);
    sub_279EC(BugCheckParameter2, (__int64)&v9);
    if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_2E128 + 19), 0xD1u, (__int64)&unk_2B2D0);
    result = v8;
  }
  else
  {
    if ( v4 != &off_2E128 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0xD0u, (__int64)&unk_2B2D0);
    result = 3i64;
  }
  return result;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000002904C) ----------------------------------------------------
__int64 __fastcall sub_2904C(ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter1, char a3)
{
  void **v6; // rcx
  unsigned __int16 v7; // dx

  v6 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0xD6u, (__int64)&unk_2B2D0);
    v6 = (void **)off_2E128;
  }
  if ( !BugCheckParameter2 )
  {
    if ( v6 == &off_2E128 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 215;
LABEL_10:
    sub_11008((__int64)v6[19], v7, (__int64)&unk_2B2D0);
    return 3i64;
  }
  if ( !BugCheckParameter1 )
  {
    if ( v6 == &off_2E128 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 216;
    goto LABEL_10;
  }
  if ( !a3 )
  {
    sub_29814(BugCheckParameter2, BugCheckParameter1);
    v6 = (void **)off_2E128;
  }
  if ( !*(_BYTE *)(BugCheckParameter1 + 45) )
  {
    ++*(_DWORD *)(BugCheckParameter1 + 40);
    v6 = (void **)off_2E128;
  }
  if ( v6 != &off_2E128 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_1FE44((__int64)v6[19], 0xD9u, (__int64)&unk_2B2D0, *(_DWORD *)(BugCheckParameter1 + 40));
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000029190) ----------------------------------------------------
__int64 __fastcall sub_29190(ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter1, char a3)
{
  void **v6; // rcx
  unsigned __int16 v7; // dx
  int v9; // eax
  __int64 v10; // rax
  int v11; // [rsp+40h] [rbp+8h] BYREF

  v6 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_12374(*((_QWORD *)off_2E128 + 19), 0xDAu, (__int64)&unk_2B2D0, *(_QWORD *)(BugCheckParameter1 + 16));
    v6 = (void **)off_2E128;
  }
  if ( !BugCheckParameter2 )
  {
    if ( v6 == &off_2E128 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 219;
LABEL_10:
    sub_11008((__int64)v6[19], v7, (__int64)&unk_2B2D0);
    return 3i64;
  }
  if ( !BugCheckParameter1 )
  {
    if ( v6 == &off_2E128 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 220;
    goto LABEL_10;
  }
  if ( !a3 )
    sub_29814(BugCheckParameter2, BugCheckParameter1);
  v9 = *(_DWORD *)(BugCheckParameter1 + 40);
  if ( v9 )
    *(_DWORD *)(BugCheckParameter1 + 40) = v9 - 1;
  v11 = 0;
  if ( sub_295A4((_BYTE *)BugCheckParameter2, &v11)
    && !*(_DWORD *)(BugCheckParameter1 + 40)
    && !*(_BYTE *)(BugCheckParameter1 + 45) )
  {
    v10 = MEMORY[0xFFFFF78000000014];
    *(_BYTE *)(BugCheckParameter1 + 45) = 1;
    *(_QWORD *)(BugCheckParameter1 + 48) = v10;
    ++*(_QWORD *)(BugCheckParameter2 + 32);
  }
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
    sub_1FE44(*((_QWORD *)off_2E128 + 19), 0xDDu, (__int64)&unk_2B2D0, *(_DWORD *)(BugCheckParameter1 + 40));
  return 0i64;
}
// 2E128: using guessed type void *off_2E128;

//----- (000000000002930C) ----------------------------------------------------
char __fastcall sub_2930C(_BYTE *a1, _DWORD *a2)
{
  char v4; // bl
  void **v5; // rcx
  unsigned __int16 v7; // dx

  v4 = 0;
  v5 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0xDEu, (__int64)&unk_2B2D0);
    v5 = (void **)off_2E128;
  }
  *a2 = 0;
  if ( a1 )
  {
    if ( (*a1 & 1) != 0 )
    {
      v4 = 1;
      if ( v5 != &off_2E128 )
      {
        if ( *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 4u )
        {
          v7 = 224;
LABEL_20:
          sub_11008((__int64)v5[19], v7, (__int64)&unk_2B2D0);
          v5 = (void **)off_2E128;
          goto LABEL_21;
        }
        goto LABEL_21;
      }
    }
    else if ( v5 != &off_2E128 )
    {
      if ( *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 4u )
      {
        v7 = 225;
        goto LABEL_20;
      }
LABEL_21:
      if ( v5 != &off_2E128 && *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 5u )
        sub_11008((__int64)v5[19], 0xE2u, (__int64)&unk_2B2D0);
      return v4;
    }
    return v4;
  }
  if ( v5 != &off_2E128 && *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 2u )
    sub_11008((__int64)v5[19], 0xDFu, (__int64)&unk_2B2D0);
  *a2 = 3;
  return 0;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000029458) ----------------------------------------------------
char __fastcall sub_29458(_BYTE *a1, _DWORD *a2)
{
  char v4; // bl
  void **v5; // rcx
  unsigned __int16 v7; // dx

  v4 = 0;
  v5 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0xE3u, (__int64)&unk_2B2D0);
    v5 = (void **)off_2E128;
  }
  *a2 = 0;
  if ( a1 )
  {
    if ( (*a1 & 2) != 0 )
    {
      v4 = 1;
      if ( v5 != &off_2E128 )
      {
        if ( *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 4u )
        {
          v7 = 229;
LABEL_20:
          sub_11008((__int64)v5[19], v7, (__int64)&unk_2B2D0);
          v5 = (void **)off_2E128;
          goto LABEL_21;
        }
        goto LABEL_21;
      }
    }
    else if ( v5 != &off_2E128 )
    {
      if ( *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 4u )
      {
        v7 = 230;
        goto LABEL_20;
      }
LABEL_21:
      if ( v5 != &off_2E128 && *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 5u )
        sub_11008((__int64)v5[19], 0xE7u, (__int64)&unk_2B2D0);
      return v4;
    }
    return v4;
  }
  if ( v5 != &off_2E128 && *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 2u )
    sub_11008((__int64)v5[19], 0xE4u, (__int64)&unk_2B2D0);
  *a2 = 3;
  return 0;
}
// 2E128: using guessed type void *off_2E128;

//----- (00000000000295A4) ----------------------------------------------------
char __fastcall sub_295A4(_BYTE *a1, _DWORD *a2)
{
  char v4; // bl
  void **v5; // rcx
  unsigned __int16 v7; // dx

  v4 = 0;
  v5 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0xE8u, (__int64)&unk_2B2D0);
    v5 = (void **)off_2E128;
  }
  *a2 = 0;
  if ( a1 )
  {
    if ( (*a1 & 4) != 0 )
    {
      v4 = 1;
      if ( v5 != &off_2E128 )
      {
        if ( *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 4u )
        {
          v7 = 234;
LABEL_20:
          sub_11008((__int64)v5[19], v7, (__int64)&unk_2B2D0);
          v5 = (void **)off_2E128;
          goto LABEL_21;
        }
        goto LABEL_21;
      }
    }
    else if ( v5 != &off_2E128 )
    {
      if ( *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 4u )
      {
        v7 = 235;
        goto LABEL_20;
      }
LABEL_21:
      if ( v5 != &off_2E128 && *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 5u )
        sub_11008((__int64)v5[19], 0xECu, (__int64)&unk_2B2D0);
      return v4;
    }
    return v4;
  }
  if ( v5 != &off_2E128 && *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 2u )
    sub_11008((__int64)v5[19], 0xE9u, (__int64)&unk_2B2D0);
  *a2 = 3;
  return 0;
}
// 2E128: using guessed type void *off_2E128;

//----- (00000000000296F0) ----------------------------------------------------
__int64 sub_296F0()
{
  void **v0; // rcx
  unsigned int v1; // ebx
  _DWORD *v2; // rax
  unsigned int v3; // edx

  v0 = (void **)off_2E128;
  if ( off_2E128 != &off_2E128 && *((char *)off_2E128 + 172) < 0 && *((_BYTE *)off_2E128 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2E128 + 19), 0x10Au, (__int64)&unk_2B2D0);
    v0 = (void **)off_2E128;
  }
  v1 = 0;
  v2 = dword_2B2E0;
  v3 = 0;
  while ( *v2 < 2u )
  {
    ++v3;
    ++v2;
    if ( v3 >= 0x1D )
    {
      if ( v0 == &off_2E128 )
        return v1;
      if ( *((char *)v0 + 172) < 0 && *((_BYTE *)v0 + 169) >= 2u )
      {
        sub_11008((__int64)v0[19], 0x10Bu, (__int64)&unk_2B2D0);
LABEL_16:
        v0 = (void **)off_2E128;
        goto LABEL_17;
      }
      goto LABEL_17;
    }
  }
  v1 = dword_2B2E0[v3];
  if ( v0 == &off_2E128 )
    return v1;
  if ( *((char *)v0 + 172) < 0 && *((_BYTE *)v0 + 169) >= 4u )
  {
    sub_14544((__int64)v0[19], 0x10Cu, (__int64)&unk_2B2D0, v1);
    goto LABEL_16;
  }
LABEL_17:
  if ( v0 != &off_2E128 && *((char *)v0 + 172) < 0 && *((_BYTE *)v0 + 169) >= 5u )
    sub_11008((__int64)v0[19], 0x10Du, (__int64)&unk_2B2D0);
  return v1;
}
// 2E128: using guessed type void *off_2E128;

//----- (0000000000029814) ----------------------------------------------------
char __fastcall sub_29814(ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter1)
{
  char result; // al
  int v5; // [rsp+50h] [rbp+18h] BYREF

  v5 = 0;
  result = sub_295A4((_BYTE *)BugCheckParameter2, &v5);
  if ( result )
  {
    if ( *(_BYTE *)(BugCheckParameter1 + 45) )
      KeBugCheckEx(0xDEFECAu, BugCheckParameter1, BugCheckParameter2, 0i64, 0i64);
  }
  return result;
}

//----- (000000000002986C) ----------------------------------------------------
void __fastcall DeferredRoutine(_KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
  if ( DeferredContext )
    ((void (__fastcall *)(_KDPC *, PVOID, PVOID, PVOID))DeferredContext)(
      Dpc,
      DeferredContext,
      SystemArgument1,
      SystemArgument2);
  KeSetTimer(&Timer, (LARGE_INTEGER)qword_30DF0, &::Dpc);
}
// 30DF0: using guessed type __int64 qword_30DF0;

//----- (00000000000298A0) ----------------------------------------------------
__int64 __fastcall sub_298A0(_QWORD *a1, _QWORD *a2)
{
  char *v4; // rbx
  NTSTATUS v6; // edi
  IRP *v7; // rax
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+50h] [rbp-58h] BYREF
  _UNICODE_STRING DestinationString; // [rsp+60h] [rbp-48h] BYREF
  struct _KEVENT Event; // [rsp+70h] [rbp-38h] BYREF

  IoStatusBlock.Pointer = 0i64;
  Event.Header.Type = 0;
  IoStatusBlock.Information = 0i64;
  *(_OWORD *)((char *)&Event.Header.Lock + 1) = 0ui64;
  *(_DWORD *)((char *)&Event.Header.WaitListHead.Blink + 1) = 0;
  *(_WORD *)((char *)&Event.Header.WaitListHead.Blink + 5) = 0;
  HIBYTE(Event.Header.WaitListHead.Blink) = 0;
  v4 = (char *)sub_1D254(2, 0x18u, 0x41434E50u);
  if ( !v4 )
    return 1793i64;
  *(_QWORD *)v4 = 0i64;
  *((_QWORD *)v4 + 1) = 0i64;
  *((_QWORD *)v4 + 2) = 0i64;
  KeInitializeEvent(&Event, SynchronizationEvent, 0);
  RtlInitUnicodeString(&DestinationString, L"\\Device\\NANO\\KNC");
  v6 = IoGetDeviceObjectPointer(&DestinationString, 0x10000000u, (PFILE_OBJECT *)v4, (PDEVICE_OBJECT *)v4 + 1);
  if ( v6
    || (v7 = IoBuildDeviceIoControlRequest(
               0x8BC82004,
               *((PDEVICE_OBJECT *)v4 + 1),
               0i64,
               0,
               v4 + 16,
               8u,
               0,
               &Event,
               &IoStatusBlock),
        (v6 = IofCallDriver(*((PDEVICE_OBJECT *)v4 + 1), v7)) != 0) )
  {
    if ( *(_QWORD *)v4 )
      ObfDereferenceObject(*(PVOID *)v4);
    sub_1D2D8(v4, 0x41434E50u);
    v4 = 0i64;
  }
  else
  {
    *a2 = *((_QWORD *)v4 + 2);
  }
  KeClearEvent(&Event);
  *a1 = v4;
  return v6 != 0 ? 0xE8700002 : 0;
}

//----- (0000000000029A24) ----------------------------------------------------
void __fastcall sub_29A24(PVOID P)
{
  PVOID *v1; // rdi

  if ( P )
  {
    v1 = (PVOID *)*((_QWORD *)P + 6);
    *(_BYTE *)P = 0;
    if ( v1 )
    {
      if ( *v1 )
        ObfDereferenceObject(*v1);
      sub_1D2D8(v1, 0x41434E50u);
    }
    sub_1D2D8(P, 0x41434E50u);
  }
}

//----- (0000000000029A94) ----------------------------------------------------
__int64 __fastcall sub_29A94(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, void *Src)
{
  size_t v5; // rbx
  unsigned int v6; // er12
  PVOID v10; // rax
  void *v11; // r13
  unsigned int v12; // ebx

  v5 = a4;
  v6 = a3;
  if ( !a1 )
    return 1799i64;
  if ( !a2 )
    return 1796i64;
  if ( !a4 || !Src )
    return (unsigned int)(*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD, _QWORD))(*(_QWORD *)(a1 + 24)
                                                                                             + 24i64))(
                           **(_QWORD **)(a1 + 24),
                           a2,
                           a3,
                           0i64,
                           0i64);
  v10 = sub_1D254(2, a4, 0x41434E50u);
  v11 = v10;
  if ( !v10 )
    return 1793;
  memmove(v10, Src, v5);
  v12 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD, void *, _DWORD))(*(_QWORD *)(a1 + 24) + 24i64))(
          **(_QWORD **)(a1 + 24),
          a2,
          v6,
          (unsigned int)v5,
          v11,
          0);
  sub_1D2D8(v11, 0x41434E50u);
  return v12;
}

//----- (0000000000029BF8) ----------------------------------------------------
__int64 __fastcall sub_29BF8(_WORD *a1, __int64 a2, __int16 *a3, __int64 a4)
{
  __int16 *v4; // r11
  unsigned int v6; // ebx
  _WORD *v7; // r10
  __int64 v8; // r8
  __int16 v9; // ax
  __int16 v10; // ax

  v4 = a3;
  if ( a4 )
  {
    if ( !a1 )
    {
LABEL_25:
      nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
      return 22i64;
    }
  }
  else if ( !a1 )
  {
    if ( !a2 )
      return 0i64;
    goto LABEL_25;
  }
  if ( !a2 )
    goto LABEL_25;
  if ( !a4 )
  {
    *a1 = 0;
    return 0i64;
  }
  if ( a3 )
  {
    v7 = a1;
    v8 = a2;
    if ( a4 == -1 )
    {
      do
      {
        v9 = *v4++;
        *v7++ = v9;
        if ( !v9 )
          break;
        --v8;
      }
      while ( v8 );
    }
    else
    {
      do
      {
        v10 = *v4++;
        *v7++ = v10;
        if ( !v10 )
          break;
        if ( !--v8 )
          break;
        --a4;
      }
      while ( a4 );
      if ( !a4 )
        *v7 = 0;
    }
    if ( v8 )
      return 0i64;
    if ( a4 == -1 )
    {
      a1[a2 - 1] = 0;
      return 80i64;
    }
    v6 = 34;
  }
  else
  {
    v6 = 22;
  }
  *a1 = 0;
  nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
  return v6;
}
// 29F10: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000029D00) ----------------------------------------------------
__int64 __fastcall sub_29D00(_BYTE *a1, __int64 a2, char *a3)
{
  _BYTE *v3; // r9
  unsigned int v4; // ebx
  char v5; // al
  __int64 result; // rax

  v3 = a1;
  if ( a1 && a2 )
  {
    if ( !a3 )
    {
      v4 = 22;
LABEL_9:
      *v3 = 0;
      nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
      return v4;
    }
    do
    {
      v5 = *a3++;
      *a1++ = v5;
      if ( !v5 )
        break;
      --a2;
    }
    while ( a2 );
    if ( !a2 )
    {
      v4 = 34;
      goto LABEL_9;
    }
    result = 0i64;
  }
  else
  {
    nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
    result = 22i64;
  }
  return result;
}
// 29F10: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000029D88) ----------------------------------------------------
__int64 __fastcall sub_29D88(void *a1, size_t a2, const void *a3, size_t a4)
{
  unsigned int v8; // ebx

  if ( !a4 )
    return 0i64;
  if ( !a1 )
  {
    nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
    return 22i64;
  }
  if ( a3 && a2 >= a4 )
  {
    memmove(a1, a3, a4);
    return 0i64;
  }
  memset(a1, 0, a2);
  if ( a3 )
  {
    if ( a2 >= a4 )
      return 22i64;
    v8 = 34;
  }
  else
  {
    v8 = 22;
  }
  nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
  return v8;
}
// 29F10: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002A40C) ----------------------------------------------------
__int64 __fastcall sub_2A40C(_WORD *a1, __int64 a2, __int16 *a3)
{
  _WORD *v3; // r9
  unsigned int v4; // ebx
  __int16 v5; // ax
  __int64 result; // rax

  v3 = a1;
  if ( a1 && a2 )
  {
    if ( !a3 )
    {
      v4 = 22;
LABEL_9:
      *v3 = 0;
      nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
      return v4;
    }
    do
    {
      v5 = *a3++;
      *a1++ = v5;
      if ( !v5 )
        break;
      --a2;
    }
    while ( a2 );
    if ( !a2 )
    {
      v4 = 34;
      goto LABEL_9;
    }
    result = 0i64;
  }
  else
  {
    nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
    result = 22i64;
  }
  return result;
}
// 29F10: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000032008) ----------------------------------------------------
__int64 __fastcall sub_32008(unsigned __int8 a1, __int64 a2, unsigned int a3, unsigned int *a4, __int64 a5, unsigned int *a6)
{
  unsigned int *v6; // r13
  unsigned int v7; // er10
  __int64 v10; // rbp
  unsigned int v11; // ebx
  __int64 v12; // rax
  unsigned int v13; // ecx
  unsigned int v14; // eax
  const void **v15; // r14
  unsigned int v16; // er12
  unsigned int v17; // esi
  _WORD *v18; // rcx
  __m128i *v19; // rdi
  __int64 v20; // rcx
  __m128i v21; // xmm0
  __int64 v22; // rbx
  bool v23; // zf
  __int64 v25; // [rsp+30h] [rbp-38h]
  char v26; // [rsp+70h] [rbp+8h] BYREF

  v6 = a6;
  v7 = 0;
  *a6 = 0;
  if ( a1 <= 3u )
    return (unsigned int)-1073741808;
  if ( a1 <= 5u )
  {
    v22 = a5;
    if ( a5 )
    {
      if ( a3 < 0x30 )
        return (unsigned int)-1073741811;
      do
      {
        if ( RtlCompareMemory(*(const void **)(v22 + 8), a4 + 6, 0x10ui64) == 16 )
          break;
        v22 = *(_QWORD *)(v22 + 16);
      }
      while ( v22 );
      if ( v22 )
      {
        v7 = 0;
        if ( a1 == 5 )
        {
          *(_DWORD *)(v22 + 44) = 0;
          *(_QWORD *)(v22 + 24) = 0i64;
          *(_BYTE *)(v22 + 41) = 0;
        }
        else
        {
          v23 = dword_2E1B8 == 2;
          v25 = *((_QWORD *)a4 + 1);
          *(_QWORD *)(v22 + 24) = v25;
          if ( v23 )
          {
            if ( !(unsigned int)qword_2E190(3i64, &v26, 4i64, &a6, a4) )
              *(_BYTE *)(v22 + 41) = v26;
            v7 = qword_2E190(2i64, v22 + 44, 4i64, &a6, a4);
          }
          else
          {
            *(_DWORD *)(v22 + 44) = HIDWORD(v25);
            *(_BYTE *)(v22 + 41) = BYTE2(v25);
          }
        }
        return v7;
      }
    }
    return (unsigned int)-1073741163;
  }
  if ( a1 <= 7u )
    return v7;
  if ( a1 != 8 )
    return (unsigned int)-1073741808;
  v10 = a5;
  v11 = 0;
  v12 = a5;
  if ( dword_2E1B8 == 1 )
  {
    v13 = a4[4];
    if ( v13 > 1 )
    {
      v14 = 32 * v13 + 24;
      if ( v14 <= a3 )
      {
        *(__m128i *)&a4[8 * v13 - 2] = _mm_loadu_si128((const __m128i *)*(_QWORD *)(a5 + 8));
        a4[8 * a4[4] + 2] = 528384;
        *(_DWORD *)(v10 + 44) = 0;
        *(_BYTE *)(v10 + 41) = 0;
        return v7;
      }
      v7 = -1073741789;
      if ( a3 >= 4 )
      {
        *a4 = v14;
LABEL_10:
        *v6 = 4;
        return v7;
      }
      return v7;
    }
  }
  v15 = *(const void ***)(a5 + 32);
  do
  {
    v12 = *(_QWORD *)(v12 + 16);
    ++v11;
  }
  while ( v12 );
  if ( v11 > 0x3F )
    return (unsigned int)-1073741811;
  if ( v15 )
  {
    v16 = 32 * v11 + 24;
    v17 = *(unsigned __int16 *)v15 + v16 + 2;
  }
  else
  {
    v16 = 0;
    v17 = 32 * v11 + 24;
  }
  if ( v17 > a3 )
  {
    v7 = -1073741789;
    if ( a3 < 4 )
      return v7;
    *a4 = v17;
    goto LABEL_10;
  }
  memset(a4, 0, a3);
  *a4 = v17;
  a4[2] = v16;
  a4[4] = v11;
  if ( v15 )
  {
    v18 = (_WORD *)((char *)a4 + v16);
    *v18 = *(_WORD *)v15;
    memmove(v18 + 1, v15[1], *(unsigned __int16 *)v15);
  }
  if ( v11 )
  {
    v19 = (__m128i *)(a4 + 10);
    v20 = v11;
    do
    {
      v21 = _mm_loadu_si128((const __m128i *)*(_QWORD *)(v10 + 8));
      v19->m128i_i32[0] = 528384;
      v19 += 2;
      v19[-3] = v21;
      *(_DWORD *)(v10 + 44) = 0;
      --v20;
      *(_BYTE *)(v10 + 41) = 0;
      v10 = *(_QWORD *)(v10 + 16);
    }
    while ( v20 );
  }
  v7 = 0;
  *v6 = v17;
  return v7;
}
// 2E190: using guessed type __int64 (__fastcall *qword_2E190)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 2E1B8: using guessed type int dword_2E1B8;

// nfuncs=275 queued=260 decompiled=260 lumina nreq=0 worse=0 better=0
// ALL OK, 260 function(s) have been successfully decompiled
