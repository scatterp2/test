/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall sub_11008(__int64 a1, unsigned __int16 a2, __int64 a3);
__int64 __fastcall sub_1102C(__int64 a1, __int64 a2, __int64 a3, __int16 a4, __int64 a5);
__int64 __fastcall sub_11180(__int64 a1, char a2, __int64 *a3, __int64 a4);
NTSTATUS __stdcall DriverEntry(_DRIVER_OBJECT *DriverObject, PUNICODE_STRING RegistryPath);
void __fastcall sub_11578(PDEVICE_OBJECT DeviceObject);
__int64 __fastcall sub_116D8(_DWORD *a1);
char __fastcall sub_117F4(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
__int64 sub_11AE8();
__int64 __fastcall sub_11B10(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall sub_11B4C(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_11C28(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall sub_11CA8(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_11D0C(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall sub_11D54(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_11DF8(__int64 a1, unsigned __int16 a2, __int64 a3, const char *a4);
__int64 sub_11E60();
__int64 sub_12334();
__int64 __fastcall sub_1297C(int a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5);
__int64 __fastcall sub_12BB8(int a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5);
__int64 __fastcall sub_12D44(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_132E8(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_136F4(__int64 a1, int a2);
void sub_137B8();
void sub_13858();
__int64 __fastcall sub_13E6C(int a1);
__int64 __fastcall sub_14070(__int64 a1, int a2);
__int64 __fastcall sub_142A8(__int64 a1);
__int64 __fastcall sub_144E8(__int64 a1, __int64 a2);
__int64 __fastcall sub_14BC8(__int64 a1, __int64 a2);
char __fastcall sub_14CBC(int a1, _DWORD *a2);
__int64 __fastcall sub_14E9C(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 sub_14EFC();
__int64 __fastcall sub_14FF0(__int64 a1);
void sub_150E0();
__int64 __fastcall sub_152F8(__int64 a1);
__int64 __fastcall sub_15364(__int64 a1);
__int64 __fastcall sub_1540C(__int64 a1, __int64 a2);
void sub_15530();
void __fastcall sub_155F4(__int64 *a1);
__int64 __fastcall sub_15630(__int64 a1, __int64 a2);
__int64 sub_156E8();
void __fastcall sub_157AC(__int64 *a1);
void __fastcall sub_157E8(__int64 a1);
__int64 __fastcall sub_158C0(__int64 a1);
void **sub_159A8();
__int64 __fastcall sub_15A68(int a1, __int16 a2);
void __fastcall sub_15B20(int a1, __int16 a2);
__int64 sub_15CB8();
__int64 __fastcall sub_15DA0(__int64 a1, __int64 a2);
__int64 __fastcall sub_15EE4(__int64 a1, __int64 a2);
void sub_16004();
__int64 __fastcall sub_161B4(int a1, int a2, __int16 a3, _DWORD *a4);
__int64 __fastcall sub_16354(__int64 a1, __int64 a2);
__int64 sub_164F0();
__int64 __fastcall sub_165C8(__int64 a1, __int64 a2);
__int64 __fastcall sub_1684C(__int64 a1);
void __fastcall sub_16954(__int64 *a1);
__int64 sub_16990();
__int64 __fastcall sub_16A58(__int64 a1, __int64 a2);
void __fastcall sub_16CB8(__int64 *a1);
void __fastcall sub_16CF4(__int64 a1);
__int64 __fastcall sub_16DD0(__int64 a1);
__int64 sub_16F00();
__int64 __fastcall sub_16FC8(__int64 a1, __int64 a2);
void __fastcall sub_17154(int a1, __int16 a2);
__int64 __fastcall sub_17200(int a1, __int16 a2);
void __fastcall sub_1737C(__int64 *a1);
__int64 __fastcall sub_173B8(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_17418(__int64 a1, _DWORD *a2);
__int64 sub_1782C();
__int64 __fastcall sub_17948(__int16 a1, int a2);
void __fastcall sub_17A14(_QWORD *a1);
__int64 __fastcall sub_17A88(__int64 a1);
__int64 __fastcall sub_17BA8(__int64 a1, unsigned __int16 a2);
PVOID __fastcall sub_17C28(int a1, unsigned int a2, ULONG a3);
void __fastcall sub_17CAC(PVOID P, ULONG Tag);
PVOID __fastcall sub_17D20(__int64 a1, void *a2, unsigned int a3, unsigned int a4);
char *__fastcall sub_17E94(int a1, unsigned int a2, ULONG a3);
void __fastcall sub_17F18(PVOID P);
_DWORD *__fastcall sub_18038(__int64 a1);
void __fastcall sub_180A0(__int64 a1, __int64 a2);
__int64 __fastcall sub_181CC(PERESOURCE Resource); // idb
__int64 __fastcall sub_182A0(PERESOURCE Resource); // idb
BOOLEAN __fastcall sub_18374(PERESOURCE Resource);
BOOLEAN __fastcall sub_1844C(PERESOURCE Resource);
void __fastcall sub_18524(PERESOURCE Resource);
void __fastcall sub_185F0(PKSPIN_LOCK SpinLock, KIRQL *a2);
void __fastcall sub_18668(PKSPIN_LOCK SpinLock, KIRQL a2);
int __fastcall sub_186DC(PRKEVENT Event);
int __fastcall sub_18744(PRKEVENT Event);
void __fastcall sub_18810(__int64 a1);
void __fastcall sub_188F0(PFAST_MUTEX FastMutex);
void __fastcall sub_189BC(PFAST_MUTEX FastMutex);
_QWORD *sub_18A88();
void __fastcall sub_18BF4(__int64 a1);
__int64 __fastcall sub_18C60(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_18CF0(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_18D8C(__int64 a1, __int64 a2, __int64 a3, int a4);
PVOID __fastcall sub_18E1C(int a1, unsigned int a2, ULONG a3);
void __fastcall sub_18F38(PVOID P, ULONG Tag);
char *__fastcall sub_19030(int a1, unsigned int a2, ULONG a3);
_DWORD *__fastcall sub_191E4(__int64 a1);
__int64 __fastcall sub_192E8(_QWORD *a1);
void __fastcall sub_1936C(PKSPIN_LOCK SpinLock, KIRQL *a2);
void __fastcall sub_19424(PKSPIN_LOCK SpinLock, KIRQL a2);
bool __fastcall sub_194C8(struct _KEVENT **a1, char a2);
void __fastcall sub_195B0(PVOID P);
int __fastcall sub_19648(PRKEVENT Event);
void __fastcall HandleInformation(PVOID StartContext);
unsigned __int8 __fastcall sub_19774(PVOID *Object, __int64 a2, __int64 (__fastcall *a3)(void ***a1));
__int64 __fastcall sub_198DC(PVOID Object); // idb
__int64 __fastcall sub_19970(void ***a1);
__int64 sub_19C7C();
__int64 __fastcall sub_19EA0(PVOID P); // idb
void __fastcall sub_1A1FC(__int64 a1, char a2);
void __fastcall sub_1A2C0(__int64 a1);
__int64 __fastcall sub_1A3A4(PVOID Object); // idb
__int64 __fastcall sub_1A44C(ULONG Count, PVOID Object[]); // idb
__int64 __fastcall sub_1A558(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 sub_1A5A4();
__int64 __fastcall sub_1A6D8(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall sub_1A72C(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, __int64 a6, int a7);
__int64 sub_1A79C(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 __fastcall sub_1A7E0(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 sub_1A850(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_1A88C(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 __fastcall sub_1A8D8(__int64 a1, __int64 a2, _QWORD *a3);
__int64 sub_1AE50();
__int64 sub_1B1F0();
__int64 __fastcall sub_1B338(__int64 a1);
__int64 sub_1B8F0();
__int64 __fastcall sub_1BFBC(unsigned int a1, int a2, unsigned int a3, _DWORD *a4);
__int64 __fastcall sub_1C5B4(__int64 a1, unsigned int a2, __int64 a3);
__int64 __fastcall sub_1C978(int a1);
__int64 __fastcall sub_1CAD4(int a1);
__int64 __fastcall sub_1CBFC(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_1CD40(__int64 a1, __int64 a2, __int64 a3, int a4, const char *a5, const char *a6);
__int64 __fastcall sub_1CE08(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_1CE60(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, const char *a5);
__int64 sub_1CEE8(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_1CF30(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_1CF90(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
_BYTE *__fastcall sub_1CFE4(_BYTE *a1, int a2);
__int64 __fastcall sub_1D5A4(__int64 a1, __int64 a2);
__int64 __fastcall sub_1D65C(__int64 a1, __int64 a2);
__int64 __fastcall sub_1D710(__int64 a1, _WORD *a2);
__int64 __fastcall sub_1D7D4(_BYTE *a1, _BYTE *a2);
__int64 __fastcall sub_1D884(_BYTE *a1, _BYTE *a2);
__int64 __fastcall sub_1D934(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_1D9E4(__int64 a1, _WORD *a2);
__int64 __fastcall sub_1DAB0(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_1DB60(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_1DC10(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_1DCC0(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_1DD84(__int64 a1, unsigned __int8 *a2, _QWORD *a3);
char __fastcall sub_1E048(__int64 a1);
__int64 __fastcall sub_1E21C(__int64 a1, unsigned __int16 *a2);
__int64 __fastcall sub_1E2E4(__int64 a1, unsigned __int8 *a2);
__int64 __fastcall sub_1E398(__int64 a1, __m128i *a2);
__int64 __fastcall sub_1E44C(__int64 a1, __m128i *a2);
__int64 __fastcall sub_1E5A8(_BYTE *a1, __m128i *a2);
__int64 __fastcall sub_1EA14(_WORD *a1, _WORD *a2);
__int64 __fastcall sub_1EAD8(__int64 a1, _WORD *a2);
__int64 __fastcall sub_1EB9C(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_1EC4C(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_1ECFC(_WORD *a1, _WORD *a2);
__int64 __fastcall sub_1EDC0(__int64 a1, _WORD *a2);
__int64 __fastcall sub_1EE84(_BYTE *a1, _BYTE *a2);
__int64 __fastcall sub_1EF30(__int64 a1, _BYTE *a2);
__int64 __fastcall sub_1EFE0(__int64 a1, _WORD *a2);
__int64 __fastcall sub_1F0A4(__int64 a1, _WORD *a2);
__int64 __fastcall sub_1F168(__int64 a1, __int64 a2);
__int64 __fastcall sub_1F23C(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_1F308(__int64 a1, __int64 a2);
__int64 __fastcall sub_1F3DC(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_1F4A8(__int16 *a1);
char __fastcall sub_1F638(__int64 a1);
__int64 __fastcall sub_1F6F8(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_1F88C(__int64 a1, unsigned int a2, unsigned __int16 *a3);
__int64 __fastcall sub_1FAA4(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_1FD14(__int64 a1, unsigned __int8 a2, unsigned __int64 *a3);
__int64 __fastcall sub_20074(__int64 a1);
const char *__fastcall sub_20274(unsigned __int8 a1);
__int64 sub_20364(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 __fastcall sub_203B8(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4);
__int64 sub_20468(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 sub_204E0(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 __fastcall sub_2054C(__int16 *a1, int a2, unsigned int *a3);
__int64 __fastcall sub_20720(char a1);
__int64 __fastcall sub_207BC(int a1);
__int64 __fastcall sub_20994(int a1, __int64 a2);
__int64 sub_20B88();
__int64 __fastcall sub_20D48(unsigned int a1, __int64 a2);
__int64 sub_20E98();
__int64 sub_21108();
__int64 __fastcall sub_21390(int a1);
__int64 sub_21754();
__int64 sub_21EB8();
__int64 __fastcall sub_22218(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_22470(unsigned int *a1);
__int64 __fastcall sub_225CC(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_226B8(__int64 a1, int a2, unsigned int a3, void *a4);
__int64 __fastcall sub_228B4(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_22B28(__int64 a1, __int64 a2, __int64 a3);
__int64 sub_22E40();
__int64 __fastcall sub_22F30(__int64 a1, __int64 a2, __int64 a3);
__int64 sub_23110();
__int64 __fastcall sub_23200(__int64 a1, const void *a2);
__int64 __fastcall sub_234E8(__int64 a1, __int64 a2, __int64 a3);
__int64 sub_2368C();
void __fastcall DeferredRoutine(_KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2);
__int64 __fastcall sub_237B8(__int64 a1, const void *a2, size_t a3);
__int64 sub_23918(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 sub_23968(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 __fastcall sub_239CC(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall sub_23A28(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_23A98(int a1, _QWORD *a2);
__int64 __fastcall sub_23C7C(int a1, __int64 a2);
__int64 __fastcall sub_23DDC(int a1, struct _FAST_MUTEX *a2, KIRQL *a3);
__int64 __fastcall sub_23EA0(int a1, struct _FAST_MUTEX *a2, KIRQL a3);
__int64 __fastcall sub_23F34(__int64 a1, __int64 a2, char a3);
__int64 __fastcall sub_24060(__int64 a1, __int64 a2, char a3);
_DWORD *__fastcall sub_24184(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6, int a7, int a8, int a9, int a10, _DWORD *a11);
__int64 __fastcall sub_24410(__int64 a1);
unsigned __int64 __fastcall sub_248A4(__int64 a1, unsigned __int64 a2, _DWORD *a3);
_DWORD *__fastcall sub_249A0(__int64 a1, __int64 a2, _DWORD *a3);
__int64 __fastcall sub_24B28(__int64 a1, unsigned int a2, __int64 *a3);
__int64 __fastcall sub_24D24(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_24EA4(__int64 a1, __int64 a2, char a3);
__int64 __fastcall sub_250F0(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_251E8(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, _DWORD *a4);
__int64 __fastcall sub_25424(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_25648(__int64 a1, unsigned __int64 a2, __int64 a3, _DWORD *a4);
_QWORD *__fastcall sub_258D4(__int64 a1, unsigned int a2, __int64 a3, _DWORD *a4);
ULONG_PTR __fastcall sub_25A94(ULONG_PTR BugCheckParameter2, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_25EF4(__int64 a1, __int64 a2);
__int64 __fastcall sub_26010(ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter1, char a3);
char __fastcall sub_2618C(_BYTE *a1, _DWORD *a2);
char __fastcall sub_262D8(_BYTE *a1, _DWORD *a2);
char __fastcall sub_26424(_BYTE *a1, _DWORD *a2);
__int64 __fastcall sub_26570(__int64 a1);
__int64 sub_26964();
char __fastcall sub_26A8C(ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter1);
void __fastcall sub_26AE4(__int64 a1);
char __fastcall sub_26B5C(PFAST_MUTEX FastMutex);
char __fastcall sub_26C04(PFAST_MUTEX FastMutex);
char __fastcall sub_26C6C(PFAST_MUTEX FastMutex);
__int64 __fastcall sub_26CD0(_QWORD *a1, _QWORD *a2);
void __fastcall sub_26E54(PVOID P);
__int64 __fastcall sub_26EC4(__int64 a1, __int64 a2);
__int64 __fastcall sub_26F08(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, void *Src);
__int64 __fastcall sub_27004(__int64 a1, __int64 a2, __int64 *a3);
__int64 __fastcall sub_270A8(char *a1, unsigned __int64 a2, CHAR *a3, __int64 a4);
__int64 sub_270F8(char *a1, unsigned __int64 a2, CHAR *a3, ...);
// __int64 __fastcall write_char(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall write_multi_char(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_271C4(_BYTE *a1, int a2, __int64 a3, _DWORD *a4);
__int64 __fastcall sub_27234(__int64 a1, CHAR *a2, __int64 a3);
__int64 __fastcall sub_27B04(char *a1, unsigned __int64 a2, CHAR *a3, __int64 a4);
// int __cdecl flsbuf(int Ch, FILE *File);
__int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
// void *__cdecl memset(void *Dst, int Val, size_t Size);
// NTSTATUS __stdcall RtlUnicodeToMultiByteN(PCHAR MultiByteString, ULONG MaxBytesInMultiByteString, PULONG BytesInMultiByteString, PCWCH UnicodeString, ULONG BytesInUnicodeString);
__int64 __fastcall sub_27D8C(void *a1, size_t a2, const void *a3, size_t a4);
__int64 __fastcall sub_27E30(_WORD *a1, __int64 a2, __int16 *a3);
// void *__cdecl memmove(void *Dst, const void *Src, size_t MaxCount);
// void __stdcall KeStallExecutionProcessor(ULONG MicroSeconds);
// LARGE_INTEGER __stdcall KeQueryPerformanceCounter(PLARGE_INTEGER PerformanceFrequency);
// NTSTATUS __stdcall IoWMIWriteEvent(PVOID WnodeEventItem);
// void __stdcall KeInitializeMutex(PRKMUTEX Mutex, ULONG Level);
// void __stdcall RtlInitUnicodeString(PUNICODE_STRING DestinationString, PCWSTR SourceString);
// PVOID __stdcall MmGetSystemRoutineAddress(PUNICODE_STRING SystemRoutineName);
// SIZE_T __stdcall RtlCompareMemory(const void *Source1, const void *Source2, SIZE_T Length);
// NTSTATUS __stdcall IofCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp);
// void __stdcall __noreturn KeBugCheckEx(ULONG BugCheckCode, ULONG_PTR BugCheckParameter1, ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter3, ULONG_PTR BugCheckParameter4);
// BOOLEAN __stdcall ExAcquireResourceExclusiveLite(PERESOURCE Resource, BOOLEAN Wait);
// void __stdcall KeClearEvent(PRKEVENT Event);
// LONG __stdcall KeResetEvent(PRKEVENT Event);
// void __stdcall ExReleaseFastMutex(PFAST_MUTEX FastMutex);
// void KeLeaveCriticalRegion(void);
// void __stdcall ExInitializeNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside, PALLOCATE_FUNCTION Allocate, PFREE_FUNCTION Free, ULONG Flags, SIZE_T Size, ULONG Tag, USHORT Depth);
// void __stdcall ExAcquireFastMutex(PFAST_MUTEX FastMutex);
// LONG __stdcall KeSetEvent(PRKEVENT Event, KPRIORITY Increment, BOOLEAN Wait);
// PSLIST_ENTRY __stdcall ExpInterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry);
// void __stdcall KeInitializeEvent(PRKEVENT Event, EVENT_TYPE Type, BOOLEAN State);
// void __stdcall KeReleaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL NewIrql);
// PSLIST_ENTRY __stdcall ExpInterlockedPopEntrySList(PSLIST_HEADER ListHead);
// void __stdcall KeReleaseSpinLockFromDpcLevel(PKSPIN_LOCK SpinLock);
// void KeEnterCriticalRegion(void);
// void __stdcall ExFreePoolWithTag(PVOID P, ULONG Tag);
// void __stdcall ExDeletePagedLookasideList(PPAGED_LOOKASIDE_LIST Lookaside);
// NTSTATUS __stdcall PsCreateSystemThread(PHANDLE ThreadHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PKSTART_ROUTINE StartRoutine, PVOID StartContext);
// NTSTATUS __stdcall PsTerminateSystemThread(NTSTATUS ExitStatus);
// BOOLEAN __stdcall ExAcquireResourceSharedLite(PERESOURCE Resource, BOOLEAN Wait);
// void __stdcall ExReleaseResourceLite(PERESOURCE Resource);
// NTSTATUS __stdcall ZwClose(HANDLE Handle);
// USHORT __stdcall ExQueryDepthSList(PSLIST_HEADER SListHead);
// NTSTATUS __stdcall ObReferenceObjectByHandle(HANDLE Handle, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PVOID *Object, POBJECT_HANDLE_INFORMATION HandleInformation);
// NTSTATUS __stdcall KeWaitForSingleObject(PVOID Object, KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
// NTSTATUS __stdcall ExDeleteResourceLite(PERESOURCE Resource);
// void __stdcall ExInitializePagedLookasideList(PPAGED_LOOKASIDE_LIST Lookaside, PALLOCATE_FUNCTION Allocate, PFREE_FUNCTION Free, ULONG Flags, SIZE_T Size, ULONG Tag, USHORT Depth);
// LONG_PTR __stdcall ObfDereferenceObject(PVOID Object);
// NTSTATUS __stdcall ExInitializeResourceLite(PERESOURCE Resource);
// NTSTATUS __stdcall KeWaitForMultipleObjects(ULONG Count, PVOID Object[], WAIT_TYPE WaitType, KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PKWAIT_BLOCK WaitBlockArray);
// void __stdcall KeAcquireSpinLockAtDpcLevel(PKSPIN_LOCK SpinLock);
// void __stdcall ExDeleteNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside);
// KIRQL __stdcall KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock);
// NTSTATUS __stdcall IoGetDeviceObjectPointer(PUNICODE_STRING ObjectName, ACCESS_MASK DesiredAccess, PFILE_OBJECT *FileObject, PDEVICE_OBJECT *DeviceObject);
// void __stdcall KeInitializeDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext);
// void __stdcall KeInitializeTimer(PKTIMER Timer);
// BOOLEAN __stdcall KeSetTimer(PKTIMER Timer, LARGE_INTEGER DueTime, PKDPC Dpc);
// BOOLEAN __stdcall KeCancelTimer(PKTIMER);
// NTSTATUS __stdcall KeDelayExecutionThread(KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Interval);
// NTSTATUS __stdcall IoWMIRegistrationControl(PDEVICE_OBJECT DeviceObject, ULONG Action);
// PVOID __stdcall ExAllocatePoolWithTag(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag);
// PIRP __stdcall IoBuildDeviceIoControlRequest(ULONG IoControlCode, PDEVICE_OBJECT DeviceObject, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, BOOLEAN InternalDeviceIoControl, PKEVENT Event, PIO_STATUS_BLOCK IoStatusBlock);
__int64 __fastcall sub_36008(unsigned __int8 a1, __int64 a2, unsigned int a3, unsigned int *a4, __int64 a5, unsigned int *a6);

//-------------------------------------------------------------------------
// Data declarations

unsigned __int8 byte_291F0[352] =
{
  6u,
  128u,
  128u,
  134u,
  128u,
  129u,
  128u,
  0u,
  0u,
  16u,
  3u,
  134u,
  128u,
  134u,
  130u,
  128u,
  20u,
  5u,
  5u,
  69u,
  69u,
  69u,
  133u,
  133u,
  133u,
  5u,
  0u,
  0u,
  48u,
  48u,
  128u,
  80u,
  128u,
  128u,
  0u,
  8u,
  0u,
  32u,
  32u,
  48u,
  80u,
  87u,
  128u,
  0u,
  7u,
  0u,
  55u,
  48u,
  48u,
  80u,
  80u,
  136u,
  0u,
  0u,
  0u,
  32u,
  40u,
  128u,
  136u,
  128u,
  128u,
  0u,
  0u,
  0u,
  96u,
  96u,
  96u,
  104u,
  104u,
  96u,
  0u,
  0u,
  7u,
  120u,
  112u,
  112u,
  119u,
  112u,
  112u,
  8u,
  8u,
  0u,
  0u,
  8u,
  0u,
  8u,
  0u,
  7u,
  8u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
_UNKNOWN unk_29AC0; // weak
_UNKNOWN unk_29AD0; // weak
_UNKNOWN unk_29AE0; // weak
_UNKNOWN unk_29AF0; // weak
_UNKNOWN unk_29B00; // weak
_DWORD dword_29B10[30] =
{
  1,
  11,
  23,
  53,
  97,
  193,
  389,
  769,
  1543,
  3079,
  6151,
  12289,
  24593,
  49157,
  98317,
  196613,
  393241,
  786433,
  1572869,
  3145739,
  6291469,
  12582917,
  25165843,
  50331653,
  100663319,
  201326611,
  402653189,
  805306457,
  1610612741,
  1666417251
}; // idb
_UNKNOWN unk_29B88; // weak
_UNKNOWN unk_29B98; // weak
_UNKNOWN unk_29BA8; // weak
_UNKNOWN unk_29BB8; // weak
_UNKNOWN unk_29BC8; // weak
_UNKNOWN unk_29BE8; // weak
_UNKNOWN unk_29BF8; // weak
_UNKNOWN unk_29C08; // weak
_UNKNOWN unk_29C18; // weak
_UNKNOWN unk_29C28; // weak
_UNKNOWN unk_29C48; // weak
_UNKNOWN unk_29C58; // weak
_UNKNOWN unk_29C68; // weak
_UNKNOWN unk_29C78; // weak
_UNKNOWN unk_29C88; // weak
_UNKNOWN unk_29C98; // weak
_UNKNOWN unk_29CA8; // weak
_UNKNOWN unk_29CB8; // weak
_UNKNOWN unk_29CD8; // weak
_UNKNOWN unk_29CE8; // weak
_UNKNOWN unk_29CF8; // weak
_UNKNOWN unk_29D08; // weak
_UNKNOWN unk_29D18; // weak
_UNKNOWN unk_29D78; // weak
char *off_2B110 = "(null)"; // weak
wchar_t *off_2B118 = L"(null)"; // weak
void *off_2B148 = &off_2B148; // weak
char aUnknownModule[15] = "Unknown module"; // weak
wchar_t aIdsreceivedpac[19] = L"IDSReceivedPackets"; // weak
__int64 (__fastcall *qword_2BAB0)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = NULL; // weak
__int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = NULL; // weak
__int64 (__fastcall *qword_2BAC0)(_QWORD) = NULL; // weak
__int64 (__fastcall *qword_2BAC8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = NULL; // weak
__int64 (__fastcall *qword_2BAD0)(_QWORD, _QWORD, _QWORD, _QWORD) = NULL; // weak
int dword_2BAD8 = 0; // weak
int dword_2BAE0 = 0; // weak
int dword_2BAE4 = 0; // weak
__int64 qword_2BAE8 = 0i64; // weak
struct _FAST_MUTEX stru_2BAF8 = { 0, NULL, 0u, { { { { 0 } }, 0, { NULL, NULL } } }, 0u }; // idb
__int64 qword_2BB30 = 0i64; // weak
PVOID qword_2BB38 = NULL; // idb
__int64 qword_2BB40 = 0i64; // weak
__int64 qword_2BB48 = 0i64; // weak
struct _FAST_MUTEX stru_2BB50 = { 0, NULL, 0u, { { { { 0 } }, 0, { NULL, NULL } } }, 0u }; // idb
struct _FAST_MUTEX stru_2BB88 = { 0, NULL, 0u, { { { { 0 } }, 0, { NULL, NULL } } }, 0u }; // idb
_UNKNOWN unk_2BBC0; // weak
_QWORD qword_2BBC8[2047] = { 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64,  }; // idb
PVOID qword_2FBC0; // idb
struct _FAST_MUTEX stru_2FBC8; // idb
_QWORD qword_2FC00[512]; // idb
__int64 qword_30C00; // weak
__int64 qword_30C08; // weak
int dword_30C10; // weak
int dword_30C14; // weak
PVOID qword_30C18; // idb
struct _FAST_MUTEX stru_30C20; // idb
__int64 qword_30C58; // weak
__int64 qword_30C68; // weak
__int64 qword_30C70; // weak
__int64 qword_30C78; // weak
struct _FAST_MUTEX stru_30C80; // idb
int dword_30CB8; // weak
struct _FAST_MUTEX FastMutex; // idb
PVOID qword_30CF8; // idb
_QWORD qword_30D00[512]; // idb
struct _FAST_MUTEX stru_31D00; // idb
__int64 qword_31D38; // weak
__int64 qword_31D40; // weak
PVOID Dst; // idb
PVOID qword_31D58; // idb
char byte_31D60; // weak
char byte_31D61; // weak
char byte_31D62; // weak
char byte_31D63; // weak
int dword_31D64; // weak
int dword_31D68; // weak
int dword_31D6C; // weak
PVOID qword_31D70; // idb
int dword_31D78; // weak
int dword_31D7C; // weak
PVOID qword_31D80; // idb
int dword_31D88; // weak
int dword_31D8C; // weak
int dword_31D90; // weak
int dword_31D94; // weak
int dword_31D98; // weak
int dword_31D9C; // weak
int dword_31DA0; // weak
int dword_31DA4; // weak
int dword_31DA8; // weak
int dword_31DAC; // weak
int dword_31DB0; // weak
int dword_31DB4; // weak
int dword_31DB8; // weak
int dword_31DBC; // weak
PVOID qword_31DC0; // idb
int dword_31DC8; // weak
int dword_31DCC; // weak
int dword_31DD0; // weak
int dword_31DD4; // weak
PVOID qword_31DD8; // idb
PVOID qword_31DE0; // idb
PVOID P; // idb
__int64 qword_31E08; // weak
union _LARGE_INTEGER PerformanceFrequency; // idb
PVOID qword_31E18; // idb
PVOID qword_31E20; // idb
__int64 qword_31E28; // weak
PVOID qword_31E30; // idb
__int64 qword_31E38; // weak
_WORD word_31E40[520]; // idb
int dword_32250; // weak
PVOID qword_32258; // idb
__int64 qword_32260; // weak
PVOID qword_32268; // idb
PVOID qword_32270; // idb
int dword_32278; // weak
int dword_3227C; // weak
char byte_32280; // weak
char byte_32281; // weak
char byte_32282; // weak
char byte_32283; // weak
char byte_32284; // weak
__int64 (__fastcall *qword_32288)(_QWORD); // weak
__int64 qword_32290; // weak
__int64 qword_32298; // weak
__int64 qword_322A0; // weak
__int64 qword_322A8; // weak
__int64 qword_34890; // weak
__int64 qword_34898; // weak
struct _KDPC Dpc; // idb
_UNKNOWN unk_348E0; // weak
struct _KTIMER Timer; // idb
struct _KMUTANT Mutex; // idb
__int64 qword_34AA0; // weak
__int64 qword_34AA8; // weak
__int64 qword_34AB0; // weak
__int64 qword_34AC0; // weak
char byte_34AC8; // weak
char byte_34AC9; // weak
__int16 word_34ACA; // weak
int dword_34ACC; // weak
__int64 qword_34AE0; // weak
__int64 qword_34AE8; // weak
__int64 qword_34AF0; // weak
__int64 qword_34B00; // weak
char byte_34B08; // weak
char byte_34B09; // weak
__int16 word_34B0A; // weak
int dword_34B0C; // weak
__int64 qword_34B20; // weak
__int64 qword_34B28; // weak
__int64 qword_34B30; // weak
__int64 qword_34B40; // weak
char byte_34B48; // weak
char byte_34B49; // weak
__int16 word_34B4A; // weak
int dword_34B4C; // weak
__int64 qword_34B60; // weak
__int64 qword_34B68; // weak
__int64 qword_34B70; // weak
__int64 qword_34B80; // weak
char byte_34B88; // weak
char byte_34B89; // weak
__int16 word_34B8A; // weak
int dword_34B8C; // weak


//----- (0000000000011008) ----------------------------------------------------
__int64 __fastcall sub_11008(__int64 a1, unsigned __int16 a2, __int64 a3)
{
  return qword_2BAB8(a1, 43i64, a3, a2, 0i64);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001102C) ----------------------------------------------------
__int64 __fastcall sub_1102C(__int64 a1, __int64 a2, __int64 a3, __int16 a4, __int64 a5)
{
  char *v7; // rsi
  __int64 *v8; // rax
  __int64 v9; // r8
  SIZE_T v10; // rbx
  unsigned __int64 v11; // rcx
  int *v12; // rdx
  __int64 v13; // r9
  char *v15; // rax
  __int64 v16; // rbp
  const void **i; // rdi
  size_t v18; // rbx
  unsigned int v19; // ebx
  __int64 WnodeEventItem[7]; // [rsp+30h] [rbp-D8h] BYREF
  int v21; // [rsp+68h] [rbp-A0h] BYREF
  char *v22; // [rsp+70h] [rbp-98h]
  int v23; // [rsp+78h] [rbp-90h]
  __int16 v24; // [rsp+128h] [rbp+20h] BYREF

  v24 = a4;
  v7 = 0i64;
  memset(WnodeEventItem, 0, 0x30ui64);
  WnodeEventItem[1] = a1;
  WnodeEventItem[6] = (__int64)&v24;
  v8 = &a5;
  WnodeEventItem[3] = a3;
  HIDWORD(WnodeEventItem[5]) = 1703936;
  BYTE4(WnodeEventItem[0]) = -1;
  v21 = 2;
  v9 = a5;
  v10 = 0i64;
  v11 = 0i64;
  if ( a5 )
  {
    v12 = &v21;
    do
    {
      v13 = v8[1];
      ++v11;
      v12 += 4;
      v10 += v13;
      if ( v11 <= 7 )
      {
        *((_QWORD *)v12 - 1) = v9;
        *v12 = v13;
      }
      v8 += 2;
      v9 = *v8;
    }
    while ( *v8 );
  }
  if ( v10 > 0x2000 )
    return 3221225473i64;
  if ( v11 <= 7 )
  {
    LOWORD(WnodeEventItem[0]) = 16 * (v11 + 4);
  }
  else
  {
    v15 = (char *)ExAllocatePoolWithTag(NonPagedPool, v10, 0x45435453u);
    v7 = v15;
    if ( !v15 )
      return 3221225495i64;
    v22 = v15;
    v23 = v10;
    v16 = 0i64;
    for ( i = (const void **)&a5; *i; i += 2 )
    {
      v18 = (size_t)i[1];
      memmove(&v7[v16], *i, v18);
      v16 += v18;
    }
    LOWORD(WnodeEventItem[0]) = 80;
  }
  v19 = IoWMIWriteEvent(WnodeEventItem);
  if ( v7 )
    ExFreePoolWithTag(v7, 0);
  return v19;
}

//----- (0000000000011180) ----------------------------------------------------
__int64 __fastcall sub_11180(__int64 a1, char a2, __int64 *a3, __int64 a4)
{
  __int64 result; // rax

  result = 0i64;
  if ( a2 == 1 || !a2 )
  {
    if ( a2 )
    {
      *(_DWORD *)(a4 + 44) = *((_DWORD *)a3 + 1);
      *(_BYTE *)(a4 + 41) = *((_BYTE *)a3 + 2);
      result = *a3;
    }
    else
    {
      *(_BYTE *)(a4 + 41) = 0;
      *(_DWORD *)(a4 + 44) = 0;
    }
    *(_QWORD *)(a4 + 24) = result;
  }
  return result;
}

//----- (00000000000111B8) ----------------------------------------------------
NTSTATUS __stdcall DriverEntry(_DRIVER_OBJECT *DriverObject, PUNICODE_STRING RegistryPath)
{
  int v3; // eax
  void **v4; // rcx
  __int64 *v5; // rbx
  __int64 v6; // rcx
  ULONG v7; // edx
  struct _DEVICE_OBJECT *v8; // rcx
  PVOID v9; // rax
  NTSTATUS result; // eax
  struct _UNICODE_STRING DestinationString; // [rsp+30h] [rbp-18h] BYREF
  unsigned int v12; // [rsp+50h] [rbp+8h] BYREF

  qword_34AA8 = (__int64)&unk_29AC0;
  qword_34AB0 = (__int64)&qword_34AE0;
  qword_34AE8 = (__int64)&unk_29AD0;
  qword_34AA0 = 0i64;
  qword_34AF0 = (__int64)&qword_34B20;
  qword_34AC0 = 0i64;
  qword_34B28 = (__int64)&unk_29AE0;
  byte_34AC8 = 1;
  qword_34B30 = (__int64)&qword_34B60;
  byte_34AC9 = 0;
  word_34ACA = 0;
  dword_34ACC = 0;
  qword_34AE0 = 0i64;
  qword_34B68 = (__int64)&unk_29AF0;
  qword_34B00 = 0i64;
  byte_34B08 = 1;
  byte_34B09 = 0;
  word_34B0A = 0;
  dword_34B0C = 0;
  qword_34B20 = 0i64;
  qword_34B40 = 0i64;
  byte_34B48 = 1;
  byte_34B49 = 0;
  word_34B4A = 0;
  dword_34B4C = 0;
  qword_34B60 = 0i64;
  qword_34B70 = 0i64;
  qword_34B80 = 0i64;
  byte_34B88 = 1;
  byte_34B89 = 0;
  word_34B8A = 0;
  dword_34B8C = 0;
  v12 = 0;
  RtlInitUnicodeString(&DestinationString, L"PsGetVersion");
  qword_2BAD0 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))MmGetSystemRoutineAddress(&DestinationString);
  RtlInitUnicodeString(&DestinationString, L"WmiTraceMessage");
  qword_2BAB8 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))MmGetSystemRoutineAddress(&DestinationString);
  if ( !qword_2BAB8 )
  {
    qword_2BAB8 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_1102C;
    v3 = 1;
LABEL_3:
    dword_2BAD8 = v3;
    goto LABEL_10;
  }
  RtlInitUnicodeString(&DestinationString, L"WmiQueryTraceInformation");
  qword_2BAB0 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))MmGetSystemRoutineAddress(&DestinationString);
  v3 = 2;
  dword_2BAD8 = 2;
  if ( qword_2BAD0 )
  {
    qword_2BAD0(&v12, 0i64, 0i64, 0i64);
    v3 = dword_2BAD8;
  }
  if ( v12 >= 6 )
  {
    RtlInitUnicodeString(&DestinationString, L"EtwRegisterClassicProvider");
    qword_2BAC8 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))MmGetSystemRoutineAddress(&DestinationString);
    if ( qword_2BAC8 )
    {
      RtlInitUnicodeString(&DestinationString, L"EtwUnregister");
      qword_2BAC0 = (__int64 (__fastcall *)(_QWORD))MmGetSystemRoutineAddress(&DestinationString);
      v3 = 4;
      goto LABEL_3;
    }
    v3 = dword_2BAD8;
  }
LABEL_10:
  v4 = (void **)off_2B148;
  v5 = &qword_34AA0;
  qword_34AC0 = 0i64;
  if ( off_2B148 != &qword_34AA0 )
  {
    off_2B148 = &qword_34AA0;
    if ( v3 == 4 )
    {
      do
      {
        v6 = v5[1];
        v5[7] = 0i64;
        qword_2BAC8(v6, 0i64, sub_11180, v5, v5 + 7);
        v5 = (__int64 *)v5[2];
      }
      while ( v5 );
    }
    else
    {
      if ( v3 == 2 )
      {
        v7 = -2147418111;
        v8 = (struct _DEVICE_OBJECT *)&qword_34AA0;
        qword_34AA0 = (__int64)sub_36008;
      }
      else
      {
        qword_34AA0 = 0i64;
        v7 = 1;
        v8 = (struct _DEVICE_OBJECT *)DriverObject;
      }
      IoWMIRegistrationControl(v8, v7);
    }
    v4 = (void **)off_2B148;
  }
  if ( v4 != &off_2B148 && (*((_BYTE *)v4 + 236) & 1) != 0 && *((_BYTE *)v4 + 233) >= 5u )
    sub_11008((__int64)v4[27], 0xAu, (__int64)&unk_29D18);
  sub_1A5A4();
  sub_1A5A4();
  if ( !P )
  {
    dword_31DD4 = 24;
    qword_34890 = (__int64)aIdsreceivedpac;
    v9 = sub_17C28(2, 0x60u, 0x72746E63u);
    P = v9;
    if ( v9 )
      memset(v9, 0, 0x60ui64);
  }
  DriverObject->DriverUnload = (PDRIVER_UNLOAD)sub_11578;
  if ( (unsigned int)sub_11E60() )
  {
    sub_11578((PDEVICE_OBJECT)DriverObject);
    result = -1073741823;
  }
  else
  {
    KeInitializeMutex(&Mutex, 0);
    result = 0;
  }
  return result;
}
// 2B148: using guessed type void *off_2B148;
// 2B190: using guessed type wchar_t aIdsreceivedpac[19];
// 2BAB0: using guessed type __int64 (__fastcall *qword_2BAB0)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 2BAC0: using guessed type __int64 (__fastcall *qword_2BAC0)(_QWORD);
// 2BAC8: using guessed type __int64 (__fastcall *qword_2BAC8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 2BAD0: using guessed type __int64 (__fastcall *qword_2BAD0)(_QWORD, _QWORD, _QWORD, _QWORD);
// 2BAD8: using guessed type int dword_2BAD8;
// 31DD4: using guessed type int dword_31DD4;
// 34890: using guessed type __int64 qword_34890;
// 34AA0: using guessed type __int64 qword_34AA0;
// 34AA8: using guessed type __int64 qword_34AA8;
// 34AB0: using guessed type __int64 qword_34AB0;
// 34AC0: using guessed type __int64 qword_34AC0;
// 34AC8: using guessed type char byte_34AC8;
// 34AC9: using guessed type char byte_34AC9;
// 34ACA: using guessed type __int16 word_34ACA;
// 34ACC: using guessed type int dword_34ACC;
// 34AE0: using guessed type __int64 qword_34AE0;
// 34AE8: using guessed type __int64 qword_34AE8;
// 34AF0: using guessed type __int64 qword_34AF0;
// 34B00: using guessed type __int64 qword_34B00;
// 34B08: using guessed type char byte_34B08;
// 34B09: using guessed type char byte_34B09;
// 34B0A: using guessed type __int16 word_34B0A;
// 34B0C: using guessed type int dword_34B0C;
// 34B20: using guessed type __int64 qword_34B20;
// 34B28: using guessed type __int64 qword_34B28;
// 34B30: using guessed type __int64 qword_34B30;
// 34B40: using guessed type __int64 qword_34B40;
// 34B48: using guessed type char byte_34B48;
// 34B49: using guessed type char byte_34B49;
// 34B4A: using guessed type __int16 word_34B4A;
// 34B4C: using guessed type int dword_34B4C;
// 34B60: using guessed type __int64 qword_34B60;
// 34B68: using guessed type __int64 qword_34B68;
// 34B70: using guessed type __int64 qword_34B70;
// 34B80: using guessed type __int64 qword_34B80;
// 34B88: using guessed type char byte_34B88;
// 34B89: using guessed type char byte_34B89;
// 34B8A: using guessed type __int16 word_34B8A;
// 34B8C: using guessed type int dword_34B8C;

//----- (0000000000011578) ----------------------------------------------------
void __fastcall sub_11578(PDEVICE_OBJECT DeviceObject)
{
  void **v2; // rbx
  ULONG v3; // edx
  struct _DEVICE_OBJECT *v4; // rcx
  void *v5; // rcx

  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 1) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0xBu, (__int64)&unk_29D18);
  sub_12334();
  if ( P )
  {
    sub_17CAC(P, 0x72746E63u);
    P = 0i64;
  }
  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( _bittest((const signed __int32 *)off_2B148 + 43, 0x12u) && *((_BYTE *)off_2B148 + 169) >= 5u )
    {
      sub_11008(*((_QWORD *)off_2B148 + 19), 0xDu, (__int64)&unk_29BC8);
      v2 = (void **)off_2B148;
    }
    if ( v2 != &off_2B148 )
    {
      if ( _bittest((const signed __int32 *)v2 + 43, 0x12u) && *((_BYTE *)v2 + 169) >= 5u )
      {
        sub_11B10((__int64)v2[19], 0xEu, (__int64)&unk_29BC8, 0);
        v2 = (void **)off_2B148;
      }
      if ( v2 != &off_2B148 )
      {
        if ( dword_2BAD8 == 4 )
        {
          while ( v2 )
          {
            v5 = v2[7];
            if ( v5 )
              qword_2BAC0(v5);
            v2 = (void **)v2[2];
          }
        }
        else
        {
          v3 = 2;
          if ( dword_2BAD8 == 2 )
          {
            v3 = -2147483646;
            v4 = (struct _DEVICE_OBJECT *)v2;
          }
          else
          {
            v4 = DeviceObject;
          }
          IoWMIRegistrationControl(v4, v3);
        }
        off_2B148 = &off_2B148;
      }
    }
  }
}
// 2B148: using guessed type void *off_2B148;
// 2BAC0: using guessed type __int64 (__fastcall *qword_2BAC0)(_QWORD);
// 2BAD8: using guessed type int dword_2BAD8;

//----- (00000000000116D8) ----------------------------------------------------
__int64 __fastcall sub_116D8(_DWORD *a1)
{
  __int64 result; // rax

  a1[34] = 1500;
  a1[5] = 1500;
  a1[33] = 600;
  a1[39] = 600;
  result = 20i64;
  *a1 = 1;
  a1[31] = 1;
  a1[32] = 5;
  a1[16] = 20;
  a1[19] = 20;
  a1[42] = 20;
  a1[35] = 1;
  a1[36] = 4;
  a1[37] = 15;
  a1[38] = 30;
  a1[4] = 1;
  a1[6] = 1;
  a1[7] = 10;
  a1[8] = 1;
  a1[9] = 500;
  a1[23] = 1;
  a1[24] = 0;
  a1[25] = 1;
  a1[26] = 1;
  a1[27] = 1;
  a1[28] = 1;
  a1[29] = 1;
  a1[10] = 1;
  a1[12] = 300;
  a1[11] = 10;
  a1[13] = 0;
  a1[14] = 1;
  a1[15] = 200;
  a1[17] = 1;
  a1[18] = 60;
  a1[30] = 1;
  a1[20] = 0;
  a1[21] = 5;
  a1[22] = 4500;
  a1[40] = 1;
  a1[41] = 0;
  a1[43] = 1;
  a1[45] = 300;
  a1[44] = 10;
  a1[46] = 1;
  a1[1] = 1;
  a1[2] = 1;
  a1[3] = 300;
  return result;
}

//----- (00000000000117F4) ----------------------------------------------------
char __fastcall sub_117F4(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  char v4; // r10

  v4 = 1;
  if ( !a2 || !a3 || !a4 )
    return 0;
  *a4 = 0;
  switch ( a1 )
  {
    case 33648641:
      *a2 = 0;
      break;
    case 33648643:
      *a2 = 16;
      break;
    case 33648644:
      *a2 = 20;
      break;
    case 33648645:
      *a2 = 24;
      break;
    case 33648646:
      *a2 = 28;
      break;
    case 33648647:
      *a2 = 32;
      break;
    case 33648648:
      *a2 = 36;
      break;
    case 33648649:
      *a2 = 40;
      break;
    case 33648650:
      *a2 = 44;
      break;
    case 33648651:
      *a2 = 48;
      break;
    case 33648652:
      *a2 = 52;
      break;
    case 33648653:
      *a2 = 56;
      break;
    case 33648654:
      *a2 = 60;
      break;
    case 33648655:
      *a2 = 64;
      break;
    case 33648656:
      *a2 = 68;
      break;
    case 33648657:
      *a2 = 72;
      break;
    case 33648658:
      *a2 = 76;
      break;
    case 33648659:
      *a2 = 80;
      break;
    case 33648660:
      *a2 = 84;
      break;
    case 33648661:
      *a2 = 88;
      break;
    case 33648662:
      *a2 = 92;
      break;
    case 33648663:
      *a2 = 96;
      break;
    case 33648664:
      *a2 = 100;
      break;
    case 33648665:
      *a2 = 104;
      break;
    case 33648666:
      *a2 = 108;
      break;
    case 33648667:
      *a2 = 112;
      break;
    case 33648668:
      *a2 = 116;
      break;
    case 33648669:
      *a2 = 120;
      break;
    case 33648670:
      *a2 = 124;
      break;
    case 33648671:
      *a2 = 128;
      break;
    case 33648672:
      *a2 = 132;
      break;
    case 33648673:
      *a2 = 136;
      break;
    case 33648674:
      *a2 = 140;
      break;
    case 33648675:
      *a2 = 144;
      break;
    case 33648676:
      *a2 = 148;
      break;
    case 33648677:
      *a2 = 152;
      break;
    case 33648678:
      *a2 = 156;
      break;
    case 33648679:
      *a2 = 160;
      break;
    case 33648680:
      *a2 = 164;
      break;
    case 33648681:
      *a2 = 168;
      break;
    case 33648682:
      *a2 = 172;
      break;
    case 33648683:
      *a2 = 176;
      break;
    case 33648684:
      *a2 = 180;
      break;
    case 33648685:
      *a2 = 184;
      break;
    case 33648686:
      *a2 = 4;
      break;
    case 33648687:
      *a2 = 8;
      break;
    case 33648688:
      *a2 = 12;
      break;
    default:
      return 0;
  }
  *a3 = 4;
  return v4;
}

//----- (0000000000011AE8) ----------------------------------------------------
__int64 sub_11AE8()
{
  __int64 result; // rax

  if ( Dst )
    result = sub_1B1F0();
  return result;
}

//----- (0000000000011B10) ----------------------------------------------------
__int64 __fastcall sub_11B10(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+68h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2BAB8(a1, 43i64, a3, a2, &v5);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000011B4C) ----------------------------------------------------
__int64 __fastcall sub_11B4C(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+118h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2BAB8(a1, 43i64, &unk_29D08, 66i64, &v5);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000011C28) ----------------------------------------------------
__int64 __fastcall sub_11C28(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+A8h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2BAB8(a1, 43i64, &unk_29D08, a2, &v5);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000011CA8) ----------------------------------------------------
__int64 __fastcall sub_11CA8(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+88h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2BAB8(a1, 43i64, &unk_29D08, 76i64, &v5);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000011D0C) ----------------------------------------------------
__int64 __fastcall sub_11D0C(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+78h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2BAB8(a1, 43i64, a3, a2, &v5);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000011D54) ----------------------------------------------------
__int64 __fastcall sub_11D54(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+D8h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2BAB8(a1, 43i64, &unk_29D08, 58i64, &v5);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000011DF8) ----------------------------------------------------
__int64 __fastcall sub_11DF8(__int64 a1, unsigned __int16 a2, __int64 a3, const char *a4)
{
  const char *v5; // rax

  if ( a4 )
    strlen(a4);
  v5 = "NULL";
  if ( a4 )
    v5 = a4;
  return qword_2BAB8(a1, 43i64, &unk_29D08, a2, v5);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000011E60) ----------------------------------------------------
__int64 sub_11E60()
{
  unsigned int v0; // ebx
  int v1; // eax
  void **v2; // rcx
  int v3; // eax
  PVOID v4; // rax
  void *v5; // rax
  int v6; // ecx
  __int64 v8[4]; // [rsp+40h] [rbp-C8h] BYREF
  int v9; // [rsp+60h] [rbp-A8h] BYREF
  __int64 v10; // [rsp+64h] [rbp-A4h]
  char Dst[120]; // [rsp+6Ch] [rbp-9Ch] BYREF
  int v12[3]; // [rsp+E4h] [rbp-24h] BYREF

  v9 = 33648640;
  v10 = 0x5300440049i64;
  memset(Dst, 0, sizeof(Dst));
  v8[3] = 0i64;
  v8[0] = (__int64)sub_117F4;
  qmemcpy(v12, "NIDS0", 5);
  v8[1] = (__int64)sub_116D8;
  v8[2] = (__int64)sub_11AE8;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 1) != 0 && *((_BYTE *)off_2B148 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0xAu, (__int64)&unk_29D08);
  memset(&unk_348E0, 0, 0x140ui64);
  sub_20720(0);
  ::Dst = sub_17C28(2, 0xBCu, 0x74736469u);
  if ( !::Dst )
  {
    v0 = 3;
LABEL_52:
    v2 = (void **)off_2B148;
    goto LABEL_53;
  }
  v1 = sub_1A8D8((__int64)&v9, 188i64, v8);
  v0 = v1;
  if ( !v1 )
  {
    v0 = sub_22E40();
    if ( v0 )
    {
      v2 = (void **)off_2B148;
      if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 236) & 1) == 0 || *((_BYTE *)off_2B148 + 233) < 2u )
      {
LABEL_26:
        if ( v0 )
          goto LABEL_53;
        v3 = sub_23110();
        v0 = v3;
        if ( v3
          && off_2B148 != &off_2B148
          && (*((_BYTE *)off_2B148 + 236) & 1) != 0
          && *((_BYTE *)off_2B148 + 233) >= 2u )
        {
          sub_11B10(*((_QWORD *)off_2B148 + 27), 0xDu, (__int64)&unk_29D08, v3);
        }
        sub_20994(40000, (__int64)sub_1297C);
        sub_20994(40001, (__int64)sub_12BB8);
        if ( (unsigned int)sub_20B88() )
        {
          v2 = (void **)off_2B148;
          if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 1) != 0 && *((_BYTE *)off_2B148 + 233) >= 2u )
          {
            sub_11008(*((_QWORD *)off_2B148 + 27), 0xEu, (__int64)&unk_29D08);
            v2 = (void **)off_2B148;
          }
          v0 = 259;
        }
        else
        {
          v2 = (void **)off_2B148;
        }
        if ( v0 )
          goto LABEL_53;
        v0 = sub_1AE50();
        if ( !v0 )
        {
          if ( !dword_31D88 )
          {
            v4 = sub_17C28(2, 0x40000u, 0x68747361u);
            qword_31D80 = v4;
            if ( v4 )
            {
              memset(v4, 0, 0x40000ui64);
              dword_31D88 = 1;
            }
          }
          dword_31D8C = 1;
          dword_31D9C = 1;
          dword_31DA0 = 1;
          sub_156E8();
          dword_31DAC = 1;
          sub_15CB8();
          dword_31DB4 = 1;
          sub_164F0();
          sub_16990();
          sub_14EFC();
          sub_16F00();
          sub_1782C();
          if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 108) < 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
            sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x2Bu);
          v5 = (void *)sub_19C7C();
          v6 = 0;
          qword_31D58 = v5;
          if ( !v5 )
            v6 = 3;
          v0 = v6;
          if ( !v6 )
          {
            KeInitializeDpc(&Dpc, (PKDEFERRED_ROUTINE)DeferredRoutine, sub_137B8);
            KeInitializeTimer(&Timer);
            qword_34898 = -10000000i64;
            KeSetTimer(&Timer, (LARGE_INTEGER)-10000000i64, &Dpc);
            sub_20720(1);
          }
        }
        goto LABEL_52;
      }
      sub_11008(*((_QWORD *)off_2B148 + 27), 0xCu, (__int64)&unk_29D08);
    }
    else
    {
      v2 = (void **)off_2B148;
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
      {
        sub_11008(*((_QWORD *)off_2B148 + 19), 0xF0u, (__int64)&unk_29B98);
        v2 = (void **)off_2B148;
      }
      byte_31D63 = 1;
      if ( v2 == &off_2B148 || (*((_BYTE *)v2 + 172) & 1) == 0 || *((_BYTE *)v2 + 169) < 5u )
        goto LABEL_26;
      sub_11B10((__int64)v2[19], 0xF1u, (__int64)&unk_29B98, 0);
    }
    v2 = (void **)off_2B148;
    goto LABEL_26;
  }
  v2 = (void **)off_2B148;
  if ( off_2B148 == &off_2B148 )
    return v0;
  if ( (*((_BYTE *)off_2B148 + 236) & 1) != 0 && *((_BYTE *)off_2B148 + 233) >= 2u )
  {
    sub_11B10(*((_QWORD *)off_2B148 + 27), 0xBu, (__int64)&unk_29D08, v1);
    goto LABEL_52;
  }
LABEL_53:
  if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 236) & 1) != 0 && *((_BYTE *)v2 + 233) >= 5u )
    sub_11008((__int64)v2[27], 0xFu, (__int64)&unk_29D08);
  return v0;
}
// 2B148: using guessed type void *off_2B148;
// 31D63: using guessed type char byte_31D63;
// 31D88: using guessed type int dword_31D88;
// 31D8C: using guessed type int dword_31D8C;
// 31D9C: using guessed type int dword_31D9C;
// 31DA0: using guessed type int dword_31DA0;
// 31DAC: using guessed type int dword_31DAC;
// 31DB4: using guessed type int dword_31DB4;
// 34898: using guessed type __int64 qword_34898;

//----- (0000000000012334) ----------------------------------------------------
__int64 sub_12334()
{
  PVOID v0; // rbx
  void **v1; // rcx
  unsigned __int16 v2; // dx
  __int64 v3; // rdx
  __int64 v4; // r8
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 v7; // rsi
  __int64 **v8; // rbx
  __int64 v9; // rdi
  __int64 **v10; // rbx
  __int64 *v11; // rdx
  __int64 v12; // rcx
  __int64 *v13; // rax
  void **v14; // rbx
  __int64 v15; // rdi
  void *v16; // rcx
  void **v17; // rcx
  unsigned __int16 v18; // dx
  char *v19; // rcx
  _QWORD *v20; // rcx
  _QWORD *v21; // rax
  _QWORD **v22; // rdx

  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 1) != 0 && *((_BYTE *)off_2B148 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0x10u, (__int64)&unk_29D08);
  sub_20720(0);
  KeCancelTimer(&Timer);
  v0 = qword_31D58;
  if ( qword_31D58 )
  {
    if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 108) < 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
      sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x2Du);
    sub_19EA0(v0);
  }
  v1 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148
    && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
    && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x1Bu, (__int64)&unk_29BB8);
    v1 = (void **)off_2B148;
  }
  if ( qword_31E18 )
  {
    sub_26B5C((PFAST_MUTEX)((char *)qword_31E18 + 128));
    v5 = *((_QWORD *)qword_31E18 + 5);
    if ( v5 )
    {
      v6 = *((_QWORD *)qword_31E18 + 6);
      if ( v6 )
      {
        (*(void (__fastcall **)(__int64, __int64, __int64))(v5 + 8))(v6, v3, v4);
        *((_QWORD *)qword_31E18 + 6) = 0i64;
      }
    }
    v1 = (void **)off_2B148;
    if ( off_2B148 != &off_2B148
      && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
      && *((_BYTE *)off_2B148 + 169) >= 5u )
    {
      v2 = 30;
      goto LABEL_31;
    }
  }
  else if ( v1 != &off_2B148 )
  {
    if ( _bittest((const signed __int32 *)v1 + 43, 8u) && *((_BYTE *)v1 + 169) >= 2u )
    {
      sub_11008((__int64)v1[19], 0x1Cu, (__int64)&unk_29BB8);
      v1 = (void **)off_2B148;
    }
    if ( v1 != &off_2B148 && _bittest((const signed __int32 *)v1 + 43, 8u) && *((_BYTE *)v1 + 169) >= 5u )
    {
      v2 = 29;
LABEL_31:
      sub_11008((__int64)v1[19], v2, (__int64)&unk_29BB8);
      goto LABEL_32;
    }
  }
LABEL_32:
  sub_20E98();
  if ( dword_31DD0 )
  {
    while ( (__int64 *)qword_31D38 != &qword_31D38 )
      sub_17A14((_QWORD *)qword_31D38);
    sub_17F18(qword_31DE0);
    sub_17F18(qword_31DD8);
    dword_31DD0 = 0;
  }
  v7 = 256i64;
  if ( dword_31DCC )
  {
    dword_31DCC = 0;
    v8 = (__int64 **)&unk_30D00;
    v9 = 256i64;
    do
    {
      while ( *v8 != (__int64 *)v8 )
        sub_1737C(*v8);
      v8 += 2;
      --v9;
    }
    while ( v9 );
    sub_17F18(qword_30CF8);
  }
  dword_31D78 = 0;
  if ( qword_31D70 )
  {
    sub_24410((__int64)qword_31D70);
    qword_31D70 = 0i64;
  }
  if ( dword_31DC8 )
  {
    dword_31DC8 = 0;
    while ( (__int64 *)qword_30C70 != &qword_30C70 )
      sub_16CB8((__int64 *)qword_30C70);
    sub_17F18(qword_31DC0);
    dword_30CB8 = 0;
  }
  if ( dword_31DB8 )
  {
    dword_31DB8 = 0;
    while ( (__int64 *)qword_30C00 != &qword_30C00 )
      sub_16954((__int64 *)qword_30C00);
    sub_17F18(qword_30C18);
  }
  dword_31DB4 = 0;
  if ( dword_31DB0 )
  {
    dword_31DB0 = 0;
    v10 = (__int64 **)&unk_2FC00;
    do
    {
      while ( *v10 != (__int64 *)v10 )
      {
        v11 = *v10;
        if ( *v10 )
        {
          v12 = *v11;
          v13 = (__int64 *)v11[1];
          *v13 = *v11;
          *(_QWORD *)(v12 + 8) = v13;
          sub_180A0((__int64)qword_2FBC0, (__int64)v11);
        }
      }
      v10 += 2;
      --v7;
    }
    while ( v7 );
    v14 = (void **)&unk_2BBC8;
    v15 = 1024i64;
    do
    {
      if ( *((_DWORD *)v14 - 2) )
      {
        v16 = *v14;
        *((_DWORD *)v14 - 2) = 0;
        sub_17CAC(v16, 0x55445045u);
        *v14 = 0i64;
      }
      v14 += 2;
      --v15;
    }
    while ( v15 );
    sub_17F18(qword_2FBC0);
  }
  dword_31DAC = 0;
  if ( dword_31DA4 )
  {
    dword_31DA4 = 0;
    while ( (__int64 *)qword_2BB40 != &qword_2BB40 )
      sub_157AC((__int64 *)qword_2BB40);
    sub_17F18(qword_2BB38);
  }
  dword_31DA0 = 0;
  dword_31D9C = 0;
  dword_31D8C = 0;
  if ( dword_31D88 )
  {
    dword_31D88 = 0;
    if ( qword_31D80 )
    {
      sub_17CAC(qword_31D80, 0x68747361u);
      qword_31D80 = 0i64;
    }
  }
  v17 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148
    && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
    && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x1Fu, (__int64)&unk_29BB8);
    v17 = (void **)off_2B148;
  }
  if ( qword_31E18 )
  {
    sub_20E98();
    sub_26AE4((__int64)qword_31E18 + 128);
    v19 = (char *)qword_31E18;
    if ( !*((_QWORD *)qword_31E18 + 26) )
      goto LABEL_91;
    v20 = (_QWORD *)*((_QWORD *)qword_31E18 + 26);
    while ( 1 )
    {
      sub_17CAC(v20, 0x66634E4Eu);
      v19 = (char *)qword_31E18;
LABEL_91:
      v22 = (_QWORD **)(v19 + 56);
      if ( *v22 == v22 )
        break;
      v21 = (_QWORD *)**v22;
      v20 = *v22 - 5;
      *v22 = v21;
      v21[1] = v22;
    }
    sub_182A0((PERESOURCE)(v19 + 216));
    sub_17CAC(qword_31E18, 0x66634E4Eu);
    qword_31E18 = 0i64;
    v17 = (void **)off_2B148;
    if ( off_2B148 != &off_2B148
      && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
      && *((_BYTE *)off_2B148 + 169) >= 5u )
    {
      v18 = 34;
      goto LABEL_96;
    }
  }
  else if ( v17 != &off_2B148 )
  {
    if ( _bittest((const signed __int32 *)v17 + 43, 8u) && *((_BYTE *)v17 + 169) >= 2u )
    {
      sub_11008((__int64)v17[19], 0x20u, (__int64)&unk_29BB8);
      v17 = (void **)off_2B148;
    }
    if ( v17 != &off_2B148 && _bittest((const signed __int32 *)v17 + 43, 8u) && *((_BYTE *)v17 + 169) >= 5u )
    {
      v18 = 33;
LABEL_96:
      sub_11008((__int64)v17[19], v18, (__int64)&unk_29BB8);
      v17 = (void **)off_2B148;
      goto LABEL_97;
    }
  }
LABEL_97:
  if ( Dst )
  {
    sub_17CAC(Dst, 0x74736469u);
    v17 = (void **)off_2B148;
    Dst = 0i64;
  }
  if ( v17 != &off_2B148 && (*((_BYTE *)v17 + 236) & 1) != 0 && *((_BYTE *)v17 + 233) >= 5u )
    sub_11008((__int64)v17[27], 0x11u, (__int64)&unk_29D08);
  return 0i64;
}
// 124C4: variable 'v3' is possibly undefined
// 124C4: variable 'v4' is possibly undefined
// 2B148: using guessed type void *off_2B148;
// 2BB40: using guessed type __int64 qword_2BB40;
// 30C00: using guessed type __int64 qword_30C00;
// 30C70: using guessed type __int64 qword_30C70;
// 30CB8: using guessed type int dword_30CB8;
// 31D38: using guessed type __int64 qword_31D38;
// 31D78: using guessed type int dword_31D78;
// 31D88: using guessed type int dword_31D88;
// 31D8C: using guessed type int dword_31D8C;
// 31D9C: using guessed type int dword_31D9C;
// 31DA0: using guessed type int dword_31DA0;
// 31DA4: using guessed type int dword_31DA4;
// 31DAC: using guessed type int dword_31DAC;
// 31DB0: using guessed type int dword_31DB0;
// 31DB4: using guessed type int dword_31DB4;
// 31DB8: using guessed type int dword_31DB8;
// 31DC8: using guessed type int dword_31DC8;
// 31DCC: using guessed type int dword_31DCC;
// 31DD0: using guessed type int dword_31DD0;

//----- (000000000001297C) ----------------------------------------------------
__int64 __fastcall sub_1297C(int a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5)
{
  unsigned int v7; // ebx
  void **v8; // rcx
  unsigned int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // eax

  *a5 = 1;
  v7 = 0;
  v8 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 0x20) != 0 && *((_BYTE *)off_2B148 + 233) >= 5u )
  {
    sub_11C28(*((_QWORD *)off_2B148 + 27), 0x12u, (__int64)&unk_29D08, a1);
    v8 = (void **)off_2B148;
  }
  if ( *(_DWORD *)Dst && a2 && *(_QWORD *)(a2 + 16) )
  {
    v9 = dword_31DD4;
    if ( dword_31DD4 )
    {
      _InterlockedAdd((volatile signed __int32 *)P, 1u);
      v8 = (void **)off_2B148;
      v9 = dword_31DD4;
    }
    if ( (*(_BYTE *)(a2 + 120) & 0x10) != 0 )
    {
      if ( v9 > 2 )
      {
        _InterlockedAdd((volatile signed __int32 *)P + 2, 1u);
        v8 = (void **)off_2B148;
      }
      if ( v8 != &off_2B148 && (*((_BYTE *)v8 + 236) & 0x20) != 0 && *((_BYTE *)v8 + 233) >= 5u )
        sub_11008((__int64)v8[27], 0x14u, (__int64)&unk_29D08);
      v7 = sub_132E8(a2, a5);
      if ( *a5 != 1 )
      {
        v11 = dword_31DD4;
        if ( (unsigned int)dword_31DD4 > 3 )
        {
          _InterlockedAdd((volatile signed __int32 *)P + 3, 1u);
          v11 = dword_31DD4;
        }
        if ( v11 > 5 )
          _InterlockedAdd((volatile signed __int32 *)P + 5, 1u);
      }
    }
    else
    {
      if ( v9 > 1 )
      {
        _InterlockedAdd((volatile signed __int32 *)P + 1, 1u);
        v8 = (void **)off_2B148;
      }
      if ( v8 != &off_2B148 && (*((_BYTE *)v8 + 236) & 0x20) != 0 && *((_BYTE *)v8 + 233) >= 5u )
        sub_11008((__int64)v8[27], 0x13u, (__int64)&unk_29D08);
      v7 = sub_12D44(a2, a5);
      if ( *a5 != 1 )
      {
        v10 = dword_31DD4;
        if ( (unsigned int)dword_31DD4 > 3 )
        {
          _InterlockedAdd((volatile signed __int32 *)P + 3, 1u);
          v10 = dword_31DD4;
        }
        if ( v10 > 4 )
          _InterlockedAdd((volatile signed __int32 *)P + 4, 1u);
      }
    }
    v8 = (void **)off_2B148;
  }
  if ( v8 != &off_2B148 && (*((_BYTE *)v8 + 236) & 0x20) != 0 && *((_BYTE *)v8 + 233) >= 5u )
    sub_11008((__int64)v8[27], 0x16u, (__int64)&unk_29D08);
  return v7;
}
// 2B148: using guessed type void *off_2B148;
// 31DD4: using guessed type int dword_31DD4;

//----- (0000000000012BB8) ----------------------------------------------------
__int64 __fastcall sub_12BB8(int a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5)
{
  void **v7; // rcx

  *a5 = 1;
  v7 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 0x20) != 0 && *((_BYTE *)off_2B148 + 233) >= 5u )
  {
    sub_11C28(*((_QWORD *)off_2B148 + 27), 0x17u, (__int64)&unk_29D08, a1);
    v7 = (void **)off_2B148;
  }
  if ( !*(_DWORD *)Dst || !a2 )
    goto LABEL_21;
  if ( (unsigned int)dword_31DD4 > 6 )
  {
    _InterlockedAdd((volatile signed __int32 *)P + 6, 1u);
    v7 = (void **)off_2B148;
  }
  if ( v7 != &off_2B148 && (*((_BYTE *)v7 + 236) & 0x20) != 0 && *((_BYTE *)v7 + 233) >= 5u )
    sub_11008((__int64)v7[27], 0x18u, (__int64)&unk_29D08);
  *a5 = 1;
  if ( !(unsigned int)sub_17418(a2, a5) )
    goto LABEL_20;
  if ( (unsigned int)dword_31DD4 > 7 )
    _InterlockedAdd((volatile signed __int32 *)P + 7, 1u);
  v7 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 236) & 2) == 0 || *((_BYTE *)off_2B148 + 233) < 4u )
    {
LABEL_21:
      if ( v7 != &off_2B148 && (*((_BYTE *)v7 + 236) & 0x20) != 0 && *((_BYTE *)v7 + 233) >= 5u )
        sub_11008((__int64)v7[27], 0x19u, (__int64)&unk_29D08);
      return 0i64;
    }
    sub_11008(*((_QWORD *)off_2B148 + 27), 0x1Au, (__int64)&unk_29D08);
LABEL_20:
    v7 = (void **)off_2B148;
    goto LABEL_21;
  }
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;
// 31DD4: using guessed type int dword_31DD4;

//----- (0000000000012D44) ----------------------------------------------------
__int64 __fastcall sub_12D44(__int64 a1, _DWORD *a2)
{
  bool v4; // zf
  const char *v5; // rsi
  _BYTE *v6; // rdi
  __int64 v7; // rbp
  int v8; // eax
  void **v9; // rcx
  int v10; // eax
  int v11; // eax
  int v12; // eax
  _WORD *v13; // rcx
  int v14; // eax
  int v15; // eax
  int v17; // eax
  __int16 v19; // [rsp+20h] [rbp-88h] BYREF
  __int64 v20; // [rsp+28h] [rbp-80h]
  int v21; // [rsp+30h] [rbp-78h] BYREF
  int v22; // [rsp+34h] [rbp-74h] BYREF
  int v23; // [rsp+38h] [rbp-70h] BYREF
  __int64 Dst[7]; // [rsp+40h] [rbp-68h] BYREF
  int v25; // [rsp+7Ch] [rbp-2Ch]

  memset(Dst, 0, 0x30ui64);
  v4 = (*(_BYTE *)(a1 + 120) & 8) == 0;
  v5 = "NONE";
  v20 = 0i64;
  if ( !v4 )
  {
    Dst[6] = 0i64;
    v20 = 0i64;
  }
  v6 = *(_BYTE **)(a1 + 16);
  v23 = 1;
  Dst[0] = (__int64)v6;
  if ( v6 )
  {
    v7 = *(_QWORD *)(a1 + 40);
    Dst[1] = v7;
    if ( v7 )
    {
      if ( dword_31D9C )
      {
        v8 = sub_15630((__int64)&v23, a1);
        v7 = Dst[1];
        v6 = (_BYTE *)Dst[0];
      }
      else
      {
        v8 = 0;
      }
      if ( v8 )
      {
        if ( (unsigned int)dword_31DD4 > 0x13 )
          _InterlockedAdd((volatile signed __int32 *)P + 19, 1u);
        v5 = "IP explicit path";
      }
      else
      {
        if ( *((_DWORD *)::Dst + 26) )
        {
          if ( dword_31DA0 )
          {
            sub_1DB60(v7, &v22);
            sub_1DC10(v7, &v21);
            if ( v22 == v21 )
            {
              sub_14070(a1, 2);
              v9 = (void **)off_2B148;
              if ( off_2B148 != &off_2B148
                && (*((_BYTE *)off_2B148 + 236) & 2) != 0
                && *((_BYTE *)off_2B148 + 233) >= 4u )
              {
                sub_11008(*((_QWORD *)off_2B148 + 27), 0xAu, (__int64)&unk_29CA8);
                v9 = (void **)off_2B148;
              }
              v23 = 4;
              if ( (unsigned int)dword_31DD4 > 0x15 )
              {
                _InterlockedAdd((volatile signed __int32 *)P + 21, 1u);
                v9 = (void **)off_2B148;
              }
              v5 = "Land Attack";
LABEL_93:
              if ( v9 != &off_2B148 && (*((_BYTE *)v9 + 236) & 2) != 0 && *((_BYTE *)v9 + 233) >= 4u )
                sub_11DF8((__int64)v9[27], 0x1Bu, (__int64)&unk_29D08, v5);
              goto LABEL_97;
            }
          }
        }
        Dst[3] = *(_QWORD *)(a1 + 56);
        if ( Dst[3] )
        {
          if ( dword_31D78 )
            v10 = sub_14FF0((__int64)&v23);
          else
            v10 = 0;
          if ( v10 )
          {
            if ( (unsigned int)dword_31DD4 > 9 )
              _InterlockedAdd((volatile signed __int32 *)P + 9, 1u);
            v5 = "SYN Flood";
          }
          else
          {
            if ( *((_DWORD *)::Dst + 43) )
              v11 = sub_16FC8((__int64)&v23, a1);
            else
              v11 = 0;
            if ( v11 )
            {
              if ( (unsigned int)dword_31DD4 > 0xC )
                _InterlockedAdd((volatile signed __int32 *)P + 12, 1u);
              v5 = "TCP PortScan";
            }
            else
            {
              if ( dword_31D8C )
                v12 = sub_1540C((__int64)&v23, a1);
              else
                v12 = 0;
              if ( v12 )
              {
                if ( (unsigned int)dword_31DD4 > 0xE )
                  _InterlockedAdd((volatile signed __int32 *)P + 14, 1u);
                v5 = "TCP Flags check";
              }
              else if ( (unsigned int)sub_16354((__int64)&v23, a1) )
              {
                if ( (unsigned int)dword_31DD4 > 0x12 )
                  _InterlockedAdd((volatile signed __int32 *)P + 18, 1u);
                v5 = "Header lengths";
              }
            }
          }
        }
        else
        {
          v13 = *(_WORD **)(a1 + 64);
          Dst[4] = (__int64)v13;
          if ( v13 )
          {
            if ( dword_31D88 )
            {
              v14 = sub_15364((__int64)&v23);
              v13 = (_WORD *)Dst[4];
            }
            else
            {
              v14 = 0;
            }
            if ( v14 )
            {
              if ( (unsigned int)dword_31DD4 > 0xA )
                _InterlockedAdd((volatile signed __int32 *)P + 10, 1u);
              v5 = "UDP FLood";
            }
            else
            {
              if ( *((_DWORD *)::Dst + 10) )
              {
                v15 = sub_15DA0((__int64)&v23, a1);
                v13 = (_WORD *)Dst[4];
              }
              else
              {
                v15 = 0;
              }
              if ( v15 )
              {
                if ( (unsigned int)dword_31DD4 > 0xD )
                  _InterlockedAdd((volatile signed __int32 *)P + 13, 1u);
                v5 = "UDP PortScan";
              }
              else if ( dword_31DA4
                     && *((_DWORD *)::Dst + 27)
                     && !(unsigned int)sub_1ECFC(v13, &v19)
                     && v19 == 53
                     && (unsigned int)sub_158C0((__int64)&v23) )
              {
                if ( off_2B148 != &off_2B148
                  && (*((_BYTE *)off_2B148 + 236) & 2) != 0
                  && *((_BYTE *)off_2B148 + 233) >= 4u )
                {
                  sub_11008(*((_QWORD *)off_2B148 + 27), 0xBu, (__int64)&unk_29C98);
                }
                sub_14070(a1, 11);
                v23 = 4;
                if ( (unsigned int)dword_31DD4 > 0x10 )
                  _InterlockedAdd((volatile signed __int32 *)P + 16, 1u);
                v5 = "Smart DNS";
              }
            }
          }
          else
          {
            Dst[5] = (__int64)sub_1CFE4(v6, 6);
            if ( Dst[5] )
            {
              if ( dword_31DB8 ? (unsigned int)sub_165C8((__int64)&v23, a1) : 0 )
              {
                if ( (unsigned int)dword_31DD4 > 0xB )
                  _InterlockedAdd((volatile signed __int32 *)P + 11, 1u);
                v5 = "ICMP Attack";
              }
            }
          }
        }
      }
    }
    else
    {
      Dst[2] = (__int64)sub_1CFE4(v6, 7);
      if ( !Dst[2] )
        goto LABEL_97;
      if ( *((_DWORD *)::Dst + 40) )
        v17 = sub_16A58((__int64)&v23, a1);
      else
        v17 = 0;
      if ( v17 )
      {
        if ( (unsigned int)dword_31DD4 > 8 )
          _InterlockedAdd((volatile signed __int32 *)P + 8, 1u);
        v5 = "Smart ARP";
      }
    }
    if ( v23 == 1 )
      goto LABEL_97;
    v9 = (void **)off_2B148;
    goto LABEL_93;
  }
LABEL_97:
  sub_136F4(a1, v23);
  if ( (*(_BYTE *)(a1 + 120) & 8) != 0 )
  {
    v25 = 0;
    if ( (unsigned int)dword_31DD4 > 0x17 )
      *((_DWORD *)P + 23) = -(int)v20;
  }
  *a2 = v23;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 5u )
    sub_11B10(*((_QWORD *)off_2B148 + 27), 0x1Cu, (__int64)&unk_29D08, 0);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;
// 31D78: using guessed type int dword_31D78;
// 31D88: using guessed type int dword_31D88;
// 31D8C: using guessed type int dword_31D8C;
// 31D9C: using guessed type int dword_31D9C;
// 31DA0: using guessed type int dword_31DA0;
// 31DA4: using guessed type int dword_31DA4;
// 31DB8: using guessed type int dword_31DB8;
// 31DD4: using guessed type int dword_31DD4;

//----- (00000000000132E8) ----------------------------------------------------
__int64 __fastcall sub_132E8(__int64 a1, _DWORD *a2)
{
  bool v4; // zf
  const char *v5; // rbp
  _BYTE *v6; // rcx
  __int64 v7; // rsi
  _WORD *v8; // rdi
  __int64 v10; // r8
  int v11; // eax
  _BYTE *v12; // rcx
  int v13; // eax
  _DWORD *v14; // rax
  int v15; // eax
  int v16; // er11
  __int16 *v17; // rax
  __int64 v18; // rdi
  int v19; // [rsp+20h] [rbp-98h] BYREF
  __int64 v20; // [rsp+28h] [rbp-90h]
  __int64 v21; // [rsp+30h] [rbp-88h]
  int v22; // [rsp+3Ch] [rbp-7Ch]
  int v23; // [rsp+40h] [rbp-78h] BYREF
  __int64 Dst[6]; // [rsp+48h] [rbp-70h] BYREF
  char v25; // [rsp+C0h] [rbp+8h] BYREF
  char v26; // [rsp+C8h] [rbp+10h] BYREF
  __int16 v27; // [rsp+D0h] [rbp+18h] BYREF
  __int16 v28; // [rsp+D8h] [rbp+20h] BYREF

  memset(Dst, 0, sizeof(Dst));
  v4 = (*(_BYTE *)(a1 + 120) & 8) == 0;
  v5 = "NONE";
  v20 = 0i64;
  if ( !v4 )
  {
    v21 = 0i64;
    v20 = 0i64;
  }
  v6 = *(_BYTE **)(a1 + 16);
  v23 = 1;
  Dst[0] = (__int64)v6;
  if ( v6 )
  {
    v7 = *(_QWORD *)(a1 + 40);
    Dst[1] = v7;
    if ( !v7 )
    {
      v17 = (__int16 *)sub_1CFE4(v6, 7);
      v18 = (__int64)v17;
      if ( !v17 || !*((_DWORD *)::Dst + 40) || !(unsigned __int8)sub_1F4A8(v17) )
        goto LABEL_11;
      sub_16CF4(v18);
      goto LABEL_59;
    }
    v8 = *(_WORD **)(a1 + 56);
    Dst[3] = (__int64)v8;
    if ( v8 )
    {
      if ( *((_DWORD *)::Dst + 43) )
      {
        if ( dword_31DCC )
        {
          sub_1EC4C((__int64)v8, &v25);
          if ( v25 == 24 || v25 == 16 )
          {
            sub_1DC10(v7, &v19);
            sub_1EA14(v8, &v27);
            sub_17154(v19, v27);
          }
        }
      }
      goto LABEL_11;
    }
    v10 = *(_QWORD *)(a1 + 64);
    Dst[4] = v10;
    if ( v10 )
    {
      if ( dword_31DA4 && *((_DWORD *)::Dst + 27) && !(unsigned int)sub_1EDC0(v10, &v28) && v28 == 53 )
        sub_157E8((__int64)&v23);
      if ( *((_DWORD *)::Dst + 10) )
        v11 = sub_15EE4((__int64)&v23, a1);
      else
        v11 = 0;
      if ( !v11 )
        goto LABEL_59;
    }
    else
    {
      v12 = sub_1CFE4(v6, 6);
      Dst[5] = (__int64)v12;
      if ( !v12 )
        goto LABEL_11;
      if ( dword_31DB8 )
      {
        v13 = sub_1684C((__int64)&v23);
        v12 = (_BYTE *)Dst[5];
      }
      else
      {
        v13 = 0;
      }
      if ( v13 )
      {
        if ( (unsigned int)dword_31DD4 > 0xB )
          _InterlockedAdd((volatile signed __int32 *)P + 11, 1u);
        v5 = "ICMP";
        goto LABEL_59;
      }
      v14 = ::Dst;
      if ( *((_DWORD *)::Dst + 10) )
      {
        v15 = sub_15EE4((__int64)&v23, a1);
        v12 = (_BYTE *)Dst[5];
        v16 = v15;
        v14 = ::Dst;
      }
      else
      {
        v16 = 0;
      }
      if ( !v16 )
      {
        if ( dword_31DAC )
        {
          if ( v14[29] )
          {
            sub_1EE84(v12, &v26);
            if ( v26 == 14 || v26 == 16 )
            {
              if ( off_2B148 != &off_2B148
                && (*((_BYTE *)off_2B148 + 236) & 2) != 0
                && *((_BYTE *)off_2B148 + 233) >= 4u )
              {
                sub_11008(*((_QWORD *)off_2B148 + 27), 0xAu, (__int64)&unk_29C78);
              }
              sub_14070(a1, 14);
              v23 = 4;
              if ( (unsigned int)dword_31DD4 > 0x16 )
                _InterlockedAdd((volatile signed __int32 *)P + 22, 1u);
              v5 = "OS Detection";
            }
          }
        }
        goto LABEL_59;
      }
    }
    if ( (unsigned int)dword_31DD4 > 0xD )
      _InterlockedAdd((volatile signed __int32 *)P + 13, 1u);
    v5 = "UDP PortScan";
LABEL_59:
    if ( v23 != 1
      && off_2B148 != &off_2B148
      && (*((_BYTE *)off_2B148 + 236) & 2) != 0
      && *((_BYTE *)off_2B148 + 233) >= 4u )
    {
      sub_11DF8(*((_QWORD *)off_2B148 + 27), 0x1Du, (__int64)&unk_29D08, v5);
    }
  }
LABEL_11:
  sub_136F4(a1, v23);
  if ( (*(_BYTE *)(a1 + 120) & 8) != 0 )
  {
    v22 = 0;
    if ( (unsigned int)dword_31DD4 > 0x17 )
      *((_DWORD *)P + 23) = -(int)v20;
  }
  *a2 = v23;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 5u )
    sub_11B10(*((_QWORD *)off_2B148 + 27), 0x1Eu, (__int64)&unk_29D08, 0);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;
// 31DA4: using guessed type int dword_31DA4;
// 31DAC: using guessed type int dword_31DAC;
// 31DB8: using guessed type int dword_31DB8;
// 31DCC: using guessed type int dword_31DCC;
// 31DD4: using guessed type int dword_31DD4;

//----- (00000000000136F4) ----------------------------------------------------
__int64 __fastcall sub_136F4(__int64 a1, int a2)
{
  int v3; // edx
  int v4; // edx
  int v5; // edx
  __int64 result; // rax
  char v7[64]; // [rsp+30h] [rbp-58h] BYREF

  if ( (*(_BYTE *)(a1 + 120) & 4) != 0 )
  {
    v3 = a2 - 1;
    if ( v3 )
    {
      v4 = v3 - 1;
      if ( v4 )
      {
        v5 = v4 - 1;
        if ( v5 )
        {
          if ( v5 == 1 )
            sub_270F8(v7, 0x40ui64, "|IDS-%I64u-S_DENY-filter:%s|");
          else
            sub_270F8(v7, 0x40ui64, "|IDS-%I64u-OTHER_AUTH-filter:%s|");
        }
        else
        {
          sub_270F8(v7, 0x40ui64, "|IDS-%I64u-S_ALLOW-filter:%s|");
        }
      }
      else
      {
        sub_270F8(v7, 0x40ui64, "|IDS-%I64u-W_DENY-filter:%s|");
      }
    }
    else
    {
      sub_270F8(v7, 0x40ui64, "|IDS-%I64u-W_ALLOW-filter:%s|");
    }
    result = sub_237B8(a1, v7, strlen(v7));
  }
  return result;
}

//----- (00000000000137B8) ----------------------------------------------------
void sub_137B8()
{
  _QWORD *v0; // rax

  if ( *(_DWORD *)Dst )
  {
    v0 = sub_18A88();
    if ( v0 )
    {
      sub_18BF4((__int64)v0);
    }
    else if ( off_2B148 != &off_2B148
           && _bittest((const signed __int32 *)off_2B148 + 43, 0xEu)
           && *((_BYTE *)off_2B148 + 169) >= 2u )
    {
      sub_11008(*((_QWORD *)off_2B148 + 19), 0x1Fu, (__int64)&unk_29D08);
    }
  }
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000013858) ----------------------------------------------------
void sub_13858()
{
  _QWORD *v0; // rdi
  __int64 v1; // rbp
  _QWORD *v2; // rsi
  _QWORD *v3; // rcx
  _DWORD *v4; // rax
  _WORD *v5; // rdx
  __int64 v6; // r8
  bool v7; // zf
  _QWORD *v8; // rbx
  __int64 v9; // rbx
  __int64 *v10; // rcx
  __int64 v11; // rbx
  __int64 *v12; // rcx
  __int64 v13; // rbx
  __int64 *v14; // rdx
  __int64 v15; // rcx
  __int64 *v16; // rax
  __int64 v17; // rbx
  __int64 *v18; // rcx
  __int64 v19; // rbx
  __int64 *v20; // rcx
  volatile __int32 *v21; // rcx
  unsigned int v22; // ebx
  __int64 v23; // rdi
  unsigned __int32 v24; // er8
  int v25; // eax
  int v26; // er8
  __int64 v27; // rbx
  __int64 *v28; // rdi
  __int64 *v29; // rcx

  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 4) != 0 && *((_BYTE *)off_2B148 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0x20u, (__int64)&unk_29D08);
  sub_16004();
  if ( *((_DWORD *)Dst + 43) && dword_31DCC )
  {
    sub_188F0(&FastMutex);
    v0 = qword_30D00;
    v1 = 256i64;
    v2 = qword_30D00;
    do
    {
      if ( (_QWORD *)*v0 != v0 )
      {
        v3 = (_QWORD *)v0[1];
        if ( v3 != v2 )
        {
          do
          {
            v4 = (_DWORD *)v3 + 23;
            v5 = (_WORD *)v3 + 14;
            v6 = 32i64;
            do
            {
              if ( *v5 )
              {
                v7 = (*v4)-- == 1;
                if ( v7 )
                {
                  --*((_DWORD *)v3 + 6);
                  *v5 = 0;
                  *v4 = 0;
                }
              }
              ++v5;
              ++v4;
              --v6;
            }
            while ( v6 );
            v8 = (_QWORD *)v3[1];
            if ( !*((_DWORD *)v3 + 6) )
              sub_1737C(v3);
            v3 = v8;
          }
          while ( v8 != v2 );
        }
      }
      v2 += 2;
      v0 += 2;
      --v1;
    }
    while ( v1 );
    sub_189BC(&FastMutex);
  }
  sub_150E0();
  if ( dword_31DB8 )
  {
    sub_188F0(&stru_2FBC8);
    v9 = qword_30C00;
    while ( (__int64 *)v9 != &qword_30C00 )
    {
      v7 = (*(_DWORD *)(v9 + 28))-- == 1;
      if ( v7 )
      {
        v10 = (__int64 *)v9;
        v9 = *(_QWORD *)v9;
        sub_16954(v10);
      }
      else
      {
        v9 = *(_QWORD *)v9;
      }
    }
    dword_2BAE4 = 0;
    if ( dword_30C14 )
    {
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
        sub_11B10(*((_QWORD *)off_2B148 + 27), 0xEu, (__int64)&unk_29C48, dword_30C14);
      sub_13E6C(15);
      dword_30C14 = 0;
    }
    if ( dword_30C10 )
    {
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
        sub_11B10(*((_QWORD *)off_2B148 + 27), 0xFu, (__int64)&unk_29C48, dword_30C10);
      sub_13E6C(18);
      dword_30C10 = 0;
    }
    sub_189BC(&stru_2FBC8);
  }
  if ( dword_31DA4 )
  {
    sub_188F0(&stru_2BB50);
    v11 = qword_2BB40;
    while ( (__int64 *)v11 != &qword_2BB40 )
    {
      v7 = (*(_DWORD *)(v11 + 32))-- == 1;
      if ( v7 )
      {
        v12 = (__int64 *)v11;
        v11 = *(_QWORD *)v11;
        sub_157AC(v12);
      }
      else
      {
        v11 = *(_QWORD *)v11;
      }
    }
    sub_189BC(&stru_2BB50);
  }
  if ( dword_31DBC )
  {
    sub_188F0(&stru_30C20);
    v13 = qword_30C58;
    while ( (__int64 *)v13 != &qword_30C58 )
    {
      v7 = (*(_DWORD *)(v13 + 24))-- == 1;
      if ( v7 )
      {
        v14 = (__int64 *)v13;
        v13 = *(_QWORD *)v13;
        if ( v14 )
        {
          v15 = *v14;
          v16 = (__int64 *)v14[1];
          *v16 = *v14;
          *(_QWORD *)(v15 + 8) = v16;
          sub_180A0(qword_30C68, (__int64)v14);
        }
      }
      else
      {
        v13 = *(_QWORD *)v13;
      }
    }
    sub_189BC(&stru_30C20);
  }
  if ( dword_31D98 )
  {
    sub_188F0(&stru_2BAF8);
    v17 = qword_2BAE8;
    while ( (__int64 *)v17 != &qword_2BAE8 )
    {
      v7 = (*(_DWORD *)(v17 + 32))-- == 1;
      if ( v7 )
      {
        v18 = (__int64 *)v17;
        v17 = *(_QWORD *)v17;
        sub_155F4(v18);
      }
      else
      {
        v17 = *(_QWORD *)v17;
      }
    }
    sub_189BC(&stru_2BAF8);
  }
  sub_188F0(&stru_30C80);
  v19 = qword_30C70;
  dword_30CB8 = 0;
  while ( (__int64 *)v19 != &qword_30C70 )
  {
    v7 = (*(_DWORD *)(v19 + 32))-- == 1;
    if ( v7 )
    {
      v20 = (__int64 *)v19;
      v19 = *(_QWORD *)v19;
      sub_16CB8(v20);
    }
    else
    {
      v19 = *(_QWORD *)v19;
    }
  }
  sub_189BC(&stru_30C80);
  if ( ++dword_31D7C == *((_DWORD *)Dst + 21) )
  {
    v21 = (volatile __int32 *)qword_31D80;
    dword_31D7C = 0;
    if ( qword_31D80 )
    {
      v22 = 0;
      v23 = 0i64;
      do
      {
        if ( v21[v23] )
        {
          v24 = _InterlockedExchange(&v21[v22], 0);
          if ( v24 > *((_DWORD *)Dst + 22) )
          {
            if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
              sub_11D0C(*((_QWORD *)off_2B148 + 27), 0xBu, (__int64)&unk_29CE8, v22);
            sub_13E6C(8);
          }
          v21 = (volatile __int32 *)qword_31D80;
        }
        ++v22;
        ++v23;
      }
      while ( v22 < 0x10000 );
    }
  }
  if ( byte_31D61 && dword_31DA8 )
  {
    if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
      sub_11B10(*((_QWORD *)off_2B148 + 27), 0xDu, (__int64)&unk_29C88, dword_31DA8);
    sub_13E6C(16);
  }
  sub_159A8();
  v25 = dword_31D90;
  dword_31DA8 = 0;
  if ( dword_31D90 )
  {
    v26 = dword_31D94;
    if ( dword_31D94 )
    {
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
      {
        sub_11B10(*((_QWORD *)off_2B148 + 27), 0xDu, (__int64)&unk_29CD8, dword_31D94);
        v25 = dword_31D90;
        v26 = dword_31D94;
      }
      dword_31D90 = v26 + v25;
    }
  }
  sub_15530();
  dword_31D94 = 0;
  sub_188F0(&stru_31D00);
  v27 = MEMORY[0xFFFFF78000000014];
  v28 = (__int64 *)qword_31D38;
  while ( v28 != &qword_31D38 )
  {
    v29 = v28;
    v28 = (__int64 *)*v28;
    if ( v29[6] + 300000000 < v27 )
      sub_17A14(v29);
  }
  sub_189BC(&stru_31D00);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 4) != 0 && *((_BYTE *)off_2B148 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0x21u, (__int64)&unk_29D08);
}
// 2B148: using guessed type void *off_2B148;
// 2BAE4: using guessed type int dword_2BAE4;
// 2BAE8: using guessed type __int64 qword_2BAE8;
// 2BB40: using guessed type __int64 qword_2BB40;
// 30C00: using guessed type __int64 qword_30C00;
// 30C10: using guessed type int dword_30C10;
// 30C14: using guessed type int dword_30C14;
// 30C58: using guessed type __int64 qword_30C58;
// 30C68: using guessed type __int64 qword_30C68;
// 30C70: using guessed type __int64 qword_30C70;
// 30CB8: using guessed type int dword_30CB8;
// 31D38: using guessed type __int64 qword_31D38;
// 31D61: using guessed type char byte_31D61;
// 31D7C: using guessed type int dword_31D7C;
// 31D90: using guessed type int dword_31D90;
// 31D94: using guessed type int dword_31D94;
// 31D98: using guessed type int dword_31D98;
// 31DA4: using guessed type int dword_31DA4;
// 31DA8: using guessed type int dword_31DA8;
// 31DB8: using guessed type int dword_31DB8;
// 31DBC: using guessed type int dword_31DBC;
// 31DCC: using guessed type int dword_31DCC;

//----- (0000000000013E6C) ----------------------------------------------------
__int64 __fastcall sub_13E6C(int a1)
{
  void **v2; // rcx
  unsigned __int16 v3; // dx
  int v5; // eax
  unsigned int v6; // ebx
  void **v7; // rcx
  int v8[4]; // [rsp+20h] [rbp-88h] BYREF
  __int64 Dst[10]; // [rsp+30h] [rbp-78h] BYREF
  int v10; // [rsp+84h] [rbp-24h]
  int v11; // [rsp+88h] [rbp-20h]

  LODWORD(Dst[0]) = 0;
  memset((char *)Dst + 4, 0, 0x58ui64);
  v8[0] = 0;
  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 8) != 0 && *((_BYTE *)off_2B148 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 27), 0x22u, (__int64)&unk_29D08);
    v2 = (void **)off_2B148;
  }
  if ( !*((_DWORD *)::Dst + 2) )
  {
    if ( v2 == &off_2B148 || (*((_BYTE *)v2 + 236) & 8) == 0 || *((_BYTE *)v2 + 233) < 5u )
      return 0i64;
    v3 = 35;
LABEL_10:
    sub_11008((__int64)v2[27], v3, (__int64)&unk_29D08);
    return 0i64;
  }
  if ( sub_14CBC(a1, v8) )
  {
    v2 = (void **)off_2B148;
    if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 236) & 8) == 0 || *((_BYTE *)off_2B148 + 233) < 5u )
      return 0i64;
    v3 = 36;
    goto LABEL_10;
  }
  v10 = a1;
  v11 = v8[0];
  Dst[0] = MEMORY[0xFFFFF78000000014];
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 8) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0x25u, (__int64)&unk_29D08);
  v5 = sub_23200(40018i64, Dst);
  v6 = v5;
  if ( !v5 )
    goto LABEL_26;
  v7 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 236) & 8) == 0 || *((_BYTE *)off_2B148 + 233) < 2u )
    {
LABEL_27:
      if ( v7 != &off_2B148 && (*((_BYTE *)v7 + 236) & 8) != 0 && *((_BYTE *)v7 + 233) >= 5u )
        sub_11008((__int64)v7[27], 0x27u, (__int64)&unk_29D08);
      return v6;
    }
    sub_11B10(*((_QWORD *)off_2B148 + 27), 0x26u, (__int64)&unk_29D08, v5);
LABEL_26:
    v7 = (void **)off_2B148;
    goto LABEL_27;
  }
  return v6;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000014070) ----------------------------------------------------
__int64 __fastcall sub_14070(__int64 a1, int a2)
{
  void **v4; // rcx
  unsigned __int16 v5; // dx
  unsigned int v7; // ebx
  void **v8; // rcx
  unsigned __int16 v9; // dx
  int v10; // eax
  int v11[4]; // [rsp+20h] [rbp-98h] BYREF
  int v12; // [rsp+30h] [rbp-88h] BYREF
  int Dst[22]; // [rsp+34h] [rbp-84h] BYREF

  v12 = 0;
  memset(Dst, 0, sizeof(Dst));
  v11[0] = 0;
  v4 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 8) != 0 && *((_BYTE *)off_2B148 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 27), 0x28u, (__int64)&unk_29D08);
    v4 = (void **)off_2B148;
  }
  if ( !*((_DWORD *)::Dst + 2) )
  {
    if ( v4 == &off_2B148 || (*((_BYTE *)v4 + 236) & 8) == 0 || *((_BYTE *)v4 + 233) < 5u )
      return 0i64;
    v5 = 41;
LABEL_10:
    sub_11008((__int64)v4[27], v5, (__int64)&unk_29D08);
    return 0i64;
  }
  if ( sub_14CBC(a2, v11) )
  {
    v4 = (void **)off_2B148;
    if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 236) & 8) == 0 || *((_BYTE *)off_2B148 + 233) < 5u )
      return 0i64;
    v5 = 42;
    goto LABEL_10;
  }
  Dst[21] = v11[0];
  Dst[20] = a2;
  v7 = sub_144E8(a1, (__int64)&v12);
  if ( v7 )
  {
    v8 = (void **)off_2B148;
    if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 236) & 8) == 0 || *((_BYTE *)off_2B148 + 233) < 2u )
      return v7;
    v9 = 43;
    goto LABEL_36;
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 8) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0x2Cu, (__int64)&unk_29D08);
  v10 = sub_23200(40018i64, &v12);
  v7 = v10;
  if ( !v10 )
    goto LABEL_31;
  v8 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 236) & 8) == 0 || *((_BYTE *)off_2B148 + 233) < 2u )
      goto LABEL_32;
    sub_11B10(*((_QWORD *)off_2B148 + 27), 0x2Du, (__int64)&unk_29D08, v10);
LABEL_31:
    v8 = (void **)off_2B148;
LABEL_32:
    if ( v8 == &off_2B148 || (*((_BYTE *)v8 + 236) & 8) == 0 || *((_BYTE *)v8 + 233) < 5u )
      return v7;
    v9 = 46;
LABEL_36:
    sub_11008((__int64)v8[27], v9, (__int64)&unk_29D08);
  }
  return v7;
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000142A8) ----------------------------------------------------
__int64 __fastcall sub_142A8(__int64 a1)
{
  void **v2; // rcx
  unsigned __int16 v3; // dx
  unsigned int v5; // ebx
  void **v6; // rcx
  unsigned __int16 v7; // dx
  int v8; // eax
  int v9[4]; // [rsp+20h] [rbp-88h] BYREF
  int v10; // [rsp+30h] [rbp-78h] BYREF
  int Dst[22]; // [rsp+34h] [rbp-74h] BYREF

  v10 = 0;
  memset(Dst, 0, sizeof(Dst));
  v9[0] = 0;
  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 8) != 0 && *((_BYTE *)off_2B148 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 27), 0x2Fu, (__int64)&unk_29D08);
    v2 = (void **)off_2B148;
  }
  if ( !*((_DWORD *)::Dst + 2) )
  {
    if ( v2 == &off_2B148 || (*((_BYTE *)v2 + 236) & 8) == 0 || *((_BYTE *)v2 + 233) < 5u )
      return 0i64;
    v3 = 48;
LABEL_10:
    sub_11008((__int64)v2[27], v3, (__int64)&unk_29D08);
    return 0i64;
  }
  if ( sub_14CBC(19, v9) )
  {
    v2 = (void **)off_2B148;
    if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 236) & 8) == 0 || *((_BYTE *)off_2B148 + 233) < 5u )
      return 0i64;
    v3 = 49;
    goto LABEL_10;
  }
  Dst[21] = v9[0];
  Dst[20] = 19;
  v5 = sub_14BC8(a1, (__int64)&v10);
  if ( v5 )
  {
    v6 = (void **)off_2B148;
    if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 236) & 8) == 0 || *((_BYTE *)off_2B148 + 233) < 2u )
      return v5;
    v7 = 50;
    goto LABEL_36;
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 8) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0x33u, (__int64)&unk_29D08);
  v8 = sub_23200(40018i64, &v10);
  v5 = v8;
  if ( !v8 )
    goto LABEL_31;
  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 236) & 8) == 0 || *((_BYTE *)off_2B148 + 233) < 2u )
      goto LABEL_32;
    sub_11B10(*((_QWORD *)off_2B148 + 27), 0x34u, (__int64)&unk_29D08, v8);
LABEL_31:
    v6 = (void **)off_2B148;
LABEL_32:
    if ( v6 == &off_2B148 || (*((_BYTE *)v6 + 236) & 8) == 0 || *((_BYTE *)v6 + 233) < 5u )
      return v5;
    v7 = 53;
LABEL_36:
    sub_11008((__int64)v6[27], v7, (__int64)&unk_29D08);
  }
  return v5;
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000144E8) ----------------------------------------------------
__int64 __fastcall sub_144E8(__int64 a1, __int64 a2)
{
  int v2; // er15
  __int64 v4; // r12
  void **v5; // rcx
  _BYTE *v6; // rax
  __int64 v7; // rbx
  int v8; // edi
  void **v9; // r10
  _QWORD *v10; // rcx
  unsigned __int16 v11; // dx
  _BYTE *v12; // rax
  __int64 v13; // rbx
  _BYTE *v14; // rbx
  int v15; // eax
  unsigned int v16; // ebp
  void **v17; // rax
  int v18; // eax
  _WORD *v19; // rax
  __int64 v20; // rbx
  _QWORD *v21; // rcx
  unsigned __int16 v22; // dx
  _WORD *v23; // rax
  __int64 v24; // rbx
  __int64 v26; // [rsp+D0h] [rbp+8h]
  unsigned __int16 v27; // [rsp+E0h] [rbp+18h] BYREF
  unsigned int v28; // [rsp+E8h] [rbp+20h]

  v26 = a1;
  v2 = 0;
  v4 = a1;
  v27 = 0;
  v5 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 8) != 0 && *((_BYTE *)off_2B148 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 27), 0x36u, (__int64)&unk_29D08);
    v5 = (void **)off_2B148;
  }
  if ( v4 && a2 )
  {
    v6 = sub_1CFE4(*(_BYTE **)(v4 + 16), 1);
    v7 = (__int64)v6;
    if ( !v6 )
    {
      v12 = sub_1CFE4(*(_BYTE **)(v4 + 16), 2);
      v13 = (__int64)v12;
      if ( v12 )
      {
        if ( (unsigned int)sub_1E398((__int64)v12, (__m128i *)(a2 + 40)) )
        {
          if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 8) != 0 && *((_BYTE *)off_2B148 + 233) >= 2u )
            sub_11008(*((_QWORD *)off_2B148 + 27), 0x3Cu, (__int64)&unk_29D08);
        }
        else
        {
          *(_DWORD *)(a2 + 32) |= 2u;
        }
        if ( (unsigned int)sub_1E44C(v13, (__m128i *)(a2 + 56)) )
        {
          v10 = off_2B148;
          if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 8) != 0 && *((_BYTE *)off_2B148 + 233) >= 2u )
          {
            v11 = 61;
            goto LABEL_49;
          }
        }
        else
        {
          *(_DWORD *)(a2 + 32) |= 4u;
        }
      }
      else
      {
        v10 = off_2B148;
        if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 8) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
        {
          v11 = 62;
          goto LABEL_49;
        }
      }
LABEL_50:
      v14 = sub_1CFE4(*(_BYTE **)(v4 + 16), 0);
      if ( !v14
        && off_2B148 != &off_2B148
        && (*((_BYTE *)off_2B148 + 236) & 8) != 0
        && *((_BYTE *)off_2B148 + 233) >= 2u )
      {
        sub_11008(*((_QWORD *)off_2B148 + 27), 0x3Fu, (__int64)&unk_29D08);
      }
      v15 = sub_1D5A4((__int64)v14, a2 + 20);
      if ( v15 && off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 8) != 0 && *((_BYTE *)off_2B148 + 233) >= 2u )
        sub_11B10(*((_QWORD *)off_2B148 + 27), 0x40u, (__int64)&unk_29D08, v15);
      v16 = sub_1D65C((__int64)v14, a2 + 26);
      v28 = v16;
      if ( v16 )
      {
        v17 = (void **)off_2B148;
        if ( off_2B148 == &off_2B148 )
          goto LABEL_70;
        if ( (*((_BYTE *)off_2B148 + 236) & 8) == 0 || *((_BYTE *)off_2B148 + 233) < 2u )
        {
LABEL_66:
          if ( v17 != &off_2B148 && (*((_BYTE *)v17 + 236) & 8) != 0 && *((_BYTE *)v17 + 233) >= 5u )
          {
            sub_11B4C(*((_QWORD *)off_2B148 + 27), 66i64, (__int64)&unk_29D08, *(unsigned __int8 *)(a2 + 20));
            v16 = v28;
            v4 = v26;
          }
LABEL_70:
          sub_1D710((__int64)v14, &v27);
          v18 = 2048;
          if ( v27 != 2048 )
          {
            switch ( v27 )
            {
              case 0x806u:
                v18 = 2054;
                break;
              case 0x8035u:
                v18 = 32821;
                break;
              case 0x86DDu:
                v18 = 34525;
                break;
              default:
                v18 = 0;
                break;
            }
          }
          *(_DWORD *)(a2 + 32) |= 1u;
          *(_DWORD *)(a2 + 36) = v18;
          v19 = sub_1CFE4(*(_BYTE **)(v4 + 16), 3);
          v20 = (__int64)v19;
          if ( v19 )
          {
            sub_1EA14(v19, (_WORD *)(a2 + 76));
            sub_1EAD8(v20, (_WORD *)(a2 + 78));
            v21 = off_2B148;
            if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 236) & 8) == 0 || *((_BYTE *)off_2B148 + 233) < 5u )
              goto LABEL_89;
            v22 = 67;
          }
          else
          {
            v23 = sub_1CFE4(*(_BYTE **)(v4 + 16), 4);
            v24 = (__int64)v23;
            if ( !v23 )
            {
              if ( off_2B148 != &off_2B148
                && (*((_BYTE *)off_2B148 + 236) & 8) != 0
                && *((_BYTE *)off_2B148 + 233) >= 5u )
              {
                sub_11008(*((_QWORD *)off_2B148 + 27), 0x45u, (__int64)&unk_29D08);
              }
              goto LABEL_94;
            }
            sub_1ECFC(v23, (_WORD *)(a2 + 76));
            sub_1EDC0(v24, (_WORD *)(a2 + 78));
            v21 = off_2B148;
            if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 236) & 8) == 0 || *((_BYTE *)off_2B148 + 233) < 5u )
            {
LABEL_89:
              *(_DWORD *)(a2 + 32) |= 0x30u;
LABEL_94:
              LOBYTE(v2) = (*(_BYTE *)(v4 + 120) & 0x10) == 16;
              *(_DWORD *)(a2 + 16) = v2 + 1;
              *(_QWORD *)a2 = *(_QWORD *)(v4 + 8);
              if ( off_2B148 != &off_2B148
                && (*((_BYTE *)off_2B148 + 236) & 8) != 0
                && *((_BYTE *)off_2B148 + 233) >= 5u )
              {
                sub_11008(*((_QWORD *)off_2B148 + 27), 0x46u, (__int64)&unk_29D08);
              }
              return v16;
            }
            v22 = 68;
          }
          sub_11D0C(v21[27], v22, (__int64)&unk_29D08, *(unsigned __int16 *)(a2 + 76));
          goto LABEL_89;
        }
        sub_11B10(*((_QWORD *)off_2B148 + 27), 0x41u, (__int64)&unk_29D08, v16);
      }
      v17 = (void **)off_2B148;
      goto LABEL_66;
    }
    if ( (unsigned int)sub_1DB60((__int64)v6, (_DWORD *)(a2 + 40)) )
    {
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 8) != 0 && *((_BYTE *)off_2B148 + 233) >= 2u )
        sub_11008(*((_QWORD *)off_2B148 + 27), 0x38u, (__int64)&unk_29D08);
    }
    else
    {
      *(_DWORD *)(a2 + 32) |= 2u;
    }
    v8 = sub_1DC10(v7, (_DWORD *)(a2 + 56));
    if ( v8 )
    {
      v9 = (void **)off_2B148;
      if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 236) & 8) == 0 || *((_BYTE *)off_2B148 + 233) < 2u )
      {
LABEL_21:
        if ( !v8 && v9 != &off_2B148 && (*((_BYTE *)v9 + 236) & 8) != 0 && *((_BYTE *)v9 + 233) >= 5u )
          sub_11D54((__int64)v9[27], 58i64, (__int64)&unk_29D08, *(unsigned __int8 *)(a2 + 56));
        if ( (unsigned int)sub_1DAB0(v7, (_BYTE *)(a2 + 72)) )
        {
          v10 = off_2B148;
          if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 8) != 0 && *((_BYTE *)off_2B148 + 233) >= 2u )
          {
            v11 = 59;
LABEL_49:
            sub_11008(v10[27], v11, (__int64)&unk_29D08);
            goto LABEL_50;
          }
        }
        else
        {
          *(_DWORD *)(a2 + 32) |= 8u;
        }
        goto LABEL_50;
      }
      sub_11008(*((_QWORD *)off_2B148 + 27), 0x39u, (__int64)&unk_29D08);
    }
    else
    {
      *(_DWORD *)(a2 + 32) |= 4u;
    }
    v9 = (void **)off_2B148;
    goto LABEL_21;
  }
  if ( v5 != &off_2B148 && (*((_BYTE *)v5 + 236) & 8) != 0 && *((_BYTE *)v5 + 233) >= 2u )
    sub_11008((__int64)v5[27], 0x37u, (__int64)&unk_29D08);
  return 4i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000014BC8) ----------------------------------------------------
__int64 __fastcall sub_14BC8(__int64 a1, __int64 a2)
{
  void **v4; // rcx
  int v5; // eax
  __int64 result; // rax

  v4 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 8) != 0 && *((_BYTE *)off_2B148 + 233) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 27), 0x47u, (__int64)&unk_29D08);
    v4 = (void **)off_2B148;
  }
  if ( a1 && a2 )
  {
    v5 = *(_DWORD *)(a1 + 18);
    *(_DWORD *)(a2 + 32) |= 2u;
    *(_DWORD *)(a2 + 40) = v5;
    *(_QWORD *)a2 = *(_QWORD *)(a1 + 8);
    if ( v4 != &off_2B148 && (*((_BYTE *)v4 + 236) & 8) != 0 && *((_BYTE *)v4 + 233) >= 5u )
      sub_11008((__int64)v4[27], 0x49u, (__int64)&unk_29D08);
    result = 0i64;
  }
  else
  {
    if ( v4 != &off_2B148 && (*((_BYTE *)v4 + 236) & 8) != 0 && *((_BYTE *)v4 + 233) >= 2u )
      sub_11008((__int64)v4[27], 0x48u, (__int64)&unk_29D08);
    result = 4i64;
  }
  return result;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000014CBC) ----------------------------------------------------
char __fastcall sub_14CBC(int a1, _DWORD *a2)
{
  __int64 v3; // r12
  __int64 v4; // rbx
  char v5; // si
  void **v6; // rcx

  v3 = a1;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 8) != 0 && *((_BYTE *)off_2B148 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0x4Au, (__int64)&unk_29D08);
  v4 = MEMORY[0xFFFFF78000000014];
  if ( (MEMORY[0xFFFFF78000000014] - *((_QWORD *)&unk_348E0 + 2 * v3)) / 0x989680ui64 <= *((unsigned int *)Dst + 3) )
  {
    ++*((_DWORD *)&unk_348E0 + 4 * v3 + 2);
    v5 = 1;
    if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 8) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
      sub_11CA8(*((_QWORD *)off_2B148 + 27), 76i64, (__int64)&unk_29D08, v3);
    *a2 = *((_DWORD *)&unk_348E0 + 4 * v3 + 2);
    v6 = (void **)off_2B148;
  }
  else
  {
    v5 = 0;
    *a2 = ++*((_DWORD *)&unk_348E0 + 4 * v3 + 2);
    v6 = (void **)off_2B148;
    if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 8) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
    {
      sub_11D0C(*((_QWORD *)off_2B148 + 27), 0x4Bu, (__int64)&unk_29D08, v3);
      v6 = (void **)off_2B148;
    }
    *((_QWORD *)&unk_348E0 + 2 * v3) = v4;
    *((_DWORD *)&unk_348E0 + 4 * v3 + 2) = 0;
  }
  if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 236) & 8) != 0 && *((_BYTE *)v6 + 233) >= 5u )
    sub_11008((__int64)v6[27], 0x4Du, (__int64)&unk_29D08);
  return v5;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000014E9C) ----------------------------------------------------
__int64 __fastcall sub_14E9C(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+98h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2BAB8(a1, 43i64, a3, a2, &v5);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000014EFC) ----------------------------------------------------
__int64 sub_14EFC()
{
  unsigned int v0; // ebx
  __int64 v1; // rcx
  _DWORD *v2; // rax
  int v4; // [rsp+70h] [rbp+8h] BYREF

  v4 = 0;
  v0 = 1;
  v1 = *((unsigned int *)Dst + 37);
  LOBYTE(v1) = 8;
  v2 = sub_24184(v1, 0i64, 1i64, 1718839662i64, *((unsigned int *)Dst + 37), 2, 0, 0, 0, 0, &v4);
  qword_31D70 = v2;
  if ( v4 )
  {
    if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 1) != 0 && *((_BYTE *)off_2B148 + 233) >= 2u )
    {
      sub_11B10(*((_QWORD *)off_2B148 + 27), 0xAu, (__int64)&unk_29CF8, v4);
      v2 = qword_31D70;
    }
    v0 = 0;
    dword_31D78 = 0;
    if ( v2 )
    {
      sub_24410((__int64)v2);
      qword_31D70 = 0i64;
    }
  }
  else
  {
    dword_31D64 = 0;
    dword_31D68 = 0;
    dword_2BAE0 = 0;
  }
  dword_31D78 = v0;
  return v0;
}
// 2B148: using guessed type void *off_2B148;
// 2BAE0: using guessed type int dword_2BAE0;
// 31D64: using guessed type int dword_31D64;
// 31D68: using guessed type int dword_31D68;
// 31D78: using guessed type int dword_31D78;

//----- (0000000000014FF0) ----------------------------------------------------
__int64 __fastcall sub_14FF0(__int64 a1)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  unsigned __int8 v5; // [rsp+38h] [rbp+10h] BYREF
  int v6; // [rsp+40h] [rbp+18h] BYREF

  if ( !*((_DWORD *)Dst + 31) )
    return 0i64;
  sub_1EC4C(*(_QWORD *)(a1 + 32), &v5);
  if ( v5 != 2 )
  {
    if ( v5 == 16 || v5 == 4 || v5 == 1 )
    {
      v6 = 0;
      v4 = sub_152F8(a1);
      if ( v4 )
        sub_25648((__int64)qword_31D70, v4, 0i64, &v6);
    }
    return 0i64;
  }
  if ( !dword_31D64 )
  {
    v3 = sub_152F8(a1);
    if ( v3 )
      sub_25424((__int64)qword_31D70, v3, v3, 0i64);
    return 0i64;
  }
  if ( off_2B148 != &off_2B148 && (v5 & *((_BYTE *)off_2B148 + 236)) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0xBu, (__int64)&unk_29CF8);
  *(_DWORD *)a1 = 4;
  return 1i64;
}
// 2B148: using guessed type void *off_2B148;
// 31D64: using guessed type int dword_31D64;

//----- (00000000000150E0) ----------------------------------------------------
void sub_150E0()
{
  unsigned int v0; // edx
  unsigned int v1; // eax
  unsigned int v2; // ebx
  int v3; // er8
  int v4; // eax
  int v5; // [rsp+50h] [rbp+8h] BYREF

  if ( *((_DWORD *)Dst + 31) )
  {
    if ( byte_31D60 )
    {
      if ( (unsigned int)++dword_2BAE0 >= *((_DWORD *)Dst + 39) )
      {
        byte_31D60 = 0;
        dword_2BAE0 = 0;
      }
    }
    v0 = ++dword_31D68;
    if ( dword_31D6C )
      --dword_31D6C;
    if ( dword_31D64 )
      v1 = *((_DWORD *)Dst + 35) + *((_DWORD *)Dst + 36);
    else
      v1 = *((_DWORD *)Dst + 35);
    if ( v0 >= v1 )
    {
      v5 = 0;
      v2 = sub_250F0((__int64)qword_31D70, &v5);
      v3 = 2;
      if ( v2 < *((_DWORD *)Dst + 34) )
      {
        if ( dword_31D64 == 2 && !dword_31D6C )
        {
          dword_31D64 = 0;
          byte_31D60 = 0;
          dword_2BAE0 = 0;
        }
        if ( (unsigned int)sub_251E8(
                             (__int64)qword_31D70,
                             (unsigned int)(*((_DWORD *)Dst + 37) - *((_DWORD *)Dst + 32)),
                             *((unsigned int *)Dst + 37),
                             &v5) < *((_DWORD *)Dst + 33) )
        {
          v3 = dword_31D64;
          if ( dword_31D64 == 1 && !dword_31D6C )
          {
            v3 = 0;
            dword_31D64 = 0;
            byte_31D60 = 0;
            dword_2BAE0 = 0;
          }
        }
        else
        {
          v3 = 1;
          dword_31D6C = *((_DWORD *)Dst + 38);
          dword_31D64 = 1;
        }
      }
      else
      {
        v4 = *((_DWORD *)Dst + 38);
        dword_31D64 = 2;
        dword_31D6C = v4;
      }
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 4) != 0 && *((_BYTE *)off_2B148 + 233) >= 5u )
      {
        sub_14E9C(*((_QWORD *)off_2B148 + 27), 0xCu, (__int64)&unk_29CF8, dword_31D68);
        v3 = dword_31D64;
      }
      if ( v3 )
      {
        if ( !byte_31D60 )
        {
          sub_13E6C(3);
          byte_31D60 = 1;
        }
      }
      dword_31D68 = 0;
    }
    sub_26570((__int64)qword_31D70);
  }
}
// 2B148: using guessed type void *off_2B148;
// 2BAE0: using guessed type int dword_2BAE0;
// 31D60: using guessed type char byte_31D60;
// 31D64: using guessed type int dword_31D64;
// 31D68: using guessed type int dword_31D68;
// 31D6C: using guessed type int dword_31D6C;

//----- (00000000000152F8) ----------------------------------------------------
__int64 __fastcall sub_152F8(__int64 a1)
{
  unsigned __int16 v3; // [rsp+30h] [rbp+8h] BYREF
  unsigned __int16 v4; // [rsp+38h] [rbp+10h] BYREF
  int v5; // [rsp+40h] [rbp+18h] BYREF
  int v6; // [rsp+48h] [rbp+20h] BYREF

  sub_1DB60(*(_QWORD *)(a1 + 16), &v6);
  sub_1DC10(*(_QWORD *)(a1 + 16), &v5);
  sub_1EA14(*(_WORD **)(a1 + 32), &v3);
  sub_1EAD8(*(_QWORD *)(a1 + 32), &v4);
  return v6 + (v3 << 16) + v5 + (unsigned int)v4;
}

//----- (0000000000015364) ----------------------------------------------------
__int64 __fastcall sub_15364(__int64 a1)
{
  unsigned __int32 v2; // ecx
  unsigned __int16 v4; // [rsp+38h] [rbp+10h] BYREF

  if ( !*((_DWORD *)Dst + 20) )
    return 0i64;
  if ( (unsigned int)sub_1EDC0(*(_QWORD *)(a1 + 40), &v4) )
    return 0i64;
  v2 = _InterlockedIncrement((volatile signed __int32 *)qword_31D80 + v4);
  if ( v2 <= *((_DWORD *)Dst + 22) )
    return 0i64;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0xAu, (__int64)&unk_29CE8);
  *(_DWORD *)a1 = 4;
  return 1i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001540C) ----------------------------------------------------
__int64 __fastcall sub_1540C(__int64 a1, __int64 a2)
{
  __int64 v4; // rcx
  __int64 v5; // rcx
  char v7; // [rsp+40h] [rbp+18h] BYREF
  int v8; // [rsp+48h] [rbp+20h] BYREF

  if ( !*((_DWORD *)Dst + 23) )
    return 0i64;
  if ( !a1 )
    return 0i64;
  v4 = *(_QWORD *)(a1 + 32);
  if ( !v4 )
    return 0i64;
  sub_1EC4C(v4, &v7);
  if ( ((v7 & 2) == 0 || (v7 & 1) == 0 && (v7 & 4) == 0)
    && ((v7 & 4) == 0 || (v7 & 7) == 4)
    && ((v7 & 1) == 0 || (v7 & 0x10) != 0)
    && v7 )
  {
    return 0i64;
  }
  if ( dword_31D94 )
    sub_15530();
  if ( !dword_31D90 )
  {
    v5 = *(_QWORD *)(a1 + 16);
    v8 = 0;
    sub_1DB60(v5, &v8);
    sub_14070(a2, 5);
  }
  ++dword_31D94;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0xAu, (__int64)&unk_29CD8);
  *(_DWORD *)a1 = 4;
  return 1i64;
}
// 2B148: using guessed type void *off_2B148;
// 31D90: using guessed type int dword_31D90;
// 31D94: using guessed type int dword_31D94;

//----- (0000000000015530) ----------------------------------------------------
void sub_15530()
{
  if ( dword_31D90 )
  {
    if ( !dword_31D94 )
    {
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
        sub_11B10(*((_QWORD *)off_2B148 + 27), 0xBu, (__int64)&unk_29CD8, dword_31D90);
      dword_31D90 = 0;
    }
  }
  else if ( (unsigned int)dword_31D94 >= 2 )
  {
    dword_31D90 = dword_31D94;
    if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
      sub_11008(*((_QWORD *)off_2B148 + 27), 0xCu, (__int64)&unk_29CD8);
    dword_31D94 = 0;
  }
}
// 2B148: using guessed type void *off_2B148;
// 31D90: using guessed type int dword_31D90;
// 31D94: using guessed type int dword_31D94;

//----- (00000000000155F4) ----------------------------------------------------
void __fastcall sub_155F4(__int64 *a1)
{
  __int64 v1; // rdx
  __int64 *v2; // rax

  if ( a1 )
  {
    v1 = *a1;
    v2 = (__int64 *)a1[1];
    *v2 = *a1;
    *(_QWORD *)(v1 + 8) = v2;
    sub_180A0(qword_2BB30, (__int64)a1);
  }
}
// 2BB30: using guessed type __int64 qword_2BB30;

//----- (0000000000015630) ----------------------------------------------------
__int64 __fastcall sub_15630(__int64 a1, __int64 a2)
{
  _BYTE *v4; // rcx
  unsigned __int8 v6; // [rsp+40h] [rbp+18h] BYREF

  if ( !*((_DWORD *)Dst + 25) )
    return 0i64;
  v4 = *(_BYTE **)(a1 + 16);
  v6 = 0;
  sub_1D884(v4, &v6);
  if ( 4 * v6 <= 20 || *(_BYTE *)(*(_QWORD *)(a1 + 16) + 20i64) != 0x89 )
    return 0i64;
  sub_14070(a2, 1);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0xAu, (__int64)&unk_29CB8);
  *(_DWORD *)a1 = 4;
  return 1i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000156E8) ----------------------------------------------------
__int64 sub_156E8()
{
  if ( dword_31DA4 )
    return 1i64;
  sub_18810((__int64)&stru_2BB50);
  qword_2BB48 = (__int64)&qword_2BB40;
  qword_2BB40 = (__int64)&qword_2BB40;
  qword_2BB38 = sub_17E94(2, 0x28u, 0x736E4449u);
  if ( qword_2BB38 )
  {
    dword_31DA4 = 1;
    return 1i64;
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 1) != 0 && *((_BYTE *)off_2B148 + 233) >= 2u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0xAu, (__int64)&unk_29C98);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;
// 2BB40: using guessed type __int64 qword_2BB40;
// 2BB48: using guessed type __int64 qword_2BB48;
// 31DA4: using guessed type int dword_31DA4;

//----- (00000000000157AC) ----------------------------------------------------
void __fastcall sub_157AC(__int64 *a1)
{
  __int64 v1; // rdx
  __int64 *v2; // rax

  if ( a1 )
  {
    v1 = *a1;
    v2 = (__int64 *)a1[1];
    *v2 = *a1;
    *(_QWORD *)(v1 + 8) = v2;
    sub_180A0((__int64)qword_2BB38, (__int64)a1);
  }
}

//----- (00000000000157E8) ----------------------------------------------------
void __fastcall sub_157E8(__int64 a1)
{
  _DWORD *v2; // rax
  __int64 v3; // rbx
  __int16 v4; // ax
  __int64 *v5; // rax

  sub_188F0(&stru_2BB50);
  v2 = sub_18038((__int64)qword_2BB38);
  v3 = (__int64)v2;
  if ( v2 )
  {
    memset(v2, 0, 0x28ui64);
    sub_1DB60(*(_QWORD *)(a1 + 16), (_DWORD *)(v3 + 20));
    sub_1DC10(*(_QWORD *)(a1 + 16), (_DWORD *)(v3 + 24));
    sub_1ECFC(*(_WORD **)(a1 + 40), (_WORD *)(v3 + 28));
    sub_1EDC0(*(_QWORD *)(a1 + 40), (_WORD *)(v3 + 30));
    v4 = *(_WORD *)(*(_QWORD *)(a1 + 40) + 8i64);
    *(_DWORD *)(v3 + 32) = 60;
    *(_WORD *)(v3 + 16) = v4;
    v5 = (__int64 *)qword_2BB48;
    *(_QWORD *)v3 = &qword_2BB40;
    *(_QWORD *)(v3 + 8) = v5;
    *v5 = v3;
    qword_2BB48 = v3;
  }
  sub_189BC(&stru_2BB50);
}
// 2BB40: using guessed type __int64 qword_2BB40;
// 2BB48: using guessed type __int64 qword_2BB48;

//----- (00000000000158C0) ----------------------------------------------------
__int64 __fastcall sub_158C0(__int64 a1)
{
  _WORD *v2; // rcx
  __int16 v3; // di
  __int64 v4; // rcx
  unsigned int v5; // ebx
  int v7[10]; // [rsp+20h] [rbp-28h] BYREF
  __int16 v8; // [rsp+58h] [rbp+10h] BYREF
  __int16 v9; // [rsp+60h] [rbp+18h] BYREF
  int v10; // [rsp+68h] [rbp+20h] BYREF

  sub_188F0(&stru_2BB50);
  if ( (__int64 *)qword_2BB40 == &qword_2BB40
    || (v2 = *(_WORD **)(a1 + 40),
        v3 = v2[4],
        sub_1ECFC(v2, &v8),
        sub_1EDC0(*(_QWORD *)(a1 + 40), &v9),
        sub_1DB60(*(_QWORD *)(a1 + 16), &v10),
        sub_1DC10(*(_QWORD *)(a1 + 16), v7),
        v4 = qword_2BB48,
        (__int64 *)qword_2BB48 == &qword_2BB40) )
  {
LABEL_9:
    v5 = 1;
  }
  else
  {
    while ( *(_DWORD *)(v4 + 24) != v10
         || *(_WORD *)(v4 + 30) != v8
         || *(_DWORD *)(v4 + 20) != v7[0]
         || *(_WORD *)(v4 + 28) != v9
         || *(_WORD *)(v4 + 16) != v3 )
    {
      v4 = *(_QWORD *)(v4 + 8);
      if ( (__int64 *)v4 == &qword_2BB40 )
        goto LABEL_9;
    }
    sub_157AC((__int64 *)v4);
    v5 = 0;
  }
  sub_189BC(&stru_2BB50);
  return v5;
}
// 2BB40: using guessed type __int64 qword_2BB40;
// 2BB48: using guessed type __int64 qword_2BB48;

//----- (00000000000159A8) ----------------------------------------------------
void **sub_159A8()
{
  void **result; // rax

  if ( byte_31D61 )
  {
    if ( !dword_31DA8 )
    {
      result = &off_2B148;
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
        result = (void **)sub_11008(*((_QWORD *)off_2B148 + 27), 0xBu, (__int64)&unk_29C88);
      byte_31D61 = 0;
    }
  }
  else if ( (unsigned int)dword_31DA8 >= 5 )
  {
    result = &off_2B148;
    if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
      result = (void **)sub_11008(*((_QWORD *)off_2B148 + 27), 0xCu, (__int64)&unk_29C88);
    dword_31DA8 = 0;
    byte_31D61 = 1;
  }
  return result;
}
// 2B148: using guessed type void *off_2B148;
// 31D61: using guessed type char byte_31D61;
// 31DA8: using guessed type int dword_31DA8;

//----- (0000000000015A68) ----------------------------------------------------
__int64 __fastcall sub_15A68(int a1, __int16 a2)
{
  unsigned int v4; // er9
  unsigned int v5; // ebx
  _QWORD *v6; // r8
  __int64 v7; // rax
  __int64 v8; // rcx

  sub_188F0(&stru_2BB88);
  v4 = 0;
  v5 = 1;
  v6 = qword_2BBC8;
  while ( 1 )
  {
    if ( *((_DWORD *)v6 - 2) )
    {
      v7 = *v6;
      if ( *v6 )
        break;
    }
LABEL_8:
    ++v4;
    v6 += 2;
    if ( v4 == 1024 )
    {
      v5 = 0;
      goto LABEL_10;
    }
  }
  v8 = 0i64;
  while ( *(_DWORD *)v7 != a1 || *(_WORD *)(v7 + 4) != a2 )
  {
    v8 = (unsigned int)(v8 + 1);
    v7 += 12i64;
    if ( (_DWORD)v8 == 1024 )
      goto LABEL_8;
  }
  *(_DWORD *)(qword_2BBC8[2 * v4] + 12 * v8 + 8) = 60;
LABEL_10:
  sub_189BC(&stru_2BB88);
  return v5;
}

//----- (0000000000015B20) ----------------------------------------------------
void __fastcall sub_15B20(int a1, __int16 a2)
{
  _QWORD *v4; // rax
  __int64 v5; // r8
  __int64 v6; // rsi
  unsigned int v7; // edx
  _WORD *v8; // rcx
  unsigned int v9; // ebp
  __int64 v10; // rdi
  _DWORD *v11; // r12
  PVOID v12; // rax
  __int64 v13; // r8
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // rdx
  __int64 v17; // rdi

  sub_188F0(&stru_2BB88);
  v4 = qword_2BBC8;
  v5 = 0i64;
  v6 = 1024i64;
  while ( !*((_DWORD *)v4 - 2) || !*v4 || *((_DWORD *)v4 - 2) == 1024 )
  {
LABEL_8:
    v5 = (unsigned int)(v5 + 1);
    v4 += 2;
    if ( (_DWORD)v5 == 1024 )
    {
      v9 = 0;
      v10 = 0i64;
      v11 = &unk_2BBC0;
      while ( 1 )
      {
        if ( !*v11 )
        {
          v12 = sub_17C28(2, 0x3000u, 0x55445045u);
          if ( v12 )
            break;
        }
        ++v9;
        ++v10;
        v11 += 4;
        if ( v9 == 1024 )
          goto LABEL_18;
      }
      v15 = 0i64;
      v16 = 2i64 * v9;
      v17 = 2 * v10;
      *((_DWORD *)&unk_2BBC0 + 2 * v16) = 1;
      *((_QWORD *)&unk_2BBC0 + v16 + 1) = v12;
      do
      {
        *(_WORD *)(*((_QWORD *)&unk_2BBC0 + v17 + 1) + v15 + 4) = 0;
        *(_DWORD *)(v15 + *((_QWORD *)&unk_2BBC0 + v17 + 1)) = 0;
        v15 += 12i64;
        --v6;
        *(_DWORD *)(*((_QWORD *)&unk_2BBC0 + v17 + 1) + v15 - 4) = 0;
      }
      while ( v6 );
      **((_DWORD **)&unk_2BBC0 + 2 * v9 + 1) = a1;
      *(_WORD *)(*((_QWORD *)&unk_2BBC0 + 2 * v9 + 1) + 4i64) = a2;
      *(_DWORD *)(*((_QWORD *)&unk_2BBC0 + 2 * v9 + 1) + 8i64) = 60;
      goto LABEL_18;
    }
  }
  v7 = 0;
  v8 = (_WORD *)(*v4 + 4i64);
  while ( *v8 )
  {
    ++v7;
    v8 += 6;
    if ( v7 == 1024 )
      goto LABEL_8;
  }
  v13 = 2 * v5;
  v14 = 3i64 * v7;
  *(_WORD *)(*((_QWORD *)&unk_2BBC0 + v13 + 1) + 4 * v14 + 4) = a2;
  *(_DWORD *)(*((_QWORD *)&unk_2BBC0 + v13 + 1) + 4 * v14 + 8) = 60;
  *(_DWORD *)(*((_QWORD *)&unk_2BBC0 + v13 + 1) + 4 * v14) = a1;
  ++*((_DWORD *)&unk_2BBC0 + 2 * v13);
LABEL_18:
  sub_189BC(&stru_2BB88);
}

//----- (0000000000015CB8) ----------------------------------------------------
__int64 sub_15CB8()
{
  _QWORD *v0; // r11
  __int64 v1; // rax
  _QWORD *v3; // rax
  __int64 v4; // rcx

  if ( dword_31DB0 )
    return 1i64;
  sub_18810((__int64)&stru_2BB88);
  v0 = qword_2FC00;
  v1 = 256i64;
  do
  {
    v0[1] = v0;
    *v0 = v0;
    v0 += 2;
    --v1;
  }
  while ( v1 );
  qword_2FBC0 = sub_17E94(2, 0xE0u, 0x73705549u);
  if ( qword_2FBC0 )
  {
    v3 = &unk_2BBC0;
    v4 = 1024i64;
    do
    {
      v3[1] = 0i64;
      *(_DWORD *)v3 = 0;
      v3 += 2;
      --v4;
    }
    while ( v4 );
    dword_31DB0 = 1;
    return 1i64;
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 1) != 0 && *((_BYTE *)off_2B148 + 233) >= 2u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0xAu, (__int64)&unk_29C68);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;
// 31DB0: using guessed type int dword_31DB0;

//----- (0000000000015DA0) ----------------------------------------------------
__int64 __fastcall sub_15DA0(__int64 a1, __int64 a2)
{
  __int64 v4; // rcx
  int v6; // [rsp+40h] [rbp-18h] BYREF
  int v7[5]; // [rsp+44h] [rbp-14h] BYREF
  __int16 v8; // [rsp+70h] [rbp+18h] BYREF
  int v9; // [rsp+78h] [rbp+20h] BYREF

  if ( !dword_31DB0 )
    return 0i64;
  v4 = *(_QWORD *)(a1 + 16);
  v6 = 0;
  sub_1DB60(v4, &v9);
  sub_1DC10(*(_QWORD *)(a1 + 16), v7);
  sub_1EDC0(*(_QWORD *)(a1 + 40), &v8);
  if ( !(unsigned int)sub_161B4(v9, v7[0], v8, &v6) )
    return 0i64;
  if ( !v6 )
  {
    if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
      sub_14E9C(*((_QWORD *)off_2B148 + 27), 0xBu, (__int64)&unk_29C68, (unsigned __int8)v9);
    sub_14070(a2, 9);
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0xCu, (__int64)&unk_29C68);
  *(_DWORD *)a1 = 4;
  return 1i64;
}
// 2B148: using guessed type void *off_2B148;
// 31DB0: using guessed type int dword_31DB0;

//----- (0000000000015EE4) ----------------------------------------------------
__int64 __fastcall sub_15EE4(__int64 a1, __int64 a2)
{
  _BYTE *v5; // rcx
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF
  __int16 v7; // [rsp+50h] [rbp+18h] BYREF
  int v8; // [rsp+58h] [rbp+20h] BYREF

  if ( !dword_31DB0 )
    return 0i64;
  if ( *(_QWORD *)(a1 + 40) )
  {
    sub_1DB60(*(_QWORD *)(a1 + 16), &v8);
    sub_1ECFC(*(_WORD **)(a1 + 40), &v7);
    if ( !(unsigned int)sub_15A68(v8, v7) )
      sub_15B20(v8, v7);
    return 0i64;
  }
  if ( !*((_DWORD *)Dst + 13) )
    return 0i64;
  v5 = *(_BYTE **)(a1 + 48);
  if ( !v5 )
    return 0i64;
  sub_1EE84(v5, &v7);
  sub_1EF30(*(_QWORD *)(a1 + 48), &v8);
  if ( (_BYTE)v7 != 3 )
    return 0i64;
  if ( (_BYTE)v8 != 3 )
    return 0i64;
  sub_1DAB0(*(_QWORD *)(a1 + 48) + 8i64, v6);
  if ( v6[0] != 17 )
    return 0i64;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0xDu, (__int64)&unk_29C68);
  sub_14070(a2, 9);
  *(_DWORD *)a1 = 4;
  return 1i64;
}
// 2B148: using guessed type void *off_2B148;
// 31DB0: using guessed type int dword_31DB0;

//----- (0000000000016004) ----------------------------------------------------
void sub_16004()
{
  _QWORD *v0; // rbx
  __int64 v1; // rbp
  _QWORD *v2; // rsi
  __int64 v3; // rdx
  _DWORD *v4; // rax
  _WORD *v5; // rcx
  __int64 v6; // r8
  bool v7; // zf
  _QWORD *v8; // rdi
  __int64 v9; // rax
  PVOID v10; // rcx
  PVOID *v11; // rbx
  __int64 v12; // rdi
  int v13; // edx
  __int64 v14; // rax
  char *v15; // rcx

  if ( *((_DWORD *)Dst + 10) && dword_31DB0 )
  {
    sub_188F0(&stru_2BB88);
    v0 = qword_2FC00;
    v1 = 256i64;
    v2 = qword_2FC00;
    do
    {
      if ( (_QWORD *)*v0 != v0 )
      {
        v3 = v0[1];
        if ( (_QWORD *)v3 != v2 )
        {
          do
          {
            v4 = (_DWORD *)(v3 + 96);
            v5 = (_WORD *)(v3 + 32);
            v6 = 32i64;
            do
            {
              if ( *v5 )
              {
                v7 = (*v4)-- == 1;
                if ( v7 )
                {
                  --*(_DWORD *)(v3 + 24);
                  *v5 = 0;
                  *v4 = 0;
                }
              }
              ++v5;
              ++v4;
              --v6;
            }
            while ( v6 );
            v8 = *(_QWORD **)(v3 + 8);
            if ( !*(_DWORD *)(v3 + 24) )
            {
              v9 = *(_QWORD *)v3;
              v10 = qword_2FBC0;
              *v8 = *(_QWORD *)v3;
              *(_QWORD *)(v9 + 8) = v8;
              sub_180A0((__int64)v10, v3);
            }
            v3 = (__int64)v8;
          }
          while ( v8 != v2 );
        }
      }
      v2 += 2;
      v0 += 2;
      --v1;
    }
    while ( v1 );
    sub_189BC(&stru_2BB88);
    sub_188F0(&stru_2BB88);
    v11 = (PVOID *)qword_2BBC8;
    v12 = 1024i64;
    do
    {
      if ( *((_DWORD *)v11 - 2) && *v11 )
      {
        v13 = 0;
        v14 = 0i64;
        do
        {
          v15 = (char *)*v11;
          if ( *(_WORD *)((char *)*v11 + v14 + 4) )
          {
            if ( *(_DWORD *)&v15[v14 + 8] )
            {
              --*(_DWORD *)&v15[v14 + 8];
            }
            else
            {
              *(_WORD *)&v15[v14 + 4] = 0;
              v7 = (*((_DWORD *)v11 - 2))-- == 1;
              if ( v7 )
              {
                sub_17CAC(*v11, 0x55445045u);
                *v11 = 0i64;
                break;
              }
            }
          }
          ++v13;
          v14 += 12i64;
        }
        while ( v13 != 1024 );
      }
      v11 += 2;
      --v12;
    }
    while ( v12 );
    sub_189BC(&stru_2BB88);
  }
}
// 31DB0: using guessed type int dword_31DB0;

//----- (00000000000161B4) ----------------------------------------------------
__int64 __fastcall sub_161B4(int a1, int a2, __int16 a3, _DWORD *a4)
{
  unsigned int v8; // ebx
  _QWORD *v10; // rdi
  __int64 i; // rdx
  _DWORD *v12; // r8
  unsigned int v13; // er10
  int v14; // eax
  _WORD *v15; // r9
  unsigned int v16; // eax
  _WORD *v17; // rcx
  __int64 v18; // rcx
  _DWORD *v19; // rax
  _DWORD *v20; // rbx
  _DWORD *v21; // rcx
  _QWORD *v22; // rax

  v8 = 0;
  *a4 = 0;
  if ( (unsigned int)sub_15A68(a2, a3) )
    return 0i64;
  sub_188F0(&stru_2BB88);
  v10 = &qword_2FC00[2 * (unsigned __int8)a1];
  if ( (_QWORD *)*v10 != v10 )
  {
    for ( i = qword_2FC00[2 * (unsigned __int8)a1 + 1]; (_QWORD *)i != v10; i = *(_QWORD *)(i + 8) )
    {
      if ( *(_DWORD *)(i + 16) == a1 && *(_DWORD *)(i + 20) == a2 )
      {
        v12 = Dst;
        v13 = *(_DWORD *)(i + 24);
        if ( v13 > *((_DWORD *)Dst + 11) )
        {
          v14 = *(_DWORD *)(i + 28);
          v8 = 1;
          *a4 = v14;
          *(_DWORD *)(i + 28) = v14 + 1;
        }
        v15 = (_WORD *)(i + 32);
        v16 = 0;
        v17 = (_WORD *)(i + 32);
        do
        {
          if ( *v17 == a3 )
          {
            v18 = v16;
            goto LABEL_20;
          }
          ++v16;
          ++v17;
        }
        while ( v16 != 32 );
        v18 = 0i64;
        while ( *v15 )
        {
          v18 = (unsigned int)(v18 + 1);
          ++v15;
          if ( (_DWORD)v18 == 32 )
            goto LABEL_24;
        }
        *(_DWORD *)(i + 24) = v13 + 1;
        *(_WORD *)(i + 2 * v18 + 32) = a3;
LABEL_20:
        *(_DWORD *)(i + 4 * v18 + 96) = v12[12];
        goto LABEL_24;
      }
    }
  }
  v19 = sub_18038((__int64)qword_2FBC0);
  v20 = v19;
  if ( v19 )
  {
    memset(v19, 0, 0xE0ui64);
    v21 = Dst;
    v20[4] = a1;
    v20[5] = a2;
    v20[6] = 1;
    v20[7] = 0;
    *((_WORD *)v20 + 16) = a3;
    v20[24] = v21[12];
    v22 = (_QWORD *)v10[1];
    *(_QWORD *)v20 = v10;
    *((_QWORD *)v20 + 1) = v22;
    *v22 = v20;
    v10[1] = v20;
  }
  v8 = 0;
LABEL_24:
  sub_189BC(&stru_2BB88);
  return v8;
}

//----- (0000000000016354) ----------------------------------------------------
__int64 __fastcall sub_16354(__int64 a1, __int64 a2)
{
  int v2; // er8
  _DWORD *v5; // rax
  unsigned int v6; // er9
  bool v7; // cf
  unsigned int v8; // er9
  int v9; // edx
  unsigned __int8 v11; // [rsp+40h] [rbp+18h] BYREF
  unsigned int v12; // [rsp+48h] [rbp+20h] BYREF

  v2 = dword_31DB4;
  if ( dword_31DB4 )
  {
    v5 = Dst;
    if ( *((_DWORD *)Dst + 14) )
    {
      v12 = 0;
      if ( *((_DWORD *)Dst + 15) < 0x14u )
        *((_DWORD *)Dst + 15) = 200;
      if ( v5[16] > 0x14u )
        v5[16] = 20;
      sub_1D884(*(_BYTE **)(a1 + 16), &v12);
      v5 = Dst;
      v6 = 4 * v12;
      v12 = v6;
      if ( v6 > *((_DWORD *)Dst + 15) || v6 < *((_DWORD *)Dst + 16) )
      {
        if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
          sub_11B10(*((_QWORD *)off_2B148 + 27), 0xAu, (__int64)&unk_29C58, v6);
        v9 = 6;
        goto LABEL_28;
      }
      v2 = dword_31DB4;
    }
    if ( v2 && v5[17] )
    {
      v7 = v5[18] < 0x14u;
      v11 = 0;
      if ( v7 )
        v5[18] = 60;
      if ( v5[19] > 0x14u )
        v5[19] = 20;
      sub_1EB9C(*(_QWORD *)(a1 + 32), &v11);
      v8 = 4 * v11;
      if ( v8 > *((_DWORD *)Dst + 18) || v8 < *((_DWORD *)Dst + 19) )
      {
        if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
          sub_11B10(*((_QWORD *)off_2B148 + 27), 0xBu, (__int64)&unk_29C58, v8);
        v9 = 7;
LABEL_28:
        sub_14070(a2, v9);
        *(_DWORD *)a1 = 4;
        return 1i64;
      }
    }
  }
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;
// 31DB4: using guessed type int dword_31DB4;

//----- (00000000000164F0) ----------------------------------------------------
__int64 sub_164F0()
{
  if ( dword_31DB8 )
    return 1i64;
  dword_2BAE4 = 0;
  dword_30C14 = 0;
  dword_30C10 = 0;
  sub_18810((__int64)&stru_2FBC8);
  qword_30C08 = (__int64)&qword_30C00;
  qword_30C00 = (__int64)&qword_30C00;
  qword_30C18 = sub_17E94(2, 0x20u, 0x6D634949u);
  if ( qword_30C18 )
  {
    dword_31DB8 = 1;
    return 1i64;
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 1) != 0 && *((_BYTE *)off_2B148 + 233) >= 2u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0xAu, (__int64)&unk_29C48);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;
// 2BAE4: using guessed type int dword_2BAE4;
// 30C00: using guessed type __int64 qword_30C00;
// 30C08: using guessed type __int64 qword_30C08;
// 30C10: using guessed type int dword_30C10;
// 30C14: using guessed type int dword_30C14;
// 31DB8: using guessed type int dword_31DB8;

//----- (00000000000165C8) ----------------------------------------------------
__int64 __fastcall sub_165C8(__int64 a1, __int64 a2)
{
  _DWORD *v4; // r8
  char v5; // al
  int v7; // ebp
  __int64 i; // rdi
  int v9; // er11
  int v10; // [rsp+20h] [rbp-38h] BYREF
  int v11[13]; // [rsp+24h] [rbp-34h] BYREF
  char v12; // [rsp+60h] [rbp+8h] BYREF
  char v13; // [rsp+70h] [rbp+18h] BYREF
  unsigned __int16 v14; // [rsp+78h] [rbp+20h] BYREF

  sub_1EE84(*(_BYTE **)(a1 + 48), &v12);
  sub_1EF30(*(_QWORD *)(a1 + 48), &v13);
  v4 = Dst;
  if ( !*((_DWORD *)Dst + 4) )
    goto LABEL_11;
  v5 = v12;
  if ( v12 != 3 )
    goto LABEL_12;
  if ( v13 != 4 )
    return 0i64;
  sub_1EFE0(*(_QWORD *)(a1 + 48), &v14);
  if ( !v14 )
    return 0i64;
  v4 = Dst;
  if ( *((unsigned int *)Dst + 5) <= 4 * (unsigned __int64)v14 )
  {
LABEL_11:
    v5 = v12;
LABEL_12:
    if ( !v5 )
    {
      v7 = 0;
      if ( v4[6] || v4[8] )
      {
        sub_188F0(&stru_2FBC8);
        if ( (__int64 *)qword_30C00 != &qword_30C00 )
        {
          for ( i = qword_30C08; (__int64 *)i != &qword_30C00; i = *(_QWORD *)(i + 8) )
          {
            sub_1DB60(*(_QWORD *)(a1 + 16), &v10);
            sub_1DC10(*(_QWORD *)(a1 + 16), v11);
            v9 = *(_DWORD *)(i + 24);
            if ( v9 == v10 && *(_DWORD *)(i + 20) == v11[0] )
            {
              *(_DWORD *)(i + 28) = 0;
LABEL_23:
              v7 = 1;
              if ( !*(_DWORD *)(i + 28) )
                sub_16954((__int64 *)i);
              break;
            }
            if ( v9 == -1 )
              goto LABEL_23;
          }
        }
        sub_189BC(&stru_2FBC8);
        v4 = Dst;
        if ( *((_DWORD *)Dst + 8) )
        {
          if ( !v7 && (unsigned int)++dword_2BAE4 > *((_DWORD *)Dst + 9) )
          {
            if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
              sub_11008(*((_QWORD *)off_2B148 + 27), 0xCu, (__int64)&unk_29C48);
            ++dword_30C10;
LABEL_33:
            *(_DWORD *)a1 = 4;
            return 1i64;
          }
        }
      }
      if ( v4[6] && !v7 )
      {
        if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
          sub_11008(*((_QWORD *)off_2B148 + 27), 0xDu, (__int64)&unk_29C48);
        ++dword_30C14;
        goto LABEL_33;
      }
    }
    return 0i64;
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0xBu, (__int64)&unk_29C48);
  sub_14070(a2, 17);
  *(_DWORD *)a1 = 4;
  return 1i64;
}
// 2B148: using guessed type void *off_2B148;
// 2BAE4: using guessed type int dword_2BAE4;
// 30C00: using guessed type __int64 qword_30C00;
// 30C08: using guessed type __int64 qword_30C08;
// 30C10: using guessed type int dword_30C10;
// 30C14: using guessed type int dword_30C14;

//----- (000000000001684C) ----------------------------------------------------
__int64 __fastcall sub_1684C(__int64 a1)
{
  _DWORD *v2; // rax
  __int64 v3; // rbx
  __int64 *v4; // r11
  char v6; // [rsp+30h] [rbp+8h] BYREF
  char v7; // [rsp+38h] [rbp+10h] BYREF
  int v8; // [rsp+40h] [rbp+18h] BYREF
  int v9; // [rsp+48h] [rbp+20h] BYREF

  sub_1EE84(*(_BYTE **)(a1 + 48), &v6);
  sub_1EF30(*(_QWORD *)(a1 + 48), &v7);
  if ( v6 == 8 && (*((_DWORD *)Dst + 8) || *((_DWORD *)Dst + 6)) )
  {
    sub_1DB60(*(_QWORD *)(a1 + 16), &v8);
    sub_1DC10(*(_QWORD *)(a1 + 16), &v9);
    v2 = sub_18038((__int64)qword_30C18);
    v3 = (__int64)v2;
    if ( v2 )
    {
      memset(v2, 0, 0x20ui64);
      *(_DWORD *)(v3 + 20) = v8;
      *(_DWORD *)(v3 + 24) = v9;
      *(_BYTE *)(v3 + 16) = v6;
      *(_DWORD *)(v3 + 28) = *((_DWORD *)Dst + 7);
      sub_188F0(&stru_2FBC8);
      v4 = (__int64 *)qword_30C08;
      *(_QWORD *)(v3 + 8) = qword_30C08;
      *(_QWORD *)v3 = &qword_30C00;
      *v4 = v3;
      qword_30C08 = v3;
      sub_189BC(&stru_2FBC8);
    }
  }
  return 0i64;
}
// 30C00: using guessed type __int64 qword_30C00;
// 30C08: using guessed type __int64 qword_30C08;

//----- (0000000000016954) ----------------------------------------------------
void __fastcall sub_16954(__int64 *a1)
{
  __int64 v1; // rdx
  __int64 *v2; // rax

  if ( a1 )
  {
    v1 = *a1;
    v2 = (__int64 *)a1[1];
    *v2 = *a1;
    *(_QWORD *)(v1 + 8) = v2;
    sub_180A0((__int64)qword_30C18, (__int64)a1);
  }
}

//----- (0000000000016990) ----------------------------------------------------
__int64 sub_16990()
{
  if ( dword_31DC8 )
    return 1i64;
  sub_18810((__int64)&stru_30C80);
  dword_30CB8 = 0;
  qword_30C78 = (__int64)&qword_30C70;
  qword_30C70 = (__int64)&qword_30C70;
  qword_31DC0 = sub_17E94(2, 0x28u, 0x70724149u);
  if ( qword_31DC0 )
  {
    dword_31DC8 = 1;
    return 1i64;
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 1) != 0 && *((_BYTE *)off_2B148 + 233) >= 2u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0xAu, (__int64)&unk_29C28);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;
// 30C70: using guessed type __int64 qword_30C70;
// 30C78: using guessed type __int64 qword_30C78;
// 30CB8: using guessed type int dword_30CB8;
// 31DC8: using guessed type int dword_31DC8;

//----- (0000000000016A58) ----------------------------------------------------
__int64 __fastcall sub_16A58(__int64 a1, __int64 a2)
{
  _DWORD *v4; // rax
  _QWORD *v5; // rcx
  unsigned __int16 v6; // dx
  unsigned int v8; // ecx
  bool v9; // zf
  int v10; // [rsp+20h] [rbp-28h] BYREF
  int v11; // [rsp+24h] [rbp-24h] BYREF
  char v12[8]; // [rsp+28h] [rbp-20h] BYREF
  char v13[8]; // [rsp+30h] [rbp-18h] BYREF

  if ( dword_31DC8
    && (unsigned __int8)sub_1F4A8(*(__int16 **)(a1 + 24))
    && (unsigned int)sub_16DD0(*(_QWORD *)(a1 + 24)) )
  {
    sub_1D65C(*(_QWORD *)(a1 + 8), (__int64)v12);
    if ( v12[0] != -1 || v12[1] != -1 || v12[2] != -1 || v12[3] != -1 || v12[4] != -1 || v12[5] != -1 )
    {
      v5 = off_2B148;
      if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 236) & 2) == 0 || *((_BYTE *)off_2B148 + 233) < 4u )
        goto LABEL_23;
      v6 = 14;
      goto LABEL_22;
    }
    sub_1F23C(*(_QWORD *)(a1 + 24), &v10);
    sub_1F3DC(*(_QWORD *)(a1 + 24), &v11);
    if ( v10 != v11
      || (sub_1F308(*(_QWORD *)(a1 + 24), (__int64)v13), v13[0])
      || v13[1]
      || v13[2]
      || v13[3]
      || v13[4]
      || v13[5] )
    {
      v4 = Dst;
    }
    else
    {
      v4 = Dst;
      if ( *((_DWORD *)Dst + 41) )
      {
        v5 = off_2B148;
        if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 236) & 2) == 0 || *((_BYTE *)off_2B148 + 233) < 4u )
          goto LABEL_23;
        v6 = 11;
LABEL_22:
        sub_11008(v5[27], v6, (__int64)&unk_29C28);
LABEL_23:
        sub_14070(a2, 13);
        *(_DWORD *)a1 = 4;
        return 1i64;
      }
    }
    v8 = dword_30CB8 + 1;
    v9 = v4[41] == 0;
    ++dword_30CB8;
    if ( !v9 )
    {
      v5 = off_2B148;
      if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 236) & 2) == 0 || *((_BYTE *)off_2B148 + 233) < 4u )
        goto LABEL_23;
      v6 = 12;
      goto LABEL_22;
    }
    if ( v8 > v4[42] )
    {
      v5 = off_2B148;
      if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 236) & 2) == 0 || *((_BYTE *)off_2B148 + 233) < 4u )
        goto LABEL_23;
      v6 = 13;
      goto LABEL_22;
    }
  }
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;
// 30CB8: using guessed type int dword_30CB8;
// 31DC8: using guessed type int dword_31DC8;

//----- (0000000000016CB8) ----------------------------------------------------
void __fastcall sub_16CB8(__int64 *a1)
{
  __int64 v1; // rdx
  __int64 *v2; // rax

  if ( a1 )
  {
    v1 = *a1;
    v2 = (__int64 *)a1[1];
    *v2 = *a1;
    *(_QWORD *)(v1 + 8) = v2;
    sub_180A0((__int64)qword_31DC0, (__int64)a1);
  }
}

//----- (0000000000016CF4) ----------------------------------------------------
void __fastcall sub_16CF4(__int64 a1)
{
  _DWORD *v2; // rax
  __int64 v3; // rdi
  __int64 *v4; // rax
  __int16 v5; // [rsp+30h] [rbp+8h] BYREF

  if ( a1 )
  {
    sub_1F0A4(a1, &v5);
    if ( v5 != 2 )
    {
      sub_188F0(&stru_30C80);
      v2 = sub_18038((__int64)qword_31DC0);
      v3 = (__int64)v2;
      if ( v2 )
      {
        memset(v2, 0, 0x28ui64);
        sub_1F168(a1, v3 + 16);
        sub_1F23C(a1, (_DWORD *)(v3 + 22));
        sub_1F3DC(a1, (_DWORD *)(v3 + 26));
        *(_DWORD *)(v3 + 32) = 10;
        v4 = (__int64 *)qword_30C78;
        *(_QWORD *)(v3 + 8) = qword_30C78;
        *(_QWORD *)v3 = &qword_30C70;
        *v4 = v3;
        qword_30C78 = v3;
      }
      sub_189BC(&stru_30C80);
    }
  }
}
// 30C70: using guessed type __int64 qword_30C70;
// 30C78: using guessed type __int64 qword_30C78;

//----- (0000000000016DD0) ----------------------------------------------------
__int64 __fastcall sub_16DD0(__int64 a1)
{
  int v1; // esi
  __int64 i; // rbx
  __int64 result; // rax
  __int16 v5[2]; // [rsp+20h] [rbp-28h] BYREF
  int v6; // [rsp+24h] [rbp-24h] BYREF
  char v7[8]; // [rsp+28h] [rbp-20h] BYREF

  v1 = 0;
  if ( !a1 )
    goto LABEL_17;
  sub_1F0A4(a1, v5);
  if ( v5[0] != 2 )
    goto LABEL_17;
  sub_188F0(&stru_30C80);
  if ( (__int64 *)qword_30C70 != &qword_30C70 )
  {
    for ( i = qword_30C78; (__int64 *)i != &qword_30C70; i = *(_QWORD *)(i + 8) )
    {
      sub_1F308(a1, (__int64)v7);
      if ( *(_BYTE *)(i + 16) == v7[0]
        && *(_BYTE *)(i + 17) == v7[1]
        && *(_BYTE *)(i + 18) == v7[2]
        && *(_BYTE *)(i + 19) == v7[3]
        && *(_BYTE *)(i + 20) == v7[4]
        && *(_BYTE *)(i + 21) == v7[5] )
      {
        sub_1F23C(a1, &v6);
        if ( *(_DWORD *)(i + 26) == v6 )
        {
          v1 = 1;
          sub_16CB8((__int64 *)i);
          break;
        }
      }
    }
  }
  sub_189BC(&stru_30C80);
  if ( !v1 )
    result = 1i64;
  else
LABEL_17:
    result = 0i64;
  return result;
}
// 30C70: using guessed type __int64 qword_30C70;
// 30C78: using guessed type __int64 qword_30C78;

//----- (0000000000016F00) ----------------------------------------------------
__int64 sub_16F00()
{
  _QWORD *v0; // r11
  __int64 v1; // rax

  if ( dword_31DCC )
    return 1i64;
  sub_18810((__int64)&FastMutex);
  v0 = qword_30D00;
  v1 = 256i64;
  do
  {
    v0[1] = v0;
    *v0 = v0;
    v0 += 2;
    --v1;
  }
  while ( v1 );
  qword_30CF8 = sub_17E94(2, 0xE0u, 0x73705449u);
  if ( qword_30CF8 )
  {
    dword_31DCC = 1;
    return 1i64;
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 1) != 0 && *((_BYTE *)off_2B148 + 233) >= 2u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0xAu, (__int64)&unk_29C18);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;
// 31DCC: using guessed type int dword_31DCC;

//----- (0000000000016FC8) ----------------------------------------------------
__int64 __fastcall sub_16FC8(__int64 a1, __int64 a2)
{
  __int64 v4; // rcx
  char v5; // r11
  int v6; // esi
  void **v7; // r11
  int v9[10]; // [rsp+40h] [rbp-28h] BYREF
  char v10; // [rsp+80h] [rbp+18h] BYREF
  __int16 v11; // [rsp+88h] [rbp+20h] BYREF

  if ( !dword_31DCC )
    return 0i64;
  v4 = *(_QWORD *)(a1 + 32);
  v10 = 0;
  sub_1EC4C(v4, &v10);
  v5 = v10;
  if ( v10 != 2 )
  {
LABEL_16:
    if ( v5 == 24 )
    {
      sub_1DB60(*(_QWORD *)(a1 + 16), v9);
      sub_1EAD8(*(_QWORD *)(a1 + 32), &v11);
      sub_17154(v9[0], v11);
    }
    return 0i64;
  }
  sub_1DB60(*(_QWORD *)(a1 + 16), v9);
  sub_1EAD8(*(_QWORD *)(a1 + 32), &v11);
  v6 = sub_17200(v9[0], v11);
  if ( !v6 )
  {
    v5 = v10;
    goto LABEL_16;
  }
  v7 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 27), 0xBu, (__int64)&unk_29C18);
    v7 = (void **)off_2B148;
  }
  if ( v6 == 2 )
  {
    if ( v7 != &off_2B148 && (*((_BYTE *)v7 + 236) & 2) != 0 && *((_BYTE *)v7 + 233) >= 4u )
      sub_14E9C((__int64)v7[27], 0xCu, (__int64)&unk_29C18, LOBYTE(v9[0]));
    sub_14070(a2, 4);
  }
  *(_DWORD *)a1 = 4;
  return 1i64;
}
// 2B148: using guessed type void *off_2B148;
// 31DCC: using guessed type int dword_31DCC;

//----- (0000000000017154) ----------------------------------------------------
void __fastcall sub_17154(int a1, __int16 a2)
{
  _QWORD *v4; // rax
  __int64 i; // rcx
  _WORD *v6; // rdx
  __int64 v7; // rax

  sub_188F0(&FastMutex);
  v4 = &qword_30D00[2 * (unsigned __int8)a1];
  if ( (_QWORD *)*v4 != v4 )
  {
    for ( i = qword_30D00[2 * (unsigned __int8)a1 + 1]; (_QWORD *)i != v4; i = *(_QWORD *)(i + 8) )
    {
      if ( *(_DWORD *)(i + 16) == a1 )
      {
        v6 = (_WORD *)(i + 28);
        v7 = 0i64;
        while ( *v6 != a2 )
        {
          v7 = (unsigned int)(v7 + 1);
          ++v6;
          if ( (_DWORD)v7 == 32 )
            goto LABEL_12;
        }
        --*(_DWORD *)(i + 24);
        *(_DWORD *)(i + 4 * v7 + 92) = 0;
        *(_WORD *)(i + 2 * v7 + 28) = 0;
LABEL_12:
        if ( !*(_DWORD *)(i + 24) )
          sub_1737C((__int64 *)i);
        break;
      }
    }
  }
  sub_189BC(&FastMutex);
}

//----- (0000000000017200) ----------------------------------------------------
__int64 __fastcall sub_17200(int a1, __int16 a2)
{
  unsigned int v4; // ebx
  _QWORD *v5; // rdi
  __int64 i; // rdx
  _DWORD *v7; // rax
  _DWORD *v8; // rbx
  _QWORD *v9; // rax
  _DWORD *v11; // r8
  unsigned int v12; // er11
  _WORD *v13; // r9
  __int64 v14; // rcx
  _WORD *v15; // r10

  v4 = 0;
  sub_188F0(&FastMutex);
  v5 = &qword_30D00[2 * (unsigned __int8)a1];
  if ( (_QWORD *)*v5 != v5 )
  {
    for ( i = qword_30D00[2 * (unsigned __int8)a1 + 1]; (_QWORD *)i != v5; i = *(_QWORD *)(i + 8) )
    {
      if ( *(_DWORD *)(i + 16) == a1 )
      {
        v11 = Dst;
        v12 = *(_DWORD *)(i + 24);
        if ( v12 > *((_DWORD *)Dst + 44) )
        {
          v4 = 1;
          if ( !*(_DWORD *)(i + 20) )
          {
            *(_DWORD *)(i + 20) = 1;
            v4 = 2;
          }
        }
        v13 = (_WORD *)(i + 28);
        v14 = 0i64;
        v15 = (_WORD *)(i + 28);
        while ( *v15 != a2 )
        {
          v14 = (unsigned int)(v14 + 1);
          ++v15;
          if ( (_DWORD)v14 == 32 )
          {
            v14 = 0i64;
            while ( *v13 )
            {
              v14 = (unsigned int)(v14 + 1);
              ++v13;
              if ( (_DWORD)v14 == 32 )
                goto LABEL_9;
            }
            *(_DWORD *)(i + 24) = v12 + 1;
            *(_WORD *)(i + 2 * v14 + 28) = a2;
            break;
          }
        }
        *(_DWORD *)(i + 4 * v14 + 92) = v11[45];
        goto LABEL_9;
      }
    }
  }
  v7 = sub_18038((__int64)qword_30CF8);
  v8 = v7;
  if ( v7 )
  {
    memset(v7, 0, 0xE0ui64);
    v8[4] = a1;
    v8[5] = 0;
    *((_WORD *)v8 + 14) = a2;
    v8[6] = 1;
    v8[23] = *((_DWORD *)Dst + 45);
    v9 = (_QWORD *)v5[1];
    *(_QWORD *)v8 = v5;
    *((_QWORD *)v8 + 1) = v9;
    *v9 = v8;
    v5[1] = v8;
  }
  v4 = 0;
LABEL_9:
  sub_189BC(&FastMutex);
  return v4;
}

//----- (000000000001737C) ----------------------------------------------------
void __fastcall sub_1737C(__int64 *a1)
{
  __int64 v1; // rdx
  __int64 *v2; // rax

  if ( a1 )
  {
    v1 = *a1;
    v2 = (__int64 *)a1[1];
    *v2 = *a1;
    *(_QWORD *)(v1 + 8) = v2;
    sub_180A0((__int64)qword_30CF8, (__int64)a1);
  }
}

//----- (00000000000173B8) ----------------------------------------------------
__int64 __fastcall sub_173B8(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+88h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2BAB8(a1, 43i64, &unk_29C08, 12i64, &v5);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000017418) ----------------------------------------------------
__int64 __fastcall sub_17418(__int64 a1, _DWORD *a2)
{
  _DWORD *v2; // r12
  unsigned int v4; // ebp
  __int64 v6; // rbx
  unsigned __int16 v7; // dx
  unsigned __int16 v8; // cx
  unsigned __int16 v9; // ax
  bool v10; // zf
  char v11; // cl
  unsigned int v12; // er8
  void **v13; // rcx
  unsigned __int8 v14; // dl
  __int64 *v15; // r13
  __int64 *v16; // rax
  unsigned __int16 v17; // dx
  _DWORD *v18; // rax
  __int64 v19; // rdx
  unsigned __int16 v20; // [rsp+30h] [rbp-48h]
  char v21; // [rsp+80h] [rbp+8h]
  _DWORD *v22; // [rsp+88h] [rbp+10h]
  unsigned __int16 v23; // [rsp+90h] [rbp+18h]
  unsigned __int16 v24; // [rsp+98h] [rbp+20h]

  v22 = a2;
  v2 = a2;
  v4 = 0;
  if ( !a1 || !*((_DWORD *)Dst + 46) || !dword_31DD0 )
    return v4;
  if ( !(unsigned int)sub_17A88(a1) )
  {
    sub_188F0(&stru_31D00);
    v6 = sub_17948(*(_WORD *)(a1 + 16), *(_DWORD *)(a1 + 18));
    if ( !v6 )
      goto LABEL_52;
    v7 = *(_WORD *)(a1 + 25) - *(unsigned __int8 *)(a1 + 27);
    v8 = *(_WORD *)(a1 + 23);
    v20 = v7;
    v24 = v8;
    v9 = v7 + v8 - 1;
    v23 = v9;
    if ( (*(_BYTE *)(a1 + 28) & 1) != 0 || (v10 = v8 == 0, v11 = 1, v10) )
      v11 = 0;
    v12 = *(_DWORD *)(v6 + 44);
    v21 = v11;
    if ( v12 )
    {
      if ( v11 )
      {
        v13 = (void **)off_2B148;
        if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 236) & 2) == 0 || *((_BYTE *)off_2B148 + 233) < 4u )
          goto LABEL_27;
        sub_11008(*((_QWORD *)off_2B148 + 27), 0xBu, (__int64)&unk_29C08);
        goto LABEL_26;
      }
      if ( v9 > v12 || *(_DWORD *)(v6 + 40) + (unsigned int)v7 > v12 )
      {
        v13 = (void **)off_2B148;
        if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 236) & 2) == 0 || *((_BYTE *)off_2B148 + 233) < 4u )
          goto LABEL_27;
        sub_173B8(*((_QWORD *)off_2B148 + 27), 12i64, (__int64)&unk_29C08, v9);
LABEL_26:
        v13 = (void **)off_2B148;
LABEL_27:
        v4 = 1;
        goto LABEL_29;
      }
    }
    v13 = (void **)off_2B148;
LABEL_29:
    v14 = *(_BYTE *)(v6 + 56);
    if ( v14 && v14 != *(_BYTE *)(a1 + 27) )
    {
      if ( v13 != &off_2B148 && (*((_BYTE *)v13 + 236) & 2) != 0 && *((_BYTE *)v13 + 233) >= 4u )
      {
        sub_11D0C((__int64)v13[27], 0xDu, (__int64)&unk_29C08, v14);
        v13 = (void **)off_2B148;
      }
      v4 = 1;
    }
    if ( !v4 )
    {
      v15 = (__int64 *)(v6 + 16);
      v16 = *(__int64 **)(v6 + 16);
      if ( v16 == (__int64 *)(v6 + 16) )
      {
LABEL_45:
        if ( v21 )
          *(_DWORD *)(v6 + 44) = v23 + 1;
        *(_QWORD *)(v6 + 48) = *(_QWORD *)(a1 + 8);
        if ( !*(_BYTE *)(v6 + 56) )
          *(_BYTE *)(v6 + 56) = *(_BYTE *)(a1 + 27);
        *(_DWORD *)(v6 + 40) += v20;
        if ( *(_DWORD *)(v6 + 40) != *(_DWORD *)(v6 + 44) )
        {
          v18 = sub_18038((__int64)qword_31DE0);
          v2 = v22;
          if ( v18 )
          {
            *((_WORD *)v18 + 8) = v24;
            *((_WORD *)v18 + 9) = v23;
            v19 = *v15;
            *(_QWORD *)v18 = *v15;
            *((_QWORD *)v18 + 1) = v15;
            *(_QWORD *)(v19 + 8) = v18;
            *v15 = (__int64)v18;
          }
          goto LABEL_52;
        }
        sub_17A14((_QWORD *)v6);
      }
      else
      {
        while ( 1 )
        {
          if ( v24 > *((_WORD *)v16 + 8) )
            goto LABEL_41;
          if ( *((_WORD *)v16 + 8) <= v23 )
            break;
          if ( v24 >= *((_WORD *)v16 + 8) )
          {
LABEL_41:
            if ( v24 <= *((_WORD *)v16 + 9) )
              break;
          }
          if ( v21 && *((_WORD *)v16 + 9) >= v24 )
          {
            if ( v13 != &off_2B148 && (*((_BYTE *)v13 + 236) & 2) != 0 && *((_BYTE *)v13 + 233) >= 4u )
            {
              v17 = 15;
              goto LABEL_63;
            }
            goto LABEL_64;
          }
          v16 = (__int64 *)*v16;
          if ( v16 == v15 )
            goto LABEL_45;
        }
        if ( v13 != &off_2B148 && (*((_BYTE *)v13 + 236) & 2) != 0 && *((_BYTE *)v13 + 233) >= 4u )
        {
          v17 = 14;
LABEL_63:
          sub_11008((__int64)v13[27], v17, (__int64)&unk_29C08);
        }
LABEL_64:
        v4 = 1;
      }
    }
    v2 = v22;
LABEL_52:
    sub_189BC(&stru_31D00);
    if ( v4 )
    {
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
        sub_11008(*((_QWORD *)off_2B148 + 27), 0x10u, (__int64)&unk_29C08);
      sub_142A8(a1);
      *v2 = 4;
    }
    return v4;
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 27), 0xAu, (__int64)&unk_29C08);
  sub_142A8(a1);
  *v2 = 4;
  return 1i64;
}
// 2B148: using guessed type void *off_2B148;
// 31DD0: using guessed type int dword_31DD0;

//----- (000000000001782C) ----------------------------------------------------
__int64 sub_1782C()
{
  _QWORD *v0; // rcx
  unsigned __int16 v1; // dx

  if ( !dword_31DD0 )
  {
    qword_31DD8 = sub_17E94(2, 0x40u, 0x64724649u);
    if ( !qword_31DD8 )
    {
      v0 = off_2B148;
      if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 236) & 1) == 0 || *((_BYTE *)off_2B148 + 233) < 2u )
        return 0i64;
      v1 = 17;
LABEL_7:
      sub_11008(v0[27], v1, (__int64)&unk_29C08);
      return 0i64;
    }
    qword_31DE0 = sub_17E94(2, 0x18u, 0x64724649u);
    if ( !qword_31DE0 )
    {
      v0 = off_2B148;
      if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 236) & 1) == 0 || *((_BYTE *)off_2B148 + 233) < 2u )
        return 0i64;
      v1 = 18;
      goto LABEL_7;
    }
    sub_18810((__int64)&stru_31D00);
    dword_31DD0 = 1;
    qword_31D40 = (__int64)&qword_31D38;
    qword_31D38 = (__int64)&qword_31D38;
  }
  return 1i64;
}
// 2B148: using guessed type void *off_2B148;
// 31D38: using guessed type __int64 qword_31D38;
// 31D40: using guessed type __int64 qword_31D40;
// 31DD0: using guessed type int dword_31DD0;

//----- (0000000000017948) ----------------------------------------------------
__int64 __fastcall sub_17948(__int16 a1, int a2)
{
  __int64 v2; // rax
  __int64 v5; // rbx
  _DWORD *v6; // rax
  __int64 v7; // rax

  v2 = qword_31D38;
  if ( (__int64 *)qword_31D38 == &qword_31D38 )
    goto LABEL_6;
  do
  {
    v5 = v2;
    if ( *(_WORD *)(v2 + 32) == a1 && *(_DWORD *)(v2 + 36) == a2 )
      break;
    v2 = *(_QWORD *)v2;
    v5 = 0i64;
  }
  while ( (__int64 *)v2 != &qword_31D38 );
  if ( !v5 )
  {
LABEL_6:
    v6 = sub_18038((__int64)qword_31DD8);
    v5 = (__int64)v6;
    if ( v6 )
    {
      memset(v6, 0, 0x40ui64);
      *(_WORD *)(v5 + 32) = a1;
      *(_DWORD *)(v5 + 36) = a2;
      *(_QWORD *)(v5 + 24) = v5 + 16;
      *(_QWORD *)(v5 + 16) = v5 + 16;
      *(_QWORD *)(v5 + 48) = MEMORY[0xFFFFF78000000014];
      v7 = qword_31D38;
      *(_QWORD *)(v5 + 8) = &qword_31D38;
      *(_QWORD *)v5 = v7;
      *(_QWORD *)(v7 + 8) = v5;
      qword_31D38 = v5;
    }
  }
  return v5;
}
// 31D38: using guessed type __int64 qword_31D38;

//----- (0000000000017A14) ----------------------------------------------------
void __fastcall sub_17A14(_QWORD *a1)
{
  __int64 **v2; // rdi
  __int64 *v3; // rdx
  PVOID v4; // rcx
  __int64 v5; // r8
  _QWORD *v6; // rax
  __int64 v7; // rcx
  _QWORD *v8; // rax

  v2 = (__int64 **)(a1 + 2);
  while ( *v2 != (__int64 *)v2 )
  {
    v3 = *v2;
    v4 = qword_31DE0;
    v5 = **v2;
    v6 = (_QWORD *)(*v2)[1];
    *v6 = v5;
    *(_QWORD *)(v5 + 8) = v6;
    sub_180A0((__int64)v4, (__int64)v3);
  }
  v7 = *a1;
  v8 = (_QWORD *)a1[1];
  *v8 = *a1;
  *(_QWORD *)(v7 + 8) = v8;
  sub_180A0((__int64)qword_31DD8, (__int64)a1);
}

//----- (0000000000017A88) ----------------------------------------------------
__int64 __fastcall sub_17A88(__int64 a1)
{
  unsigned int v1; // edx
  unsigned __int16 v2; // r8
  _QWORD *v3; // rcx
  int v4; // er9
  unsigned __int16 v5; // dx
  unsigned __int16 v6; // r8

  v1 = 0;
  if ( (*(_BYTE *)(a1 + 28) & 2) != 0 )
  {
    v2 = *(_WORD *)(a1 + 23);
    if ( v2 )
    {
      v3 = off_2B148;
      if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 236) & 2) == 0 || *((_BYTE *)off_2B148 + 233) < 4u )
        return 1;
      v4 = v2;
      v5 = 19;
LABEL_17:
      sub_11B10(v3[27], v5, (__int64)&unk_29C08, v4);
      return 1;
    }
  }
  v6 = *(_WORD *)(a1 + 25);
  if ( v6 <= *(unsigned __int8 *)(a1 + 27) )
  {
    if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 236) & 2) != 0 && *((_BYTE *)off_2B148 + 233) >= 4u )
      sub_11D0C(*((_QWORD *)off_2B148 + 27), 0x14u, (__int64)&unk_29C08, v6);
    return 1;
  }
  v4 = *(unsigned __int16 *)(a1 + 23) + v6 + 14;
  if ( v4 >= 65550 )
  {
    v3 = off_2B148;
    if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 236) & 2) == 0 || *((_BYTE *)off_2B148 + 233) < 4u )
      return 1;
    v5 = 21;
    goto LABEL_17;
  }
  return v1;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000017BA8) ----------------------------------------------------
__int64 __fastcall sub_17BA8(__int64 a1, unsigned __int16 a2)
{
  strlen(aUnknownModule);
  return qword_2BAB8(a1, 43i64, &unk_29BF8, a2, aUnknownModule);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000017C28) ----------------------------------------------------
PVOID __fastcall sub_17C28(int a1, unsigned int a2, ULONG a3)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 4) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_17BA8(*((_QWORD *)off_2B148 + 11), 0xAu);
  return sub_18E1C(a1, a2, a3);
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000017CAC) ----------------------------------------------------
void __fastcall sub_17CAC(PVOID P, ULONG Tag)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 4) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_17BA8(*((_QWORD *)off_2B148 + 11), 0xBu);
  sub_18F38(P, Tag);
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000017D20) ----------------------------------------------------
PVOID __fastcall sub_17D20(__int64 a1, void *a2, unsigned int a3, unsigned int a4)
{
  size_t v5; // rsi
  void **v7; // rcx
  PVOID v8; // rax
  PVOID v9; // rbx

  v5 = a3;
  v7 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 108) & 4) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    {
      sub_17BA8(*((_QWORD *)off_2B148 + 11), 0xCu);
      v7 = (void **)off_2B148;
    }
    if ( v7 != &off_2B148 )
    {
      if ( (*((_BYTE *)v7 + 108) & 2) != 0 && *((_BYTE *)v7 + 105) >= 4u )
      {
        sub_11008((__int64)v7[11], 0x10u, (__int64)&unk_29BE8);
        v7 = (void **)off_2B148;
      }
      if ( v7 != &off_2B148 && (*((_BYTE *)v7 + 108) & 4) != 0 && *((_BYTE *)v7 + 105) >= 6u )
        sub_18CF0((__int64)v7[11], 17i64, (__int64)&unk_29BE8, (int)a2);
    }
  }
  v8 = sub_18E1C(1, a4, 0x706D744Eu);
  v9 = v8;
  if ( v8 && a2 )
  {
    memmove(v8, a2, v5);
    sub_18F38(a2, 0x706D744Eu);
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11B10(*((_QWORD *)off_2B148 + 11), 0x12u, (__int64)&unk_29BE8, (int)v9);
  return v9;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000017E94) ----------------------------------------------------
char *__fastcall sub_17E94(int a1, unsigned int a2, ULONG a3)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 4) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_17BA8(*((_QWORD *)off_2B148 + 11), 0xDu);
  return sub_19030(a1, a2, a3);
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000017F18) ----------------------------------------------------
void __fastcall sub_17F18(PVOID P)
{
  void **v2; // rcx

  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 108) & 4) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    {
      sub_17BA8(*((_QWORD *)off_2B148 + 11), 0xEu);
      v2 = (void **)off_2B148;
    }
    if ( v2 != &off_2B148 )
    {
      if ( (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      {
        sub_11008((__int64)v2[11], 0x16u, (__int64)&unk_29BE8);
        v2 = (void **)off_2B148;
      }
      if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 108) & 4) != 0 && *((_BYTE *)v2 + 105) >= 5u )
        sub_11008((__int64)v2[11], 0x17u, (__int64)&unk_29BE8);
    }
  }
  if ( *(_DWORD *)P == 2 )
  {
    ExDeleteNPagedLookasideList((PNPAGED_LOOKASIDE_LIST)((char *)P + 64));
  }
  else if ( *(_DWORD *)P == 1 )
  {
    ExDeletePagedLookasideList((PPAGED_LOOKASIDE_LIST)((char *)P + 64));
  }
  sub_18F38(P, *((_DWORD *)P + 2));
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x18u, (__int64)&unk_29BE8);
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000018038) ----------------------------------------------------
_DWORD *__fastcall sub_18038(__int64 a1)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 4) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_17BA8(*((_QWORD *)off_2B148 + 11), 0xFu);
  return sub_191E4(a1);
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000180A0) ----------------------------------------------------
void __fastcall sub_180A0(__int64 a1, __int64 a2)
{
  void **v4; // rcx
  struct _SLIST_ENTRY *v5; // rdi

  v4 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 108) & 4) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    {
      sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x10u);
      v4 = (void **)off_2B148;
    }
    if ( v4 != &off_2B148 && (*((_BYTE *)v4 + 108) & 2) != 0 && *((_BYTE *)v4 + 105) >= 4u )
    {
      sub_11008((__int64)v4[11], 0x1Bu, (__int64)&unk_29BE8);
      v4 = (void **)off_2B148;
    }
  }
  v5 = (struct _SLIST_ENTRY *)(a2 - 4);
  if ( LODWORD(v5->Next) )
  {
    if ( LODWORD(v5->Next) == 1 )
    {
      sub_18F38(v5, *(_DWORD *)(a1 + 8));
LABEL_18:
      v4 = (void **)off_2B148;
      goto LABEL_19;
    }
  }
  else if ( *(_DWORD *)a1 == 2 || *(_DWORD *)a1 == 1 )
  {
    ++*(_DWORD *)(a1 + 92);
    if ( ExQueryDepthSList((PSLIST_HEADER)(a1 + 64)) < *(_WORD *)(a1 + 80) )
    {
      ExpInterlockedPushEntrySList((PSLIST_HEADER)(a1 + 64), v5);
    }
    else
    {
      ++*(_DWORD *)(a1 + 96);
      (*(void (__fastcall **)(struct _SLIST_ENTRY *))(a1 + 120))(v5);
    }
    goto LABEL_18;
  }
LABEL_19:
  if ( v4 != &off_2B148 && (*((_BYTE *)v4 + 108) & 2) != 0 && *((_BYTE *)v4 + 105) >= 4u )
    sub_11008((__int64)v4[11], 0x1Cu, (__int64)&unk_29BE8);
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000181CC) ----------------------------------------------------
__int64 __fastcall sub_181CC(PERESOURCE Resource)
{
  void **v2; // rcx
  int v3; // eax
  unsigned int v4; // ebx

  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 108) & 0x20) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    {
      sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x12u);
      v2 = (void **)off_2B148;
    }
    if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x1Fu, (__int64)&unk_29BE8);
  }
  v3 = ExInitializeResourceLite(Resource);
  v4 = v3;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11B10(*((_QWORD *)off_2B148 + 11), 0x20u, (__int64)&unk_29BE8, v3);
  return v4;
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000182A0) ----------------------------------------------------
__int64 __fastcall sub_182A0(PERESOURCE Resource)
{
  void **v2; // rcx
  int v3; // eax
  unsigned int v4; // ebx

  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 108) & 0x20) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    {
      sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x13u);
      v2 = (void **)off_2B148;
    }
    if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x21u, (__int64)&unk_29BE8);
  }
  v3 = ExDeleteResourceLite(Resource);
  v4 = v3;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11B10(*((_QWORD *)off_2B148 + 11), 0x22u, (__int64)&unk_29BE8, v3);
  return v4;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000018374) ----------------------------------------------------
BOOLEAN __fastcall sub_18374(PERESOURCE Resource)
{
  void **v2; // rcx
  BOOLEAN v3; // al
  BOOLEAN v4; // bl

  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 108) & 0x20) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    {
      sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x15u);
      v2 = (void **)off_2B148;
    }
    if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x25u, (__int64)&unk_29BE8);
  }
  v3 = ExAcquireResourceExclusiveLite(Resource, 1u);
  v4 = v3;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11B10(*((_QWORD *)off_2B148 + 11), 0x26u, (__int64)&unk_29BE8, v3);
  return v4;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001844C) ----------------------------------------------------
BOOLEAN __fastcall sub_1844C(PERESOURCE Resource)
{
  void **v2; // rcx
  BOOLEAN v3; // al
  BOOLEAN v4; // bl

  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 108) & 0x20) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    {
      sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x16u);
      v2 = (void **)off_2B148;
    }
    if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x27u, (__int64)&unk_29BE8);
  }
  v3 = ExAcquireResourceSharedLite(Resource, 1u);
  v4 = v3;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11B10(*((_QWORD *)off_2B148 + 11), 0x28u, (__int64)&unk_29BE8, v3);
  return v4;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000018524) ----------------------------------------------------
void __fastcall sub_18524(PERESOURCE Resource)
{
  void **v2; // rcx

  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 108) & 0x20) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    {
      sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x18u);
      v2 = (void **)off_2B148;
    }
    if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x2Bu, (__int64)&unk_29BE8);
  }
  ExReleaseResourceLite(Resource);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x2Cu, (__int64)&unk_29BE8);
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000185F0) ----------------------------------------------------
void __fastcall sub_185F0(PKSPIN_LOCK SpinLock, KIRQL *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 0x20) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x1Bu);
  sub_1936C(SpinLock, a2);
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000018668) ----------------------------------------------------
void __fastcall sub_18668(PKSPIN_LOCK SpinLock, KIRQL a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 0x20) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x1Cu);
  sub_19424(SpinLock, a2);
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000186DC) ----------------------------------------------------
int __fastcall sub_186DC(PRKEVENT Event)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 0x20) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x1Fu);
  return sub_19648(Event);
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000018744) ----------------------------------------------------
int __fastcall sub_18744(PRKEVENT Event)
{
  void **v2; // rcx
  int result; // eax

  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 108) & 0x20) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    {
      sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x20u);
      v2 = (void **)off_2B148;
    }
    if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x3Bu, (__int64)&unk_29BE8);
  }
  result = KeResetEvent(Event);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    result = sub_11008(*((_QWORD *)off_2B148 + 11), 0x3Cu, (__int64)&unk_29BE8);
  return result;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000018810) ----------------------------------------------------
void __fastcall sub_18810(__int64 a1)
{
  void **v2; // rcx

  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 108) & 0x20) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    {
      sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x21u);
      v2 = (void **)off_2B148;
    }
    if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x3Du, (__int64)&unk_29BE8);
  }
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 1;
  KeInitializeEvent((PRKEVENT)(a1 + 24), SynchronizationEvent, 0);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x3Eu, (__int64)&unk_29BE8);
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000188F0) ----------------------------------------------------
void __fastcall sub_188F0(PFAST_MUTEX FastMutex)
{
  void **v2; // rcx

  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 108) & 0x20) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    {
      sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x22u);
      v2 = (void **)off_2B148;
    }
    if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x3Fu, (__int64)&unk_29BE8);
  }
  ExAcquireFastMutex(FastMutex);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x40u, (__int64)&unk_29BE8);
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000189BC) ----------------------------------------------------
void __fastcall sub_189BC(PFAST_MUTEX FastMutex)
{
  void **v2; // rcx

  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 108) & 0x20) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    {
      sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x24u);
      v2 = (void **)off_2B148;
    }
    if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
      sub_11008((__int64)v2[11], 0x43u, (__int64)&unk_29BE8);
  }
  ExReleaseFastMutex(FastMutex);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x44u, (__int64)&unk_29BE8);
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000018A88) ----------------------------------------------------
_QWORD *sub_18A88()
{
  PVOID v0; // rsi
  void **v1; // rcx
  _QWORD *v2; // rbx
  _QWORD *v3; // rdi

  v0 = qword_31D58;
  v1 = (void **)off_2B148;
  v2 = 0i64;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 108) < 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
  {
    sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x2Eu);
    v1 = (void **)off_2B148;
  }
  v3 = 0i64;
  if ( v1 != &off_2B148 && (*((_BYTE *)v1 + 108) & 2) != 0 && *((_BYTE *)v1 + 105) >= 4u )
  {
    sub_11008((__int64)v1[11], 0x68u, (__int64)&unk_29BE8);
    v1 = (void **)off_2B148;
  }
  if ( v0 && sub_13858 )
  {
    v3 = sub_18E1C(2, 0x2Cu, 0x6E635749u);
LABEL_16:
    if ( v3 )
    {
      memset(v3, 0, 0x2Cui64);
      v3[4] = 0i64;
      v2 = v3 + 5;
      v3[1] = v3;
      *v3 = v3;
      v3[3] = sub_13858;
      v3[2] = v0;
    }
    v1 = (void **)off_2B148;
    goto LABEL_19;
  }
  if ( v1 == &off_2B148 )
    return v2;
  if ( *((char *)v1 + 108) < 0 && *((_BYTE *)v1 + 105) >= 3u )
  {
    sub_11008((__int64)v1[11], 0x69u, (__int64)&unk_29BE8);
    goto LABEL_16;
  }
LABEL_19:
  if ( v1 != &off_2B148 && (*((_BYTE *)v1 + 108) & 2) != 0 && *((_BYTE *)v1 + 105) >= 4u )
    sub_11B10((__int64)v1[11], 0x6Au, (__int64)&unk_29BE8, (int)v2);
  return v2;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000018BF4) ----------------------------------------------------
void __fastcall sub_18BF4(__int64 a1)
{
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 108) < 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x30u);
  sub_1A2C0(a1);
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000018C60) ----------------------------------------------------
__int64 __fastcall sub_18C60(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+B8h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2BAB8(a1, 43i64, &unk_29BE8, 14i64, &v5);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000018CF0) ----------------------------------------------------
__int64 __fastcall sub_18CF0(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+C8h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2BAB8(a1, 43i64, &unk_29BE8, 17i64, &v5);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000018D8C) ----------------------------------------------------
__int64 __fastcall sub_18D8C(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+B8h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2BAB8(a1, 43i64, &unk_29BE8, 11i64, &v5);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000018E1C) ----------------------------------------------------
PVOID __fastcall sub_18E1C(int a1, unsigned int a2, ULONG a3)
{
  SIZE_T v4; // rdi
  void **v6; // rcx
  PVOID v7; // rax
  PVOID v8; // rbx

  v4 = a2;
  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    {
      sub_11008(*((_QWORD *)off_2B148 + 11), 0xAu, (__int64)&unk_29BE8);
      v6 = (void **)off_2B148;
    }
    if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 108) & 4) != 0 && *((_BYTE *)v6 + 105) >= 6u )
      sub_18D8C((__int64)v6[11], 11i64, (__int64)&unk_29BE8, v4);
  }
  v7 = ExAllocatePoolWithTag((POOL_TYPE)(a1 != 2), v4, a3);
  v8 = v7;
  if ( v7 )
    memset(v7, 0, v4);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11B10(*((_QWORD *)off_2B148 + 11), 0xCu, (__int64)&unk_29BE8, (int)v8);
  return v8;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000018F38) ----------------------------------------------------
void __fastcall sub_18F38(PVOID P, ULONG Tag)
{
  void **v4; // rcx

  v4 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    {
      sub_11008(*((_QWORD *)off_2B148 + 11), 0xDu, (__int64)&unk_29BE8);
      v4 = (void **)off_2B148;
    }
    if ( v4 != &off_2B148 && (*((_BYTE *)v4 + 108) & 4) != 0 && *((_BYTE *)v4 + 105) >= 6u )
    {
      sub_18C60((__int64)v4[11], 14i64, (__int64)&unk_29BE8, (int)P);
      v4 = (void **)off_2B148;
    }
  }
  if ( P )
  {
    ExFreePoolWithTag(P, Tag);
    v4 = (void **)off_2B148;
  }
  if ( v4 != &off_2B148 && (*((_BYTE *)v4 + 108) & 2) != 0 && *((_BYTE *)v4 + 105) >= 4u )
    sub_11008((__int64)v4[11], 0xFu, (__int64)&unk_29BE8);
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000019030) ----------------------------------------------------
char *__fastcall sub_19030(int a1, unsigned int a2, ULONG a3)
{
  __int64 v4; // rsi
  char *v5; // rbx
  void **v7; // rcx
  bool v8; // dl
  char *v9; // rax

  v4 = a2;
  v5 = 0i64;
  v7 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x13u, (__int64)&unk_29BE8);
    v7 = (void **)off_2B148;
  }
  v8 = (_DWORD)v4 != 0;
  if ( a1 != 2 && a1 != 1 )
    v8 = 0;
  if ( v8 )
  {
    v9 = (char *)sub_18E1C(2, 0xC0u, a3);
    v5 = v9;
    if ( v9 )
    {
      memset(v9, 0, 0xC0ui64);
      *((_DWORD *)v5 + 1) = v4;
      *(_DWORD *)v5 = a1;
      *((_DWORD *)v5 + 2) = a3;
      v7 = (void **)off_2B148;
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 4) != 0 && *((_BYTE *)off_2B148 + 105) >= 5u )
      {
        sub_11008(*((_QWORD *)off_2B148 + 11), 0x14u, (__int64)&unk_29BE8);
        v7 = (void **)off_2B148;
      }
      if ( *(_DWORD *)v5 == 2 )
      {
        ExInitializeNPagedLookasideList((PNPAGED_LOOKASIDE_LIST)(v5 + 64), 0i64, 0i64, 0, v4 + 7, a3, 0);
        v7 = (void **)off_2B148;
      }
      if ( *(_DWORD *)v5 == 1 )
      {
        ExInitializePagedLookasideList((PPAGED_LOOKASIDE_LIST)(v5 + 64), 0i64, 0i64, 0, v4 + 7, a3, 0);
        v7 = (void **)off_2B148;
      }
    }
    else
    {
      v7 = (void **)off_2B148;
    }
  }
  if ( v7 != &off_2B148 && (*((_BYTE *)v7 + 108) & 2) != 0 && *((_BYTE *)v7 + 105) >= 4u )
    sub_11B10((__int64)v7[11], 0x15u, (__int64)&unk_29BE8, (int)v5);
  return v5;
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000191E4) ----------------------------------------------------
_DWORD *__fastcall sub_191E4(__int64 a1)
{
  _DWORD *v2; // rbx
  _DWORD *v3; // rax

  v2 = 0i64;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x19u, (__int64)&unk_29BE8);
  if ( (*(_DWORD *)a1 == 2 || *(_DWORD *)a1 == 1)
    && ((++*(_DWORD *)(a1 + 84), (v3 = ExpInterlockedPopEntrySList((PSLIST_HEADER)(a1 + 64))) != 0i64)
     || (++*(_DWORD *)(a1 + 88),
         (v3 = (_DWORD *)(*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(a1 + 112))(
                           *(unsigned int *)(a1 + 100),
                           *(unsigned int *)(a1 + 108),
                           *(unsigned int *)(a1 + 104))) != 0i64)) )
  {
    *v3 = 0;
  }
  else
  {
    v3 = sub_18E1C(*(_DWORD *)a1, *(_DWORD *)(a1 + 4) + 7, *(_DWORD *)(a1 + 8));
    if ( !v3 )
      goto LABEL_14;
    *v3 = 1;
  }
  v2 = v3 + 1;
  if ( v3 != (_DWORD *)-4i64 )
    memset(v3 + 1, 0, *(unsigned int *)(a1 + 4));
LABEL_14:
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11B10(*((_QWORD *)off_2B148 + 11), 0x1Au, (__int64)&unk_29BE8, (int)v2);
  return v2;
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000192E8) ----------------------------------------------------
__int64 __fastcall sub_192E8(_QWORD *a1)
{
  __int64 result; // rax

  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    result = sub_11008(*((_QWORD *)off_2B148 + 11), 0x2Fu, (__int64)&unk_29BE8);
  *a1 = 0i64;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    result = sub_11008(*((_QWORD *)off_2B148 + 11), 0x30u, (__int64)&unk_29BE8);
  return result;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001936C) ----------------------------------------------------
void __fastcall sub_1936C(PKSPIN_LOCK SpinLock, KIRQL *a2)
{
  unsigned __int8 v4; // si

  v4 = KeGetCurrentIrql();
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x31u, (__int64)&unk_29BE8);
  if ( v4 == 2 )
  {
    *a2 = 2;
    KeAcquireSpinLockAtDpcLevel(SpinLock);
  }
  else
  {
    *a2 = KeAcquireSpinLockRaiseToDpc(SpinLock);
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x32u, (__int64)&unk_29BE8);
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000019424) ----------------------------------------------------
void __fastcall sub_19424(PKSPIN_LOCK SpinLock, KIRQL a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x33u, (__int64)&unk_29BE8);
  if ( a2 == 2 )
    KeReleaseSpinLockFromDpcLevel(SpinLock);
  else
    KeReleaseSpinLock(SpinLock, a2);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x34u, (__int64)&unk_29BE8);
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000194C8) ----------------------------------------------------
bool __fastcall sub_194C8(struct _KEVENT **a1, char a2)
{
  struct _KEVENT *v4; // rax
  struct _KEVENT *v5; // rdi

  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x35u, (__int64)&unk_29BE8);
  *a1 = 0i64;
  v4 = (struct _KEVENT *)sub_18E1C(2, 0x18u, 0x6E634556u);
  v5 = v4;
  if ( v4 )
  {
    KeInitializeEvent(v4, (EVENT_TYPE)(a2 == 0), 0);
    *a1 = v5;
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11B10(*((_QWORD *)off_2B148 + 11), 0x36u, (__int64)&unk_29BE8, v5 != 0i64);
  return v5 != 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000195B0) ----------------------------------------------------
void __fastcall sub_195B0(PVOID P)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x37u, (__int64)&unk_29BE8);
  KeClearEvent((PRKEVENT)P);
  sub_18F38(P, 0x6E634556u);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x38u, (__int64)&unk_29BE8);
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000019648) ----------------------------------------------------
int __fastcall sub_19648(PRKEVENT Event)
{
  int result; // eax

  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x39u, (__int64)&unk_29BE8);
  result = KeSetEvent(Event, 0, 0);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    result = sub_11008(*((_QWORD *)off_2B148 + 11), 0x3Au, (__int64)&unk_29BE8);
  return result;
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000196D8) ----------------------------------------------------
void __fastcall HandleInformation(PVOID StartContext)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x49u, (__int64)&unk_29BE8);
  (*(void (__fastcall **)(_QWORD))StartContext)(*((_QWORD *)StartContext + 1));
  sub_18F38(StartContext, 0x6E635448u);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x4Au, (__int64)&unk_29BE8);
  PsTerminateSystemThread(0);
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000019774) ----------------------------------------------------
unsigned __int8 __fastcall sub_19774(PVOID *Object, __int64 a2, __int64 (__fastcall *a3)(void ***a1))
{
  unsigned __int8 v5; // bl
  __int64 (__fastcall **v6)(void ***); // rax
  __int64 (__fastcall **StartContext)(void ***); // rsi
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+40h] [rbp-48h] BYREF
  void *ThreadHandle; // [rsp+90h] [rbp+8h] BYREF

  v5 = 1;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x4Bu, (__int64)&unk_29BE8);
  v6 = (__int64 (__fastcall **)(void ***))sub_18E1C(2, 0x10u, 0x6E635448u);
  *Object = 0i64;
  StartContext = v6;
  if ( !v6 )
    goto LABEL_10;
  memset(&ObjectAttributes.RootDirectory, 0, 0x28ui64);
  ThreadHandle = 0i64;
  *StartContext = sub_19970;
  ObjectAttributes.Length = 48;
  StartContext[1] = a3;
  if ( !PsCreateSystemThread(
          &ThreadHandle,
          0x1F03FFu,
          &ObjectAttributes,
          0i64,
          0i64,
          (PKSTART_ROUTINE)HandleInformation,
          StartContext) )
  {
    ObReferenceObjectByHandle(ThreadHandle, 0, 0i64, 0, Object, 0i64);
    ZwClose(ThreadHandle);
  }
  if ( !*Object )
  {
    sub_18F38(StartContext, 0x6E635448u);
LABEL_10:
    v5 = 0;
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11B10(*((_QWORD *)off_2B148 + 11), 0x4Cu, (__int64)&unk_29BE8, v5);
  return v5;
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000198DC) ----------------------------------------------------
__int64 __fastcall sub_198DC(PVOID Object)
{
  void **v2; // rcx
  __int64 result; // rax

  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
  {
    result = sub_11008(*((_QWORD *)off_2B148 + 11), 0x4Du, (__int64)&unk_29BE8);
    v2 = (void **)off_2B148;
  }
  if ( Object )
  {
    result = ObfDereferenceObject(Object);
    v2 = (void **)off_2B148;
  }
  if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
    result = sub_11008((__int64)v2[11], 0x4Eu, (__int64)&unk_29BE8);
  return result;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000019970) ----------------------------------------------------
__int64 __fastcall sub_19970(void ***a1)
{
  void **v1; // r12
  __int64 v2; // rdi
  void *v4; // rax
  ULONG v5; // er14
  void *v6; // rdx
  void **v7; // r10
  unsigned int v8; // ebp
  __int64 v9; // rsi
  __int64 v10; // r13
  __int64 v11; // rsi
  _QWORD **v12; // rcx
  _QWORD *v13; // rbx
  _QWORD *v14; // rax
  char *v15; // rcx
  void (__fastcall *v16)(_QWORD *); // rax
  __int64 result; // rax
  void **v18; // rcx
  PVOID v19[2]; // [rsp+30h] [rbp-48h] BYREF
  __int64 v20; // [rsp+40h] [rbp-38h]
  KIRQL v21; // [rsp+80h] [rbp+8h] BYREF

  v1 = *a1;
  v2 = *((int *)a1 + 2);
  v4 = **a1;
  v5 = 2;
  v21 = 0;
  v19[0] = v4;
  v6 = (void *)*((_QWORD *)v1[3] + 3);
  v20 = 0i64;
  v19[1] = v6;
  v7 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x53u, (__int64)&unk_29BE8);
    v7 = (void **)off_2B148;
  }
  if ( *((_BYTE *)v1 + 12) )
  {
    v5 = 3;
    v20 = *((_QWORD *)v1[3] + 4 * (unsigned int)v2 + 3);
  }
  if ( a1[2] )
  {
    if ( v7 != &off_2B148 && *((char *)v7 + 108) < 0 && *((_BYTE *)v7 + 105) >= 5u )
      sub_11B10((__int64)v7[11], 0x54u, (__int64)&unk_29BE8, v2);
    sub_19648((PRKEVENT)a1[2]);
  }
  while ( 1 )
  {
    result = sub_1A44C(v5, v19);
    if ( !(_DWORD)result )
      break;
    v8 = 0;
    v9 = 0i64;
    if ( (_DWORD)result == 2 )
    {
      v8 = v2;
      v9 = v2;
    }
    if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 108) < 0 && *((_BYTE *)off_2B148 + 105) >= 5u )
      sub_11B10(*((_QWORD *)off_2B148 + 11), 0x56u, (__int64)&unk_29BE8, v2);
    v10 = 32i64 * v8;
    sub_1936C((PKSPIN_LOCK)((char *)v1[3] + v10), &v21);
    v11 = 32 * v9;
    v12 = (_QWORD **)((char *)v1[3] + v11 + 8);
    v13 = 0i64;
    if ( *v12 != v12 )
    {
      v13 = *v12;
      v14 = (_QWORD *)**v12;
      *v12 = v14;
      v14[1] = v12;
      if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 108) < 0 && *((_BYTE *)off_2B148 + 105) >= 5u )
        sub_11D0C(*((_QWORD *)off_2B148 + 11), 0x57u, (__int64)&unk_29BE8, v2);
      v15 = (char *)v1[3];
      if ( *(char **)&v15[v11 + 8] != &v15[v11 + 8] )
        sub_19648(*(PRKEVENT *)&v15[v11 + 24]);
    }
    sub_19424((PKSPIN_LOCK)((char *)v1[3] + v10), v21);
    if ( v13 )
    {
      if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 108) < 0 && *((_BYTE *)off_2B148 + 105) >= 5u )
        sub_11D0C(*((_QWORD *)off_2B148 + 11), 0x58u, (__int64)&unk_29BE8, v2);
      v16 = (void (__fastcall *)(_QWORD *))v13[3];
      if ( v16 )
        v16(v13 + 5);
      sub_1A1FC((__int64)(v13 + 5), 0);
      if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 108) < 0 && *((_BYTE *)off_2B148 + 105) >= 5u )
        sub_11D0C(*((_QWORD *)off_2B148 + 11), 0x59u, (__int64)&unk_29BE8, v2);
    }
  }
  v18 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( *((char *)off_2B148 + 108) < 0 && *((_BYTE *)off_2B148 + 105) >= 5u )
    {
      result = sub_11B10(*((_QWORD *)off_2B148 + 11), 0x55u, (__int64)&unk_29BE8, v2);
      v18 = (void **)off_2B148;
    }
    if ( v18 != &off_2B148 && (*((_BYTE *)v18 + 108) & 2) != 0 && *((_BYTE *)v18 + 105) >= 4u )
      result = sub_11008((__int64)v18[11], 0x5Au, (__int64)&unk_29BE8);
  }
  return result;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000019C7C) ----------------------------------------------------
__int64 sub_19C7C()
{
  int v0; // ebx
  PVOID v1; // rax
  __int64 v2; // rdi
  PVOID v3; // rax
  unsigned int v4; // esi
  _QWORD *v5; // r11
  __int64 v6; // r12
  unsigned int v7; // ebp
  PVOID *v8; // rcx
  __int64 v10; // [rsp+30h] [rbp-38h] BYREF
  unsigned int v11; // [rsp+38h] [rbp-30h]
  PVOID P; // [rsp+40h] [rbp-28h] BYREF

  v0 = 0;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x5Bu, (__int64)&unk_29BE8);
  v1 = sub_18E1C(2, 0x20u, 0x6E635450u);
  v2 = (__int64)v1;
  if ( v1
    && (memset(v1, 0, 0x20ui64),
        sub_194C8((struct _KEVENT **)v2, 1),
        *(_DWORD *)(v2 + 8) = 1,
        *(_BYTE *)(v2 + 12) = 0,
        *(_QWORD *)(v2 + 16) = sub_18E1C(2, 8u, 0x6E635450u),
        v3 = sub_18E1C(2, 0x20u, 0x6E635450u),
        *(_QWORD *)(v2 + 24) = v3,
        *(_QWORD *)(v2 + 16))
    && v3 )
  {
    v10 = v2;
    sub_194C8((struct _KEVENT **)&P, 0);
    **(_QWORD **)(v2 + 16) = 0i64;
    memset(*(void **)(v2 + 24), 0, 0x20ui64);
    sub_192E8(*(_QWORD **)(v2 + 24));
    sub_194C8((struct _KEVENT **)(*(_QWORD *)(v2 + 24) + 24i64), 0);
    v4 = 0;
    v5 = (_QWORD *)(*(_QWORD *)(v2 + 24) + 8i64);
    v6 = 0i64;
    v5[1] = v5;
    *v5 = v5;
    while ( 1 )
    {
      if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 108) < 0 && *((_BYTE *)off_2B148 + 105) >= 5u )
        sub_11D0C(*((_QWORD *)off_2B148 + 11), 0x5Cu, (__int64)&unk_29BE8, v4 + 1);
      v7 = v4 + 1;
      v8 = (PVOID *)(*(_QWORD *)(v2 + 16) + 8i64 * v4);
      v11 = v4 + 1;
      sub_19774(v8, (__int64)sub_19970, (__int64 (__fastcall *)(void ***))&v10);
      if ( !*(_QWORD *)(v6 + *(_QWORD *)(v2 + 16)) )
        break;
      sub_1A3A4(P);
      v6 += 8i64;
      ++v4;
      if ( v7 )
        goto LABEL_17;
    }
    v0 = -16777213;
LABEL_17:
    sub_195B0(P);
  }
  else
  {
    v0 = -16777213;
  }
  if ( v0 && v2 )
  {
    sub_19EA0((PVOID)v2);
    v2 = 0i64;
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11B10(*((_QWORD *)off_2B148 + 11), 0x5Du, (__int64)&unk_29BE8, v2);
  return v2;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000019EA0) ----------------------------------------------------
__int64 __fastcall sub_19EA0(PVOID P)
{
  void **v2; // rcx
  unsigned int v3; // eax
  __int64 v4; // rsi
  __int64 v5; // rbp
  __int64 v6; // r12
  void **v7; // rcx
  __int64 v8; // rdx
  _QWORD **v9; // rcx
  _QWORD *v10; // rdi
  _QWORD *v11; // rax
  unsigned int v12; // esi
  __int64 v13; // rdi
  __int64 v14; // rbp
  KIRQL v16; // [rsp+50h] [rbp+8h] BYREF

  v16 = 0;
  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x5Eu, (__int64)&unk_29BE8);
    v2 = (void **)off_2B148;
  }
  if ( *((_BYTE *)P + 12) )
    v3 = *((_DWORD *)P + 2) + 1;
  else
    v3 = 1;
  if ( v3 )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = v3;
    do
    {
      sub_1936C((PKSPIN_LOCK)(v5 + *((_QWORD *)P + 3)), &v16);
      v7 = (void **)off_2B148;
      if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 108) < 0 && *((_BYTE *)off_2B148 + 105) >= 5u )
      {
        sub_11008(*((_QWORD *)off_2B148 + 11), 0x5Fu, (__int64)&unk_29BE8);
        v7 = (void **)off_2B148;
      }
      v8 = *((_QWORD *)P + 3);
      if ( *(_QWORD *)(v4 + v8 + 8) != v4 + v8 + 8 )
      {
        do
        {
          v9 = (_QWORD **)(v4 + v8 + 8);
          v10 = *v9;
          v11 = (_QWORD *)**v9;
          *v9 = v11;
          v11[1] = v9;
          if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 108) < 0 && *((_BYTE *)off_2B148 + 105) >= 5u )
            sub_11B10(*((_QWORD *)off_2B148 + 11), 0x60u, (__int64)&unk_29BE8, (int)v10);
          sub_1A1FC((__int64)(v10 + 5), 1);
          v8 = *((_QWORD *)P + 3);
        }
        while ( *(_QWORD *)(v4 + v8 + 8) != v4 + v8 + 8 );
        v7 = (void **)off_2B148;
      }
      if ( v7 != &off_2B148 && *((char *)v7 + 108) < 0 && *((_BYTE *)v7 + 105) >= 5u )
        sub_11008((__int64)v7[11], 0x61u, (__int64)&unk_29BE8);
      sub_19424((PKSPIN_LOCK)(v5 + *((_QWORD *)P + 3)), v16);
      v5 += 32i64;
      v4 += 32i64;
      --v6;
    }
    while ( v6 );
    v2 = (void **)off_2B148;
  }
  if ( *(_QWORD *)P )
  {
    if ( v2 != &off_2B148 && *((char *)v2 + 108) < 0 && *((_BYTE *)v2 + 105) >= 5u )
      sub_11008((__int64)v2[11], 0x62u, (__int64)&unk_29BE8);
    sub_19648(*(PRKEVENT *)P);
    v2 = (void **)off_2B148;
  }
  if ( v2 != &off_2B148 && *((char *)v2 + 108) < 0 && *((_BYTE *)v2 + 105) >= 5u )
  {
    sub_11B10((__int64)v2[11], 0x63u, (__int64)&unk_29BE8, *((_DWORD *)P + 2));
    v2 = (void **)off_2B148;
  }
  v12 = 0;
  if ( *((_DWORD *)P + 2) )
  {
    v13 = 0i64;
    v14 = 32i64;
    do
    {
      if ( *(_QWORD *)(v13 + *((_QWORD *)P + 2)) )
      {
        if ( v2 != &off_2B148 && *((char *)v2 + 108) < 0 && *((_BYTE *)v2 + 105) >= 5u )
          sub_11B10((__int64)v2[11], 0x64u, (__int64)&unk_29BE8, v12);
        sub_1A3A4(*(PVOID *)(v13 + *((_QWORD *)P + 2)));
        if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 108) < 0 && *((_BYTE *)off_2B148 + 105) >= 5u )
          sub_11B10(*((_QWORD *)off_2B148 + 11), 0x65u, (__int64)&unk_29BE8, v12);
        sub_198DC(*(PVOID *)(v13 + *((_QWORD *)P + 2)));
        *(_QWORD *)(v13 + *((_QWORD *)P + 2)) = 0i64;
        if ( *((_BYTE *)P + 12) )
          sub_195B0(*(PVOID *)(*((_QWORD *)P + 3) + v14 + 24));
        v2 = (void **)off_2B148;
      }
      ++v12;
      v14 += 32i64;
      v13 += 8i64;
    }
    while ( v12 < *((_DWORD *)P + 2) );
  }
  if ( v2 != &off_2B148 && *((char *)v2 + 108) < 0 && *((_BYTE *)v2 + 105) >= 5u )
    sub_11008((__int64)v2[11], 0x66u, (__int64)&unk_29BE8);
  sub_195B0(*(PVOID *)(*((_QWORD *)P + 3) + 24i64));
  sub_195B0(*(PVOID *)P);
  sub_18F38(*((PVOID *)P + 2), 0x6E635450u);
  sub_18F38(*((PVOID *)P + 3), 0x6E635450u);
  sub_18F38(P, 0x6E635450u);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x67u, (__int64)&unk_29BE8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001A1FC) ----------------------------------------------------
void __fastcall sub_1A1FC(__int64 a1, char a2)
{
  void **v4; // rcx
  void (__fastcall *v5)(__int64); // rax

  v4 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x6Bu, (__int64)&unk_29BE8);
    v4 = (void **)off_2B148;
  }
  if ( a1 )
  {
    if ( a2 )
    {
      v5 = *(void (__fastcall **)(__int64))(a1 - 8);
      if ( v5 )
        v5(a1);
    }
    sub_18F38((PVOID)(a1 - 40), 0x6E635749u);
    v4 = (void **)off_2B148;
  }
  if ( v4 != &off_2B148 && (*((_BYTE *)v4 + 108) & 2) != 0 && *((_BYTE *)v4 + 105) >= 4u )
    sub_11008((__int64)v4[11], 0x6Cu, (__int64)&unk_29BE8);
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001A2C0) ----------------------------------------------------
void __fastcall sub_1A2C0(__int64 a1)
{
  void **v2; // rcx
  __int64 v3; // rdi
  _QWORD *v4; // rbx
  KSPIN_LOCK *v5; // rcx
  __int64 v6; // r11
  _QWORD *v7; // rax
  KIRQL v8; // [rsp+30h] [rbp+8h] BYREF

  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x6Du, (__int64)&unk_29BE8);
    v2 = (void **)off_2B148;
  }
  if ( a1 )
  {
    v3 = *(_QWORD *)(a1 - 24);
    v4 = (_QWORD *)(a1 - 40);
    v5 = *(KSPIN_LOCK **)(v3 + 24);
    v8 = 0;
    sub_1936C(v5, &v8);
    v6 = *(_QWORD *)(v3 + 24);
    v7 = *(_QWORD **)(v6 + 16);
    v6 += 8i64;
    v4[1] = v7;
    *v4 = v6;
    *v7 = v4;
    *(_QWORD *)(v6 + 8) = v4;
    sub_19648(*(PRKEVENT *)(*(_QWORD *)(v3 + 24) + 24i64));
    sub_19424(*(PKSPIN_LOCK *)(v3 + 24), v8);
    v2 = (void **)off_2B148;
  }
  if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 108) & 2) != 0 && *((_BYTE *)v2 + 105) >= 4u )
    sub_11008((__int64)v2[11], 0x6Eu, (__int64)&unk_29BE8);
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001A3A4) ----------------------------------------------------
__int64 __fastcall sub_1A3A4(PVOID Object)
{
  int v2; // eax
  unsigned int v3; // ebx

  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x6Fu, (__int64)&unk_29BE8);
  v2 = KeWaitForSingleObject(Object, Executive, 0, 0, 0i64);
  v3 = v2;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11B10(*((_QWORD *)off_2B148 + 11), 0x70u, (__int64)&unk_29BE8, v2);
  return v3;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001A44C) ----------------------------------------------------
__int64 __fastcall sub_1A44C(ULONG Count, PVOID Object[])
{
  struct _KWAIT_BLOCK *WaitBlockArray; // rdi
  unsigned int v6; // ebx

  WaitBlockArray = 0i64;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 11), 0x71u, (__int64)&unk_29BE8);
  if ( Count > 3 )
  {
    WaitBlockArray = (struct _KWAIT_BLOCK *)sub_18E1C(2, 48 * Count, 0x6E635742u);
    if ( !WaitBlockArray )
      return 4278190083i64;
  }
  v6 = KeWaitForMultipleObjects(Count, Object, WaitAny, Executive, 0, 0, 0i64, WaitBlockArray);
  if ( WaitBlockArray )
    sub_18F38(WaitBlockArray, 0x6E635742u);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 2) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_11B10(*((_QWORD *)off_2B148 + 11), 0x72u, (__int64)&unk_29BE8, v6);
  return v6;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001A558) ----------------------------------------------------
__int64 __fastcall sub_1A558(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+78h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2BAB8(a1, 43i64, a3, a2, &v5);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001A5A4) ----------------------------------------------------
__int64 sub_1A5A4()
{
  unsigned __int8 v0; // bl
  unsigned __int8 v2; // [rsp+48h] [rbp+10h]
  unsigned __int8 v3; // [rsp+50h] [rbp+18h]

  if ( off_2B148 != &off_2B148
    && _bittest((const signed __int32 *)off_2B148 + 43, 0x12u)
    && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11B10(*((_QWORD *)off_2B148 + 19), 0xAu, (__int64)&unk_29BC8, 1);
  }
  v0 = KeGetCurrentIrql();
  __writecr8(2ui64);
  v3 = 0;
  KeStallExecutionProcessor(1u);
  v2 = 0;
  __writecr8(v0);
  qword_31E08 = v2 - (unsigned __int64)v3;
  if ( off_2B148 != &off_2B148
    && _bittest((const signed __int32 *)off_2B148 + 43, 0x12u)
    && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_1A558(*((_QWORD *)off_2B148 + 19), 0xBu, (__int64)&unk_29BC8, 1);
  }
  KeQueryPerformanceCounter(&PerformanceFrequency);
  byte_31D62 = 1;
  if ( off_2B148 != &off_2B148
    && _bittest((const signed __int32 *)off_2B148 + 43, 0x12u)
    && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11B10(*((_QWORD *)off_2B148 + 19), 0xCu, (__int64)&unk_29BC8, 0);
  }
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;
// 31D62: using guessed type char byte_31D62;
// 31E08: using guessed type __int64 qword_31E08;

//----- (000000000001A6D8) ----------------------------------------------------
__int64 __fastcall sub_1A6D8(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+88h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2BAB8(a1, 43i64, a3, a2, &v5);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001A72C) ----------------------------------------------------
__int64 __fastcall sub_1A72C(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, __int64 a6, int a7)
{
  int v8; // [rsp+98h] [rbp+20h] BYREF

  v8 = a4;
  a7 = 0;
  return qword_2BAB8(a1, 43i64, &unk_29BB8, 125i64, &v8);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001A79C) ----------------------------------------------------
__int64 sub_1A79C(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2BAB8(a1, 43i64, &unk_29B00, a2, (__int64 *)va);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001A7E0) ----------------------------------------------------
__int64 __fastcall sub_1A7E0(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+98h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2BAB8(a1, 43i64, &unk_29BB8, 115i64, &v5);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001A850) ----------------------------------------------------
__int64 sub_1A850(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2BAB8(a1, 43i64, a3, a2, (__int64 *)va);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001A88C) ----------------------------------------------------
__int64 sub_1A88C(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2BAB8(a1, 43i64, a3, a2, (__int64 *)va);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001A8D8) ----------------------------------------------------
__int64 __fastcall sub_1A8D8(__int64 a1, __int64 a2, _QWORD *a3)
{
  bool v5; // r13
  void **v6; // rcx
  unsigned __int16 v7; // dx
  unsigned int v8; // edi
  int v9; // er9
  unsigned int v10; // eax
  _WORD *v11; // rdx
  char *v12; // rax
  char *v13; // rbx
  PVOID v14; // rax
  unsigned int v15; // edx
  __int64 v16; // r8
  _QWORD *v17; // rax
  char *v18; // rcx
  unsigned int *v19; // rbx
  unsigned int v20; // eax
  void *v21; // rcx

  v5 = 0;
  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148
    && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
    && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xAu, (__int64)&unk_29BB8);
    v6 = (void **)off_2B148;
  }
  if ( !a1 )
  {
    if ( v6 == &off_2B148 || !_bittest((const signed __int32 *)v6 + 43, 8u) || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_12;
    v7 = 11;
    goto LABEL_10;
  }
  v9 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 0xFF000000) != 0x2000000 || (v9 & 0xFFFF00) == 0 || (_BYTE)v9 )
  {
    if ( v6 != &off_2B148 && _bittest((const signed __int32 *)v6 + 43, 8u) && *((_BYTE *)v6 + 169) >= 2u )
    {
      sub_11B10((__int64)v6[19], 0xCu, (__int64)&unk_29BB8, v9);
      v6 = (void **)off_2B148;
    }
    v8 = 4;
    goto LABEL_63;
  }
  v10 = 0;
  v11 = (_WORD *)(a1 + 4);
  do
  {
    if ( !*v11 )
      break;
    ++v10;
    ++v11;
  }
  while ( v10 < 0x40 );
  if ( v10 >= 0x40 )
  {
    if ( v6 == &off_2B148 || !_bittest((const signed __int32 *)v6 + 43, 8u) || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_12;
    v7 = 13;
LABEL_10:
    sub_11008((__int64)v6[19], v7, (__int64)&unk_29BB8);
LABEL_11:
    v6 = (void **)off_2B148;
LABEL_12:
    v8 = 4;
    goto LABEL_67;
  }
  if ( !a3 || !*a3 )
  {
    if ( v6 == &off_2B148 || !_bittest((const signed __int32 *)v6 + 43, 8u) || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_12;
    sub_1A850((__int64)v6[19], 0xEu, (__int64)&unk_29BB8, a3);
    goto LABEL_11;
  }
  v12 = (char *)sub_17C28(2, 0x21Cu, 0x66634E4Eu);
  v13 = v12;
  qword_31E18 = v12;
  if ( !v12 )
  {
    v6 = (void **)off_2B148;
    if ( off_2B148 != &off_2B148 && _bittest((const signed __int32 *)off_2B148 + 43, 8u) && *((_BYTE *)off_2B148 + 169) )
    {
      sub_11B10(*((_QWORD *)off_2B148 + 19), 0xFu, (__int64)&unk_29BB8, 188);
      v6 = (void **)off_2B148;
      v13 = (char *)qword_31E18;
    }
    v8 = 3;
    goto LABEL_68;
  }
  memset(v12, 0, 0x21Cui64);
  if ( v13 == (char *)-128i64 )
  {
LABEL_39:
    v6 = (void **)off_2B148;
    if ( off_2B148 != &off_2B148 && _bittest((const signed __int32 *)off_2B148 + 43, 8u) && *((_BYTE *)off_2B148 + 169) )
    {
      sub_11008(*((_QWORD *)off_2B148 + 19), 0x10u, (__int64)&unk_29BB8);
      v6 = (void **)off_2B148;
      v13 = (char *)qword_31E18;
    }
    v8 = 9;
    goto LABEL_68;
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 0x20) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
    sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x1Du);
  v5 = sub_194C8((struct _KEVENT **)v13 + 23, 1);
  sub_18810((__int64)(v13 + 128));
  *((_DWORD *)v13 + 48) = 0;
  *((_DWORD *)v13 + 49) = 0;
  v13[200] = 0;
  if ( !v5 )
  {
    v13 = (char *)qword_31E18;
    goto LABEL_39;
  }
  v14 = sub_17C28(1, 4 * (unsigned int)*(unsigned __int8 *)(a1 + 136), 0x66634E4Eu);
  v13 = (char *)qword_31E18;
  *((_QWORD *)qword_31E18 + 26) = v14;
  if ( v14 )
  {
    v15 = 0;
    if ( *(_BYTE *)(a1 + 136) )
    {
      v16 = 0i64;
      do
      {
        *(_DWORD *)(v16 + *((_QWORD *)v13 + 26)) = *(_DWORD *)a1 | ++v15;
        v16 += 4i64;
      }
      while ( v15 < *(unsigned __int8 *)(a1 + 136) );
    }
    *(_DWORD *)v13 = 2;
    *((_DWORD *)v13 + 1) = 188;
    v13[8] = 0;
    *((_DWORD *)v13 + 4) = *(_DWORD *)a1;
    v13[20] = *(_BYTE *)(a1 + 136);
    *((_QWORD *)v13 + 3) = *((_QWORD *)v13 + 26);
    *((_QWORD *)v13 + 4) = sub_1B338;
    sub_181CC((PERESOURCE)(v13 + 216));
    v17 = (char *)qword_31E18 + 56;
    v18 = (char *)qword_31E18 + 72;
    *((_QWORD *)qword_31E18 + 8) = (char *)qword_31E18 + 56;
    *v17 = v17;
    sub_18810((__int64)v18);
    v19 = (unsigned int *)qword_31E18;
    memmove((char *)qword_31E18 + 320, a3, 0x20ui64);
    v20 = sub_2054C((__int16 *)(a1 + 4), *(_DWORD *)(a1 + 132), v19 + 4);
    v6 = (void **)off_2B148;
    v8 = v20;
LABEL_63:
    if ( !v8 )
      goto LABEL_72;
    v13 = (char *)qword_31E18;
    goto LABEL_65;
  }
  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && _bittest((const signed __int32 *)off_2B148 + 43, 8u) && *((_BYTE *)off_2B148 + 169) )
  {
    sub_11B10(*((_QWORD *)off_2B148 + 19), 0x11u, (__int64)&unk_29BB8, 4 * *(unsigned __int8 *)(a1 + 136));
    v6 = (void **)off_2B148;
    v13 = (char *)qword_31E18;
  }
  v8 = 3;
LABEL_65:
  if ( !v5 )
    goto LABEL_68;
  sub_26AE4((__int64)(v13 + 128));
  v6 = (void **)off_2B148;
LABEL_67:
  v13 = (char *)qword_31E18;
LABEL_68:
  if ( v13 )
  {
    v21 = (void *)*((_QWORD *)v13 + 26);
    if ( v21 )
    {
      sub_17CAC(v21, 0x66634E4Eu);
      v13 = (char *)qword_31E18;
    }
    sub_17CAC(v13, 0x66634E4Eu);
    v6 = (void **)off_2B148;
    qword_31E18 = 0i64;
  }
LABEL_72:
  if ( v6 != &off_2B148 && _bittest((const signed __int32 *)v6 + 43, 8u) && *((_BYTE *)v6 + 169) >= 5u )
    sub_11B10((__int64)v6[19], 0x12u, (__int64)&unk_29BB8, v8);
  return v8;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001AE50) ----------------------------------------------------
__int64 sub_1AE50()
{
  char v0; // di
  void **v1; // rcx
  PVOID v2; // rdx
  unsigned int v3; // ebx
  void *v4; // rcx
  int v5; // eax
  _QWORD *v6; // rax
  unsigned int v7; // eax
  PRKEVENT *v8; // rbx
  int v9; // eax

  v0 = 0;
  v1 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148
    && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
    && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x13u, (__int64)&unk_29BB8);
    v1 = (void **)off_2B148;
  }
  v2 = qword_31E18;
  if ( !qword_31E18 )
  {
    if ( v1 != &off_2B148 && _bittest((const signed __int32 *)v1 + 43, 8u) && *((_BYTE *)v1 + 169) >= 2u )
    {
      sub_11008((__int64)v1[19], 0x14u, (__int64)&unk_29BB8);
      v1 = (void **)off_2B148;
    }
    v3 = 16;
    goto LABEL_62;
  }
  if ( *((_QWORD *)qword_31E18 + 5) )
  {
    if ( v1 != &off_2B148 && _bittest((const signed __int32 *)v1 + 43, 8u) && *((_BYTE *)v1 + 169) >= 2u )
    {
      sub_11008((__int64)v1[19], 0x15u, (__int64)&unk_29BB8);
      v1 = (void **)off_2B148;
    }
    v3 = 6;
    goto LABEL_62;
  }
  v4 = (void *)*((_QWORD *)qword_31E18 + 26);
  if ( v4 )
  {
    sub_17CAC(v4, 0x66634E4Eu);
    v2 = qword_31E18;
    *((_QWORD *)qword_31E18 + 26) = 0i64;
  }
  v5 = sub_20D48(6u, (__int64)v2 + 40);
  v3 = v5;
  if ( v5 )
  {
    v1 = (void **)off_2B148;
    if ( off_2B148 != &off_2B148
      && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
      && *((_BYTE *)off_2B148 + 169) >= 2u )
    {
      sub_11B10(*((_QWORD *)off_2B148 + 19), 0x16u, (__int64)&unk_29BB8, v5);
      v1 = (void **)off_2B148;
    }
LABEL_54:
    if ( !v3 || !v0 )
      goto LABEL_62;
    sub_26B5C((PFAST_MUTEX)((char *)qword_31E18 + 128));
LABEL_26:
    v1 = (void **)off_2B148;
    goto LABEL_62;
  }
  v6 = (_QWORD *)*((_QWORD *)qword_31E18 + 5);
  if ( !v6 || !*v6 || !v6[1] || !v6[2] || !v6[3] || !v6[4] || !v6[5] || !v6[6] || !v6[7] || !v6[8] || !v6[9] || !v6[10] )
  {
    v3 = 2;
    goto LABEL_26;
  }
  v7 = ((__int64 (__fastcall *)(_QWORD, char *))*v6)(*((unsigned int *)qword_31E18 + 4), (char *)qword_31E18 + 48);
  if ( v7 < 0x700 )
  {
    v8 = (PRKEVENT *)((char *)qword_31E18 + 128);
    if ( qword_31E18 != (PVOID)-128i64
      && !*((_DWORD *)qword_31E18 + 48)
      && !*((_BYTE *)qword_31E18 + 200)
      && !*((_DWORD *)qword_31E18 + 49) )
    {
      sub_188F0((PFAST_MUTEX)((char *)qword_31E18 + 128));
      sub_186DC(v8[7]);
      v0 = 1;
      *((_BYTE *)v8 + 72) = 1;
      sub_189BC((PFAST_MUTEX)v8);
      v9 = sub_1B8F0();
      v3 = v9;
      if ( !v9 )
        goto LABEL_26;
      v1 = (void **)off_2B148;
      if ( off_2B148 != &off_2B148
        && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
        && *((_BYTE *)off_2B148 + 169) >= 2u )
      {
        sub_11B10(*((_QWORD *)off_2B148 + 19), 0x19u, (__int64)&unk_29BB8, v9);
        v1 = (void **)off_2B148;
      }
      v3 = 0;
      goto LABEL_54;
    }
    v1 = (void **)off_2B148;
    if ( off_2B148 != &off_2B148
      && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
      && *((_BYTE *)off_2B148 + 169) >= 2u )
    {
      sub_11008(*((_QWORD *)off_2B148 + 19), 0x18u, (__int64)&unk_29BB8);
      v1 = (void **)off_2B148;
    }
    v3 = 9;
  }
  else
  {
    v1 = (void **)off_2B148;
    if ( off_2B148 != &off_2B148
      && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
      && *((_BYTE *)off_2B148 + 169) >= 2u )
    {
      sub_11B10(*((_QWORD *)off_2B148 + 19), 0x17u, (__int64)&unk_29BB8, v7);
      v1 = (void **)off_2B148;
    }
    v3 = 8;
  }
LABEL_62:
  if ( v1 != &off_2B148 && _bittest((const signed __int32 *)v1 + 43, 8u) && *((_BYTE *)v1 + 169) >= 5u )
    sub_11B10((__int64)v1[19], 0x1Au, (__int64)&unk_29BB8, v3);
  return v3;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001B1F0) ----------------------------------------------------
__int64 sub_1B1F0()
{
  PVOID v0; // rsi
  unsigned int v1; // edi
  void **v2; // rcx
  char *v3; // rbx

  v0 = Dst;
  v1 = 0;
  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148
    && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
    && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_1A88C(*((_QWORD *)off_2B148 + 19), 0x23u, (__int64)&unk_29BB8, Dst, 188);
    v2 = (void **)off_2B148;
  }
  if ( v0 )
  {
    if ( qword_31E18 )
    {
      if ( *((_DWORD *)qword_31E18 + 1) <= 0xBCu )
      {
        KeEnterCriticalRegion();
        sub_1844C((PERESOURCE)((char *)qword_31E18 + 216));
        v3 = (char *)qword_31E18;
        memmove(v0, (char *)qword_31E18 + 352, *((unsigned int *)qword_31E18 + 1));
        sub_18524((PERESOURCE)(v3 + 216));
        KeLeaveCriticalRegion();
        v2 = (void **)off_2B148;
      }
      else
      {
        v1 = 6;
      }
    }
    else
    {
      v1 = 16;
    }
  }
  else
  {
    v1 = 4;
  }
  if ( v2 != &off_2B148 && _bittest((const signed __int32 *)v2 + 43, 8u) && *((_BYTE *)v2 + 169) >= 5u )
    sub_11B10((__int64)v2[19], 0x24u, (__int64)&unk_29BB8, v1);
  return v1;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001B338) ----------------------------------------------------
__int64 __fastcall sub_1B338(__int64 a1)
{
  char *v1; // r8
  unsigned int v2; // ebx
  __int64 (__fastcall **v4)(_QWORD, _QWORD); // r13
  __int64 v5; // r14
  int v6; // ebp
  void **v7; // rcx
  _DWORD *v8; // rdi
  unsigned __int16 v10; // dx
  unsigned __int16 v11; // dx
  int v12; // edx
  int *v13; // rdi
  int *v14; // rbp
  int v15; // edi
  int *v16; // rbp
  int v17; // edi

  v1 = (char *)qword_31E18;
  v2 = 0;
  v4 = (__int64 (__fastcall **)(_QWORD, _QWORD))*((_QWORD *)qword_31E18 + 5);
  v5 = *((_QWORD *)qword_31E18 + 6);
  v6 = 0;
  v7 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148
    && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
    && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x5Bu, (__int64)&unk_29BB8);
    v1 = (char *)qword_31E18;
    v7 = (void **)off_2B148;
  }
  if ( !a1 )
    goto LABEL_6;
  v8 = *(_DWORD **)(a1 + 56);
  if ( !v8 )
    goto LABEL_6;
  switch ( *v8 )
  {
    case 0:
      v16 = v8 + 1;
      if ( v7 != &off_2B148 && _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 4u )
      {
        sub_11008((__int64)v7[19], 0x5Cu, (__int64)&unk_29BB8);
        v1 = (char *)qword_31E18;
        v7 = (void **)off_2B148;
      }
      if ( v8 != (_DWORD *)-4i64 )
      {
        if ( !sub_26C04((PFAST_MUTEX)(v1 + 128)) )
          goto LABEL_26;
        v2 = sub_1C978(*v16);
        if ( v2 )
          goto LABEL_65;
        v17 = v4[9](v5, (unsigned int)*v16);
        if ( off_2B148 != &off_2B148
          && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
          && *((_BYTE *)off_2B148 + 169) >= 4u )
        {
          sub_11D0C(*((_QWORD *)off_2B148 + 19), v2 + 93, (__int64)&unk_29BB8, *v16);
        }
        sub_26C6C((PFAST_MUTEX)((char *)qword_31E18 + 128));
        if ( !v17 )
          goto LABEL_26;
        v2 = 8;
        v7 = (void **)off_2B148;
        if ( off_2B148 != &off_2B148 )
        {
          if ( _bittest((const signed __int32 *)off_2B148 + 43, 8u) && *((_BYTE *)off_2B148 + 169) >= 2u )
          {
            v10 = 94;
            goto LABEL_91;
          }
          goto LABEL_93;
        }
        goto LABEL_53;
      }
LABEL_6:
      v2 = 2;
      goto LABEL_93;
    case 1:
      v14 = v8 + 1;
      if ( v7 != &off_2B148 && _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 4u )
      {
        sub_11008((__int64)v7[19], 0x5Fu, (__int64)&unk_29BB8);
        v1 = (char *)qword_31E18;
        v7 = (void **)off_2B148;
      }
      if ( v8 != (_DWORD *)-4i64 )
      {
        if ( !sub_26C04((PFAST_MUTEX)(v1 + 128)) )
          goto LABEL_26;
        v2 = sub_1CAD4(*v14);
        if ( v2 )
        {
LABEL_65:
          sub_26C6C((PFAST_MUTEX)((char *)qword_31E18 + 128));
LABEL_92:
          v7 = (void **)off_2B148;
          goto LABEL_93;
        }
        v15 = v4[10](v5, (unsigned int)*v14);
        if ( off_2B148 != &off_2B148
          && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
          && *((_BYTE *)off_2B148 + 169) >= 4u )
        {
          sub_11D0C(*((_QWORD *)off_2B148 + 19), 0x60u, (__int64)&unk_29BB8, *v14);
        }
        sub_26C6C((PFAST_MUTEX)((char *)qword_31E18 + 128));
        if ( !v15 )
          goto LABEL_26;
        v2 = 8;
        v7 = (void **)off_2B148;
        if ( off_2B148 != &off_2B148 )
        {
          if ( _bittest((const signed __int32 *)off_2B148 + 43, 8u) && *((_BYTE *)off_2B148 + 169) >= 2u )
          {
            v10 = 97;
            goto LABEL_91;
          }
LABEL_93:
          if ( v7 != &off_2B148 && _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 2u )
            sub_11008((__int64)v7[19], 0x68u, (__int64)&unk_29BB8);
          if ( v2 )
            goto LABEL_53;
          goto LABEL_98;
        }
LABEL_53:
        v12 = v2;
        goto LABEL_27;
      }
      goto LABEL_6;
    case 2:
      if ( sub_26C04((PFAST_MUTEX)(v1 + 128)) )
      {
        v2 = sub_1BFBC(v8[1], v8[2], v8[3], v8 + 4);
        sub_26C6C((PFAST_MUTEX)((char *)qword_31E18 + 128));
      }
      goto LABEL_53;
    case 3:
      if ( sub_26C04((PFAST_MUTEX)(v1 + 128)) )
      {
        v2 = sub_1C5B4((unsigned int)v8[1], v8[2], a1);
        sub_26C6C((PFAST_MUTEX)((char *)qword_31E18 + 128));
      }
      goto LABEL_28;
    case 4:
      v13 = v8 + 1;
      if ( v7 != &off_2B148 && _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 4u )
      {
        sub_11008((__int64)v7[19], 0x62u, (__int64)&unk_29BB8);
        v1 = (char *)qword_31E18;
      }
      if ( sub_26C04((PFAST_MUTEX)(v1 + 128)) )
      {
        if ( v13 )
        {
          v6 = v4[8](v5, (unsigned int)*v13);
          if ( off_2B148 != &off_2B148
            && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
            && *((_BYTE *)off_2B148 + 169) >= 4u )
          {
            sub_11D0C(*((_QWORD *)off_2B148 + 19), 0x63u, (__int64)&unk_29BB8, *v13);
          }
        }
        sub_26C6C((PFAST_MUTEX)((char *)qword_31E18 + 128));
        if ( !v13 || v6 )
        {
          v2 = 8;
          if ( off_2B148 != &off_2B148
            && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
            && *((_BYTE *)off_2B148 + 169) >= 2u )
          {
            sub_11008(*((_QWORD *)off_2B148 + 19), 0x64u, (__int64)&unk_29BB8);
          }
        }
      }
      goto LABEL_53;
    case 5:
      if ( v7 == &off_2B148 || !_bittest((const signed __int32 *)v7 + 43, 8u) || *((_BYTE *)v7 + 169) < 4u )
        goto LABEL_26;
      v11 = 101;
      goto LABEL_25;
  }
  if ( *v8 != 6 )
  {
    if ( *((_QWORD *)v1 + 43) )
      return (*((__int64 (__fastcall **)(__int64, _QWORD, char *, void *))v1 + 43))(
               a1,
               (unsigned int)(*v8 - 5),
               v1,
               &unk_29BB8);
    if ( v7 == &off_2B148 )
    {
LABEL_98:
      v2 = 17;
      goto LABEL_53;
    }
    if ( _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 3u )
    {
      v10 = 103;
LABEL_91:
      sub_11008((__int64)v7[19], v10, (__int64)&unk_29BB8);
      goto LABEL_92;
    }
    goto LABEL_93;
  }
  if ( v7 != &off_2B148 && _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 4u )
  {
    v11 = 102;
LABEL_25:
    sub_11008((__int64)v7[19], v11, (__int64)&unk_29BB8);
  }
LABEL_26:
  v12 = 0;
LABEL_27:
  sub_226B8(a1, v12, 0, 0i64);
LABEL_28:
  if ( off_2B148 != &off_2B148
    && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
    && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11B10(*((_QWORD *)off_2B148 + 19), 0x69u, (__int64)&unk_29BB8, v2);
  }
  return v2;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001B8F0) ----------------------------------------------------
__int64 sub_1B8F0()
{
  __int64 v0; // rsi
  __int64 v1; // r15
  unsigned int v2; // er13
  int v3; // eax
  void *v4; // rbp
  void **v5; // r14
  unsigned int v6; // er12
  void (__fastcall *v7)(char *); // rax
  int v8; // eax
  void **v9; // r10
  _DWORD *v10; // r11
  unsigned int i; // er9
  void (__fastcall *v12)(int *); // rax
  PVOID v13; // r11
  int v14; // esi
  unsigned int v15; // eax
  unsigned int v16; // esi
  PVOID v17; // rax
  char *v18; // rbx
  int v19; // eax
  int v20; // ebx
  unsigned int v21; // eax
  unsigned int v22; // ebx
  int v23; // eax
  char *v24; // rsi
  size_t v25; // r8
  void (__fastcall *v26)(int *); // rax
  __int64 v28; // [rsp+20h] [rbp-A8h]
  __int64 v29; // [rsp+28h] [rbp-A0h]
  __int64 v30; // [rsp+30h] [rbp-98h]
  int v31; // [rsp+38h] [rbp-90h]
  char v32[8]; // [rsp+40h] [rbp-88h] BYREF
  void *Src; // [rsp+48h] [rbp-80h] BYREF
  __int64 v34; // [rsp+50h] [rbp-78h]
  int v35[28]; // [rsp+58h] [rbp-70h] BYREF
  _BYTE v36[28]; // [rsp+5Ch] [rbp-6Ch] BYREF
  char v37; // [rsp+D0h] [rbp+8h] BYREF
  size_t MaxCount; // [rsp+D8h] [rbp+10h] BYREF
  unsigned int v39; // [rsp+E0h] [rbp+18h] BYREF
  size_t v40; // [rsp+E8h] [rbp+20h] BYREF

  v0 = *((_QWORD *)qword_31E18 + 6);
  v1 = *((_QWORD *)qword_31E18 + 5);
  v34 = v0;
  v2 = 0;
  v37 = 0;
  v35[0] = 0;
  memset(v36, 0, sizeof(v36));
  if ( off_2B148 != &off_2B148
    && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
    && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x6Au, (__int64)&unk_29BB8);
  }
  v3 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))(v1 + 40))(v0, 0i64, &v37);
  if ( !v3 )
  {
    v13 = qword_31E18;
    v20 = *((_DWORD *)qword_31E18 + 4);
    v21 = v20 | *((char *)qword_31E18 + 20);
    v22 = v20 | 1;
    if ( v22 > v21 )
    {
LABEL_73:
      v9 = (void **)off_2B148;
      goto LABEL_74;
    }
    while ( 1 )
    {
      Src = 0i64;
      LODWORD(MaxCount) = 0;
      if ( (*((unsigned __int8 (__fastcall **)(_QWORD, unsigned int *, size_t *, char *, _DWORD))v13 + 40))(
             v22,
             &v39,
             &v40,
             v32,
             v28) )
      {
        v23 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, void **, size_t *))(v1 + 16))(
                v0,
                0i64,
                v22,
                &Src,
                &MaxCount);
        if ( v23 || !Src )
        {
          v9 = (void **)off_2B148;
          if ( off_2B148 != &off_2B148
            && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
            && *((_BYTE *)off_2B148 + 169) >= 2u )
          {
            LODWORD(v28) = v22;
            sub_11D0C(*((_QWORD *)off_2B148 + 19), 0x70u, (__int64)&unk_29BB8, v23);
            v9 = (void **)off_2B148;
          }
          v2 = 8;
          goto LABEL_66;
        }
        if ( off_2B148 != &off_2B148
          && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
          && *((_BYTE *)off_2B148 + 169) >= 4u )
        {
          sub_11B10(*((_QWORD *)off_2B148 + 19), 0x71u, (__int64)&unk_29BB8, v22);
        }
        KeEnterCriticalRegion();
        LODWORD(v28) = 0;
        sub_18374((PERESOURCE)((char *)qword_31E18 + 216));
        v24 = (char *)qword_31E18;
        v25 = (unsigned int)MaxCount;
        if ( (unsigned int)MaxCount >= (unsigned int)v40 )
          v25 = (unsigned int)v40;
        memmove((char *)qword_31E18 + v39 + 352, Src, v25);
        sub_18524((PERESOURCE)(v24 + 216));
        KeLeaveCriticalRegion();
        v0 = v34;
        (*(void (__fastcall **)(__int64, void *))(v1 + 32))(v34, Src);
        v35[(unsigned __int8)(v22 - 1) >> 5] |= 1 << ((v22 - 1) & 0x1F);
      }
      v9 = (void **)off_2B148;
LABEL_66:
      v13 = qword_31E18;
      if ( ++v22 > (*((_DWORD *)qword_31E18 + 4) | (unsigned int)*((char *)qword_31E18 + 20)) )
        goto LABEL_74;
    }
  }
  v4 = 0i64;
  v5 = 0i64;
  v6 = 0;
  if ( v3 == 1879048199 || v3 == 1879048193 )
  {
    if ( off_2B148 != &off_2B148
      && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
      && *((_BYTE *)off_2B148 + 169) >= 3u )
    {
      sub_11B10(*((_QWORD *)off_2B148 + 19), 0x6Bu, (__int64)&unk_29BB8, 0);
    }
  }
  else if ( off_2B148 != &off_2B148
         && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
         && *((_BYTE *)off_2B148 + 169) >= 3u )
  {
    LODWORD(v28) = 0;
    sub_11D0C(*((_QWORD *)off_2B148 + 19), 0x6Cu, (__int64)&unk_29BB8, v3);
  }
  v7 = (void (__fastcall *)(char *))*((_QWORD *)qword_31E18 + 41);
  if ( v7 )
    v7((char *)qword_31E18 + 352);
  v8 = (*(__int64 (__fastcall **)(__int64, _QWORD))(v1 + 64))(v0, 0i64);
  if ( v8 )
  {
    v9 = (void **)off_2B148;
    if ( off_2B148 != &off_2B148
      && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
      && *((_BYTE *)off_2B148 + 169) >= 2u )
    {
      sub_11B10(*((_QWORD *)off_2B148 + 19), 0x6Du, (__int64)&unk_29BB8, v8);
      v9 = (void **)off_2B148;
    }
    v10 = qword_31E18;
    for ( i = *((_DWORD *)qword_31E18 + 4) | 1; i <= (v10[4] | (unsigned int)*((char *)v10 + 20)); ++i )
      v35[(unsigned __int8)(i - 1) >> 5] |= 1 << ((i - 1) & 0x1F);
    v12 = (void (__fastcall *)(int *))*((_QWORD *)v10 + 42);
    if ( v12 )
    {
      v12(v35);
      v9 = (void **)off_2B148;
    }
    v2 = 8;
    goto LABEL_76;
  }
  v9 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148
    && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
    && *((_BYTE *)off_2B148 + 169) >= 4u )
  {
    sub_11B10(*((_QWORD *)off_2B148 + 19), 0x6Eu, (__int64)&unk_29BB8, 0);
    v9 = (void **)off_2B148;
  }
  v13 = qword_31E18;
  v14 = *((_DWORD *)qword_31E18 + 4);
  v15 = v14 | *((char *)qword_31E18 + 20);
  v16 = v14 | 1;
  if ( v16 > v15 )
    goto LABEL_74;
  do
  {
    if ( !(*((unsigned __int8 (__fastcall **)(_QWORD, unsigned int *, size_t *, size_t *, __int64, __int64))v13 + 40))(
            v16,
            &v39,
            &MaxCount,
            &v40,
            v28,
            v29) )
      goto LABEL_44;
    if ( (unsigned int)MaxCount > v6 )
    {
      if ( (unsigned int)MaxCount > 8 )
      {
        if ( v4 )
        {
          v31 = 0;
          v30 = 0i64;
          v29 = 0i64;
          LODWORD(v28) = 1886221390;
          v17 = sub_17D20(1i64, v4, v6, MaxCount);
        }
        else
        {
          LODWORD(v29) = 0;
          v28 = 0i64;
          v17 = sub_17C28(1, MaxCount, 0x706D744Eu);
        }
        v4 = v17;
        v5 = (void **)v17;
        v6 = v17 != 0i64 ? MaxCount : 0;
      }
      else
      {
        v5 = &Src;
        v6 = 8;
      }
    }
    v35[(unsigned __int8)(v16 - 1) >> 5] |= 1 << ((v16 - 1) & 0x1F);
    if ( !v5 )
    {
      v2 = 3;
LABEL_44:
      v9 = (void **)off_2B148;
      goto LABEL_45;
    }
    KeEnterCriticalRegion();
    sub_1844C((PERESOURCE)((char *)qword_31E18 + 216));
    v18 = (char *)qword_31E18;
    memmove(v5, (char *)qword_31E18 + v39 + 352, (unsigned int)MaxCount);
    sub_18524((PERESOURCE)(v18 + 216));
    KeLeaveCriticalRegion();
    LODWORD(v29) = MaxCount;
    v19 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, void **, __int64, __int64, int))(v1 + 24))(
            v34,
            0i64,
            0i64,
            v16,
            v5,
            v29,
            v30,
            v31);
    if ( !v19 )
      goto LABEL_44;
    v9 = (void **)off_2B148;
    if ( off_2B148 != &off_2B148
      && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
      && *((_BYTE *)off_2B148 + 169) >= 4u )
    {
      LODWORD(v28) = v16;
      sub_11D0C(*((_QWORD *)off_2B148 + 19), 0x6Fu, (__int64)&unk_29BB8, v19);
      v9 = (void **)off_2B148;
    }
    v2 = 8;
LABEL_45:
    v13 = qword_31E18;
    ++v16;
  }
  while ( v16 <= (*((_DWORD *)qword_31E18 + 4) | (unsigned int)*((char *)qword_31E18 + 20)) );
  if ( v4 )
  {
    sub_17CAC(v4, 0x706D744Eu);
    v13 = qword_31E18;
    goto LABEL_73;
  }
LABEL_74:
  v26 = (void (__fastcall *)(int *))*((_QWORD *)v13 + 42);
  if ( v26 )
  {
    v26(v35);
    v9 = (void **)off_2B148;
  }
LABEL_76:
  if ( v9 != &off_2B148 && _bittest((const signed __int32 *)v9 + 43, 8u) && *((_BYTE *)v9 + 169) >= 5u )
    sub_11B10((__int64)v9[19], 0x72u, (__int64)&unk_29BB8, v2);
  return v2;
}
// 1BB76: variable 'v28' is possibly undefined
// 1BB76: variable 'v29' is possibly undefined
// 1BCF3: variable 'v30' is possibly undefined
// 1BCF3: variable 'v31' is possibly undefined
// 2B148: using guessed type void *off_2B148;
// 1B8F0: using guessed type int var_70[28];

//----- (000000000001BFBC) ----------------------------------------------------
__int64 __fastcall sub_1BFBC(unsigned int a1, int a2, unsigned int a3, _DWORD *a4)
{
  _QWORD *v4; // rsi
  __int64 v6; // rax
  __int64 v7; // r15
  _QWORD *v9; // r14
  unsigned int v10; // ebx
  void **v13; // rcx
  _QWORD *i; // rax
  char *v16; // rsi
  size_t v17; // r8
  char *v18; // rcx
  _QWORD *v19; // rax
  void (__fastcall *v20)(int *); // rdx
  int v21; // eax
  _QWORD *v22; // rcx
  unsigned __int16 v23; // dx
  __int64 v24; // r9
  _QWORD *v25; // rcx
  unsigned __int16 v26; // dx
  unsigned __int64 v27; // r11
  __int64 v28; // rcx
  int v29; // eax
  int v30; // [rsp+20h] [rbp-78h]
  __int64 v31; // [rsp+20h] [rbp-78h]
  unsigned int v32; // [rsp+28h] [rbp-70h]
  __int64 v33; // [rsp+28h] [rbp-70h]
  _DWORD *v34; // [rsp+30h] [rbp-68h]
  unsigned int v35; // [rsp+40h] [rbp-58h] BYREF
  int v36; // [rsp+44h] [rbp-54h] BYREF
  __int64 v37; // [rsp+48h] [rbp-50h]
  int v38[8]; // [rsp+50h] [rbp-48h] BYREF
  _BYTE v39[28]; // [rsp+54h] [rbp-44h] BYREF
  size_t MaxCount; // [rsp+A0h] [rbp+8h] BYREF

  v4 = qword_31E18;
  v6 = *((_QWORD *)qword_31E18 + 6);
  v7 = *((_QWORD *)qword_31E18 + 5);
  v9 = 0i64;
  v10 = 0;
  v35 = 0;
  LODWORD(MaxCount) = 0;
  v38[0] = 0;
  v37 = v6;
  memset(v39, 0, sizeof(v39));
  v13 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( _bittest((const signed __int32 *)off_2B148 + 43, 8u) && *((_BYTE *)off_2B148 + 169) >= 4u )
    {
      v34 = a4;
      v32 = a3;
      v30 = a2;
      sub_1A7E0(*((_QWORD *)off_2B148 + 19), 115i64, (__int64)&unk_29BB8, a1);
      v4 = qword_31E18;
      v13 = (void **)off_2B148;
    }
    if ( v13 != &off_2B148 && _bittest((const signed __int32 *)v13 + 43, 8u) && *((_BYTE *)v13 + 169) >= 4u )
    {
      sub_11008((__int64)v13[19], 0x74u, (__int64)&unk_29BB8);
      v4 = qword_31E18;
      v13 = (void **)off_2B148;
    }
  }
  if ( a1 )
  {
    for ( i = (_QWORD *)v4[7]; i != v4 + 7; i = (_QWORD *)*i )
    {
      v9 = i - 5;
      if ( *((_DWORD *)i - 10) == a1 )
        goto LABEL_15;
    }
    v9 = 0i64;
LABEL_15:
    if ( !v9 )
    {
      if ( v13 != &off_2B148 && _bittest((const signed __int32 *)v13 + 43, 8u) && *((_BYTE *)v13 + 169) >= 2u )
        sub_11B10((__int64)v13[19], 0x75u, (__int64)&unk_29BB8, a1);
      return 4i64;
    }
  }
  if ( !((unsigned __int8 (__fastcall *)(_QWORD, unsigned int *, size_t *, int *, int, unsigned int))v4[40])(
          a3,
          &v35,
          &MaxCount,
          &v36,
          v30,
          v32) )
  {
    if ( off_2B148 != &off_2B148
      && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
      && *((_BYTE *)off_2B148 + 169) >= 2u )
    {
      sub_11B10(*((_QWORD *)off_2B148 + 19), 0x76u, (__int64)&unk_29BB8, a3);
    }
    return 4i64;
  }
  if ( a1 )
  {
    v16 = (char *)v9 + v35 + 56;
    sub_188F0((PFAST_MUTEX)((char *)qword_31E18 + 72));
  }
  else
  {
    v16 = (char *)qword_31E18 + v35 + 352;
    KeEnterCriticalRegion();
    sub_18374((PERESOURCE)((char *)qword_31E18 + 216));
  }
  if ( v36 < 0 )
    goto LABEL_34;
  if ( v36 <= 1 )
    goto LABEL_77;
  if ( v36 == 2 )
  {
    if ( a4 )
    {
      v24 = (unsigned int)*a4;
      if ( 2 * v24 <= (unsigned __int64)(unsigned int)MaxCount )
      {
        memmove(v16, a4 + 1, 2 * v24);
        v27 = 2i64 * (unsigned int)*a4;
        if ( v27 >= (unsigned int)MaxCount )
          goto LABEL_44;
        v17 = (unsigned int)MaxCount - v27;
        v18 = &v16[v27];
        goto LABEL_43;
      }
      v22 = off_2B148;
      if ( off_2B148 == &off_2B148
        || !_bittest((const signed __int32 *)off_2B148 + 43, 8u)
        || *((_BYTE *)off_2B148 + 169) < 2u )
      {
LABEL_64:
        v10 = 6;
        goto LABEL_44;
      }
      v23 = 121;
LABEL_58:
      sub_1A6D8(v22[19], v23, (__int64)&unk_29BB8, v24);
      goto LABEL_64;
    }
    v25 = off_2B148;
    if ( off_2B148 == &off_2B148
      || !_bittest((const signed __int32 *)off_2B148 + 43, 8u)
      || *((_BYTE *)off_2B148 + 169) < 2u )
    {
      goto LABEL_64;
    }
    v26 = 122;
LABEL_63:
    sub_11008(v25[19], v26, (__int64)&unk_29BB8);
    goto LABEL_64;
  }
  if ( v36 > 4 )
  {
    if ( v36 > 7 )
    {
LABEL_34:
      if ( off_2B148 != &off_2B148
        && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
        && *((_BYTE *)off_2B148 + 169) >= 2u )
      {
        sub_11008(*((_QWORD *)off_2B148 + 19), 0x7Bu, (__int64)&unk_29BB8);
      }
      v10 = 4;
      goto LABEL_44;
    }
LABEL_77:
    memmove(v16, a4, (unsigned int)MaxCount);
    goto LABEL_44;
  }
  if ( !a4 )
  {
    v25 = off_2B148;
    if ( off_2B148 == &off_2B148
      || !_bittest((const signed __int32 *)off_2B148 + 43, 8u)
      || *((_BYTE *)off_2B148 + 169) < 2u )
    {
      goto LABEL_64;
    }
    v26 = 120;
    goto LABEL_63;
  }
  if ( *a4 > (unsigned int)MaxCount )
  {
    v22 = off_2B148;
    if ( off_2B148 == &off_2B148
      || !_bittest((const signed __int32 *)off_2B148 + 43, 8u)
      || *((_BYTE *)off_2B148 + 169) < 2u )
    {
      goto LABEL_64;
    }
    v23 = 119;
    LODWORD(v24) = *a4;
    goto LABEL_58;
  }
  memmove(v16, a4 + 1, (unsigned int)*a4);
  if ( *a4 < (unsigned int)MaxCount )
  {
    v17 = (unsigned int)(MaxCount - *a4);
    v18 = &v16[*a4];
LABEL_43:
    memset(v18, 0, v17);
  }
LABEL_44:
  if ( a1 )
  {
    if ( !v10 )
    {
      v28 = v37;
      *((_DWORD *)v9 + (((a3 - 1) >> 5) & 7) + 1) |= 1 << ((a3 - 1) & 0x1F);
      v29 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, char *, _DWORD))(v7 + 24))(
              v28,
              a1,
              0i64,
              a3,
              v16,
              MaxCount);
      if ( v29 )
      {
        if ( off_2B148 != &off_2B148
          && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
          && *((_BYTE *)off_2B148 + 169) >= 2u )
        {
          LODWORD(v33) = a3;
          LODWORD(v31) = a1;
          sub_1A72C(*((_QWORD *)off_2B148 + 19), 125i64, (__int64)&unk_29BB8, v29, v31, v33, 0);
        }
        v10 = 8;
      }
    }
    sub_189BC((PFAST_MUTEX)((char *)qword_31E18 + 72));
  }
  else
  {
    sub_18524((PERESOURCE)((char *)qword_31E18 + 216));
    KeLeaveCriticalRegion();
    if ( !v10 )
    {
      v19 = qword_31E18;
      v38[((a3 - 1) >> 5) & 7] |= 1 << ((a3 - 1) & 0x1F);
      v20 = (void (__fastcall *)(int *))v19[42];
      if ( v20 )
        v20(v38);
      v21 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, char *, _DWORD, _DWORD *))(v7 + 24))(
              v37,
              0i64,
              0i64,
              a3,
              v16,
              MaxCount,
              v34);
      if ( v21 )
      {
        if ( off_2B148 != &off_2B148
          && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
          && *((_BYTE *)off_2B148 + 169) >= 2u )
        {
          sub_1A6D8(*((_QWORD *)off_2B148 + 19), 0x7Cu, (__int64)&unk_29BB8, v21);
        }
        v10 = 8;
      }
    }
  }
  return v10;
}
// 1C20C: conditional instruction was optimized away because of 'eax.4>=3'
// 1C13E: variable 'v30' is possibly undefined
// 1C13E: variable 'v32' is possibly undefined
// 1C32D: variable 'v34' is possibly undefined
// 1C56B: variable 'v31' is possibly undefined
// 1C56B: variable 'v33' is possibly undefined
// 2B148: using guessed type void *off_2B148;
// 1BFBC: using guessed type int var_48[8];

//----- (000000000001C5B4) ----------------------------------------------------
__int64 __fastcall sub_1C5B4(__int64 a1, unsigned int a2, __int64 a3)
{
  unsigned int v5; // ebx
  void **v6; // rcx
  void **v7; // rcx
  int v8; // edx
  char *v9; // rbp
  unsigned int v10; // er8
  __int64 *v11; // r9
  unsigned int v12; // er12
  _DWORD *v13; // rsi
  unsigned __int16 v14; // dx
  int v15; // eax
  __int64 Dst; // [rsp+30h] [rbp-38h] BYREF
  unsigned int v18; // [rsp+38h] [rbp-30h] BYREF
  int v19; // [rsp+3Ch] [rbp-2Ch] BYREF
  size_t MaxCount; // [rsp+88h] [rbp+20h] BYREF

  v5 = 0;
  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( _bittest((const signed __int32 *)off_2B148 + 43, 8u) && *((_BYTE *)off_2B148 + 169) >= 5u )
    {
      sub_11008(*((_QWORD *)off_2B148 + 19), 0x7Eu, (__int64)&unk_29BB8);
      v6 = (void **)off_2B148;
    }
    if ( v6 != &off_2B148 && _bittest((const signed __int32 *)v6 + 43, 8u) && *((_BYTE *)v6 + 169) >= 4u )
      sub_11B10((__int64)v6[19], 0x7Fu, (__int64)&unk_29BB8, a2);
  }
  if ( !(*((unsigned __int8 (__fastcall **)(_QWORD, unsigned int *, size_t *, int *))qword_31E18 + 40))(
          a2,
          &v18,
          &MaxCount,
          &v19) )
  {
    v7 = (void **)off_2B148;
    if ( off_2B148 != &off_2B148 )
    {
      if ( _bittest((const signed __int32 *)off_2B148 + 43, 8u) && *((_BYTE *)off_2B148 + 169) >= 2u )
      {
        sub_11B10(*((_QWORD *)off_2B148 + 19), 0x80u, (__int64)&unk_29BB8, a2);
LABEL_46:
        v7 = (void **)off_2B148;
      }
LABEL_47:
      if ( v7 != &off_2B148 && _bittest((const signed __int32 *)v7 + 43, 8u) && *((_BYTE *)v7 + 169) >= 2u )
        sub_11008((__int64)v7[19], 0x85u, (__int64)&unk_29BB8);
    }
LABEL_51:
    v8 = 17;
LABEL_52:
    v11 = 0i64;
    v5 = v8;
    v10 = 0;
    goto LABEL_53;
  }
  if ( !(_DWORD)MaxCount )
  {
    if ( off_2B148 != &off_2B148
      && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
      && *((_BYTE *)off_2B148 + 169) >= 2u )
    {
      sub_11B10(*((_QWORD *)off_2B148 + 19), 0x81u, (__int64)&unk_29BB8, a2);
    }
    v8 = 12;
    goto LABEL_52;
  }
  v9 = (char *)qword_31E18 + v18 + 352;
  if ( v19 < 0 )
  {
LABEL_41:
    v7 = (void **)off_2B148;
    if ( off_2B148 == &off_2B148 )
      goto LABEL_51;
    if ( !_bittest((const signed __int32 *)off_2B148 + 43, 8u) || *((_BYTE *)off_2B148 + 169) < 2u )
      goto LABEL_47;
    v14 = 132;
    goto LABEL_45;
  }
  if ( v19 <= 1 )
  {
LABEL_40:
    LODWORD(Dst) = 0;
    memmove(&Dst, (char *)qword_31E18 + v18 + 352, (unsigned int)MaxCount);
    v8 = 0;
    v10 = 4;
    v11 = &Dst;
    goto LABEL_53;
  }
  if ( v19 == 2 )
  {
    v12 = MaxCount + 4;
    v13 = sub_17C28(1, (int)MaxCount + 4, 0x66634E4Eu);
    if ( !v13 )
    {
      v7 = (void **)off_2B148;
      if ( off_2B148 == &off_2B148 )
        goto LABEL_51;
      if ( !_bittest((const signed __int32 *)off_2B148 + 43, 8u) || *((_BYTE *)off_2B148 + 169) < 2u )
        goto LABEL_47;
      v14 = 131;
      goto LABEL_45;
    }
    v15 = (unsigned int)MaxCount >> 1;
  }
  else
  {
    if ( v19 > 4 )
    {
      if ( v19 > 6 )
      {
        if ( v19 == 7 )
        {
          Dst = 0i64;
          memmove(&Dst, (char *)qword_31E18 + v18 + 352, (unsigned int)MaxCount);
          v8 = 0;
          v10 = 8;
          v11 = &Dst;
LABEL_53:
          sub_226B8(a3, v8, v10, v11);
          goto LABEL_54;
        }
        goto LABEL_41;
      }
      goto LABEL_40;
    }
    v12 = MaxCount + 4;
    v13 = sub_17C28(1, (int)MaxCount + 4, 0x66634E4Eu);
    if ( !v13 )
    {
      v7 = (void **)off_2B148;
      if ( off_2B148 == &off_2B148 )
        goto LABEL_51;
      if ( !_bittest((const signed __int32 *)off_2B148 + 43, 8u) || *((_BYTE *)off_2B148 + 169) < 2u )
        goto LABEL_47;
      v14 = 130;
LABEL_45:
      sub_11008((__int64)v7[19], v14, (__int64)&unk_29BB8);
      goto LABEL_46;
    }
    v15 = MaxCount;
  }
  *v13 = v15;
  memmove(v13 + 1, v9, (unsigned int)MaxCount);
  sub_226B8(a3, 0, v12, v13);
  sub_17CAC(v13, 0x66634E4Eu);
LABEL_54:
  if ( off_2B148 != &off_2B148
    && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
    && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11B10(*((_QWORD *)off_2B148 + 19), 0x86u, (__int64)&unk_29BB8, v5);
  }
  return v5;
}
// 1C738: conditional instruction was optimized away because of 'eax.4>=3'
// 2B148: using guessed type void *off_2B148;

//----- (000000000001C978) ----------------------------------------------------
__int64 __fastcall sub_1C978(int a1)
{
  unsigned int v1; // edi
  char *v4; // r10
  char *i; // rax
  char *v6; // rax
  _DWORD *v7; // rax
  _QWORD *v8; // rsi
  char *v9; // rbx
  _QWORD *v10; // rdx
  __int64 v11; // rcx

  v1 = 0;
  if ( !a1 )
    return 6i64;
  sub_188F0((PFAST_MUTEX)((char *)qword_31E18 + 72));
  v4 = (char *)qword_31E18;
  for ( i = (char *)*((_QWORD *)qword_31E18 + 7); i != (char *)qword_31E18 + 56; i = (char *)*((_QWORD *)v6 + 5) )
  {
    v6 = i - 40;
    if ( *(_DWORD *)v6 == a1 )
      goto LABEL_8;
  }
  v6 = 0i64;
LABEL_8:
  if ( v6 )
  {
    v1 = 6;
  }
  else
  {
    v7 = sub_17C28(1, *((_DWORD *)qword_31E18 + 1) + 56, 0x66634E4Eu);
    v8 = v7;
    if ( v7 )
    {
      *v7 = a1;
      memset(v7 + 1, 0, 0x20ui64);
      KeEnterCriticalRegion();
      sub_1844C((PERESOURCE)((char *)qword_31E18 + 216));
      v9 = (char *)qword_31E18;
      memmove(v8 + 7, (char *)qword_31E18 + 352, *((unsigned int *)qword_31E18 + 1));
      sub_18524((PERESOURCE)(v9 + 216));
      KeLeaveCriticalRegion();
      v4 = (char *)qword_31E18;
      v10 = (char *)qword_31E18 + 56;
      v11 = *((_QWORD *)qword_31E18 + 7);
      v8[6] = (char *)qword_31E18 + 56;
      v8[5] = v11;
      *(_QWORD *)(v11 + 8) = v8 + 5;
      *v10 = v8 + 5;
    }
    else
    {
      v4 = (char *)qword_31E18;
      v1 = 3;
    }
  }
  sub_189BC((PFAST_MUTEX)(v4 + 72));
  return v1;
}

//----- (000000000001CAD4) ----------------------------------------------------
__int64 __fastcall sub_1CAD4(int a1)
{
  __int64 result; // rax
  char *v3; // r11
  _QWORD *i; // rax
  char *v5; // rdi
  __int64 v6; // rcx
  _QWORD *v7; // rax
  char *v8; // rbx
  void (__fastcall *v9)(char *); // rax

  if ( !a1 )
    return 6i64;
  sub_188F0((PFAST_MUTEX)((char *)qword_31E18 + 72));
  v3 = (char *)qword_31E18;
  for ( i = (_QWORD *)*((_QWORD *)qword_31E18 + 7); i != (_QWORD *)((char *)qword_31E18 + 56); i = (_QWORD *)*i )
  {
    v5 = (char *)(i - 5);
    if ( *((_DWORD *)i - 10) == a1 )
      goto LABEL_8;
  }
  v5 = 0i64;
LABEL_8:
  if ( v5 )
  {
    v6 = *((_QWORD *)v5 + 5);
    v7 = (_QWORD *)*((_QWORD *)v5 + 6);
    *v7 = v6;
    *(_QWORD *)(v6 + 8) = v7;
    sub_189BC((PFAST_MUTEX)(v3 + 72));
    KeEnterCriticalRegion();
    sub_18374((PERESOURCE)((char *)qword_31E18 + 216));
    v8 = (char *)qword_31E18;
    memmove((char *)qword_31E18 + 352, v5 + 56, *((unsigned int *)qword_31E18 + 1));
    sub_18524((PERESOURCE)(v8 + 216));
    KeLeaveCriticalRegion();
    v9 = (void (__fastcall *)(char *))*((_QWORD *)qword_31E18 + 42);
    if ( v9 )
      v9(v5 + 4);
    sub_17CAC(v5, 0x66634E4Eu);
    result = 0i64;
  }
  else
  {
    sub_189BC((PFAST_MUTEX)((char *)qword_31E18 + 72));
    result = 5i64;
  }
  return result;
}

//----- (000000000001CBFC) ----------------------------------------------------
__int64 __fastcall sub_1CBFC(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+168h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2BAB8(a1, 43i64, &unk_29BA8, 119i64, &v5);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001CD40) ----------------------------------------------------
__int64 __fastcall sub_1CD40(__int64 a1, __int64 a2, __int64 a3, int a4, const char *a5, const char *a6)
{
  int v8; // [rsp+88h] [rbp+20h] BYREF

  v8 = a4;
  if ( a6 )
    strlen(a6);
  if ( a5 )
    strlen(a5);
  return qword_2BAB8(a1, 43i64, &unk_29BA8, 336i64, &v8);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001CE08) ----------------------------------------------------
__int64 __fastcall sub_1CE08(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+78h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2BAB8(a1, 43i64, &unk_29BA8, 10i64, &v5);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001CE60) ----------------------------------------------------
__int64 __fastcall sub_1CE60(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, const char *a5)
{
  int v7; // [rsp+78h] [rbp+20h] BYREF

  v7 = a4;
  if ( a5 )
    strlen(a5);
  return qword_2BAB8(a1, 43i64, &unk_29BA8, a2, &v7);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001CEE8) ----------------------------------------------------
__int64 sub_1CEE8(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2BAB8(a1, 43i64, a3, a2, (__int64 *)va);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001CF30) ----------------------------------------------------
__int64 sub_1CF30(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+88h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2BAB8(a1, 43i64, &unk_29BA8, a2, (__int64 *)va);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001CF90) ----------------------------------------------------
__int64 sub_1CF90(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+88h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2BAB8(a1, 43i64, a3, a2, (__int64 *)va);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000001CFE4) ----------------------------------------------------
_BYTE *__fastcall sub_1CFE4(_BYTE *a1, int a2)
{
  __int64 v2; // rbx
  void **v5; // rcx
  unsigned __int16 v6; // dx
  unsigned __int16 v8; // dx
  void **v9; // rcx
  unsigned __int16 v10; // dx
  int v11; // eax
  unsigned __int8 v12; // al
  __int64 v13; // rbx
  unsigned __int16 v14; // dx
  __int64 v15; // [rsp+30h] [rbp-78h] BYREF
  unsigned __int64 v16; // [rsp+38h] [rbp-70h] BYREF
  char Dst[40]; // [rsp+40h] [rbp-68h] BYREF
  unsigned __int8 v18; // [rsp+B8h] [rbp+10h] BYREF
  char v19; // [rsp+C0h] [rbp+18h] BYREF
  unsigned __int16 v20; // [rsp+C8h] [rbp+20h] BYREF

  v2 = 0i64;
  v19 = 0;
  v15 = 0i64;
  v18 = -1;
  v5 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_1CE08(*((_QWORD *)off_2B148 + 19), 10i64, (__int64)&unk_29BA8, a2);
    v5 = (void **)off_2B148;
  }
  if ( !a2 )
  {
    if ( v5 == &off_2B148 || (*((_BYTE *)v5 + 172) & 0x20) == 0 || *((_BYTE *)v5 + 169) < 5u )
      return a1;
    v6 = 11;
LABEL_10:
    sub_11008((__int64)v5[19], v6, (__int64)&unk_29BA8);
    return a1;
  }
  sub_1D710((__int64)a1, &v20);
  v8 = v20;
  a1 += 14;
  if ( v20 == 2048 || v20 == 0x86DD )
  {
    sub_1D7D4(a1, &v19);
    v8 = v20;
    if ( v20 == 2048 && v19 != 4 || v20 == 0x86DD && v19 != 6 )
    {
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 3u )
        sub_11D0C(*((_QWORD *)off_2B148 + 19), 0xDu, (__int64)&unk_29BA8, v20);
      return 0i64;
    }
LABEL_27:
    switch ( a2 )
    {
      case 1:
        if ( v8 == 2048 )
        {
          v5 = (void **)off_2B148;
          if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 172) & 0x20) == 0 || *((_BYTE *)off_2B148 + 169) < 5u )
            return a1;
          v6 = 14;
          goto LABEL_10;
        }
        v9 = (void **)off_2B148;
        if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 172) & 0x20) == 0 || *((_BYTE *)off_2B148 + 169) < 2u )
          return 0i64;
        v10 = 15;
        goto LABEL_124;
      case 2:
        if ( v8 == 0x86DD )
        {
          v5 = (void **)off_2B148;
          if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 172) & 0x20) == 0 || *((_BYTE *)off_2B148 + 169) < 5u )
            return a1;
          v6 = 16;
          goto LABEL_10;
        }
        v9 = (void **)off_2B148;
        if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 172) & 0x20) == 0 || *((_BYTE *)off_2B148 + 169) < 2u )
          return 0i64;
        v10 = 17;
        goto LABEL_124;
      case 7:
        if ( v8 == 2054 )
        {
          v5 = (void **)off_2B148;
          if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 172) & 0x20) == 0 || *((_BYTE *)off_2B148 + 169) < 5u )
            return a1;
          v6 = 18;
          goto LABEL_10;
        }
        v9 = (void **)off_2B148;
        if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 172) & 0x20) == 0 || *((_BYTE *)off_2B148 + 169) < 2u )
          return 0i64;
        v10 = 19;
        goto LABEL_124;
    }
    if ( v8 == 2048 )
    {
      if ( sub_1F638((__int64)a1) )
      {
        v9 = (void **)off_2B148;
        if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 172) & 0x20) == 0 || *((_BYTE *)off_2B148 + 169) < 3u )
          return 0i64;
        v10 = 20;
        goto LABEL_124;
      }
      v13 = 4 * (*a1 & 0xF);
      v12 = a1[9];
      v18 = v12;
      v2 = (__int64)&a1[v13];
    }
    else
    {
      if ( v8 == 34525 )
      {
        v16 = 0i64;
        memset(Dst, 0, sizeof(Dst));
        if ( !(unsigned int)sub_1FD14((__int64)a1, 0x2Cu, &v16) )
        {
          v9 = (void **)off_2B148;
          if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 172) & 0x20) == 0 || *((_BYTE *)off_2B148 + 169) < 3u )
            return 0i64;
          v10 = 21;
          goto LABEL_124;
        }
        v11 = sub_1DD84((__int64)a1, &v18, &v15);
        if ( v11 )
        {
          v9 = (void **)off_2B148;
          if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 172) & 0x20) == 0 || *((_BYTE *)off_2B148 + 169) < 2u )
          {
            v2 = v15;
            v12 = v18;
LABEL_79:
            if ( v12 != 6 && v12 != 17 && v12 != 1 && v12 != 58 )
            {
              if ( v9 == &off_2B148 || (*((_BYTE *)v9 + 172) & 0x20) == 0 || *((_BYTE *)v9 + 169) < 2u )
                return 0i64;
              v10 = 23;
              goto LABEL_124;
            }
            switch ( a2 )
            {
              case 3:
                if ( v12 != 6 )
                {
                  if ( v9 == &off_2B148 || (*((_BYTE *)v9 + 172) & 0x20) == 0 || *((_BYTE *)v9 + 169) < 2u )
                    return 0i64;
                  v10 = 25;
                  goto LABEL_124;
                }
                if ( v9 != &off_2B148 && (*((_BYTE *)v9 + 172) & 0x20) != 0 && *((_BYTE *)v9 + 169) >= 5u )
                {
                  v14 = 24;
LABEL_93:
                  sub_11008((__int64)v9[19], v14, (__int64)&unk_29BA8);
                  return (_BYTE *)v2;
                }
                break;
              case 4:
                if ( v12 != 17 )
                {
                  if ( v9 == &off_2B148 || (*((_BYTE *)v9 + 172) & 0x20) == 0 || *((_BYTE *)v9 + 169) < 2u )
                    return 0i64;
                  v10 = 27;
                  goto LABEL_124;
                }
                if ( v9 != &off_2B148 && (*((_BYTE *)v9 + 172) & 0x20) != 0 && *((_BYTE *)v9 + 169) >= 5u )
                {
                  v14 = 26;
                  goto LABEL_93;
                }
                break;
              case 6:
                if ( v12 != 1 && v12 != 58 )
                {
                  if ( v9 == &off_2B148 || (*((_BYTE *)v9 + 172) & 0x20) == 0 || *((_BYTE *)v9 + 169) < 2u )
                    return 0i64;
                  v10 = 29;
                  goto LABEL_124;
                }
                if ( v9 != &off_2B148 && (*((_BYTE *)v9 + 172) & 0x20) != 0 && *((_BYTE *)v9 + 169) >= 5u )
                {
                  v14 = 28;
                  goto LABEL_93;
                }
                break;
              default:
                if ( v9 == &off_2B148 || (*((_BYTE *)v9 + 172) & 0x20) == 0 || *((_BYTE *)v9 + 169) < 2u )
                  return 0i64;
                v10 = 31;
                goto LABEL_124;
            }
            return (_BYTE *)v2;
          }
          sub_11B10(*((_QWORD *)off_2B148 + 19), 0x16u, (__int64)&unk_29BA8, v11);
        }
        v2 = v15;
      }
      v12 = v18;
    }
    v9 = (void **)off_2B148;
    goto LABEL_79;
  }
  if ( v20 == 2054 )
    goto LABEL_27;
  v9 = (void **)off_2B148;
  if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 172) & 0x20) == 0 || *((_BYTE *)off_2B148 + 169) < 2u )
    return 0i64;
  v10 = 12;
LABEL_124:
  sub_11008((__int64)v9[19], v10, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001D5A4) ----------------------------------------------------
__int64 __fastcall sub_1D5A4(__int64 a1, __int64 a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0x31u, (__int64)&unk_29BA8, a1, a2);
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 6);
  *(_WORD *)(a2 + 4) = *(_WORD *)(a1 + 10);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x32u, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001D65C) ----------------------------------------------------
__int64 __fastcall sub_1D65C(__int64 a1, __int64 a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0x33u, (__int64)&unk_29BA8, a1, a2);
  *(_DWORD *)a2 = *(_DWORD *)a1;
  *(_WORD *)(a2 + 4) = *(_WORD *)(a1 + 4);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x34u, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001D710) ----------------------------------------------------
__int64 __fastcall sub_1D710(__int64 a1, _WORD *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0x35u, (__int64)&unk_29BA8, a1, a2);
  *a2 = (unsigned __int8)HIBYTE(*(_WORD *)(a1 + 12)) | ((unsigned __int8)*(_WORD *)(a1 + 12) << 8);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x36u, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001D7D4) ----------------------------------------------------
__int64 __fastcall sub_1D7D4(_BYTE *a1, _BYTE *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0x37u, (__int64)&unk_29BA8, a1, a2);
  *a2 = *a1 >> 4;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x38u, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001D884) ----------------------------------------------------
__int64 __fastcall sub_1D884(_BYTE *a1, _BYTE *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0x39u, (__int64)&unk_29BA8, a1, a2);
  *a2 = *a1 & 0xF;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x3Au, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001D934) ----------------------------------------------------
__int64 __fastcall sub_1D934(__int64 a1, _BYTE *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0x41u, (__int64)&unk_29BA8, a1, a2);
  *a2 = *(_BYTE *)(a1 + 6) >> 5;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x42u, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001D9E4) ----------------------------------------------------
__int64 __fastcall sub_1D9E4(__int64 a1, _WORD *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0x43u, (__int64)&unk_29BA8, a1, a2);
  *a2 = _byteswap_ushort(*(_WORD *)(a1 + 6)) & 0x1FFF;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x44u, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001DAB0) ----------------------------------------------------
__int64 __fastcall sub_1DAB0(__int64 a1, _BYTE *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0x47u, (__int64)&unk_29BA8, a1, a2);
  *a2 = *(_BYTE *)(a1 + 9);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x48u, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001DB60) ----------------------------------------------------
__int64 __fastcall sub_1DB60(__int64 a1, _DWORD *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0x4Bu, (__int64)&unk_29BA8, a1, a2);
  *a2 = *(_DWORD *)(a1 + 12);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x4Cu, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001DC10) ----------------------------------------------------
__int64 __fastcall sub_1DC10(__int64 a1, _DWORD *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0x4Du, (__int64)&unk_29BA8, a1, a2);
  *a2 = *(_DWORD *)(a1 + 16);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x4Eu, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001DCC0) ----------------------------------------------------
__int64 __fastcall sub_1DCC0(__int64 a1, _DWORD *a2)
{
  unsigned __int16 v5; // [rsp+38h] [rbp+10h] BYREF

  v5 = 0;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1A850(*((_QWORD *)off_2B148 + 19), 0x51u, (__int64)&unk_29BA8, a1);
  sub_1E21C(a1, &v5);
  *a2 = v5 + 40;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x52u, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001DD84) ----------------------------------------------------
__int64 __fastcall sub_1DD84(__int64 a1, unsigned __int8 *a2, _QWORD *a3)
{
  void **v6; // rcx
  unsigned int v7; // ebx
  unsigned __int8 v8; // si
  unsigned __int8 v9; // di
  unsigned __int64 v11; // [rsp+30h] [rbp-48h] BYREF
  _BYTE v12[40]; // [rsp+38h] [rbp-40h] BYREF
  char v13; // [rsp+80h] [rbp+8h]
  char v14; // [rsp+81h] [rbp+9h]
  char v15; // [rsp+82h] [rbp+Ah]

  v11 = 0i64;
  memset(v12, 0, sizeof(v12));
  v13 = 6;
  v14 = 17;
  v15 = 58;
  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x53u, (__int64)&unk_29BA8);
    v6 = (void **)off_2B148;
  }
  if ( a1 && a2 )
  {
    *a2 = 0;
    if ( a3 )
      *a3 = 0i64;
    if ( sub_1E048(a1) )
    {
      v6 = (void **)off_2B148;
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 3u )
      {
        sub_11008(*((_QWORD *)off_2B148 + 19), 0x55u, (__int64)&unk_29BA8);
        v6 = (void **)off_2B148;
      }
      v7 = 18;
    }
    else
    {
      v6 = (void **)off_2B148;
      v8 = 0;
      while ( 1 )
      {
        v9 = *(&v13 + v8);
        if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 5u )
          sub_11B10((__int64)v6[19], 0x56u, (__int64)&unk_29BA8, v9);
        v7 = sub_1FD14(a1, v9, &v11);
        if ( !v7 )
          break;
        v6 = (void **)off_2B148;
        if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 2u )
        {
          sub_11B10(*((_QWORD *)off_2B148 + 19), 0x58u, (__int64)&unk_29BA8, v7);
          v6 = (void **)off_2B148;
        }
        if ( ++v8 >= 3u )
          goto LABEL_38;
      }
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
        sub_11B10(*((_QWORD *)off_2B148 + 19), 0x57u, (__int64)&unk_29BA8, v9);
      *a2 = v9;
      v6 = (void **)off_2B148;
      if ( a3 )
        *a3 = v11;
    }
  }
  else
  {
    if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 2u )
    {
      sub_1CF90((__int64)v6[19], 0x54u, (__int64)&unk_29BA8, a1, a2, 0i64);
      v6 = (void **)off_2B148;
    }
    v7 = 4;
  }
LABEL_38:
  if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_11008((__int64)v6[19], 0x59u, (__int64)&unk_29BA8);
  return v7;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001E048) ----------------------------------------------------
char __fastcall sub_1E048(__int64 a1)
{
  char v1; // bl
  void **v3; // rcx
  unsigned __int64 v5; // [rsp+20h] [rbp-38h] BYREF
  _BYTE v6[40]; // [rsp+28h] [rbp-30h] BYREF
  unsigned __int16 v7; // [rsp+60h] [rbp+8h] BYREF

  v1 = 0;
  v5 = 0i64;
  memset(v6, 0, sizeof(v6));
  v7 = 0;
  v3 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x5Au, (__int64)&unk_29BA8);
    v3 = (void **)off_2B148;
  }
  if ( a1 )
  {
    sub_1E21C(a1, &v7);
    if ( !(unsigned int)sub_1FD14(a1, 0, &v5) )
    {
      v3 = (void **)off_2B148;
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
      {
        sub_11008(*((_QWORD *)off_2B148 + 19), 0x5Cu, (__int64)&unk_29BA8);
        v3 = (void **)off_2B148;
      }
      if ( !v7 )
      {
        if ( v3 != &off_2B148 && (*((_BYTE *)v3 + 172) & 0x20) != 0 && *((_BYTE *)v3 + 169) >= 3u )
        {
          sub_11008((__int64)v3[19], 0x5Du, (__int64)&unk_29BA8);
          v3 = (void **)off_2B148;
        }
        v1 = 1;
      }
      goto LABEL_26;
    }
    v3 = (void **)off_2B148;
    if ( off_2B148 == &off_2B148 )
      return v1;
    if ( (*((_BYTE *)off_2B148 + 172) & 0x20) == 0 || *((_BYTE *)off_2B148 + 169) < 5u )
      goto LABEL_26;
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x5Eu, (__int64)&unk_29BA8);
    goto LABEL_25;
  }
  if ( v3 == &off_2B148 )
    return v1;
  if ( (*((_BYTE *)v3 + 172) & 0x20) != 0 && *((_BYTE *)v3 + 169) >= 2u )
  {
    sub_1A850((__int64)v3[19], 0x5Bu, (__int64)&unk_29BA8, 0i64, v5);
LABEL_25:
    v3 = (void **)off_2B148;
  }
LABEL_26:
  if ( v3 != &off_2B148 && (*((_BYTE *)v3 + 172) & 0x20) != 0 && *((_BYTE *)v3 + 169) >= 5u )
    sub_11008((__int64)v3[19], 0x5Fu, (__int64)&unk_29BA8);
  return v1;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001E21C) ----------------------------------------------------
__int64 __fastcall sub_1E21C(__int64 a1, unsigned __int16 *a2)
{
  unsigned __int16 v4; // dx

  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0x68u, (__int64)&unk_29BA8, a1, a2);
  v4 = (unsigned __int8)HIBYTE(*(_WORD *)(a1 + 4)) | ((unsigned __int8)*(_WORD *)(a1 + 4) << 8);
  *a2 = v4;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11B10(*((_QWORD *)off_2B148 + 19), 0x69u, (__int64)&unk_29BA8, v4);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001E2E4) ----------------------------------------------------
__int64 __fastcall sub_1E2E4(__int64 a1, unsigned __int8 *a2)
{
  unsigned __int8 v4; // al

  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0x6Au, (__int64)&unk_29BA8, a1, a2);
  v4 = *(_BYTE *)(a1 + 6);
  *a2 = v4;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11B10(*((_QWORD *)off_2B148 + 19), 0x6Bu, (__int64)&unk_29BA8, v4);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001E398) ----------------------------------------------------
__int64 __fastcall sub_1E398(__int64 a1, __m128i *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0x6Eu, (__int64)&unk_29BA8, a1, a2);
  *a2 = _mm_loadu_si128((const __m128i *)(a1 + 8));
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x6Fu, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001E44C) ----------------------------------------------------
__int64 __fastcall sub_1E44C(__int64 a1, __m128i *a2)
{
  int v4; // eax
  void **v5; // rcx
  unsigned __int64 v7; // [rsp+30h] [rbp-38h] BYREF
  _BYTE v8[40]; // [rsp+38h] [rbp-30h] BYREF

  v7 = 0i64;
  memset(v8, 0, sizeof(v8));
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0x70u, (__int64)&unk_29BA8, a1, a2);
  if ( (unsigned int)sub_1FD14(a1, 0x2Bu, &v7) )
    goto LABEL_11;
  v4 = sub_1E5A8(&v7, a2);
  if ( v4 )
  {
    v5 = (void **)off_2B148;
    if ( off_2B148 == &off_2B148 )
    {
LABEL_16:
      *a2 = _mm_loadu_si128((const __m128i *)(a1 + 24));
      goto LABEL_17;
    }
    if ( (*((_BYTE *)off_2B148 + 172) & 0x20) == 0 || *((_BYTE *)off_2B148 + 169) < 5u )
    {
LABEL_12:
      if ( v5 != &off_2B148 && (*((_BYTE *)v5 + 172) & 0x20) != 0 && *((_BYTE *)v5 + 169) >= 5u )
        sub_11008((__int64)v5[19], 0x72u, (__int64)&unk_29BA8);
      goto LABEL_16;
    }
    sub_11B10(*((_QWORD *)off_2B148 + 19), 0x71u, (__int64)&unk_29BA8, v4);
LABEL_11:
    v5 = (void **)off_2B148;
    goto LABEL_12;
  }
LABEL_17:
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x73u, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001E5A8) ----------------------------------------------------
__int64 __fastcall sub_1E5A8(_BYTE *a1, __m128i *a2)
{
  __m128i *v2; // r12
  const __m128i *v4; // r15
  unsigned __int8 v5; // di
  void **v6; // rcx
  bool v7; // bp
  const char *v8; // r8
  __int64 v9; // rcx
  const char *v10; // rax
  unsigned int v11; // ebx
  unsigned __int8 v12; // di
  __int64 v13; // rax
  unsigned __int16 v14; // r9
  unsigned __int16 v15; // ax
  unsigned __int16 v17; // [rsp+F0h] [rbp+8h]
  __m128i *v18; // [rsp+F8h] [rbp+10h]
  const __m128i *v19; // [rsp+108h] [rbp+20h]

  v18 = a2;
  v2 = a2;
  v4 = 0i64;
  v19 = 0i64;
  v5 = -1;
  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x74u, (__int64)&unk_29BA8);
    v6 = (void **)off_2B148;
  }
  v7 = 0;
  if ( *(_QWORD *)a1 )
  {
    v5 = *(_BYTE *)(*(_QWORD *)a1 + 2i64);
    if ( !v5 || v5 > 1u && v5 <= 3u )
      v7 = 1;
  }
  if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 5u )
  {
    if ( v5 )
    {
      switch ( v5 )
      {
        case 1u:
          v8 = "NIMROD";
          break;
        case 2u:
          v8 = "MOBILITY";
          break;
        case 3u:
          v8 = "RPL";
          break;
        case 4u:
          v8 = "SEGMENT";
          break;
        case 0xFDu:
          v8 = "EXP_1";
          break;
        case 0xFEu:
          v8 = "EXP_2";
          break;
        default:
          v8 = "UNKNOWN";
          break;
      }
    }
    else
    {
      v8 = "SOURCE_ROUTE";
    }
    v9 = (__int64)v6[19];
    v10 = "NOT";
    if ( v7 )
      v10 = (const char *)&unk_29D78;
    sub_1CD40(v9, 336i64, (__int64)&unk_29BA8, v5, v8, v10);
    v6 = (void **)off_2B148;
  }
  if ( v7 )
  {
    if ( *(_QWORD *)a1 && *(_BYTE *)(*(_QWORD *)a1 + 3i64) )
    {
      v12 = (unsigned __int8)(a1[24] - 8) >> 4;
      if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 5u )
      {
        sub_11008((__int64)v6[19], 0x76u, (__int64)&unk_29BA8);
        v6 = (void **)off_2B148;
      }
      v13 = *(_QWORD *)a1;
      if ( *(_QWORD *)a1 )
      {
        v4 = (const __m128i *)(v13 + 8);
        v19 = (const __m128i *)(v13 + 8);
      }
      v14 = 0;
      v17 = 0;
      if ( v12 )
      {
        do
        {
          if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 5u )
          {
            v4 = v19;
            sub_1CBFC(*((_QWORD *)off_2B148 + 19), 119i64, (__int64)&unk_29BA8, v17);
            v6 = (void **)off_2B148;
            v14 = v17;
            v2 = v18;
          }
          ++v14;
          v15 = v12;
          v17 = v14;
          if ( v14 == v12 )
          {
            if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 5u )
            {
              sub_11008((__int64)v6[19], 0x78u, (__int64)&unk_29BA8);
              v14 = v17;
              v15 = v12;
            }
            *v2 = _mm_loadu_si128(v4);
          }
          else
          {
            v19 = ++v4;
          }
          v6 = (void **)off_2B148;
        }
        while ( v14 < v15 );
      }
      v11 = 0;
      *v2 = _mm_loadu_si128(v4);
    }
    else
    {
      if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 5u )
        sub_11008((__int64)v6[19], 0x75u, (__int64)&unk_29BA8);
      v11 = 6;
    }
  }
  else
  {
    v11 = 18;
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x79u, (__int64)&unk_29BA8);
  return v11;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001EA14) ----------------------------------------------------
__int64 __fastcall sub_1EA14(_WORD *a1, _WORD *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0x7Au, (__int64)&unk_29BA8, a1, a2);
  *a2 = (unsigned __int8)HIBYTE(*a1) | ((unsigned __int8)*a1 << 8);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x7Bu, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001EAD8) ----------------------------------------------------
__int64 __fastcall sub_1EAD8(__int64 a1, _WORD *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0x7Cu, (__int64)&unk_29BA8, a1, a2);
  *a2 = (unsigned __int8)HIBYTE(*(_WORD *)(a1 + 2)) | ((unsigned __int8)*(_WORD *)(a1 + 2) << 8);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x7Du, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001EB9C) ----------------------------------------------------
__int64 __fastcall sub_1EB9C(__int64 a1, _BYTE *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0x82u, (__int64)&unk_29BA8, a1, a2);
  *a2 = *(_BYTE *)(a1 + 12) >> 4;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x83u, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001EC4C) ----------------------------------------------------
__int64 __fastcall sub_1EC4C(__int64 a1, _BYTE *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0x86u, (__int64)&unk_29BA8, a1, a2);
  *a2 = *(_BYTE *)(a1 + 13);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x87u, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001ECFC) ----------------------------------------------------
__int64 __fastcall sub_1ECFC(_WORD *a1, _WORD *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0xB3u, (__int64)&unk_29BA8, a1, a2);
  *a2 = (unsigned __int8)HIBYTE(*a1) | ((unsigned __int8)*a1 << 8);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xB4u, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001EDC0) ----------------------------------------------------
__int64 __fastcall sub_1EDC0(__int64 a1, _WORD *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0xB5u, (__int64)&unk_29BA8, a1, a2);
  *a2 = (unsigned __int8)HIBYTE(*(_WORD *)(a1 + 2)) | ((unsigned __int8)*(_WORD *)(a1 + 2) << 8);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xB6u, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001EE84) ----------------------------------------------------
__int64 __fastcall sub_1EE84(_BYTE *a1, _BYTE *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0xBBu, (__int64)&unk_29BA8, a1, a2);
  *a2 = *a1;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xBCu, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001EF30) ----------------------------------------------------
__int64 __fastcall sub_1EF30(__int64 a1, _BYTE *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0xBDu, (__int64)&unk_29BA8, a1, a2);
  *a2 = *(_BYTE *)(a1 + 1);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xBEu, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001EFE0) ----------------------------------------------------
__int64 __fastcall sub_1EFE0(__int64 a1, _WORD *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0xC3u, (__int64)&unk_29BA8, a1, a2);
  *a2 = (unsigned __int8)HIBYTE(*(_WORD *)(a1 + 6)) | ((unsigned __int8)*(_WORD *)(a1 + 6) << 8);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xC4u, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001F0A4) ----------------------------------------------------
__int64 __fastcall sub_1F0A4(__int64 a1, _WORD *a2)
{
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0xDFu, (__int64)&unk_29BA8, a1, a2);
  *a2 = (unsigned __int8)HIBYTE(*(_WORD *)(a1 + 6)) | ((unsigned __int8)*(_WORD *)(a1 + 6) << 8);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xE0u, (__int64)&unk_29BA8);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001F168) ----------------------------------------------------
__int64 __fastcall sub_1F168(__int64 a1, __int64 a2)
{
  unsigned int v4; // ebx

  v4 = 1;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0xE3u, (__int64)&unk_29BA8, a1, a2);
  if ( (unsigned __int8)sub_1F4A8((__int16 *)a1) )
  {
    v4 = 0;
    *(_DWORD *)a2 = *(_DWORD *)(a1 + 8);
    *(_WORD *)(a2 + 4) = *(_WORD *)(a1 + 12);
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11B10(*((_QWORD *)off_2B148 + 19), 0xE4u, (__int64)&unk_29BA8, v4);
  return v4;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001F23C) ----------------------------------------------------
__int64 __fastcall sub_1F23C(__int64 a1, _DWORD *a2)
{
  unsigned int v4; // ebx

  v4 = 1;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0xE7u, (__int64)&unk_29BA8, a1, a2);
  if ( (unsigned __int8)sub_1F4A8((__int16 *)a1) )
  {
    v4 = 0;
    *a2 = *(_DWORD *)(a1 + 14);
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11B10(*((_QWORD *)off_2B148 + 19), 0xE8u, (__int64)&unk_29BA8, v4);
  return v4;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001F308) ----------------------------------------------------
__int64 __fastcall sub_1F308(__int64 a1, __int64 a2)
{
  unsigned int v4; // ebx

  v4 = 1;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0xEBu, (__int64)&unk_29BA8, a1, a2);
  if ( (unsigned __int8)sub_1F4A8((__int16 *)a1) )
  {
    v4 = 0;
    *(_DWORD *)a2 = *(_DWORD *)(a1 + 18);
    *(_WORD *)(a2 + 4) = *(_WORD *)(a1 + 22);
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11B10(*((_QWORD *)off_2B148 + 19), 0xECu, (__int64)&unk_29BA8, v4);
  return v4;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001F3DC) ----------------------------------------------------
__int64 __fastcall sub_1F3DC(__int64 a1, _DWORD *a2)
{
  unsigned int v4; // ebx

  v4 = 1;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0xEFu, (__int64)&unk_29BA8, a1, a2);
  if ( (unsigned __int8)sub_1F4A8((__int16 *)a1) )
  {
    v4 = 0;
    *a2 = *(_DWORD *)(a1 + 24);
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11B10(*((_QWORD *)off_2B148 + 19), 0xF0u, (__int64)&unk_29BA8, v4);
  return v4;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001F4A8) ----------------------------------------------------
__int64 __fastcall sub_1F4A8(__int16 *a1)
{
  void **v2; // r10
  __int16 v3; // ax
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // cx
  __int64 result; // rax
  unsigned __int16 v7; // [rsp+40h] [rbp+8h] BYREF
  __int16 v8; // [rsp+48h] [rbp+10h] BYREF

  v8 = 0;
  v7 = 0;
  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0xCFu, (__int64)&unk_29BA8, a1, &v8);
    v2 = (void **)off_2B148;
  }
  v3 = *a1;
  HIBYTE(v8) = HIBYTE(*a1);
  v8 = HIBYTE(v8) | ((unsigned __int8)v3 << 8);
  if ( v2 != &off_2B148 )
  {
    if ( (*((_BYTE *)v2 + 172) & 0x20) != 0 && *((_BYTE *)v2 + 169) >= 5u )
    {
      sub_11008((__int64)v2[19], 0xD0u, (__int64)&unk_29BA8);
      v2 = (void **)off_2B148;
    }
    if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 172) & 0x20) != 0 && *((_BYTE *)v2 + 169) >= 5u )
    {
      sub_1CEE8((__int64)v2[19], 0xD3u, (__int64)&unk_29BA8, a1, &v7);
      v2 = (void **)off_2B148;
    }
  }
  v4 = a1[1];
  v5 = _byteswap_ushort(v4);
  v7 = v5;
  if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 172) & 0x20) != 0 && *((_BYTE *)v2 + 169) >= 5u )
  {
    sub_11008((__int64)v2[19], 0xD4u, (__int64)&unk_29BA8);
    v5 = v7;
  }
  result = 1i64;
  if ( v8 != 1 || v5 != 2048 )
    result = 0i64;
  return result;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001F638) ----------------------------------------------------
char __fastcall sub_1F638(__int64 a1)
{
  _QWORD *v2; // rcx
  unsigned __int16 v3; // dx
  char v5; // [rsp+38h] [rbp+10h] BYREF
  __int16 v6; // [rsp+40h] [rbp+18h] BYREF

  v5 = 0;
  v6 = 0;
  sub_1D934(a1, &v5);
  if ( (v5 & 1) != 0 )
  {
    v2 = off_2B148;
    if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 172) & 0x20) == 0 || *((_BYTE *)off_2B148 + 169) < 5u )
      return 1;
    v3 = 276;
LABEL_6:
    sub_11008(v2[19], v3, (__int64)&unk_29BA8);
    return 1;
  }
  sub_1D9E4(a1, &v6);
  if ( v6 )
  {
    v2 = off_2B148;
    if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 172) & 0x20) == 0 || *((_BYTE *)off_2B148 + 169) < 5u )
      return 1;
    v3 = 277;
    goto LABEL_6;
  }
  return 0;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001F6F8) ----------------------------------------------------
__int64 __fastcall sub_1F6F8(__int64 a1, int a2, __int64 a3)
{
  void **v6; // rcx
  int v7; // eax
  unsigned int v8; // edi
  __int64 v9; // rax
  int v11; // [rsp+28h] [rbp-10h]

  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x116u, (__int64)&unk_29BA8);
    v6 = (void **)off_2B148;
  }
  if ( a1 && a3 && a2 )
  {
    *(_QWORD *)a3 = a1 + 40;
    sub_1E2E4(a1, (unsigned __int8 *)(a3 + 8));
    v7 = sub_1FAA4(a1, a2, a3);
    v8 = v7;
    if ( v7 )
    {
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 2u )
        sub_11B10(*((_QWORD *)off_2B148 + 19), 0x118u, (__int64)&unk_29BA8, v7);
      v8 = 0;
    }
    v9 = *(_QWORD *)a3;
    *(_QWORD *)(a3 + 32) = a1;
    *(_BYTE *)(a3 + 40) = -1;
    *(_QWORD *)(a3 + 16) = v9 + 2;
    sub_20074(a3);
    v6 = (void **)off_2B148;
  }
  else
  {
    if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 2u )
    {
      v11 = a2;
      sub_1CF30((__int64)v6[19], 0x117u, (__int64)&unk_29BA8, a1, a3, v11);
      v6 = (void **)off_2B148;
    }
    v8 = 4;
  }
  if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_11008((__int64)v6[19], 0x119u, (__int64)&unk_29BA8);
  return v8;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001F88C) ----------------------------------------------------
__int64 __fastcall sub_1F88C(__int64 a1, unsigned int a2, unsigned __int16 *a3)
{
  __int64 v3; // rbx
  void **v6; // r10
  unsigned int v7; // ebx
  char v8; // al
  int v9; // eax
  int v11; // [rsp+28h] [rbp-40h]
  __int64 Src; // [rsp+30h] [rbp-38h] BYREF
  __int64 v13[5]; // [rsp+38h] [rbp-30h] BYREF

  Src = 0i64;
  v3 = a2;
  memset(v13, 0, sizeof(v13));
  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x11Au, (__int64)&unk_29BA8);
    v6 = (void **)off_2B148;
  }
  if ( a1 && a3 && (_DWORD)v3 )
  {
    if ( *(_QWORD *)a3 + (unsigned __int64)a3[12] < v3 + a1 - 1 )
    {
      v8 = **(_BYTE **)a3;
      Src = *(_QWORD *)a3 + a3[12];
      LOBYTE(v13[0]) = v8;
      v9 = sub_1FAA4(a1, v3, (__int64)&Src);
      v7 = v9;
      if ( v9 )
      {
        if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 3u )
          sub_11B10(*((_QWORD *)off_2B148 + 19), 0x11Du, (__int64)&unk_29BA8, v9);
        v7 = 0;
      }
      v13[1] = Src + 2;
      v13[3] = *(_QWORD *)a3;
      LOBYTE(v13[4]) = *((_BYTE *)a3 + 8);
      memmove(a3, &Src, 0x30ui64);
      sub_20074((__int64)a3);
      v6 = (void **)off_2B148;
    }
    else
    {
      if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 3u )
      {
        sub_11008((__int64)v6[19], 0x11Cu, (__int64)&unk_29BA8);
        v6 = (void **)off_2B148;
      }
      v7 = 10;
    }
  }
  else
  {
    if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 2u )
    {
      v11 = v3;
      sub_1CF30((__int64)v6[19], 0x11Bu, (__int64)&unk_29BA8, a1, a3, v11, Src);
      v6 = (void **)off_2B148;
    }
    v7 = 4;
  }
  if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 0x20) != 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_11008((__int64)v6[19], 0x11Eu, (__int64)&unk_29BA8);
  return v7;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001FAA4) ----------------------------------------------------
__int64 __fastcall sub_1FAA4(__int64 a1, int a2, __int64 a3)
{
  unsigned int v5; // esi
  void **v7; // rcx
  __int16 v8; // cx

  v5 = 0;
  v7 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x11Fu, (__int64)&unk_29BA8);
    v7 = (void **)off_2B148;
  }
  if ( !a1 || !a3 || !a2 )
  {
    if ( v7 != &off_2B148 && (*((_BYTE *)v7 + 172) & 0x20) != 0 && *((_BYTE *)v7 + 169) >= 2u )
    {
      sub_1CF30((__int64)v7[19], 0x120u, (__int64)&unk_29BA8, a1, a3, a2);
      v7 = (void **)off_2B148;
    }
    v5 = 4;
    goto LABEL_39;
  }
  if ( v7 != &off_2B148 && (*((_BYTE *)v7 + 172) & 0x20) != 0 && *((_BYTE *)v7 + 169) >= 5u )
  {
    sub_11B10((__int64)v7[19], 0x121u, (__int64)&unk_29BA8, *(unsigned __int8 *)(a3 + 8));
    v7 = (void **)off_2B148;
  }
  switch ( *(_BYTE *)(a3 + 8) )
  {
    case 0:
      goto LABEL_28;
    case 6:
    case 0x11:
LABEL_27:
      *(_WORD *)(a3 + 24) = a1 + a2 - *(_WORD *)a3;
      goto LABEL_30;
    case 0x2B:
LABEL_28:
      v8 = 8 * (*(unsigned __int8 *)(*(_QWORD *)a3 + 1i64) + 1);
      goto LABEL_29;
  }
  if ( *(_BYTE *)(a3 + 8) != 44 )
  {
    if ( *(_BYTE *)(a3 + 8) == 51 )
    {
      v8 = 4 * *(unsigned __int8 *)(*(_QWORD *)a3 + 1i64) + 2;
LABEL_29:
      *(_WORD *)(a3 + 24) = v8;
      goto LABEL_30;
    }
    if ( *(_BYTE *)(a3 + 8) != 58 )
    {
      if ( *(_BYTE *)(a3 + 8) != 60 )
      {
        if ( v7 != &off_2B148 && (*((_BYTE *)v7 + 172) & 0x20) != 0 && *((_BYTE *)v7 + 169) >= 5u )
          sub_11B10((__int64)v7[19], 0x122u, (__int64)&unk_29BA8, *(unsigned __int8 *)(a3 + 8));
        v5 = 5;
        *(_WORD *)(a3 + 24) = 0;
        goto LABEL_30;
      }
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  *(_WORD *)(a3 + 24) = 8;
LABEL_30:
  *(_WORD *)(a3 + 26) = *(_WORD *)a3 - a1;
  v7 = (void **)off_2B148;
  if ( off_2B148 == &off_2B148 )
    return v5;
  if ( (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11D0C(*((_QWORD *)off_2B148 + 19), 0x123u, (__int64)&unk_29BA8, *(unsigned __int16 *)(a3 + 24));
    v7 = (void **)off_2B148;
  }
LABEL_39:
  if ( v7 != &off_2B148 && (*((_BYTE *)v7 + 172) & 0x20) != 0 && *((_BYTE *)v7 + 169) >= 5u )
    sub_11008((__int64)v7[19], 0x124u, (__int64)&unk_29BA8);
  return v5;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000001FD14) ----------------------------------------------------
__int64 __fastcall sub_1FD14(__int64 a1, unsigned __int8 a2, unsigned __int64 *a3)
{
  unsigned int v3; // ebx
  void **v7; // r10
  const char *v8; // rax
  __int64 v9; // r10
  int v10; // eax
  unsigned __int16 v11; // dx
  unsigned __int8 v12; // cl
  unsigned __int64 v13; // rsi
  unsigned __int16 v14; // dx
  __int64 Src; // [rsp+30h] [rbp-48h] BYREF
  char v17[40]; // [rsp+38h] [rbp-40h] BYREF
  unsigned int v18; // [rsp+80h] [rbp+8h] BYREF

  v3 = 0;
  Src = 0i64;
  memset(v17, 0, sizeof(v17));
  v18 = 0;
  v7 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x125u, (__int64)&unk_29BA8);
    v7 = (void **)off_2B148;
  }
  if ( !a1 || !a3 )
  {
    if ( v7 == &off_2B148 || (*((_BYTE *)v7 + 172) & 0x20) == 0 || *((_BYTE *)v7 + 169) < 2u )
      goto LABEL_57;
    sub_1CEE8((__int64)v7[19], 0x126u, (__int64)&unk_29BA8, a1, a3);
    goto LABEL_56;
  }
  if ( v7 != &off_2B148 && (*((_BYTE *)v7 + 172) & 0x20) != 0 && *((_BYTE *)v7 + 169) >= 4u )
  {
    v8 = sub_20274(a2);
    sub_1CE60(*(_QWORD *)(v9 + 152), 0x127u, (__int64)&unk_29BA8, a2, v8);
  }
  sub_1DCC0(a1, &v18);
  v10 = sub_1F6F8(a1, v18, (__int64)&Src);
  if ( v10 )
  {
    v7 = (void **)off_2B148;
    if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 172) & 0x20) == 0 || *((_BYTE *)off_2B148 + 169) < 2u )
      goto LABEL_57;
    v11 = 296;
LABEL_16:
    sub_11B10((__int64)v7[19], v11, (__int64)&unk_29BA8, v10);
    goto LABEL_56;
  }
  v12 = v17[0];
  if ( v17[0] == 59 )
  {
LABEL_56:
    v7 = (void **)off_2B148;
    goto LABEL_57;
  }
  v13 = v18 + a1 - 1;
  while ( 1 )
  {
    if ( *a3 >= v13 )
    {
      v7 = (void **)off_2B148;
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 3u )
      {
        v14 = 297;
        goto LABEL_38;
      }
      goto LABEL_57;
    }
    if ( a2 == v12 )
    {
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
        sub_11008(*((_QWORD *)off_2B148 + 19), 0x12Au, (__int64)&unk_29BA8);
      memmove(a3, &Src, 0x30ui64);
      v7 = (void **)off_2B148;
      goto LABEL_58;
    }
    if ( (v12 > 0x3Cu || v12 != 60 && v12 && (v12 <= 0x2Au || v12 > 0x2Cu && (v12 == 50 || v12 != 51)))
      && v12 != 6
      && v12 != 17
      && v12 != 58 )
    {
      v7 = (void **)off_2B148;
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 3u )
      {
        v14 = 299;
LABEL_38:
        sub_11008((__int64)v7[19], v14, (__int64)&unk_29BA8);
        goto LABEL_56;
      }
      goto LABEL_57;
    }
    v10 = sub_1F88C(a1, v18, (unsigned __int16 *)&Src);
    if ( v10 )
      break;
    v12 = v17[0];
    if ( v17[0] == 59 )
      goto LABEL_56;
  }
  v7 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
  {
    v11 = 300;
    goto LABEL_16;
  }
LABEL_57:
  v3 = 5;
LABEL_58:
  if ( v7 != &off_2B148 && (*((_BYTE *)v7 + 172) & 0x20) != 0 && *((_BYTE *)v7 + 169) >= 5u )
    sub_11008((__int64)v7[19], 0x12Du, (__int64)&unk_29BA8);
  return v3;
}
// 1FDCD: variable 'v9' is possibly undefined
// 2B148: using guessed type void *off_2B148;

//----- (0000000000020074) ----------------------------------------------------
__int64 __fastcall sub_20074(__int64 a1)
{
  unsigned int v1; // edi
  void **v3; // r10
  const char *v4; // rax
  __int64 v5; // r10
  int v6; // er9

  v1 = 0;
  if ( !a1 )
    return 4;
  v3 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 172) & 0x20) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    {
      sub_11008(*((_QWORD *)off_2B148 + 19), 0x136u, (__int64)&unk_29BA8);
      v3 = (void **)off_2B148;
    }
    if ( v3 != &off_2B148 )
    {
      if ( (*((_BYTE *)v3 + 172) & 0x20) != 0 && *((_BYTE *)v3 + 169) >= 5u )
      {
        sub_1A850((__int64)v3[19], 0x137u, (__int64)&unk_29BA8, *(_QWORD *)a1);
        v3 = (void **)off_2B148;
      }
      if ( v3 != &off_2B148 )
      {
        if ( (*((_BYTE *)v3 + 172) & 0x20) != 0 && *((_BYTE *)v3 + 169) >= 5u )
        {
          v4 = sub_20274(*(_BYTE *)(a1 + 8));
          sub_1CE60(*(_QWORD *)(v5 + 152), 0x138u, (__int64)&unk_29BA8, v6, v4);
          v3 = (void **)off_2B148;
        }
        if ( v3 != &off_2B148 )
        {
          if ( (*((_BYTE *)v3 + 172) & 0x20) != 0 && *((_BYTE *)v3 + 169) >= 5u )
          {
            sub_11B10((__int64)v3[19], 0x139u, (__int64)&unk_29BA8, *(unsigned __int16 *)(a1 + 24));
            v3 = (void **)off_2B148;
          }
          if ( v3 != &off_2B148 )
          {
            if ( (*((_BYTE *)v3 + 172) & 0x20) != 0 && *((_BYTE *)v3 + 169) >= 5u )
            {
              sub_11B10((__int64)v3[19], 0x13Au, (__int64)&unk_29BA8, *(unsigned __int16 *)(a1 + 26));
              v3 = (void **)off_2B148;
            }
            if ( v3 != &off_2B148 )
            {
              if ( (*((_BYTE *)v3 + 172) & 0x20) != 0 && *((_BYTE *)v3 + 169) >= 5u )
              {
                sub_1A850((__int64)v3[19], 0x13Bu, (__int64)&unk_29BA8, *(_QWORD *)(a1 + 32));
                v3 = (void **)off_2B148;
              }
              if ( v3 != &off_2B148 && (*((_BYTE *)v3 + 172) & 0x20) != 0 && *((_BYTE *)v3 + 169) >= 5u )
                sub_11B10((__int64)v3[19], 0x13Cu, (__int64)&unk_29BA8, *(unsigned __int8 *)(a1 + 40));
            }
          }
        }
      }
    }
  }
  return v1;
}
// 20149: variable 'v5' is possibly undefined
// 2015D: variable 'v6' is possibly undefined
// 2B148: using guessed type void *off_2B148;

//----- (0000000000020274) ----------------------------------------------------
const char *__fastcall sub_20274(unsigned __int8 a1)
{
  if ( a1 <= 0x3Au )
  {
    switch ( a1 )
    {
      case 0x3Au:
        return "IPv6_ICMPV6_HEADER";
      case 0u:
        return "IPv6_HOP_BY_HOP_HEADER";
      case 4u:
        return "IPv6_IPV4_OVER_IPV6";
      case 6u:
        return "IPv6_TCP_HEADER";
      case 0x11u:
        return "IPv6_UDP_HEADER";
      case 0x2Bu:
        return "IPv6_ROUTING_HEADER";
      case 0x2Cu:
        return "IPv6_FRAGMENT_HEADER";
      case 0x32u:
        return "IPv6_IPSEC_ESP_HEADER";
      case 0x33u:
        return "IPv6_AH_HEADER";
    }
    return "UNKNOWN";
  }
  switch ( a1 )
  {
    case 0x3Bu:
      return "IPv6_NO_NEXT_HEADER";
    case 0x3Cu:
      return "IPv6_DESTINATION_OPTIONS_HEADER";
    case 0x87u:
      return "IPv6_MOBILITY_HEADER";
    case 0x8Bu:
      return "IPv6_HOST_IDENTITY_HEADER";
    case 0x8Cu:
      return "IPv6_SHIM6_HEADER";
    case 0xFDu:
      return "IPv6_EXPERIMENT_TESTING_1";
    case 0xFEu:
      return "IPv6_EXPERIMENT_TESTING_2";
  }
  if ( a1 != 255 )
    return "UNKNOWN";
  return "IPv6_HEADER";
}

//----- (0000000000020364) ----------------------------------------------------
__int64 sub_20364(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2BAB8(a1, 43i64, &unk_29B00, a2, (__int64 *)va);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000203B8) ----------------------------------------------------
__int64 __fastcall sub_203B8(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4)
{
  __int64 v5; // rcx
  const wchar_t *v6; // rdi
  bool v7; // zf

  if ( a4 && *a4 )
  {
    v5 = -1i64;
    v6 = a4;
    do
    {
      if ( !v5 )
        break;
      v7 = *v6++ == 0;
      --v5;
    }
    while ( !v7 );
  }
  if ( a4 )
  {
    if ( !*a4 )
      a4 = L"<NULL>";
  }
  else
  {
    a4 = L"NULL";
  }
  return qword_2BAB8(a1, 43i64, &unk_29B98, 71i64, a4);
}
// 29F18: using guessed type wchar_t aNull_0[7];
// 29F28: using guessed type wchar_t aNull_1[5];
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000020468) ----------------------------------------------------
__int64 sub_20468(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+98h] [rbp+20h] BYREF

  va_start(va, a3);
  *((int *)va + 4) = 92;
  return qword_2BAB8(a1, 43i64, &unk_29B98, 270i64, (__int64 *)va);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000204E0) ----------------------------------------------------
__int64 sub_204E0(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+98h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2BAB8(a1, 43i64, &unk_29B98, 134i64, (__int64 *)va);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000002054C) ----------------------------------------------------
__int64 __fastcall sub_2054C(__int16 *a1, int a2, unsigned int *a3)
{
  void **v6; // rbx
  __int64 v7; // rcx
  unsigned __int16 v8; // dx

  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xAu, (__int64)&unk_29B98);
    v6 = (void **)off_2B148;
  }
  if ( !byte_32282 )
  {
    memset(&qword_31E20, 0, 0x470ui64);
    if ( a3 )
    {
      if ( !(unsigned int)sub_22470(a3) )
      {
        dword_32278 = 0;
        dword_3227C = 0;
        byte_32283 = 0;
        byte_32280 = 0;
        byte_32281 = 0;
        sub_27E30(word_31E40, 520i64, a1);
        dword_32250 = a2;
        byte_32282 = 1;
        sub_20720(1);
        if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
          sub_11B10(*((_QWORD *)off_2B148 + 19), 0xEu, (__int64)&unk_29B98, 0);
        return 0i64;
      }
      if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 172) & 1) == 0 || *((_BYTE *)off_2B148 + 169) < 2u )
        return 264i64;
      v7 = *((_QWORD *)off_2B148 + 19);
      v8 = 13;
    }
    else
    {
      if ( v6 == &off_2B148 || (*((_BYTE *)v6 + 172) & 1) == 0 || *((_BYTE *)v6 + 169) < 2u )
        return 264i64;
      v7 = (__int64)v6[19];
      v8 = 12;
    }
    sub_11008(v7, v8, (__int64)&unk_29B98);
    return 264i64;
  }
  if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 1) != 0 && *((_BYTE *)v6 + 169) >= 2u )
    sub_11008((__int64)v6[19], 0xBu, (__int64)&unk_29B98);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;
// 32250: using guessed type int dword_32250;
// 32278: using guessed type int dword_32278;
// 3227C: using guessed type int dword_3227C;
// 32280: using guessed type char byte_32280;
// 32281: using guessed type char byte_32281;
// 32282: using guessed type char byte_32282;
// 32283: using guessed type char byte_32283;

//----- (0000000000020720) ----------------------------------------------------
__int64 __fastcall sub_20720(char a1)
{
  void **v2; // rcx

  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xFu, (__int64)&unk_29B98);
    v2 = (void **)off_2B148;
  }
  byte_32284 = a1;
  if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 172) & 1) != 0 && *((_BYTE *)v2 + 169) >= 5u )
    sub_11B10((__int64)v2[19], 0x10u, (__int64)&unk_29B98, 0);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;
// 32284: using guessed type char byte_32284;

//----- (00000000000207BC) ----------------------------------------------------
__int64 __fastcall sub_207BC(int a1)
{
  void **v2; // rcx
  __int64 result; // rax
  _QWORD *v4; // rax
  _QWORD *v5; // rcx
  void **v6; // rcx

  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x11u, (__int64)&unk_29B98);
    v2 = (void **)off_2B148;
  }
  if ( byte_32282 )
  {
    if ( !dword_32278 )
    {
      qword_31E28 = (__int64)&qword_31E20;
      qword_31E20 = &qword_31E20;
    }
    v4 = sub_17C28(2, 0x28u, 0x74785072u);
    if ( v4 )
    {
      v4[4] = 0i64;
      *((_DWORD *)v4 + 4) = a1;
      *((_DWORD *)v4 + 6) = 2;
      *((_DWORD *)v4 + 7) = 2;
      v5 = (_QWORD *)qword_31E28;
      *v4 = &qword_31E20;
      v4[1] = v5;
      *v5 = v4;
      ++dword_32278;
      qword_31E28 = (__int64)v4;
      v6 = (void **)off_2B148;
      if ( off_2B148 != &off_2B148 )
      {
        if ( (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
        {
          sub_11B10(*((_QWORD *)off_2B148 + 19), 0x14u, (__int64)&unk_29B98, a1);
          v6 = (void **)off_2B148;
        }
        if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 1) != 0 && *((_BYTE *)v6 + 169) >= 5u )
          sub_11B10((__int64)v6[19], 0x15u, (__int64)&unk_29B98, 0);
      }
      result = 0i64;
    }
    else
    {
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 2u )
        sub_11008(*((_QWORD *)off_2B148 + 19), 0x13u, (__int64)&unk_29B98);
      result = 3i64;
    }
  }
  else
  {
    if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 172) & 1) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x12u, (__int64)&unk_29B98);
    result = 258i64;
  }
  return result;
}
// 2B148: using guessed type void *off_2B148;
// 31E28: using guessed type __int64 qword_31E28;
// 32278: using guessed type int dword_32278;
// 32282: using guessed type char byte_32282;

//----- (0000000000020994) ----------------------------------------------------
__int64 __fastcall sub_20994(int a1, __int64 a2)
{
  void **v4; // rcx
  __int64 result; // rax
  _QWORD *v6; // rax
  _QWORD *v7; // rcx
  void **v8; // rcx

  v4 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x16u, (__int64)&unk_29B98);
    v4 = (void **)off_2B148;
  }
  if ( byte_32282 )
  {
    if ( !dword_3227C )
    {
      qword_31E38 = (__int64)&qword_31E30;
      qword_31E30 = &qword_31E30;
    }
    v6 = sub_17C28(2, 0x48u, 0x746D436Eu);
    if ( v6 )
    {
      v6[6] = 0i64;
      *((_DWORD *)v6 + 4) = a1;
      v6[4] = a2;
      *((_DWORD *)v6 + 6) = 1;
      *((_DWORD *)v6 + 7) = 1;
      v6[8] = &qword_31E20;
      v7 = (_QWORD *)qword_31E38;
      *v6 = &qword_31E30;
      v6[1] = v7;
      *v7 = v6;
      ++dword_3227C;
      qword_31E38 = (__int64)v6;
      v8 = (void **)off_2B148;
      if ( off_2B148 != &off_2B148 )
      {
        if ( (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
        {
          sub_11B10(*((_QWORD *)off_2B148 + 19), 0x19u, (__int64)&unk_29B98, a1);
          v8 = (void **)off_2B148;
        }
        if ( v8 != &off_2B148 && (*((_BYTE *)v8 + 172) & 1) != 0 && *((_BYTE *)v8 + 169) >= 5u )
          sub_11B10((__int64)v8[19], 0x1Au, (__int64)&unk_29B98, 0);
      }
      result = 0i64;
    }
    else
    {
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 2u )
        sub_11008(*((_QWORD *)off_2B148 + 19), 0x18u, (__int64)&unk_29B98);
      result = 3i64;
    }
  }
  else
  {
    if ( v4 != &off_2B148 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x17u, (__int64)&unk_29B98);
    result = 258i64;
  }
  return result;
}
// 2B148: using guessed type void *off_2B148;
// 31E38: using guessed type __int64 qword_31E38;
// 3227C: using guessed type int dword_3227C;
// 32282: using guessed type char byte_32282;

//----- (0000000000020B88) ----------------------------------------------------
__int64 sub_20B88()
{
  void **v0; // rcx
  _QWORD *v2; // rcx
  unsigned __int16 v3; // dx

  v0 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x1Bu, (__int64)&unk_29B98);
    v0 = (void **)off_2B148;
  }
  if ( !byte_32282 )
  {
    if ( v0 != &off_2B148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
      sub_11008((__int64)v0[19], 0x1Cu, (__int64)&unk_29B98);
    return 258i64;
  }
  if ( !dword_32278 && !dword_3227C && v0 != &off_2B148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
    sub_11008((__int64)v0[19], 0x1Du, (__int64)&unk_29B98);
  if ( (unsigned int)sub_21108() )
  {
    v2 = off_2B148;
    if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 172) & 1) == 0 || *((_BYTE *)off_2B148 + 169) < 2u )
      return 257i64;
    v3 = 30;
LABEL_22:
    sub_11008(v2[19], v3, (__int64)&unk_29B98);
    return 257i64;
  }
  if ( (unsigned int)sub_21754() )
  {
    v2 = off_2B148;
    if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 172) & 1) == 0 || *((_BYTE *)off_2B148 + 169) < 2u )
      return 257i64;
    v3 = 31;
    goto LABEL_22;
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x20u, (__int64)&unk_29B98);
  sub_2368C();
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11B10(*((_QWORD *)off_2B148 + 19), 0x21u, (__int64)&unk_29B98, 0);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;
// 32278: using guessed type int dword_32278;
// 3227C: using guessed type int dword_3227C;
// 32282: using guessed type char byte_32282;

//----- (0000000000020D48) ----------------------------------------------------
__int64 __fastcall sub_20D48(unsigned int a1, __int64 a2)
{
  void **v4; // rcx
  __int64 result; // rax
  int v6; // eax

  v4 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x35u, (__int64)&unk_29B98);
    v4 = (void **)off_2B148;
  }
  if ( byte_32283 )
  {
    if ( qword_32258 && a2 )
    {
      v6 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(*((_QWORD *)qword_32258 + 1) + 8i64))(
             **((_QWORD **)qword_32258 + 1),
             a1,
             a2);
      v4 = (void **)off_2B148;
    }
    else
    {
      v6 = 1796;
    }
    if ( v6 )
    {
      if ( v4 != &off_2B148 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 2u )
        sub_11B10((__int64)v4[19], 0x37u, (__int64)&unk_29B98, v6);
      result = 257i64;
    }
    else
    {
      if ( v4 != &off_2B148 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 5u )
        sub_11B10((__int64)v4[19], 0x38u, (__int64)&unk_29B98, 0);
      result = 0i64;
    }
  }
  else
  {
    if ( v4 != &off_2B148 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x36u, (__int64)&unk_29B98);
    result = 260i64;
  }
  return result;
}
// 2B148: using guessed type void *off_2B148;
// 32283: using guessed type char byte_32283;

//----- (0000000000020E98) ----------------------------------------------------
__int64 sub_20E98()
{
  void **v0; // rcx
  int v2; // eax
  unsigned int v3; // edi
  void **v4; // rbx
  PVOID *v5; // rcx
  PVOID *v6; // rcx

  v0 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x39u, (__int64)&unk_29B98);
    v0 = (void **)off_2B148;
  }
  if ( byte_32282 )
  {
    v2 = sub_21EB8();
    v3 = v2;
    if ( v2 )
    {
      v4 = (void **)off_2B148;
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 2u )
      {
        sub_11B10(*((_QWORD *)off_2B148 + 19), 0x3Bu, (__int64)&unk_29B98, v2);
        v4 = (void **)off_2B148;
      }
      if ( v3 != 260 )
        return v3;
    }
    else
    {
      v4 = (void **)off_2B148;
    }
    if ( dword_32278 )
    {
      v5 = (PVOID *)qword_31E20;
      if ( qword_31E20 != &qword_31E20 )
      {
        do
        {
          qword_31E20 = *v5;
          *((_QWORD *)qword_31E20 + 1) = &qword_31E20;
          sub_17CAC(v5, 0x74785072u);
          v5 = (PVOID *)qword_31E20;
        }
        while ( qword_31E20 != &qword_31E20 );
        v4 = (void **)off_2B148;
      }
    }
    if ( dword_3227C )
    {
      v6 = (PVOID *)qword_31E30;
      if ( qword_31E30 != &qword_31E30 )
      {
        do
        {
          qword_31E30 = *v6;
          *((_QWORD *)qword_31E30 + 1) = &qword_31E30;
          sub_17CAC(v6, 0x746D436Eu);
          v6 = (PVOID *)qword_31E30;
        }
        while ( qword_31E30 != &qword_31E30 );
        v4 = (void **)off_2B148;
      }
    }
    if ( qword_32268 && byte_32280 == 1 )
    {
      sub_17CAC(qword_32268, 0x74785072u);
      qword_32268 = 0i64;
      v4 = (void **)off_2B148;
    }
    if ( qword_32270 && byte_32281 == 1 )
    {
      sub_17CAC(qword_32270, 0x746D436Eu);
      v4 = (void **)off_2B148;
    }
    memset(&qword_31E20, 0, 0x470ui64);
    if ( v4 != &off_2B148 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 5u )
      sub_11B10((__int64)v4[19], 0x3Cu, (__int64)&unk_29B98, v3);
    return v3;
  }
  if ( v0 != &off_2B148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
    sub_11008((__int64)v0[19], 0x3Au, (__int64)&unk_29B98);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;
// 32278: using guessed type int dword_32278;
// 3227C: using guessed type int dword_3227C;
// 32280: using guessed type char byte_32280;
// 32281: using guessed type char byte_32281;
// 32282: using guessed type char byte_32282;

//----- (0000000000021108) ----------------------------------------------------
__int64 sub_21108()
{
  void **v0; // rcx
  PVOID v1; // rax
  PVOID v3; // rax

  v0 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x3Du, (__int64)&unk_29B98);
    v0 = (void **)off_2B148;
  }
  if ( dword_32278 )
  {
    v1 = sub_17C28(2, 0x1340u, 0x74785072u);
    qword_32268 = v1;
    if ( !v1 )
      return 3i64;
    memset(v1, 0, 0x1340ui64);
    if ( (unsigned int)sub_21390(0) )
    {
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
        sub_11008(*((_QWORD *)off_2B148 + 19), 0x3Eu, (__int64)&unk_29B98);
      sub_17CAC(qword_32268, 0x74785072u);
      qword_32268 = 0i64;
      return 1i64;
    }
    v0 = (void **)off_2B148;
    if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
    {
      sub_11008(*((_QWORD *)off_2B148 + 19), 0x3Fu, (__int64)&unk_29B98);
      v0 = (void **)off_2B148;
    }
    byte_32280 = 1;
  }
  if ( dword_3227C )
  {
    v3 = sub_17C28(2, 0x9A0u, 0x746D436Eu);
    qword_32270 = v3;
    if ( v3 )
    {
      memset(v3, 0, 0x9A0ui64);
      if ( (unsigned int)sub_21390(1) )
      {
        if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
          sub_11008(*((_QWORD *)off_2B148 + 19), 0x40u, (__int64)&unk_29B98);
        sub_17CAC(qword_32270, 0x746D436Eu);
        qword_32270 = 0i64;
        return 1i64;
      }
      v0 = (void **)off_2B148;
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
      {
        sub_11008(*((_QWORD *)off_2B148 + 19), 0x41u, (__int64)&unk_29B98);
        v0 = (void **)off_2B148;
      }
      byte_32281 = 1;
      goto LABEL_33;
    }
    return 3i64;
  }
LABEL_33:
  if ( v0 != &off_2B148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 5u )
    sub_11B10((__int64)v0[19], 0x42u, (__int64)&unk_29B98, 0);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;
// 32278: using guessed type int dword_32278;
// 3227C: using guessed type int dword_3227C;
// 32280: using guessed type char byte_32280;
// 32281: using guessed type char byte_32281;

//----- (0000000000021390) ----------------------------------------------------
__int64 __fastcall sub_21390(int a1)
{
  unsigned int v2; // edi
  void **v3; // rcx
  PVOID *j; // rbx
  int v5; // edx
  unsigned int v6; // er9
  unsigned __int64 v7; // r8
  PVOID *i; // rbx
  unsigned int v9; // er9
  __int64 v10; // r8
  __int64 (__fastcall *v11)(__int64, __int64, __int64); // rcx
  int v12; // eax

  v2 = 0;
  v3 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x43u, (__int64)&unk_29B98);
    v3 = (void **)off_2B148;
  }
  if ( a1 )
  {
    for ( i = (PVOID *)qword_31E30; i != &qword_31E30; i = (PVOID *)*i )
    {
      v9 = *((_DWORD *)i + 4) - 40000;
      if ( v9 >= 0x4D )
      {
        if ( v3 != &off_2B148 && (*((_BYTE *)v3 + 172) & 1) != 0 && *((_BYTE *)v3 + 169) >= 2u )
        {
          sub_11B10((__int64)v3[19], 0x45u, (__int64)&unk_29B98, v9);
          v3 = (void **)off_2B148;
        }
        v2 = 1;
      }
      else
      {
        v10 = 32i64 * v9;
        *(_DWORD *)((char *)qword_32270 + v10) = *((_DWORD *)i + 4);
        *(_DWORD *)((char *)qword_32270 + v10 + 4) = -1;
        *(_DWORD *)((char *)qword_32270 + v10 + 8) = *((_DWORD *)i + 6);
        *(_DWORD *)((char *)qword_32270 + v10 + 12) = *((_DWORD *)i + 7);
        *(_QWORD *)((char *)qword_32270 + v10 + 24) = i + 3;
        if ( *((_DWORD *)i + 4) == 40005 )
        {
          v11 = sub_22F30;
        }
        else
        {
          v12 = *((_DWORD *)i + 4);
          if ( v12 == 40015
            || v12 == 40016
            || v12 == 40017
            || v12 == 40018
            || v12 == 40019
            || v12 == 40020
            || v12 == 40021
            || v12 == 40023
            || v12 == 40022
            || v12 == 40039
            || v12 == 40044
            || v12 == 40024
            || v12 == 40036
            || v12 == 40012
            || v12 == 40037
            || v12 == 40014
            || v12 == 40041
            || v12 == 40042
            || v12 == 40013
            || v12 == 40038
            || v12 == 40025 )
          {
            v11 = sub_234E8;
          }
          else if ( v12 == 40011
                 || v12 == 40053
                 || v12 == 40050
                 || v12 == 40051
                 || v12 == 40052
                 || v12 == 40045
                 || v12 == 40003 )
          {
            v11 = sub_22B28;
          }
          else
          {
            v11 = sub_228B4;
          }
        }
        *(_QWORD *)((char *)qword_32270 + v10 + 16) = v11;
        v3 = (void **)off_2B148;
      }
    }
  }
  else
  {
    for ( j = (PVOID *)qword_31E20; j != &qword_31E20; j = (PVOID *)*j )
    {
      v5 = *((_DWORD *)j + 4);
      v6 = v5 - 40000;
      if ( (unsigned int)(v5 - 40000) >= 0x4D )
      {
        if ( v3 != &off_2B148 && (*((_BYTE *)v3 + 172) & 1) != 0 && *((_BYTE *)v3 + 169) >= 2u )
        {
          sub_11B10((__int64)v3[19], 0x44u, (__int64)&unk_29B98, v6);
          v3 = (void **)off_2B148;
        }
        v2 = 1;
      }
      else
      {
        v7 = (unsigned __int64)v6 << 6;
        *(_DWORD *)((char *)qword_32268 + v7) = v5;
        *(_DWORD *)((char *)qword_32268 + v7 + 4) = *((_DWORD *)j + 6);
        *(_DWORD *)((char *)qword_32268 + v7 + 8) = -1;
        *(_QWORD *)((char *)qword_32268 + v7 + 16) = 0i64;
        *(_DWORD *)((char *)qword_32268 + v7 + 24) = *((_DWORD *)j + 7);
        *(_QWORD *)((char *)qword_32268 + v7 + 32) = (unsigned __int64)sub_22218 & -(__int64)(j[4] != 0i64);
        *(_QWORD *)((char *)qword_32268 + v7 + 40) = j + 3;
        *(_DWORD *)((char *)qword_32268 + v7 + 48) = 0;
        *(_QWORD *)((char *)qword_32268 + v7 + 56) = 0i64;
        v3 = (void **)off_2B148;
      }
    }
  }
  if ( v3 != &off_2B148 && (*((_BYTE *)v3 + 172) & 1) != 0 && *((_BYTE *)v3 + 169) >= 5u )
    sub_11B10((__int64)v3[19], 0x46u, (__int64)&unk_29B98, v2);
  return v2;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000021754) ----------------------------------------------------
__int64 sub_21754()
{
  void **v0; // rcx
  _QWORD *v1; // rax
  _QWORD *v2; // rbx
  int v3; // edi
  void **v4; // rcx
  unsigned __int16 v5; // dx
  int v6; // er9
  unsigned int v7; // esi
  __int64 v8; // rdi
  _QWORD *v9; // rbp
  int v10; // er12
  int v11; // eax
  __int64 v12; // rax
  int v13; // eax
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // rcx
  void **v18; // r10
  unsigned int v19; // ebx
  __int64 v20; // rdi
  int v21; // er9
  __int64 v22; // rax
  unsigned int v23; // ebx
  __int64 v24; // rdi
  __int64 v25; // rax
  __int64 v26; // rax
  unsigned __int16 v27; // dx
  __int64 (__fastcall **v28)(_QWORD *, _QWORD, _WORD *); // [rsp+60h] [rbp+8h] BYREF

  v0 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_203B8(*((_QWORD *)off_2B148 + 19), 71i64, (__int64)&unk_29B98, word_31E40);
    v0 = (void **)off_2B148;
  }
  if ( byte_32280 || byte_32281 )
    goto LABEL_11;
  if ( v0 != &off_2B148 )
  {
    if ( (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
    {
      sub_11008((__int64)v0[19], 0x48u, (__int64)&unk_29B98);
      v0 = (void **)off_2B148;
    }
LABEL_11:
    if ( v0 != &off_2B148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 4u )
      sub_1A850((__int64)v0[19], 0x49u, (__int64)&unk_29B98, &qword_32258);
  }
  qword_32258 = 0i64;
  v1 = sub_17C28(2, 0x38u, 0x41434E50u);
  v2 = v1;
  if ( !v1 )
  {
    v3 = 1793;
LABEL_25:
    v4 = (void **)off_2B148;
    if ( off_2B148 == &off_2B148 || (*((_BYTE *)off_2B148 + 172) & 1) == 0 || !*((_BYTE *)off_2B148 + 169) )
      return 260i64;
    v5 = 74;
    v6 = v3;
LABEL_53:
    v16 = (__int64)v4[19];
    goto LABEL_54;
  }
  memset(v1, 0, 0x38ui64);
  v3 = sub_26CD0(v2 + 6, v2 + 1);
  if ( v3
    || (v3 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD *))(v2[1] + 8i64))(
               *(_QWORD *)v2[1],
               4026531842i64,
               v2 + 2)) != 0
    || (v3 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD *))(v2[1] + 8i64))(
               *(_QWORD *)v2[1],
               4026531845i64,
               v2 + 5)) != 0
    || (v3 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD *))(v2[1] + 8i64))(
               *(_QWORD *)v2[1],
               4026531843i64,
               v2 + 4)) != 0
    || (v3 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD *))(v2[1] + 8i64))(
               *(_QWORD *)v2[1],
               4026531844i64,
               v2 + 3)) != 0 )
  {
    sub_26E54(v2);
    v2 = qword_32258;
  }
  else
  {
    *(_BYTE *)v2 = 1;
    qword_32258 = v2;
  }
  if ( v3 )
    goto LABEL_25;
  v4 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
  {
    sub_1A850(*((_QWORD *)off_2B148 + 19), 0x4Bu, (__int64)&unk_29B98, &qword_32258, 0i64, 0);
    v4 = (void **)off_2B148;
    v2 = qword_32258;
  }
  v7 = dword_32250;
  v8 = 0i64;
  v9 = v2;
  v10 = 1796;
  if ( v2 )
  {
    v11 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD))(v2[1] + 8i64))(*(_QWORD *)v2[1], 1i64, &v28);
    v4 = (void **)off_2B148;
    v2 = qword_32258;
    if ( !v11 )
    {
      v12 = (*v28)(v9, v7, word_31E40);
      v4 = (void **)off_2B148;
      v2 = qword_32258;
      v8 = v12;
    }
  }
  qword_32260 = v8;
  if ( !v8 )
  {
    if ( v4 != &off_2B148 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) )
      sub_11008((__int64)v4[19], 0x4Cu, (__int64)&unk_29B98);
    return 260i64;
  }
  if ( v4 != &off_2B148 && (*((_BYTE *)v4 + 172) & 1) != 0 && *((_BYTE *)v4 + 169) >= 4u )
  {
    sub_1CF90((__int64)v4[19], 0x4Du, (__int64)&unk_29B98, v2, v8, &qword_32290);
    v4 = (void **)off_2B148;
    v8 = qword_32260;
    v2 = qword_32258;
  }
  v13 = 1796;
  if ( !v8 || (v14 = *(_QWORD *)(v8 + 1112)) == 0 )
  {
LABEL_49:
    if ( v4 == &off_2B148 || (*((_BYTE *)v4 + 172) & 1) == 0 || !*((_BYTE *)v4 + 169) )
      return 260i64;
    v5 = 78;
    v6 = v13;
    goto LABEL_53;
  }
  v13 = (*(__int64 (__fastcall **)(_QWORD *, __int64, __int64 *))(v14 + 112))(v2, v8, &qword_32290);
  if ( v13 )
  {
    v4 = (void **)off_2B148;
    goto LABEL_49;
  }
  v18 = (void **)off_2B148;
  if ( !dword_32278 )
  {
LABEL_71:
    if ( dword_3227C )
    {
      v23 = 0;
      v24 = 0i64;
      do
      {
        if ( v18 != &off_2B148 && (*((_BYTE *)v18 + 172) & 1) != 0 && *((_BYTE *)v18 + 169) >= 4u )
        {
          sub_1CF90(
            (__int64)v18[19],
            0x52u,
            (__int64)&unk_29B98,
            qword_32258,
            qword_32260,
            (char *)qword_32270 + 32 * v23);
          v18 = (void **)off_2B148;
        }
        if ( *(_DWORD *)((char *)qword_32270 + v24) )
        {
          v21 = 1796;
          if ( !qword_32260 )
            goto LABEL_105;
          v25 = *(_QWORD *)(qword_32260 + 1112);
          if ( !v25 )
            goto LABEL_105;
          v21 = (*(__int64 (__fastcall **)(__int64, char *, __int64, __int64))(v25 + 40))(
                  qword_32260,
                  (char *)qword_32270 + 32 * v23,
                  v15,
                  1796i64);
          if ( v21 )
          {
            v18 = (void **)off_2B148;
LABEL_105:
            if ( v18 != &off_2B148 && (*((_BYTE *)v18 + 172) & 1) != 0 && *((_BYTE *)v18 + 169) )
            {
              v27 = 83;
LABEL_103:
              sub_11D0C((__int64)v18[19], v27, (__int64)&unk_29B98, v21);
            }
            return 260i64;
          }
          v18 = (void **)off_2B148;
          if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) )
          {
            sub_11B10(*((_QWORD *)off_2B148 + 19), 0x54u, (__int64)&unk_29B98, v23);
            v18 = (void **)off_2B148;
          }
        }
        ++v23;
        v24 += 32i64;
      }
      while ( v23 < 0x4D );
    }
    if ( v18 != &off_2B148 && (*((_BYTE *)v18 + 172) & 1) != 0 && *((_BYTE *)v18 + 169) >= 4u )
    {
      sub_1CEE8((__int64)v18[19], 0x55u, (__int64)&unk_29B98, qword_32258, qword_32260);
      v18 = (void **)off_2B148;
    }
    if ( qword_32260 )
    {
      v26 = *(_QWORD *)(qword_32260 + 1112);
      if ( v26 )
      {
        v10 = (*(__int64 (__fastcall **)(PVOID))(v26 + 8))(qword_32258);
        if ( !v10 )
        {
          byte_32283 = 1;
          if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
            sub_11B10(*((_QWORD *)off_2B148 + 19), 0x57u, (__int64)&unk_29B98, 0);
          return 0i64;
        }
        v18 = (void **)off_2B148;
      }
    }
    if ( v18 == &off_2B148 || (*((_BYTE *)v18 + 172) & 1) == 0 || !*((_BYTE *)v18 + 169) )
      return 260i64;
    v16 = (__int64)v18[19];
    v5 = 86;
    v6 = v10;
LABEL_54:
    sub_11B10(v16, v5, (__int64)&unk_29B98, v6);
    return 260i64;
  }
  v19 = 0;
  v20 = 0i64;
  while ( 1 )
  {
    if ( v18 != &off_2B148 && (*((_BYTE *)v18 + 172) & 1) != 0 && *((_BYTE *)v18 + 169) >= 4u )
    {
      sub_1CF90(
        (__int64)v18[19],
        0x4Fu,
        (__int64)&unk_29B98,
        qword_32258,
        qword_32260,
        (char *)qword_32268 + 64 * (unsigned __int64)v19);
      v18 = (void **)off_2B148;
    }
    if ( !*(_DWORD *)((char *)qword_32268 + v20) )
      goto LABEL_70;
    v21 = 1796;
    if ( !qword_32260 )
      goto LABEL_99;
    v22 = *(_QWORD *)(qword_32260 + 1112);
    if ( !v22 )
      goto LABEL_99;
    v21 = (*(__int64 (__fastcall **)(__int64, char *, __int64, __int64))(v22 + 64))(
            qword_32260,
            (char *)qword_32268 + 64 * (unsigned __int64)v19,
            v15,
            1796i64);
    if ( v21 )
      break;
    v18 = (void **)off_2B148;
    if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) )
    {
      sub_11B10(*((_QWORD *)off_2B148 + 19), 0x51u, (__int64)&unk_29B98, v19);
      v18 = (void **)off_2B148;
    }
LABEL_70:
    ++v19;
    v20 += 64i64;
    if ( v19 >= 0x4D )
      goto LABEL_71;
  }
  v18 = (void **)off_2B148;
LABEL_99:
  if ( v18 != &off_2B148 && (*((_BYTE *)v18 + 172) & 1) != 0 && *((_BYTE *)v18 + 169) )
  {
    v27 = 80;
    goto LABEL_103;
  }
  return 260i64;
}
// 21BD1: variable 'v15' is possibly undefined
// 2B148: using guessed type void *off_2B148;
// 32250: using guessed type int dword_32250;
// 32260: using guessed type __int64 qword_32260;
// 32278: using guessed type int dword_32278;
// 3227C: using guessed type int dword_3227C;
// 32280: using guessed type char byte_32280;
// 32281: using guessed type char byte_32281;
// 32283: using guessed type char byte_32283;
// 32290: using guessed type __int64 qword_32290;

//----- (0000000000021EB8) ----------------------------------------------------
__int64 sub_21EB8()
{
  void **v0; // rcx
  unsigned int v2; // ebx
  __int64 v3; // rdx
  unsigned int v4; // eax
  PVOID v5; // rdi
  __int64 v6; // rax
  int v7; // esi
  int v8; // eax
  int v9; // er11
  char v10; // al
  __int64 v11; // rax
  __int64 v12; // r8
  int v13; // eax
  __int64 v14; // rdx
  __int64 v15; // [rsp+20h] [rbp-28h]
  __int64 v16; // [rsp+50h] [rbp+8h] BYREF

  v0 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x58u, (__int64)&unk_29B98);
    v0 = (void **)off_2B148;
  }
  if ( !byte_32283 )
  {
    if ( v0 != &off_2B148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
      sub_11008((__int64)v0[19], 0x59u, (__int64)&unk_29B98);
    return 260i64;
  }
  if ( v0 != &off_2B148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 4u )
  {
    sub_1A850((__int64)v0[19], 0x5Au, (__int64)&unk_29B98, qword_32260);
    v0 = (void **)off_2B148;
  }
  v2 = 0;
  if ( qword_32260 )
  {
    v3 = *(_QWORD *)(qword_32260 + 1112);
    if ( v3 )
    {
      v4 = (*(__int64 (__fastcall **)(__int64))(v3 + 88))(qword_32260);
      v0 = (void **)off_2B148;
      v2 = v4;
    }
  }
  if ( v0 != &off_2B148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 4u )
  {
    sub_1A88C((__int64)v0[19], 0x5Bu, (__int64)&unk_29B98, qword_32258, v2);
    v0 = (void **)off_2B148;
  }
  v5 = qword_32258;
  v6 = 0i64;
  v7 = 1796;
  v16 = 0i64;
  if ( qword_32258 )
  {
    v8 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64 *))(*((_QWORD *)qword_32258 + 1) + 8i64))(
           **((_QWORD **)qword_32258 + 1),
           1i64,
           &v16);
    v0 = (void **)off_2B148;
    v9 = v8;
    v6 = v16;
  }
  else
  {
    v9 = 1796;
  }
  if ( !v9 )
  {
    v10 = (*(__int64 (__fastcall **)(PVOID, _QWORD))(v6 + 80))(v5, v2);
    v0 = (void **)off_2B148;
    if ( v10 )
    {
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
      {
        LODWORD(v15) = v2;
        sub_1A88C(*((_QWORD *)off_2B148 + 19), 0x5Du, (__int64)&unk_29B98, qword_32258, v15);
        v0 = (void **)off_2B148;
      }
      v11 = qword_32260;
      if ( qword_32260 )
      {
        v12 = *(_QWORD *)(qword_32260 + 1112);
        if ( v12 )
        {
          v13 = (*(__int64 (__fastcall **)(PVOID, __int64))(v12 + 16))(qword_32258, qword_32260);
          v0 = (void **)off_2B148;
          v7 = v13;
          v11 = qword_32260;
        }
      }
      if ( v7 )
      {
        if ( v0 != &off_2B148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
          sub_11B10((__int64)v0[19], 0x5Eu, (__int64)&unk_29B98, v7 != 0);
        return 257i64;
      }
      if ( v0 != &off_2B148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 4u )
      {
        sub_11008((__int64)v0[19], 0x5Fu, (__int64)&unk_29B98);
        v0 = (void **)off_2B148;
        v11 = qword_32260;
      }
      if ( !v11 )
        goto LABEL_52;
      v14 = *(_QWORD *)(v11 + 1112);
      if ( !v14 )
        goto LABEL_52;
      (*(void (__fastcall **)(__int64))(v14 + 32))(v11);
      goto LABEL_51;
    }
  }
  if ( v0 != &off_2B148 )
  {
    if ( (*((_BYTE *)v0 + 172) & 1) == 0 || *((_BYTE *)v0 + 169) < 2u )
    {
LABEL_52:
      if ( v0 != &off_2B148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 4u )
        sub_1A850((__int64)v0[19], 0x60u, (__int64)&unk_29B98, qword_32258);
      goto LABEL_56;
    }
    sub_11008((__int64)v0[19], 0x5Cu, (__int64)&unk_29B98);
LABEL_51:
    v0 = (void **)off_2B148;
    goto LABEL_52;
  }
LABEL_56:
  sub_26E54(qword_32258);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11B10(*((_QWORD *)off_2B148 + 19), 0x61u, (__int64)&unk_29B98, 0);
  return 0i64;
}
// 22080: variable 'v15' is possibly undefined
// 2B148: using guessed type void *off_2B148;
// 32260: using guessed type __int64 qword_32260;
// 32283: using guessed type char byte_32283;

//----- (0000000000022218) ----------------------------------------------------
__int64 __fastcall sub_22218(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int v3; // esi
  void **v7; // rcx
  void (__fastcall *v9)(_QWORD, _QWORD, _QWORD, int *); // rdi
  unsigned __int16 v10; // dx
  char v11[40]; // [rsp+40h] [rbp-28h] BYREF
  int v12; // [rsp+80h] [rbp+18h] BYREF
  char v13; // [rsp+88h] [rbp+20h] BYREF

  v3 = 0;
  v12 = 0;
  v7 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148
    && _bittest((const signed __int32 *)off_2B148 + 43, 0xAu)
    && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_1CF90(*((_QWORD *)off_2B148 + 19), 0x84u, (__int64)&unk_29B98, a1, a2, a3);
    v7 = (void **)off_2B148;
  }
  if ( a3 )
  {
    if ( a2 )
    {
      v9 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, int *))(a2 + 8);
      if ( v9 )
      {
        if ( v7 != &off_2B148 && _bittest((const signed __int32 *)v7 + 43, 0xAu) && *((_BYTE *)v7 + 169) >= 4u )
        {
          sub_204E0((__int64)v7[19], 134i64, (__int64)&unk_29B98, qword_32258, a3, &v13, &v12);
          v7 = (void **)off_2B148;
        }
        if ( qword_32258 )
        {
          (*(void (__fastcall **)(_QWORD, __int64, char *, int *, char *, _QWORD))(*((_QWORD *)qword_32258 + 5) + 32i64))(
            **((_QWORD **)qword_32258 + 5),
            a3,
            &v13,
            &v12,
            v11,
            0i64);
        }
        else
        {
          v3 = 1799;
          if ( v7 != &off_2B148 && _bittest((const signed __int32 *)v7 + 43, 0xAu) && *((_BYTE *)v7 + 169) >= 2u )
            sub_11B10((__int64)v7[19], 0x87u, (__int64)&unk_29B98, 1799);
        }
        v9(*(unsigned int *)(a3 + 8), *(_QWORD *)(a3 + 56), *(unsigned int *)(a3 + 28), &v12);
        if ( qword_32258 )
          (*(void (__fastcall **)(_QWORD, __int64))(*((_QWORD *)qword_32258 + 5) + 24i64))(
            **((_QWORD **)qword_32258 + 5),
            a3);
        goto LABEL_34;
      }
      if ( v7 != &off_2B148 )
      {
        if ( _bittest((const signed __int32 *)v7 + 43, 0xAu) && *((_BYTE *)v7 + 169) >= 2u )
        {
          v10 = 136;
LABEL_33:
          sub_11008((__int64)v7[19], v10, (__int64)&unk_29B98);
LABEL_34:
          v7 = (void **)off_2B148;
          goto LABEL_35;
        }
        goto LABEL_35;
      }
    }
    else if ( v7 != &off_2B148 )
    {
      if ( _bittest((const signed __int32 *)v7 + 43, 0xAu) && *((_BYTE *)v7 + 169) >= 2u )
      {
        v10 = 137;
        goto LABEL_33;
      }
LABEL_35:
      if ( v7 != &off_2B148 && _bittest((const signed __int32 *)v7 + 43, 0xAu) && *((_BYTE *)v7 + 169) >= 5u )
        sub_11B10((__int64)v7[19], 0x8Au, (__int64)&unk_29B98, v3);
      return v3;
    }
    return v3;
  }
  if ( v7 != &off_2B148 && _bittest((const signed __int32 *)v7 + 43, 0xAu) && *((_BYTE *)v7 + 169) >= 2u )
    sub_11008((__int64)v7[19], 0x85u, (__int64)&unk_29B98);
  return 3899654172i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000022470) ----------------------------------------------------
__int64 __fastcall sub_22470(unsigned int *a1)
{
  void **v2; // rcx
  __int64 result; // rax

  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x8Bu, (__int64)&unk_29B98);
    v2 = (void **)off_2B148;
  }
  qword_32290 = 0i64;
  qword_32298 = 0i64;
  qword_322A0 = 0i64;
  qword_32290 = *a1;
  HIDWORD(qword_32290) = *((unsigned __int8 *)a1 + 4);
  qword_32298 = *((_QWORD *)a1 + 1);
  if ( *((_QWORD *)a1 + 2) )
  {
    qword_322A0 = (__int64)sub_225CC;
    qword_32288 = (__int64 (__fastcall *)(_QWORD))*((_QWORD *)a1 + 2);
    if ( v2 != &off_2B148 )
    {
      if ( (*((_BYTE *)v2 + 172) & 1) != 0 && *((_BYTE *)v2 + 169) >= 4u )
      {
        sub_11008((__int64)v2[19], 0x8Cu, (__int64)&unk_29B98);
        v2 = (void **)off_2B148;
      }
      if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 172) & 1) != 0 && *((_BYTE *)v2 + 169) >= 5u )
        sub_11B10((__int64)v2[19], 0x8Eu, (__int64)&unk_29B98, 0);
    }
    result = 0i64;
  }
  else
  {
    if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 172) & 1) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x8Du, (__int64)&unk_29B98);
    result = 264i64;
  }
  return result;
}
// 2B148: using guessed type void *off_2B148;
// 32288: using guessed type __int64 (__fastcall *qword_32288)(_QWORD);
// 32290: using guessed type __int64 qword_32290;
// 32298: using guessed type __int64 qword_32298;
// 322A0: using guessed type __int64 qword_322A0;

//----- (00000000000225CC) ----------------------------------------------------
__int64 __fastcall sub_225CC(__int64 a1, __int64 a2, __int64 a3)
{
  void **v4; // rcx

  v4 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( _bittest((const signed __int32 *)off_2B148 + 43, 8u) && *((_BYTE *)off_2B148 + 169) >= 5u )
    {
      sub_11008(*((_QWORD *)off_2B148 + 19), 0x8Fu, (__int64)&unk_29B98);
      v4 = (void **)off_2B148;
    }
    if ( v4 != &off_2B148 && _bittest((const signed __int32 *)v4 + 43, 8u) && *((_BYTE *)v4 + 169) >= 4u )
    {
      sub_1A850((__int64)v4[19], 0x90u, (__int64)&unk_29B98, a3);
      v4 = (void **)off_2B148;
    }
  }
  if ( qword_32288 )
  {
    qword_32288(a3);
    v4 = (void **)off_2B148;
  }
  if ( v4 != &off_2B148 && _bittest((const signed __int32 *)v4 + 43, 8u) && *((_BYTE *)v4 + 169) >= 5u )
    sub_11B10((__int64)v4[19], 0x91u, (__int64)&unk_29B98, 0);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;
// 32288: using guessed type __int64 (__fastcall *qword_32288)(_QWORD);

//----- (00000000000226B8) ----------------------------------------------------
__int64 __fastcall sub_226B8(__int64 a1, int a2, unsigned int a3, void *a4)
{
  unsigned int v8; // ebx
  void **v9; // rcx
  _DWORD *v11; // rdi
  __int64 v12; // r8
  int v13; // eax

  v8 = 6;
  v9 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148
    && _bittest((const signed __int32 *)off_2B148 + 43, 8u)
    && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11D0C(*((_QWORD *)off_2B148 + 19), 0x92u, (__int64)&unk_29B98, a2);
    v9 = (void **)off_2B148;
  }
  if ( !byte_32283 )
  {
    if ( v9 != &off_2B148 && _bittest((const signed __int32 *)v9 + 43, 8u) && *((_BYTE *)v9 + 169) >= 2u )
      sub_11008((__int64)v9[19], 0x93u, (__int64)&unk_29B98);
    return 260i64;
  }
  v11 = *(_DWORD **)(a1 + 56);
  if ( v11 )
  {
    if ( a2 && v9 != &off_2B148 && _bittest((const signed __int32 *)v9 + 43, 8u) && *((_BYTE *)v9 + 169) >= 3u )
    {
      sub_11B10((__int64)v9[19], 0x94u, (__int64)&unk_29B98, a2);
      v9 = (void **)off_2B148;
    }
    v12 = a2 != 0 ? 0x80000000 : 0;
    if ( *v11 == 3 || *v11 == 8 )
    {
      v13 = sub_26F08((__int64)qword_32258, a1, v12, a3, a4);
    }
    else
    {
      if ( !qword_32258 )
      {
        v13 = 1799;
        goto LABEL_24;
      }
      v13 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD, _QWORD))(*((_QWORD *)qword_32258 + 3) + 24i64))(
              **((_QWORD **)qword_32258 + 3),
              a1,
              v12,
              0i64,
              0i64);
    }
    v9 = (void **)off_2B148;
LABEL_24:
    if ( v13 )
    {
      if ( v9 != &off_2B148 && _bittest((const signed __int32 *)v9 + 43, 8u) && *((_BYTE *)v9 + 169) >= 2u )
      {
        sub_11B10((__int64)v9[19], 0x95u, (__int64)&unk_29B98, v13);
        v9 = (void **)off_2B148;
      }
      v8 = 273;
    }
    else
    {
      v8 = 0;
    }
  }
  if ( v9 != &off_2B148 && _bittest((const signed __int32 *)v9 + 43, 8u) && *((_BYTE *)v9 + 169) >= 5u )
    sub_11B10((__int64)v9[19], 0x96u, (__int64)&unk_29B98, v8);
  return v8;
}
// 2B148: using guessed type void *off_2B148;
// 32283: using guessed type char byte_32283;

//----- (00000000000228B4) ----------------------------------------------------
__int64 __fastcall sub_228B4(__int64 a1, __int64 a2, __int64 a3)
{
  void **v6; // rcx
  void (__fastcall *v7)(_QWORD, _QWORD, _QWORD, __int64, unsigned int *); // rax
  unsigned int v8; // ebx
  unsigned int v9; // eax
  unsigned __int16 v11; // dx
  unsigned int v12; // [rsp+58h] [rbp+20h] BYREF

  v12 = 3;
  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( _bittest((const signed __int32 *)off_2B148 + 43, 0xAu) && *((_BYTE *)off_2B148 + 169) >= 5u )
    {
      sub_1CF90(*((_QWORD *)off_2B148 + 19), 0x97u, (__int64)&unk_29B98, a1, a2, a3);
      v6 = (void **)off_2B148;
    }
    if ( v6 != &off_2B148 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 4u )
    {
      sub_11B10((__int64)v6[19], 0x98u, (__int64)&unk_29B98, *(_DWORD *)a3);
      v6 = (void **)off_2B148;
    }
  }
  if ( !byte_32284 )
  {
    if ( v6 != &off_2B148 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 3u )
      sub_11008((__int64)v6[19], 0x99u, (__int64)&unk_29B98);
    return 0i64;
  }
  if ( !a2 )
  {
    if ( v6 != &off_2B148 )
    {
      if ( !_bittest((const signed __int32 *)v6 + 43, 0xAu) || *((_BYTE *)v6 + 169) < 2u )
        goto LABEL_37;
      v11 = 157;
LABEL_36:
      sub_11008((__int64)v6[19], v11, (__int64)&unk_29B98);
      v6 = (void **)off_2B148;
      goto LABEL_37;
    }
    return 0i64;
  }
  v7 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, __int64, unsigned int *))(a2 + 8);
  if ( !v7 )
  {
    if ( v6 != &off_2B148 )
    {
      if ( !_bittest((const signed __int32 *)v6 + 43, 0xAu) || *((_BYTE *)v6 + 169) < 2u )
        goto LABEL_37;
      v11 = 156;
      goto LABEL_36;
    }
    return 0i64;
  }
  v7(*(unsigned int *)(a3 + 8), *(_QWORD *)(a3 + 56), *(unsigned int *)(a3 + 28), a3, &v12);
  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148
    && _bittest((const signed __int32 *)off_2B148 + 43, 0xAu)
    && *((_BYTE *)off_2B148 + 169) >= 4u )
  {
    sub_11B10(*((_QWORD *)off_2B148 + 19), 0x9Au, (__int64)&unk_29B98, v12);
    v6 = (void **)off_2B148;
  }
  if ( !qword_32258 )
  {
    v8 = 1799;
    goto LABEL_23;
  }
  v9 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD, _QWORD))(*((_QWORD *)qword_32258 + 3) + 24i64))(
         **((_QWORD **)qword_32258 + 3),
         a3,
         v12,
         0i64,
         0i64);
  v6 = (void **)off_2B148;
  v8 = v9;
  if ( !v9 )
  {
LABEL_37:
    if ( v6 != &off_2B148 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 5u )
      sub_11B10((__int64)v6[19], 0x9Eu, (__int64)&unk_29B98, 0);
    return 0i64;
  }
LABEL_23:
  if ( v6 != &off_2B148 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 2u )
    sub_11B10((__int64)v6[19], 0x9Bu, (__int64)&unk_29B98, v8);
  return v8;
}
// 2B148: using guessed type void *off_2B148;
// 32284: using guessed type char byte_32284;

//----- (0000000000022B28) ----------------------------------------------------
__int64 __fastcall sub_22B28(__int64 a1, __int64 a2, __int64 a3)
{
  void **v6; // rcx
  void (__fastcall *v7)(_QWORD, _QWORD, _QWORD, unsigned int *, PVOID *, __int64 *); // rax
  void **v8; // rcx
  int v9; // eax
  unsigned int v10; // ebx
  unsigned __int16 v12; // dx
  __int64 v13; // [rsp+20h] [rbp-28h]
  __int64 Tag; // [rsp+30h] [rbp-18h] BYREF
  PVOID P[2]; // [rsp+38h] [rbp-10h] BYREF
  unsigned int v16; // [rsp+68h] [rbp+20h] BYREF

  P[0] = 0i64;
  v16 = 0;
  LODWORD(Tag) = 0;
  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( _bittest((const signed __int32 *)off_2B148 + 43, 0xAu) && *((_BYTE *)off_2B148 + 169) >= 5u )
    {
      sub_1CF90(*((_QWORD *)off_2B148 + 19), 0x9Fu, (__int64)&unk_29B98, a1, a2, a3, Tag);
      v6 = (void **)off_2B148;
    }
    if ( v6 != &off_2B148 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 4u )
    {
      sub_11B10((__int64)v6[19], 0xA0u, (__int64)&unk_29B98, *(_DWORD *)a3);
      v6 = (void **)off_2B148;
    }
  }
  if ( !byte_32284 )
  {
    if ( v6 != &off_2B148 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 3u )
      sub_11008((__int64)v6[19], 0xA1u, (__int64)&unk_29B98);
    return 0i64;
  }
  if ( !a2 )
  {
    if ( v6 == &off_2B148 )
      return 0i64;
    if ( !_bittest((const signed __int32 *)v6 + 43, 0xAu) || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_46;
    v12 = 167;
    goto LABEL_44;
  }
  v7 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, unsigned int *, PVOID *, __int64 *))(a2 + 16);
  if ( !v7 )
  {
    if ( v6 == &off_2B148 )
      return 0i64;
    if ( !_bittest((const signed __int32 *)v6 + 43, 0xAu) || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_46;
    v12 = 166;
LABEL_44:
    sub_11008((__int64)v6[19], v12, (__int64)&unk_29B98);
    goto LABEL_45;
  }
  v7(*(unsigned int *)(a3 + 8), *(_QWORD *)(a3 + 56), *(unsigned int *)(a3 + 28), &v16, P, &Tag);
  v8 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( _bittest((const signed __int32 *)off_2B148 + 43, 0xAu) && *((_BYTE *)off_2B148 + 169) >= 4u )
    {
      sub_11B10(*((_QWORD *)off_2B148 + 19), 0xA2u, (__int64)&unk_29B98, 5);
      v8 = (void **)off_2B148;
    }
    if ( v8 != &off_2B148 && _bittest((const signed __int32 *)v8 + 43, 0xAu) && *((_BYTE *)v8 + 169) >= 4u )
      sub_11B10((__int64)v8[19], 0xA3u, (__int64)&unk_29B98, v16);
  }
  v9 = sub_26F08((__int64)qword_32258, a3, 5i64, v16, P[0]);
  v10 = v9;
  if ( !v9 )
  {
    if ( !P[0] || !v16 )
      goto LABEL_45;
    LODWORD(v13) = 0;
    sub_17CAC(P[0], Tag);
    v6 = (void **)off_2B148;
    if ( off_2B148 != &off_2B148 )
    {
      if ( _bittest((const signed __int32 *)off_2B148 + 43, 0xAu) && *((_BYTE *)off_2B148 + 169) >= 4u )
      {
        sub_1A850(*((_QWORD *)off_2B148 + 19), 0xA5u, (__int64)&unk_29B98, P[0], v13);
LABEL_45:
        v6 = (void **)off_2B148;
      }
LABEL_46:
      if ( v6 != &off_2B148 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 5u )
        sub_11B10((__int64)v6[19], 0xA8u, (__int64)&unk_29B98, 0);
    }
    return 0i64;
  }
  if ( off_2B148 != &off_2B148
    && _bittest((const signed __int32 *)off_2B148 + 43, 0xAu)
    && *((_BYTE *)off_2B148 + 169) >= 2u )
  {
    sub_11B10(*((_QWORD *)off_2B148 + 19), 0xA4u, (__int64)&unk_29B98, v9);
  }
  return v10;
}
// 22D97: variable 'v13' is possibly undefined
// 2B148: using guessed type void *off_2B148;
// 32284: using guessed type char byte_32284;

//----- (0000000000022E40) ----------------------------------------------------
__int64 sub_22E40()
{
  void **v0; // rcx
  __int64 result; // rax
  int v2; // eax
  unsigned int v3; // ebx

  v0 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xE3u, (__int64)&unk_29B98);
    v0 = (void **)off_2B148;
  }
  if ( byte_32282 )
  {
    v2 = sub_207BC(40005);
    v3 = v2;
    if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
      sub_11B10(*((_QWORD *)off_2B148 + 19), 0xE5u, (__int64)&unk_29B98, v2);
    result = v3;
  }
  else
  {
    if ( v0 != &off_2B148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
      sub_11008((__int64)v0[19], 0xE4u, (__int64)&unk_29B98);
    result = 258i64;
  }
  return result;
}
// 2B148: using guessed type void *off_2B148;
// 32282: using guessed type char byte_32282;

//----- (0000000000022F30) ----------------------------------------------------
__int64 __fastcall sub_22F30(__int64 a1, __int64 a2, __int64 a3)
{
  void **v6; // rcx
  void (__fastcall *v7)(_QWORD, _QWORD, __int64, __int64); // rax
  unsigned __int16 v8; // dx

  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    {
      sub_1CF90(*((_QWORD *)off_2B148 + 19), 0xF7u, (__int64)&unk_29B98, a1, a2, a3);
      v6 = (void **)off_2B148;
    }
    if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 1) != 0 && *((_BYTE *)v6 + 169) >= 4u )
    {
      sub_11B10((__int64)v6[19], 0xF8u, (__int64)&unk_29B98, *(_DWORD *)a3);
      v6 = (void **)off_2B148;
    }
  }
  if ( !byte_32284 )
  {
    if ( v6 != &off_2B148 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 3u )
      sub_11008((__int64)v6[19], 0xF9u, (__int64)&unk_29B98);
    return 0i64;
  }
  if ( a2 )
  {
    v7 = *(void (__fastcall **)(_QWORD, _QWORD, __int64, __int64))(a2 + 24);
    if ( v7 )
    {
      v7(*(unsigned int *)(a3 + 8), *(_QWORD *)(a3 + 56), 1024i64, a1);
      v6 = (void **)off_2B148;
      if ( off_2B148 == &off_2B148 )
        return 0i64;
      if ( (*((_BYTE *)off_2B148 + 172) & 1) == 0 || *((_BYTE *)off_2B148 + 169) < 4u )
        goto LABEL_30;
      sub_11B10(*((_QWORD *)off_2B148 + 19), 0xFAu, (__int64)&unk_29B98, 3);
      goto LABEL_29;
    }
    if ( v6 == &off_2B148 )
      return 0i64;
    if ( (*((_BYTE *)v6 + 172) & 1) == 0 || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_30;
    v8 = 251;
  }
  else
  {
    if ( v6 == &off_2B148 )
      return 0i64;
    if ( (*((_BYTE *)v6 + 172) & 1) == 0 || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_30;
    v8 = 252;
  }
  sub_11008((__int64)v6[19], v8, (__int64)&unk_29B98);
LABEL_29:
  v6 = (void **)off_2B148;
LABEL_30:
  if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 1) != 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_11B10((__int64)v6[19], 0xFDu, (__int64)&unk_29B98, 0);
  return 0i64;
}
// 23033: variable 'a1' is possibly undefined
// 2B148: using guessed type void *off_2B148;
// 32284: using guessed type char byte_32284;

//----- (0000000000023110) ----------------------------------------------------
__int64 sub_23110()
{
  void **v0; // rcx
  __int64 result; // rax
  int v2; // eax
  unsigned int v3; // ebx

  v0 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xFEu, (__int64)&unk_29B98);
    v0 = (void **)off_2B148;
  }
  if ( byte_32282 )
  {
    v2 = sub_207BC(40018);
    v3 = v2;
    if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
      sub_11B10(*((_QWORD *)off_2B148 + 19), 0x100u, (__int64)&unk_29B98, v2);
    result = v3;
  }
  else
  {
    if ( v0 != &off_2B148 && (*((_BYTE *)v0 + 172) & 1) != 0 && *((_BYTE *)v0 + 169) >= 2u )
      sub_11008((__int64)v0[19], 0xFFu, (__int64)&unk_29B98);
    result = 258i64;
  }
  return result;
}
// 2B148: using guessed type void *off_2B148;
// 32282: using guessed type char byte_32282;

//----- (0000000000023200) ----------------------------------------------------
__int64 __fastcall sub_23200(__int64 a1, const void *a2)
{
  unsigned int v2; // edi
  void **v4; // rcx
  __int64 result; // rax
  __int64 v6; // rdx
  unsigned int v7; // ebx
  int v8; // eax
  void **v9; // rcx
  __int64 v10; // [rsp+78h] [rbp+20h] BYREF

  v2 = 0;
  v10 = 0i64;
  v4 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148
    && _bittest((const signed __int32 *)off_2B148 + 43, 0xDu)
    && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x10Bu, (__int64)&unk_29B98);
    v4 = (void **)off_2B148;
  }
  if ( !byte_32283 )
  {
    if ( v4 != &off_2B148 && _bittest((const signed __int32 *)v4 + 43, 0xDu) && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x10Cu, (__int64)&unk_29B98);
    return 260i64;
  }
  if ( v4 != &off_2B148 && _bittest((const signed __int32 *)v4 + 43, 0xDu) && *((_BYTE *)v4 + 169) >= 4u )
  {
    sub_20468((__int64)v4[19], 270i64, (__int64)&unk_29B98, qword_32258, &unk_31E40, 92, &v10);
    v4 = (void **)off_2B148;
  }
  v6 = *((_QWORD *)qword_32268 + 146);
  v10 = 0i64;
  if ( !qword_32258 )
  {
    v7 = 1799;
    goto LABEL_19;
  }
  v7 = sub_27004((__int64)qword_32258, v6, &v10);
  if ( v7 )
  {
    v4 = (void **)off_2B148;
LABEL_19:
    if ( v4 != &off_2B148 && _bittest((const signed __int32 *)v4 + 43, 0xDu) && *((_BYTE *)v4 + 169) >= 2u )
      sub_11B10((__int64)v4[19], 0x10Fu, (__int64)&unk_29B98, v7);
    return v7;
  }
  if ( v10 )
  {
    memmove(*(void **)(v10 + 56), a2, 0x5Cui64);
    if ( off_2B148 != &off_2B148
      && _bittest((const signed __int32 *)off_2B148 + 43, 0xDu)
      && *((_BYTE *)off_2B148 + 169) >= 4u )
    {
      sub_1CEE8(*((_QWORD *)off_2B148 + 19), 0x111u, (__int64)&unk_29B98, qword_32258, v10);
    }
    v8 = sub_26EC4((__int64)qword_32258, v10);
    if ( v8 )
    {
      v9 = (void **)off_2B148;
      if ( off_2B148 != &off_2B148
        && _bittest((const signed __int32 *)off_2B148 + 43, 0xDu)
        && *((_BYTE *)off_2B148 + 169) >= 2u )
      {
        sub_11B10(*((_QWORD *)off_2B148 + 19), 0x112u, (__int64)&unk_29B98, v8);
        v9 = (void **)off_2B148;
      }
      v2 = 263;
    }
    else
    {
      v9 = (void **)off_2B148;
    }
    if ( v10 )
    {
      if ( qword_32258 )
      {
        (*(void (__fastcall **)(_QWORD))(*((_QWORD *)qword_32258 + 5) + 24i64))(**((_QWORD **)qword_32258 + 5));
        v9 = (void **)off_2B148;
      }
      v10 = 0i64;
    }
    if ( v9 != &off_2B148 && _bittest((const signed __int32 *)v9 + 43, 0xDu) && *((_BYTE *)v9 + 169) >= 5u )
      sub_11B10((__int64)v9[19], 0x113u, (__int64)&unk_29B98, v2);
    result = v2;
  }
  else
  {
    if ( off_2B148 != &off_2B148
      && _bittest((const signed __int32 *)off_2B148 + 43, 0xDu)
      && *((_BYTE *)off_2B148 + 169) >= 2u )
    {
      sub_11008(*((_QWORD *)off_2B148 + 19), 0x110u, (__int64)&unk_29B98);
    }
    result = 6i64;
  }
  return result;
}
// 2B148: using guessed type void *off_2B148;
// 32283: using guessed type char byte_32283;

//----- (00000000000234E8) ----------------------------------------------------
__int64 __fastcall sub_234E8(__int64 a1, __int64 a2, __int64 a3)
{
  void **v6; // rcx
  void (__fastcall *v7)(_QWORD, _QWORD, _QWORD, __int64); // rax
  unsigned __int16 v8; // dx

  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    {
      sub_1CF90(*((_QWORD *)off_2B148 + 19), 0x114u, (__int64)&unk_29B98, a1, a2, a3);
      v6 = (void **)off_2B148;
    }
    if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 1) != 0 && *((_BYTE *)v6 + 169) >= 4u )
    {
      sub_11B10((__int64)v6[19], 0x115u, (__int64)&unk_29B98, *(_DWORD *)a3);
      v6 = (void **)off_2B148;
    }
  }
  if ( !byte_32284 )
  {
    if ( v6 != &off_2B148 && _bittest((const signed __int32 *)v6 + 43, 0xAu) && *((_BYTE *)v6 + 169) >= 3u )
      sub_11008((__int64)v6[19], 0x116u, (__int64)&unk_29B98);
    return 0i64;
  }
  if ( !a2 )
  {
    if ( v6 == &off_2B148 )
      return 0i64;
    if ( (*((_BYTE *)v6 + 172) & 1) == 0 || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_27;
    v8 = 280;
    goto LABEL_25;
  }
  v7 = *(void (__fastcall **)(_QWORD, _QWORD, _QWORD, __int64))(a2 + 32);
  if ( !v7 )
  {
    if ( v6 == &off_2B148 )
      return 0i64;
    if ( (*((_BYTE *)v6 + 172) & 1) == 0 || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_27;
    v8 = 279;
LABEL_25:
    sub_11008((__int64)v6[19], v8, (__int64)&unk_29B98);
    goto LABEL_26;
  }
  v7(*(unsigned int *)(a3 + 8), *(_QWORD *)(a3 + 56), *(unsigned int *)(a3 + 28), a1);
LABEL_26:
  v6 = (void **)off_2B148;
LABEL_27:
  if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 1) != 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_11B10((__int64)v6[19], 0x119u, (__int64)&unk_29B98, 0);
  return 0i64;
}
// 235E9: variable 'a1' is possibly undefined
// 2B148: using guessed type void *off_2B148;
// 32284: using guessed type char byte_32284;

//----- (000000000002368C) ----------------------------------------------------
__int64 sub_2368C()
{
  unsigned int v0; // ebx
  void **v1; // rcx
  int v2; // eax

  v0 = 0;
  v1 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x11Au, (__int64)&unk_29B98);
    v1 = (void **)off_2B148;
  }
  if ( qword_322A8 )
    goto LABEL_12;
  v2 = sub_20D48(9u, (__int64)&qword_322A8);
  v0 = v2;
  if ( !v2 )
    goto LABEL_11;
  v1 = (void **)off_2B148;
  if ( off_2B148 == &off_2B148 )
    return v0;
  if ( (*((_BYTE *)off_2B148 + 172) & 1) != 0 && *((_BYTE *)off_2B148 + 169) >= 2u )
  {
    sub_11B10(*((_QWORD *)off_2B148 + 19), 0x11Bu, (__int64)&unk_29B98, v2);
LABEL_11:
    v1 = (void **)off_2B148;
  }
LABEL_12:
  if ( v1 != &off_2B148 && (*((_BYTE *)v1 + 172) & 1) != 0 && *((_BYTE *)v1 + 169) >= 5u )
    sub_11B10((__int64)v1[19], 0x11Cu, (__int64)&unk_29B98, v0);
  return v0;
}
// 2B148: using guessed type void *off_2B148;
// 322A8: using guessed type __int64 qword_322A8;

//----- (0000000000023784) ----------------------------------------------------
void __fastcall DeferredRoutine(_KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
  if ( DeferredContext )
    ((void (__fastcall *)(_KDPC *, PVOID, PVOID, PVOID))DeferredContext)(
      Dpc,
      DeferredContext,
      SystemArgument1,
      SystemArgument2);
  KeSetTimer(&Timer, (LARGE_INTEGER)qword_34898, &::Dpc);
}
// 34898: using guessed type __int64 qword_34898;

//----- (00000000000237B8) ----------------------------------------------------
__int64 __fastcall sub_237B8(__int64 a1, const void *a2, size_t a3)
{
  void **v6; // rcx
  _DWORD *v7; // rdx
  int v8; // eax
  size_t v9; // rdx

  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x40) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x23u, (__int64)&unk_29B88);
    v6 = (void **)off_2B148;
  }
  v7 = *(_DWORD **)(a1 + 132);
  if ( !v7 || (v8 = *(_DWORD *)(a1 + 140)) == 0 )
  {
    if ( v6 == &off_2B148 )
      return 0i64;
    if ( (*((_BYTE *)v6 + 172) & 0x40) == 0 || *((_BYTE *)v6 + 169) < 4u )
    {
LABEL_19:
      if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 0x40) != 0 && *((_BYTE *)v6 + 169) >= 5u )
        sub_11008((__int64)v6[19], 0x26u, (__int64)&unk_29B88);
      return 0i64;
    }
    sub_11008((__int64)v6[19], 0x25u, (__int64)&unk_29B88);
LABEL_18:
    v6 = (void **)off_2B148;
    goto LABEL_19;
  }
  v9 = (unsigned int)(v8 - *v7);
  if ( v9 > a3 )
  {
    sub_27D8C((void *)(**(unsigned int **)(a1 + 132) + *(_QWORD *)(a1 + 132) + 4i64), v9, a2, a3);
    **(_DWORD **)(a1 + 132) += a3;
    goto LABEL_18;
  }
  if ( v6 != &off_2B148 && (*((_BYTE *)v6 + 172) & 0x40) != 0 && *((_BYTE *)v6 + 169) >= 2u )
    sub_11008((__int64)v6[19], 0x24u, (__int64)&unk_29B88);
  return 10i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000023918) ----------------------------------------------------
__int64 sub_23918(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2BAB8(a1, 43i64, &unk_29B00, a2, (__int64 *)va);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000023968) ----------------------------------------------------
__int64 sub_23968(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+88h] [rbp+20h] BYREF

  va_start(va, a3);
  return qword_2BAB8(a1, 43i64, &unk_29B00, 103i64, (__int64 *)va);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000239CC) ----------------------------------------------------
__int64 __fastcall sub_239CC(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+88h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2BAB8(a1, 43i64, &unk_29B00, a2, &v5);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000023A28) ----------------------------------------------------
__int64 __fastcall sub_23A28(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+98h] [rbp+20h] BYREF

  v5 = a4;
  return qword_2BAB8(a1, 43i64, &unk_29B00, 189i64, &v5);
}
// 2BAB8: using guessed type __int64 (__fastcall *qword_2BAB8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000023A98) ----------------------------------------------------
__int64 __fastcall sub_23A98(int a1, _QWORD *a2)
{
  void **v4; // rcx
  int v6; // ebx

  v4 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xAu, (__int64)&unk_29B00);
    v4 = (void **)off_2B148;
  }
  if ( a2 )
  {
    if ( a1 )
    {
      v6 = a1 - 1;
      if ( !v6 )
      {
        if ( v4 != &off_2B148 )
        {
          if ( *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
          {
            sub_11008((__int64)v4[19], 0xDu, (__int64)&unk_29B00);
            v4 = (void **)off_2B148;
          }
          if ( v4 != &off_2B148 && (*((_BYTE *)v4 + 108) & 0x20) != 0 && *((_BYTE *)v4 + 105) >= 4u )
            sub_17BA8((__int64)v4[11], 0x1Au);
        }
        sub_192E8(a2);
        goto LABEL_32;
      }
      if ( v6 == 1 )
      {
        if ( v4 != &off_2B148 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
          sub_11008((__int64)v4[19], 0xEu, (__int64)&unk_29B00);
        sub_18810((__int64)a2);
        goto LABEL_32;
      }
    }
    else
    {
      if ( v4 == &off_2B148 )
        return 0i64;
      if ( *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
      {
        sub_11008((__int64)v4[19], 0xCu, (__int64)&unk_29B00);
LABEL_32:
        v4 = (void **)off_2B148;
        goto LABEL_33;
      }
    }
LABEL_33:
    if ( v4 != &off_2B148 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
      sub_11008((__int64)v4[19], 0xFu, (__int64)&unk_29B00);
    return 0i64;
  }
  if ( v4 != &off_2B148 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 2u )
    sub_11008((__int64)v4[19], 0xBu, (__int64)&unk_29B00);
  return 3i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000023C7C) ----------------------------------------------------
__int64 __fastcall sub_23C7C(int a1, __int64 a2)
{
  void **v4; // rcx
  int v6; // ebx
  unsigned __int16 v7; // dx

  v4 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x10u, (__int64)&unk_29B00);
    v4 = (void **)off_2B148;
  }
  if ( a2 )
  {
    if ( a1 )
    {
      v6 = a1 - 1;
      if ( v6 )
      {
        if ( v6 != 1 )
          goto LABEL_27;
        if ( v4 != &off_2B148 )
        {
          if ( *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
          {
            v7 = 20;
LABEL_26:
            sub_11008((__int64)v4[19], v7, (__int64)&unk_29B00);
            v4 = (void **)off_2B148;
            goto LABEL_27;
          }
          goto LABEL_27;
        }
      }
      else if ( v4 != &off_2B148 )
      {
        if ( *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
        {
          v7 = 19;
          goto LABEL_26;
        }
LABEL_27:
        if ( v4 != &off_2B148 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
          sub_11008((__int64)v4[19], 0x15u, (__int64)&unk_29B00);
        return 0i64;
      }
    }
    else if ( v4 != &off_2B148 )
    {
      if ( *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
      {
        v7 = 18;
        goto LABEL_26;
      }
      goto LABEL_27;
    }
    return 0i64;
  }
  if ( v4 != &off_2B148 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 2u )
    sub_11008((__int64)v4[19], 0x11u, (__int64)&unk_29B00);
  return 3i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000023DDC) ----------------------------------------------------
__int64 __fastcall sub_23DDC(int a1, struct _FAST_MUTEX *a2, KIRQL *a3)
{
  _QWORD *v3; // rcx
  unsigned __int16 v4; // dx
  int v6; // ecx

  if ( !a2 )
  {
    v3 = off_2B148;
    if ( off_2B148 == &off_2B148 || *((char *)off_2B148 + 172) >= 0 || *((_BYTE *)off_2B148 + 169) < 2u )
      return 3i64;
    v4 = 22;
LABEL_6:
    sub_11008(v3[19], v4, (__int64)&unk_29B00);
    return 3i64;
  }
  if ( !a3 )
  {
    v3 = off_2B148;
    if ( off_2B148 == &off_2B148 || *((char *)off_2B148 + 172) >= 0 || *((_BYTE *)off_2B148 + 169) < 2u )
      return 3i64;
    v4 = 23;
    goto LABEL_6;
  }
  v6 = a1 - 1;
  if ( v6 )
  {
    if ( v6 == 1 )
      sub_188F0(a2);
  }
  else
  {
    sub_185F0((PKSPIN_LOCK)a2, a3);
  }
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000023EA0) ----------------------------------------------------
__int64 __fastcall sub_23EA0(int a1, struct _FAST_MUTEX *a2, KIRQL a3)
{
  __int64 result; // rax
  int v4; // ecx

  if ( a2 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
        sub_189BC(a2);
    }
    else
    {
      sub_18668((PKSPIN_LOCK)a2, a3);
    }
    result = 0i64;
  }
  else
  {
    if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_2B148 + 19), 0x18u, (__int64)&unk_29B00);
    result = 3i64;
  }
  return result;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000023F34) ----------------------------------------------------
__int64 __fastcall sub_23F34(__int64 a1, __int64 a2, char a3)
{
  void **v6; // rcx
  unsigned __int16 v7; // dx

  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x19u, (__int64)&unk_29B00);
    v6 = (void **)off_2B148;
  }
  if ( !a1 )
  {
    if ( v6 == &off_2B148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 26;
LABEL_10:
    sub_11008((__int64)v6[19], v7, (__int64)&unk_29B00);
    return 3i64;
  }
  if ( !a2 )
  {
    if ( v6 == &off_2B148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 27;
    goto LABEL_10;
  }
  *(_DWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 8) = a2;
  *(_QWORD *)a2 = a2;
  if ( a3 )
    sub_23A98(*(_DWORD *)(a1 + 24), (_QWORD *)(a2 + 24));
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x1Cu, (__int64)&unk_29B00);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000024060) ----------------------------------------------------
__int64 __fastcall sub_24060(__int64 a1, __int64 a2, char a3)
{
  void **v6; // rcx
  unsigned __int16 v7; // dx

  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x1Du, (__int64)&unk_29B00);
    v6 = (void **)off_2B148;
  }
  if ( !a1 )
  {
    if ( v6 == &off_2B148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 30;
LABEL_10:
    sub_11008((__int64)v6[19], v7, (__int64)&unk_29B00);
    return 3i64;
  }
  if ( !a2 )
  {
    if ( v6 == &off_2B148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 31;
    goto LABEL_10;
  }
  if ( a3 )
  {
    sub_23C7C(*(_DWORD *)(a1 + 24), a2 + 24);
    v6 = (void **)off_2B148;
  }
  if ( v6 != &off_2B148 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_11008((__int64)v6[19], 0x20u, (__int64)&unk_29B00);
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000024184) ----------------------------------------------------
_DWORD *__fastcall sub_24184(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6, int a7, int a8, int a9, int a10, _DWORD *a11)
{
  int v11; // eax
  int v12; // ebp
  _DWORD *v14; // rbx
  char *v15; // rax
  unsigned int i; // edi
  void **v17; // rcx

  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x21u, (__int64)&unk_29B00);
  *a11 = 0;
  v11 = sub_26964();
  v12 = v11;
  if ( !v11 )
  {
    if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 2u )
      sub_11B10(*((_QWORD *)off_2B148 + 19), 0x23u, (__int64)&unk_29B00, 256);
    *a11 = 3;
    return 0i64;
  }
  v14 = sub_17C28(2, 16 * (5 * v11 + 5), 0x6673696Eu);
  if ( !v14 )
  {
    if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_2B148 + 19), 0x25u, (__int64)&unk_29B00);
LABEL_17:
    *a11 = 2;
    return 0i64;
  }
  v15 = sub_17E94(1, 0x38u, 0x6673696Eu);
  *((_QWORD *)v14 + 9) = v15;
  if ( !v15 )
  {
    if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_2B148 + 19), 0x26u, (__int64)&unk_29B00);
    sub_17CAC(v14, 0x6673696Eu);
    goto LABEL_17;
  }
  v14[6] = 2;
  v14[3] = 1718839662;
  *v14 = 0;
  v14[1] = v12;
  v14[2] = 0;
  *((_QWORD *)v14 + 2) = a5;
  for ( i = 0; i < v14[1]; ++i )
    sub_23F34((__int64)v14, (__int64)&v14[20 * i + 20], 1);
  *((_QWORD *)v14 + 5) = 0i64;
  *((_QWORD *)v14 + 6) = 0i64;
  *((_QWORD *)v14 + 7) = 0i64;
  *((_QWORD *)v14 + 8) = 0i64;
  v17 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
    {
      sub_239CC(*((_QWORD *)off_2B148 + 19), 0x27u, (__int64)&unk_29B00, v14[1]);
      v17 = (void **)off_2B148;
    }
    if ( v17 != &off_2B148 && *((char *)v17 + 172) < 0 && *((_BYTE *)v17 + 169) >= 5u )
      sub_11008((__int64)v17[19], 0x28u, (__int64)&unk_29B00);
  }
  return v14;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000024410) ----------------------------------------------------
__int64 __fastcall sub_24410(__int64 a1)
{
  char *v1; // rdi
  void **v2; // rcx
  __int64 v4; // rsi
  _QWORD **v5; // r12
  int v6; // ecx
  struct _FAST_MUTEX *v7; // r14
  _QWORD *v8; // rbp
  __int64 v9; // r13
  void **v10; // rcx
  ULONG_PTR v11; // rbx
  int v12; // eax
  int i; // ebx
  __int64 j; // rbx
  void **v15; // rcx
  __int64 v16; // [rsp+20h] [rbp-98h]
  __int64 v17; // [rsp+30h] [rbp-88h] BYREF
  _BYTE v18[72]; // [rsp+38h] [rbp-80h] BYREF
  __int64 v19; // [rsp+C0h] [rbp+8h] BYREF
  unsigned int v20; // [rsp+D0h] [rbp+18h] BYREF
  union _LARGE_INTEGER Interval; // [rsp+D8h] [rbp+20h] BYREF

  v19 = a1;
  v20 = 0;
  v1 = (char *)qword_31D70;
  v17 = 0i64;
  memset(v18, 0, sizeof(v18));
  v2 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x80) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x36u, (__int64)&unk_29B00);
    v2 = (void **)off_2B148;
  }
  if ( !v1 )
  {
    if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 172) & 0x80) != 0 && *((_BYTE *)v2 + 169) >= 2u )
      sub_11008((__int64)v2[19], 0x37u, (__int64)&unk_29B00);
    return 3i64;
  }
  if ( v2 != &off_2B148 && (*((_BYTE *)v2 + 172) & 0x80) != 0 && *((_BYTE *)v2 + 169) >= 4u )
    sub_239CC((__int64)v2[19], 0x38u, (__int64)&unk_29B00, *((_DWORD *)v1 + 1));
  _InterlockedAdd((volatile signed __int32 *)v1 + 7, 1u);
  v4 = 0i64;
  if ( !*((_DWORD *)v1 + 1) )
    goto LABEL_38;
  v5 = (_QWORD **)(v1 + 80);
  do
  {
    v6 = *((_DWORD *)v1 + 6);
    v7 = (struct _FAST_MUTEX *)&v1[80 * v4 + 104];
    Interval.QuadPart = (LONGLONG)v7;
    sub_23DDC(v6, v7, (KIRQL *)&v19);
    v8 = *v5;
    v9 = (__int64)&v1[80 * v4 + 80];
    if ( *v5 == (_QWORD *)v9 )
      goto LABEL_37;
    v10 = (void **)off_2B148;
    do
    {
      v11 = (ULONG_PTR)v8;
      v8 = (_QWORD *)*v8;
      if ( *(_BYTE *)(v11 + 44) )
      {
        if ( v10 != &off_2B148 && *((char *)v10 + 172) < 0 && *((_BYTE *)v10 + 169) >= 4u )
        {
          LODWORD(v16) = *(_DWORD *)(v11 + 40);
          sub_20364((__int64)v10[19], 0x39u, (__int64)&unk_29B00, *(_QWORD *)(v11 + 16), v16);
LABEL_34:
          v10 = (void **)off_2B148;
          continue;
        }
      }
      else
      {
        if ( !sub_262D8(v1, &v20) )
          v20 = sub_26010((ULONG_PTR)v1, v11, 1);
        if ( *(_DWORD *)(v11 + 40) )
        {
          *(_BYTE *)(v11 + 44) = 1;
          goto LABEL_34;
        }
        v20 = sub_24B28((__int64)v1, v4, (__int64 *)v11);
        if ( !v20 )
        {
          sub_24D24((__int64)v1, (__int64)&v17, v11);
          goto LABEL_34;
        }
        v10 = (void **)off_2B148;
        if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 3u )
        {
          sub_11008(*((_QWORD *)off_2B148 + 19), 0x3Au, (__int64)&unk_29B00);
          goto LABEL_34;
        }
      }
    }
    while ( v8 != (_QWORD *)v9 );
    v7 = (struct _FAST_MUTEX *)Interval.QuadPart;
LABEL_37:
    sub_23EA0(*((_DWORD *)v1 + 6), v7, v19);
    v4 = (unsigned int)(v4 + 1);
    v5 += 10;
  }
  while ( (unsigned int)v4 < *((_DWORD *)v1 + 1) );
LABEL_38:
  sub_24EA4((__int64)v1, (__int64)&v17, 0);
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x80) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x3Bu, (__int64)&unk_29B00);
  v12 = sub_250F0((__int64)v1, &v20);
  if ( v12 )
  {
    Interval.QuadPart = -5000000i64;
    if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x80) != 0 && *((_BYTE *)off_2B148 + 169) >= 3u )
      sub_11B10(*((_QWORD *)off_2B148 + 19), 0x3Cu, (__int64)&unk_29B00, v12);
    for ( i = 0; i < 10; ++i )
    {
      if ( !(unsigned int)sub_250F0((__int64)v1, &v20) )
        break;
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x80) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
        sub_11B10(*((_QWORD *)off_2B148 + 19), 0x3Du, (__int64)&unk_29B00, i);
      KeDelayExecutionThread(0, 0, &Interval);
    }
  }
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x80) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x3Eu, (__int64)&unk_29B00);
  for ( j = 0i64; (unsigned int)j < *((_DWORD *)v1 + 1); j = (unsigned int)(j + 1) )
    sub_24060((__int64)v1, (__int64)&v1[80 * j + 80], 1);
  sub_17F18(*((PVOID *)v1 + 9));
  sub_17CAC(v1, *((_DWORD *)v1 + 3));
  v15 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 )
  {
    if ( (*((_BYTE *)off_2B148 + 172) & 0x80) != 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
    {
      sub_11008(*((_QWORD *)off_2B148 + 19), 0x3Fu, (__int64)&unk_29B00);
      v15 = (void **)off_2B148;
    }
    if ( v15 != &off_2B148 && (*((_BYTE *)v15 + 172) & 0x80) != 0 && *((_BYTE *)v15 + 169) >= 5u )
      sub_11008((__int64)v15[19], 0x40u, (__int64)&unk_29B00);
  }
  return v20;
}
// 245B2: variable 'v16' is possibly undefined
// 2B148: using guessed type void *off_2B148;

//----- (00000000000248A4) ----------------------------------------------------
unsigned __int64 __fastcall sub_248A4(__int64 a1, unsigned __int64 a2, _DWORD *a3)
{
  void **v6; // rcx
  unsigned __int64 result; // rax

  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x5Au, (__int64)&unk_29B00);
    v6 = (void **)off_2B148;
  }
  *a3 = 0;
  if ( a1 )
  {
    if ( v6 != &off_2B148 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 5u )
      sub_11008((__int64)v6[19], 0x5Cu, (__int64)&unk_29B00);
    result = a2 % *(unsigned int *)(a1 + 4);
  }
  else
  {
    if ( v6 != &off_2B148 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 2u )
      sub_11008((__int64)v6[19], 0x5Bu, (__int64)&unk_29B00);
    *a3 = 3;
    result = 0xFFFFFFFFi64;
  }
  return result;
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000249A0) ----------------------------------------------------
_DWORD *__fastcall sub_249A0(__int64 a1, __int64 a2, _DWORD *a3)
{
  void **v6; // rcx
  unsigned __int16 v7; // dx
  _DWORD *v9; // rax
  _DWORD *v10; // rdi
  __int64 v11; // r11

  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x5Du, (__int64)&unk_29B00);
    v6 = (void **)off_2B148;
  }
  *a3 = 0;
  if ( !a1 )
  {
    if ( v6 == &off_2B148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_11;
    v7 = 94;
LABEL_10:
    sub_11008((__int64)v6[19], v7, (__int64)&unk_29B00);
LABEL_11:
    *a3 = 3;
    return 0i64;
  }
  if ( !a2 )
  {
    if ( v6 == &off_2B148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      goto LABEL_11;
    v7 = 95;
    goto LABEL_10;
  }
  v9 = sub_18038(*(_QWORD *)(a1 + 72));
  v10 = v9;
  if ( !v9 )
  {
    if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_2B148 + 19), 0x60u, (__int64)&unk_29B00);
    *a3 = 2;
    return 0i64;
  }
  memset(v9, 0, 0x38ui64);
  v11 = *(_QWORD *)(a1 + 16);
  *((_QWORD *)v10 + 4) = a2;
  *((_QWORD *)v10 + 3) = v11;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x61u, (__int64)&unk_29B00);
  return v10;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000024B28) ----------------------------------------------------
__int64 __fastcall sub_24B28(__int64 a1, unsigned int a2, __int64 *a3)
{
  __int64 v4; // rsi
  void **v6; // rcx
  unsigned __int16 v7; // dx
  __int64 result; // rax
  _QWORD *v9; // rax
  __int64 v10; // rcx
  signed __int32 v11; // eax
  void **v12; // rcx
  __int64 v13; // [rsp+20h] [rbp-28h]
  unsigned int v14; // [rsp+50h] [rbp+8h] BYREF

  v14 = 0;
  v4 = a2;
  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x62u, (__int64)&unk_29B00);
    v6 = (void **)off_2B148;
  }
  if ( !a1 )
  {
    if ( v6 == &off_2B148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 99;
LABEL_10:
    sub_11008((__int64)v6[19], v7, (__int64)&unk_29B00);
    return 3i64;
  }
  if ( !a3 )
  {
    if ( v6 == &off_2B148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 100;
    goto LABEL_10;
  }
  if ( v6 != &off_2B148 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 5u )
    sub_20364((__int64)v6[19], 0x65u, (__int64)&unk_29B00, a3[2], *((_DWORD *)a3 + 10));
  if ( sub_26424((_BYTE *)a1, &v14) )
  {
    if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
      sub_11008(*((_QWORD *)off_2B148 + 19), 0x66u, (__int64)&unk_29B00);
    result = 12i64;
  }
  else
  {
    v9 = (_QWORD *)a3[1];
    v10 = *a3;
    *v9 = *a3;
    *(_QWORD *)(v10 + 8) = v9;
    --*(_DWORD *)(a1 + 80 * v4 + 96);
    v11 = _InterlockedDecrement((volatile signed __int32 *)(a1 + 8));
    v12 = (void **)off_2B148;
    if ( off_2B148 != &off_2B148 )
    {
      if ( *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
      {
        LODWORD(v13) = *(_DWORD *)(a1 + 80 * v4 + 96);
        sub_23968(*((_QWORD *)off_2B148 + 19), 103i64, (__int64)&unk_29B00, a3[2], v13, v11);
        v12 = (void **)off_2B148;
      }
      if ( v12 != &off_2B148 && *((char *)v12 + 172) < 0 && *((_BYTE *)v12 + 169) >= 5u )
        sub_11008((__int64)v12[19], 0x68u, (__int64)&unk_29B00);
    }
    result = v14;
  }
  return result;
}
// 24CCD: variable 'v13' is possibly undefined
// 2B148: using guessed type void *off_2B148;

//----- (0000000000024D24) ----------------------------------------------------
__int64 __fastcall sub_24D24(__int64 a1, __int64 a2, __int64 a3)
{
  void **v6; // rcx
  __int64 *v7; // rax
  __int64 result; // rax
  int v9; // [rsp+20h] [rbp-18h]

  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x69u, (__int64)&unk_29B00);
    v6 = (void **)off_2B148;
  }
  if ( a1 && a2 && a3 )
  {
    if ( !*(_DWORD *)(a2 + 16) )
    {
      sub_23F34(a1, a2, 0);
      v6 = (void **)off_2B148;
    }
    if ( v6 != &off_2B148 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 5u )
    {
      v9 = *(_DWORD *)(a3 + 40);
      sub_20364((__int64)v6[19], 0x6Bu, (__int64)&unk_29B00, *(_QWORD *)(a3 + 16), v9);
    }
    v7 = *(__int64 **)(a2 + 8);
    *(_QWORD *)a3 = a2;
    *(_QWORD *)(a3 + 8) = v7;
    *v7 = a3;
    ++*(_DWORD *)(a2 + 16);
    *(_QWORD *)(a2 + 8) = a3;
    if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_2B148 + 19), 0x6Cu, (__int64)&unk_29B00);
    result = 0i64;
  }
  else
  {
    if ( v6 != &off_2B148 && *((char *)v6 + 172) < 0 && *((_BYTE *)v6 + 169) >= 2u )
      sub_1CF90((__int64)v6[19], 0x6Au, (__int64)&unk_29B00, a1, a2, a3);
    result = 3i64;
  }
  return result;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000024EA4) ----------------------------------------------------
__int64 __fastcall sub_24EA4(__int64 a1, __int64 a2, char a3)
{
  unsigned int v6; // edi
  void **v7; // rcx
  __int64 *v8; // r12
  __int64 *v9; // rsi
  __int64 *v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rcx
  void (__fastcall *v13)(__int64); // rax

  v6 = 0;
  v7 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x6Du, (__int64)&unk_29B00);
    v7 = (void **)off_2B148;
  }
  if ( a1 && a2 )
  {
    if ( !*(_DWORD *)(a2 + 16) )
    {
      v6 = 4;
      goto LABEL_30;
    }
    v8 = *(__int64 **)a2;
    if ( *(_QWORD *)a2 == a2 )
    {
LABEL_30:
      sub_24060(a1, a2, 0);
      if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
        sub_11008(*((_QWORD *)off_2B148 + 19), 0x72u, (__int64)&unk_29B00);
      return v6;
    }
    while ( 1 )
    {
      v9 = v8;
      v8 = (__int64 *)*v8;
      v10 = (__int64 *)v9[1];
      v11 = *v9;
      *v10 = *v9;
      *(_QWORD *)(v11 + 8) = v10;
      --*(_DWORD *)(a2 + 16);
      if ( !a3 )
        goto LABEL_24;
      v12 = v9[4];
      if ( v12 )
      {
        v13 = *(void (__fastcall **)(__int64))(a1 + 56);
        if ( v13 )
        {
          v13(v12);
LABEL_24:
          if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
            sub_1A79C(*((_QWORD *)off_2B148 + 19), 0x71u, (__int64)&unk_29B00, v9[2]);
          sub_180A0(*(_QWORD *)(a1 + 72), (__int64)v9);
          goto LABEL_29;
        }
        if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 2u )
          sub_11008(*((_QWORD *)off_2B148 + 19), 0x70u, (__int64)&unk_29B00);
        v6 = 5;
      }
      else
      {
        if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 2u )
          sub_11008(*((_QWORD *)off_2B148 + 19), 0x6Fu, (__int64)&unk_29B00);
        v6 = 6;
      }
LABEL_29:
      if ( *(_QWORD *)a2 == a2 )
        goto LABEL_30;
    }
  }
  if ( v7 != &off_2B148 && *((char *)v7 + 172) < 0 && *((_BYTE *)v7 + 169) >= 2u )
    sub_1CEE8((__int64)v7[19], 0x6Eu, (__int64)&unk_29B00, a1, a2);
  return 3i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000250F0) ----------------------------------------------------
__int64 __fastcall sub_250F0(__int64 a1, _DWORD *a2)
{
  void **v4; // rcx
  __int64 result; // rax
  unsigned __int32 v6; // ebx

  v4 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x73u, (__int64)&unk_29B00);
    v4 = (void **)off_2B148;
  }
  *a2 = 0;
  if ( a1 )
  {
    v6 = _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 8), 0);
    if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
      sub_11008(*((_QWORD *)off_2B148 + 19), 0x75u, (__int64)&unk_29B00);
    result = v6;
  }
  else
  {
    if ( v4 != &off_2B148 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 2u )
      sub_11008((__int64)v4[19], 0x74u, (__int64)&unk_29B00);
    *a2 = 3;
    result = 0i64;
  }
  return result;
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000251E8) ----------------------------------------------------
__int64 __fastcall sub_251E8(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, _DWORD *a4)
{
  char *v4; // rdi
  unsigned int v8; // er14
  void **v9; // rcx
  __int64 v11; // rbp
  _QWORD **v12; // r15
  _QWORD *v13; // rsi
  __int64 v14; // rbx
  void **v15; // rcx
  _QWORD *v16; // r8
  __int64 v17; // [rsp+20h] [rbp-58h]
  struct _FAST_MUTEX *v18; // [rsp+30h] [rbp-48h]
  __int64 v19; // [rsp+80h] [rbp+8h] BYREF
  char *v20; // [rsp+98h] [rbp+20h]

  v19 = a1;
  v4 = (char *)qword_31D70;
  v8 = 0;
  v20 = (char *)qword_31D70;
  v9 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x76u, (__int64)&unk_29B00);
    v9 = (void **)off_2B148;
  }
  *a4 = 0;
  if ( !v4 )
  {
    if ( v9 != &off_2B148 && *((char *)v9 + 172) < 0 && *((_BYTE *)v9 + 169) >= 2u )
      sub_11008((__int64)v9[19], 0x77u, (__int64)&unk_29B00);
LABEL_10:
    *a4 = 3;
    return 0i64;
  }
  if ( a2 >= a3 )
  {
    if ( v9 != &off_2B148 && *((char *)v9 + 172) < 0 && *((_BYTE *)v9 + 169) >= 2u )
      sub_23918((__int64)v9[19], 0x78u, (__int64)&unk_29B00, a2, a3);
    goto LABEL_10;
  }
  v11 = 0i64;
  if ( *((_DWORD *)v4 + 1) )
  {
    v12 = (_QWORD **)(v4 + 80);
    do
    {
      v18 = (struct _FAST_MUTEX *)&v4[80 * v11 + 104];
      sub_23DDC(*((_DWORD *)v4 + 6), v18, (KIRQL *)&v19);
      v13 = *v12;
      v14 = (__int64)&v4[80 * v11 + 80];
      if ( *v12 != (_QWORD *)v14 )
      {
        v15 = (void **)off_2B148;
        do
        {
          v16 = v13;
          v13 = (_QWORD *)*v13;
          if ( *((_BYTE *)v16 + 44) )
          {
            if ( v15 != &off_2B148 && *((char *)v15 + 172) < 0 && *((_BYTE *)v15 + 169) >= 4u )
            {
              LODWORD(v17) = *((_DWORD *)v16 + 10);
              sub_20364((__int64)v15[19], 0x79u, (__int64)&unk_29B00, v16[2], v17);
              v15 = (void **)off_2B148;
            }
          }
          else if ( v16[3] >= a2 && v16[3] <= a3 )
          {
            ++v8;
          }
        }
        while ( v13 != (_QWORD *)v14 );
        v4 = v20;
      }
      sub_23EA0(*((_DWORD *)v4 + 6), v18, v19);
      v11 = (unsigned int)(v11 + 1);
      v12 += 10;
    }
    while ( (unsigned int)v11 < *((_DWORD *)v4 + 1) );
    v9 = (void **)off_2B148;
  }
  if ( v9 != &off_2B148 && *((char *)v9 + 172) < 0 && *((_BYTE *)v9 + 169) >= 5u )
    sub_11008((__int64)v9[19], 0x7Au, (__int64)&unk_29B00);
  return v8;
}
// 25378: variable 'v17' is possibly undefined
// 2B148: using guessed type void *off_2B148;

//----- (0000000000025424) ----------------------------------------------------
__int64 __fastcall sub_25424(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  volatile signed __int32 *v4; // rdi
  void **v7; // rcx
  unsigned __int16 v8; // dx
  __int64 result; // rax
  ULONG_PTR v10; // rax
  void **v11; // rcx
  unsigned int v12; // ebx
  __int64 v13; // [rsp+68h] [rbp+20h] BYREF

  HIDWORD(v13) = HIDWORD(a4);
  v4 = (volatile signed __int32 *)qword_31D70;
  LODWORD(v13) = 0;
  v7 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x86u, (__int64)&unk_29B00);
    v7 = (void **)off_2B148;
  }
  if ( !v4 )
  {
    if ( v7 == &off_2B148 || *((char *)v7 + 172) >= 0 || *((_BYTE *)v7 + 169) < 2u )
      return 3i64;
    v8 = 135;
LABEL_10:
    sub_11008((__int64)v7[19], v8, (__int64)&unk_29B00);
    return 3i64;
  }
  if ( !a3 )
  {
    if ( v7 == &off_2B148 || *((char *)v7 + 172) >= 0 || *((_BYTE *)v7 + 169) < 2u )
      return 3i64;
    v8 = 136;
    goto LABEL_10;
  }
  if ( _InterlockedCompareExchange(v4 + 7, 0, 0) )
  {
    if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_2B148 + 19), 0x89u, (__int64)&unk_29B00);
    result = 9i64;
  }
  else
  {
    v10 = sub_25A94((ULONG_PTR)v4, a2, a3, 0i64, (__int64)&v13);
    if ( v10 )
    {
      if ( v10 == a3 )
      {
        v12 = v13;
        v11 = (void **)off_2B148;
      }
      else
      {
        v11 = (void **)off_2B148;
        if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 2u )
        {
          sub_1A79C(*((_QWORD *)off_2B148 + 19), 0x8Bu, (__int64)&unk_29B00, a2);
          v11 = (void **)off_2B148;
        }
        v12 = 7;
      }
      if ( v11 != &off_2B148 && *((char *)v11 + 172) < 0 && *((_BYTE *)v11 + 169) >= 5u )
        sub_11008((__int64)v11[19], 0x8Cu, (__int64)&unk_29B00);
      result = v12;
    }
    else
    {
      if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 2u )
        sub_11B10(*((_QWORD *)off_2B148 + 19), 0x8Au, (__int64)&unk_29B00, v13);
      result = (unsigned int)v13;
    }
  }
  return result;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000025648) ----------------------------------------------------
__int64 __fastcall sub_25648(__int64 a1, unsigned __int64 a2, __int64 a3, _DWORD *a4)
{
  char *v4; // rbx
  __int64 v5; // rbp
  void **v8; // rcx
  __int64 v10; // r14
  struct _FAST_MUTEX *v11; // r12
  _QWORD *v12; // rax
  __int64 v13; // rsi
  int v14; // eax
  __int64 v15; // [rsp+20h] [rbp-78h] BYREF
  _BYTE v16[72]; // [rsp+28h] [rbp-70h] BYREF
  __int64 v17; // [rsp+A0h] [rbp+8h] BYREF

  v17 = a1;
  v4 = (char *)qword_31D70;
  v5 = 0i64;
  v15 = 0i64;
  memset(v16, 0, sizeof(v16));
  v8 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x80) != 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x93u, (__int64)&unk_29B00);
    v8 = (void **)off_2B148;
  }
  *a4 = 0;
  if ( !v4 )
  {
    if ( v8 != &off_2B148 && (*((_BYTE *)v8 + 172) & 0x80) != 0 && *((_BYTE *)v8 + 169) >= 2u )
      sub_11008((__int64)v8[19], 0x94u, (__int64)&unk_29B00);
    *a4 = 3;
    return 0i64;
  }
  if ( sub_262D8(v4, a4) )
  {
    if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 172) & 0x80) != 0 && *((_BYTE *)off_2B148 + 169) >= 2u )
      sub_11008(*((_QWORD *)off_2B148 + 19), 0x95u, (__int64)&unk_29B00);
    *a4 = 10;
    return 0i64;
  }
  v10 = (unsigned int)sub_248A4((__int64)v4, a2, a4);
  v11 = (struct _FAST_MUTEX *)&v4[80 * v10 + 104];
  sub_23DDC(*((_DWORD *)v4 + 6), v11, (KIRQL *)&v17);
  v12 = sub_258D4((__int64)v4, v10, a2, a4);
  v13 = (__int64)v12;
  if ( v12 )
  {
    if ( *a4 == 8 )
    {
      sub_23EA0(*((_DWORD *)v4 + 6), v11, v17);
      if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 3u )
        sub_1A79C(*((_QWORD *)off_2B148 + 19), 0x96u, (__int64)&unk_29B00, a2, v15);
      return 0i64;
    }
    sub_26010((ULONG_PTR)v4, (ULONG_PTR)v12, 0);
    v5 = *(_QWORD *)(v13 + 32);
    if ( *(_DWORD *)(v13 + 40) )
    {
      *(_BYTE *)(v13 + 44) = 1;
    }
    else
    {
      v14 = sub_24B28((__int64)v4, v10, (__int64 *)v13);
      *a4 = v14;
      if ( !v14 )
        sub_24D24((__int64)v4, (__int64)&v15, v13);
    }
  }
  sub_23EA0(*((_DWORD *)v4 + 6), v11, v17);
  sub_24EA4((__int64)v4, (__int64)&v15, 0);
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x97u, (__int64)&unk_29B00);
  return v5;
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000258D4) ----------------------------------------------------
_QWORD *__fastcall sub_258D4(__int64 a1, unsigned int a2, __int64 a3, _DWORD *a4)
{
  __int64 v6; // r12
  _QWORD *v8; // rsi
  void **v9; // rcx
  _QWORD *result; // rax
  _QWORD *v11; // rdx
  _QWORD *v12; // rbx

  v6 = a2;
  v8 = 0i64;
  v9 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xB0u, (__int64)&unk_29B00);
    v9 = (void **)off_2B148;
  }
  *a4 = 4;
  if ( a1 )
  {
    v11 = (_QWORD *)(a1 + 16 * (5 * v6 + 5));
    if ( (_QWORD *)*v11 != v11 )
    {
      v12 = (_QWORD *)*v11;
      while ( v12 != v11 )
      {
        v8 = v12;
        if ( v12[2] == a3 )
        {
          if ( v9 != &off_2B148 && *((char *)v9 + 172) < 0 && *((_BYTE *)v9 + 169) >= 4u )
          {
            sub_1A558((__int64)v9[19], 0xB2u, (__int64)&unk_29B00, v6);
            v9 = (void **)off_2B148;
          }
          if ( *((_BYTE *)v12 + 44) )
          {
            if ( v9 != &off_2B148 && *((char *)v9 + 172) < 0 && *((_BYTE *)v9 + 169) >= 4u )
            {
              sub_1A79C((__int64)v9[19], 0xB3u, (__int64)&unk_29B00, v12[2]);
              v9 = (void **)off_2B148;
            }
            *a4 = 8;
          }
          else
          {
            *a4 = 0;
          }
          break;
        }
        v12 = (_QWORD *)*v12;
        v8 = 0i64;
      }
    }
    if ( v9 != &off_2B148 && *((char *)v9 + 172) < 0 && *((_BYTE *)v9 + 169) >= 5u )
      sub_11008((__int64)v9[19], 0xB4u, (__int64)&unk_29B00);
    result = v8;
  }
  else
  {
    if ( v9 != &off_2B148 && *((char *)v9 + 172) < 0 && *((_BYTE *)v9 + 169) >= 2u )
      sub_11008((__int64)v9[19], 0xB1u, (__int64)&unk_29B00);
    *a4 = 3;
    result = 0i64;
  }
  return result;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000025A94) ----------------------------------------------------
ULONG_PTR __fastcall sub_25A94(ULONG_PTR BugCheckParameter2, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  ULONG_PTR v5; // rdi
  __int64 v8; // r15
  void **v10; // rcx
  _DWORD *v11; // r12
  int v13; // ebx
  ULONG_PTR *v14; // rax
  ULONG_PTR *v15; // rbp
  ULONG_PTR *v16; // rax
  ULONG_PTR v17; // rcx
  ULONG_PTR **v18; // rax
  ULONG_PTR v19; // [rsp+20h] [rbp-48h]
  int v20; // [rsp+70h] [rbp+8h] BYREF

  v5 = 0i64;
  v20 = 0;
  LODWORD(v8) = 0;
  v10 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xB5u, (__int64)&unk_29B00);
    v10 = (void **)off_2B148;
  }
  v11 = (_DWORD *)a5;
  if ( !a5 )
  {
    if ( v10 != &off_2B148 && *((char *)v10 + 172) < 0 && *((_BYTE *)v10 + 169) >= 2u )
      sub_11008((__int64)v10[19], 0xB6u, (__int64)&unk_29B00);
    return 0i64;
  }
  if ( !BugCheckParameter2 )
  {
    if ( v10 != &off_2B148 && *((char *)v10 + 172) < 0 && *((_BYTE *)v10 + 169) >= 2u )
      sub_11008((__int64)v10[19], 0xB7u, (__int64)&unk_29B00);
    *v11 = 3;
    return 0i64;
  }
  if ( a3 )
  {
    if ( _InterlockedCompareExchange((volatile signed __int32 *)(BugCheckParameter2 + 28), 0, 0) )
    {
      if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 2u )
        sub_11008(*((_QWORD *)off_2B148 + 19), 0xB9u, (__int64)&unk_29B00);
      *v11 = 9;
      return 0i64;
    }
    v8 = (unsigned int)sub_248A4(BugCheckParameter2, a2, &v20);
    sub_23DDC(
      *(_DWORD *)(BugCheckParameter2 + 24),
      (struct _FAST_MUTEX *)(BugCheckParameter2 + 80 * v8 + 104),
      (KIRQL *)&a5);
    if ( sub_2618C((_BYTE *)BugCheckParameter2, &v20)
      || (v14 = sub_258D4(BugCheckParameter2, v8, a2, &v20), (v15 = v14) == 0i64) )
    {
      v16 = (ULONG_PTR *)sub_249A0(BugCheckParameter2, a3, &v20);
      v15 = v16;
      if ( !v16 )
      {
        v13 = 2;
        if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 2u )
          sub_11008(*((_QWORD *)off_2B148 + 19), 0xBCu, (__int64)&unk_29B00);
        goto LABEL_53;
      }
      v16[2] = a2;
      if ( !sub_262D8((_BYTE *)BugCheckParameter2, &v20) )
        sub_25EF4(BugCheckParameter2, (__int64)v15);
      v17 = BugCheckParameter2 + 80 * v8 + 80;
      v18 = *(ULONG_PTR ***)(BugCheckParameter2 + 80 * v8 + 88);
      *v15 = v17;
      v15[1] = (ULONG_PTR)v18;
      *v18 = v15;
      *(_QWORD *)(v17 + 8) = v15;
      ++*(_DWORD *)(BugCheckParameter2 + 80 * v8 + 96);
      _InterlockedIncrement((volatile signed __int32 *)(BugCheckParameter2 + 8));
      if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
      {
        v19 = v15[2];
        sub_23A28(*((_QWORD *)off_2B148 + 19), 189i64, (__int64)&unk_29B00, v8);
      }
      v13 = v20;
    }
    else
    {
      sub_26A8C(BugCheckParameter2, (ULONG_PTR)v14);
      v13 = v20;
      if ( v20 == 8 )
      {
        if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 3u )
          sub_1A79C(*((_QWORD *)off_2B148 + 19), 0xBAu, (__int64)&unk_29B00, a2);
        goto LABEL_53;
      }
      if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
      {
        v19 = v15[2];
        sub_1A558(*((_QWORD *)off_2B148 + 19), 0xBBu, (__int64)&unk_29B00, v8);
      }
    }
    v5 = v15[4];
  }
  else
  {
    if ( v10 != &off_2B148 && *((char *)v10 + 172) < 0 && *((_BYTE *)v10 + 169) >= 2u )
      sub_11008((__int64)v10[19], 0xB8u, (__int64)&unk_29B00);
    v13 = 3;
  }
LABEL_53:
  sub_23EA0(
    *(_DWORD *)(BugCheckParameter2 + 24),
    (struct _FAST_MUTEX *)(BugCheckParameter2 + 80i64 * (unsigned int)v8 + 104),
    a5);
  *v11 = v13;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    LODWORD(v19) = v13;
    sub_1A88C(*((_QWORD *)off_2B148 + 19), 0xBEu, (__int64)&unk_29B00, v5, v19);
  }
  return v5;
}
// 25EC7: variable 'v19' is possibly undefined
// 2B148: using guessed type void *off_2B148;

//----- (0000000000025EF4) ----------------------------------------------------
__int64 __fastcall sub_25EF4(__int64 a1, __int64 a2)
{
  void **v4; // rcx
  unsigned __int16 v5; // dx

  v4 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xD6u, (__int64)&unk_29B00);
    v4 = (void **)off_2B148;
  }
  if ( !a1 )
  {
    if ( v4 == &off_2B148 || *((char *)v4 + 172) >= 0 || *((_BYTE *)v4 + 169) < 2u )
      return 3i64;
    v5 = 215;
LABEL_10:
    sub_11008((__int64)v4[19], v5, (__int64)&unk_29B00);
    return 3i64;
  }
  if ( !a2 )
  {
    if ( v4 == &off_2B148 || *((char *)v4 + 172) >= 0 || *((_BYTE *)v4 + 169) < 2u )
      return 3i64;
    v5 = 216;
    goto LABEL_10;
  }
  if ( !*(_BYTE *)(a2 + 45) )
  {
    ++*(_DWORD *)(a2 + 40);
    v4 = (void **)off_2B148;
  }
  if ( v4 != &off_2B148 && *((char *)v4 + 172) < 0 && *((_BYTE *)v4 + 169) >= 5u )
    sub_1A558((__int64)v4[19], 0xD9u, (__int64)&unk_29B00, *(_DWORD *)(a2 + 40));
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000026010) ----------------------------------------------------
__int64 __fastcall sub_26010(ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter1, char a3)
{
  void **v6; // rcx
  unsigned __int16 v7; // dx
  int v9; // eax
  __int64 v10; // rax
  int v11; // [rsp+40h] [rbp+8h] BYREF

  v6 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_1A79C(*((_QWORD *)off_2B148 + 19), 0xDAu, (__int64)&unk_29B00, *(_QWORD *)(BugCheckParameter1 + 16));
    v6 = (void **)off_2B148;
  }
  if ( !BugCheckParameter2 )
  {
    if ( v6 == &off_2B148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 219;
LABEL_10:
    sub_11008((__int64)v6[19], v7, (__int64)&unk_29B00);
    return 3i64;
  }
  if ( !BugCheckParameter1 )
  {
    if ( v6 == &off_2B148 || *((char *)v6 + 172) >= 0 || *((_BYTE *)v6 + 169) < 2u )
      return 3i64;
    v7 = 220;
    goto LABEL_10;
  }
  if ( !a3 )
    sub_26A8C(BugCheckParameter2, BugCheckParameter1);
  v9 = *(_DWORD *)(BugCheckParameter1 + 40);
  if ( v9 )
    *(_DWORD *)(BugCheckParameter1 + 40) = v9 - 1;
  v11 = 0;
  if ( sub_26424((_BYTE *)BugCheckParameter2, &v11)
    && !*(_DWORD *)(BugCheckParameter1 + 40)
    && !*(_BYTE *)(BugCheckParameter1 + 45) )
  {
    v10 = MEMORY[0xFFFFF78000000014];
    *(_BYTE *)(BugCheckParameter1 + 45) = 1;
    *(_QWORD *)(BugCheckParameter1 + 48) = v10;
    ++*(_QWORD *)(BugCheckParameter2 + 32);
  }
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_1A558(*((_QWORD *)off_2B148 + 19), 0xDDu, (__int64)&unk_29B00, *(_DWORD *)(BugCheckParameter1 + 40));
  return 0i64;
}
// 2B148: using guessed type void *off_2B148;

//----- (000000000002618C) ----------------------------------------------------
char __fastcall sub_2618C(_BYTE *a1, _DWORD *a2)
{
  char v4; // bl
  void **v5; // rcx
  unsigned __int16 v7; // dx

  v4 = 0;
  v5 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xDEu, (__int64)&unk_29B00);
    v5 = (void **)off_2B148;
  }
  *a2 = 0;
  if ( a1 )
  {
    if ( (*a1 & 1) != 0 )
    {
      v4 = 1;
      if ( v5 != &off_2B148 )
      {
        if ( *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 4u )
        {
          v7 = 224;
LABEL_20:
          sub_11008((__int64)v5[19], v7, (__int64)&unk_29B00);
          v5 = (void **)off_2B148;
          goto LABEL_21;
        }
        goto LABEL_21;
      }
    }
    else if ( v5 != &off_2B148 )
    {
      if ( *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 4u )
      {
        v7 = 225;
        goto LABEL_20;
      }
LABEL_21:
      if ( v5 != &off_2B148 && *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 5u )
        sub_11008((__int64)v5[19], 0xE2u, (__int64)&unk_29B00);
      return v4;
    }
    return v4;
  }
  if ( v5 != &off_2B148 && *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 2u )
    sub_11008((__int64)v5[19], 0xDFu, (__int64)&unk_29B00);
  *a2 = 3;
  return 0;
}
// 2B148: using guessed type void *off_2B148;

//----- (00000000000262D8) ----------------------------------------------------
char __fastcall sub_262D8(_BYTE *a1, _DWORD *a2)
{
  char v4; // bl
  void **v5; // rcx
  unsigned __int16 v7; // dx

  v4 = 0;
  v5 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xE3u, (__int64)&unk_29B00);
    v5 = (void **)off_2B148;
  }
  *a2 = 0;
  if ( a1 )
  {
    if ( (*a1 & 2) != 0 )
    {
      v4 = 1;
      if ( v5 != &off_2B148 )
      {
        if ( *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 4u )
        {
          v7 = 229;
LABEL_20:
          sub_11008((__int64)v5[19], v7, (__int64)&unk_29B00);
          v5 = (void **)off_2B148;
          goto LABEL_21;
        }
        goto LABEL_21;
      }
    }
    else if ( v5 != &off_2B148 )
    {
      if ( *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 4u )
      {
        v7 = 230;
        goto LABEL_20;
      }
LABEL_21:
      if ( v5 != &off_2B148 && *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 5u )
        sub_11008((__int64)v5[19], 0xE7u, (__int64)&unk_29B00);
      return v4;
    }
    return v4;
  }
  if ( v5 != &off_2B148 && *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 2u )
    sub_11008((__int64)v5[19], 0xE4u, (__int64)&unk_29B00);
  *a2 = 3;
  return 0;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000026424) ----------------------------------------------------
char __fastcall sub_26424(_BYTE *a1, _DWORD *a2)
{
  char v4; // bl
  void **v5; // rcx
  unsigned __int16 v7; // dx

  v4 = 0;
  v5 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xE8u, (__int64)&unk_29B00);
    v5 = (void **)off_2B148;
  }
  *a2 = 0;
  if ( a1 )
  {
    if ( (*a1 & 4) != 0 )
    {
      v4 = 1;
      if ( v5 != &off_2B148 )
      {
        if ( *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 4u )
        {
          v7 = 234;
LABEL_20:
          sub_11008((__int64)v5[19], v7, (__int64)&unk_29B00);
          v5 = (void **)off_2B148;
          goto LABEL_21;
        }
        goto LABEL_21;
      }
    }
    else if ( v5 != &off_2B148 )
    {
      if ( *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 4u )
      {
        v7 = 235;
        goto LABEL_20;
      }
LABEL_21:
      if ( v5 != &off_2B148 && *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 5u )
        sub_11008((__int64)v5[19], 0xECu, (__int64)&unk_29B00);
      return v4;
    }
    return v4;
  }
  if ( v5 != &off_2B148 && *((char *)v5 + 172) < 0 && *((_BYTE *)v5 + 169) >= 2u )
    sub_11008((__int64)v5[19], 0xE9u, (__int64)&unk_29B00);
  *a2 = 3;
  return 0;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000026570) ----------------------------------------------------
__int64 __fastcall sub_26570(__int64 a1)
{
  char *v1; // rdi
  unsigned int v2; // ebp
  void **v3; // rcx
  __int64 v5; // r12
  _QWORD **v6; // r14
  int v7; // ecx
  _QWORD *v8; // r13
  __int64 v9; // r15
  void **v10; // rcx
  ULONG_PTR v11; // rbx
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rsi
  __int64 v15; // [rsp+20h] [rbp-98h]
  __int64 v16; // [rsp+30h] [rbp-88h] BYREF
  _BYTE v17[72]; // [rsp+38h] [rbp-80h] BYREF
  __int64 v18; // [rsp+C0h] [rbp+8h] BYREF
  unsigned int v19; // [rsp+D0h] [rbp+18h] BYREF
  struct _FAST_MUTEX *v20; // [rsp+D8h] [rbp+20h]

  v18 = a1;
  v1 = (char *)qword_31D70;
  v2 = 0;
  v16 = 0i64;
  v19 = 0;
  memset(v17, 0, sizeof(v17));
  v3 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xEDu, (__int64)&unk_29B00);
    v3 = (void **)off_2B148;
  }
  if ( !v1 )
  {
    if ( v3 != &off_2B148 && *((char *)v3 + 172) < 0 && *((_BYTE *)v3 + 169) >= 2u )
      sub_11008((__int64)v3[19], 0xEEu, (__int64)&unk_29B00);
    return 3i64;
  }
  v5 = 0i64;
  if ( *((_DWORD *)v1 + 1) )
  {
    v6 = (_QWORD **)(v1 + 80);
    while ( 1 )
    {
      v7 = *((_DWORD *)v1 + 6);
      v20 = (struct _FAST_MUTEX *)&v1[80 * v5 + 104];
      sub_23DDC(v7, v20, (KIRQL *)&v18);
      v8 = *v6;
      v9 = (__int64)&v1[80 * v5 + 80];
      if ( *v6 != (_QWORD *)v9 )
        break;
LABEL_40:
      sub_23EA0(*((_DWORD *)v1 + 6), v20, v18);
      v5 = (unsigned int)(v5 + 1);
      v6 += 10;
      if ( (unsigned int)v5 >= *((_DWORD *)v1 + 1) )
        goto LABEL_41;
    }
    v10 = (void **)off_2B148;
    while ( 1 )
    {
      v11 = (ULONG_PTR)v8;
      v8 = (_QWORD *)*v8;
      if ( *(_BYTE *)(v11 + 44) )
      {
        if ( v10 == &off_2B148 || *((char *)v10 + 172) >= 0 || *((_BYTE *)v10 + 169) < 4u )
          goto LABEL_39;
        LODWORD(v15) = *(_DWORD *)(v11 + 40);
        sub_20364((__int64)v10[19], 0xF0u, (__int64)&unk_29B00, *(_QWORD *)(v11 + 16), v15);
      }
      else
      {
        v12 = *(_QWORD *)(v11 + 24);
        if ( v12 )
        {
          v13 = v12 - 1;
          *(_QWORD *)(v11 + 24) = v13;
          if ( v13 )
          {
            v10 = (void **)off_2B148;
            if ( off_2B148 == &off_2B148 || *((char *)off_2B148 + 172) >= 0 || *((_BYTE *)off_2B148 + 169) < 4u )
              goto LABEL_39;
            sub_23918(*((_QWORD *)off_2B148 + 19), 0xF4u, (__int64)&unk_29B00, *(_QWORD *)(v11 + 16), v13);
          }
          else
          {
            *(_BYTE *)(v11 + 44) = 1;
            if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
            {
              LODWORD(v15) = *(_DWORD *)(v11 + 40);
              sub_20364(*((_QWORD *)off_2B148 + 19), 0xF1u, (__int64)&unk_29B00, *(_QWORD *)(v11 + 16), v15);
            }
            if ( !sub_262D8(v1, &v19) )
              sub_26010((ULONG_PTR)v1, v11, 1);
            if ( !*(_DWORD *)(v11 + 40) )
            {
              v14 = *(_QWORD *)(v11 + 16);
              if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
                sub_1A79C(*((_QWORD *)off_2B148 + 19), 0xF2u, (__int64)&unk_29B00, *(_QWORD *)(v11 + 16));
              v2 = sub_24B28((__int64)v1, v5, (__int64 *)v11);
              v19 = v2;
              if ( !v2 )
                sub_24D24((__int64)v1, (__int64)&v16, v11);
              v10 = (void **)off_2B148;
              if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 4u )
              {
                LODWORD(v15) = v2;
                sub_20364(*((_QWORD *)off_2B148 + 19), 0xF3u, (__int64)&unk_29B00, v14, v15);
                v10 = (void **)off_2B148;
              }
              goto LABEL_39;
            }
            v2 = v19;
          }
        }
        else
        {
          if ( v10 == &off_2B148 || *((char *)v10 + 172) >= 0 || *((_BYTE *)v10 + 169) < 4u )
            goto LABEL_39;
          sub_1A79C((__int64)v10[19], 0xF5u, (__int64)&unk_29B00, *(_QWORD *)(v11 + 16));
        }
      }
      v10 = (void **)off_2B148;
LABEL_39:
      if ( v8 == (_QWORD *)v9 )
        goto LABEL_40;
    }
  }
LABEL_41:
  sub_24EA4((__int64)v1, (__int64)&v16, 0);
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
    sub_11008(*((_QWORD *)off_2B148 + 19), 0xF6u, (__int64)&unk_29B00);
  return v2;
}
// 266CC: variable 'v15' is possibly undefined
// 2B148: using guessed type void *off_2B148;

//----- (0000000000026964) ----------------------------------------------------
__int64 sub_26964()
{
  void **v0; // rcx
  unsigned int v1; // ebx
  _DWORD *v2; // rax
  unsigned int v3; // edx

  v0 = (void **)off_2B148;
  if ( off_2B148 != &off_2B148 && *((char *)off_2B148 + 172) < 0 && *((_BYTE *)off_2B148 + 169) >= 5u )
  {
    sub_11008(*((_QWORD *)off_2B148 + 19), 0x10Au, (__int64)&unk_29B00);
    v0 = (void **)off_2B148;
  }
  v1 = 0;
  v2 = dword_29B10;
  v3 = 0;
  while ( *v2 < 0x100u )
  {
    ++v3;
    ++v2;
    if ( v3 >= 0x1D )
    {
      if ( v0 == &off_2B148 )
        return v1;
      if ( *((char *)v0 + 172) < 0 && *((_BYTE *)v0 + 169) >= 2u )
      {
        sub_11008((__int64)v0[19], 0x10Bu, (__int64)&unk_29B00);
LABEL_16:
        v0 = (void **)off_2B148;
        goto LABEL_17;
      }
      goto LABEL_17;
    }
  }
  v1 = dword_29B10[v3];
  if ( v0 == &off_2B148 )
    return v1;
  if ( *((char *)v0 + 172) < 0 && *((_BYTE *)v0 + 169) >= 4u )
  {
    sub_11B10((__int64)v0[19], 0x10Cu, (__int64)&unk_29B00, v1);
    goto LABEL_16;
  }
LABEL_17:
  if ( v0 != &off_2B148 && *((char *)v0 + 172) < 0 && *((_BYTE *)v0 + 169) >= 5u )
    sub_11008((__int64)v0[19], 0x10Du, (__int64)&unk_29B00);
  return v1;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000026A8C) ----------------------------------------------------
char __fastcall sub_26A8C(ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter1)
{
  char result; // al
  int v5; // [rsp+50h] [rbp+18h] BYREF

  v5 = 0;
  result = sub_26424((_BYTE *)BugCheckParameter2, &v5);
  if ( result )
  {
    if ( *(_BYTE *)(BugCheckParameter1 + 45) )
      KeBugCheckEx(0xDEFECAu, BugCheckParameter1, BugCheckParameter2, 0i64, 0i64);
  }
  return result;
}

//----- (0000000000026AE4) ----------------------------------------------------
void __fastcall sub_26AE4(__int64 a1)
{
  void *v1; // rbx

  if ( a1 )
  {
    v1 = *(void **)(a1 + 56);
    *(_DWORD *)(a1 + 68) = 0;
    if ( v1 )
    {
      if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 0x20) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
        sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x1Eu);
      sub_195B0(v1);
    }
  }
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000026B5C) ----------------------------------------------------
char __fastcall sub_26B5C(PFAST_MUTEX FastMutex)
{
  void *v3; // rbx

  if ( !FastMutex )
    return 0;
  if ( LOBYTE(FastMutex[1].Contention) )
  {
    sub_188F0(FastMutex);
    LOBYTE(FastMutex[1].Contention) = 0;
    sub_189BC(FastMutex);
    v3 = *(void **)&FastMutex[1].Count;
    if ( off_2B148 != &off_2B148 && (*((_BYTE *)off_2B148 + 108) & 0x20) != 0 && *((_BYTE *)off_2B148 + 105) >= 4u )
      sub_17BA8(*((_QWORD *)off_2B148 + 11), 0x32u);
    sub_1A3A4(v3);
  }
  return 1;
}
// 2B148: using guessed type void *off_2B148;

//----- (0000000000026C04) ----------------------------------------------------
char __fastcall sub_26C04(PFAST_MUTEX FastMutex)
{
  char v1; // di
  struct _KEVENT *v4; // rcx

  v1 = 0;
  if ( !FastMutex )
    return 0;
  sub_188F0(FastMutex);
  if ( LOBYTE(FastMutex[1].Contention) )
  {
    v4 = *(struct _KEVENT **)&FastMutex[1].Count;
    ++LODWORD(FastMutex[1].Owner);
    sub_18744(v4);
    v1 = 1;
  }
  sub_189BC(FastMutex);
  return v1;
}

//----- (0000000000026C6C) ----------------------------------------------------
char __fastcall sub_26C6C(PFAST_MUTEX FastMutex)
{
  if ( !FastMutex || !*(_QWORD *)&FastMutex[1].Count || !LODWORD(FastMutex[1].Owner) )
    return 0;
  sub_188F0(FastMutex);
  if ( LODWORD(FastMutex[1].Owner)-- == 1 )
    sub_186DC(*(PRKEVENT *)&FastMutex[1].Count);
  sub_189BC(FastMutex);
  return 1;
}

//----- (0000000000026CD0) ----------------------------------------------------
__int64 __fastcall sub_26CD0(_QWORD *a1, _QWORD *a2)
{
  char *v4; // rbx
  NTSTATUS v6; // edi
  IRP *v7; // rax
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+50h] [rbp-58h] BYREF
  _UNICODE_STRING DestinationString; // [rsp+60h] [rbp-48h] BYREF
  struct _KEVENT Event; // [rsp+70h] [rbp-38h] BYREF

  IoStatusBlock.Pointer = 0i64;
  Event.Header.Type = 0;
  IoStatusBlock.Information = 0i64;
  *(_OWORD *)((char *)&Event.Header.Lock + 1) = 0ui64;
  *(_DWORD *)((char *)&Event.Header.WaitListHead.Blink + 1) = 0;
  *(_WORD *)((char *)&Event.Header.WaitListHead.Blink + 5) = 0;
  HIBYTE(Event.Header.WaitListHead.Blink) = 0;
  v4 = (char *)sub_17C28(2, 0x18u, 0x41434E50u);
  if ( !v4 )
    return 1793i64;
  *(_QWORD *)v4 = 0i64;
  *((_QWORD *)v4 + 1) = 0i64;
  *((_QWORD *)v4 + 2) = 0i64;
  KeInitializeEvent(&Event, SynchronizationEvent, 0);
  RtlInitUnicodeString(&DestinationString, L"\\Device\\NANO\\KNC");
  v6 = IoGetDeviceObjectPointer(&DestinationString, 0x10000000u, (PFILE_OBJECT *)v4, (PDEVICE_OBJECT *)v4 + 1);
  if ( v6
    || (v7 = IoBuildDeviceIoControlRequest(
               0x8BC82004,
               *((PDEVICE_OBJECT *)v4 + 1),
               0i64,
               0,
               v4 + 16,
               8u,
               0,
               &Event,
               &IoStatusBlock),
        (v6 = IofCallDriver(*((PDEVICE_OBJECT *)v4 + 1), v7)) != 0) )
  {
    if ( *(_QWORD *)v4 )
      ObfDereferenceObject(*(PVOID *)v4);
    sub_17CAC(v4, 0x41434E50u);
    v4 = 0i64;
  }
  else
  {
    *a2 = *((_QWORD *)v4 + 2);
  }
  KeClearEvent(&Event);
  *a1 = v4;
  return v6 != 0 ? 0xE8700002 : 0;
}

//----- (0000000000026E54) ----------------------------------------------------
void __fastcall sub_26E54(PVOID P)
{
  PVOID *v1; // rdi

  if ( P )
  {
    v1 = (PVOID *)*((_QWORD *)P + 6);
    *(_BYTE *)P = 0;
    if ( v1 )
    {
      if ( *v1 )
        ObfDereferenceObject(*v1);
      sub_17CAC(v1, 0x41434E50u);
    }
    sub_17CAC(P, 0x41434E50u);
  }
}

//----- (0000000000026EC4) ----------------------------------------------------
__int64 __fastcall sub_26EC4(__int64 a1, __int64 a2)
{
  if ( !a1 )
    return 1799i64;
  if ( a2 )
    return (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD, char, _QWORD))(*(_QWORD *)(a1 + 24) + 16i64))(
             **(_QWORD **)(a1 + 24),
             a2,
             0i64,
             0i64,
             1,
             0i64);
  return 1796i64;
}

//----- (0000000000026F08) ----------------------------------------------------
__int64 __fastcall sub_26F08(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, void *Src)
{
  size_t v5; // rbx
  unsigned int v6; // er12
  PVOID v10; // rax
  void *v11; // r13
  unsigned int v12; // ebx

  v5 = a4;
  v6 = a3;
  if ( !a1 )
    return 1799i64;
  if ( !a2 )
    return 1796i64;
  if ( !a4 || !Src )
    return (unsigned int)(*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD, _QWORD))(*(_QWORD *)(a1 + 24)
                                                                                             + 24i64))(
                           **(_QWORD **)(a1 + 24),
                           a2,
                           a3,
                           0i64,
                           0i64);
  v10 = sub_17C28(2, a4, 0x41434E50u);
  v11 = v10;
  if ( !v10 )
    return 1793;
  memmove(v10, Src, v5);
  v12 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD, void *, _DWORD))(*(_QWORD *)(a1 + 24) + 24i64))(
          **(_QWORD **)(a1 + 24),
          a2,
          v6,
          (unsigned int)v5,
          v11,
          0);
  sub_17CAC(v11, 0x41434E50u);
  return v12;
}

//----- (0000000000027004) ----------------------------------------------------
__int64 __fastcall sub_27004(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 v5; // rax

  if ( !a2 )
    return 1796i64;
  v5 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64))(*(_QWORD *)(a1 + 40) + 16i64))(
         **(_QWORD **)(a1 + 40),
         a2,
         92i64);
  *a3 = v5;
  return v5 == 0 ? 0x706 : 0;
}

//----- (00000000000270A8) ----------------------------------------------------
__int64 __fastcall sub_270A8(char *a1, unsigned __int64 a2, CHAR *a3, __int64 a4)
{
  __int64 result; // rax

  if ( !a1 || !a2 || !a3 )
    goto LABEL_6;
  result = sub_27B04(a1, a2, a3, a4);
  if ( (int)result >= 0 )
    return result;
  *a1 = 0;
  if ( (_DWORD)result == -2 )
LABEL_6:
    nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
  return 0xFFFFFFFFi64;
}
// 27BE4: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000270F8) ----------------------------------------------------
__int64 sub_270F8(char *a1, unsigned __int64 a2, CHAR *a3, ...)
{
  va_list va; // [rsp+48h] [rbp+20h] BYREF

  va_start(va, a3);
  return sub_270A8(a1, a2, a3, (__int64)va);
}

//----- (00000000000271C4) ----------------------------------------------------
__int64 __fastcall sub_271C4(_BYTE *a1, int a2, __int64 a3, _DWORD *a4)
{
  int v6; // ebx
  _BYTE *v7; // rbp
  __int64 result; // rax

  v6 = a2;
  v7 = a1;
  if ( (*(_BYTE *)(a3 + 24) & 0x40) == 0 || *(_QWORD *)(a3 + 16) )
  {
    if ( a2 > 0 )
    {
      do
      {
        LOBYTE(a1) = *v7;
        --v6;
        result = write_char(a1, a3, a4);
        ++v7;
      }
      while ( *a4 != -1 && v6 > 0 );
    }
  }
  else
  {
    *a4 += a2;
  }
  return result;
}
// 27205: variable 'a1' is possibly undefined
// 2711C: using guessed type __int64 __fastcall write_char(_QWORD, _QWORD, _QWORD);

//----- (0000000000027234) ----------------------------------------------------
__int64 __fastcall sub_27234(__int64 a1, CHAR *a2, __int64 a3)
{
  int *v3; // r9
  __int64 v5; // r13
  int v6; // esi
  int v7; // er11
  int v8; // edx
  int v9; // er10
  int v10; // er8
  CHAR v12; // di
  int v13; // er14
  int v14; // er12
  CHAR *v15; // rbx
  int v16; // ecx
  __int64 v17; // rcx
  int v18; // eax
  char *i; // rcx
  __int64 v20; // r9
  int v21; // er8
  int v22; // eax
  _BYTE *j; // rcx
  __int64 v24; // rdi
  __int64 v25; // r9
  unsigned int v26; // er15
  char v27; // r13
  CHAR *v28; // rbx
  unsigned __int64 v29; // rdx
  CHAR v30; // al
  int v31; // esp
  int v32; // eax
  __int64 v33; // rdi
  unsigned int v34; // er13
  __int64 v35; // rcx
  WCHAR *v36; // rbp
  int v37; // er12
  int v38; // edi
  __int64 v39; // rcx
  int v40; // eax
  CHAR v41; // al
  __int64 v42; // rcx
  int v43; // [rsp+30h] [rbp-298h]
  unsigned int v44; // [rsp+34h] [rbp-294h] BYREF
  char v45[4]; // [rsp+38h] [rbp-290h] BYREF
  int v46; // [rsp+3Ch] [rbp-28Ch]
  int v47; // [rsp+40h] [rbp-288h]
  int v48; // [rsp+44h] [rbp-284h]
  WCHAR UnicodeString; // [rsp+48h] [rbp-280h] BYREF
  int v50; // [rsp+50h] [rbp-278h]
  int *v51; // [rsp+58h] [rbp-270h]
  __int64 v52; // [rsp+60h] [rbp-268h]
  int v53; // [rsp+68h] [rbp-260h]
  int v54; // [rsp+6Ch] [rbp-25Ch]
  ULONG BytesInMultiByteString; // [rsp+70h] [rbp-258h] BYREF
  ULONG v56; // [rsp+74h] [rbp-254h] BYREF
  CHAR *v57; // [rsp+78h] [rbp-250h]
  CHAR MultiByteString[512]; // [rsp+80h] [rbp-248h] BYREF
  CHAR v59[4]; // [rsp+280h] [rbp-48h] BYREF
  __int16 v60; // [rsp+284h] [rbp-44h]

  v3 = (int *)a3;
  v51 = (int *)a3;
  v5 = a1;
  v52 = a1;
  v53 = 0;
  v6 = 0;
  v7 = 0;
  v47 = 0;
  v8 = 0;
  v43 = 0;
  v9 = 0;
  v46 = 0;
  v10 = 0;
  v48 = 0;
  v50 = 0;
  if ( !a1 || !a2 )
  {
    nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
    return 0xFFFFFFFFi64;
  }
  v12 = *a2;
  v44 = 0;
  v13 = 0;
  v14 = 0;
  if ( !v12 )
    return v44;
  v15 = v57;
  while ( 1 )
  {
    v57 = ++a2;
    if ( (v44 & 0x80000000) != 0 )
      break;
    if ( (unsigned __int8)(v12 - 32) > 0x58u )
      v16 = 0;
    else
      v16 = byte_291F0[v12 - 32] & 0xF;
    v14 = byte_291F0[9 * v16 + v14] >> 4;
    v54 = v14;
    switch ( v14 )
    {
      case 8:
        goto LABEL_192;
      case 0:
        v42 = 0i64;
        goto LABEL_187;
      case 1:
        v8 = -1;
        v10 = 0;
        v48 = 0;
        v7 = 0;
        v47 = 0;
        v9 = 0;
        v46 = 0;
        v6 = 0;
        v43 = -1;
        v50 = 0;
        break;
      case 2:
        switch ( v12 )
        {
          case ' ':
            v6 |= 2u;
            break;
          case '#':
            v6 |= 0x80u;
            break;
          case '+':
            v6 |= 1u;
            break;
          case '-':
            v6 |= 4u;
            break;
          case '0':
            v6 |= 8u;
            break;
        }
        break;
      case 3:
        if ( v12 == 42 )
        {
          v7 = *v3;
          v51 = v3 + 2;
          v47 = v7;
          if ( v7 >= 0 )
            break;
          v6 |= 4u;
          v7 = -v7;
        }
        else
        {
          v7 = v12 + 10 * v7 - 48;
        }
        v47 = v7;
        break;
      case 4:
        v8 = 0;
LABEL_169:
        v43 = v8;
        break;
      case 5:
        if ( v12 == 42 )
        {
          v8 = *v3;
          v51 = v3 + 2;
          v43 = v8;
          if ( v8 >= 0 )
            break;
          v8 = -1;
        }
        else
        {
          v8 = v12 + 10 * v8 - 48;
        }
        goto LABEL_169;
      case 6:
        switch ( v12 )
        {
          case 'I':
            v41 = *a2;
            v6 |= 0x8000u;
            if ( *a2 == 54 && a2[1] == 52 )
            {
              a2 += 2;
              v6 |= 0x8000u;
              goto LABEL_190;
            }
            if ( v41 == 51 && a2[1] == 50 )
            {
              a2 += 2;
              v6 &= 0xFFFF7FFF;
              goto LABEL_190;
            }
            if ( v41 != 100 && v41 != 105 && v41 != 111 && v41 != 117 && v41 != 120 && v41 != 88 )
            {
              v42 = 0i64;
              v14 = 0;
LABEL_187:
              v50 = 0;
              LOBYTE(v42) = v12;
              write_char(v42, v5, &v44);
              goto LABEL_188;
            }
            break;
          case 'h':
            v6 |= 0x20u;
            break;
          case 'l':
            if ( *a2 == 108 )
            {
              ++a2;
              v6 |= 0x1000u;
            }
            else
            {
              v6 |= 0x10u;
            }
            break;
          case 'w':
            v6 |= 0x800u;
            break;
        }
        break;
      case 7:
        if ( v12 > 105 )
        {
          switch ( v12 )
          {
            case 'n':
              goto LABEL_192;
            case 'o':
              v21 = 8;
              if ( (v6 & 0x80u) != 0 )
                v6 |= 0x200u;
              goto LABEL_83;
            case 'p':
              v43 = 16;
              v6 |= 0x8000u;
              goto LABEL_78;
          }
          if ( v12 != 115 )
          {
            v17 = (unsigned int)(v12 - 117);
            if ( v12 == 117 )
              goto LABEL_57;
            if ( v12 != 120 )
              goto LABEL_27;
            v22 = 39;
            goto LABEL_79;
          }
        }
        else
        {
          if ( v12 == 105 )
            goto LABEL_56;
          v17 = (unsigned int)(v12 - 67);
          if ( v12 == 67 )
          {
            if ( (v6 & 0x830) == 0 )
              v6 |= 0x800u;
            goto LABEL_50;
          }
          if ( v12 != 83 )
          {
            if ( v12 != 88 )
            {
              if ( v12 == 90 )
              {
                v17 = *(_QWORD *)v3;
                v51 = v3 + 2;
                if ( v17 && (v15 = *(CHAR **)(v17 + 8)) != 0i64 )
                {
                  if ( *(_WORD *)(v17 + 2) < *(_WORD *)v17 )
                    goto LABEL_192;
                  v13 = *(unsigned __int16 *)v17;
                  if ( _bittest(&v6, 0xBu) )
                  {
                    if ( (v13 & 1) != 0 || ((unsigned __int8)v15 & 1) != 0 )
                      goto LABEL_192;
                    v13 = *(unsigned __int16 *)v17 >> 1;
                    v50 = 1;
                  }
                  else
                  {
                    v50 = 0;
                  }
                }
                else
                {
                  v15 = off_2B110;
                  v17 = strlen(off_2B110) + 1;
                  v13 = v17 - 1;
                }
                goto LABEL_27;
              }
              v17 = (unsigned int)(v12 - 99);
              if ( v12 != 99 )
              {
                if ( v12 != 100 )
                  goto LABEL_27;
LABEL_56:
                v6 |= 0x40u;
LABEL_57:
                v21 = 10;
LABEL_83:
                if ( _bittest(&v6, 0xFu) || _bittest(&v6, 0xCu) )
                {
                  v24 = *(_QWORD *)v3;
                  v25 = (__int64)(v3 + 2);
                }
                else
                {
                  v25 = (__int64)(v3 + 2);
                  if ( (v6 & 0x20) != 0 )
                  {
                    v51 = (int *)v25;
                    if ( (v6 & 0x40) != 0 )
                      v24 = *(__int16 *)(v25 - 8);
                    else
                      v24 = *(unsigned __int16 *)(v25 - 8);
LABEL_94:
                    if ( (v6 & 0x40) != 0 && v24 < 0 )
                    {
                      v24 = -v24;
                      v6 |= 0x100u;
                    }
                    if ( !_bittest(&v6, 0xFu) && !_bittest(&v6, 0xCu) )
                      v24 = (unsigned int)v24;
                    v26 = v43;
                    if ( v43 >= 0 )
                    {
                      v6 &= 0xFFFFFFF7;
                      if ( v43 > 512 )
                        v26 = 512;
                    }
                    else
                    {
                      v26 = 1;
                    }
                    v27 = v53;
                    v28 = &MultiByteString[511];
                    v9 &= -(v24 != 0);
                    v46 = v9;
                    while ( 1 )
                    {
                      v17 = v26--;
                      if ( (int)v17 <= 0 && !v24 )
                        break;
                      v29 = v24 % (unsigned __int64)v21;
                      v24 /= (unsigned __int64)v21;
                      v30 = v29 + 48;
                      if ( (int)v29 + 48 > 57 )
                        v30 += v27;
                      *v28-- = v30;
                    }
                    v5 = v52;
                    v43 = v26;
                    v32 = v31 + 639 - (_DWORD)v28;
                    v15 = v28 + 1;
                    v13 = v32;
                    if ( _bittest(&v6, 9u) && (!v32 || *v15 != 48) )
                    {
                      --v15;
                      v13 = v32 + 1;
                      *v15 = 48;
                    }
                    v10 = v48;
LABEL_27:
                    if ( !v10 )
                    {
                      if ( (v6 & 0x40) != 0 )
                      {
                        if ( _bittest(&v6, 8u) )
                        {
                          v45[0] = 45;
                          goto LABEL_119;
                        }
                        if ( (v6 & 1) != 0 )
                        {
                          v45[0] = 43;
                          goto LABEL_119;
                        }
                        if ( (v6 & 2) != 0 )
                        {
                          v45[0] = 32;
LABEL_119:
                          v9 = 1;
                          v46 = 1;
                        }
                      }
                      v33 = v52;
                      v34 = v7 - v13 - v9;
                      if ( (v6 & 0xC) == 0 )
                      {
                        LOBYTE(v17) = 32;
                        write_multi_char(v17, v34, v52, &v44);
                        v9 = v46;
                      }
                      sub_271C4(v45, v9, v33, &v44);
                      if ( (v6 & 8) != 0 && (v6 & 4) == 0 )
                      {
                        LOBYTE(v35) = 48;
                        write_multi_char(v35, v34, v33, &v44);
                      }
                      if ( v50 && v13 > 0 )
                      {
                        v36 = (WCHAR *)v15;
                        v37 = v13;
                        while ( 1 )
                        {
                          --v37;
                          UnicodeString = *v36;
                          v38 = -1;
                          if ( RtlUnicodeToMultiByteN(v59, 6u, &v56, &UnicodeString, 2u) >= 0 )
                          {
                            v38 = v56;
                            v40 = 0;
                          }
                          else
                          {
                            *(_DWORD *)v59 = 0;
                            v60 = 0;
                            v40 = 42;
                          }
                          ++v36;
                          if ( v40 || !v38 )
                            break;
                          sub_271C4(v59, v38, v52, &v44);
                          if ( !v37 )
                            goto LABEL_136;
                        }
                        v44 = -1;
LABEL_136:
                        a2 = v57;
                        v14 = v54;
                        v33 = v52;
                      }
                      else
                      {
                        sub_271C4(v15, v13, v33, &v44);
                      }
                      if ( (v44 & 0x80000000) == 0 && (v6 & 4) != 0 )
                      {
                        LOBYTE(v39) = 32;
                        write_multi_char(v39, v34, v33, &v44);
                      }
                      v5 = v52;
LABEL_188:
                      v10 = v48;
                      v7 = v47;
                      v9 = v46;
                    }
                    v8 = v43;
                    break;
                  }
                  if ( (v6 & 0x40) != 0 )
                    v24 = *(int *)(v25 - 8);
                  else
                    v24 = *(unsigned int *)(v25 - 8);
                }
                v51 = (int *)v25;
                goto LABEL_94;
              }
LABEL_50:
              v20 = (__int64)(v3 + 2);
              v51 = (int *)v20;
              if ( (v6 & 0x810) != 0 )
              {
                UnicodeString = *(_WORD *)(v20 - 8);
                v13 = -1;
                if ( RtlUnicodeToMultiByteN(MultiByteString, 0x200u, &BytesInMultiByteString, &UnicodeString, 2u) >= 0 )
                {
                  v13 = BytesInMultiByteString;
                  v9 = v46;
                  v7 = v47;
                  v10 = v48;
                }
                else
                {
                  memset(MultiByteString, 0, sizeof(MultiByteString));
                  v9 = v46;
                  v7 = v47;
                  v10 = 1;
                  v48 = 1;
                }
              }
              else
              {
                v13 = 1;
                MultiByteString[0] = *(_BYTE *)(v20 - 8);
              }
              v15 = MultiByteString;
              goto LABEL_27;
            }
LABEL_78:
            v22 = 7;
LABEL_79:
            v53 = v22;
            v21 = 16;
            if ( (v6 & 0x80u) != 0 )
            {
              v45[0] = 48;
              v9 = 2;
              v45[1] = v22 + 81;
            }
            goto LABEL_83;
          }
          if ( (v6 & 0x830) == 0 )
            v6 |= 0x800u;
        }
        v15 = *(CHAR **)v3;
        v18 = v8;
        if ( v8 == -1 )
          v18 = 0x7FFFFFFF;
        v51 = v3 + 2;
        if ( (v6 & 0x810) != 0 )
        {
          v50 = 1;
          if ( !v15 )
            v15 = (CHAR *)off_2B118;
          for ( i = v15; v18; i += 2 )
          {
            --v18;
            if ( !*(_WORD *)i )
              break;
          }
          v17 = (i - v15) >> 1;
        }
        else
        {
          if ( !v15 )
            v15 = off_2B110;
          for ( j = v15; v18; ++j )
          {
            --v18;
            if ( !*j )
              break;
          }
          v17 = (unsigned int)((_DWORD)j - (_DWORD)v15);
        }
        v13 = v17;
        goto LABEL_27;
      default:
        break;
    }
LABEL_190:
    v12 = *a2;
    if ( !*a2 )
      break;
    v3 = v51;
  }
  if ( v14 && v14 != 7 )
  {
LABEL_192:
    nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
    return 0xFFFFFFFFi64;
  }
  return v44;
}
// 27715: variable 'v31' is possibly undefined
// 27797: variable 'v17' is possibly undefined
// 277CF: variable 'v35' is possibly undefined
// 278BA: variable 'v39' is possibly undefined
// 2711C: using guessed type __int64 __fastcall write_char(_QWORD, _QWORD, _QWORD);
// 2716C: using guessed type __int64 __fastcall write_multi_char(_QWORD, _QWORD, _QWORD, _QWORD);
// 27BE4: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 2B110: using guessed type char *off_2B110;
// 2B118: using guessed type wchar_t *off_2B118;

//----- (0000000000027B04) ----------------------------------------------------
__int64 __fastcall sub_27B04(char *a1, unsigned __int64 a2, CHAR *a3, __int64 a4)
{
  __int64 result; // rax
  unsigned int v7; // edi
  FILE File; // [rsp+30h] [rbp-38h] BYREF

  if ( a2 == -1i64 )
  {
    File._cnt = 0x7FFFFFFF;
  }
  else
  {
    if ( a2 > 0x7FFFFFFF )
    {
      nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
      return 0xFFFFFFFFi64;
    }
    File._cnt = a2;
  }
  File._base = a1;
  File._ptr = a1;
  File._flag = 66;
  result = sub_27234((__int64)&File, a3, a4);
  v7 = result;
  a1[a2 - 1] = 0;
  if ( (int)result >= 0 )
  {
    if ( --File._cnt < 0 )
    {
      if ( flsbuf(0, &File) == -1 )
        return 4294967294i64;
    }
    else
    {
      *File._ptr = 0;
    }
    return v7;
  }
  if ( File._cnt < 0 )
    return 4294967294i64;
  if ( a1 )
  {
    if ( a2 )
      *a1 = 0;
  }
  return result;
}
// 27BE4: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000027D8C) ----------------------------------------------------
__int64 __fastcall sub_27D8C(void *a1, size_t a2, const void *a3, size_t a4)
{
  unsigned int v8; // ebx

  if ( !a4 )
    return 0i64;
  if ( !a1 )
  {
    nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
    return 22i64;
  }
  if ( a3 && a2 >= a4 )
  {
    memmove(a1, a3, a4);
    return 0i64;
  }
  memset(a1, 0, a2);
  if ( a3 )
  {
    if ( a2 >= a4 )
      return 22i64;
    v8 = 34;
  }
  else
  {
    v8 = 22;
  }
  nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
  return v8;
}
// 27BE4: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000027E30) ----------------------------------------------------
__int64 __fastcall sub_27E30(_WORD *a1, __int64 a2, __int16 *a3)
{
  _WORD *v3; // r9
  unsigned int v4; // ebx
  __int16 v5; // ax
  __int64 result; // rax

  v3 = a1;
  if ( a1 && a2 )
  {
    if ( !a3 )
    {
      v4 = 22;
LABEL_9:
      *v3 = 0;
      nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
      return v4;
    }
    do
    {
      v5 = *a3++;
      *a1++ = v5;
      if ( !v5 )
        break;
      --a2;
    }
    while ( a2 );
    if ( !a2 )
    {
      v4 = 34;
      goto LABEL_9;
    }
    result = 0i64;
  }
  else
  {
    nullsub_1(0i64, 0i64, 0i64, 0i64, 0i64);
    result = 22i64;
  }
  return result;
}
// 27BE4: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000036008) ----------------------------------------------------
__int64 __fastcall sub_36008(unsigned __int8 a1, __int64 a2, unsigned int a3, unsigned int *a4, __int64 a5, unsigned int *a6)
{
  unsigned int *v6; // r13
  unsigned int v7; // er10
  __int64 v10; // rbp
  unsigned int v11; // ebx
  __int64 v12; // rax
  unsigned int v13; // ecx
  unsigned int v14; // eax
  const void **v15; // r14
  unsigned int v16; // er12
  unsigned int v17; // esi
  _WORD *v18; // rcx
  __m128i *v19; // rdi
  __int64 v20; // rcx
  __m128i v21; // xmm0
  __int64 v22; // rbx
  bool v23; // zf
  __int64 v25; // [rsp+30h] [rbp-38h]
  char v26; // [rsp+70h] [rbp+8h] BYREF

  v6 = a6;
  v7 = 0;
  *a6 = 0;
  if ( a1 <= 3u )
    return (unsigned int)-1073741808;
  if ( a1 <= 5u )
  {
    v22 = a5;
    if ( a5 )
    {
      if ( a3 < 0x30 )
        return (unsigned int)-1073741811;
      do
      {
        if ( RtlCompareMemory(*(const void **)(v22 + 8), a4 + 6, 0x10ui64) == 16 )
          break;
        v22 = *(_QWORD *)(v22 + 16);
      }
      while ( v22 );
      if ( v22 )
      {
        v7 = 0;
        if ( a1 == 5 )
        {
          *(_DWORD *)(v22 + 44) = 0;
          *(_QWORD *)(v22 + 24) = 0i64;
          *(_BYTE *)(v22 + 41) = 0;
        }
        else
        {
          v23 = dword_2BAD8 == 2;
          v25 = *((_QWORD *)a4 + 1);
          *(_QWORD *)(v22 + 24) = v25;
          if ( v23 )
          {
            if ( !(unsigned int)qword_2BAB0(3i64, &v26, 4i64, &a6, a4) )
              *(_BYTE *)(v22 + 41) = v26;
            v7 = qword_2BAB0(2i64, v22 + 44, 4i64, &a6, a4);
          }
          else
          {
            *(_DWORD *)(v22 + 44) = HIDWORD(v25);
            *(_BYTE *)(v22 + 41) = BYTE2(v25);
          }
        }
        return v7;
      }
    }
    return (unsigned int)-1073741163;
  }
  if ( a1 <= 7u )
    return v7;
  if ( a1 != 8 )
    return (unsigned int)-1073741808;
  v10 = a5;
  v11 = 0;
  v12 = a5;
  if ( dword_2BAD8 == 1 )
  {
    v13 = a4[4];
    if ( v13 > 1 )
    {
      v14 = 32 * v13 + 24;
      if ( v14 <= a3 )
      {
        *(__m128i *)&a4[8 * v13 - 2] = _mm_loadu_si128((const __m128i *)*(_QWORD *)(a5 + 8));
        a4[8 * a4[4] + 2] = 528384;
        *(_DWORD *)(v10 + 44) = 0;
        *(_BYTE *)(v10 + 41) = 0;
        return v7;
      }
      v7 = -1073741789;
      if ( a3 >= 4 )
      {
        *a4 = v14;
LABEL_10:
        *v6 = 4;
        return v7;
      }
      return v7;
    }
  }
  v15 = *(const void ***)(a5 + 32);
  do
  {
    v12 = *(_QWORD *)(v12 + 16);
    ++v11;
  }
  while ( v12 );
  if ( v11 > 0x3F )
    return (unsigned int)-1073741811;
  if ( v15 )
  {
    v16 = 32 * v11 + 24;
    v17 = *(unsigned __int16 *)v15 + v16 + 2;
  }
  else
  {
    v16 = 0;
    v17 = 32 * v11 + 24;
  }
  if ( v17 > a3 )
  {
    v7 = -1073741789;
    if ( a3 < 4 )
      return v7;
    *a4 = v17;
    goto LABEL_10;
  }
  memset(a4, 0, a3);
  *a4 = v17;
  a4[2] = v16;
  a4[4] = v11;
  if ( v15 )
  {
    v18 = (_WORD *)((char *)a4 + v16);
    *v18 = *(_WORD *)v15;
    memmove(v18 + 1, v15[1], *(unsigned __int16 *)v15);
  }
  if ( v11 )
  {
    v19 = (__m128i *)(a4 + 10);
    v20 = v11;
    do
    {
      v21 = _mm_loadu_si128((const __m128i *)*(_QWORD *)(v10 + 8));
      v19->m128i_i32[0] = 528384;
      v19 += 2;
      v19[-3] = v21;
      *(_DWORD *)(v10 + 44) = 0;
      --v20;
      *(_BYTE *)(v10 + 41) = 0;
      v10 = *(_QWORD *)(v10 + 16);
    }
    while ( v20 );
  }
  v7 = 0;
  *v6 = v17;
  return v7;
}
// 2BAB0: using guessed type __int64 (__fastcall *qword_2BAB0)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 2BAD8: using guessed type int dword_2BAD8;

// nfuncs=273 queued=260 decompiled=260 lumina nreq=0 worse=0 better=0
// ALL OK, 260 function(s) have been successfully decompiled
