/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall sub_140001000(__int64 a1, __int64 a2);
__int64 __fastcall sub_140001248(__int64 a1, __int64 a2);
void sub_1400012D8();
__int64 sub_140001314();
__int64 sub_140001428();
__int64 __fastcall sub_1400014B4(__m128i *a1, __int64 *a2);
__int64 sub_140001648();
__int64 sub_1400018D8();
__int64 sub_1400019A8();
__int64 __fastcall sub_140001A84(__int64 a1);
void *sub_140001AF0();
__int64 __fastcall sub_140001BB8(); // weak
__int64 __fastcall sub_140001BC8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5, __int64 a6, _DWORD *a7);
__int64 __fastcall sub_140001DB8(int a1);
__int64 sub_140001DD8();
__int64 __fastcall sub_140002134(__int64 a1, __int64 a2);
__int64 sub_1400021FC();
__int64 __fastcall sub_1400023C8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5);
__int64 __fastcall sub_140002498(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5);
__int64 sub_140002524();
__int64 sub_140002694();
__int64 __fastcall sub_140002790(__int64 a1);
__int64 sub_1400028C8();
__int64 __fastcall sub_140002924(_WORD *a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4);
char *__fastcall sub_1400029A8(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_140002CF4(int a1);
void __fastcall sub_140002D04(unsigned __int16 a1);
__int64 __fastcall sub_140002D80(__int64 a1);
__int64 __fastcall sub_140002F40(__int64 a1);
__int16 __fastcall sub_1400030A4(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400030C4(__int64 a1, int a2);
__int64 __fastcall sub_140003348(__int64 a1, int a2);
int *__fastcall sub_1400036E8(__int64 a1, const wchar_t *a2, unsigned int a3);
void __fastcall sub_14000389C(void **a1, _QWORD *a2);
void __fastcall sub_1400038D8(_QWORD *a1, unsigned __int64 *a2);
char __fastcall sub_140003A24(int a1, __int16 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_140003A50(_WORD *a1, unsigned int a2, _QWORD *a3, _QWORD *a4);
char __fastcall sub_140003B14(__int64 a1, unsigned __int64 a2, __int64 a3, _WORD *a4);
__int64 __fastcall sub_140003D28(_WORD *a1, unsigned int a2, _QWORD *a3, __int64 a4);
char __fastcall sub_140003F50(_DWORD *a1, unsigned int a2, void **a3, _DWORD *a4);
char __fastcall sub_1400040A0(UNICODE_STRING *a1, UNICODE_STRING *a2, void **a3, _DWORD *a4);
// char *__cdecl strrchr(const char *Str, int Ch);
// int __cdecl wcsnicmp(const wchar_t *Str1, const wchar_t *Str2, size_t MaxCount);
// __int64 __fastcall FwpmEngineOpen0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 FwpmEngineClose0(void); weak
// __int64 __fastcall FwpmTransactionBegin0(_QWORD, _QWORD); weak
// __int64 __fastcall FwpmTransactionCommit0(_QWORD); weak
// __int64 __fastcall FwpmTransactionAbort0(_QWORD); weak
// __int64 __fastcall FwpmProviderAdd0(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpmSubLayerAdd0(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpmCalloutAdd0(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpmFilterAdd0(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpsCalloutRegister1(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpsCalloutUnregisterByKey0(_QWORD); weak
// __int64 __fastcall FwpsAcquireClassifyHandle0(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpsReleaseClassifyHandle0(_QWORD); weak
// __int64 __fastcall FwpsAcquireWritableLayerDataPointer0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpsApplyModifiedLayerData0(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall FwpsRedirectHandleCreate0(_QWORD, _QWORD, _QWORD); weak
// __int64 FwpsRedirectHandleDestroy0(void); weak
__int64 sub_1400044E8();
__int64 __fastcall DriverEntry(__int64 a1, const UNICODE_STRING *a2);
__int64 __fastcall sub_140004664(); // weak
__int64 sub_14000466C();
signed __int64 sub_140004694();
__int64 __fastcall sub_140004700(__int64 a1);
void *__fastcall sub_140004798(__int64 a1);
// __int64 __fastcall WdfVersionBind(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall WdfVersionUnbind(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall WdfVersionBindClass(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall WdfVersionUnbindClass(_QWORD, _QWORD, _QWORD); weak
// void *__cdecl memset(void *Dst, int Val, size_t Size);
// void *__cdecl memmove(void *Dst, const void *Src, size_t Size);
// __int64 __fastcall SecLookupAccountSid(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// NTSTATUS __stdcall ZwQueryValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);
// NTSTATUS __stdcall ZwOpenKey(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
// NTSTATUS __stdcall ZwClose(HANDLE Handle);
// void __stdcall ExFreePoolWithTag(PVOID P, ULONG Tag);
// PVOID __stdcall ExAllocatePoolWithTag(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag);
// __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD); weak
// __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD, _QWORD); weak
// PEPROCESS IoGetCurrentProcess(void);
// void __stdcall ExReleaseFastMutex(PFAST_MUTEX FastMutex);
// void __stdcall RtlCopyUnicodeString(PUNICODE_STRING DestinationString, PCUNICODE_STRING SourceString);
// void __stdcall ExAcquireFastMutex(PFAST_MUTEX FastMutex);
// void __stdcall KeInitializeSpinLock(PKSPIN_LOCK SpinLock);
// void __stdcall KeInitializeEvent(PRKEVENT Event, EVENT_TYPE Type, BOOLEAN State);
// __int64 __fastcall DbgPrintEx(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//-------------------------------------------------------------------------
// Data declarations

__int128 xmmword_140005260 = 0x5C006500630069007600650044005Ci64; // weak
__int128 xmmword_140005270 = 0x6C006C00610063005F006900770073i64; // weak
__int128 xmmword_140005290 = 0x690076006500440073006F0044005Ci64; // weak
__int128 xmmword_1400052A0 = 0x5F006900770073005C007300650063i64; // weak
__int128 xmmword_1400052B0 = 0x740075006F006C006C00610063i64; // weak
_UNKNOWN unk_1400061A8; // weak
_UNKNOWN unk_1400061B8; // weak
_UNKNOWN unk_1400061C8; // weak
_UNKNOWN unk_140006280; // weak
wchar_t *off_140007000[3] =
{
  L"SWI_CONNECT",
  (wchar_t *)0x4243D589943FDA86i64,
  (wchar_t *)0xF28AFBF2898DF682i64
}; // idb
wchar_t *off_140007018 = L"SWI_CLOSE"; // weak
wchar_t *off_140007030 = L"SWI_RELEASE"; // weak
__int128 xmmword_140007048 = 0x4B176E6EB4694DA140C92F713C59FC7Ci64; // weak
__int128 xmmword_140007058 = 0x2DB779224A548EAF4427BDE4175FBA13i64; // weak
_UNKNOWN unk_140007080; // weak
_UNKNOWN unk_1400070B0; // weak
_UNKNOWN unk_1400070C0; // weak
void *off_1400070C8 = &unk_1400070B0; // weak
_UNKNOWN unk_1400070D0; // weak
_UNKNOWN unk_1400070E0; // weak
__int64 qword_1400070F0[] = { 0i64 }; // weak
_QWORD qword_1400070F8 = 0i64; // idb
__int64 qword_140007100 = 0i64; // weak
__int64 qword_140007108 = 0i64; // weak
_QWORD qword_140007110 = 0i64; // idb
_QWORD qword_140007118 = 0i64; // idb
int dword_140007120 = 0; // weak
__int64 qword_140007124 = 0i64; // weak
int dword_14000712C = 0; // weak
int dword_140007228; // weak
int dword_140007230; // weak
__int16 word_140007234; // weak
__int64 qword_140007238; // weak
__int64 qword_140007240; // weak
__int64 qword_140007248; // weak
int dword_140007250; // weak
int dword_140007254; // weak
int dword_140047258; // weak
int dword_14004725C; // weak
__int64 qword_140087260; // weak
__int64 qword_140087268; // weak
int dword_140087270; // weak
int dword_140087274; // weak
int dword_14010AA78; // weak
int dword_14010AA7C; // weak
KSPIN_LOCK SpinLock; // idb
_QWORD qword_14018E288[131072]; // idb
__int64 qword_14028E288; // weak
__int64 qword_14028E290; // weak
int dword_14028E298; // weak
struct _FAST_MUTEX FastMutex; // idb
_QWORD qword_14028E2D8; // idb
__int64 qword_14028E2E0; // weak
__int64 qword_14028E2E8; // weak
__int64 qword_14028E2F0; // weak
__int64 (__fastcall *qword_14028E3C8)(_QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028E3D8)(_QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028E3F8)(_QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028E4B0)(_QWORD); // weak
__int64 (__fastcall *qword_14028E510)(_QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028E518)(_QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028E530)(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028E538)(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028E558)(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028E580)(_QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028E6A0)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028E7C0)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028E7F0)(_QWORD, _QWORD, _QWORD); // weak
__int64 qword_14028E948; // weak
__int64 (__fastcall *qword_14028EAF8)(_QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028EB38)(_QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028EB48)(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028EB70)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028EBC8)(_QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028ECC0)(_QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028ECC8)(_QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028ECD0)(_QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028EED8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_14028EEE0)(_QWORD, _QWORD); // weak
__int64 (*qword_14028F088)(void); // weak
_QWORD qword_14028F090; // idb
__int64 qword_14028F098; // weak
__int64 qword_14028F0A0; // weak
_UNKNOWN unk_14028F0B0; // weak
UNICODE_STRING DestinationString; // idb


//----- (0000000140001000) ----------------------------------------------------
__int64 __fastcall sub_140001000(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdi
  signed int v4; // ebx
  const char *v5; // rdi
  char *v6; // rax
  const char *v7; // rdi
  char *v8; // rax
  __int64 v10; // [rsp+20h] [rbp-58h]
  int Dst; // [rsp+30h] [rbp-48h]
  int v12; // [rsp+48h] [rbp-30h]
  int v13; // [rsp+4Ch] [rbp-2Ch]
  __int64 v14; // [rsp+50h] [rbp-28h]

  v2 = a1;
  v3 = a2;
  KeInitializeSpinLock(&SpinLock);
  FastMutex.Count = 1;
  FastMutex.Owner = 0i64;
  FastMutex.Contention = 0;
  KeInitializeEvent(&FastMutex.Event, SynchronizationEvent, 0);
  dword_140007250 = 0;
  qword_140007240 = (__int64)&dword_140007250;
  dword_140007254 = 0;
  qword_140007248 = (__int64)&dword_140047258;
  dword_140047258 = 0;
  dword_14004725C = 1;
  qword_140087260 = (__int64)&dword_140087270;
  dword_140087270 = 0;
  dword_140087274 = 0;
  dword_14010AA78 = 0;
  qword_140087268 = (__int64)&dword_14010AA78;
  dword_14010AA7C = 1;
  qword_14028E290 = 0i64;
  dword_14028E298 = 0;
  qword_14028E288 = 0i64;
  v4 = FwpsRedirectHandleCreate0(&xmmword_140007048, 0i64, &qword_14028E288);
  if ( v4 )
    qword_14028E288 = 0i64;
  sub_1400038D8(&qword_14028E2E8, (unsigned __int64 *)&qword_14028E2F0);
  if ( v4 >= 0 )
  {
    v4 = sub_140002134(v2, v3);
    if ( v4 < 0 )
      goto LABEL_15;
    v4 = sub_140001DD8();
    if ( v4 < 0 )
      goto LABEL_15;
    memset(&Dst, 0, 0x38ui64);
    v14 = qword_1400070F8;
    Dst = 56;
    v12 = 1;
    v13 = 1;
    v4 = qword_14028ECC0(qword_14028F090, &Dst, &qword_14028E2D8);
    if ( v4 < 0 )
      goto LABEL_15;
    qword_14028E2E0 = 0i64;
    v4 = sub_140002524();
    if ( v4 < 0 )
      goto LABEL_15;
    v7 = "..\\..\\src\\swi_callout\\callout.c";
    v8 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
    if ( v8 )
      v7 = v8 + 1;
    LODWORD(v10) = 912;
    DbgPrintEx(77i64, 2i64, "[%s:%hu] Loaded the driver <%S>", v7, v10);
  }
  else
  {
    v5 = "..\\..\\src\\swi_callout\\callout.c";
    v6 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
    if ( v6 )
      v5 = v6 + 1;
    LODWORD(v10) = 894;
    DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot create the redirect handle: 0x%08x", v5, v10);
  }
  if ( v4 < 0 )
LABEL_15:
    sub_140001AF0();
  return (unsigned int)v4;
}
// 14000449A: using guessed type __int64 __fastcall FwpsRedirectHandleCreate0(_QWORD, _QWORD, _QWORD);
// 140007048: using guessed type __int128 xmmword_140007048;
// 140007240: using guessed type __int64 qword_140007240;
// 140007248: using guessed type __int64 qword_140007248;
// 140007250: using guessed type int dword_140007250;
// 140007254: using guessed type int dword_140007254;
// 140047258: using guessed type int dword_140047258;
// 14004725C: using guessed type int dword_14004725C;
// 140087260: using guessed type __int64 qword_140087260;
// 140087268: using guessed type __int64 qword_140087268;
// 140087270: using guessed type int dword_140087270;
// 140087274: using guessed type int dword_140087274;
// 14010AA78: using guessed type int dword_14010AA78;
// 14010AA7C: using guessed type int dword_14010AA7C;
// 14028E288: using guessed type __int64 qword_14028E288;
// 14028E290: using guessed type __int64 qword_14028E290;
// 14028E298: using guessed type int dword_14028E298;
// 14028E2E0: using guessed type __int64 qword_14028E2E0;
// 14028E2E8: using guessed type __int64 qword_14028E2E8;
// 14028E2F0: using guessed type __int64 qword_14028E2F0;
// 14028ECC0: using guessed type __int64 (__fastcall *qword_14028ECC0)(_QWORD, _QWORD, _QWORD);

//----- (0000000140001248) ----------------------------------------------------
__int64 __fastcall sub_140001248(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  unsigned int v3; // ebx
  PEPROCESS v4; // rax

  v2 = a2;
  v3 = -1073741790;
  ExAcquireFastMutex(&FastMutex);
  if ( !qword_14028E290 )
  {
    v4 = IoGetCurrentProcess();
    ++dword_14028E298;
    qword_14028E290 = (__int64)v4;
LABEL_6:
    v3 = 0;
    goto LABEL_7;
  }
  if ( (PEPROCESS)qword_14028E290 == IoGetCurrentProcess() && dword_14028E298 < 3 )
  {
    ++dword_14028E298;
    goto LABEL_6;
  }
LABEL_7:
  ExReleaseFastMutex(&FastMutex);
  return qword_14028EB38(qword_14028F090, v2, v3);
}
// 14028E290: using guessed type __int64 qword_14028E290;
// 14028E298: using guessed type int dword_14028E298;
// 14028EB38: using guessed type __int64 (__fastcall *qword_14028EB38)(_QWORD, _QWORD, _QWORD);
// 14028F090: using guessed type __int64 qword_14028F090;

//----- (00000001400012D8) ----------------------------------------------------
void sub_1400012D8()
{
  ExAcquireFastMutex(&FastMutex);
  if ( !--dword_14028E298 )
  {
    qword_14028E290 = 0i64;
    qword_14028E2E0 = 0i64;
  }
  ExReleaseFastMutex(&FastMutex);
}
// 14028E290: using guessed type __int64 qword_14028E290;
// 14028E298: using guessed type int dword_14028E298;
// 14028E2E0: using guessed type __int64 qword_14028E2E0;

//----- (0000000140001314) ----------------------------------------------------
__int64 sub_140001314()
{
  unsigned int v0; // eax
  signed __int64 v1; // r8
  __int64 v3; // [rsp+48h] [rbp+10h]
  __int64 v4; // [rsp+50h] [rbp+18h]
  __int64 v5; // [rsp+58h] [rbp+20h]

  qword_14028ECC8(qword_14028F090, qword_14028E2D8, 0i64);
  sub_140002CF4(0);
  sub_140002694();
  if ( (signed int)qword_14028E2E0 >= 3 )
  {
    if ( !HIDWORD(qword_14028E2E0) && (signed int)qword_14028E7F0(qword_14028F090, qword_140007118, &v3) >= 0 )
    {
      v0 = qword_14028EB70(qword_14028F090, v3, 4i64, &v5, &v4);
      if ( (v0 & 0x80000000) != 0 )
      {
        v1 = v0;
      }
      else
      {
        if ( v4 == 4 )
        {
          *(_DWORD *)v5 = 1;
          qword_14028EB48(qword_14028F090, v3, 0i64, 4i64);
          HIDWORD(qword_14028E2E0) = 1;
          return qword_14028ECD0(qword_14028F090, qword_14028E2D8);
        }
        v1 = 3221225990i64;
      }
      qword_14028EB38(qword_14028F090, v3, v1);
      return qword_14028ECD0(qword_14028F090, qword_14028E2D8);
    }
  }
  else
  {
    sub_140001648();
    sub_140002CF4(1);
    LODWORD(qword_14028E2E0) = qword_14028E2E0 + 1;
  }
  return qword_14028ECD0(qword_14028F090, qword_14028E2D8);
}
// 14028E2D8: using guessed type __int64 qword_14028E2D8;
// 14028E2E0: using guessed type __int64 qword_14028E2E0;
// 14028E7F0: using guessed type __int64 (__fastcall *qword_14028E7F0)(_QWORD, _QWORD, _QWORD);
// 14028EB38: using guessed type __int64 (__fastcall *qword_14028EB38)(_QWORD, _QWORD, _QWORD);
// 14028EB48: using guessed type __int64 (__fastcall *qword_14028EB48)(_QWORD, _QWORD, _QWORD, _QWORD);
// 14028EB70: using guessed type __int64 (__fastcall *qword_14028EB70)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 14028ECC8: using guessed type __int64 (__fastcall *qword_14028ECC8)(_QWORD, _QWORD, _QWORD);
// 14028ECD0: using guessed type __int64 (__fastcall *qword_14028ECD0)(_QWORD, _QWORD);

//----- (0000000140001428) ----------------------------------------------------
__int64 sub_140001428()
{
  __int64 result; // rax
  __int64 v1; // [rsp+20h] [rbp-50h]
  int Dst; // [rsp+38h] [rbp-38h]
  int v3; // [rsp+50h] [rbp-20h]
  int v4; // [rsp+54h] [rbp-1Ch]
  __int64 v5; // [rsp+58h] [rbp-18h]
  __int64 v6; // [rsp+80h] [rbp+10h]

  memset(&Dst, 0, 0x38ui64);
  v5 = qword_1400070F8;
  v3 = 1;
  v4 = 1;
  Dst = 56;
  result = qword_14028EED8(qword_14028F090, &v1, &Dst, &v6, 24i64, sub_140001314, 1i64, *(_QWORD *)&Dst);
  if ( (signed int)result >= 0 )
  {
    qword_14028EEE0(qword_14028F090, v6);
    result = 0i64;
  }
  return result;
}
// 14028EED8: using guessed type __int64 (__fastcall *qword_14028EED8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 14028EEE0: using guessed type __int64 (__fastcall *qword_14028EEE0)(_QWORD, _QWORD);

//----- (00000001400014B4) ----------------------------------------------------
__int64 __fastcall sub_1400014B4(__m128i *a1, __int64 *a2)
{
  __int64 *v2; // rsi
  __m128i *v3; // rbx
  __m128i v4; // xmm0
  __m128i v5; // xmm1
  __int64 v6; // rcx
  unsigned int v7; // edi
  const char *v8; // rbx
  char *v9; // rax
  __int64 v10; // ST28_8
  __m128i v11; // xmm0
  __int64 v12; // rax
  __int64 v13; // rcx
  __m128i v14; // xmm0
  const char *v15; // rbx
  char *v16; // rax
  __int64 v17; // ST28_8
  __int64 v19; // [rsp+20h] [rbp-E0h]
  __int128 Dst; // [rsp+40h] [rbp-C0h]
  __int64 v21; // [rsp+50h] [rbp-B0h]
  __int128 *v22; // [rsp+68h] [rbp-98h]
  __int128 v23; // [rsp+80h] [rbp-80h]
  char v24; // [rsp+A0h] [rbp-60h]
  __int64 v25; // [rsp+B0h] [rbp-50h]
  __int128 *v26; // [rsp+C8h] [rbp-38h]
  __int128 v27; // [rsp+E0h] [rbp-20h]
  __int128 v28; // [rsp+F0h] [rbp-10h]
  int v29; // [rsp+100h] [rbp+0h]
  int v30; // [rsp+110h] [rbp+10h]
  int v31; // [rsp+120h] [rbp+20h]
  __int128 v32; // [rsp+124h] [rbp+24h]

  v2 = a2;
  v3 = a1;
  memset((char *)&Dst + 4, 0, 0x54ui64);
  memset(&v24, 0, 0xC8ui64);
  v4 = *v3;
  v5 = *(__m128i *)(v2 + 1);
  v6 = qword_140007108;
  v21 = *v2;
  v22 = &xmmword_140007048;
  _mm_storeu_si128((__m128i *)&v23, v4);
  _mm_storeu_si128((__m128i *)&Dst, v5);
  v7 = FwpmCalloutAdd0(v6, &Dst, 0i64, 0i64);
  if ( (v7 & 0x80000000) != 0 )
  {
    v8 = "..\\..\\src\\swi_callout\\callout.c";
    v9 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
    if ( v9 )
      v8 = v9 + 1;
    v10 = *v2;
    LODWORD(v19) = 92;
    DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot add the callout <%S>: 0x%08x", v8, v19);
    return v7;
  }
  v11 = *(__m128i *)(v2 + 1);
  v12 = *v2;
  v13 = qword_140007108;
  v30 = 0;
  v29 = 0;
  _mm_storeu_si128((__m128i *)&v32, v11);
  v31 = 16389;
  v14 = *v3;
  v25 = v12;
  v26 = &xmmword_140007048;
  _mm_storeu_si128((__m128i *)&v27, v14);
  _mm_storeu_si128((__m128i *)&v28, (__m128i)xmmword_140007058);
  v7 = FwpmFilterAdd0(v13, &v24, 0i64, 0i64);
  if ( (v7 & 0x80000000) != 0 )
  {
    v15 = "..\\..\\src\\swi_callout\\callout.c";
    v16 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
    if ( v16 )
      v15 = v16 + 1;
    v17 = *v2;
    LODWORD(v19) = 106;
    DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot add the filter <%S>: 0x%08x", v15, v19);
    return v7;
  }
  return 0i64;
}
// 14000446A: using guessed type __int64 __fastcall FwpmCalloutAdd0(_QWORD, _QWORD, _QWORD, _QWORD);
// 140004470: using guessed type __int64 __fastcall FwpmFilterAdd0(_QWORD, _QWORD, _QWORD, _QWORD);
// 140007048: using guessed type __int128 xmmword_140007048;
// 140007058: using guessed type __int128 xmmword_140007058;
// 140007108: using guessed type __int64 qword_140007108;

//----- (0000000140001648) ----------------------------------------------------
__int64 sub_140001648()
{
  const char *v0; // rbx
  char *v1; // rax
  signed int v3; // edi
  const char *v4; // rbx
  char *v5; // rax
  const char *v6; // rbx
  char *v7; // rax
  const char *v8; // rbx
  char *v9; // rax
  const char *v10; // r9
  char *v11; // rax
  const char *v12; // rbx
  char *v13; // rax
  __int64 v14; // [rsp+20h] [rbp-78h]
  __int64 v15; // [rsp+20h] [rbp-78h]
  char Dst; // [rsp+30h] [rbp-68h]
  int v17; // [rsp+50h] [rbp-48h]
  int v18; // [rsp+54h] [rbp-44h]

  memset(&Dst, 0, 0x48ui64);
  if ( qword_140007108 )
  {
    v0 = "..\\..\\src\\swi_callout\\callout.c";
    v1 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
    if ( v1 )
      v0 = v1 + 1;
    LODWORD(v14) = 123;
    DbgPrintEx(77i64, 2i64, "[%s:%hu] swi_callout filters already registered, no need to register again", v0, v14);
    return 0i64;
  }
  v18 = dword_140007228;
  v17 = 1;
  v3 = FwpmEngineOpen0(0i64, 10i64, 0i64, &Dst, &qword_140007108);
  if ( v3 >= 0 )
  {
    v3 = FwpmTransactionBegin0(qword_140007108, 0i64);
    if ( v3 >= 0 )
    {
      v8 = "..\\..\\src\\swi_callout\\callout.c";
      v3 = sub_1400018D8();
      if ( v3 >= 0 )
      {
        v3 = sub_1400019A8();
        if ( v3 >= 0 )
        {
          v3 = sub_1400014B4((__m128i *)&unk_1400061C8, (__int64 *)off_140007000);
          if ( v3 >= 0 )
          {
            v3 = sub_1400014B4((__m128i *)&unk_1400061B8, (__int64 *)&off_140007018);
            if ( v3 >= 0 )
            {
              v3 = sub_1400014B4((__m128i *)&unk_1400061A8, (__int64 *)&off_140007030);
              if ( v3 >= 0 )
              {
                v3 = FwpmTransactionCommit0(qword_140007108);
                if ( v3 >= 0 )
                {
                  v12 = "..\\..\\src\\swi_callout\\callout.c";
                  v13 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
                  if ( v13 )
                    v12 = v13 + 1;
                  LODWORD(v15) = 153;
                  DbgPrintEx(77i64, 2i64, "[%s:%hu] swi_callout filters registered", v12, v15);
                  return 0i64;
                }
                v9 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
                v10 = v9 + 1;
                if ( !v9 )
                  v10 = "..\\..\\src\\swi_callout\\callout.c";
                LODWORD(v15) = 150;
                DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot commit the transaction: 0x%x", v10, v15);
              }
            }
          }
        }
      }
      if ( (signed int)FwpmTransactionAbort0(qword_140007108) < 0 )
      {
        v11 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
        if ( v11 )
          v8 = v11 + 1;
        LODWORD(v15) = 160;
        DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot abort the transaction: 0x%x", v8, v15);
      }
    }
    else
    {
      v6 = "..\\..\\src\\swi_callout\\callout.c";
      v7 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
      if ( v7 )
        v6 = v7 + 1;
      LODWORD(v15) = 134;
      DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot begin the transaction: 0x%x", v6, v15);
    }
  }
  else
  {
    v4 = "..\\..\\src\\swi_callout\\callout.c";
    v5 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
    if ( v5 )
      v4 = v5 + 1;
    LODWORD(v15) = 131;
    DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot open the engine: 0x%x", v4, v15);
  }
  return (unsigned int)v3;
}
// 140004440: using guessed type __int64 __fastcall FwpmEngineOpen0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 14000444C: using guessed type __int64 __fastcall FwpmTransactionBegin0(_QWORD, _QWORD);
// 140004452: using guessed type __int64 __fastcall FwpmTransactionCommit0(_QWORD);
// 140004458: using guessed type __int64 __fastcall FwpmTransactionAbort0(_QWORD);
// 140007018: using guessed type wchar_t *off_140007018;
// 140007030: using guessed type wchar_t *off_140007030;
// 140007108: using guessed type __int64 qword_140007108;
// 140007228: using guessed type int dword_140007228;

//----- (00000001400018D8) ----------------------------------------------------
__int64 sub_1400018D8()
{
  __int64 v0; // rcx
  unsigned int v1; // edi
  const char *v2; // rbx
  char *v3; // rax
  __int64 v5; // [rsp+20h] [rbp-78h]
  __int128 Dst; // [rsp+40h] [rbp-58h]
  const wchar_t *v7; // [rsp+50h] [rbp-48h]

  memset((char *)&Dst + 4, 0, 0x3Cui64);
  v0 = qword_140007108;
  v7 = L"Sophos";
  _mm_storeu_si128((__m128i *)&Dst, (__m128i)xmmword_140007048);
  v1 = FwpmProviderAdd0(v0, &Dst, 0i64);
  if ( (v1 & 0x80000000) != 0 )
  {
    v2 = "..\\..\\src\\swi_callout\\callout.c";
    v3 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
    if ( v3 )
      v2 = v3 + 1;
    LODWORD(v5) = 58;
    DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot add the provider <%S>: 0x%08x", v2, v5);
  }
  return v1;
}
// 14000445E: using guessed type __int64 __fastcall FwpmProviderAdd0(_QWORD, _QWORD, _QWORD);
// 140004CC0: using guessed type wchar_t aSophos[7];
// 140007048: using guessed type __int128 xmmword_140007048;
// 140007108: using guessed type __int64 qword_140007108;

//----- (00000001400019A8) ----------------------------------------------------
__int64 sub_1400019A8()
{
  __int64 v0; // rcx
  unsigned int v1; // edi
  const char *v2; // rbx
  char *v3; // rax
  __int64 v5; // [rsp+20h] [rbp-88h]
  __int128 Dst; // [rsp+40h] [rbp-68h]
  const wchar_t *v7; // [rsp+50h] [rbp-58h]
  __int128 *v8; // [rsp+68h] [rbp-40h]

  memset((char *)&Dst + 4, 0, 0x44ui64);
  v0 = qword_140007108;
  v7 = L"SWI_SUBLAYER";
  v8 = &xmmword_140007048;
  _mm_storeu_si128((__m128i *)&Dst, (__m128i)xmmword_140007058);
  v1 = FwpmSubLayerAdd0(v0, &Dst, 0i64);
  if ( (v1 & 0x80000000) != 0 )
  {
    v2 = "..\\..\\src\\swi_callout\\callout.c";
    v3 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
    if ( v3 )
      v2 = v3 + 1;
    LODWORD(v5) = 73;
    DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot add the sublayer <%S>: 0x%08x", v2, v5);
  }
  return v1;
}
// 140004464: using guessed type __int64 __fastcall FwpmSubLayerAdd0(_QWORD, _QWORD, _QWORD);
// 140004D20: using guessed type wchar_t aSwiSublayer[13];
// 140007048: using guessed type __int128 xmmword_140007048;
// 140007058: using guessed type __int128 xmmword_140007058;
// 140007108: using guessed type __int64 qword_140007108;

//----- (0000000140001A84) ----------------------------------------------------
__int64 __fastcall sub_140001A84(__int64 a1)
{
  __int64 v1; // rbx
  const char *v2; // rbx
  char *v3; // rax
  _QWORD v5[3]; // [rsp+20h] [rbp-18h]

  v1 = a1;
  sub_140002CF4(0);
  qword_14028EB38(qword_14028F090, v1, 3221225760i64);
  v2 = "..\\..\\src\\swi_callout\\callout.c";
  v3 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
  if ( v3 )
    v2 = v3 + 1;
  LODWORD(v5[0]) = 517;
  return DbgPrintEx(77i64, 2i64, "[%s:%hu] swi_callout lost proxy link, disable redirection", v2, v5[0]);
}
// 14028EB38: using guessed type __int64 (__fastcall *qword_14028EB38)(_QWORD, _QWORD, _QWORD);

//----- (0000000140001AF0) ----------------------------------------------------
void *sub_140001AF0()
{
  wchar_t **v0; // rbx
  signed __int64 v1; // rdi
  char *v2; // rax
  const char *v3; // r9
  wchar_t *v4; // ST28_8
  __int64 v6; // [rsp+20h] [rbp-28h]

  sub_140002694();
  v0 = off_140007000;
  v1 = 3i64;
  do
  {
    if ( (signed int)FwpsCalloutUnregisterByKey0(v0 + 1) < 0 )
    {
      v2 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
      v3 = v2 + 1;
      if ( !v2 )
        v3 = "..\\..\\src\\swi_callout\\callout.c";
      v4 = *v0;
      LODWORD(v6) = 430;
      DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot unregister the callout <%S>: 0x%x", v3, v6);
    }
    v0 += 3;
    --v1;
  }
  while ( v1 );
  if ( qword_14028E288 )
    FwpsRedirectHandleDestroy0();
  sub_14000389C((void **)&qword_14028E2E8, &qword_14028E2F0);
  return memset(qword_1400070F0, 0, 0x287208ui64);
}
// 14000447C: using guessed type __int64 __fastcall FwpsCalloutUnregisterByKey0(_QWORD);
// 1400044A0: using guessed type __int64 FwpsRedirectHandleDestroy0(void);
// 1400070F0: using guessed type __int64 qword_1400070F0[];
// 14028E288: using guessed type __int64 qword_14028E288;
// 14028E2E8: using guessed type __int64 qword_14028E2E8;
// 14028E2F0: using guessed type __int64 qword_14028E2F0;

//----- (0000000140001BC8) ----------------------------------------------------
__int64 __fastcall sub_140001BC8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5, __int64 a6, _DWORD *a7)
{
  const wchar_t *v7; // rdi
  unsigned int v8; // ebx
  _DWORD *v9; // r14
  __int64 v10; // r15
  __int64 v11; // r12
  __int64 v12; // rbp
  __int64 result; // rax
  __int64 v14; // rax
  int v15; // ecx
  __int64 v16; // rax
  _DWORD *v17; // rsi
  const char *v18; // rbx
  char *v19; // rax
  const char *v20; // rbx
  char *v21; // rax
  __int64 v22; // [rsp+20h] [rbp-48h]
  __int64 v23; // [rsp+20h] [rbp-48h]
  __int64 v24; // [rsp+30h] [rbp-38h]
  __int64 v25; // [rsp+70h] [rbp+8h]

  v25 = 0i64;
  v7 = 0i64;
  v24 = 0i64;
  v8 = 0;
  v9 = a7;
  v10 = a4;
  v11 = a2;
  v12 = a1;
  *a7 = 4098;
  result = *(_QWORD *)(a1 + 8);
  if ( *(_BYTE *)(result + 88) == 6 )
  {
    v14 = *(_QWORD *)(result + 8);
    if ( v14 )
    {
      v7 = *(const wchar_t **)(v14 + 8);
      v8 = *(_DWORD *)v14 >> 1;
      v15 = v8 - 1;
      v16 = (signed int)(v8 - 1);
      if ( (signed int)(v8 - 1) >= 0 )
      {
        while ( v7[v16] != 92 )
        {
          --v15;
          if ( --v16 < 0 )
            goto LABEL_9;
        }
        v8 += -1 - v15;
        if ( v8 )
          v7 += v15 + 1;
      }
    }
LABEL_9:
    result = (__int64)sub_1400036E8(v12, v7, v8);
    v17 = (_DWORD *)result;
    if ( result )
    {
      result = (__int64)sub_1400029A8(v12, v11, (__int64)v7, v8);
      if ( result )
      {
        if ( (signed int)FwpsAcquireClassifyHandle0(v10, 0i64, &v24) >= 0 )
        {
          if ( (signed int)FwpsAcquireWritableLayerDataPointer0(v24, *a5, 0i64, &v25, v9) >= 0 )
          {
            *(_QWORD *)(v25 + 288) = qword_14028E288;
            if ( *v17 == 2130706433 && (_DWORD)qword_140007124 )
              *(_DWORD *)(v25 + 264) = qword_140007124;
            sub_1400030A4(v25 + 128, (__int64)v17);
            result = FwpsApplyModifiedLayerData0(v24, v25, 0i64);
          }
          else
          {
            v20 = "..\\..\\src\\swi_callout\\callout.c";
            v21 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
            if ( v21 )
              v20 = v21 + 1;
            LODWORD(v23) = 243;
            result = DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot acquire the layer data: 0x%08x", v20, v23);
          }
        }
        else
        {
          v18 = "..\\..\\src\\swi_callout\\callout.c";
          v19 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
          if ( v19 )
            v18 = v19 + 1;
          LODWORD(v22) = 240;
          result = DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot acquire the classify handle: 0x%08x", v18, v22);
        }
        if ( !v24 )
          result = FwpsReleaseClassifyHandle0(0i64);
      }
    }
  }
  return result;
}
// 140004482: using guessed type __int64 __fastcall FwpsAcquireClassifyHandle0(_QWORD, _QWORD, _QWORD);
// 140004488: using guessed type __int64 __fastcall FwpsReleaseClassifyHandle0(_QWORD);
// 14000448E: using guessed type __int64 __fastcall FwpsAcquireWritableLayerDataPointer0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140004494: using guessed type __int64 __fastcall FwpsApplyModifiedLayerData0(_QWORD, _QWORD, _QWORD);
// 140007124: using guessed type __int64 qword_140007124;
// 14028E288: using guessed type __int64 qword_14028E288;

//----- (0000000140001DB8) ----------------------------------------------------
__int64 __fastcall sub_140001DB8(int a1)
{
  if ( a1 == 1 && dword_140007120 == 1 )
    sub_140001428();
  return 0i64;
}
// 140007120: using guessed type int dword_140007120;

//----- (0000000140001DD8) ----------------------------------------------------
__int64 sub_140001DD8()
{
  __int64 v0; // rax
  signed int v1; // edi
  const char *v2; // rbx
  char *v3; // rax
  const char *v4; // rbx
  char *v5; // rax
  const char *v6; // rbx
  char *v7; // rax
  const char *v8; // rbx
  char *v9; // rax
  const char *v10; // rbx
  char *v11; // rax
  __int64 v13; // [rsp+20h] [rbp-D8h]
  __int64 v14; // [rsp+30h] [rbp-C8h]
  int v15; // [rsp+38h] [rbp-C0h]
  __int128 *v16; // [rsp+40h] [rbp-B8h]
  int v17; // [rsp+48h] [rbp-B0h]
  __int128 *v18; // [rsp+50h] [rbp-A8h]
  int v19; // [rsp+58h] [rbp-A0h]
  __int64 (__fastcall *v20)(__int64, __int64); // [rsp+60h] [rbp-98h]
  __int64 v21; // [rsp+68h] [rbp-90h]
  void (*v22)(); // [rsp+70h] [rbp-88h]
  int Dst; // [rsp+78h] [rbp-80h]
  int v24; // [rsp+7Ch] [rbp-7Ch]
  int v25; // [rsp+90h] [rbp-68h]
  int v26; // [rsp+94h] [rbp-64h]
  __int128 v27; // [rsp+B0h] [rbp-48h]
  __int128 v28; // [rsp+C0h] [rbp-38h]
  __int64 v29; // [rsp+D0h] [rbp-28h]
  __int128 v30; // [rsp+D8h] [rbp-20h]
  __int128 v31; // [rsp+E8h] [rbp-10h]
  __int128 v32; // [rsp+F8h] [rbp+0h]

  v16 = (__int128 *)((char *)&v27 + 8);
  v27 = xmmword_140005260;
  v29 = 498223874159i64;
  v15 = 2621478;
  v28 = xmmword_140005270;
  v17 = 3145774;
  v18 = (__int128 *)((char *)&v30 + 8);
  v30 = xmmword_140005290;
  v31 = xmmword_1400052A0;
  v32 = xmmword_1400052B0;
  memset(&Dst, 0, 0x38ui64);
  v25 = 1;
  v26 = 1;
  Dst = 56;
  v0 = qword_14028E3C8(qword_14028F090, qword_1400070F0[0], L"68");
  v14 = v0;
  if ( v0 )
  {
    qword_14028E510(qword_14028F090, v0, 18i64);
    qword_14028E530(qword_14028F090, v14, 256i64, 0i64);
    v1 = qword_14028E518(qword_14028F090, v14, &v15);
    if ( v1 >= 0 )
    {
      v21 = 0i64;
      v20 = sub_140001248;
      v22 = sub_1400012D8;
      v19 = 40;
      v24 = 4;
      Dst = 2;
      qword_14028E538(qword_14028F090, v14, &v19, &Dst);
      v1 = qword_14028E558(qword_14028F090, &v14, 0i64, &qword_1400070F8);
      if ( v1 >= 0 )
      {
        v1 = qword_14028E580(qword_14028F090, qword_1400070F8, &v17);
        if ( v1 >= 0 )
        {
          v1 = sub_1400021FC();
          if ( v1 >= 0 )
          {
            qword_14028E3D8(qword_14028F090, qword_1400070F8);
            v14 = 0i64;
            qword_140007100 = qword_14028E3F8(qword_14028F090, qword_1400070F8);
            return 0i64;
          }
          v10 = "..\\..\\src\\swi_callout\\callout.c";
          v11 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
          if ( v11 )
            v10 = v11 + 1;
          LODWORD(v13) = 837;
          DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot create the queue: 0x%x", v10, v13);
        }
        else
        {
          v8 = "..\\..\\src\\swi_callout\\callout.c";
          v9 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
          if ( v9 )
            v8 = v9 + 1;
          LODWORD(v13) = 834;
          DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot create the symbolic link: 0x%x", v8, v13);
        }
      }
      else
      {
        v6 = "..\\..\\src\\swi_callout\\callout.c";
        v7 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
        if ( v7 )
          v6 = v7 + 1;
        LODWORD(v13) = 831;
        DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot create the device: 0x%x", v6, v13);
      }
    }
    else
    {
      v4 = "..\\..\\src\\swi_callout\\callout.c";
      v5 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
      if ( v5 )
        v4 = v5 + 1;
      LODWORD(v13) = 810;
      DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot assign the name: 0x%x", v4, v13);
    }
  }
  else
  {
    v1 = -1073741801;
    v2 = "..\\..\\src\\swi_callout\\callout.c";
    v3 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
    if ( v3 )
      v2 = v3 + 1;
    LODWORD(v13) = 804;
    DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot allocate the device init", v2, v13);
  }
  if ( v14 )
    qword_14028E4B0(qword_14028F090);
  return (unsigned int)v1;
}
// 140005260: using guessed type __int128 xmmword_140005260;
// 140005270: using guessed type __int128 xmmword_140005270;
// 140005290: using guessed type __int128 xmmword_140005290;
// 1400052A0: using guessed type __int128 xmmword_1400052A0;
// 1400052B0: using guessed type __int128 xmmword_1400052B0;
// 1400062D0: using guessed type wchar_t a68[3];
// 1400070F0: using guessed type __int64 qword_1400070F0[];
// 140007100: using guessed type __int64 qword_140007100;
// 14028E3C8: using guessed type __int64 (__fastcall *qword_14028E3C8)(_QWORD, _QWORD, _QWORD);
// 14028E3D8: using guessed type __int64 (__fastcall *qword_14028E3D8)(_QWORD, _QWORD);
// 14028E3F8: using guessed type __int64 (__fastcall *qword_14028E3F8)(_QWORD, _QWORD);
// 14028E4B0: using guessed type __int64 (__fastcall *qword_14028E4B0)(_QWORD);
// 14028E510: using guessed type __int64 (__fastcall *qword_14028E510)(_QWORD, _QWORD, _QWORD);
// 14028E518: using guessed type __int64 (__fastcall *qword_14028E518)(_QWORD, _QWORD, _QWORD);
// 14028E530: using guessed type __int64 (__fastcall *qword_14028E530)(_QWORD, _QWORD, _QWORD, _QWORD);
// 14028E538: using guessed type __int64 (__fastcall *qword_14028E538)(_QWORD, _QWORD, _QWORD, _QWORD);
// 14028E558: using guessed type __int64 (__fastcall *qword_14028E558)(_QWORD, _QWORD, _QWORD, _QWORD);
// 14028E580: using guessed type __int64 (__fastcall *qword_14028E580)(_QWORD, _QWORD, _QWORD);

//----- (0000000140002134) ----------------------------------------------------
__int64 __fastcall sub_140002134(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  unsigned int v4; // edi
  const char *v5; // rbx
  char *v6; // rax
  __int64 v8; // [rsp+20h] [rbp-48h]
  int Dst; // [rsp+40h] [rbp-28h]
  __int64 v10; // [rsp+48h] [rbp-20h]
  __int64 (*v11)(); // [rsp+50h] [rbp-18h]
  int v12; // [rsp+58h] [rbp-10h]

  v2 = a2;
  v3 = a1;
  memset(&Dst, 0, 0x20ui64);
  v10 = 0i64;
  v12 |= 1u;
  v11 = sub_1400028C8;
  Dst = 32;
  v4 = qword_14028E6A0(qword_14028F090, v3, v2, 0i64, &Dst, qword_1400070F0);
  if ( (v4 & 0x80000000) != 0 )
  {
    v5 = "..\\..\\src\\swi_callout\\callout.c";
    v6 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
    if ( v6 )
      v5 = v6 + 1;
    LODWORD(v8) = 498;
    DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot create the driver <%S>: 0x%x", v5, v8);
  }
  return v4;
}
// 1400070F0: using guessed type __int64 qword_1400070F0[];
// 14028E6A0: using guessed type __int64 (__fastcall *qword_14028E6A0)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400021FC) ----------------------------------------------------
__int64 sub_1400021FC()
{
  signed int v0; // edi
  const char *v1; // rbx
  char *v2; // rax
  const char *v3; // rbx
  char *v4; // rax
  const char *v5; // rbx
  char *v6; // rax
  __int64 v8; // [rsp+20h] [rbp-E0h]
  __int64 v9; // [rsp+20h] [rbp-E0h]
  __int64 v10; // [rsp+20h] [rbp-E0h]
  int Dst; // [rsp+30h] [rbp-D0h]
  int v12; // [rsp+34h] [rbp-CCh]
  int v13; // [rsp+38h] [rbp-C8h]
  char v14; // [rsp+3Dh] [rbp-C3h]
  __int64 (__fastcall *v15)(__int64, __int64, __int64, __int64, unsigned int); // [rsp+58h] [rbp-A8h]
  int v16; // [rsp+80h] [rbp-80h]
  int v17; // [rsp+90h] [rbp-70h]
  int v18; // [rsp+94h] [rbp-6Ch]
  int v19; // [rsp+98h] [rbp-68h]
  __int64 (__fastcall *v20)(__int64, __int64, __int64, __int64, int); // [rsp+B8h] [rbp-48h]
  int v21; // [rsp+F0h] [rbp-10h]
  int v22; // [rsp+F4h] [rbp-Ch]
  int v23; // [rsp+F8h] [rbp-8h]

  memset(&Dst, 0, 0x60ui64);
  v16 = -1;
  v15 = sub_1400023C8;
  Dst = 96;
  v13 = 2;
  v14 = 1;
  v12 = 2;
  memset(&v17, 0, 0x60ui64);
  v17 = 96;
  v20 = sub_140002498;
  v19 = 2;
  v18 = 1;
  memset(&v21, 0, 0x60ui64);
  v21 = 96;
  v23 = 2;
  v22 = 3;
  v0 = qword_14028E7C0(qword_14028F090, qword_1400070F8, &Dst, 0i64, 0i64);
  if ( v0 >= 0 )
  {
    v0 = qword_14028E7C0(qword_14028F090, qword_1400070F8, &v17, 0i64, &qword_140007110);
    if ( v0 >= 0 )
    {
      v0 = qword_14028E7C0(qword_14028F090, qword_1400070F8, &v21, 0i64, &qword_140007118);
      if ( v0 < 0 )
      {
        v5 = "..\\..\\src\\swi_callout\\callout.c";
        v6 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
        if ( v6 )
          v5 = v6 + 1;
        LODWORD(v10) = 659;
        DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot create the pendingRequests queue: 0x%x", v5, v10);
      }
    }
    else
    {
      v3 = "..\\..\\src\\swi_callout\\callout.c";
      v4 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
      if ( v4 )
        v3 = v4 + 1;
      LODWORD(v9) = 656;
      DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot create the driverControl queue: 0x%x", v3, v9);
    }
  }
  else
  {
    v1 = "..\\..\\src\\swi_callout\\callout.c";
    v2 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
    if ( v2 )
      v1 = v2 + 1;
    LODWORD(v8) = 653;
    DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot create the default queue: 0x%x", v1, v8);
  }
  return (unsigned int)v0;
}
// 1400070F8: using guessed type __int64 qword_1400070F8;
// 14028E7C0: using guessed type __int64 (__fastcall *qword_14028E7C0)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400023C8) ----------------------------------------------------
__int64 __fastcall sub_1400023C8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  __int64 v5; // rbx
  __int64 result; // rax
  signed __int64 v7; // r8

  v5 = a2;
  if ( a5 > 0x12E04A )
  {
    if ( a5 != 1237126 && a5 != 1237130 && a5 != 1237134 && a5 != 1237138 )
    {
LABEL_17:
      LODWORD(result) = -1073741808;
      goto LABEL_19;
    }
LABEL_18:
    result = qword_14028EBC8(qword_14028F090, a2, qword_140007110);
    if ( (signed int)result >= 0 )
      return result;
    goto LABEL_19;
  }
  switch ( a5 )
  {
    case 0x12E04Au:
      LODWORD(result) = sub_140002D80(a2);
      goto LABEL_19;
    case 0x12E006u:
    case 0x12E00Au:
      goto LABEL_18;
    case 0x12E00Eu:
      return qword_14028EAF8(qword_14028F090, a2, sub_140001A84);
    case 0x12E012u:
      result = qword_14028EBC8(qword_14028F090, a2, qword_140007118);
      if ( (signed int)result >= 0 )
        return result;
      v7 = 3221225473i64;
      return qword_14028EB38(qword_14028F090, v5, v7);
  }
  if ( a5 != 1237062 )
    goto LABEL_17;
  LODWORD(result) = sub_140002F40(a2);
LABEL_19:
  v7 = (unsigned int)result;
  return qword_14028EB38(qword_14028F090, v5, v7);
}
// 140007110: using guessed type __int64 qword_140007110;
// 140007118: using guessed type __int64 qword_140007118;
// 14028EAF8: using guessed type __int64 (__fastcall *qword_14028EAF8)(_QWORD, _QWORD, _QWORD);
// 14028EB38: using guessed type __int64 (__fastcall *qword_14028EB38)(_QWORD, _QWORD, _QWORD);
// 14028EBC8: using guessed type __int64 (__fastcall *qword_14028EBC8)(_QWORD, _QWORD, _QWORD);

//----- (0000000140002498) ----------------------------------------------------
__int64 __fastcall sub_140002498(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5)
{
  __int64 v5; // rbx
  unsigned int v6; // eax
  int v7; // edx
  int v8; // edx

  v5 = a2;
  switch ( a5 )
  {
    case 1236998:
      v6 = sub_140002790(a2);
      return qword_14028EB38(qword_14028F090, v5, v6);
    case 1237002:
      sub_140002CF4(0);
      v6 = sub_140002694();
      return qword_14028EB38(qword_14028F090, v5, v6);
    case 1237126:
      v8 = 0;
      goto LABEL_13;
    case 1237130:
      v8 = 1;
LABEL_13:
      v6 = sub_1400030C4(v5, v8);
      return qword_14028EB38(qword_14028F090, v5, v6);
    case 1237134:
      v7 = 0;
      goto LABEL_10;
    case 1237138:
      v7 = 1;
LABEL_10:
      v6 = sub_140003348(v5, v7);
      return qword_14028EB38(qword_14028F090, v5, v6);
  }
  v6 = -1073741808;
  return qword_14028EB38(qword_14028F090, v5, v6);
}
// 14028EB38: using guessed type __int64 (__fastcall *qword_14028EB38)(_QWORD, _QWORD, _QWORD);

//----- (0000000140002524) ----------------------------------------------------
__int64 sub_140002524()
{
  unsigned __int8 v0; // bl
  __m128i *v1; // rdx
  __int64 v2; // rcx
  unsigned int v3; // esi
  const char *v4; // rdi
  char *v5; // rax
  wchar_t *v6; // ST28_8
  __int64 v8; // [rsp+20h] [rbp-61h]
  int v9; // [rsp+38h] [rbp-49h]
  __int64 v10; // [rsp+3Ch] [rbp-45h]
  int v11; // [rsp+44h] [rbp-3Dh]
  int v12; // [rsp+48h] [rbp-39h]
  __int64 (__fastcall *v13)(__int64, __int64, __int64, __int64, _QWORD *, __int64, _DWORD *); // [rsp+50h] [rbp-31h]
  __int64 (__fastcall *v14)(int); // [rsp+58h] [rbp-29h]
  __int64 v15; // [rsp+60h] [rbp-21h]
  int v16; // [rsp+68h] [rbp-19h]
  __int64 v17; // [rsp+6Ch] [rbp-15h]
  int v18; // [rsp+74h] [rbp-Dh]
  int v19; // [rsp+78h] [rbp-9h]
  __int64 (__fastcall *v20)(); // [rsp+80h] [rbp-1h]
  __int64 (__fastcall *v21)(int); // [rsp+88h] [rbp+7h]
  __int64 v22; // [rsp+90h] [rbp+Fh]
  int v23; // [rsp+98h] [rbp+17h]
  __int64 v24; // [rsp+9Ch] [rbp+1Bh]
  int v25; // [rsp+A4h] [rbp+23h]
  int v26; // [rsp+A8h] [rbp+27h]
  __int64 (__fastcall *v27)(); // [rsp+B0h] [rbp+2Fh]
  __int64 (__fastcall *v28)(int); // [rsp+B8h] [rbp+37h]
  __int64 v29; // [rsp+C0h] [rbp+3Fh]

  v9 = 0;
  v15 = 0i64;
  v12 = 0;
  v16 = 0;
  v22 = 0i64;
  v23 = 0;
  v29 = 0i64;
  v10 = 0i64;
  v11 = 0;
  v13 = sub_140001BC8;
  v14 = sub_140001DB8;
  v19 = 0;
  v17 = 0i64;
  v18 = 0;
  v20 = sub_140001BB8;
  v21 = sub_140001DB8;
  v26 = 0;
  v24 = 0i64;
  v0 = 0;
  v25 = 0;
  v27 = sub_140001BB8;
  v28 = sub_140001DB8;
  while ( 1 )
  {
    v1 = (__m128i *)(&v9 + 12 * v0);
    v2 = qword_140007100;
    _mm_storeu_si128(v1, *(__m128i *)&off_140007000[3 * v0 + 1]);
    v3 = FwpsCalloutRegister1(v2, v1, 0i64);
    if ( (v3 & 0x80000000) != 0 )
      break;
    if ( ++v0 >= 3u )
      return v3;
  }
  v4 = "..\\..\\src\\swi_callout\\callout.c";
  v5 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
  if ( v5 )
    v4 = v5 + 1;
  v6 = off_140007000[3 * v0];
  LODWORD(v8) = 414;
  DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot register the callout <%S>: 0x%x", v4, v8);
  return v3;
}
// 140001BB8: using guessed type __int64 __fastcall sub_140001BB8();
// 140004476: using guessed type __int64 __fastcall FwpsCalloutRegister1(_QWORD, _QWORD, _QWORD);
// 140007100: using guessed type __int64 qword_140007100;

//----- (0000000140002694) ----------------------------------------------------
__int64 sub_140002694()
{
  const char *v0; // rbx
  unsigned int v1; // edi
  unsigned int v2; // esi
  char *v3; // rax
  const char *v4; // r9
  char *v5; // rax
  const char *v6; // r9
  char *v7; // rax
  __int64 v9; // [rsp+20h] [rbp-18h]

  v0 = "..\\..\\src\\swi_callout\\callout.c";
  v1 = 0;
  if ( !qword_140007108 )
  {
    v5 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
    v6 = v5 + 1;
    if ( !v5 )
      v6 = "..\\..\\src\\swi_callout\\callout.c";
    LODWORD(v9) = 453;
    DbgPrintEx(77i64, 2i64, "[%s:%hu] swi_callout filters is not registered, no need to un-register", v6, v9);
LABEL_11:
    if ( (v1 & 0x80000000) == 0 )
      return v1;
    goto LABEL_12;
  }
  v1 = FwpmEngineClose0();
  if ( (v1 & 0x80000000) == 0 )
  {
    v2 = 0;
    do
      sub_140002D04(v2++);
    while ( v2 < 0x10000 );
    qword_140007108 = 0i64;
    v3 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
    v4 = v3 + 1;
    if ( !v3 )
      v4 = "..\\..\\src\\swi_callout\\callout.c";
    LODWORD(v9) = 448;
    DbgPrintEx(77i64, 2i64, "[%s:%hu] swi_callout filters un-registered", v4, v9);
    goto LABEL_11;
  }
LABEL_12:
  v7 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
  if ( v7 )
    v0 = v7 + 1;
  LODWORD(v9) = 456;
  DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot close the engine: 0x%x", v0, v9);
  return v1;
}
// 140004446: using guessed type __int64 FwpmEngineClose0(void);
// 140007108: using guessed type __int64 qword_140007108;

//----- (0000000140002790) ----------------------------------------------------
__int64 __fastcall sub_140002790(__int64 a1)
{
  unsigned int v1; // ebx
  const char *v2; // rdi
  char *v3; // rax
  _OWORD *v4; // rax
  signed __int64 v5; // rdx
  __int64 *v6; // rcx
  __int128 v7; // xmm1
  __int64 v9; // [rsp+20h] [rbp-18h]
  _OWORD *v10; // [rsp+48h] [rbp+10h]

  v10 = 0i64;
  v1 = qword_14028EB70(qword_14028F090, a1, 264i64, &v10, 0i64);
  if ( (v1 & 0x80000000) == 0 )
  {
    v4 = v10;
    if ( v10 )
    {
      v5 = 2i64;
      v6 = &qword_140007124;
      do
      {
        *(_OWORD *)v6 = *v4;
        *((_OWORD *)v6 + 1) = v4[1];
        *((_OWORD *)v6 + 2) = v4[2];
        *((_OWORD *)v6 + 3) = v4[3];
        *((_OWORD *)v6 + 4) = v4[4];
        *((_OWORD *)v6 + 5) = v4[5];
        *((_OWORD *)v6 + 6) = v4[6];
        v6 += 16;
        v7 = v4[7];
        v4 += 8;
        *((_OWORD *)v6 - 1) = v7;
        --v5;
      }
      while ( v5 );
      *v6 = *(_QWORD *)v4;
      word_140007234 = __ROR2__(HIWORD(qword_140007124), 8);
      dword_140007230 = _byteswap_ulong(dword_14000712C);
      qword_140007238 = (__int64)"local proxy";
    }
    v1 = sub_140001648();
    sub_140002CF4(1);
  }
  else
  {
    v2 = "..\\..\\src\\swi_callout\\callout.c";
    v3 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
    if ( v3 )
      v2 = v3 + 1;
    LODWORD(v9) = 526;
    DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot get the pointer to config: 0x%08x", v2, v9);
  }
  return v1;
}
// 140007124: using guessed type __int64 qword_140007124;
// 14000712C: using guessed type int dword_14000712C;
// 140007230: using guessed type int dword_140007230;
// 140007234: using guessed type __int16 word_140007234;
// 140007238: using guessed type __int64 qword_140007238;
// 14028EB70: using guessed type __int64 (__fastcall *qword_14028EB70)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400028C8) ----------------------------------------------------
__int64 sub_1400028C8()
{
  const char *v0; // rbx
  char *v1; // rax
  __int64 v3; // [rsp+20h] [rbp-18h]

  sub_140001AF0();
  v0 = "..\\..\\src\\swi_callout\\callout.c";
  v1 = strrchr("..\\..\\src\\swi_callout\\callout.c", 92);
  if ( v1 )
    v0 = v1 + 1;
  LODWORD(v3) = 483;
  return DbgPrintEx(77i64, 2i64, "[%s:%hu] Unloaded the driver <%S>", v0, v3);
}

//----- (0000000140002924) ----------------------------------------------------
__int64 __fastcall sub_140002924(_WORD *a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rdx
  signed int v5; // er10
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // r9
  __int64 v8; // r8
  __int16 v9; // ax

  v4 = a2 >> 1;
  v5 = 0;
  if ( v4 - 1 > 0x7FFFFFFE )
    v5 = -1073741811;
  if ( v5 >= 0 )
  {
    v6 = a4 >> 1;
    if ( v6 <= 0x7FFFFFFE )
    {
      v5 = 0;
      if ( !v4 )
        goto LABEL_17;
      v7 = v6 - v4;
      v8 = a3 - (_QWORD)a1;
      do
      {
        if ( !(v7 + v4) )
          break;
        v9 = *(_WORD *)((char *)a1 + v8);
        if ( !v9 )
          break;
        *a1 = v9;
        ++a1;
        --v4;
      }
      while ( v4 );
      if ( !v4 )
      {
LABEL_17:
        --a1;
        v5 = -2147483643;
      }
    }
    else
    {
      v5 = -1073741811;
    }
    *a1 = 0;
  }
  return (unsigned int)v5;
}

//----- (00000001400029A8) ----------------------------------------------------
char *__fastcall sub_1400029A8(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 v4; // r15
  __int64 v5; // r14
  __int64 v6; // r12
  __int64 v7; // rbx
  char *v8; // rdi
  __int64 v9; // rsi
  __int64 v10; // r13
  const char *v11; // rbx
  char *v12; // rax
  char *v13; // rax
  const char *v14; // rbx
  char *v15; // rax
  __int16 v16; // cx
  int v17; // eax
  const char *v18; // rbx
  __int64 *v19; // rdx
  __int64 v20; // rax
  _QWORD *v21; // rcx
  int v22; // esi
  bool v23; // zf
  char *v24; // rax
  const char *v25; // r9
  char *v26; // rax
  const char *v27; // r9
  char *v28; // rax
  __int64 v29; // rcx
  __int64 v31; // [rsp+20h] [rbp-11h]
  __int64 *v32; // [rsp+28h] [rbp-9h]
  int v33; // [rsp+30h] [rbp-1h]
  char *v34; // [rsp+38h] [rbp+7h]
  int v35; // [rsp+40h] [rbp+Fh]
  char *v36; // [rsp+48h] [rbp+17h]
  __int64 v37; // [rsp+50h] [rbp+1Fh]
  __int64 v38; // [rsp+58h] [rbp+27h]
  __int64 v39; // [rsp+60h] [rbp+2Fh]
  int v40; // [rsp+98h] [rbp+67h]

  v4 = a4;
  v38 = 0i64;
  v5 = a1;
  v39 = 0i64;
  v37 = 0i64;
  v6 = a3;
  v7 = a2;
  v8 = 0i64;
  v9 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 72i64);
  v10 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 72i64);
  if ( qword_14018E288[v9] )
  {
    v11 = "..\\..\\src\\swi_callout\\calloutUtil.c";
    v12 = strrchr("..\\..\\src\\swi_callout\\calloutUtil.c", 92);
    if ( v12 )
      v11 = v12 + 1;
    LODWORD(v32) = (unsigned __int16)v9;
    LODWORD(v31) = 199;
    DbgPrintEx(77i64, 0i64, "[%s:%hu] Port <%hu> is in use", v11, v31);
  }
  else
  {
    v13 = (char *)ExAllocatePoolWithTag((POOL_TYPE)512, 0x696ui64, 0x30495753u);
    v8 = v13;
    if ( v13 )
    {
      memset(v13, 0, 0x696ui64);
      *((_WORD *)v8 + 2) = 2;
      *((_DWORD *)v8 + 2) = _byteswap_ulong(*(_DWORD *)(*(_QWORD *)(v5 + 8) + 104i64));
      v16 = *(_WORD *)(*(_QWORD *)(v5 + 8) + 136i64);
      *(_WORD *)v8 = v9;
      *((_WORD *)v8 + 1) = 2;
      *((_WORD *)v8 + 3) = __ROR2__(v16, 8);
      v17 = *(_DWORD *)(v7 + 64);
      v18 = "..\\..\\src\\swi_callout\\calloutUtil.c";
      *((_DWORD *)v8 + 33) = v17;
      v19 = *(__int64 **)(*(_QWORD *)(*(_QWORD *)(v5 + 8) + 24i64) + 8i64);
      if ( v19 )
      {
        if ( KeGetCurrentIrql() > 1u )
        {
          v26 = strrchr("..\\..\\src\\swi_callout\\calloutUtil.c", 92);
          v27 = v26 + 1;
          if ( !v26 )
            v27 = "..\\..\\src\\swi_callout\\calloutUtil.c";
          LODWORD(v31) = 245;
          DbgPrintEx(
            77i64,
            1i64,
            "[%s:%hu] Current Irql level is greater than APC_LEVEL, skip calling SecLookupAccountSid.",
            v27,
            v31);
        }
        else
        {
          v33 = 0x2000000;
          v35 = 0x2000000;
          v34 = v8 + 658;
          LODWORD(v32) = 512;
          v36 = v8 + 1172;
          v20 = *v19;
          v40 = 512;
          v21 = *(_QWORD **)(v20 + 8);
          v32 = (__int64 *)((char *)&v32 + 4);
          v22 = SecLookupAccountSid(*v21, &v32, &v33, &v40, &v35);
          v23 = v22 == 0;
          if ( v22 < 0 )
          {
            v24 = strrchr("..\\..\\src\\swi_callout\\calloutUtil.c", 92);
            v25 = v24 + 1;
            if ( !v24 )
              v25 = "..\\..\\src\\swi_callout\\calloutUtil.c";
            LODWORD(v34) = v40;
            v33 = (signed int)v32;
            LODWORD(v32) = v22;
            LODWORD(v31) = 235;
            DbgPrintEx(
              77i64,
              0i64,
              "[%s:%hu] SecLookupAccountSid() failed: status : %d, username size is %d, domain size is %d",
              v25,
              v31);
            v23 = v22 == 0;
          }
          if ( v23 )
          {
            *(_WORD *)&v34[2 * (unsigned __int16)v33 + 4] = 0;
            *(_WORD *)&v36[2 * (unsigned __int16)v35 + 4] = 0;
          }
        }
      }
      if ( v6 && (_DWORD)v4 )
      {
        sub_140002924((_WORD *)v8 + 68, 0x20Aui64, v6, 2 * v4);
        *((_WORD *)v8 + 328) = 0;
      }
      if ( *(_DWORD *)(*(_QWORD *)(v5 + 8) + 40i64) )
      {
        v28 = strrchr("..\\..\\src\\swi_callout\\calloutUtil.c", 92);
        if ( v28 )
          v18 = v28 + 1;
        v29 = *(_QWORD *)(v5 + 8);
        v35 = *(unsigned __int16 *)(v29 + 72);
        LODWORD(v34) = *(_DWORD *)(v29 + 40);
        v33 = *((_DWORD *)v8 + 33);
        v32 = (__int64 *)(v8 + 136);
        LODWORD(v31) = 258;
        DbgPrintEx(77i64, 1i64, "[%s:%hu] %S(%u) bind() to <0x%x:%hu> before connect()", v18, v31);
      }
      KeAcquireInStackQueuedSpinLock(&SpinLock, &v37);
      qword_14018E288[v10] = v8;
      KeReleaseInStackQueuedSpinLock(&v37);
    }
    else
    {
      v14 = "..\\..\\src\\swi_callout\\calloutUtil.c";
      v15 = strrchr("..\\..\\src\\swi_callout\\calloutUtil.c", 92);
      if ( v15 )
        v14 = v15 + 1;
      LODWORD(v31) = 204;
      DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot create a new meta", v14, v31);
    }
  }
  return v8;
}
// 1400060B8: using guessed type __int64 __fastcall SecLookupAccountSid(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400060F0: using guessed type __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD);
// 1400060F8: using guessed type __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD, _QWORD);

//----- (0000000140002CF4) ----------------------------------------------------
__int64 __fastcall sub_140002CF4(int a1)
{
  return (unsigned int)_InterlockedExchange(&dword_140007120, a1 != 0);
}
// 140007120: using guessed type int dword_140007120;

//----- (0000000140002D04) ----------------------------------------------------
void __fastcall sub_140002D04(unsigned __int16 a1)
{
  __int64 v1; // rbx
  void *v2; // rdi
  __int64 v3; // [rsp+20h] [rbp-28h]
  __int64 v4; // [rsp+28h] [rbp-20h]
  __int64 v5; // [rsp+30h] [rbp-18h]

  v1 = a1;
  v3 = 0i64;
  v4 = 0i64;
  v5 = 0i64;
  if ( qword_14018E288[a1] )
  {
    KeAcquireInStackQueuedSpinLock(&SpinLock, &v3);
    v2 = (void *)qword_14018E288[v1];
    qword_14018E288[v1] = 0i64;
    KeReleaseInStackQueuedSpinLock(&v3);
    if ( v2 )
      ExFreePoolWithTag(v2, 0x30495753u);
  }
}
// 1400060F0: using guessed type __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD);
// 1400060F8: using guessed type __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD, _QWORD);

//----- (0000000140002D80) ----------------------------------------------------
__int64 __fastcall sub_140002D80(__int64 a1)
{
  signed int v1; // edi
  const char *v2; // rbx
  char *v3; // rax
  const char *v4; // rbx
  char *v5; // rax
  __int64 v6; // rsi
  __int128 **v7; // rbx
  signed __int64 v8; // rbp
  __int128 *v9; // rcx
  signed __int64 v10; // rax
  __int64 v11; // rdx
  __int128 v12; // xmm0
  __int64 v14; // [rsp+20h] [rbp-38h]
  __int64 v15; // [rsp+30h] [rbp-28h]
  __int64 v16; // [rsp+38h] [rbp-20h]
  __int64 v17; // [rsp+40h] [rbp-18h]
  __int64 v18; // [rsp+68h] [rbp+10h]

  v18 = 0i64;
  v1 = qword_14028EB70(qword_14028F090, a1, 220987392i64, &v18, 0i64);
  if ( v1 >= 0 )
  {
    if ( v18 )
    {
      v6 = 0i64;
      v7 = (__int128 **)qword_14018E288;
      v8 = 0x10000i64;
      do
      {
        if ( *v7 )
        {
          v15 = 0i64;
          v16 = 0i64;
          v17 = 0i64;
          KeAcquireInStackQueuedSpinLock(&SpinLock, &v15);
          v9 = *v7;
          if ( *v7 )
          {
            v10 = 13i64;
            v11 = v6 + v18;
            do
            {
              v12 = *v9;
              v9 += 8;
              *(_OWORD *)v11 = v12;
              v11 += 128i64;
              *(_OWORD *)(v11 - 112) = *(v9 - 7);
              *(_OWORD *)(v11 - 96) = *(v9 - 6);
              *(_OWORD *)(v11 - 80) = *(v9 - 5);
              *(_OWORD *)(v11 - 64) = *(v9 - 4);
              *(_OWORD *)(v11 - 48) = *(v9 - 3);
              *(_OWORD *)(v11 - 32) = *(v9 - 2);
              *(_OWORD *)(v11 - 16) = *(v9 - 1);
              --v10;
            }
            while ( v10 );
            *(_OWORD *)v11 = *v9;
            *(_DWORD *)(v11 + 16) = *((_DWORD *)v9 + 4);
            *(_WORD *)(v11 + 20) = *((_WORD *)v9 + 10);
          }
          KeReleaseInStackQueuedSpinLock(&v15);
        }
        ++v7;
        v6 += 1686i64;
        --v8;
      }
      while ( v8 );
    }
    else
    {
      v4 = "..\\..\\src\\swi_callout\\calloutUtil.c";
      v1 = -1073741801;
      v5 = strrchr("..\\..\\src\\swi_callout\\calloutUtil.c", 92);
      if ( v5 )
        v4 = v5 + 1;
      LODWORD(v14) = 524;
      DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot get the pointer to metas", v4, v14);
    }
  }
  else
  {
    v2 = "..\\..\\src\\swi_callout\\calloutUtil.c";
    v3 = strrchr("..\\..\\src\\swi_callout\\calloutUtil.c", 92);
    if ( v3 )
      v2 = v3 + 1;
    LODWORD(v14) = 523;
    DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot get the pointer to metas: 0x%08x", v2, v14);
  }
  return (unsigned int)v1;
}
// 1400060F0: using guessed type __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD);
// 1400060F8: using guessed type __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD, _QWORD);
// 14028EB70: using guessed type __int64 (__fastcall *qword_14028EB70)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140002F40) ----------------------------------------------------
__int64 __fastcall sub_140002F40(__int64 a1)
{
  unsigned int v1; // edi
  const char *v2; // rbx
  char *v3; // rax
  unsigned __int16 *v4; // rcx
  __int64 v5; // rdx
  signed __int64 v6; // rax
  __int128 v7; // xmm1
  __int64 v9; // [rsp+20h] [rbp-38h]
  __int64 v10; // [rsp+30h] [rbp-28h]
  __int64 v11; // [rsp+38h] [rbp-20h]
  __int64 v12; // [rsp+40h] [rbp-18h]
  unsigned __int16 *v13; // [rsp+68h] [rbp+10h]

  v13 = 0i64;
  v1 = qword_14028EB70(qword_14028F090, a1, 1686i64, &v13, 0i64);
  if ( (v1 & 0x80000000) == 0 )
  {
    if ( v13[1] == 2 && qword_1400070F0[*v13 + 200243] )
    {
      v10 = 0i64;
      v11 = 0i64;
      v12 = 0i64;
      KeAcquireInStackQueuedSpinLock(&SpinLock, &v10);
      v4 = v13;
      v5 = qword_1400070F0[*v13 + 200243];
      if ( v5 )
      {
        v6 = 13i64;
        do
        {
          *(_OWORD *)v4 = *(_OWORD *)v5;
          *((_OWORD *)v4 + 1) = *(_OWORD *)(v5 + 16);
          *((_OWORD *)v4 + 2) = *(_OWORD *)(v5 + 32);
          *((_OWORD *)v4 + 3) = *(_OWORD *)(v5 + 48);
          *((_OWORD *)v4 + 4) = *(_OWORD *)(v5 + 64);
          *((_OWORD *)v4 + 5) = *(_OWORD *)(v5 + 80);
          *((_OWORD *)v4 + 6) = *(_OWORD *)(v5 + 96);
          v4 += 64;
          v7 = *(_OWORD *)(v5 + 112);
          v5 += 128i64;
          *((_OWORD *)v4 - 1) = v7;
          --v6;
        }
        while ( v6 );
        *(_OWORD *)v4 = *(_OWORD *)v5;
        *((_DWORD *)v4 + 4) = *(_DWORD *)(v5 + 16);
        v4[10] = *(_WORD *)(v5 + 20);
      }
      KeReleaseInStackQueuedSpinLock(&v10);
    }
  }
  else
  {
    v2 = "..\\..\\src\\swi_callout\\calloutUtil.c";
    v3 = strrchr("..\\..\\src\\swi_callout\\calloutUtil.c", 92);
    if ( v3 )
      v2 = v3 + 1;
    LODWORD(v9) = 493;
    DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot get the pointer to meta: 0x%08x", v2, v9);
  }
  return v1;
}
// 1400060F0: using guessed type __int64 __fastcall KeReleaseInStackQueuedSpinLock(_QWORD);
// 1400060F8: using guessed type __int64 __fastcall KeAcquireInStackQueuedSpinLock(_QWORD, _QWORD);
// 1400070F0: using guessed type __int64 qword_1400070F0[];
// 14028EB70: using guessed type __int64 (__fastcall *qword_14028EB70)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400030A4) ----------------------------------------------------
__int16 __fastcall sub_1400030A4(__int64 a1, __int64 a2)
{
  __int16 result; // ax

  if ( a1 )
  {
    if ( a2 )
    {
      *(_DWORD *)(a1 + 4) = _byteswap_ulong(*(_DWORD *)a2);
      result = __ROR2__(*(_WORD *)(a2 + 4), 8);
      *(_WORD *)(a1 + 2) = result;
    }
  }
  return result;
}

//----- (00000001400030C4) ----------------------------------------------------
__int64 __fastcall sub_1400030C4(__int64 a1, int a2)
{
  int v2; // ebp
  unsigned int v3; // edi
  const char *v4; // rbx
  char *v5; // rax
  _OWORD *v8; // rax
  _OWORD *v9; // rcx
  signed __int64 v10; // r8
  __int128 v11; // xmm1
  unsigned int v12; // edx
  bool v13; // zf
  __int64 v14; // rax
  signed __int64 v15; // r8
  _OWORD *v16; // rax
  _OWORD *v17; // rcx
  signed __int64 v18; // r8
  __int128 v19; // xmm1
  unsigned int v20; // edx
  signed __int64 v21; // r8
  __int64 v25; // [rsp+20h] [rbp-28h]
  unsigned int *v26; // [rsp+60h] [rbp+18h]

  v2 = a2;
  v26 = 0i64;
  v3 = qword_14028EB70(qword_14028F090, a1, 134660i64, &v26, 0i64);
  if ( (v3 & 0x80000000) == 0 )
  {
    if ( v26 && *v26 <= 0x100 )
    {
      _RSI = (unsigned int *)qword_140087260;
      _RBX = (unsigned int *)qword_140087268;
      if ( !v2 )
      {
        v16 = v26 + 1;
        v17 = (_OWORD *)(qword_140087268 + 8);
        v18 = 1052i64;
        do
        {
          *v17 = *v16;
          v17[1] = v16[1];
          v17[2] = v16[2];
          v17[3] = v16[3];
          v17[4] = v16[4];
          v17[5] = v16[5];
          v17[6] = v16[6];
          v17 += 8;
          v19 = v16[7];
          v16 += 8;
          *(v17 - 1) = v19;
          --v18;
        }
        while ( v18 );
        v20 = 0;
        *_RBX = *v26;
        if ( *_RBX )
        {
          do
          {
            v21 = 526i64 * v20;
            if ( *(unsigned int *)((char *)_RBX + v21 + 530) > 0x104 )
            {
              *(unsigned int *)((char *)_RBX + v21 + 530) = 260;
              *((_WORD *)_RBX + 263 * v20 + 264) = 0;
            }
            ++v20;
          }
          while ( v20 < *_RBX );
        }
        goto LABEL_22;
      }
      if ( *v26 + *(_DWORD *)qword_140087260 <= 0x400 )
      {
        v8 = (_OWORD *)(qword_140087260 + 8);
        v9 = (_OWORD *)(qword_140087268 + 8);
        v10 = 4208i64;
        do
        {
          *v9 = *v8;
          v9[1] = v8[1];
          v9[2] = v8[2];
          v9[3] = v8[3];
          v9[4] = v8[4];
          v9[5] = v8[5];
          v9[6] = v8[6];
          v9 += 8;
          v11 = v8[7];
          v8 += 8;
          *(v9 - 1) = v11;
          --v10;
        }
        while ( v10 );
        *_RBX = *_RSI;
        memmove((char *)_RBX + 526 * *_RBX + 8, v26 + 1, 526i64 * *v26);
        v12 = 0;
        v13 = *v26 + *_RBX == 0;
        *_RBX += *v26;
        v14 = *_RBX;
        if ( !v13 )
        {
          do
          {
            v15 = 526i64 * v12;
            if ( *(unsigned int *)((char *)_RBX + v15 + 530) > 0x104 )
            {
              *(unsigned int *)((char *)_RBX + v15 + 530) = 260;
              *((_WORD *)_RBX + 263 * v12 + 264) = 0;
            }
            ++v12;
          }
          while ( v12 < *_RBX );
        }
LABEL_22:
        _RBX[1] = 0;
        __asm
        {
          xchg    rbx, cs:qword_140087260
          xchg    rsi, cs:qword_140087268
        }
        *(_DWORD *)(qword_140087268 + 4) = 1;
        return v3;
      }
    }
    return (unsigned int)-1073741811;
  }
  v4 = "..\\..\\src\\swi_callout\\calloutUtil.c";
  v5 = strrchr("..\\..\\src\\swi_callout\\calloutUtil.c", 92);
  if ( v5 )
    v4 = v5 + 1;
  LODWORD(v25) = 277;
  DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot get the pointer to browser list: 0x%08x", v4, v25);
  return v3;
}
// 140087260: using guessed type __int64 qword_140087260;
// 140087268: using guessed type __int64 qword_140087268;
// 14028EB70: using guessed type __int64 (__fastcall *qword_14028EB70)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140003348) ----------------------------------------------------
__int64 __fastcall sub_140003348(__int64 a1, int a2)
{
  int v2; // edi
  unsigned int v3; // ebx
  const char *v4; // rdi
  char *v5; // rax
  _OWORD *v8; // rax
  _OWORD *v9; // rcx
  signed __int64 v10; // r9
  __int128 v11; // xmm1
  unsigned int v12; // er11
  unsigned int *v13; // rax
  unsigned __int64 v14; // rcx
  _OWORD *v15; // r10
  char *v16; // rax
  signed __int64 v17; // rcx
  __int128 v18; // xmm1
  __int128 v19; // xmm0
  __int128 v20; // xmm1
  __int128 v21; // xmm0
  __int128 v22; // xmm1
  __int128 v23; // xmm0
  __int128 v24; // xmm1
  signed __int64 v25; // r10
  unsigned int *v26; // rax
  char *v27; // rcx
  __int128 v28; // xmm1
  __int128 v29; // xmm0
  __int128 v30; // xmm1
  __int128 v31; // xmm0
  __int128 v32; // xmm1
  __int128 v33; // xmm0
  __int128 v34; // xmm1
  unsigned int v35; // er11
  unsigned int *v36; // rax
  unsigned __int64 v37; // rcx
  _OWORD *v38; // r10
  char *v39; // rax
  signed __int64 v40; // rcx
  __int128 v41; // xmm1
  __int128 v42; // xmm0
  __int128 v43; // xmm1
  __int128 v44; // xmm0
  __int128 v45; // xmm1
  __int128 v46; // xmm0
  __int128 v47; // xmm1
  signed __int64 v48; // r10
  unsigned int *v49; // rax
  char *v50; // rcx
  __int128 v51; // xmm1
  __int128 v52; // xmm0
  __int128 v53; // xmm1
  __int128 v54; // xmm0
  __int128 v55; // xmm1
  __int128 v56; // xmm0
  __int128 v57; // xmm1
  __int64 v61; // [rsp+20h] [rbp-E0h]
  char v62; // [rsp+30h] [rbp-D0h]
  __int64 v63; // [rsp+150h] [rbp+50h]

  v63 = 0i64;
  v2 = a2;
  v3 = qword_14028EB70(qword_14028F090, a1, 65540i64, &v63, 0i64);
  if ( (v3 & 0x80000000) == 0 )
  {
    if ( v63 && *(_DWORD *)v63 <= 0x100u )
    {
      _R8 = (unsigned int *)qword_140007240;
      _RDX = (unsigned int *)qword_140007248;
      if ( !v2 )
      {
        *(_DWORD *)qword_140007248 = 0;
        v35 = 0;
        v36 = (unsigned int *)v63;
        if ( *(_DWORD *)v63 )
        {
          do
          {
            v37 = (unsigned __int64)v35 << 8;
            v38 = (_OWORD *)((char *)v36 + v37 + 4);
            if ( 2 == *(_WORD *)v38
              && *(unsigned int *)((char *)v36 + v37 + 8)
              && *(unsigned int *)((char *)v36 + v37 + 136) )
            {
              v39 = &v62;
              v40 = 2i64;
              do
              {
                v41 = v38[1];
                *(_OWORD *)v39 = *v38;
                v42 = v38[2];
                *((_OWORD *)v39 + 1) = v41;
                v43 = v38[3];
                *((_OWORD *)v39 + 2) = v42;
                v44 = v38[4];
                *((_OWORD *)v39 + 3) = v43;
                v45 = v38[5];
                *((_OWORD *)v39 + 4) = v44;
                v46 = v38[6];
                *((_OWORD *)v39 + 5) = v45;
                v47 = v38[7];
                v38 += 8;
                *((_OWORD *)v39 + 6) = v46;
                v39 += 128;
                *((_OWORD *)v39 - 1) = v47;
                --v40;
              }
              while ( v40 );
              v48 = 2i64;
              v49 = &_RDX[64 * (unsigned __int64)*_RDX + 2];
              v50 = &v62;
              do
              {
                v51 = *((_OWORD *)v50 + 1);
                *(_OWORD *)v49 = *(_OWORD *)v50;
                v52 = *((_OWORD *)v50 + 2);
                *((_OWORD *)v49 + 1) = v51;
                v53 = *((_OWORD *)v50 + 3);
                *((_OWORD *)v49 + 2) = v52;
                v54 = *((_OWORD *)v50 + 4);
                *((_OWORD *)v49 + 3) = v53;
                v55 = *((_OWORD *)v50 + 5);
                *((_OWORD *)v49 + 4) = v54;
                v56 = *((_OWORD *)v50 + 6);
                *((_OWORD *)v49 + 5) = v55;
                v57 = *((_OWORD *)v50 + 7);
                v50 += 128;
                *((_OWORD *)v49 + 6) = v56;
                v49 += 32;
                *((_OWORD *)v49 - 1) = v57;
                --v48;
              }
              while ( v48 );
              ++*_RDX;
              v36 = (unsigned int *)v63;
            }
            ++v35;
          }
          while ( v35 < *v36 );
        }
        goto LABEL_32;
      }
      if ( (unsigned int)(*(_DWORD *)v63 + *(_DWORD *)qword_140007240) <= 0x400 )
      {
        v8 = (_OWORD *)(qword_140007240 + 8);
        v9 = (_OWORD *)(qword_140007248 + 8);
        v10 = 2048i64;
        do
        {
          *v9 = *v8;
          v9[1] = v8[1];
          v9[2] = v8[2];
          v9[3] = v8[3];
          v9[4] = v8[4];
          v9[5] = v8[5];
          v9[6] = v8[6];
          v9 += 8;
          v11 = v8[7];
          v8 += 8;
          *(v9 - 1) = v11;
          --v10;
        }
        while ( v10 );
        v12 = 0;
        *_RDX = *_R8;
        v13 = (unsigned int *)v63;
        if ( *(_DWORD *)v63 )
        {
          do
          {
            v14 = (unsigned __int64)v12 << 8;
            v15 = (_OWORD *)((char *)v13 + v14 + 4);
            if ( 2 == *(_WORD *)v15
              && *(unsigned int *)((char *)v13 + v14 + 8)
              && *(unsigned int *)((char *)v13 + v14 + 136) )
            {
              v16 = &v62;
              v17 = 2i64;
              do
              {
                v18 = v15[1];
                *(_OWORD *)v16 = *v15;
                v19 = v15[2];
                *((_OWORD *)v16 + 1) = v18;
                v20 = v15[3];
                *((_OWORD *)v16 + 2) = v19;
                v21 = v15[4];
                *((_OWORD *)v16 + 3) = v20;
                v22 = v15[5];
                *((_OWORD *)v16 + 4) = v21;
                v23 = v15[6];
                *((_OWORD *)v16 + 5) = v22;
                v24 = v15[7];
                v15 += 8;
                *((_OWORD *)v16 + 6) = v23;
                v16 += 128;
                *((_OWORD *)v16 - 1) = v24;
                --v17;
              }
              while ( v17 );
              v25 = 2i64;
              v26 = &_RDX[64 * (unsigned __int64)*_RDX + 2];
              v27 = &v62;
              do
              {
                v28 = *((_OWORD *)v27 + 1);
                *(_OWORD *)v26 = *(_OWORD *)v27;
                v29 = *((_OWORD *)v27 + 2);
                *((_OWORD *)v26 + 1) = v28;
                v30 = *((_OWORD *)v27 + 3);
                *((_OWORD *)v26 + 2) = v29;
                v31 = *((_OWORD *)v27 + 4);
                *((_OWORD *)v26 + 3) = v30;
                v32 = *((_OWORD *)v27 + 5);
                *((_OWORD *)v26 + 4) = v31;
                v33 = *((_OWORD *)v27 + 6);
                *((_OWORD *)v26 + 5) = v32;
                v34 = *((_OWORD *)v27 + 7);
                v27 += 128;
                *((_OWORD *)v26 + 6) = v33;
                v26 += 32;
                *((_OWORD *)v26 - 1) = v34;
                --v25;
              }
              while ( v25 );
              ++*_RDX;
              v13 = (unsigned int *)v63;
            }
            ++v12;
          }
          while ( v12 < *v13 );
        }
LABEL_32:
        _RDX[1] = 0;
        __asm
        {
          xchg    rdx, cs:qword_140007240
          xchg    r8, cs:qword_140007248
        }
        *(_DWORD *)(qword_140007248 + 4) = 1;
        return v3;
      }
    }
    return (unsigned int)-1073741811;
  }
  v4 = "..\\..\\src\\swi_callout\\calloutUtil.c";
  v5 = strrchr("..\\..\\src\\swi_callout\\calloutUtil.c", 92);
  if ( v5 )
    v4 = v5 + 1;
  LODWORD(v61) = 365;
  DbgPrintEx(77i64, 0i64, "[%s:%hu] Cannot get the pointer to bypass list: 0x%08x", v4, v61);
  return v3;
}
// 140007240: using guessed type __int64 qword_140007240;
// 140007248: using guessed type __int64 qword_140007248;
// 14028EB70: using guessed type __int64 (__fastcall *qword_14028EB70)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400036E8) ----------------------------------------------------
int *__fastcall sub_1400036E8(__int64 a1, const wchar_t *a2, unsigned int a3)
{
  unsigned int v3; // esi
  const wchar_t *v4; // rbp
  __int64 v5; // rbx
  __int64 v6; // rdx
  unsigned int v7; // er9
  unsigned int v8; // ebx
  signed __int64 v9; // rdi

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a1 )
  {
    if ( dword_140007120 )
    {
      v6 = *(_QWORD *)(a1 + 8);
      if ( !_byteswap_ulong(*(_DWORD *)(v6 + 40))
        && !sub_140003A24(*(_DWORD *)(v6 + 104), *(_WORD *)(v6 + 136), qword_14028E2E8, qword_14028E2F0) )
      {
        v7 = 0;
        if ( *(_DWORD *)qword_140007240 )
        {
          do
          {
            if ( *(_DWORD *)(qword_140007240 + 4) )
              break;
            if ( (*(_DWORD *)(((unsigned __int64)v7 << 8) + qword_140007240 + 140) & _byteswap_ulong(*(_DWORD *)(*(_QWORD *)(v5 + 8) + 104i64))) == (*(_DWORD *)(((unsigned __int64)v7 << 8) + qword_140007240 + 140) & *(_DWORD *)(((unsigned __int64)v7 << 8) + qword_140007240 + 12)) )
              return 0i64;
            ++v7;
          }
          while ( v7 < *(_DWORD *)qword_140007240 );
        }
        if ( (unsigned __int16)word_140007234 > 0u )
        {
          if ( v4 )
          {
            if ( v3 )
            {
              v8 = 0;
              if ( *(_DWORD *)qword_140087260 )
              {
                while ( !*(_DWORD *)(qword_140087260 + 4) )
                {
                  v9 = 526i64 * v8;
                  if ( v3 >= *(_DWORD *)(v9 + qword_140087260 + 530)
                    && !wcsnicmp(
                          (const wchar_t *)(v9 + qword_140087260 + 8),
                          v4,
                          *(unsigned int *)(v9 + qword_140087260 + 530))
                    && (v3 <= *(_DWORD *)(v9 + qword_140087260 + 530)
                     || !v4[*(unsigned int *)(v9 + qword_140087260 + 530)]) )
                  {
                    return &dword_140007230;
                  }
                  if ( ++v8 >= *(_DWORD *)qword_140087260 )
                    return 0i64;
                }
              }
            }
          }
        }
      }
    }
  }
  return 0i64;
}
// 140007120: using guessed type int dword_140007120;
// 140007230: using guessed type int dword_140007230;
// 140007234: using guessed type __int16 word_140007234;
// 140007240: using guessed type __int64 qword_140007240;
// 140087260: using guessed type __int64 qword_140087260;
// 14028E2E8: using guessed type __int64 qword_14028E2E8;
// 14028E2F0: using guessed type __int64 qword_14028E2F0;

//----- (000000014000389C) ----------------------------------------------------
void __fastcall sub_14000389C(void **a1, _QWORD *a2)
{
  void **v2; // rdi
  _QWORD *v3; // rbx
  void *v4; // rcx

  v2 = a1;
  v3 = a2;
  v4 = *a1;
  if ( v4 )
  {
    if ( *a2 )
    {
      ExFreePoolWithTag(v4, 0x34495753u);
      *v2 = 0i64;
      *v3 = 0i64;
    }
  }
}

//----- (00000001400038D8) ----------------------------------------------------
void __fastcall sub_1400038D8(_QWORD *a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // rbx
  _QWORD *v3; // rdi
  char *v4; // rax
  const char *v5; // r9
  unsigned __int64 v6; // rsi
  char *v7; // rax
  const char *v8; // r9
  int v9; // ST28_4
  __int64 v10; // [rsp+20h] [rbp-28h]
  __int64 v11; // [rsp+20h] [rbp-28h]
  unsigned int v12; // [rsp+50h] [rbp+8h]
  PVOID P; // [rsp+58h] [rbp+10h]

  v2 = a2;
  v3 = a1;
  if ( a2 )
    *a2 = 0i64;
  if ( a1 )
  {
    *a1 = 0i64;
    if ( a2 )
    {
      P = 0i64;
      v12 = 0;
      if ( sub_1400040A0((UNICODE_STRING *)&unk_140006280, (UNICODE_STRING *)L"&(", &P, &v12) )
      {
        v4 = strrchr("..\\..\\src\\swi_callout\\Loopback.c", 92);
        v5 = v4 + 1;
        if ( !v4 )
          v5 = "..\\..\\src\\swi_callout\\Loopback.c";
        LODWORD(v10) = 209;
        DbgPrintEx(77i64, 2i64, "[%s:%hu] Loopback ports string [%S...] len %lu...", v5, v10);
        sub_140003A50(P, v12, v3, v2);
        ExFreePoolWithTag(P, 0x32495753u);
        P = 0i64;
        v6 = 0i64;
        v12 = 0;
        if ( *v2 )
        {
          do
          {
            v7 = strrchr("..\\..\\src\\swi_callout\\Loopback.c", 92);
            v8 = v7 + 1;
            if ( !v7 )
              v8 = "..\\..\\src\\swi_callout\\Loopback.c";
            v9 = *(unsigned __int16 *)(*v3 + 2 * v6);
            LODWORD(v11) = 216;
            DbgPrintEx(77i64, 2i64, "[%s:%hu]  - port %hu", v8, v11);
            ++v6;
          }
          while ( v6 < *v2 );
        }
      }
    }
  }
}
// 1400062B8: using guessed type wchar_t asc_1400062B8[3];

//----- (0000000140003A24) ----------------------------------------------------
char __fastcall sub_140003A24(int a1, __int16 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int16 v4; // ax
  __int64 v5; // rcx

  if ( a1 != 2130706433 )
    return 0;
  v4 = 0;
  if ( !a4 )
    return 0;
  v5 = 0i64;
  while ( a2 != *(_WORD *)(a3 + 2 * v5) )
  {
    v5 = ++v4;
    if ( v4 >= a4 )
      return 0;
  }
  return 1;
}

//----- (0000000140003A50) ----------------------------------------------------
__int64 __fastcall sub_140003A50(_WORD *a1, unsigned int a2, _QWORD *a3, _QWORD *a4)
{
  __int64 v4; // rsi
  _QWORD *v5; // rbx
  unsigned int v6; // ebp
  _WORD *v7; // r14
  __int64 result; // rax
  PVOID v9; // rax
  const char *v10; // rbx
  char *v11; // rax
  __int64 v12; // [rsp+20h] [rbp-28h]
  __int64 v13; // [rsp+60h] [rbp+18h]

  *a3 = 0i64;
  v4 = (__int64)a4;
  *a4 = 0i64;
  v5 = a3;
  v13 = 0i64;
  v6 = a2;
  v7 = a1;
  result = sub_140003D28(a1, a2, 0i64, (__int64)&v13);
  if ( v13 )
  {
    v9 = ExAllocatePoolWithTag((POOL_TYPE)512, 2 * v13, 0x34495753u);
    *v5 = v9;
    if ( v9 )
    {
      result = sub_140003D28(v7, v6, v5, v4);
    }
    else
    {
      v10 = "..\\..\\src\\swi_callout\\Loopback.c";
      v11 = strrchr("..\\..\\src\\swi_callout\\Loopback.c", 92);
      if ( v11 )
        v10 = v11 + 1;
      LODWORD(v12) = 174;
      result = DbgPrintEx(
                 77i64,
                 0i64,
                 "[%s:%hu] ParseLoopbackPorts: ExAllocatePoolWithTag(NonPagedPool, %Iu, SWI4) FAILED",
                 v10,
                 v12);
    }
  }
  return result;
}

//----- (0000000140003B14) ----------------------------------------------------
char __fastcall sub_140003B14(__int64 a1, unsigned __int64 a2, __int64 a3, _WORD *a4)
{
  signed __int64 v4; // rsi
  _WORD *v5; // r15
  __int64 v6; // r14
  const char *v7; // rbx
  char *v8; // rax
  __int64 v9; // rbp
  __int64 v10; // rax
  unsigned __int16 v11; // cx
  const char *v12; // rbx
  char *v13; // rax
  char result; // al
  const char *v15; // rbx
  char *v16; // rax
  int v17; // ST40_4
  const char *v18; // rbx
  char *v19; // rax
  __int64 v20; // [rsp+20h] [rbp-58h]

  v4 = 0i64;
  v5 = a4;
  v6 = a1;
  if ( !a4 )
    return 0;
  if ( a2 > 5 )
  {
    v7 = "..\\..\\src\\swi_callout\\Loopback.c";
    v8 = strrchr("..\\..\\src\\swi_callout\\Loopback.c", 92);
    if ( v8 )
      v7 = v8 + 1;
    LODWORD(v20) = 52;
    DbgPrintEx(77i64, 0i64, "[%s:%hu] ...port [%.*S] not valid, more then 5 chars long: ignored", v7, v20);
    return 0;
  }
  v9 = 0i64;
  if ( !a2 )
  {
LABEL_17:
    v18 = "..\\..\\src\\swi_callout\\Loopback.c";
    v19 = strrchr("..\\..\\src\\swi_callout\\Loopback.c", 92);
    if ( v19 )
      v18 = v19 + 1;
    LODWORD(v20) = 75;
    DbgPrintEx(77i64, 0i64, "[%s:%hu] ...port [%.*S] (%Iu) not valid, out of range: ignored", v18, v20);
    return 0;
  }
  v10 = 0i64;
  do
  {
    v11 = *(_WORD *)(v6 + 2 * v10);
    if ( (unsigned __int16)(v11 - 48) > 9u )
    {
      v15 = "..\\..\\src\\swi_callout\\Loopback.c";
      v16 = strrchr("..\\..\\src\\swi_callout\\Loopback.c", 92);
      if ( v16 )
        v15 = v16 + 1;
      v17 = *(unsigned __int16 *)(v6 + 2 * v9);
      LODWORD(v20) = 66;
      DbgPrintEx(
        77i64,
        0i64,
        "[%s:%hu] temp port is %Iu, %Id along whole multistring, , non num char 0x%x[%C], viewing [%.*S]",
        v15,
        v20);
      return 0;
    }
    v9 = (unsigned int)(v9 + 1);
    v4 = v11 - 48 + 10 * v4;
    v10 = (unsigned int)v9;
  }
  while ( (unsigned int)v9 < a2 );
  if ( (unsigned __int64)(v4 - 1) > 0xFFFE )
    goto LABEL_17;
  v12 = "..\\..\\src\\swi_callout\\Loopback.c";
  v13 = strrchr("..\\..\\src\\swi_callout\\Loopback.c", 92);
  if ( v13 )
    v12 = v13 + 1;
  LODWORD(v20) = 79;
  DbgPrintEx(77i64, 2i64, "[%s:%hu] Bypass loopback port %Iu  ", v12, v20);
  result = 1;
  *v5 = v4;
  return result;
}

//----- (0000000140003D28) ----------------------------------------------------
__int64 __fastcall sub_140003D28(_WORD *a1, unsigned int a2, _QWORD *a3, __int64 a4)
{
  const char *v4; // rbx
  _QWORD *v5; // rdi
  __int64 v6; // r12
  unsigned __int64 v7; // rbp
  __int64 v8; // r14
  _WORD *v9; // r15
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // r13
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rdi
  unsigned __int64 v14; // rax
  _WORD *v15; // rcx
  signed int v16; // esi
  char *v17; // rax
  const char *v18; // r9
  char *v19; // rax
  const char *v20; // r9
  char *v21; // rax
  const char *v22; // r9
  char *v23; // rax
  __int64 result; // rax
  __int64 v25; // [rsp+20h] [rbp-78h]
  unsigned __int64 v26; // [rsp+40h] [rbp-58h]
  __int16 v27; // [rsp+A0h] [rbp+8h]
  unsigned int v28; // [rsp+A8h] [rbp+10h]
  _QWORD *v29; // [rsp+B0h] [rbp+18h]
  _QWORD *v30; // [rsp+B8h] [rbp+20h]

  v30 = (_QWORD *)a4;
  v29 = a3;
  v28 = a2;
  v4 = "..\\..\\src\\swi_callout\\Loopback.c";
  v5 = (_QWORD *)a4;
  v6 = (__int64)a1;
  v7 = 0i64;
  v8 = 0i64;
  v9 = a1;
  if ( *a1 )
  {
    v10 = a2;
    v26 = a2;
    v11 = 1i64;
    while ( 1 )
    {
      v12 = 2 * (((signed __int64)v9 - v6) >> 1);
      if ( v12 >= v10 )
      {
LABEL_28:
        v5 = v30;
        break;
      }
      v13 = (v10 - v12) >> 1;
      if ( v13 <= 0x7FFFFFFF )
      {
        v14 = (v10 - v12) >> 1;
        v15 = v9;
        v16 = 0;
        if ( v13 )
        {
          do
          {
            if ( !*v15 )
              break;
            ++v15;
            --v14;
          }
          while ( v14 );
          if ( v14 )
          {
            v7 = v13 - v14;
            goto LABEL_12;
          }
        }
        v7 = 0i64;
      }
      v16 = -1073741811;
LABEL_12:
      if ( v16 < 0 )
      {
        v21 = strrchr("..\\..\\src\\swi_callout\\Loopback.c", 92);
        v22 = v21 + 1;
        if ( !v21 )
          v22 = "..\\..\\src\\swi_callout\\Loopback.c";
        LODWORD(v25) = 128;
        DbgPrintEx(
          77i64,
          0i64,
          "[%s:%hu] WalkLoopbackPortsMultiString: RtlStringCchLengthW failed with status 0x%x multistring len %lu remaini"
          "ng characters %Iu",
          v22,
          v25);
        goto LABEL_28;
      }
      v27 = 0;
      if ( sub_140003B14((__int64)v9, v7, v6, &v27) )
      {
        v17 = strrchr("..\\..\\src\\swi_callout\\Loopback.c", 92);
        v18 = v17 + 1;
        if ( !v17 )
          v18 = "..\\..\\src\\swi_callout\\Loopback.c";
        LODWORD(v25) = 111;
        DbgPrintEx(77i64, 2i64, "[%s:%hu] ...valid", v18, v25);
        if ( v11 > 0x64 )
        {
          v19 = strrchr("..\\..\\src\\swi_callout\\Loopback.c", 92);
          v20 = v19 + 1;
          if ( !v19 )
            v20 = "..\\..\\src\\swi_callout\\Loopback.c";
          LODWORD(v25) = 114;
          DbgPrintEx(
            77i64,
            0i64,
            "[%s:%hu] More than 100 ports specified - the limit is 100, **ports after the 100th are ignored**. User must reconfigure.",
            v20,
            v25);
          goto LABEL_28;
        }
        ++v8;
        ++v11;
        if ( v29 && *v29 )
          *(_WORD *)(*v29 + 2 * v8 - 2) = v27;
      }
      v9 += v7 + 1;
      if ( 0 == *v9 )
        goto LABEL_28;
      v10 = v26;
    }
  }
  v23 = strrchr("..\\..\\src\\swi_callout\\Loopback.c", 92);
  if ( v23 )
    v4 = v23 + 1;
  LODWORD(v25) = 133;
  result = DbgPrintEx(77i64, 2i64, "[%s:%hu] %Iu valid bypass loopback ports specified in the registry", v4, v25);
  if ( v5 )
    *v5 = v8;
  return result;
}

//----- (0000000140003F50) ----------------------------------------------------
char __fastcall sub_140003F50(_DWORD *a1, unsigned int a2, void **a3, _DWORD *a4)
{
  _DWORD *v4; // r14
  void **v5; // rbx
  unsigned int v6; // esi
  _DWORD *v7; // rdi
  const char *v8; // rbx
  char *v9; // rax
  int v10; // ST28_4
  SIZE_T v12; // rdx
  const char *v13; // rbx
  char *v14; // rax
  int v15; // ST30_4
  int v16; // ST28_4
  PVOID v17; // rax
  const char *v18; // rbx
  char *v19; // rax
  int v20; // ST28_4
  __int64 v21; // [rsp+20h] [rbp-28h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( a1[1] != 7 )
  {
    v8 = "..\\..\\src\\swi_callout\\registry.c";
    v9 = strrchr("..\\..\\src\\swi_callout\\registry.c", 92);
    if ( v9 )
      v8 = v9 + 1;
    v10 = v7[1];
    LODWORD(v21) = 35;
    DbgPrintEx(77i64, 2i64, "[%s:%hu] CopyMultiStringBuffer KeyValueInformation->Type(%lu) != REG_MULTI_SZ", v8, v21);
    return 0;
  }
  v12 = (unsigned int)a1[3];
  if ( (signed int)v12 + a1[2] > v6 )
  {
    v13 = "..\\..\\src\\swi_callout\\registry.c";
    v14 = strrchr("..\\..\\src\\swi_callout\\registry.c", 92);
    if ( v14 )
      v13 = v14 + 1;
    v15 = v7[3];
    v16 = v7[2];
    LODWORD(v21) = 42;
    DbgPrintEx(
      77i64,
      2i64,
      "[%s:%hu] CopyMultiStringBuffer KeyValueInformation->DataOffset(%lu) + KeyValueInformation->DataLength(%lu) > size(%lu)",
      v13,
      v21);
    return 0;
  }
  v17 = ExAllocatePoolWithTag((POOL_TYPE)512, v12, 0x32495753u);
  if ( !v17 )
  {
    v18 = "..\\..\\src\\swi_callout\\registry.c";
    v19 = strrchr("..\\..\\src\\swi_callout\\registry.c", 92);
    if ( v19 )
      v18 = v19 + 1;
    v20 = v7[3];
    LODWORD(v21) = 51;
    DbgPrintEx(77i64, 2i64, "[%s:%hu] ExAllocatePoolWithTag failed for size %lu", v18, v21);
    return 0;
  }
  *v5 = v17;
  *v4 = v7[3];
  memmove(*v5, (char *)v7 + (unsigned int)v7[2], (unsigned int)v7[3]);
  return 1;
}

//----- (00000001400040A0) ----------------------------------------------------
char __fastcall sub_1400040A0(UNICODE_STRING *a1, UNICODE_STRING *a2, void **a3, _DWORD *a4)
{
  UNICODE_STRING *v4; // r15
  void **v5; // r13
  UNICODE_STRING *v6; // rsi
  _DWORD *v7; // rbx
  char v8; // di
  NTSTATUS v9; // eax
  NTSTATUS v10; // eax
  _DWORD *v11; // rax
  _DWORD *v12; // r14
  const char *v13; // rbx
  char *v14; // rax
  const char *v15; // rbx
  char *v16; // rax
  const char *v17; // rbx
  char *v18; // rax
  char *v19; // rax
  const char *v20; // rbx
  char *v21; // rax
  char *v22; // rax
  __int64 Length; // [rsp+20h] [rbp-60h]
  __int64 Lengtha; // [rsp+20h] [rbp-60h]
  __int64 Lengthb; // [rsp+20h] [rbp-60h]
  ULONG v27; // [rsp+40h] [rbp-40h]
  HANDLE KeyHandle; // [rsp+48h] [rbp-38h]
  OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+50h] [rbp-30h]
  ULONG ResultLength; // [rsp+B0h] [rbp+30h]

  v4 = a2;
  v5 = a3;
  v6 = a1;
  v7 = a4;
  memset(&ObjectAttributes.RootDirectory, 0, 0x28ui64);
  KeyHandle = (HANDLE)-1i64;
  v8 = 0;
  ObjectAttributes.Length = 48;
  ResultLength = 0;
  v27 = 0;
  ObjectAttributes.RootDirectory = 0i64;
  _mm_storeu_si128((__m128i *)&ObjectAttributes.SecurityDescriptor, (__m128i)0i64);
  ObjectAttributes.Attributes = 576;
  ObjectAttributes.ObjectName = v6;
  v9 = ZwOpenKey(&KeyHandle, 0x20019u, &ObjectAttributes);
  if ( v9 < 0 )
  {
    v20 = "..\\..\\src\\swi_callout\\registry.c";
    if ( v9 == -1073741772 )
    {
      v22 = strrchr("..\\..\\src\\swi_callout\\registry.c", 92);
      if ( v22 )
        v20 = v22 + 1;
      LODWORD(Length) = 144;
      DbgPrintEx(77i64, 2i64, "[%s:%hu] Registry key %wZ is not present.", v20, Length);
    }
    else
    {
      v21 = strrchr("..\\..\\src\\swi_callout\\registry.c", 92);
      if ( v21 )
        v20 = v21 + 1;
      LODWORD(Length) = 140;
      DbgPrintEx(77i64, 0i64, "[%s:%hu] ZwOpenKey(%wZ) failed status 0x%x", v20, Length);
    }
  }
  else
  {
    v10 = ZwQueryValueKey(KeyHandle, v4, KeyValueFullInformation, 0i64, 0, &ResultLength);
    if ( v10 == -1073741789 )
    {
      v11 = ExAllocatePoolWithTag((POOL_TYPE)512, ResultLength, 0x33495753u);
      v12 = v11;
      if ( v11 )
      {
        if ( ZwQueryValueKey(KeyHandle, v4, KeyValueFullInformation, v11, ResultLength, &v27) < 0 )
        {
          v13 = "..\\..\\src\\swi_callout\\registry.c";
          v14 = strrchr("..\\..\\src\\swi_callout\\registry.c", 92);
          if ( v14 )
            v13 = v14 + 1;
          LODWORD(Lengthb) = 111;
          DbgPrintEx(
            77i64,
            0i64,
            "[%s:%hu] ZwQueryValueKey(%wZ, %wZ,allocated buffer) failed status 0x%x",
            v13,
            Lengthb);
        }
        else
        {
          v8 = sub_140003F50(v12, v27, v5, v7);
        }
        ExFreePoolWithTag(v12, 0x33495753u);
      }
      else
      {
        v15 = "..\\..\\src\\swi_callout\\registry.c";
        v16 = strrchr("..\\..\\src\\swi_callout\\registry.c", 92);
        if ( v16 )
          v15 = v16 + 1;
        LODWORD(Lengtha) = 117;
        DbgPrintEx(77i64, 0i64, "[%s:%hu] ExAllocatePoolWithTag(NonPagedPool, %lu, SWI3) failed", v15, Lengtha);
      }
    }
    else
    {
      v17 = "..\\..\\src\\swi_callout\\registry.c";
      if ( v10 == -1073741772 )
      {
        v19 = strrchr("..\\..\\src\\swi_callout\\registry.c", 92);
        if ( v19 )
          v17 = v19 + 1;
        LODWORD(Lengtha) = 128;
        DbgPrintEx(77i64, 1i64, "[%s:%hu] Registry value %wZ %wZ is not present.", v17, Lengtha);
      }
      else
      {
        v18 = strrchr("..\\..\\src\\swi_callout\\registry.c", 92);
        if ( v18 )
          v17 = v18 + 1;
        LODWORD(Lengtha) = 124;
        DbgPrintEx(
          77i64,
          0i64,
          "[%s:%hu] ZwQueryValueKey (%wZ, %wZ, null...) returned unexpected status 0x%x not STATUS_BUFFER_TOO_SMALL as expected",
          v17,
          Lengtha);
      }
    }
    if ( KeyHandle != (HANDLE)-1i64 )
      ZwClose(KeyHandle);
  }
  return v8;
}

//----- (00000001400044E8) ----------------------------------------------------
__int64 sub_1400044E8()
{
  sub_140004798((__int64)&unk_140007080);
  return WdfVersionUnbind(&DestinationString, &unk_140007080, qword_14028F090);
}
// 140004816: using guessed type __int64 __fastcall WdfVersionUnbind(_QWORD, _QWORD, _QWORD);

//----- (0000000140004544) ----------------------------------------------------
__int64 __fastcall DriverEntry(__int64 a1, const UNICODE_STRING *a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdi
  __int64 result; // rax
  signed int v5; // ebx
  __int64 (*v6)(void); // rax

  v2 = (__int64)a2;
  v3 = a1;
  if ( !a1 )
    return sub_140001000(0i64, (__int64)a2);
  qword_14028F098 = a1;
  DestinationString.Buffer = (PWSTR)&unk_14028F0B0;
  *(_DWORD *)&DestinationString.Length = 34078720;
  RtlCopyUnicodeString(&DestinationString, a2);
  result = WdfVersionBind(v3, &DestinationString, &unk_140007080, &qword_14028F090);
  if ( (signed int)result >= 0 )
  {
    v5 = sub_140004700((__int64)&unk_140007080);
    if ( v5 < 0 || (v5 = sub_140004694(), v5 < 0) || (v5 = sub_140001000(v3, v2), v5 < 0) )
    {
      sub_1400044E8();
      result = (unsigned int)v5;
    }
    else
    {
      if ( *(_BYTE *)(qword_14028F090 + 48i64) )
      {
        v6 = qword_14028F088;
        if ( *(_QWORD *)(v3 + 104) )
          v6 = *(__int64 (**)(void))(v3 + 104);
        qword_14028F088 = v6;
        *(_QWORD *)(v3 + 104) = sub_14000466C;
      }
      else if ( *(_DWORD *)(qword_14028F090 + 8i64) & 2 )
      {
        qword_14028F0A0 = qword_14028E948;
        qword_14028E948 = (__int64)sub_140004664;
      }
      result = 0i64;
    }
  }
  return result;
}
// 140004664: using guessed type __int64 __fastcall sub_140004664();
// 140004810: using guessed type __int64 __fastcall WdfVersionBind(_QWORD, _QWORD, _QWORD, _QWORD);
// 14028E948: using guessed type __int64 qword_14028E948;
// 14028F088: using guessed type __int64 (*qword_14028F088)(void);
// 14028F098: using guessed type __int64 qword_14028F098;
// 14028F0A0: using guessed type __int64 qword_14028F0A0;

//----- (000000014000466C) ----------------------------------------------------
__int64 sub_14000466C()
{
  if ( qword_14028F088 && (char *)qword_14028F088 != (char *)sub_14000466C )
    qword_14028F088();
  return sub_1400044E8();
}
// 14028F088: using guessed type __int64 (*qword_14028F088)(void);

//----- (0000000140004694) ----------------------------------------------------
signed __int64 sub_140004694()
{
  __int64 (**v1)(void); // rbx

  if ( &unk_1400070D0 > &unk_1400070E0 )
    return 3221225595i64;
  if ( &unk_1400070E0 >= &unk_1400070E0 )
    return 0i64;
  v1 = (__int64 (**)(void))&qword_140007100;
  while ( *((_DWORD *)v1 - 8) == 40 )
  {
    if ( *v1 )
      *(v1 - 1) = (__int64 (*)(void))(*v1)();
    v1 += 5;
    if ( v1 - 4 >= (__int64 (**)(void))&unk_1400070E0 )
      return 0i64;
  }
  return 3221225476i64;
}
// 140007100: using guessed type __int64 qword_140007100;

//----- (0000000140004700) ----------------------------------------------------
__int64 __fastcall sub_140004700(__int64 a1)
{
  __int64 v1; // rdi
  __int64 result; // rax
  _QWORD *i; // rbx
  __int64 (__fastcall *v4)(_QWORD, _QWORD, _QWORD, _QWORD); // rax

  v1 = a1;
  result = 0i64;
  if ( &unk_1400070B0 > &unk_1400070C0 )
    return 3221225595i64;
  for ( i = &unk_1400070C0; i < (_QWORD *)&unk_1400070C0; i += 10 )
  {
    if ( *(_DWORD *)i != 80 )
      return 3221225476i64;
    v4 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))i[7];
    off_1400070C8 = i;
    if ( v4 )
      result = v4(WdfVersionBindClass, v1, qword_14028F090, i);
    else
      result = WdfVersionBindClass(v1, qword_14028F090, i);
    if ( (signed int)result < 0 )
      return result;
  }
  return result;
}
// 14000481C: using guessed type __int64 __fastcall WdfVersionBindClass(_QWORD, _QWORD, _QWORD);
// 1400070C8: using guessed type void *off_1400070C8;

//----- (0000000140004798) ----------------------------------------------------
void *__fastcall sub_140004798(__int64 a1)
{
  void *result; // rax
  _QWORD *v2; // rbx
  __int64 v3; // rdi
  __int64 (__fastcall *v4)(_QWORD, _QWORD, _QWORD, _QWORD); // rax

  result = off_1400070C8;
  v2 = &unk_1400070C0;
  v3 = a1;
  if ( off_1400070C8 != &unk_1400070B0 && &unk_1400070C0 <= off_1400070C8 )
  {
    do
    {
      v4 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))v2[8];
      if ( v4 )
        result = (void *)v4(WdfVersionUnbindClass, v3, qword_14028F090, v2);
      else
        result = (void *)WdfVersionUnbindClass(v3, qword_14028F090, v2);
      v2 += 10;
    }
    while ( v2 <= off_1400070C8 );
  }
  return result;
}
// 140004822: using guessed type __int64 __fastcall WdfVersionUnbindClass(_QWORD, _QWORD, _QWORD);
// 1400070C8: using guessed type void *off_1400070C8;

// ALL OK, 46 function(s) have been successfully decompiled
